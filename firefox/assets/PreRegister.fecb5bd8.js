var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { d as SvelteComponent, i as init, e as safe_not_equal, p as element, N as set_style, q as insert, F as noop, u as detach, O as create_slot, E as attr, P as update_slot_base, Q as get_all_dirty_from_scope, R as get_slot_changes, t as transition_in, g as transition_out, o as space, T as toggle_class, U as append, Y as listen, Z as group_outros, _ as check_outros, $ as run_all, k as component_subscribe, a0 as yw_nav_visible, a1 as yw_blur, a2 as compute_slots, a3 as getContext, a4 as createEventDispatcher, a5 as onMount, x as set_store_value, a6 as bubble, l as binding_callbacks, a7 as src_url_equal, D as text, a8 as SX_ICON_ADD, a9 as set_data, aa as create_out_transition, ab as empty, f as create_component, m as mount_component, ac as get_spread_update, ad as get_spread_object, j as destroy_component, r as add_flush_callback, ae as set_input_value, af as yw_search, ag as yw_cancel_search, ah as yw_thread, ai as yw_menu_vendor, aj as yw_overlay_network, ak as yw_chain, al as yw_chain_ref, am as yw_overlay_account, an as yw_account, ao as assign, ap as PfpDisplay, n as bind, aq as Close, M as qs, ar as handle_promise, as as Chains, at as update_await_block_branch, B as Accounts, au as destroy_each, av as Row, A as ActionsLine, aw as acceptable, ax as Field, ay as NL_PASSPHRASE_MINIMUM, az as NL_PASSPHRASE_MAXIMUM, V as Vault, aA as ATU8_DUMMY_PHRASE, aB as ATU8_DUMMY_VECTOR, K as register$1, aC as AlreadyRegisteredError, aD as InvalidPassphraseError, L as login, aE as add_render_callback, aF as create_bidirectional_transition, aG as slide, aH as yw_owner, aI as load_pfps, J as ode, aJ as Entities, aK as StarSelect, aL as yw_network_active, aM as BigNumber, aN as XT_MINUTES, aO as CoinGecko, aP as format_amount, y as yw_account_ref, aQ as oderac, aR as yw_family, aS as subscribe_store, aT as onDestroy, aU as Agents, aV as Address, aW as Select, I as yw_navigator, aX as format_fiat, aY as SX_ICON_DROPDOWN, aZ as fold, a_ as SX_ICON_INFO, C as CheckboxField, a$ as SX_ICON_ADD$1, b0 as cubicOut, b1 as Portrait, b2 as SI_STORE_CHAINS, b3 as oderom, b4 as syserr, b5 as popup_receive, b6 as open_external_link, b7 as forever, b8 as Info, b9 as InlineTags, ba as SubHeader, bb as setContext, bc as afterUpdate, bd as writable, be as tick, bf as Pfps, bg as F_NOOP, bh as ofe, bi as ContactAgentType, bj as R_BECH32, bk as proper, bl as SX_ICON_EDIT, bm as SX_ICON_DELETE, bn as quintOut, bo as Apps, bp as Networks, bq as svg_element, br as yw_overscroll_pct, bs as yw_popup, bt as HtmlTag, bu as yw_page, bv as yw_menu_expanded, bw as yw_notifications, bx as yw_nav_collapsed, by as yw_header_props, bz as yw_progress, bA as SX_ICON_CLOSE, bB as yw_network, G as global_receive, bC as dd, bD as objects_might_differ, bE as getAllContexts, bF as yw_network_ref, bG as once_store_updates, bH as timeout, bI as UnregisteredError, bJ as RecoverableVaultError, bK as CorruptedVaultError } from "./mem.6e57882d.js";
var global = /* @__PURE__ */ (() => ".font-family_mono {\n  font-family: 'PT Mono';\n  white-space: pre;\n}\n.hide-scrollbar {\n  scrollbar-width: none;\n}\n.hide-scrollbar::-webkit-scrollbar {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-track {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-thumb {\n  background-color: rgba(0, 0, 0, 0.2);\n}\n:root {\n  --app-window-width: 360px;\n  --app-window-height: 640px;\n  --app-icon-diameter: 46px;\n  --app-tag-diameter: 10px;\n  --app-max-width: 700px;\n  --ui-row-height: 48px;\n  --ui-padding: 16px;\n  --ui-border-radius: 8px;\n  --inline-padding: 12px;\n  --proxy-icon-diameter: var(--icon-diameter, 100%);\n  --theme-color-light: #f7f7f7;\n  --theme-color-yellow: #ffb61a;\n  --theme-color-orange: #f85931;\n  --theme-color-sky: #1976d2;\n  --theme-color-grass: #3a6f16;\n  --theme-color-graymed: #96a0ac;\n  --theme-color-graydark: #35383d;\n  --theme-color-dark: #0f1317;\n  --theme-color-black: #000000;\n  --theme-color-graysoft: #757575;\n  --theme-color-slime: #a0f831;\n  --theme-color-red: #ff0000;\n  --theme-color-green: #23af00;\n  --theme-color-blue: #0094ff;\n  --theme-color-bg: var(--theme-color-dark);\n  --theme-color-primary: var(--theme-color-yellow);\n  --theme-color-border: #35383d;\n  --theme-color-input-bg: var(--theme-color-graydark);\n  --theme-color-text-light: var(--theme-color-light);\n  --theme-color-text-dark: var(--theme-color-black);\n  --theme-color-text-med: var(--theme-color-graymed);\n  --theme-color-caution: var(--theme-color-orange);\n  /* ease-in corresponds to cubic-bezier(0.42, 0, 1.0, 1.0) */\n  --ease-in-quad: cubic-bezier(0.55, 0.085, 0.68, 0.53);\n  --ease-in-cubic: cubic-bezier(0.55, 0.055, 0.675, 0.19);\n  --ease-in-quart: cubic-bezier(0.895, 0.03, 0.685, 0.22);\n  --ease-in-quint: cubic-bezier(0.755, 0.05, 0.855, 0.06);\n  --ease-in-expo: cubic-bezier(0.95, 0.05, 0.795, 0.035);\n  --ease-in-circ: cubic-bezier(0.6, 0.04, 0.98, 0.335);\n  /* ease-out corresponds to cubic-bezier(0, 0, 0.58, 1.0) */\n  --ease-out-quad: cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  --ease-out-cubic: cubic-bezier(0.215, 0.61, 0.355, 1);\n  --ease-out-quart: cubic-bezier(0.165, 0.84, 0.44, 1);\n  --ease-out-quint: cubic-bezier(0.23, 1, 0.32, 1);\n  --ease-out-expo: cubic-bezier(0.19, 1, 0.22, 1);\n  --ease-out-circ: cubic-bezier(0.075, 0.82, 0.165, 1);\n  /* ease-in-out corresponds to cubic-bezier(0.42, 0, 0.58, 1.0) */\n  --ease-in-out-quad: cubic-bezier(0.455, 0.03, 0.515, 0.955);\n  --ease-in-out-cubic: cubic-bezier(0.645, 0.045, 0.355, 1);\n  --ease-in-out-quart: cubic-bezier(0.77, 0, 0.175, 1);\n  --ease-in-out-quint: cubic-bezier(0.86, 0, 0.07, 1);\n  --ease-in-out-expo: cubic-bezier(1, 0, 0, 1);\n  --ease-in-out-circ: cubic-bezier(0.785, 0.135, 0.15, 0.86);\n  /* custom easing */\n  --ease-out-quick: cubic-bezier(0, 1, 0, 1);\n}\nhtml,\nbody {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  width: var(--app-window-width);\n  height: var(--app-window-height);\n}\nbody {\n  background-color: black;\n  color: white;\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n  /* overflow: hidden; */\n  font-family: 'Poppins', sans-serif;\n}\n.global_pfp {\n  display: inline-block;\n}\n.global_pfp > img {\n  width: 100%;\n  height: 100%;\n}\n.global_pfp.square svg,\n.global_pfp.square img,\n.global_pfp.square .icon-dom {\n  border-radius: 20%;\n}\n/*\n###############################################\n*/\n.icon {\n  --icon-diameter: var(--proxy-icon-diameter);\n  --button-diameter: var(--icon-diameter);\n  --icon-color: var(--theme-color-text-light);\n  display: inline-block;\n  width: var(--button-diameter);\n  height: var(--button-diameter);\n  border-radius: var(--button-diameter);\n  text-align: center;\n  outline: 1px solid transparent;\n  color: var(--icon-color);\n  fill: var(--icon-color);\n}\n.icon.pfp {\n  display: inline-flex;\n  overflow: hidden;\n  border-radius: var(--icon-diameter);\n  outline: 2px solid var(--theme-color-border);\n}\n.icon.pfp.square {\n  border-radius: 20%;\n}\n.icon > .group {\n  position: relative;\n  display: inline-flex;\n  width: var(--icon-diameter);\n  height: var(--icon-diameter);\n}\n.icon > .group > .platform {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n.icon > .group > .platform > svg,\n.icon > .group > .platform > img,\n.icon > .group > .platform > picture,\n.icon > .group > .platform > .icon-dom {\n  width: var(--icon-diameter);\n  height: var(--icon-diameter);\n  object-fit: cover;\n}\n.icon > .group > .foreground {\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  height: calc(var(--icon-diameter) / 2);\n}\n.icon > .group > .foreground > svg,\n.icon > .group > .foreground > img,\n.icon > .group > .foreground > picture,\n.icon > .group > .foreground > .icon-dom {\n  width: calc(var(--icon-diameter) / 2);\n  height: calc(var(--icon-diameter) / 2);\n  margin-top: calc(50% - (var(--icon-diameter) / 4));\n  object-fit: cover;\n  box-shadow: 0px 0px 6px 3px black;\n}\n.icon > .group > .pair > svg,\n.icon > .group > .pair > img,\n.icon > .group > .pair > picture,\n.icon > .group > .pair > .icon-dom {\n  width: calc(var(--icon-diameter) / 2);\n  height: calc(var(--icon-diameter) / 2);\n  margin-top: calc(50% - (var(--icon-diameter) / 4));\n  object-fit: cover;\n}\n.warning {\n  color: var(--theme-color-orange);\n}\n.alertspan {\n  color: #f85931;\n}\n.viewport > section.slid {\n  transition-duration: 0.375s;\n  transition-timing-function: var(--ease-out-cubic);\n}\n.frozen,\n.frozen * {\n  pointer-events: none;\n  user-select: none;\n}\na {\n  color: var(--theme-color-primary);\n  text-decoration: none;\n}\na:hover {\n  text-decoration: underline;\n}\na:visited {\n  color: var(--theme-color-primary);\n}\nhr {\n  margin: var(--ui-padding) 0;\n  border: none;\n  border-top: 1px solid var(--theme-color-border);\n}\n::-webkit-scrollbar {\n  width: 12px;\n}\n::-webkit-scrollbar-track {\n  display: none;\n}\n::-webkit-scrollbar-thumb {\n  background-color: rgba(0, 0, 0, 0.6);\n}\n* {\n  scrollbar-width: 12px;\n  scrollbar-track-color: transparent;\n  scrollbar-face-color: rgba(0, 0, 0, 0.6);\n}\n.viewport .display_none {\n  display: none !important;\n}\n.viewport .align-self_center {\n  align-self: center !important;\n}\n.viewport pointer-events_none {\n  pointer-events: none !important;\n}\n.viewport .visibility_hidden {\n  visibility: hidden !important;\n}\n.viewport .text-align_center {\n  text-align: center !important;\n}\n.viewport .text-align_right {\n  text-align: right !important;\n}\n.viewport .border-bottom_1px-border {\n  border-bottom: 1px solid var(--theme-color-border);\n}\n")();
function create_fragment$M(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      set_style(span, "display", "none");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
class Blank extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$M, safe_not_equal, {});
  }
}
const get_help_slot_changes = (dirty) => ({});
const get_help_slot_context = (ctx) => ({});
function create_if_block$i(ctx) {
  let div;
  let current;
  const help_slot_template = ctx[21].help;
  const help_slot = create_slot(help_slot_template, ctx, ctx[20], get_help_slot_context);
  return {
    c() {
      div = element("div");
      if (help_slot)
        help_slot.c();
      attr(div, "class", "display_none");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (help_slot) {
        help_slot.m(div, null);
      }
      ctx[23](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (help_slot) {
        if (help_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(help_slot, help_slot_template, ctx2, ctx2[20], !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(help_slot_template, ctx2[20], dirty, get_help_slot_changes), get_help_slot_context);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(help_slot, local);
      current = true;
    },
    o(local) {
      transition_out(help_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (help_slot)
        help_slot.d(detaching);
      ctx[23](null);
    }
  };
}
function create_fragment$L(ctx) {
  let div;
  let form_1;
  let t;
  let form_1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[21].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
  let if_block = "help" in ctx[10] && create_if_block$i(ctx);
  return {
    c() {
      div = element("div");
      form_1 = element("form");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(form_1, "class", form_1_class_value = "screen " + ctx[1] + " svelte-re7ihy");
      attr(form_1, "data-s2-exit", ctx[9]);
      attr(form_1, "style", ctx[3]);
      attr(form_1, "autocomplete", "off");
      toggle_class(form_1, "flex", true);
      toggle_class(form_1, "scroll", true);
      toggle_class(form_1, "nav", ctx[7]);
      toggle_class(form_1, "progress", ctx[0]);
      toggle_class(form_1, "transparent", ctx[2]);
      toggle_class(form_1, "sublimate", false);
      toggle_class(form_1, "blur", ctx[6]);
      attr(div, "class", "bounds svelte-re7ihy");
      toggle_class(div, "slides", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form_1);
      if (default_slot) {
        default_slot.m(form_1, null);
      }
      append(form_1, t);
      if (if_block)
        if_block.m(form_1, null);
      ctx[24](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(form_1, "submit", submit_handler_1),
          listen(form_1, "submit", ctx[22])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[20], !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null), null);
        }
      }
      if ("help" in ctx2[10]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$i(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(form_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 2 && form_1_class_value !== (form_1_class_value = "screen " + ctx2[1] + " svelte-re7ihy")) {
        attr(form_1, "class", form_1_class_value);
      }
      if (!current || dirty & 8) {
        attr(form_1, "style", ctx2[3]);
      }
      if (dirty & 2) {
        toggle_class(form_1, "flex", true);
      }
      if (dirty & 2) {
        toggle_class(form_1, "scroll", true);
      }
      if (dirty & 130) {
        toggle_class(form_1, "nav", ctx2[7]);
      }
      if (dirty & 3) {
        toggle_class(form_1, "progress", ctx2[0]);
      }
      if (dirty & 6) {
        toggle_class(form_1, "transparent", ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(form_1, "sublimate", false);
      }
      if (dirty & 66) {
        toggle_class(form_1, "blur", ctx2[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const submit_handler_1 = (d_event) => void d_event.preventDefault();
function instance$I($$self, $$props, $$invalidate) {
  let $yw_nav_visible;
  let $yw_blur;
  component_subscribe($$self, yw_nav_visible, ($$value) => $$invalidate(25, $yw_nav_visible = $$value));
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(6, $yw_blur = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { nav = false } = $$props;
  const b_nav = nav;
  let { debug = "" } = $$props;
  let { progress = null } = $$props;
  let { full = false } = $$props;
  let { keyed = false } = $$props;
  let { classNames = "" } = $$props;
  const k_page = getContext("page");
  let { leaves = false } = $$props;
  let { swipes = false } = $$props;
  let { root = k_page.index === 0 } = $$props;
  let { slides = !leaves && !swipes && !root } = $$props;
  const b_slides = slides;
  let { form = false } = $$props;
  let { transparent = false } = $$props;
  let dm_screen;
  let dm_help = null;
  const si_exit = leaves ? "leaves" : swipes ? "swipes" : "";
  createEventDispatcher();
  onMount(() => {
    if (!k_page) {
      console.warn(`${debug || "unknown"} Screen missing page context`);
    } else {
      k_page.on({
        focus() {
          set_store_value(yw_nav_visible, $yw_nav_visible = b_nav, $yw_nav_visible);
        }
      });
    }
    if (keyed) {
      let x_scroll_top = 0;
      new MutationObserver(async (a_mutations) => {
        if (a_mutations[0]?.addedNodes.length) {
          try {
            x_scroll_top = dm_screen.scrollTop;
          } catch (e_null) {
          }
        } else if (a_mutations[0]?.removedNodes.length) {
          if (dm_screen) {
            $$invalidate(4, dm_screen.scrollTop = x_scroll_top, dm_screen);
          }
        }
      }).observe(dm_screen, { childList: true });
    }
  });
  let { style = "" } = $$props;
  function submit_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_help = $$value;
      $$invalidate(5, dm_help);
    });
  }
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_screen = $$value;
      $$invalidate(4, dm_screen);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("nav" in $$props2)
      $$invalidate(11, nav = $$props2.nav);
    if ("debug" in $$props2)
      $$invalidate(12, debug = $$props2.debug);
    if ("progress" in $$props2)
      $$invalidate(0, progress = $$props2.progress);
    if ("full" in $$props2)
      $$invalidate(13, full = $$props2.full);
    if ("keyed" in $$props2)
      $$invalidate(14, keyed = $$props2.keyed);
    if ("classNames" in $$props2)
      $$invalidate(1, classNames = $$props2.classNames);
    if ("leaves" in $$props2)
      $$invalidate(15, leaves = $$props2.leaves);
    if ("swipes" in $$props2)
      $$invalidate(16, swipes = $$props2.swipes);
    if ("root" in $$props2)
      $$invalidate(17, root = $$props2.root);
    if ("slides" in $$props2)
      $$invalidate(18, slides = $$props2.slides);
    if ("form" in $$props2)
      $$invalidate(19, form = $$props2.form);
    if ("transparent" in $$props2)
      $$invalidate(2, transparent = $$props2.transparent);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  return [
    progress,
    classNames,
    transparent,
    style,
    dm_screen,
    dm_help,
    $yw_blur,
    b_nav,
    b_slides,
    si_exit,
    $$slots,
    nav,
    debug,
    full,
    keyed,
    leaves,
    swipes,
    root,
    slides,
    form,
    $$scope,
    slots,
    submit_handler2,
    div_binding,
    form_1_binding
  ];
}
class Screen extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$L, safe_not_equal, {
      nav: 11,
      debug: 12,
      progress: 0,
      full: 13,
      keyed: 14,
      classNames: 1,
      leaves: 15,
      swipes: 16,
      root: 17,
      slides: 18,
      form: 19,
      transparent: 2,
      style: 3
    });
  }
}
function create_fragment$K(ctx) {
  let picture;
  let source;
  let t;
  let img;
  let img_src_value;
  let mounted;
  let dispose;
  return {
    c() {
      picture = element("picture");
      source = element("source");
      t = space();
      img = element("img");
      attr(source, "srcset", ctx[3]);
      attr(source, "media", "(min-resolution: 2dppx)");
      attr(img, "alt", ctx[1]);
      if (!src_url_equal(img.src, img_src_value = ctx[2]))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-5d3u97");
      attr(picture, "class", "no-margin logo svelte-5d3u97");
      set_style(picture, "width", ctx[0] + "px");
      set_style(picture, "height", ctx[0] + "px");
    },
    m(target, anchor) {
      insert(target, picture, anchor);
      append(picture, source);
      append(picture, t);
      append(picture, img);
      if (!mounted) {
        dispose = listen(picture, "click", ctx[6]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(picture);
      mounted = false;
      dispose();
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let { dim } = $$props;
  const x_dim = dim;
  let { alt = "StarShell logo" } = $$props;
  const s_alt = alt;
  const f_src = (x) => `/media/vendor/logo-${x}px.png`;
  const sr_default = f_src(x_dim);
  const sr_double = f_src(x_dim * 2);
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("dim" in $$props2)
      $$invalidate(4, dim = $$props2.dim);
    if ("alt" in $$props2)
      $$invalidate(5, alt = $$props2.alt);
  };
  return [x_dim, s_alt, sr_default, sr_double, dim, alt, click_handler2];
}
class StarShellLogo extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$K, safe_not_equal, { dim: 4, alt: 5 });
  }
}
const get_rows_slot_changes = (dirty) => ({});
const get_rows_slot_context = (ctx) => ({});
function create_fragment$J(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t0;
  let t1;
  let button;
  let span0;
  let t2;
  let span1;
  let t4;
  let div1;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  const rows_slot_template = ctx[4].rows;
  const rows_slot = create_slot(rows_slot_template, ctx, ctx[3], get_rows_slot_context);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(ctx[1]);
      t1 = space();
      button = element("button");
      span0 = element("span");
      t2 = space();
      span1 = element("span");
      span1.textContent = "Add New";
      t4 = space();
      div1 = element("div");
      if (rows_slot)
        rows_slot.c();
      attr(h3, "class", "svelte-1f5uzt4");
      attr(span0, "class", "icon svelte-1f5uzt4");
      attr(span1, "class", "text");
      attr(button, "class", "pill add-new svelte-1f5uzt4");
      attr(div0, "class", "top svelte-1f5uzt4");
      attr(div1, "class", "rows svelte-1f5uzt4");
      attr(div2, "class", "overlay select svelte-1f5uzt4");
      attr(div3, "class", "cancel svelte-1f5uzt4");
      toggle_class(div3, "showing", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(h3, t0);
      append(div0, t1);
      append(div0, button);
      append(button, span0);
      span0.innerHTML = SX_ICON_ADD;
      append(button, t2);
      append(button, span1);
      append(div2, t4);
      append(div2, div1);
      if (rows_slot) {
        rows_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div3, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 2)
        set_data(t0, ctx2[1]);
      if (rows_slot) {
        if (rows_slot.p && (!current || dirty & 8)) {
          update_slot_base(rows_slot, rows_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(rows_slot_template, ctx2[3], dirty, get_rows_slot_changes), get_rows_slot_context);
        }
      }
      if (dirty & 4) {
        toggle_class(div3, "showing", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rows_slot, local);
      if (div2_outro)
        div2_outro.end(1);
      current = true;
    },
    o(local) {
      transition_out(rows_slot, local);
      div2_outro = create_out_transition(div2, pause, {});
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (rows_slot)
        rows_slot.d(detaching);
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function pause(dm, gc) {
  return { duration: 200 };
}
function instance$G($$self, $$props, $$invalidate) {
  let $yw_blur;
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(6, $yw_blur = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { open = true } = $$props;
  let b_showing = false;
  setTimeout(() => {
    $$invalidate(2, b_showing = true);
  }, 10);
  const click_handler2 = () => {
    $$invalidate(2, b_showing = false);
    $$invalidate(0, open = false);
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      set_store_value(yw_blur, $yw_blur = open, $yw_blur);
    }
  };
  return [open, title, b_showing, $$scope, slots, click_handler2];
}
class OverlaySelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$J, safe_not_equal, { title: 1, open: 0 });
  }
}
var SX_ICON_ARROW_LEFT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-arrow-left-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-arrow-left-fg" d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"/>\n</svg>\n';
var SX_ICON_SEARCH = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-search-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-search-fg" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n</svg>\n';
function get_each_context$b(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[49] = list[i][0];
  child_ctx[50] = list[i][1];
  return child_ctx;
}
function create_if_block_10(ctx) {
  let starshelllogo;
  let current;
  starshelllogo = new StarShellLogo({
    props: {
      dim: 48,
      alt: "Click to view general status"
    }
  });
  starshelllogo.$on("click", ctx[34]);
  return {
    c() {
      create_component(starshelllogo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starshelllogo, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starshelllogo, detaching);
    }
  };
}
function create_if_block_9(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "class", "back svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_ARROW_LEFT;
      if (!mounted) {
        dispose = listen(span, "click", ctx[33]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7(ctx) {
  let span;
  let t1;
  let if_block_anchor;
  let if_block = ctx[17] && create_if_block_8(ctx);
  return {
    c() {
      span = element("span");
      span.textContent = `${ctx[16]}`;
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "name svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[17])
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_8(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `- ${ctx[17]}`;
      attr(span, "class", "symbol svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_4$2(ctx) {
  let span;
  let previous_key = ctx[6];
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block_1$1(ctx);
  let if_block = ctx[5] && create_if_block_5$1(ctx);
  return {
    c() {
      span = element("span");
      key_block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "network svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      key_block.m(span, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[35]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64 && safe_not_equal(previous_key, previous_key = ctx2[6])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_1$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(span, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      key_block.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block_1$1(ctx) {
  let pfpdisplay;
  let current;
  const pfpdisplay_spread_levels = [{ resource: ctx[6] }, ctx[20](false)];
  let pfpdisplay_props = {};
  for (let i = 0; i < pfpdisplay_spread_levels.length; i += 1) {
    pfpdisplay_props = assign(pfpdisplay_props, pfpdisplay_spread_levels[i]);
  }
  pfpdisplay = new PfpDisplay({ props: pfpdisplay_props });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = dirty[0] & 1048640 ? get_spread_update(pfpdisplay_spread_levels, [
        dirty[0] & 64 && { resource: ctx2[6] },
        dirty[0] & 1048576 && get_spread_object(ctx2[20](false))
      ]) : {};
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_5$1(ctx) {
  let overlayselect;
  let updating_open;
  let current;
  function overlayselect_open_binding(value) {
    ctx[37](value);
  }
  let overlayselect_props = {
    title: "Switch Network",
    $$slots: { rows: [create_rows_slot_1] },
    $$scope: { ctx }
  };
  if (ctx[5] !== void 0) {
    overlayselect_props.open = ctx[5];
  }
  overlayselect = new OverlaySelect({ props: overlayselect_props });
  binding_callbacks.push(() => bind(overlayselect, "open", overlayselect_open_binding));
  return {
    c() {
      create_component(overlayselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayselect_changes = {};
      if (dirty[0] & 160 | dirty[1] & 4194304) {
        overlayselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty[0] & 32) {
        updating_open = true;
        overlayselect_changes.open = ctx2[5];
        add_flush_callback(() => updating_open = false);
      }
      overlayselect.$set(overlayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayselect, detaching);
    }
  };
}
function create_catch_block_1$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[48].entries();
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 160) {
        each_value = ctx2[48].entries();
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$b(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$b(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_6(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "overlay-select icon svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_right_slot$1(ctx) {
  let t;
  let if_block = ctx[7] === ctx[49] && create_if_block_6();
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[7] === ctx2[49]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_6();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$b(ctx) {
  let row;
  let current;
  function click_handler_3() {
    return ctx[36](ctx[49]);
  }
  row = new Row({
    props: {
      resource: ctx[50],
      detail: "Default Provider",
      $$slots: { right: [create_right_slot$1] },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_3);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 128 | dirty[1] & 4194304) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_rows_slot_1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1$1,
    then: create_then_block_1$1,
    catch: create_catch_block_1$1,
    value: 48,
    blocks: [, , ,]
  };
  handle_promise(Chains.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block_2$5(ctx) {
  let span;
  let previous_key = ctx[9];
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block$2(ctx);
  let if_block = ctx[8] && create_if_block_3$2(ctx);
  return {
    c() {
      span = element("span");
      key_block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "account svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      key_block.m(span, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[38]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512 && safe_not_equal(previous_key, previous_key = ctx2[9])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$2(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(span, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      key_block.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block$2(ctx) {
  let pfpdisplay;
  let current;
  const pfpdisplay_spread_levels = [{ resource: ctx[9] }, ctx[20](true)];
  let pfpdisplay_props = {};
  for (let i = 0; i < pfpdisplay_spread_levels.length; i += 1) {
    pfpdisplay_props = assign(pfpdisplay_props, pfpdisplay_spread_levels[i]);
  }
  pfpdisplay = new PfpDisplay({ props: pfpdisplay_props });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = dirty[0] & 1049088 ? get_spread_update(pfpdisplay_spread_levels, [
        dirty[0] & 512 && { resource: ctx2[9] },
        dirty[0] & 1048576 && get_spread_object(ctx2[20](true))
      ]) : {};
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_3$2(ctx) {
  let overlayselect;
  let updating_open;
  let current;
  function overlayselect_open_binding_1(value) {
    ctx[39](value);
  }
  let overlayselect_props = {
    title: "Switch Account",
    $$slots: { rows: [create_rows_slot] },
    $$scope: { ctx }
  };
  if (ctx[8] !== void 0) {
    overlayselect_props.open = ctx[8];
  }
  overlayselect = new OverlaySelect({ props: overlayselect_props });
  binding_callbacks.push(() => bind(overlayselect, "open", overlayselect_open_binding_1));
  return {
    c() {
      create_component(overlayselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayselect_changes = {};
      if (dirty[1] & 4194304) {
        overlayselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty[0] & 256) {
        updating_open = true;
        overlayselect_changes.open = ctx2[8];
        add_flush_callback(() => updating_open = false);
      }
      overlayselect.$set(overlayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayselect, detaching);
    }
  };
}
function create_catch_block$b(ctx) {
  return { c: noop, m: noop, d: noop };
}
function create_then_block$b(ctx) {
  return { c: noop, m: noop, d: noop };
}
function create_pending_block$b(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_rows_slot(ctx) {
  let await_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$b,
    then: create_then_block$b,
    catch: create_catch_block$b,
    value: 47
  };
  handle_promise(Accounts.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block_1$9(ctx) {
  let close;
  let current;
  close = new Close({});
  close.$on("click", ctx[40]);
  return {
    c() {
      create_component(close.$$.fragment);
    },
    m(target, anchor) {
      mount_component(close, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(close, detaching);
    }
  };
}
function create_if_block$h(ctx) {
  let div;
  let input;
  let t;
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      span = element("span");
      attr(input, "type", "text");
      input.autofocus = ctx[0];
      attr(input, "placeholder", "Search anything: token, account, contact, txn...");
      attr(span, "class", "action svelte-1fcz7ql");
      attr(div, "class", "search svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[3]);
      ctx[42](input);
      append(div, t);
      append(div, span);
      span.innerHTML = SX_ICON_SEARCH;
      if (ctx[0])
        input.focus();
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[41]),
          listen(input, "input", ctx[22])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1) {
        input.autofocus = ctx2[0];
      }
      if (dirty[0] & 8 && input.value !== ctx2[3]) {
        set_input_value(input, ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[42](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$I(ctx) {
  let div3;
  let div2;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span0;
  let div0;
  let t1;
  let div1;
  let t3;
  let span2;
  let span1;
  let t4;
  let t5;
  let t6;
  let current;
  const if_block_creators = [create_if_block_9, create_if_block_10];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[10])
      return 0;
    if (!ctx2[11] && !ctx2[12])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[16] && create_if_block_7(ctx);
  let if_block2 = ctx[14] && create_if_block_4$2(ctx);
  let if_block3 = ctx[13] && create_if_block_2$5(ctx);
  let if_block4 = ctx[11] && create_if_block_1$9(ctx);
  let if_block5 = ctx[15] && create_if_block$h(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span0 = element("span");
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      div1.textContent = `${ctx[18]}`;
      t3 = space();
      span2 = element("span");
      span1 = element("span");
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (if_block5)
        if_block5.c();
      attr(div0, "class", "title svelte-1fcz7ql");
      attr(div1, "class", "subtitle svelte-1fcz7ql");
      attr(span0, "class", "main svelte-1fcz7ql");
      attr(span1, "class", "cluster svelte-1fcz7ql");
      attr(span2, "class", "right svelte-1fcz7ql");
      toggle_class(span2, "heightless", !ctx[14] && ctx[11]);
      attr(div2, "class", "top svelte-1fcz7ql");
      attr(div3, "class", "header svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      append(div2, t0);
      append(div2, span0);
      append(span0, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append(span0, t1);
      append(span0, div1);
      append(div2, t3);
      append(div2, span2);
      append(span2, span1);
      if (if_block2)
        if_block2.m(span1, null);
      append(span1, t4);
      if (if_block3)
        if_block3.m(span1, null);
      append(span2, t5);
      if (if_block4)
        if_block4.m(span2, null);
      append(div3, t6);
      if (if_block5)
        if_block5.m(div3, null);
      ctx[43](div3);
      current = true;
    },
    p(ctx2, dirty) {
      if (if_block0)
        if_block0.p(ctx2, dirty);
      if (ctx2[16])
        if_block1.p(ctx2, dirty);
      if (ctx2[14])
        if_block2.p(ctx2, dirty);
      if (ctx2[13])
        if_block3.p(ctx2, dirty);
      if (ctx2[11])
        if_block4.p(ctx2, dirty);
      if (ctx2[15])
        if_block5.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      ctx[43](null);
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let $yw_search;
  let $yw_cancel_search;
  let $yw_thread;
  let $yw_menu_vendor;
  let $yw_overlay_network;
  let $yw_chain;
  let $yw_chain_ref;
  let $yw_overlay_account;
  let $yw_account;
  component_subscribe($$self, yw_search, ($$value) => $$invalidate(44, $yw_search = $$value));
  component_subscribe($$self, yw_cancel_search, ($$value) => $$invalidate(45, $yw_cancel_search = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(46, $yw_thread = $$value));
  component_subscribe($$self, yw_menu_vendor, ($$value) => $$invalidate(4, $yw_menu_vendor = $$value));
  component_subscribe($$self, yw_overlay_network, ($$value) => $$invalidate(5, $yw_overlay_network = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(6, $yw_chain = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(7, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_overlay_account, ($$value) => $$invalidate(8, $yw_overlay_account = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(9, $yw_account = $$value));
  let { pops = false } = $$props;
  const b_pops = pops;
  let { exits = false } = $$props;
  const b_exits = exits;
  let { plain = false } = $$props;
  const b_plain = plain;
  let { account = false } = $$props;
  const b_account = account;
  let { network = false } = $$props;
  const b_network = network;
  let { search: search2 = false } = $$props;
  const b_search = search2;
  let { title = "" } = $$props;
  const s_title = title;
  let { symbol = "" } = $$props;
  const s_symbol = symbol;
  let { subtitle = "" } = $$props;
  const s_subtitle = subtitle;
  const dispatch = createEventDispatcher();
  const overlay_pfp_props = (b_mirror = false) => ({
    dim: 21,
    bg: "satin",
    genStyle: "font-size:21px;",
    rootStyle: `
			padding: 5px 6px;
			border: 2px solid var(--theme-color-border);
			border-radius: ${b_mirror ? "0 4px 4px 0" : "4px 0 0 4px"};
		`.replace(/\s+/g, " ")
  });
  const k_page = getContext("page");
  let dm_header;
  let dm_search;
  let { isSearchScreen = false } = $$props;
  let { search_input = "" } = $$props;
  let s_search = $yw_search;
  yw_search.subscribe((s_value) => {
    if (isSearchScreen && s_value) {
      console.log("search screen and search text");
      $$invalidate(3, s_search = s_value);
      if (dm_search) {
        setTimeout(() => {
          dm_search.focus();
        }, 0);
      }
    } else if (!s_value) {
      $$invalidate(3, s_search = "");
    }
  });
  function update_search(d_event) {
    if (isSearchScreen) {
      if (!s_search) {
        set_store_value(yw_search, $yw_search = "", $yw_search);
        $yw_cancel_search();
      } else {
        dispatch("search", s_search);
      }
    } else if (s_search) {
      $yw_thread.id;
      const dm_focus = qs(dm_header, ":focus");
      if (dm_focus) {
        dm_focus.blur();
      }
      set_store_value(yw_cancel_search, $yw_cancel_search = () => {
        $$invalidate(3, s_search = "");
        console.log("stealing focus for cancel search");
        dm_search.focus();
      }, $yw_cancel_search);
      set_store_value(yw_search, $yw_search = s_search, $yw_search);
    }
  }
  const click_handler2 = () => k_page.pop();
  const click_handler_1 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = true, $yw_menu_vendor);
  const click_handler_2 = (d_event) => {
    d_event.stopPropagation();
    set_store_value(yw_overlay_network, $yw_overlay_network = !$yw_overlay_network, $yw_overlay_network);
  };
  const click_handler_3 = (p_chain) => {
    set_store_value(yw_chain_ref, $yw_chain_ref = p_chain, $yw_chain_ref);
    set_store_value(yw_overlay_network, $yw_overlay_network = false, $yw_overlay_network);
  };
  function overlayselect_open_binding(value) {
    $yw_overlay_network = value;
    yw_overlay_network.set($yw_overlay_network);
  }
  const click_handler_4 = (d_event) => {
    d_event.stopPropagation();
    set_store_value(yw_overlay_account, $yw_overlay_account = !$yw_overlay_account, $yw_overlay_account);
  };
  function overlayselect_open_binding_1(value) {
    $yw_overlay_account = value;
    yw_overlay_account.set($yw_overlay_account);
  }
  const click_handler_5 = () => dispatch("close");
  function input_input_handler() {
    s_search = this.value;
    $$invalidate(3, s_search);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_search = $$value;
      $$invalidate(2, dm_search);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_header = $$value;
      $$invalidate(1, dm_header);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("pops" in $$props2)
      $$invalidate(23, pops = $$props2.pops);
    if ("exits" in $$props2)
      $$invalidate(24, exits = $$props2.exits);
    if ("plain" in $$props2)
      $$invalidate(25, plain = $$props2.plain);
    if ("account" in $$props2)
      $$invalidate(26, account = $$props2.account);
    if ("network" in $$props2)
      $$invalidate(27, network = $$props2.network);
    if ("search" in $$props2)
      $$invalidate(28, search2 = $$props2.search);
    if ("title" in $$props2)
      $$invalidate(29, title = $$props2.title);
    if ("symbol" in $$props2)
      $$invalidate(30, symbol = $$props2.symbol);
    if ("subtitle" in $$props2)
      $$invalidate(31, subtitle = $$props2.subtitle);
    if ("isSearchScreen" in $$props2)
      $$invalidate(0, isSearchScreen = $$props2.isSearchScreen);
    if ("search_input" in $$props2)
      $$invalidate(32, search_input = $$props2.search_input);
  };
  return [
    isSearchScreen,
    dm_header,
    dm_search,
    s_search,
    $yw_menu_vendor,
    $yw_overlay_network,
    $yw_chain,
    $yw_chain_ref,
    $yw_overlay_account,
    $yw_account,
    b_pops,
    b_exits,
    b_plain,
    b_account,
    b_network,
    b_search,
    s_title,
    s_symbol,
    s_subtitle,
    dispatch,
    overlay_pfp_props,
    k_page,
    update_search,
    pops,
    exits,
    plain,
    account,
    network,
    search2,
    title,
    symbol,
    subtitle,
    search_input,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    overlayselect_open_binding,
    click_handler_4,
    overlayselect_open_binding_1,
    click_handler_5,
    input_input_handler,
    input_binding,
    div3_binding
  ];
}
class Header extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$F, create_fragment$I, safe_not_equal, {
      pops: 23,
      exits: 24,
      plain: 25,
      account: 26,
      network: 27,
      search: 28,
      title: 29,
      symbol: 30,
      subtitle: 31,
      isSearchScreen: 0,
      search_input: 32
    }, null, [-1, -1]);
  }
}
function get_each_context$a(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_if_block_1$8(ctx) {
  let span2;
  let span0;
  let t0;
  let t1_value = format_ms(ctx[2].value.offset) + "";
  let t1;
  let t2;
  let t3;
  let span1;
  let t4_value = ctx[2].value.message + "";
  let t4;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = text("+");
      t1 = text(t1_value);
      t2 = text("ms:");
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      attr(span0, "class", "offset");
      attr(span1, "class", "message");
      attr(span2, "class", "event");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span0, t0);
      append(span0, t1);
      append(span0, t2);
      append(span2, t3);
      append(span2, span1);
      append(span1, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = format_ms(ctx2[2].value.offset) + ""))
        set_data(t1, t1_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx2[2].value.message + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(span2);
    }
  };
}
function create_if_block$g(ctx) {
  let span;
  let t_value = ctx[2].value + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "string");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[2].value + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$a(ctx) {
  let li;
  let t;
  function select_block_type(ctx2, dirty) {
    if (ctx2[2].type === "string")
      return create_if_block$g;
    if (ctx2[2].type === "event")
      return create_if_block_1$8;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      li = element("li");
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (if_block)
        if_block.m(li, null);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(li, t);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_fragment$H(ctx) {
  let div;
  let ol;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "log-container svelte-13jddbg");
      toggle_class(div, "display_none", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ol, null);
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$a(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$a(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ol, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        toggle_class(div, "display_none", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
class Logger {
  constructor() {
    this._a_items = [];
  }
  get items() {
    return this._a_items;
  }
  set items(a_items) {
    this._a_items = a_items;
  }
  event(s_msg, xt_offset) {
    this._a_items.push({
      type: "event",
      value: { message: s_msg, offset: xt_offset }
    });
    return this;
  }
}
function format_ms(n_ms) {
  return (n_ms / 1e3).toFixed(2).padStart(5, "0");
}
function instance$E($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { hide = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("hide" in $$props2)
      $$invalidate(1, hide = $$props2.hide);
  };
  return [items, hide];
}
class Log extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$H, safe_not_equal, { items: 0, hide: 1 });
  }
}
function create_fragment$G(ctx) {
  let div;
  let img;
  let img_src_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      attr(img, "alt", "StarShell title");
      if (!src_url_equal(img.src, img_src_value = "/media/vendor/title.svg"))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-1htd4i8");
      attr(div, "class", "no-margin title svelte-1htd4i8");
      set_style(div, "width", ctx[0] + "px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  let { width = 180 } = $$props;
  const x_width = width;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
  };
  return [x_width, width];
}
class StarShellTitle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$G, safe_not_equal, { width: 1 });
  }
}
function create_default_slot$i(ctx) {
  let h3;
  let t1;
  let p0;
  let t3;
  let p1;
  let t5;
  let p2;
  let t7;
  let actionsline;
  let current;
  actionsline = new ActionsLine({
    props: {
      cancel: "pop",
      confirm: ["Use anyway", ctx[0]],
      wait: 5e3
    }
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Weak Password Warning";
      t1 = space();
      p0 = element("p");
      p0.textContent = "The password you entered was found on a list of the top ten thousand most commonly used passwords.";
      t3 = space();
      p1 = element("p");
      p1.textContent = "In order to help prevent the loss of funds, you are encouraged to create a strong, unique password.";
      t5 = space();
      p2 = element("p");
      p2.textContent = "How do you want to proceed?";
      t7 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, p0, anchor);
      insert(target, t3, anchor);
      insert(target, p1, anchor);
      insert(target, t5, anchor);
      insert(target, p2, anchor);
      insert(target, t7, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t7);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$F(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 32) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let { attempt_register } = $$props;
  let { weakness } = $$props;
  const k_page = getContext("page");
  function use_anyway() {
    attempt_register();
    k_page.pop();
  }
  $$self.$$set = ($$props2) => {
    if ("attempt_register" in $$props2)
      $$invalidate(1, attempt_register = $$props2.attempt_register);
    if ("weakness" in $$props2)
      $$invalidate(2, weakness = $$props2.weakness);
  };
  return [use_anyway, attempt_register, weakness];
}
class RegisterWeakPassword extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$F, safe_not_equal, { attempt_register: 1, weakness: 2 });
  }
}
function create_if_block_2$4(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[4]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 16)
        set_data(t, ctx2[4]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_2$4(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && ctx[4] && create_if_block_2$4(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "autocomplete", "new-password");
      attr(input, "name", "password");
      attr(input, "placeholder", "Password");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", ctx[10]),
          listen(input, "input", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (!ctx2[2] && ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 20) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$7(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[5]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 32)
        set_data(t, ctx2[5]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_1$6(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && ctx[5] && create_if_block_1$7(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "autocomplete", "new-password");
      attr(input, "name", "verify");
      attr(input, "placeholder", "Password");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", ctx[12]),
          listen(input, "input", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      if (!ctx2[2] && ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 36) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$f(ctx) {
  let pre;
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(ctx[3]);
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_default_slot$h(ctx) {
  let center;
  let div0;
  let starshelllogo;
  let t0;
  let starshelltitle;
  let t1;
  let p;
  let t3;
  let div1;
  let input;
  let t4;
  let field0;
  let t5;
  let field1;
  let t6;
  let log_1;
  let updating_items;
  let t7;
  let t8;
  let actionsline;
  let current;
  starshelllogo = new StarShellLogo({ props: { dim: 96 } });
  starshelltitle = new StarShellTitle({ props: { width: 150 } });
  field0 = new Field({
    props: {
      key: "password",
      name: "New password",
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      key: "verify-password",
      name: "Verify password",
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  function log_1_items_binding(value) {
    ctx[14](value);
  }
  let log_1_props = {};
  if (ctx[6].items !== void 0) {
    log_1_props.items = ctx[6].items;
  }
  log_1 = new Log({ props: log_1_props });
  binding_callbacks.push(() => bind(log_1, "items", log_1_items_binding));
  let if_block = ctx[3] && create_if_block$f(ctx);
  actionsline = new ActionsLine({
    props: { confirm: ctx[7] }
  });
  return {
    c() {
      center = element("center");
      div0 = element("div");
      create_component(starshelllogo.$$.fragment);
      t0 = space();
      create_component(starshelltitle.$$.fragment);
      t1 = space();
      p = element("p");
      p.textContent = "Create a new password to protect your wallet's data.";
      t3 = space();
      div1 = element("div");
      input = element("input");
      t4 = space();
      create_component(field0.$$.fragment);
      t5 = space();
      create_component(field1.$$.fragment);
      t6 = space();
      create_component(log_1.$$.fragment);
      t7 = space();
      if (if_block)
        if_block.c();
      t8 = space();
      create_component(actionsline.$$.fragment);
      attr(div0, "class", "intro svelte-pdf2wg");
      attr(p, "class", "narrow svelte-pdf2wg");
      input.hidden = true;
      attr(input, "type", "text");
      attr(input, "name", "username");
      attr(input, "autocomplete", "username");
      input.value = "StarShell Wallet User";
      attr(div1, "class", "form flex-rows");
    },
    m(target, anchor) {
      insert(target, center, anchor);
      append(center, div0);
      mount_component(starshelllogo, div0, null);
      append(div0, t0);
      mount_component(starshelltitle, div0, null);
      append(center, t1);
      append(center, p);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      append(div1, input);
      append(div1, t4);
      mount_component(field0, div1, null);
      append(div1, t5);
      mount_component(field1, div1, null);
      insert(target, t6, anchor);
      mount_component(log_1, target, anchor);
      insert(target, t7, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t8, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 8388629) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 8388646) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const log_1_changes = {};
      if (!updating_items && dirty & 64) {
        updating_items = true;
        log_1_changes.items = ctx2[6].items;
        add_flush_callback(() => updating_items = false);
      }
      log_1.$set(log_1_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$f(ctx2);
          if_block.c();
          if_block.m(t8.parentNode, t8);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const actionsline_changes = {};
      if (dirty & 128)
        actionsline_changes.confirm = ctx2[7];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      transition_in(starshelltitle.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(log_1.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      transition_out(starshelltitle.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(log_1.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(center);
      destroy_component(starshelllogo);
      destroy_component(starshelltitle);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      destroy_component(field0);
      destroy_component(field1);
      if (detaching)
        detach(t6);
      destroy_component(log_1, detaching);
      if (detaching)
        detach(t7);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t8);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$E(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8388863) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let b_password_acceptable;
  let a_confirm_action;
  const k_page = getContext("page");
  const completed = getContext("completed");
  let sh_phrase = "";
  let sh_verify = "";
  let s_error = "";
  let s_err_password = "";
  let s_err_verify = "";
  let xt_start = 0;
  let k_logger = new Logger();
  function log(s_msg) {
    $$invalidate(6, k_logger = k_logger.event(s_msg, Date.now() - xt_start));
  }
  k_page.on({
    restore() {
      $$invalidate(0, sh_phrase = $$invalidate(1, sh_verify = ""));
    }
  });
  function check_password() {
    if (sh_phrase && !acceptable(sh_phrase)) {
      if (sh_phrase.length < NL_PASSPHRASE_MINIMUM) {
        $$invalidate(4, s_err_password = "Password must be at least 5 characters");
      } else if (sh_phrase.length > NL_PASSPHRASE_MAXIMUM) {
        $$invalidate(4, s_err_password = "Password must be 1024 characters or fewer");
      } else {
        $$invalidate(4, s_err_password = "Password is not acceptable");
      }
      return;
    }
    $$invalidate(4, s_err_password = "");
  }
  function check_verify() {
    if (sh_phrase && !s_err_password && sh_phrase !== sh_verify) {
      $$invalidate(5, s_err_verify = "Passwords do not match");
      return;
    }
    $$invalidate(5, s_err_verify = "");
  }
  const dp_passwords = (async () => {
    const d_res = await fetch("/data/passwords-top-10k.txt");
    const s_list = await d_res.text();
    return s_list.split("\n");
  })();
  async function prepare_register() {
    const a_passwords = await dp_passwords;
    if (a_passwords.includes(sh_phrase)) {
      k_page.push({
        creator: RegisterWeakPassword,
        props: { attempt_register }
      });
    } else {
      await attempt_register();
    }
  }
  let b_busy = false;
  async function attempt_register() {
    if (!b_password_acceptable)
      return 1;
    if (b_busy)
      return 1;
    b_busy = true;
    const exit = () => (b_busy = false, 1);
    $$invalidate(3, s_error = "");
    xt_start = Date.now();
    log("Estimating time to complete");
    {
      const xt_start_est = window.performance.now();
      await Vault.deriveRootBits(ATU8_DUMMY_PHRASE, ATU8_DUMMY_VECTOR, 1 / 50);
      const xt_finish_est = window.performance.now();
      const xt_elapsed_est = xt_finish_est - xt_start_est;
      const xt_estimate = 2 * (2 * (xt_elapsed_est * 50));
      log(`About ${(xt_estimate / 1e3).toFixed(1)} seconds`);
    }
    try {
      await register$1(sh_phrase, log);
    } catch (e_register) {
      if (e_register instanceof AlreadyRegisteredError) {
        $$invalidate(3, s_error = "A passphrase is already registered");
      } else if (e_register instanceof InvalidPassphraseError) {
        $$invalidate(3, s_error = "Invalid passphrase");
      } else {
        $$invalidate(3, s_error = `Unexpected error occurred while attempting to register:
${e_register.stack || e_register.message}`);
      }
      return exit();
    }
    log("Verifying passphrase");
    try {
      await login(sh_phrase, false, log);
    } catch (e_login) {
      $$invalidate(3, s_error = "Failed to verify passphrase immediately after registration");
      await Vault.eraseBase();
      return exit();
    }
    log("Done");
    $$invalidate(3, s_error = "Success");
    if (completed)
      completed(true);
    return exit();
  }
  const blur_handler = () => check_password();
  function input_input_handler() {
    sh_phrase = this.value;
    $$invalidate(0, sh_phrase);
  }
  const blur_handler_1 = () => check_verify();
  function input_input_handler_1() {
    sh_verify = this.value;
    $$invalidate(1, sh_verify);
  }
  function log_1_items_binding(value) {
    if ($$self.$$.not_equal(k_logger.items, value)) {
      k_logger.items = value;
      $$invalidate(6, k_logger);
    }
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $$invalidate(2, b_password_acceptable = !!sh_phrase && sh_phrase === sh_verify && acceptable(sh_phrase));
    }
    if ($$self.$$.dirty & 4) {
      $$invalidate(7, a_confirm_action = ["Continue", prepare_register, !b_password_acceptable]);
    }
  };
  return [
    sh_phrase,
    sh_verify,
    b_password_acceptable,
    s_error,
    s_err_password,
    s_err_verify,
    k_logger,
    a_confirm_action,
    check_password,
    check_verify,
    blur_handler,
    input_input_handler,
    blur_handler_1,
    input_input_handler_1,
    log_1_items_binding
  ];
}
class Register extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$E, safe_not_equal, {});
  }
}
var SX_ICON_CONTACTS$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M19 5v14H5V5h14m0-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 9c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm6 10H6v-1.53c0-2.5 3.97-3.58 6-3.58s6 1.08 6 3.58V18zm-9.69-2h7.38c-.69-.56-2.38-1.12-3.69-1.12s-3.01.56-3.69 1.12z"/>\n</svg>';
var SX_ICON_CONTRACT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-analytics-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-analytics-fg" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/>\n	<path class="s2r-analytics-fg" d="M7 12h2v5H7zm8-5h2v10h-2zm-4 7h2v3h-2zm0-4h2v2h-2z"/>\n</svg>';
var SX_ICON_LOADING = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M13 5.08A7 7 0 0 1 18.92 11h3.03c-.47-4.72-4.23-8.48-8.95-8.95v3.03zM18.92 13A7 7 0 0 1 13 18.92v3.03c4.72-.47 8.48-4.23 8.95-8.95h-3.03zM11 18.92c-3.39-.49-6-3.4-6-6.92s2.61-6.43 6-6.92V2.05c-5.05.5-9 4.76-9 9.95 0 5.19 3.95 9.45 9 9.95v-3.03z"/>\n</svg>';
function create_catch_block$a(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$a(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding(value) {
    ctx[4](value);
  }
  let starselect_props = {
    id: "asset-select",
    pfpMap: ctx[1],
    placeholder: "Select asset",
    items: ctx[8]
  };
  if (ctx[0] !== void 0) {
    starselect_props.value = ctx[0];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (dirty & 2)
        starselect_changes.pfpMap = ctx2[1];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        starselect_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block$a(ctx) {
  let t;
  return {
    c() {
      t = text("Loading assets...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$D(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$a,
    then: create_then_block$a,
    catch: create_catch_block$a,
    value: 8,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "asset");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let $yw_owner;
  let $yw_chain;
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(5, $yw_owner = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(6, $yw_chain = $$value));
  let { assetRef = "" } = $$props;
  $yw_chain?.id || "*";
  let h_asset_pfps = {};
  async function load_assets() {
    const a_items = [];
    $$invalidate(1, h_asset_pfps = await load_pfps($yw_chain.coins, { dim: 19 }));
    for (const [si_coin, g_coin] of ode($yw_chain.coins)) {
      a_items.push({
        value: Entities.holdingPathFor($yw_owner, si_coin),
        object: g_coin,
        primary: si_coin,
        secondary: g_coin.name,
        pfp: g_coin.pfp
      });
    }
    return a_items;
  }
  let g_item = {
    value: assetRef,
    object: null,
    primary: "",
    secondary: "",
    pfp: ""
  };
  function starselect_value_binding(value) {
    g_item = value;
    $$invalidate(0, g_item);
  }
  $$self.$$set = ($$props2) => {
    if ("assetRef" in $$props2)
      $$invalidate(3, assetRef = $$props2.assetRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        $$invalidate(3, assetRef = g_item?.value || "");
      }
    }
  };
  return [g_item, h_asset_pfps, load_assets, assetRef, starselect_value_binding];
}
class AssetSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$D, safe_not_equal, { assetRef: 3 });
  }
}
var SX_ICON_INCREMENT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14l-6-6z"/>\n</svg>';
var SX_ICON_DECREMENT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"/>\n</svg>';
function create_if_block_1$6(ctx) {
  let span6;
  let span2;
  let span0;
  let t0;
  let t1;
  let t2;
  let span1;
  let t4;
  let span5;
  let span3;
  let t5;
  let span4;
  let mounted;
  let dispose;
  return {
    c() {
      span6 = element("span");
      span2 = element("span");
      span0 = element("span");
      t0 = text("= ");
      t1 = text(ctx[5]);
      t2 = space();
      span1 = element("span");
      span1.textContent = "USD";
      t4 = space();
      span5 = element("span");
      span3 = element("span");
      t5 = space();
      span4 = element("span");
      attr(span0, "class", "amount svelte-1h2yrt5");
      attr(span1, "class", "fiat svelte-1h2yrt5");
      attr(span2, "class", "equivalent svelte-1h2yrt5");
      attr(span3, "class", "icon increment clickable svelte-1h2yrt5");
      attr(span4, "class", "icon decrement clickable svelte-1h2yrt5");
      attr(span5, "class", "adjust svelte-1h2yrt5");
      attr(span6, "class", "occupy svelte-1h2yrt5");
    },
    m(target, anchor) {
      insert(target, span6, anchor);
      append(span6, span2);
      append(span2, span0);
      append(span0, t0);
      append(span0, t1);
      append(span2, t2);
      append(span2, span1);
      append(span6, t4);
      append(span6, span5);
      append(span5, span3);
      span3.innerHTML = SX_ICON_INCREMENT;
      append(span5, t5);
      append(span5, span4);
      span4.innerHTML = SX_ICON_DECREMENT;
      if (!mounted) {
        dispose = [
          listen(span3, "click", ctx[16]),
          listen(span3, "mousedown", ctx[17]),
          listen(span4, "click", ctx[18]),
          listen(span4, "mousedown", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t1, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(span6);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$e(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$C(ctx) {
  let div;
  let input;
  let input_disabled_value;
  let input_max_value;
  let input_step_value;
  let t0;
  let t1;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_1$6(ctx);
  let if_block1 = ctx[1] && create_if_block$e(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      input.disabled = input_disabled_value = !ctx[2];
      attr(input, "type", "number");
      attr(input, "min", "0");
      attr(input, "max", input_max_value = ctx[4] + "" || "0");
      attr(input, "step", input_step_value = "0." + "0".repeat((ctx[3]?.decimals || 1) - 1) + "1");
      input.required = true;
      input.value = ctx[0];
      attr(input, "class", "svelte-1h2yrt5");
      toggle_class(input, "invalid", ctx[1]);
      attr(div, "class", "amount-input svelte-1h2yrt5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[15](input);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[14]),
          listen(input, "input", ctx[7]),
          listen(input, "invalid", invalid_handler)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && input_disabled_value !== (input_disabled_value = !ctx2[2])) {
        input.disabled = input_disabled_value;
      }
      if (dirty & 16 && input_max_value !== (input_max_value = ctx2[4] + "" || "0")) {
        attr(input, "max", input_max_value);
      }
      if (dirty & 8 && input_step_value !== (input_step_value = "0." + "0".repeat((ctx2[3]?.decimals || 1) - 1) + "1")) {
        attr(input, "step", input_step_value);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 2) {
        toggle_class(input, "invalid", ctx2[1]);
      }
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$6(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$e(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[15](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function long_press(f_action) {
  let i_ticker = 0;
  const i_buffer = window.setTimeout(() => {
    i_ticker = window.setInterval(f_action, 90);
  }, 1e3);
  window.addEventListener("mouseup", () => {
    clearTimeout(i_buffer);
    clearInterval(i_ticker);
  }, { once: true });
}
const invalid_handler = (d) => d.preventDefault();
function instance$z($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_owner;
  let $yw_network_active;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(21, $yw_chain = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(22, $yw_owner = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(23, $yw_network_active = $$value));
  let { value = "" } = $$props;
  const YG_ZERO = new BigNumber(0);
  const YG_ONE = new BigNumber(1);
  let { assetRef = "" } = $$props;
  let { bufferMax = 0 } = $$props;
  let g_asset;
  let yg_max = YG_ZERO;
  let yg_step = YG_ZERO;
  let s_fiat_equivalent = "";
  let si_coingecko = "";
  async function reload_asset() {
    $$invalidate(5, s_fiat_equivalent = "[...]");
    const g_entity = Entities.parseEntityPath(assetRef);
    if (g_entity?.type === "holding") {
      const si_coin = g_entity.coin;
      $$invalidate(3, g_asset = $yw_chain.coins[si_coin]);
      const g_cached = $yw_network_active.cachedBalance($yw_owner, si_coin);
      if (g_cached && g_cached.timestamp > Date.now() - 5 * XT_MINUTES) {
        $$invalidate(4, yg_max = new BigNumber(g_cached.data.amount).shiftedBy(-g_asset.decimals).minus(new BigNumber(bufferMax)));
      }
      const g_bundle = await $yw_network_active.bankBalance($yw_owner, si_coin);
      if (assetRef === g_bundle.holding) {
        const yg_amount = new BigNumber(g_bundle.balance.amount).shiftedBy(-g_asset.decimals).minus(new BigNumber(bufferMax));
        if (!yg_amount.eq(yg_max)) {
          $$invalidate(4, yg_max = yg_amount);
        }
        const g_coin = $yw_chain.coins[si_coin];
        $$invalidate(13, si_coingecko = g_coin?.extra?.coingecko_id || "");
      }
    } else if (g_entity?.type === "token") {
      $$invalidate(3, g_asset = null);
    }
    if (g_asset) {
      yg_step = YG_ONE.shiftedBy(-g_asset.decimals);
    } else {
      yg_step = YG_ZERO;
      $$invalidate(4, yg_max = YG_ZERO);
    }
  }
  function capture_input(d_event) {
    $$invalidate(0, value = d_event.target.value);
  }
  function increment() {
    const yg_next = yg_step.plus(value || 0);
    if (yg_next.lte(yg_max)) {
      $$invalidate(0, value = yg_next + "");
    } else {
      $$invalidate(0, value = yg_max + "");
    }
    check_validity();
  }
  function decrement() {
    const yg_next = yg_step.negated().plus(value || 0);
    if (yg_next.gte(0)) {
      if (yg_next.gt(yg_max)) {
        $$invalidate(0, value = yg_max + "");
      } else {
        $$invalidate(0, value = yg_next + "");
      }
    } else {
      $$invalidate(0, value = "0");
    }
    check_validity();
  }
  let { error = "" } = $$props;
  let dm_input;
  function invalidate(s_msg) {
    dm_input.setCustomValidity(s_msg);
    $$invalidate(1, error = s_msg);
  }
  function check_validity() {
    if (!value) {
      return invalidate("Enter an amount");
    }
    let yg_input;
    try {
      yg_input = new BigNumber(value);
    } catch (e_parse) {
      return invalidate("Invalid number");
    }
    if (yg_input.lt(YG_ZERO)) {
      return invalidate("Value must be positive");
    }
    if (yg_input.gt(yg_max)) {
      return invalidate("Insufficient balance");
    }
    $$invalidate(1, error = "");
  }
  let { showValidation = 0 } = $$props;
  const change_handler = () => check_validity();
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_input = $$value;
      $$invalidate(6, dm_input);
    });
  }
  const click_handler2 = () => increment();
  const mousedown_handler = () => long_press(increment);
  const click_handler_1 = () => decrement();
  const mousedown_handler_1 = () => long_press(decrement);
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("assetRef" in $$props2)
      $$invalidate(2, assetRef = $$props2.assetRef);
    if ("bufferMax" in $$props2)
      $$invalidate(11, bufferMax = $$props2.bufferMax);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("showValidation" in $$props2)
      $$invalidate(12, showValidation = $$props2.showValidation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      {
        if (assetRef) {
          void reload_asset();
        } else {
          $$invalidate(3, g_asset = null);
        }
      }
    }
    if ($$self.$$.dirty & 8193) {
      {
        if (si_coingecko) {
          (async () => {
            const h_versus = await CoinGecko.coinsVersus([si_coingecko], "usd", 1 * XT_MINUTES);
            if (si_coingecko in h_versus) {
              $$invalidate(5, s_fiat_equivalent = format_amount(+value * +h_versus[si_coingecko], true));
            } else {
              $$invalidate(5, s_fiat_equivalent = "(?)");
            }
          })();
        } else {
          $$invalidate(5, s_fiat_equivalent = "");
        }
      }
    }
    if ($$self.$$.dirty & 4097) {
      {
        if (showValidation) {
          check_validity();
        } else if (!value) {
          $$invalidate(1, error = "");
        }
      }
    }
  };
  return [
    value,
    error,
    assetRef,
    g_asset,
    yg_max,
    s_fiat_equivalent,
    dm_input,
    capture_input,
    increment,
    decrement,
    check_validity,
    bufferMax,
    showValidation,
    si_coingecko,
    change_handler,
    input_binding,
    click_handler2,
    mousedown_handler,
    click_handler_1,
    mousedown_handler_1
  ];
}
class AmountInput extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$C, safe_not_equal, {
      value: 0,
      assetRef: 2,
      bufferMax: 11,
      error: 1,
      showValidation: 12
    });
  }
}
function create_catch_block$9(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$9(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding(value) {
    ctx[4](value);
  }
  let starselect_props = {
    id: "sender-select",
    placeholder: "Select account",
    secondaryClass: "balance",
    items: ctx[1]
  };
  if (ctx[0] !== void 0) {
    starselect_props.value = ctx[0];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (!updating_value && dirty & 1) {
        updating_value = true;
        starselect_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block$9(ctx) {
  let t;
  return {
    c() {
      t = text("Loading accounts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$B(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$9,
    then: create_then_block$9,
    catch: create_catch_block$9,
    value: 1,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "sender");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let $yw_account_ref;
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(5, $yw_account_ref = $$value));
  let { accountRef = $yw_account_ref } = $$props;
  const p_account = accountRef;
  const mk_account = (p_acc, g_acc) => ({
    value: p_acc,
    primary: g_acc.name,
    secondary: "$$"
  });
  let g_selected;
  let a_options;
  async function load_accounts() {
    const ks_accounts = await Accounts.read();
    $$invalidate(1, a_options = oderac(ks_accounts.raw, mk_account));
    $$invalidate(0, g_selected = a_options.find((g) => p_account === g.value));
    return a_options;
  }
  function starselect_value_binding(value) {
    g_selected = value;
    $$invalidate(0, g_selected);
  }
  $$self.$$set = ($$props2) => {
    if ("accountRef" in $$props2)
      $$invalidate(3, accountRef = $$props2.accountRef);
  };
  return [g_selected, a_options, load_accounts, accountRef, starselect_value_binding];
}
class SenderSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$B, safe_not_equal, { accountRef: 3 });
  }
}
function create_else_block$3(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Failed to locate contact";
      attr(span, "class", "warning");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$3(ctx) {
  let span;
  let address_1;
  let current;
  address_1 = new Address({ props: { address: ctx[0] } });
  return {
    c() {
      span = element("span");
      create_component(address_1.$$.fragment);
      attr(span, "class", "manual");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(address_1, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const address_1_changes = {};
      if (dirty & 1)
        address_1_changes.address = ctx2[0];
      address_1.$set(address_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(address_1);
    }
  };
}
function create_if_block$d(ctx) {
  let div;
  let span0;
  let t0;
  let span2;
  let span1;
  let t1_value = ctx[1].name + "";
  let t1;
  let t2;
  let address_1;
  let current;
  let if_block = ctx[1] && create_if_block_1$5(ctx);
  address_1 = new Address({
    props: {
      address: Chains.bech32(ctx[1].address)
    }
  });
  return {
    c() {
      div = element("div");
      span0 = element("span");
      if (if_block)
        if_block.c();
      t0 = space();
      span2 = element("span");
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      create_component(address_1.$$.fragment);
      attr(span0, "class", "contact-pfp svelte-1ontxbe");
      attr(span1, "class", "name svelte-1ontxbe");
      attr(span2, "class", "info svelte-1ontxbe");
      attr(div, "class", "contact svelte-1ontxbe");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      if (if_block)
        if_block.m(span0, null);
      append(div, t0);
      append(div, span2);
      append(span2, span1);
      append(span1, t1);
      append(span2, t2);
      mount_component(address_1, span2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if ((!current || dirty & 2) && t1_value !== (t1_value = ctx2[1].name + ""))
        set_data(t1, t1_value);
      const address_1_changes = {};
      if (dirty & 2)
        address_1_changes.address = Chains.bech32(ctx2[1].address);
      address_1.$set(address_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(address_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(address_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_component(address_1);
    }
  };
}
function create_if_block_1$5(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 28,
      resource: ctx[1],
      genStyle: "font-size:18px;"
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = {};
      if (dirty & 2)
        pfpdisplay_changes.resource = ctx2[1];
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_fragment$A(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$d, create_if_block_2$3, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    if (ctx2[0])
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let $yw_family;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(3, $yw_family = $$value));
  let { contact = null } = $$props;
  let g_contact = contact;
  let { address = "" } = $$props;
  async function reload_contacts() {
    const ks_agents = await Agents.read();
    const di_contacts = ks_agents.contacts($yw_family);
    if (!g_contact && address) {
      for (const [, g_contact_each] of di_contacts) {
        if (address === Chains.bech32(g_contact_each.address)) {
          $$invalidate(1, g_contact = g_contact_each);
          break;
        }
      }
    }
  }
  void reload_contacts();
  const f_unsub_agents = subscribe_store("agents", reload_contacts);
  onDestroy(() => {
    f_unsub_agents();
  });
  $$self.$$set = ($$props2) => {
    if ("contact" in $$props2)
      $$invalidate(2, contact = $$props2.contact);
    if ("address" in $$props2)
      $$invalidate(0, address = $$props2.address);
  };
  return [address, g_contact, contact];
}
class InlineContactSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$A, safe_not_equal, { contact: 2, address: 0 });
  }
}
function create_fragment$z(ctx) {
  let div;
  let inlinecontactselection;
  let div_class_value;
  let current;
  inlinecontactselection = new InlineContactSelection({
    props: {
      contact: ctx[1].contact,
      address: ctx[1].value
    }
  });
  return {
    c() {
      div = element("div");
      create_component(inlinecontactselection.$$.fragment);
      attr(div, "class", div_class_value = "item " + ctx[2] + " svelte-pgx3pp");
      toggle_class(div, "display_none", ctx[0] || !ctx[1].value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inlinecontactselection, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const inlinecontactselection_changes = {};
      if (dirty & 2)
        inlinecontactselection_changes.contact = ctx2[1].contact;
      if (dirty & 2)
        inlinecontactselection_changes.address = ctx2[1].value;
      inlinecontactselection.$set(inlinecontactselection_changes);
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "item " + ctx2[2] + " svelte-pgx3pp")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & 7) {
        toggle_class(div, "display_none", ctx2[0] || !ctx2[1].value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinecontactselection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontactselection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inlinecontactselection);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let { isActive = false } = $$props;
  let { isFirst = false } = $$props;
  let { isHover = false } = $$props;
  let { isSelectable = false } = $$props;
  let { getOptionLabel = void 0 } = $$props;
  let { item } = $$props;
  let { filterText = "" } = $$props;
  let itemClasses = "";
  $$self.$$set = ($$props2) => {
    if ("isActive" in $$props2)
      $$invalidate(0, isActive = $$props2.isActive);
    if ("isFirst" in $$props2)
      $$invalidate(3, isFirst = $$props2.isFirst);
    if ("isHover" in $$props2)
      $$invalidate(4, isHover = $$props2.isHover);
    if ("isSelectable" in $$props2)
      $$invalidate(5, isSelectable = $$props2.isSelectable);
    if ("getOptionLabel" in $$props2)
      $$invalidate(6, getOptionLabel = $$props2.getOptionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("filterText" in $$props2)
      $$invalidate(7, filterText = $$props2.filterText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 57) {
      {
        const classes = [];
        if (isActive) {
          classes.push("active");
        }
        if (isFirst) {
          classes.push("first");
        }
        if (isHover) {
          classes.push("hover");
        }
        if (!isSelectable) {
          classes.push("notSelectable");
        }
        $$invalidate(2, itemClasses = classes.join(" "));
      }
    }
  };
  return [
    isActive,
    item,
    itemClasses,
    isFirst,
    isHover,
    isSelectable,
    getOptionLabel,
    filterText
  ];
}
class RecipientSelectItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$z, safe_not_equal, {
      isActive: 0,
      isFirst: 3,
      isHover: 4,
      isSelectable: 5,
      getOptionLabel: 6,
      item: 1,
      filterText: 7
    });
  }
}
function create_fragment$y(ctx) {
  let div;
  let inlinecontactselection;
  let current;
  inlinecontactselection = new InlineContactSelection({
    props: {
      contact: ctx[0].contact,
      address: ctx[0].value
    }
  });
  return {
    c() {
      div = element("div");
      create_component(inlinecontactselection.$$.fragment);
      attr(div, "class", "selection svelte-aitqlq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inlinecontactselection, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const inlinecontactselection_changes = {};
      if (dirty & 1)
        inlinecontactselection_changes.contact = ctx2[0].contact;
      if (dirty & 1)
        inlinecontactselection_changes.address = ctx2[0].value;
      inlinecontactselection.$set(inlinecontactselection_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinecontactselection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontactselection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inlinecontactselection);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let { getSelectionLabel } = $$props;
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("getSelectionLabel" in $$props2)
      $$invalidate(1, getSelectionLabel = $$props2.getSelectionLabel);
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item, getSelectionLabel];
}
class RecipientSelectSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$y, safe_not_equal, { getSelectionLabel: 1, item: 0 });
  }
}
function create_catch_block$8(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$8(ctx) {
  let select_1;
  let updating_filterText;
  let updating_listOpen;
  let current;
  function select_1_filterText_binding(value) {
    ctx[14](value);
  }
  function select_1_listOpen_binding(value) {
    ctx[15](value);
  }
  let select_1_props = {
    id: "recipient-select",
    placeholder: "Address or contact",
    listOffset: 1,
    isClearable: !!ctx[0],
    isCreatable: !!ctx[3],
    Item: RecipientSelectItem,
    Selection: RecipientSelectSelection,
    items: ctx[8],
    value: ctx[4],
    noOptionsMessage: "Stop typing in the address. \n Use copy/paste instead!",
    containerClasses: ctx[1] ? "invalid" : ""
  };
  if (ctx[2] !== void 0) {
    select_1_props.filterText = ctx[2];
  }
  if (ctx[6] !== void 0) {
    select_1_props.listOpen = ctx[6];
  }
  select_1 = new Select({ props: select_1_props });
  binding_callbacks.push(() => bind(select_1, "filterText", select_1_filterText_binding));
  binding_callbacks.push(() => bind(select_1, "listOpen", select_1_listOpen_binding));
  select_1.$on("select", ctx[10]);
  select_1.$on("clear", ctx[11]);
  return {
    c() {
      create_component(select_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_1_changes = {};
      if (dirty & 1)
        select_1_changes.isClearable = !!ctx2[0];
      if (dirty & 8)
        select_1_changes.isCreatable = !!ctx2[3];
      if (dirty & 16)
        select_1_changes.value = ctx2[4];
      if (dirty & 2)
        select_1_changes.containerClasses = ctx2[1] ? "invalid" : "";
      if (!updating_filterText && dirty & 4) {
        updating_filterText = true;
        select_1_changes.filterText = ctx2[2];
        add_flush_callback(() => updating_filterText = false);
      }
      if (!updating_listOpen && dirty & 64) {
        updating_listOpen = true;
        select_1_changes.listOpen = ctx2[6];
        add_flush_callback(() => updating_listOpen = false);
      }
      select_1.$set(select_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_1, detaching);
    }
  };
}
function create_pending_block$8(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contacts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$c(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$x(ctx) {
  let div;
  let t;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$8,
    then: create_then_block$8,
    catch: create_catch_block$8,
    value: 8,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  let if_block = ctx[1] && create_if_block$c(ctx);
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "sender svelte-1rmr362");
      toggle_class(div, "hide-cursor", ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[16](div);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (ctx[1]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$c(ctx);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32) {
        toggle_class(div, "hide-cursor", ctx[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      if (if_block)
        if_block.d();
      ctx[16](null);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_family;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(13, $yw_chain = $$value));
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(17, $yw_family = $$value));
  let { address = "" } = $$props;
  const sa_input = address;
  let { error = "" } = $$props;
  let s_manual_input;
  let g_item_select;
  let a_contacts;
  const contact_to_option = (g) => ({
    value: Chains.bech32(g.address),
    label: g.name,
    contact: g
  });
  async function load_contacts() {
    const ks_agents = await Agents.read();
    const a_options = [{ value: "", label: "", contact: null }];
    $$invalidate(8, a_contacts = [...ks_agents.contacts($yw_family)]);
    for (const [, g_contact] of a_contacts) {
      const g_option = contact_to_option(g_contact);
      const sa_contact = Chains.bech32(g_contact.address);
      if (sa_input && sa_contact === sa_input) {
        $$invalidate(4, g_item_select = g_option);
      }
      a_options.push(g_option);
    }
    return a_options;
  }
  function select(d_event) {
    $$invalidate(0, address = d_event.detail.value);
    $$invalidate(1, error = "");
  }
  function clear() {
    $$invalidate(0, address = "");
  }
  let s_accepted_input = "";
  let b_hide_cursor = false;
  let b_list_open = false;
  function check_manual_input() {
    $$invalidate(3, s_accepted_input = "");
    if (!$yw_chain) {
      $$invalidate(1, error = "No chain set");
    } else if (!Chains.isValidAddressFor($yw_chain, s_manual_input, "acc")) {
      $$invalidate(1, error = "Invalid address for this chain");
    } else {
      $$invalidate(1, error = "");
      for (const [, g_contact] of a_contacts) {
        if (s_manual_input === Chains.bech32(g_contact.address)) {
          $$invalidate(2, s_manual_input = "");
          $$invalidate(4, g_item_select = contact_to_option(g_contact));
          $$invalidate(6, b_list_open = false);
          $$invalidate(5, b_hide_cursor = true);
          return;
        }
      }
      $$invalidate(3, s_accepted_input = s_manual_input);
      setTimeout(() => {
        qs(dm_sender, ".manual>.address").click();
        $$invalidate(6, b_list_open = false);
      }, 0);
    }
  }
  let dm_sender;
  let { showValidation = 0 } = $$props;
  function select_1_filterText_binding(value) {
    s_manual_input = value;
    $$invalidate(2, s_manual_input);
  }
  function select_1_listOpen_binding(value) {
    b_list_open = value;
    $$invalidate(6, b_list_open);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_sender = $$value;
      $$invalidate(7, dm_sender);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("address" in $$props2)
      $$invalidate(0, address = $$props2.address);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("showValidation" in $$props2)
      $$invalidate(12, showValidation = $$props2.showValidation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      {
        $$invalidate(5, b_hide_cursor = false);
        if (s_manual_input) {
          check_manual_input();
        } else {
          $$invalidate(5, b_hide_cursor = !!s_accepted_input);
          $$invalidate(3, s_accepted_input = "");
        }
      }
    }
    if ($$self.$$.dirty & 12293) {
      {
        if (showValidation) {
          if (!address) {
            if (s_manual_input) {
              check_manual_input();
            } else {
              $$invalidate(1, error = "Enter a recipient");
            }
          } else if (!Chains.isValidAddressFor($yw_chain, address, "acc")) {
            $$invalidate(1, error = "Invalid address for this chain");
          } else {
            $$invalidate(1, error = "");
          }
        } else if (!address) {
          $$invalidate(1, error = "");
        }
      }
    }
  };
  return [
    address,
    error,
    s_manual_input,
    s_accepted_input,
    g_item_select,
    b_hide_cursor,
    b_list_open,
    dm_sender,
    a_contacts,
    load_contacts,
    select,
    clear,
    showValidation,
    $yw_chain,
    select_1_filterText_binding,
    select_1_listOpen_binding,
    div_binding
  ];
}
class RecipientSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$x, safe_not_equal, { address: 0, error: 1, showValidation: 12 });
  }
}
var SX_ICON_ASTRONAUT = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M64 224h13.5c24.7 56.5 80.9 96 146.5 96s121.8-39.5 146.5-96H384c8.8 0 16-7.2 16-16v-96c0-8.8-7.2-16-16-16h-13.5C345.8 39.5 289.6 0 224 0S102.2 39.5 77.5 96H64c-8.8 0-16 7.2-16 16v96c0 8.8 7.2 16 16 16zm40-88c0-22.1 21.5-40 48-40h144c26.5 0 48 17.9 48 40v24c0 53-43 96-96 96h-48c-53 0-96-43-96-96v-24zm72 72l12-36 36-12-36-12-12-36-12 36-36 12 36 12 12 36zm151.6 113.4C297.7 340.7 262.2 352 224 352s-73.7-11.3-103.6-30.6C52.9 328.5 0 385 0 454.4v9.6c0 26.5 21.5 48 48 48h80v-64c0-17.7 14.3-32 32-32h128c17.7 0 32 14.3 32 32v64h80c26.5 0 48-21.5 48-48v-9.6c0-69.4-52.9-125.9-120.4-133zM272 448c-8.8 0-16 7.2-16 16s7.2 16 16 16 16-7.2 16-16-7.2-16-16-16zm-96 0c-8.8 0-16 7.2-16 16v48h32v-48c0-8.8-7.2-16-16-16z"/></svg>';
function create_default_slot$g(ctx) {
  let header;
  let t0;
  let h3;
  let t2;
  let p0;
  let t4;
  let p1;
  let t6;
  let center;
  let span;
  let t7;
  let div;
  let button;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: { pops: true, title: "Not yet available" }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      h3 = element("h3");
      h3.textContent = "Nothing to see here!";
      t2 = space();
      p0 = element("p");
      p0.textContent = "This screen has not yet been implemented.";
      t4 = space();
      p1 = element("p");
      p1.textContent = "Please continue exploring the beta.";
      t6 = space();
      center = element("center");
      span = element("span");
      t7 = space();
      div = element("div");
      button = element("button");
      button.textContent = "Continue";
      attr(span, "class", "icon svelte-o7n71o");
      attr(button, "class", "primary");
      attr(div, "class", "action-line");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, h3, anchor);
      insert(target, t2, anchor);
      insert(target, p0, anchor);
      insert(target, t4, anchor);
      insert(target, p1, anchor);
      insert(target, t6, anchor);
      insert(target, center, anchor);
      append(center, span);
      span.innerHTML = SX_ICON_ASTRONAUT;
      insert(target, t7, anchor);
      insert(target, div, anchor);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(center);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$w(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 64) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let $yw_navigator;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(3, $yw_navigator = $$value));
  let { reset = false } = $$props;
  const b_reset = reset;
  const k_page = getContext("page");
  function cont() {
    if (b_reset) {
      k_page.reset();
      void $yw_navigator.activateThread(ThreadId.TOKENS);
    } else {
      k_page.pop();
    }
  }
  const click_handler2 = () => cont();
  $$self.$$set = ($$props2) => {
    if ("reset" in $$props2)
      $$invalidate(1, reset = $$props2.reset);
  };
  return [cont, reset, click_handler2];
}
class DeadEnd$1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$w, safe_not_equal, { reset: 1 });
  }
}
function create_default_slot_9(ctx) {
  let senderselect;
  let current;
  senderselect = new SenderSelect({});
  return {
    c() {
      create_component(senderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(senderselect, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(senderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(senderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(senderselect, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let recipientselect;
  let updating_error;
  let updating_address;
  let current;
  function recipientselect_error_binding(value) {
    ctx[37](value);
  }
  function recipientselect_address_binding(value) {
    ctx[38](value);
  }
  let recipientselect_props = {
    showValidation: ctx[4]
  };
  if (ctx[6] !== void 0) {
    recipientselect_props.error = ctx[6];
  }
  if (ctx[0] !== void 0) {
    recipientselect_props.address = ctx[0];
  }
  recipientselect = new RecipientSelect({ props: recipientselect_props });
  binding_callbacks.push(() => bind(recipientselect, "error", recipientselect_error_binding));
  binding_callbacks.push(() => bind(recipientselect, "address", recipientselect_address_binding));
  return {
    c() {
      create_component(recipientselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipientselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recipientselect_changes = {};
      if (dirty[0] & 16)
        recipientselect_changes.showValidation = ctx2[4];
      if (!updating_error && dirty[0] & 64) {
        updating_error = true;
        recipientselect_changes.error = ctx2[6];
        add_flush_callback(() => updating_error = false);
      }
      if (!updating_address && dirty[0] & 1) {
        updating_address = true;
        recipientselect_changes.address = ctx2[0];
        add_flush_callback(() => updating_address = false);
      }
      recipientselect.$set(recipientselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipientselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipientselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipientselect, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let div;
  let checkboxfield;
  let updating_checked;
  let current;
  function checkboxfield_checked_binding(value) {
    ctx[39](value);
  }
  let checkboxfield_props = {
    id: "save-contact",
    $$slots: { default: [create_default_slot_7$1] },
    $$scope: { ctx }
  };
  if (ctx[5] !== void 0) {
    checkboxfield_props.checked = ctx[5];
  }
  checkboxfield = new CheckboxField({ props: checkboxfield_props });
  binding_callbacks.push(() => bind(checkboxfield, "checked", checkboxfield_checked_binding));
  return {
    c() {
      div = element("div");
      create_component(checkboxfield.$$.fragment);
      attr(div, "class", "new-address svelte-1iq9fv7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkboxfield, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const checkboxfield_changes = {};
      if (dirty[1] & 8388608) {
        checkboxfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_checked && dirty[0] & 32) {
        updating_checked = true;
        checkboxfield_changes.checked = ctx2[5];
        add_flush_callback(() => updating_checked = false);
      }
      checkboxfield.$set(checkboxfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkboxfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(checkboxfield);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let t;
  return {
    c() {
      t = text("Save to contacts");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$2(ctx) {
  let span2;
  let span0;
  let raw_value = ctx[16].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[16].text + "";
  let t1;
  let span2_class_value;
  let t2;
  let if_block_anchor;
  let current;
  let if_block = ctx[9] && create_if_block_5(ctx);
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span0, "class", "icon svelte-1iq9fv7");
      attr(span1, "class", "text svelte-1iq9fv7");
      attr(span2, "class", span2_class_value = "status " + ctx[3] + " svelte-1iq9fv7");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      span0.innerHTML = raw_value;
      append(span2, t0);
      append(span2, span1);
      append(span1, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 65536) && raw_value !== (raw_value = ctx2[16].icon + ""))
        span0.innerHTML = raw_value;
      if ((!current || dirty[0] & 65536) && t1_value !== (t1_value = ctx2[16].text + ""))
        set_data(t1, t1_value);
      if (!current || dirty[0] & 8 && span2_class_value !== (span2_class_value = "status " + ctx2[3] + " svelte-1iq9fv7")) {
        attr(span2, "class", span2_class_value);
      }
      if (ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3$1(ctx) {
  let field;
  let current;
  field = new Field({
    props: {
      short: true,
      slides: true,
      key: "new-contact-name",
      name: "Contact Name",
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty[0] & 256 | dirty[1] & 8388608) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
    }
  };
}
function create_if_block_4$1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[8]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256)
        set_data(t, ctx2[8]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[8] && create_if_block_4$1(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "id", "new-contact-name-value");
      attr(input, "type", "text");
      toggle_class(input, "invalid", ctx[8]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[23]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256) {
        toggle_class(input, "invalid", ctx2[8]);
      }
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_4$3(ctx) {
  let assetselect;
  let updating_assetRef;
  let current;
  function assetselect_assetRef_binding(value) {
    ctx[40](value);
  }
  let assetselect_props = {};
  if (ctx[1] !== void 0) {
    assetselect_props.assetRef = ctx[1];
  }
  assetselect = new AssetSelect({ props: assetselect_props });
  binding_callbacks.push(() => bind(assetselect, "assetRef", assetselect_assetRef_binding));
  return {
    c() {
      create_component(assetselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(assetselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const assetselect_changes = {};
      if (!updating_assetRef && dirty[0] & 2) {
        updating_assetRef = true;
        assetselect_changes.assetRef = ctx2[1];
        add_flush_callback(() => updating_assetRef = false);
      }
      assetselect.$set(assetselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(assetselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(assetselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(assetselect, detaching);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let amountinput;
  let updating_error;
  let updating_value;
  let current;
  function amountinput_error_binding(value) {
    ctx[41](value);
  }
  function amountinput_value_binding(value) {
    ctx[42](value);
  }
  let amountinput_props = {
    bufferMax: ctx[10] ? x_fee : 0,
    assetRef: ctx[1],
    showValidation: ctx[4]
  };
  if (ctx[7] !== void 0) {
    amountinput_props.error = ctx[7];
  }
  if (ctx[2] !== void 0) {
    amountinput_props.value = ctx[2];
  }
  amountinput = new AmountInput({ props: amountinput_props });
  binding_callbacks.push(() => bind(amountinput, "error", amountinput_error_binding));
  binding_callbacks.push(() => bind(amountinput, "value", amountinput_value_binding));
  return {
    c() {
      create_component(amountinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(amountinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const amountinput_changes = {};
      if (dirty[0] & 1024)
        amountinput_changes.bufferMax = ctx2[10] ? x_fee : 0;
      if (dirty[0] & 2)
        amountinput_changes.assetRef = ctx2[1];
      if (dirty[0] & 16)
        amountinput_changes.showValidation = ctx2[4];
      if (!updating_error && dirty[0] & 128) {
        updating_error = true;
        amountinput_changes.error = ctx2[7];
        add_flush_callback(() => updating_error = false);
      }
      if (!updating_value && dirty[0] & 4) {
        updating_value = true;
        amountinput_changes.value = ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      amountinput.$set(amountinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(amountinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(amountinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(amountinput, detaching);
    }
  };
}
function create_if_block_2$2(ctx) {
  let span2;
  let span0;
  let t1;
  let span1;
  let t2;
  let t3;
  let t4;
  let t5;
  let span4;
  let span3;
  let mounted;
  let dispose;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      span0.textContent = "Balance";
      t1 = space();
      span1 = element("span");
      t2 = text(ctx[11]);
      t3 = space();
      t4 = text(ctx[19]);
      t5 = space();
      span4 = element("span");
      span3 = element("span");
      span3.textContent = "USE MAX";
      attr(span0, "class", "label svelte-1iq9fv7");
      attr(span1, "class", "amount svelte-1iq9fv7");
      attr(span2, "class", "balance svelte-1iq9fv7");
      attr(span3, "class", "link svelte-1iq9fv7");
      toggle_class(span3, "disabled", ctx[18]);
      attr(span4, "class", "use-max");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span2, t1);
      append(span2, span1);
      append(span1, t2);
      append(span1, t3);
      append(span1, t4);
      insert(target, t5, anchor);
      insert(target, span4, anchor);
      append(span4, span3);
      if (!mounted) {
        dispose = listen(span3, "click", ctx[43]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data(t2, ctx2[11]);
      if (dirty[0] & 524288)
        set_data(t4, ctx2[19]);
      if (dirty[0] & 262144) {
        toggle_class(span3, "disabled", ctx2[18]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(span4);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$3(ctx) {
  let span;
  let if_block = ctx[1] && create_if_block_2$2(ctx);
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      attr(span, "class", "balance-line svelte-1iq9fv7");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$2(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block)
        if_block.d();
    }
  };
}
function create_default_slot_1$5(ctx) {
  let div0;
  let t2;
  let div1;
  let t3;
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${x_fee} SCRT`;
      t2 = space();
      div1 = element("div");
      t3 = text(ctx[17]);
      attr(div0, "class", "fee-amount");
      attr(div1, "class", "fee-fiat svelte-1iq9fv7");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 131072)
        set_data(t3, ctx2[17]);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
    }
  };
}
function create_post_slot(ctx) {
  let div;
  let span0;
  let t1;
  let span1;
  return {
    c() {
      div = element("div");
      span0 = element("span");
      span0.textContent = "Set fee manually";
      t1 = space();
      span1 = element("span");
      attr(span0, "class", "link disabled svelte-1iq9fv7");
      attr(span1, "class", "icon info svelte-1iq9fv7");
      attr(div, "class", "manual-fee svelte-1iq9fv7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(div, t1);
      append(div, span1);
      span1.innerHTML = SX_ICON_INFO;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$4(ctx) {
  let span;
  let span_transition;
  let current;
  return {
    c() {
      span = element("span");
      span.textContent = "Caution: Memos are NOT private";
      attr(span, "class", "disclaimer svelte-1iq9fv7");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, slide, { duration: 350, delay: 400 }, true);
        span_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!span_transition)
        span_transition = create_bidirectional_transition(span, slide, { duration: 350, delay: 400 }, false);
      span_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_if_block$b(ctx) {
  let div;
  let textarea;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      attr(div, "class", "input");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      set_input_value(textarea, ctx[14]);
      current = true;
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[45]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 16384) {
        set_input_value(textarea, ctx2[14]);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 350 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 350 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$f(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let field1;
  let t2;
  let field2;
  let t3;
  let t4;
  let hr0;
  let t5;
  let field3;
  let t6;
  let field4;
  let t7;
  let field5;
  let t8;
  let hr1;
  let t9;
  let field6;
  let t10;
  let hr2;
  let t11;
  let div1;
  let div0;
  let span0;
  let t12;
  let span1;
  let t14;
  let t15;
  let t16;
  let actionsline;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: {
      pops: true,
      title: ctx[21] ? "Transferring" : "Sending",
      symbol: ctx[21] ? ctx[21].symbol : "",
      subtitle: ctx[12]?.name || "?"
    }
  });
  field0 = new Field({
    props: {
      short: true,
      key: "sender-select",
      name: "From",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      short: true,
      key: "recipient-select",
      name: "To",
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      short: true,
      key: "recipient-status",
      name: "",
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[9] && ctx[5] && create_if_block_3$1(ctx);
  field3 = new Field({
    props: {
      short: true,
      key: "asset-select",
      name: "Asset",
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      short: true,
      key: "amount",
      name: "Amount",
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  field5 = new Field({
    props: {
      short: true,
      key: "balance",
      name: "",
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  field6 = new Field({
    props: {
      short: true,
      key: "fee",
      name: "Fee",
      $$slots: {
        post: [create_post_slot],
        default: [create_default_slot_1$5]
      },
      $$scope: { ctx }
    }
  });
  let if_block1 = ctx[13] && create_if_block_1$4();
  let if_block2 = ctx[13] && create_if_block$b(ctx);
  actionsline = new ActionsLine({
    props: {
      cancel: "pop",
      confirm: ["Next", ctx[46], !ctx[15]]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      create_component(field1.$$.fragment);
      t2 = space();
      create_component(field2.$$.fragment);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      hr0 = element("hr");
      t5 = space();
      create_component(field3.$$.fragment);
      t6 = space();
      create_component(field4.$$.fragment);
      t7 = space();
      create_component(field5.$$.fragment);
      t8 = space();
      hr1 = element("hr");
      t9 = space();
      create_component(field6.$$.fragment);
      t10 = space();
      hr2 = element("hr");
      t11 = space();
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t12 = space();
      span1 = element("span");
      span1.textContent = "Add memo";
      t14 = space();
      if (if_block1)
        if_block1.c();
      t15 = space();
      if (if_block2)
        if_block2.c();
      t16 = space();
      create_component(actionsline.$$.fragment);
      attr(span0, "class", "icon dropdown svelte-1iq9fv7");
      attr(span1, "class", "text");
      attr(div0, "class", "title clickable svelte-1iq9fv7");
      attr(div1, "class", "memo svelte-1iq9fv7");
      toggle_class(div1, "expanded", ctx[13]);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      mount_component(field1, target, anchor);
      insert(target, t2, anchor);
      mount_component(field2, target, anchor);
      insert(target, t3, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t4, anchor);
      insert(target, hr0, anchor);
      insert(target, t5, anchor);
      mount_component(field3, target, anchor);
      insert(target, t6, anchor);
      mount_component(field4, target, anchor);
      insert(target, t7, anchor);
      mount_component(field5, target, anchor);
      insert(target, t8, anchor);
      insert(target, hr1, anchor);
      insert(target, t9, anchor);
      mount_component(field6, target, anchor);
      insert(target, t10, anchor);
      insert(target, hr2, anchor);
      insert(target, t11, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span0);
      span0.innerHTML = SX_ICON_DROPDOWN;
      append(div0, t12);
      append(div0, span1);
      append(div0, t14);
      if (if_block1)
        if_block1.m(div0, null);
      append(div1, t15);
      if (if_block2)
        if_block2.m(div1, null);
      insert(target, t16, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[44]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty[0] & 4096)
        header_changes.subtitle = ctx2[12]?.name || "?";
      header.$set(header_changes);
      const field0_changes = {};
      if (dirty[1] & 8388608) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty[0] & 81 | dirty[1] & 8388608) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty[0] & 66088 | dirty[1] & 8388608) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      if (ctx2[9] && ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 544) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t4.parentNode, t4);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const field3_changes = {};
      if (dirty[0] & 2 | dirty[1] & 8388608) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty[0] & 1174 | dirty[1] & 8388608) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      const field5_changes = {};
      if (dirty[0] & 788482 | dirty[1] & 8388608) {
        field5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field5.$set(field5_changes);
      const field6_changes = {};
      if (dirty[0] & 131072 | dirty[1] & 8388608) {
        field6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field6.$set(field6_changes);
      if (ctx2[13]) {
        if (if_block1) {
          if (dirty[0] & 8192) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$4();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[13]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 8192) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$b(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty[0] & 8192) {
        toggle_class(div1, "expanded", ctx2[13]);
      }
      const actionsline_changes = {};
      if (dirty[0] & 32768)
        actionsline_changes.confirm = ["Next", ctx2[46], !ctx2[15]];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(if_block0);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(field5.$$.fragment, local);
      transition_in(field6.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(if_block0);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(field5.$$.fragment, local);
      transition_out(field6.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t3);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(hr0);
      if (detaching)
        detach(t5);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t6);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t7);
      destroy_component(field5, detaching);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(hr1);
      if (detaching)
        detach(t9);
      destroy_component(field6, detaching);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(hr2);
      if (detaching)
        detach(t11);
      if (detaching)
        detach(div1);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach(t16);
      destroy_component(actionsline, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$v(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      form: true,
      slides: true,
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  screen.$on("submit", submit_handler);
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const screen_changes = {};
      if (dirty[0] & 1048575 | dirty[1] & 8388608) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
const si_versus = "usd";
let x_fee = 0.01;
const R_CONTACT_NAME = /^\S.{0,1023}$/;
const submit_handler = (d_submit) => {
  d_submit.preventDefault();
};
function instance$s($$self, $$props, $$invalidate) {
  let g_coin;
  let p_token;
  let s_symbol;
  let s_balance;
  let b_using_max;
  let si_coingecko;
  let s_fee_fiat;
  let g_address_type;
  let b_new_address;
  let s_err_new_contact;
  let b_form_valid;
  let $yw_network_active;
  let $yw_owner;
  let $yw_account;
  let $yw_chain;
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(34, $yw_network_active = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(35, $yw_owner = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(36, $yw_account = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(12, $yw_chain = $$value));
  const k_page = getContext("page");
  let { sender = null } = $$props;
  let { native = Object.keys($yw_chain.coins)[0] } = $$props;
  let si_native = native;
  let { token = null } = $$props;
  let g_token2 = token;
  let { recipient = "" } = $$props;
  let sa_recipient = recipient;
  let p_asset = si_native ? Entities.holdingPathFor($yw_owner, si_native) : "";
  let h_addr_to_contact;
  let b_busy_agents = false;
  async function reload_agents(b_init = false) {
    if (b_busy_agents)
      return;
    b_busy_agents = true;
    const ks_agents = await Agents.read();
    const a_contacts = [...ks_agents.contacts()];
    $$invalidate(28, h_addr_to_contact = fold(a_contacts, ([p_contact, g_contact]) => ({
      [Chains.bech32(g_contact.address)]: p_contact
    })));
    b_busy_agents = false;
  }
  {
    const f_unsub_agents = subscribe_store("agents", reload_agents);
    const f_unsub_chain = yw_chain.subscribe(reload_agents);
    onDestroy(() => {
      f_unsub_agents();
      f_unsub_chain();
    });
  }
  let yg_balance = null;
  let s_amount = "";
  function use_max() {
    $$invalidate(2, s_amount = s_balance);
    if (g_coin) {
      $$invalidate(2, s_amount = new BigNumber(s_amount).minus(x_fee).toString());
    }
    $$invalidate(4, c_show_validations++, c_show_validations);
  }
  let x_worth = null;
  const H_ADDRESS_TYPES = {
    none: { icon: "<svg></svg>", text: "" },
    unknown: {
      icon: SX_ICON_LOADING,
      text: "Determining address type..."
    },
    personal: {
      icon: SX_ICON_CONTACTS$1,
      text: "Personal address"
    },
    contract: {
      icon: SX_ICON_CONTRACT,
      text: "Contract address"
    }
  };
  let si_address_type = "none";
  let b_memo_expanded = false;
  let s_memo = "";
  let c_show_validations = 0;
  let b_checked_save_contact = false;
  let s_err_recipient = "";
  let s_err_amount = "";
  let s_new_contact = "";
  function input_new_contact(d_event) {
    $$invalidate(31, s_new_contact = d_event.target.value);
  }
  function recipientselect_error_binding(value) {
    s_err_recipient = value;
    $$invalidate(6, s_err_recipient);
  }
  function recipientselect_address_binding(value) {
    sa_recipient = value;
    $$invalidate(0, sa_recipient);
  }
  function checkboxfield_checked_binding(value) {
    b_checked_save_contact = value;
    $$invalidate(5, b_checked_save_contact);
  }
  function assetselect_assetRef_binding(value) {
    p_asset = value;
    $$invalidate(1, p_asset);
  }
  function amountinput_error_binding(value) {
    s_err_amount = value;
    $$invalidate(7, s_err_amount);
  }
  function amountinput_value_binding(value) {
    s_amount = value;
    $$invalidate(2, s_amount);
  }
  const click_handler2 = () => use_max();
  const click_handler_1 = () => $$invalidate(13, b_memo_expanded = !b_memo_expanded);
  function textarea_input_handler() {
    s_memo = this.value;
    $$invalidate(14, s_memo);
  }
  const func = () => k_page.push({ creator: DeadEnd$1, props: {} });
  $$self.$$set = ($$props2) => {
    if ("sender" in $$props2)
      $$invalidate(24, sender = $$props2.sender);
    if ("native" in $$props2)
      $$invalidate(25, native = $$props2.native);
    if ("token" in $$props2)
      $$invalidate(26, token = $$props2.token);
    if ("recipient" in $$props2)
      $$invalidate(27, recipient = $$props2.recipient);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4098) {
      $$invalidate(10, g_coin = p_asset && Entities.parseEntityPath(p_asset)?.type === "holding" && si_native ? $yw_chain.coins?.[si_native] : null);
    }
    if ($$self.$$.dirty[0] & 2) {
      $$invalidate(33, p_token = p_asset && Entities.parseEntityPath(p_asset)?.type === "token" && g_token2 ? Entities.pathFrom(g_token2) : "");
    }
    if ($$self.$$.dirty[0] & 1026 | $$self.$$.dirty[1] & 4) {
      {
        console.log({
          si_native,
          g_coin,
          p_asset,
          p_token,
          g_token: g_token2
        });
      }
    }
    if ($$self.$$.dirty[0] & 2 | $$self.$$.dirty[1] & 56) {
      {
        if ($yw_account && p_asset) {
          $$invalidate(29, yg_balance = null);
          queueMicrotask(async () => {
            $$invalidate(11, s_balance = "[...]");
            const g_cached = $yw_network_active.cachedBalance($yw_owner, si_native);
            if (g_cached && g_cached.timestamp > Date.now() - 5 * XT_MINUTES) {
              $$invalidate(29, yg_balance = new BigNumber(g_cached.data.amount));
            }
            const g_bundle = await $yw_network_active.bankBalance($yw_owner, si_native);
            if (g_bundle) {
              $$invalidate(29, yg_balance = new BigNumber(g_bundle.balance.amount));
            }
          });
        }
      }
    }
    if ($$self.$$.dirty[0] & 536871936) {
      $$invalidate(11, s_balance = yg_balance ? format_amount(yg_balance.shiftedBy(-(g_coin || g_token2).decimals).toNumber()) : "");
    }
    if ($$self.$$.dirty[0] & 2052) {
      $$invalidate(18, b_using_max = s_amount === s_balance);
    }
    if ($$self.$$.dirty[0] & 1024) {
      $$invalidate(32, si_coingecko = (g_token2 || g_coin)?.extra?.coingecko_id || "");
    }
    if ($$self.$$.dirty[0] & 1073741824 | $$self.$$.dirty[1] & 2) {
      {
        if (si_coingecko) {
          (async () => {
            const h_versus = await CoinGecko.coinsVersus([si_coingecko], si_versus);
            $$invalidate(30, x_worth = h_versus[si_coingecko]);
            if (typeof x_worth === "number") {
              format_fiat(x_worth);
            }
          })();
        }
      }
    }
    if ($$self.$$.dirty[0] & 1073741824) {
      $$invalidate(17, s_fee_fiat = typeof x_worth === "number" ? format_fiat(x_fee * x_worth) : "");
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 8) {
      {
        if (!sa_recipient) {
          $$invalidate(3, si_address_type = "none");
        } else {
          $$invalidate(3, si_address_type = "unknown");
          (async () => {
            if (await $yw_network_active.isContract(sa_recipient)) {
              $$invalidate(3, si_address_type = "contract");
            } else {
              $$invalidate(3, si_address_type = "personal");
            }
          })();
        }
      }
    }
    if ($$self.$$.dirty[0] & 8) {
      $$invalidate(16, g_address_type = H_ADDRESS_TYPES[si_address_type]);
    }
    if ($$self.$$.dirty[0] & 268435457) {
      $$invalidate(9, b_new_address = sa_recipient && h_addr_to_contact && !(sa_recipient in h_addr_to_contact));
    }
    if ($$self.$$.dirty[0] & 48 | $$self.$$.dirty[1] & 1) {
      $$invalidate(8, s_err_new_contact = b_checked_save_contact && (c_show_validations || true) ? s_new_contact ? R_CONTACT_NAME.test(s_new_contact) ? "" : s_new_contact.length > 1024 ? "That name is way too long" : "Cannot begin with space" : "Enter a contact name to save new address" : "");
    }
    if ($$self.$$.dirty[0] & 48) {
      {
        if (b_checked_save_contact && !c_show_validations) {
          $$invalidate(8, s_err_new_contact = "");
        }
      }
    }
    if ($$self.$$.dirty[0] & 997 | $$self.$$.dirty[1] & 1) {
      $$invalidate(15, b_form_valid = sa_recipient && s_amount && !s_err_recipient && !s_err_amount && (!b_new_address || !b_checked_save_contact || s_new_contact && !s_err_new_contact) || false);
    }
    if ($$self.$$.dirty[0] & 197) {
      {
        console.log({
          to: sa_recipient,
          s_amount,
          s_err_recipient,
          s_err_amount
        });
      }
    }
  };
  $$invalidate(19, s_symbol = si_native || g_token2?.symbol || "");
  return [
    sa_recipient,
    p_asset,
    s_amount,
    si_address_type,
    c_show_validations,
    b_checked_save_contact,
    s_err_recipient,
    s_err_amount,
    s_err_new_contact,
    b_new_address,
    g_coin,
    s_balance,
    $yw_chain,
    b_memo_expanded,
    s_memo,
    b_form_valid,
    g_address_type,
    s_fee_fiat,
    b_using_max,
    s_symbol,
    k_page,
    g_token2,
    use_max,
    input_new_contact,
    sender,
    native,
    token,
    recipient,
    h_addr_to_contact,
    yg_balance,
    x_worth,
    s_new_contact,
    si_coingecko,
    p_token,
    $yw_network_active,
    $yw_owner,
    $yw_account,
    recipientselect_error_binding,
    recipientselect_address_binding,
    checkboxfield_checked_binding,
    assetselect_assetRef_binding,
    amountinput_error_binding,
    amountinput_value_binding,
    click_handler2,
    click_handler_1,
    textarea_input_handler,
    func
  ];
}
class Send extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$v, safe_not_equal, {
      sender: 24,
      native: 25,
      token: 26,
      recipient: 27
    }, null, [-1, -1]);
  }
}
function create_fragment$u(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "\xA0";
      attr(div, "class", "gap no-margin svelte-1rn5flx");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class Gap extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$u, safe_not_equal, {});
  }
}
const get_suffix_slot_changes = (dirty) => ({});
const get_suffix_slot_context = (ctx) => ({});
function get_each_context$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  child_ctx[18] = i;
  return child_ctx;
}
const get_prefix_slot_changes = (dirty) => ({});
const get_prefix_slot_context = (ctx) => ({});
function create_if_block_4(ctx) {
  let span;
  let span_class_value;
  let current;
  const prefix_slot_template = ctx[13].prefix;
  const prefix_slot = create_slot(prefix_slot_template, ctx, ctx[12], get_prefix_slot_context);
  return {
    c() {
      span = element("span");
      if (prefix_slot)
        prefix_slot.c();
      attr(span, "class", span_class_value = "prefix " + ctx[1] + " svelte-12kzkkx");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (prefix_slot) {
        prefix_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (prefix_slot) {
        if (prefix_slot.p && (!current || dirty & 4096)) {
          update_slot_base(prefix_slot, prefix_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(prefix_slot_template, ctx2[12], dirty, get_prefix_slot_changes), get_prefix_slot_context);
        }
      }
      if (!current || dirty & 2 && span_class_value !== (span_class_value = "prefix " + ctx2[1] + " svelte-12kzkkx")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(prefix_slot, local);
      current = true;
    },
    o(local) {
      transition_out(prefix_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (prefix_slot)
        prefix_slot.d(detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 16,
      circular: true,
      name: ctx[16].name,
      ref: ctx[16].pfpPath
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = {};
      if (dirty & 1)
        pfpdisplay_changes.name = ctx2[16].name;
      if (dirty & 1)
        pfpdisplay_changes.ref = ctx2[16].pfpPath;
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let span;
  let t_value = ctx[16].name + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "label svelte-12kzkkx");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[16].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$3(ctx) {
  let span;
  let mounted;
  let dispose;
  function click_handler2() {
    return ctx[14](ctx[16]);
  }
  return {
    c() {
      span = element("span");
      attr(span, "class", "delete icon svelte-12kzkkx");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_ADD$1;
      if (!mounted) {
        dispose = listen(span, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$9(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  let span_outro;
  let current;
  let if_block0 = ctx[16].pfpPath && create_if_block_3(ctx);
  let if_block1 = !ctx[6] && create_if_block_2$1(ctx);
  let if_block2 = ctx[5] && create_if_block_1$3(ctx);
  return {
    c() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      attr(span, "class", "item svelte-12kzkkx");
      set_style(span, "background-color", ctx[16].color || "transparent");
      toggle_class(span, "collapsed", ctx[6]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append(span, t0);
      if (if_block1)
        if_block1.m(span, null);
      append(span, t1);
      if (if_block2)
        if_block2.m(span, null);
      append(span, t2);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (ctx[16].pfpPath) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!ctx[6])
        if_block1.p(ctx, dirty);
      if (ctx[5])
        if_block2.p(ctx, dirty);
      if (!current || dirty & 1) {
        set_style(span, "background-color", ctx[16].color || "transparent");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      if (span_outro)
        span_outro.end(1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      span_outro = create_out_transition(span, ctx[8], {
        duration: ctx[5] ? 300 : 0
      });
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (detaching && span_outro)
        span_outro.end();
    }
  };
}
function create_if_block$a(ctx) {
  let span;
  let span_class_value;
  let current;
  const suffix_slot_template = ctx[13].suffix;
  const suffix_slot = create_slot(suffix_slot_template, ctx, ctx[12], get_suffix_slot_context);
  return {
    c() {
      span = element("span");
      if (suffix_slot)
        suffix_slot.c();
      attr(span, "class", span_class_value = "suffix " + ctx[2] + " svelte-12kzkkx");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (suffix_slot) {
        suffix_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (suffix_slot) {
        if (suffix_slot.p && (!current || dirty & 4096)) {
          update_slot_base(suffix_slot, suffix_slot_template, ctx2, ctx2[12], !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(suffix_slot_template, ctx2[12], dirty, get_suffix_slot_changes), get_suffix_slot_context);
        }
      }
      if (!current || dirty & 4 && span_class_value !== (span_class_value = "suffix " + ctx2[2] + " svelte-12kzkkx")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(suffix_slot, local);
      current = true;
    },
    o(local) {
      transition_out(suffix_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (suffix_slot)
        suffix_slot.d(detaching);
    }
  };
}
function create_fragment$t(ctx) {
  let span;
  let t0;
  let each_1_anchor;
  let t1;
  let current;
  let if_block0 = ctx[9].prefix && create_if_block_4(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block1 = ctx[9].suffix && create_if_block$a(ctx);
  return {
    c() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr(span, "class", "cluster svelte-12kzkkx");
      attr(span, "style", ctx[3]);
      toggle_class(span, "editable", ctx[5]);
      toggle_class(span, "collapsed", ctx[6]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append(span, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span, null);
      }
      append(span, each_1_anchor);
      append(span, t1);
      if (if_block1)
        if_block1.m(span, null);
      ctx[15](span);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[9].prefix) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & 225) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (ctx2[9].suffix) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$a(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 8) {
        attr(span, "style", ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      ctx[15](null);
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { items } = $$props;
  let { editable = false } = $$props;
  const b_editable = editable;
  let { collapsed = false } = $$props;
  const b_collapsed = collapsed;
  let { prefixClass = "" } = $$props;
  let { suffixClass = "" } = $$props;
  let { rootStyle = "" } = $$props;
  let dm_cluster;
  function remove_item(g_item) {
    const i_item = items.findIndex((g) => g.id === g_item.id);
    items.splice(i_item, 1);
    $$invalidate(0, items);
  }
  function sslide(dm_node, { delay: xt_delay = 0, duration: xt_duration = 400, easing: f_easing = cubicOut } = {}) {
    const d_style = getComputedStyle(dm_node);
    const x_opacity = +d_style.opacity;
    const x_width = parseFloat(d_style.width);
    const x_padding_left = parseFloat(d_style.paddingLeft);
    const x_padding_right = parseFloat(d_style.paddingRight);
    const x_margin_left = parseFloat(d_style.marginLeft);
    const x_margin_right = parseFloat(d_style.marginRight);
    const x_border_left_width = parseFloat(d_style.borderLeftWidth);
    const x_border_right_width = parseFloat(d_style.borderRightWidth);
    return {
      delay: xt_delay,
      duration: xt_duration,
      easing: f_easing,
      css: (xt) => `--delete-display: none;overflow: hidden;opacity: ${Math.min(xt * 20, 1) * x_opacity};width: ${xt * x_width}px;padding-left: ${xt * x_padding_left}px;padding-right: ${xt * x_padding_right}px;margin-left: ${xt * x_margin_left}px;margin-right: ${xt * x_margin_right}px;border-left-width: ${xt * x_border_left_width}px;border-right-width: ${xt * x_border_right_width}px;`
    };
  }
  const click_handler2 = (g_item) => remove_item(g_item);
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_cluster = $$value;
      $$invalidate(4, dm_cluster);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("editable" in $$props2)
      $$invalidate(10, editable = $$props2.editable);
    if ("collapsed" in $$props2)
      $$invalidate(11, collapsed = $$props2.collapsed);
    if ("prefixClass" in $$props2)
      $$invalidate(1, prefixClass = $$props2.prefixClass);
    if ("suffixClass" in $$props2)
      $$invalidate(2, suffixClass = $$props2.suffixClass);
    if ("rootStyle" in $$props2)
      $$invalidate(3, rootStyle = $$props2.rootStyle);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  return [
    items,
    prefixClass,
    suffixClass,
    rootStyle,
    dm_cluster,
    b_editable,
    b_collapsed,
    remove_item,
    sslide,
    $$slots,
    editable,
    collapsed,
    $$scope,
    slots,
    click_handler2,
    span_binding
  ];
}
class InlinePills extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$t, safe_not_equal, {
      items: 0,
      editable: 10,
      collapsed: 11,
      prefixClass: 1,
      suffixClass: 2,
      rootStyle: 3
    });
  }
}
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  return child_ctx;
}
function create_if_block$9(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[2][ctx[1].id];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 14) {
        each_value = ctx2[2][ctx2[1].id];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$8(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_right_slot(ctx) {
  let span;
  let t;
  let mounted;
  let dispose;
  function click_handler2() {
    return ctx[5](ctx[6]);
  }
  return {
    c() {
      span = element("span");
      t = space();
      attr(span, "class", "add icon text-align_right");
      set_style(span, "--icon-diameter", "22px");
      set_style(span, "--icon-color", "var(--theme-color-primary)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_ADD$1;
      insert(target, t, anchor);
      if (!mounted) {
        dispose = listen(span, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$8(ctx) {
  let row;
  let div;
  let current;
  row = new Row({
    props: {
      resource: ctx[6],
      postname: ctx[6].symbol,
      pfpDim: 32,
      $$slots: { right: [create_right_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(row.$$.fragment);
      set_style(div, "display", "contents");
      set_style(div, "--icon-diameter", "32px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(row, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const row_changes = {};
      if (dirty & 2)
        row_changes.resource = ctx2[6];
      if (dirty & 2)
        row_changes.postname = ctx2[6].symbol;
      if (dirty & 514) {
        row_changes.$$scope = { dirty, ctx: ctx2 };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(row, detaching);
    }
  };
}
function create_default_slot$e(ctx) {
  let header;
  let t0;
  let div;
  let inlinepills;
  let updating_items;
  let t1;
  let if_block_anchor;
  let current;
  header = new Header({
    props: { pops: true, title: "Add Tokens" }
  });
  function inlinepills_items_binding(value) {
    ctx[4](value);
  }
  let inlinepills_props = {};
  if (ctx[0] !== void 0) {
    inlinepills_props.items = ctx[0];
  }
  inlinepills = new InlinePills({ props: inlinepills_props });
  binding_callbacks.push(() => bind(inlinepills, "items", inlinepills_items_binding));
  let if_block = ctx[2][ctx[1].id] && create_if_block$9(ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      div = element("div");
      create_component(inlinepills.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(div, "class", "staged svelte-18quu74");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, div, anchor);
      mount_component(inlinepills, div, null);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinepills_changes = {};
      if (!updating_items && dirty & 1) {
        updating_items = true;
        inlinepills_changes.items = ctx2[0];
        add_flush_callback(() => updating_items = false);
      }
      inlinepills.$set(inlinepills_changes);
      if (ctx2[2][ctx2[1].id]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(inlinepills.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(inlinepills.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      destroy_component(inlinepills);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$s(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 515) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let $yw_chain;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(1, $yw_chain = $$value));
  const H_REGISTRY = {
    "pulsar-2": [
      {
        chain: "/family.cosmos/chain.pulsar-2",
        name: "Secret Secret",
        symbol: "sSCRT",
        pfp: "/template.pfp/id.1",
        hash: "9587D60B8E6B078ACE12014CEEEE089530B9FABCD76535D93666A6C127AD8813",
        extra: { coingecko_id: "secret" },
        origin: "built-in",
        spec: "snip-20",
        bech32: "secret18vd8fpwxzck93qlwghaj6arh4p7c5n8978vsyg"
      }
    ]
  };
  let a_staged = [];
  function add_token(g_token2) {
    $$invalidate(0, a_staged = a_staged.concat([
      {
        id: g_token2.bech32,
        name: g_token2.name,
        pfpPath: g_token2.pfp,
        data: g_token2
      }
    ]));
  }
  function inlinepills_items_binding(value) {
    a_staged = value;
    $$invalidate(0, a_staged);
  }
  const click_handler2 = (g_token2) => add_token(g_token2);
  return [
    a_staged,
    $yw_chain,
    H_REGISTRY,
    add_token,
    inlinepills_items_binding,
    click_handler2
  ];
}
class TokensAdd extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$s, safe_not_equal, {});
  }
}
function as_amount(g_balance, g_coin) {
  const s_norm = g_balance.amount.padStart(g_coin.decimals + 2, "0");
  return s_norm.slice(0, -g_coin.decimals).replace(/^0+/, "0") + "." + s_norm.slice(-g_coin.decimals);
}
async function to_fiat(g_balance, g_coin, si_versus2 = "usd") {
  if (g_balance.amount === "0")
    return new BigNumber(0);
  const si_gecko = g_coin.extra.coingecko_id;
  const g_versus = await CoinGecko.coinsVersus([si_gecko], si_versus2);
  return new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals).times(g_versus[si_gecko]);
}
async function coin_formats(g_balance, g_coin, si_versus2 = "usd") {
  const si_gecko = g_coin.extra.coingecko_id;
  const g_versus = await CoinGecko.coinsVersus([si_gecko], si_versus2);
  const x_worth = g_versus[si_gecko];
  const yg_balance = new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals).times(x_worth);
  return {
    versus: si_versus2,
    balance: yg_balance,
    fiat: yg_balance.times(x_worth).toNumber(),
    worth: x_worth
  };
}
function create_default_slot$d(ctx) {
  let header;
  let t0;
  let portrait;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      pops: true,
      account: true,
      network: true,
      title: ctx[3],
      subtitle: ctx[4]
    }
  });
  portrait = new Portrait({
    props: {
      pfp: ctx[2],
      resource: ctx[1] || g_token || null,
      resourcePath: ctx[8],
      title: ctx[5] ? `${format_amount(ctx[5].toNumber())} ${ctx[3]}` : "...",
      subtitle: `${ctx[6]} (${ctx[7]} per ${ctx[0]})`,
      actions: ctx[9]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(portrait.$$.fragment);
      t1 = space();
      div = element("div");
      attr(div, "class", "txns no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(portrait, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & 8)
        header_changes.title = ctx2[3];
      if (dirty & 16)
        header_changes.subtitle = ctx2[4];
      header.$set(header_changes);
      const portrait_changes = {};
      if (dirty & 4)
        portrait_changes.pfp = ctx2[2];
      if (dirty & 2)
        portrait_changes.resource = ctx2[1] || g_token || null;
      if (dirty & 40)
        portrait_changes.title = ctx2[5] ? `${format_amount(ctx2[5].toNumber())} ${ctx2[3]}` : "...";
      if (dirty & 193)
        portrait_changes.subtitle = `${ctx2[6]} (${ctx2[7]} per ${ctx2[0]})`;
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$r(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "HoldingView",
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 262399) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
let g_token = null;
function instance$p($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_network_active;
  let $yw_chain_ref;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(13, $yw_chain = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(14, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(15, $yw_chain_ref = $$value));
  const k_page = getContext("page");
  let { entityRef } = $$props;
  const p_entity = entityRef;
  let si_type = "";
  let si_coin = "";
  let g_coin = null;
  let p_pfp = "";
  let s_symbol = "";
  let s_name = "";
  let yg_amount = null;
  let s_fiat = "";
  let s_worth = "";
  async function load_entity() {
    await Entities.read();
    const g_info = Entities.parseEntityPath(p_entity);
    if (!g_info) {
      throw new Error(`Attempted to load holding view on non-entity path "${p_entity}"`);
    }
    switch (g_info.type) {
      case "holding": {
        $$invalidate(0, si_type = "coin");
        ({ coin: si_coin } = g_info);
        const p_chain = g_info.chainRef;
        const g_chain = p_chain === $yw_chain_ref ? $yw_chain : await Chains.at(p_chain);
        $$invalidate(1, g_coin = g_chain.coins[si_coin]);
        $$invalidate(3, s_symbol = si_coin);
        $$invalidate(4, s_name = g_coin.name);
        $$invalidate(2, p_pfp = g_coin.pfp);
        const g_cached = $yw_network_active.cachedBalance(g_info.bech32, si_coin);
        let g_balance;
        if (g_cached && g_cached.timestamp >= Date.now() - 2 * XT_MINUTES) {
          g_balance = g_cached.data;
        } else {
          ({ balance: g_balance } = await $yw_network_active.bankBalance(g_info.bech32, si_coin));
        }
        $$invalidate(5, yg_amount = new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals));
        void coin_formats(g_balance, g_coin).then((g_formats) => {
          $$invalidate(6, s_fiat = format_fiat(g_formats.fiat, g_formats.versus));
          $$invalidate(7, s_worth = format_fiat(g_formats.worth, g_formats.versus));
        });
        break;
      }
      case "token": {
        $$invalidate(0, si_type = "token");
        const ks_entites = await Entities.read();
        ks_entites.tokens(g_info.entityRef, Entities.fungibleInterfacesFor($yw_chain));
        debugger;
        break;
      }
      default: {
        throw new Error(`Unhandled entity type: "${g_info.type}"`);
      }
    }
  }
  load_entity();
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: si_coin ? { native: SI_STORE_CHAINS } : {}
        });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("entityRef" in $$props2)
      $$invalidate(10, entityRef = $$props2.entityRef);
  };
  return [
    si_type,
    g_coin,
    p_pfp,
    s_symbol,
    s_name,
    yg_amount,
    s_fiat,
    s_worth,
    p_entity,
    gc_actions,
    entityRef
  ];
}
class HoldingView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$r, safe_not_equal, { entityRef: 10 });
  }
}
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i][0];
  child_ctx[25] = list[i][1];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i][0];
  child_ctx[34] = list[i][1];
  child_ctx[35] = list[i][2];
  child_ctx[36] = list[i][3];
  const constants_0 = Entities.holdingPathFor(child_ctx[3], child_ctx[28]);
  child_ctx[30] = constants_0;
  const constants_1 = {
    name: child_ctx[28],
    pfp: child_ctx[0].pfp
  };
  child_ctx[37] = constants_1;
  const constants_2 = child_ctx[36](to_fiat(child_ctx[35], child_ctx[34]));
  child_ctx[38] = constants_2;
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i][0];
  child_ctx[29] = list[i][1];
  const constants_0 = Entities.holdingPathFor(child_ctx[3], child_ctx[28]);
  child_ctx[30] = constants_0;
  return child_ctx;
}
function create_if_block_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "TESETNET";
      attr(div, "class", "testnet-reminder no-margin svelte-8v4b7t");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$8(ctx) {
  let div2;
  let div0;
  let span;
  let t1;
  let t2_value = ctx[0].testnet ? "testnet " : "";
  let t2;
  let t3_value = ctx[1].join(" or ") + "";
  let t3;
  let t4;
  let t5;
  let div1;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].testnet)
      return create_if_block_1$2;
    return create_else_block$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span = element("span");
      span.textContent = "Warning:";
      t1 = text(" you don't have any ");
      t2 = text(t2_value);
      t3 = text(t3_value);
      t4 = text(" to pay gas fees.");
      t5 = space();
      div1 = element("div");
      if_block.c();
      attr(span, "class", "warning");
      attr(div0, "class", "message svelte-8v4b7t");
      attr(div1, "class", "buttons");
      attr(div2, "class", "no-gas text-align_center subinfo svelte-8v4b7t");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span);
      append(div0, t1);
      append(div0, t2);
      append(div0, t3);
      append(div0, t4);
      append(div2, t5);
      append(div2, div1);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t2_value !== (t2_value = ctx2[0].testnet ? "testnet " : ""))
        set_data(t2, t2_value);
      if (dirty[0] & 2 && t3_value !== (t3_value = ctx2[1].join(" or ") + ""))
        set_data(t3, t3_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_block.d();
    }
  };
}
function create_else_block$2(ctx) {
  let button;
  let t0;
  let t1_value = ctx[1].join(" or ") + "";
  let t1;
  return {
    c() {
      button = element("button");
      t0 = text("Buy ");
      t1 = text(t1_value);
      attr(button, "class", "pill");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t1_value !== (t1_value = ctx2[1].join(" or ") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
    }
  };
}
function create_if_block_1$2(ctx) {
  let button;
  let t0;
  let t1_value = ctx[1].join(" or ") + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text("Get ");
      t1 = text(t1_value);
      t2 = text(" from faucet");
      attr(button, "class", "pill");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t1_value !== (t1_value = ctx2[1].join(" or ") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block_1(ctx) {
  let t;
  let div;
  let address;
  let current;
  let if_block = ctx[1].length && create_if_block$8(ctx);
  address = new Address({
    props: {
      address: ctx[3],
      copyable: "text"
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      create_component(address.$$.fragment);
      attr(div, "class", "owner-address subinfo svelte-8v4b7t");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      mount_component(address, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const address_changes = {};
      if (dirty[0] & 8)
        address_changes.address = ctx2[3];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      destroy_component(address);
    }
  };
}
function create_catch_block_1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ctx[33];
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 777) {
        each_value_2 = ctx2[33];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_2(ctx) {
  let row;
  let current;
  function click_handler_2() {
    return ctx[18](ctx[30]);
  }
  row = new Row({
    props: {
      lockIcon: true,
      detail: "Native Coin",
      resourcePath: ctx[30],
      resource: ctx[37],
      amount: as_amount(ctx[35], ctx[34]),
      fiat: ctx[38].then(ctx[17])
    }
  });
  row.$on("click", click_handler_2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 8)
        row_changes.resourcePath = ctx[30];
      if (dirty[0] & 1)
        row_changes.resource = ctx[37];
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ode(ctx[0].coins);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 265) {
        each_value_1 = ode(ctx2[0].coins);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_1$2(ctx) {
  let row;
  let current;
  function click_handler_1() {
    return ctx[16](ctx[30]);
  }
  row = new Row({
    props: {
      lockIcon: true,
      detail: "Native Coin",
      name: ctx[28],
      pfp: ctx[0].pfp,
      amount: forever()
    }
  });
  row.$on("click", click_handler_1);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 1)
        row_changes.name = ctx[28];
      if (dirty[0] & 1)
        row_changes.pfp = ctx[0].pfp;
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_catch_block$7(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$7(ctx) {
  let each_1_anchor;
  let each_value = ode(ctx[7](ctx[23]));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 129) {
        each_value = ode(ctx2[7](ctx2[23]));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$7(ctx) {
  let t_value = ctx[25].spec + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t_value !== (t_value = ctx2[25].spec + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block$7(ctx) {
  let t;
  return {
    c() {
      t = text("Loading tokens...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_key_block$1(ctx) {
  let div;
  let t;
  let promise_1;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 33,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  let info_1 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$7,
    then: create_then_block$7,
    catch: create_catch_block$7,
    value: 23
  };
  handle_promise(promise_1 = Entities.readFungibleTokens(ctx[0]), info_1);
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      info_1.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      info_1.block.m(div, info_1.anchor = null);
      info_1.mount = () => div;
      info_1.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      info_1.ctx = ctx;
      if (dirty[0] & 1 && promise_1 !== (promise_1 = Entities.readFungibleTokens(ctx[0])) && handle_promise(promise_1, info_1))
        ;
      else {
        update_await_block_branch(info_1, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      info_1.block.d();
      info_1.token = null;
      info_1 = null;
    }
  };
}
function create_default_slot$c(ctx) {
  let header;
  let t0;
  let t1;
  let portrait;
  let t2;
  let previous_key = ctx[0];
  let t3;
  let gap;
  let t4;
  let previous_key_1 = ctx[4];
  let key_block1_anchor;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  let if_block = ctx[0].testnet && create_if_block_2();
  portrait = new Portrait({
    props: {
      title: ctx[2],
      subtitle: ctx[5].name,
      resource: ctx[5],
      resourcePath: ctx[6],
      actions: {
        send: { label: "Send", trigger: ctx[12] },
        recv: {
          label: "Receive",
          trigger: ctx[13]
        },
        add: {
          label: "Add Token",
          trigger: ctx[14]
        }
      }
    }
  });
  let key_block0 = create_key_block_1(ctx);
  gap = new Gap({});
  let key_block1 = create_key_block$1(ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(portrait.$$.fragment);
      t2 = space();
      key_block0.c();
      t3 = space();
      create_component(gap.$$.fragment);
      t4 = space();
      key_block1.c();
      key_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(portrait, target, anchor);
      insert(target, t2, anchor);
      key_block0.m(target, anchor);
      insert(target, t3, anchor);
      mount_component(gap, target, anchor);
      insert(target, t4, anchor);
      key_block1.m(target, anchor);
      insert(target, key_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0].testnet) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_2();
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const portrait_changes = {};
      if (dirty[0] & 4)
        portrait_changes.title = ctx2[2];
      if (dirty[0] & 32)
        portrait_changes.subtitle = ctx2[5].name;
      if (dirty[0] & 32)
        portrait_changes.resource = ctx2[5];
      if (dirty[0] & 64)
        portrait_changes.resourcePath = ctx2[6];
      if (dirty[0] & 96)
        portrait_changes.actions = {
          send: { label: "Send", trigger: ctx2[12] },
          recv: {
            label: "Receive",
            trigger: ctx2[13]
          },
          add: {
            label: "Add Token",
            trigger: ctx2[14]
          }
        };
      portrait.$set(portrait_changes);
      if (dirty[0] & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block0, 1, 1, noop);
        check_outros();
        key_block0 = create_key_block_1(ctx2);
        key_block0.c();
        transition_in(key_block0, 1);
        key_block0.m(t3.parentNode, t3);
      } else {
        key_block0.p(ctx2, dirty);
      }
      if (dirty[0] & 16 && safe_not_equal(previous_key_1, previous_key_1 = ctx2[4])) {
        group_outros();
        transition_out(key_block1, 1, 1, noop);
        check_outros();
        key_block1 = create_key_block$1(ctx2);
        key_block1.c();
        transition_in(key_block1, 1);
        key_block1.m(key_block1_anchor.parentNode, key_block1_anchor);
      } else {
        key_block1.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(portrait.$$.fragment, local);
      transition_in(key_block0);
      transition_in(gap.$$.fragment, local);
      transition_in(key_block1);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(portrait.$$.fragment, local);
      transition_out(key_block0);
      transition_out(gap.$$.fragment, local);
      transition_out(key_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t2);
      key_block0.d(detaching);
      if (detaching)
        detach(t3);
      destroy_component(gap, detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(key_block1_anchor);
      key_block1.d(detaching);
    }
  };
}
function create_fragment$q(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "HoldingsHome",
      nav: true,
      root: true,
      keyed: true,
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const screen_changes = {};
      if (dirty[0] & 127 | dirty[1] & 1024) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_owner;
  let $yw_network_active;
  let $yw_account;
  let $yw_account_ref;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(0, $yw_chain = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(3, $yw_owner = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(4, $yw_network_active = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(5, $yw_account = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(6, $yw_account_ref = $$value));
  const merge_fungible_tokens = (h_fungibles) => oderom(h_fungibles, (_, h) => h);
  const k_page = getContext("page");
  let yg_total = new BigNumber(0);
  let c_balances = 0;
  let a_no_gas = [];
  let fk_resolve_total;
  let dp_total = new Promise((fk_resolve) => {
    fk_resolve_total = fk_resolve;
  });
  let g_chain_cached = $yw_chain;
  function check_total() {
    c_balances -= 1;
    if (!c_balances) {
      fk_resolve_total(format_fiat(yg_total.toNumber()));
    }
  }
  async function load_native_balances() {
    let h_balances;
    try {
      h_balances = await $yw_network_active.bankBalances($yw_owner);
    } catch (e_network) {
      syserr({ error: e_network, text: "Network error" });
      return [];
    }
    const a_outs = [];
    for (const [si_coin, g_coin] of ode($yw_chain.coins)) {
      const g_bundle = h_balances[si_coin];
      if (!g_bundle || g_bundle.balance.amount === "0") {
        a_no_gas.push(si_coin);
      }
      c_balances += 1;
      a_outs.push([
        si_coin,
        $yw_chain.coins[si_coin],
        g_bundle?.balance || { amount: "0", denom: g_coin.denom },
        async (z_out) => {
          const yg_balance = await z_out;
          yg_total = yg_total.plus(yg_balance);
          check_total();
          return yg_balance;
        }
      ]);
    }
    $$invalidate(1, a_no_gas), $$invalidate(0, $yw_chain), $$invalidate(11, g_chain_cached);
    return a_outs;
  }
  const H_FAUCETS = {
    "theta-testnet-001": "https://discord.com/channels/669268347736686612/953697793476821092",
    "pulsar-2": "https://faucet.secrettestnet.io/"
  };
  const func = function() {
    k_page.push({
      creator: Send,
      props: { from: $yw_account }
    });
  };
  const func_12 = function() {
    popup_receive($yw_account_ref);
  };
  const func_2 = function() {
    k_page.push({ creator: TokensAdd });
  };
  const click_handler2 = () => open_external_link(H_FAUCETS[$yw_chain.id]);
  const click_handler_1 = (p_entity) => {
    k_page.push({
      creator: HoldingView,
      props: { entityRef: p_entity }
    });
  };
  const func_3 = (yg) => format_fiat(yg.toNumber());
  const click_handler_2 = (p_entity) => {
    k_page.push({
      creator: HoldingView,
      props: { entityRef: p_entity }
    });
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2049) {
      {
        if ($yw_chain !== g_chain_cached) {
          $$invalidate(11, g_chain_cached = $yw_chain);
          yg_total = new BigNumber(0);
          c_balances = 0;
          $$invalidate(2, dp_total = new Promise((fk_resolve) => {
            fk_resolve_total = fk_resolve;
          }));
          $$invalidate(1, a_no_gas = []);
        }
      }
    }
  };
  return [
    $yw_chain,
    a_no_gas,
    dp_total,
    $yw_owner,
    $yw_network_active,
    $yw_account,
    $yw_account_ref,
    merge_fungible_tokens,
    k_page,
    load_native_balances,
    H_FAUCETS,
    g_chain_cached,
    func,
    func_12,
    func_2,
    click_handler2,
    click_handler_1,
    func_3,
    click_handler_2
  ];
}
class HoldingsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$q, safe_not_equal, {}, null, [-1, -1]);
  }
}
function create_catch_block$6(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$6(ctx) {
  let field0;
  let t0;
  let field1;
  let t1;
  let field2;
  let t2;
  let field3;
  let t3;
  let actionsline;
  let current;
  field0 = new Field({
    props: {
      key: "profile-icon",
      name: "Profile icon"
    }
  });
  field1 = new Field({
    props: {
      key: "account-name",
      name: "Name",
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      key: "account-address",
      name: "Public address",
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  field3 = new Field({
    props: {
      key: "account-tags",
      name: "Add tags",
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      cancel: !ctx[5],
      back: true,
      confirm: ["Finish", ctx[7], !ctx[3]]
    }
  });
  return {
    c() {
      create_component(field0.$$.fragment);
      t0 = space();
      create_component(field1.$$.fragment);
      t1 = space();
      create_component(field2.$$.fragment);
      t2 = space();
      create_component(field3.$$.fragment);
      t3 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t0, anchor);
      mount_component(field1, target, anchor);
      insert(target, t1, anchor);
      mount_component(field2, target, anchor);
      insert(target, t2, anchor);
      mount_component(field3, target, anchor);
      insert(target, t3, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field1_changes = {};
      if (dirty & 4098) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 4100) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const field3_changes = {};
      if (dirty & 4096) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const actionsline_changes = {};
      if (dirty & 8)
        actionsline_changes.confirm = ["Finish", ctx2[7], !ctx2[3]];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(field3.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(field3.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t3);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "id", "account-name");
      attr(input, "type", "text");
      attr(input, "placeholder", "Satoshi");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[10]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3$2(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: ctx[2]
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 4)
        address_changes.address = ctx2[2];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      address: true,
      key: "account-address",
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 4100) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let inlinetags;
  let current;
  inlinetags = new InlineTags({
    props: {
      editable: true,
      resourcePath: ctx[4]
    }
  });
  return {
    c() {
      create_component(inlinetags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inlinetags, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetags, detaching);
    }
  };
}
function create_pending_block$6(ctx) {
  let t;
  return {
    c() {
      t = text("Loading accounts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$b(ctx) {
  let h3;
  let t0_value = ctx[0] ? "Edit" : "New";
  let t0;
  let t1;
  let t2;
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$6,
    then: create_then_block$6,
    catch: create_catch_block$6,
    blocks: [, , ,]
  };
  handle_promise(ctx[6](), info);
  return {
    c() {
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" account");
      t2 = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, t1);
      insert(target, t2, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[0] ? "Edit" : "New"))
        set_data(t0, t0_value);
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$p(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 4111) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let b_form_valid;
  let $yw_chain;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(9, $yw_chain = $$value));
  let { account } = $$props;
  const p_account = account;
  let g_account;
  let s_name = "";
  let sa_account;
  const completed = getContext("completed");
  const k_page = getContext("page");
  async function load_account() {
    const ks_accounts = await Accounts.read();
    $$invalidate(8, g_account = ks_accounts.at(p_account));
    $$invalidate(1, s_name = g_account.name);
  }
  async function save_account() {
    Object.assign(g_account, { name: s_name });
    await Accounts.open((ks_accounts) => ks_accounts.put(g_account));
    if (completed) {
      completed(true);
    } else {
      k_page.reset();
    }
  }
  function input_input_handler() {
    s_name = this.value;
    $$invalidate(1, s_name);
  }
  $$self.$$set = ($$props2) => {
    if ("account" in $$props2)
      $$invalidate(0, account = $$props2.account);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$invalidate(3, b_form_valid = !!s_name);
    }
    if ($$self.$$.dirty & 768) {
      $$invalidate(2, sa_account = g_account ? Chains.addressFor(g_account.pubkey, $yw_chain) : "");
    }
  };
  return [
    account,
    s_name,
    sa_account,
    b_form_valid,
    p_account,
    completed,
    load_account,
    save_account,
    g_account,
    $yw_chain,
    input_input_handler
  ];
}
class AccountEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$p, safe_not_equal, { account: 0 });
  }
}
function create_default_slot$a(ctx) {
  let header;
  let t0;
  let hr;
  let t1;
  let p;
  let t3;
  let div;
  let button0;
  let t5;
  let button1;
  let t7;
  let button2;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: { pops: true, title: "Add account" }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      hr = element("hr");
      t1 = space();
      p = element("p");
      p.textContent = "Create a new account, import an existing one, or connect to a hardwarware wallet.";
      t3 = space();
      div = element("div");
      button0 = element("button");
      button0.textContent = "Create new StarSehll account";
      t5 = space();
      button1 = element("button");
      button1.textContent = "Import with private key";
      t7 = space();
      button2 = element("button");
      button2.textContent = "Connect to hardware";
      attr(button0, "class", "primary");
      attr(div, "class", "action-wall");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, hr, anchor);
      insert(target, t1, anchor);
      insert(target, p, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      append(div, button0);
      append(div, t5);
      append(div, button1);
      append(div, t7);
      append(div, button2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[1]),
          listen(button1, "click", ctx[2]),
          listen(button2, "click", ctx[3])
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(hr);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$o(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 16) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$m($$self) {
  const k_page = getContext("page");
  const click_handler2 = () => k_page.push({ creator: AccountEdit });
  const click_handler_1 = () => k_page.push({ creator: DeadEnd });
  const click_handler_2 = () => k_page.push({ creator: DeadEnd });
  return [k_page, click_handler2, click_handler_1, click_handler_2];
}
class AccountCreate extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$o, safe_not_equal, {});
  }
}
function create_catch_block$5(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$5(ctx) {
  let portrait;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[1],
      actions: ctx[3],
      $$slots: { subtitle: [create_subtitle_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portrait.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 65) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
    }
  };
}
function create_subtitle_slot$1(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: Chains.addressFor(ctx[0].pubkey)
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = Chains.addressFor(ctx2[0].pubkey);
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_pending_block$5(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$9(ctx) {
  let header;
  let t;
  let await_block_anchor;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      title: "Account"
    }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$5,
    then: create_then_block$5,
    catch: create_catch_block$5,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$n(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 65) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let { accountRef } = $$props;
  const p_account = accountRef;
  let g_account;
  const k_page = getContext("page");
  async function load_account() {
    const ks_accounts = await Accounts.read();
    return $$invalidate(0, g_account = ks_accounts.at(p_account));
  }
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: {
            from: Chains.addressFor(g_account.pubkey)
          }
        });
      }
    },
    recv: {
      label: "Receive",
      trigger() {
        popup_receive(p_account);
      }
    },
    edit: {
      label: "Edit",
      trigger() {
        k_page.push({
          creator: AccountEdit,
          props: { account: p_account }
        });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("accountRef" in $$props2)
      $$invalidate(4, accountRef = $$props2.accountRef);
  };
  return [g_account, p_account, load_account, gc_actions, accountRef];
}
class AccountView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$n, safe_not_equal, { accountRef: 4 });
  }
}
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i][0];
  child_ctx[7] = list[i][1];
  const constants_0 = Chains.addressFor(child_ctx[7].pubkey);
  child_ctx[8] = constants_0;
  return child_ctx;
}
function create_catch_block$4(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$4(ctx) {
  let previous_key = ctx[1];
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2 && safe_not_equal(previous_key, previous_key = ctx2[1])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_detail_slot$1(ctx) {
  let div;
  let t1;
  let address;
  let t2;
  let current;
  address = new Address({ props: { address: ctx[8] } });
  return {
    c() {
      div = element("div");
      div.textContent = "StarShell - - m/44'/118'/0'/0/??";
      t1 = space();
      create_component(address.$$.fragment);
      t2 = space();
      attr(div, "class", "hd-path");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
      mount_component(address, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = ctx2[8];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      destroy_component(address, detaching);
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$6(ctx) {
  let row;
  let current;
  function click_handler2() {
    return ctx[5](ctx[6]);
  }
  row = new Row({
    props: {
      resource: ctx[7],
      resourcePath: ctx[6],
      address: ctx[8],
      iconClass: "square pfp",
      $$slots: { detail: [create_detail_slot$1] },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1)
        row_changes.resource = ctx[7];
      if (dirty & 1)
        row_changes.resourcePath = ctx[6];
      if (dirty & 1)
        row_changes.address = ctx[8];
      if (dirty & 2049) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_key_block(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_pending_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$8(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "Accounts" } });
  subheader.$on("add_new", ctx[4]);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block$4,
    blocks: [, , ,]
  };
  handle_promise(ctx[3](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$m(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Accounts",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 2051) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let $yw_chain;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(1, $yw_chain = $$value));
  const k_page = getContext("page");
  let a_accounts;
  async function load_accounts() {
    const ks_accounts = await Accounts.read();
    return $$invalidate(0, a_accounts = ks_accounts.entries());
  }
  const add_new_handler = () => k_page.push({ creator: AccountCreate });
  const click_handler2 = (p_account) => k_page.push({
    creator: AccountView,
    props: { accountRef: p_account }
  });
  return [a_accounts, $yw_chain, k_page, load_accounts, add_new_handler, click_handler2];
}
class AccountsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$m, safe_not_equal, {});
  }
}
let id = 1;
function getId() {
  return `svelte-tabs-${id++}`;
}
function create_fragment$l(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-tabs");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "keydown", ctx[1]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
const TABS = {};
function removeAndUpdateSelected(arr, item, selectedStore) {
  const index = arr.indexOf(item);
  arr.splice(index, 1);
  selectedStore.update((selected) => selected === item ? arr[index] || arr[arr.length - 1] : selected);
}
function instance$j($$self, $$props, $$invalidate) {
  let $selectedTab;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { initialSelectedIndex = 0 } = $$props;
  const tabElements = [];
  const tabs = [];
  const panels = [];
  const controls = writable({});
  const labeledBy = writable({});
  const selectedTab = writable(null);
  component_subscribe($$self, selectedTab, (value) => $$invalidate(5, $selectedTab = value));
  const selectedPanel = writable(null);
  function registerItem(arr, item, selectedStore) {
    arr.push(item);
    selectedStore.update((selected) => selected || item);
    onDestroy(() => removeAndUpdateSelected(arr, item, selectedStore));
  }
  function selectTab(tab) {
    const index = tabs.indexOf(tab);
    selectedTab.set(tab);
    selectedPanel.set(panels[index]);
  }
  setContext(TABS, {
    registerTab(tab) {
      registerItem(tabs, tab, selectedTab);
    },
    registerTabElement(tabElement) {
      tabElements.push(tabElement);
    },
    registerPanel(panel) {
      registerItem(panels, panel, selectedPanel);
    },
    selectTab,
    selectedTab,
    selectedPanel,
    controls,
    labeledBy
  });
  onMount(() => {
    selectTab(tabs[initialSelectedIndex]);
  });
  afterUpdate(() => {
    for (let i = 0; i < tabs.length; i++) {
      controls.update((controlsData) => ({
        ...controlsData,
        [tabs[i].id]: panels[i].id
      }));
      labeledBy.update((labeledByData) => ({
        ...labeledByData,
        [panels[i].id]: tabs[i].id
      }));
    }
  });
  async function handleKeyDown(event) {
    if (event.target.classList.contains("svelte-tabs__tab")) {
      let selectedIndex = tabs.indexOf($selectedTab);
      switch (event.key) {
        case "ArrowRight":
          selectedIndex += 1;
          if (selectedIndex > tabs.length - 1) {
            selectedIndex = 0;
          }
          selectTab(tabs[selectedIndex]);
          tabElements[selectedIndex].focus();
          break;
        case "ArrowLeft":
          selectedIndex -= 1;
          if (selectedIndex < 0) {
            selectedIndex = tabs.length - 1;
          }
          selectTab(tabs[selectedIndex]);
          tabElements[selectedIndex].focus();
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("initialSelectedIndex" in $$props2)
      $$invalidate(2, initialSelectedIndex = $$props2.initialSelectedIndex);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [selectedTab, handleKeyDown, initialSelectedIndex, $$scope, slots];
}
class Tabs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$l, safe_not_equal, { initialSelectedIndex: 2 });
  }
}
function create_fragment$k(ctx) {
  let li;
  let li_aria_controls_value;
  let li_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  return {
    c() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      attr(li, "role", "tab");
      attr(li, "id", ctx[3].id);
      attr(li, "aria-controls", li_aria_controls_value = ctx[2][ctx[3].id]);
      attr(li, "aria-selected", ctx[1]);
      attr(li, "tabindex", li_tabindex_value = ctx[1] ? 0 : -1);
      attr(li, "class", "svelte-tabs__tab svelte-1fbofsd");
      toggle_class(li, "svelte-tabs__selected", ctx[1]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[10](li);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[8], !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null), null);
        }
      }
      if (!current || dirty & 4 && li_aria_controls_value !== (li_aria_controls_value = ctx2[2][ctx2[3].id])) {
        attr(li, "aria-controls", li_aria_controls_value);
      }
      if (!current || dirty & 2) {
        attr(li, "aria-selected", ctx2[1]);
      }
      if (!current || dirty & 2 && li_tabindex_value !== (li_tabindex_value = ctx2[1] ? 0 : -1)) {
        attr(li, "tabindex", li_tabindex_value);
      }
      if (dirty & 2) {
        toggle_class(li, "svelte-tabs__selected", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let $selectedTab;
  let $controls;
  let { $$slots: slots = {}, $$scope } = $$props;
  let tabEl;
  const tab = { id: getId() };
  const { registerTab, registerTabElement, selectTab, selectedTab, controls } = getContext(TABS);
  component_subscribe($$self, selectedTab, (value) => $$invalidate(7, $selectedTab = value));
  component_subscribe($$self, controls, (value) => $$invalidate(2, $controls = value));
  let isSelected;
  registerTab(tab);
  onMount(async () => {
    await tick();
    registerTabElement(tabEl);
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tabEl = $$value;
      $$invalidate(0, tabEl);
    });
  }
  const click_handler2 = () => selectTab(tab);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(1, isSelected = $selectedTab === tab);
    }
  };
  return [
    tabEl,
    isSelected,
    $controls,
    tab,
    selectTab,
    selectedTab,
    controls,
    $selectedTab,
    $$scope,
    slots,
    li_binding,
    click_handler2
  ];
}
class Tab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$k, safe_not_equal, {});
  }
}
function create_fragment$j(ctx) {
  let ul;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr(ul, "role", "tablist");
      attr(ul, "class", "svelte-tabs__tab-list svelte-12yby2a");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[0], !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TabList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$j, safe_not_equal, {});
  }
}
function create_if_block$7(ctx) {
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[5], !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null), null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let div;
  let div_aria_labelledby_value;
  let current;
  let if_block = ctx[1] === ctx[2] && create_if_block$7(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "id", ctx[2].id);
      attr(div, "aria-labelledby", div_aria_labelledby_value = ctx[0][ctx[2].id]);
      attr(div, "class", "svelte-tabs__tab-panel svelte-epfyet");
      attr(div, "role", "tabpanel");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1] === ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 1 && div_aria_labelledby_value !== (div_aria_labelledby_value = ctx2[0][ctx2[2].id])) {
        attr(div, "aria-labelledby", div_aria_labelledby_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let $labeledBy;
  let $selectedPanel;
  let { $$slots: slots = {}, $$scope } = $$props;
  const panel = { id: getId() };
  const { registerPanel, selectedPanel, labeledBy } = getContext(TABS);
  component_subscribe($$self, selectedPanel, (value) => $$invalidate(1, $selectedPanel = value));
  component_subscribe($$self, labeledBy, (value) => $$invalidate(0, $labeledBy = value));
  registerPanel(panel);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [$labeledBy, $selectedPanel, panel, selectedPanel, labeledBy, $$scope, slots];
}
class TabPanel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$i, safe_not_equal, {});
  }
}
function create_else_block$1(ctx) {
  let portrait;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[1],
      actions: ctx[2],
      $$slots: {
        subtitle: [create_subtitle_slot],
        default: [create_default_slot_1$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portrait.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 65) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
    }
  };
}
function create_if_block$6(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contact...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$3(ctx) {
  let t;
  return {
    c() {
      t = text("address");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_subtitle_slot(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: Chains.bech32(ctx[0].address)
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = Chains.bech32(ctx2[0].address);
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_default_slot$7(ctx) {
  let header;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      account: true
    }
  });
  const if_block_creators = [create_if_block$6, create_else_block$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$h(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 65) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let { contactRef } = $$props;
  const p_contact = contactRef;
  let g_contact;
  void Agents.getContact(p_contact).then((g) => $$invalidate(0, g_contact = g));
  const k_page = getContext("page");
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: { to: Chains.bech32(g_contact.address) }
        });
      }
    },
    edit: {
      label: "Edit",
      trigger() {
        k_page.push({
          creator: ContactEdit,
          props: { contactRef: p_contact }
        });
      }
    },
    delete: {
      label: "Delete",
      trigger() {
        k_page.push({ creator: DeadEnd$1 });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("contactRef" in $$props2)
      $$invalidate(3, contactRef = $$props2.contactRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      g_contact ? Chains.bech32(g_contact.address) : "";
    }
  };
  return [g_contact, p_contact, gc_actions, contactRef];
}
class ContactView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$h, safe_not_equal, { contactRef: 3 });
  }
}
var SX_ICON_IMAGE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/>\n</svg>';
function create_if_block$5(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 48,
      ref: ctx[0],
      name: ctx[1]
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_fragment$g(ctx) {
  let div4;
  let div3;
  let span0;
  let t0;
  let span5;
  let div0;
  let t4;
  let div2;
  let div1;
  let span3;
  let t5;
  let span4;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] && create_if_block$5(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      span0 = element("span");
      if (if_block)
        if_block.c();
      t0 = space();
      span5 = element("span");
      div0 = element("div");
      div0.innerHTML = `<span class="warning svelte-1i7pjsy">Notice:</span> 
				<span class="info">Uploaded icons will be resized to be square. Only JPG &amp; PNG files less than 1MB allowed.</span>`;
      t4 = space();
      div2 = element("div");
      div1 = element("div");
      span3 = element("span");
      t5 = space();
      span4 = element("span");
      span4.textContent = "Upload Icon";
      attr(span0, "class", "left svelte-1i7pjsy");
      attr(div0, "class", "disclaimer svelte-1i7pjsy");
      attr(span3, "class", "icon svelte-1i7pjsy");
      attr(span4, "class", "text svelte-1i7pjsy");
      attr(div1, "class", "upload svelte-1i7pjsy");
      attr(div2, "class", "actions svelte-1i7pjsy");
      attr(span5, "class", "right svelte-1i7pjsy");
      attr(div3, "class", "row svelte-1i7pjsy");
      attr(div4, "class", "area svelte-1i7pjsy");
      toggle_class(div4, "intent-person", ctx[2] === "person");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, span0);
      if (if_block)
        if_block.m(span0, null);
      append(div3, t0);
      append(div3, span5);
      append(span5, div0);
      append(span5, t4);
      append(span5, div2);
      append(div2, div1);
      append(div1, span3);
      span3.innerHTML = SX_ICON_IMAGE;
      append(div1, t5);
      append(div1, span4);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[0])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let { pfpRef } = $$props;
  const p_pfp = pfpRef || "";
  let { name = "" } = $$props;
  const s_name = name;
  let { intent = "token" } = $$props;
  const si_intent = intent;
  (async () => {
    if (p_pfp) {
      await Pfps.at(p_pfp);
    }
  })();
  const click_handler2 = () => F_NOOP;
  $$self.$$set = ($$props2) => {
    if ("pfpRef" in $$props2)
      $$invalidate(3, pfpRef = $$props2.pfpRef);
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("intent" in $$props2)
      $$invalidate(5, intent = $$props2.intent);
  };
  return [p_pfp, s_name, si_intent, pfpRef, name, intent, click_handler2];
}
class IconEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$g, safe_not_equal, { pfpRef: 3, name: 4, intent: 5 });
  }
}
function create_default_slot_6$1(ctx) {
  let iconeditor;
  let updating_name;
  let current;
  function iconeditor_name_binding(value) {
    ctx[17](value);
  }
  let iconeditor_props = {
    intent: "person",
    pfpRef: ctx[0]?.pfp
  };
  if (ctx[1] !== void 0) {
    iconeditor_props.name = ctx[1];
  }
  iconeditor = new IconEditor({ props: iconeditor_props });
  binding_callbacks.push(() => bind(iconeditor, "name", iconeditor_name_binding));
  return {
    c() {
      create_component(iconeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const iconeditor_changes = {};
      if (dirty & 1)
        iconeditor_changes.pfpRef = ctx2[0]?.pfp;
      if (!updating_name && dirty & 2) {
        updating_name = true;
        iconeditor_changes.name = ctx2[1];
        add_flush_callback(() => updating_name = false);
      }
      iconeditor.$set(iconeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconeditor, detaching);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let style;
  let t1;
  let span0;
  let t2_value = proper(ctx[9]) + "";
  let t2;
  let t3;
  let span1;
  let t4;
  let t5_value = ode(ctx[3]).filter(ctx[18]).map(func_1).join(", ") + "";
  let t5;
  let t6;
  return {
    c() {
      style = element("style");
      style.textContent = ".font-family_mono {\n  font-family: 'PT Mono';\n  white-space: pre;\n}\n.hide-scrollbar {\n  scrollbar-width: none;\n}\n.hide-scrollbar::-webkit-scrollbar {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-track {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-thumb {\n  background-color: rgba(0, 0, 0, 0.2);\n}\n.title {\n  font-family: Poppins;\n  font-weight: 400;\n  font-size: 14px;\n  color: var(--theme-color-text-light);\n}\n.examples {\n  margin-left: 0.5em;\n}";
      t1 = space();
      span0 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span1 = element("span");
      t4 = text("(");
      t5 = text(t5_value);
      t6 = text(")");
      attr(style, "lang", "less");
      attr(span0, "class", "title");
      attr(span1, "class", "examples");
    },
    m(target, anchor) {
      insert(target, style, anchor);
      insert(target, t1, anchor);
      insert(target, span0, anchor);
      append(span0, t2);
      insert(target, t3, anchor);
      insert(target, span1, anchor);
      append(span1, t4);
      append(span1, t5);
      append(span1, t6);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t2_value !== (t2_value = proper(ctx2[9]) + ""))
        set_data(t2, t2_value);
      if (dirty & 520 && t5_value !== (t5_value = ode(ctx2[3]).filter(ctx2[18]).map(func_1).join(", ") + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching)
        detach(style);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(span1);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "chain-family",
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 268435976) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[4]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_3$1(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[4] && create_if_block_1$1(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Enter a name");
      toggle_class(input, "invalid", ctx[4]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      if (dirty & 16) {
        toggle_class(input, "invalid", ctx2[4]);
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$1(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$4(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[5]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let input;
  let input_placeholder_value;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[5] && create_if_block$4(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "text");
      attr(input, "class", "address");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", input_placeholder_value = ctx[10].bech32s.acc + "1...");
      toggle_class(input, "invalid", ctx[5]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[2]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && input_placeholder_value !== (input_placeholder_value = ctx2[10].bech32s.acc + "1...")) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
      if (dirty & 32) {
        toggle_class(input, "invalid", ctx2[5]);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$2(ctx) {
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "placeholder", "");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(textarea, ctx[7]);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[21]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 128) {
        set_input_value(textarea, ctx2[7]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$6(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let field1;
  let t2;
  let field2;
  let t3;
  let field3;
  let t4;
  let field4;
  let t5;
  let hr;
  let t6;
  let h3;
  let t9;
  let inlinetags;
  let t10;
  let div;
  let button0;
  let t12;
  let button1;
  let t13_value = ctx[12] ? "Save" : "Add";
  let t13;
  let button1_readonly_value;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: {
      plain: true,
      pops: true,
      title: (ctx[12] ? "Edit" : "Add New") + " Contact"
    }
  });
  field0 = new Field({
    props: {
      key: "contact-pfp",
      name: "Profile Icon",
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      key: "chain-family",
      name: "Chain Family",
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      key: "contact-name",
      name: "Name",
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  field3 = new Field({
    props: {
      key: "contact-address",
      name: "Address",
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      key: "contact-notes",
      name: "Secure Notes",
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  inlinetags = new InlineTags({
    props: {
      editable: true,
      resourcePath: ctx[12]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      create_component(field1.$$.fragment);
      t2 = space();
      create_component(field2.$$.fragment);
      t3 = space();
      create_component(field3.$$.fragment);
      t4 = space();
      create_component(field4.$$.fragment);
      t5 = space();
      hr = element("hr");
      t6 = space();
      h3 = element("h3");
      h3.textContent = `${ctx[12] ? "Edit" : "Add"} Tags`;
      t9 = space();
      create_component(inlinetags.$$.fragment);
      t10 = space();
      div = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t12 = space();
      button1 = element("button");
      t13 = text(t13_value);
      attr(button1, "class", "primary");
      attr(button1, "readonly", button1_readonly_value = !ctx[8]);
      attr(div, "class", "action-line");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      mount_component(field1, target, anchor);
      insert(target, t2, anchor);
      mount_component(field2, target, anchor);
      insert(target, t3, anchor);
      mount_component(field3, target, anchor);
      insert(target, t4, anchor);
      mount_component(field4, target, anchor);
      insert(target, t5, anchor);
      insert(target, hr, anchor);
      insert(target, t6, anchor);
      insert(target, h3, anchor);
      insert(target, t9, anchor);
      mount_component(inlinetags, target, anchor);
      insert(target, t10, anchor);
      insert(target, div, anchor);
      append(div, button0);
      append(div, t12);
      append(div, button1);
      append(button1, t13);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[22]),
          listen(button1, "click", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 268435459) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 268435976) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 268435474) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const field3_changes = {};
      if (dirty & 268436516) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty & 268435584) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      if (!current || dirty & 256 && button1_readonly_value !== (button1_readonly_value = !ctx2[8])) {
        attr(button1, "readonly", button1_readonly_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t3);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t4);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(hr);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t9);
      destroy_component(inlinetags, detaching);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$f(ctx) {
  let screen;
  let current;
  let screen_props = {
    leaves: true,
    $$slots: { default: [create_default_slot$6] },
    $$scope: { ctx }
  };
  screen = new Screen({ props: screen_props });
  ctx[24](screen);
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 268437439) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[24](null);
      destroy_component(screen, detaching);
    }
  };
}
const func_1 = ([, g]) => g.bech32s.acc.hrp;
function instance$d($$self, $$props, $$invalidate) {
  let s_name;
  let s_addr;
  let sa_bech32;
  let s_notes;
  let si_agent_type;
  let b_form_valid;
  let $yw_family;
  let $yw_chain;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(9, $yw_family = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(10, $yw_chain = $$value));
  const k_page = getContext("page");
  let { contactRef = "" } = $$props;
  const p_contact = contactRef || "";
  let g_contact;
  if (p_contact)
    void Agents.getContact(p_contact).then((g) => $$invalidate(0, g_contact = g));
  let h_chains = {};
  (async function load_chains() {
    $$invalidate(3, h_chains = ofe((await Chains.read()).entries()));
  })();
  let s_err_name = "";
  let s_err_address = "";
  function pubkey_from_addr(sa_address, b_show_err = false) {
    const m_bech = R_BECH32.exec(sa_address);
    if (!m_bech) {
      if (b_show_err) {
        $$invalidate(5, s_err_address = "Invalid Bech32 address");
      }
      return "";
    }
    const [, s_chain, s_pubkey_local] = m_bech;
    let k_chain_match = null;
    for (const [, k_chain] of ode(H_CHAINS)) {
      if (k_chain.def.bechPrefix === s_chain) {
        k_chain_match = k_chain;
        break;
      }
    }
    if (b_show_err) {
      if (!k_chain_match) {
        $$invalidate(5, s_err_address = `No Cosmos SDK chains matched '${s_chain}'`);
      } else {
        $$invalidate(5, s_err_address = "");
      }
    }
    return $$invalidate(16, s_addr = s_pubkey_local);
  }
  let c_show_validations = 0;
  let y_screen;
  async function save() {
    if (!b_form_valid) {
      $$invalidate(15, c_show_validations++, c_show_validations);
      return;
    } else if (p_contact) {
      Object.assign(g_contact, {
        name: s_name,
        address: s_addr,
        pfp: g_contact.pfp,
        agentType: si_agent_type,
        notes: s_notes
      });
      k_page.reset();
    } else {
      $$invalidate(0, g_contact = {
        name: s_name,
        family: $yw_family,
        address: s_addr,
        pfp: g_contact.pfp,
        agentType: si_agent_type,
        notes: s_notes,
        space: "acc",
        origin: "user",
        chains: {}
      });
    }
    try {
      await Agents.open(async (ks_agents) => {
        await ks_agents.putContact(g_contact);
      });
      k_page.reset();
      k_page.push({
        creator: ContactView,
        props: { contactRef: p_contact }
      });
    } catch (e_write) {
    }
  }
  function iconeditor_name_binding(value) {
    s_name = value;
    $$invalidate(1, s_name), $$invalidate(0, g_contact);
  }
  const func = ([, g]) => $yw_family === g.family;
  function input_input_handler() {
    s_name = this.value;
    $$invalidate(1, s_name), $$invalidate(0, g_contact);
  }
  function input_input_handler_1() {
    sa_bech32 = this.value;
    $$invalidate(2, sa_bech32), $$invalidate(16, s_addr), $$invalidate(0, g_contact);
  }
  function textarea_input_handler() {
    s_notes = this.value;
    $$invalidate(7, s_notes), $$invalidate(0, g_contact);
  }
  const click_handler2 = () => k_page.pop();
  const click_handler_1 = () => save();
  function screen_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      y_screen = $$value;
      $$invalidate(6, y_screen);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("contactRef" in $$props2)
      $$invalidate(14, contactRef = $$props2.contactRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, s_name = g_contact?.name || "");
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(16, s_addr = g_contact?.address || "");
    }
    if ($$self.$$.dirty & 65536) {
      $$invalidate(2, sa_bech32 = s_addr ? Chains.bech32(s_addr) : "");
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(7, s_notes = g_contact?.notes || "");
    }
    if ($$self.$$.dirty & 1) {
      si_agent_type = g_contact?.agentType || ContactAgentType.PERSON;
    }
    if ($$self.$$.dirty & 6) {
      $$invalidate(8, b_form_valid = !!(s_name && pubkey_from_addr(sa_bech32)));
    }
    if ($$self.$$.dirty & 32774) {
      {
        if (c_show_validations) {
          $$invalidate(4, s_err_name = s_name ? "" : "Name must not be empty");
          pubkey_from_addr(sa_bech32, true);
        }
      }
    }
  };
  return [
    g_contact,
    s_name,
    sa_bech32,
    h_chains,
    s_err_name,
    s_err_address,
    y_screen,
    s_notes,
    b_form_valid,
    $yw_family,
    $yw_chain,
    k_page,
    p_contact,
    save,
    contactRef,
    c_show_validations,
    s_addr,
    iconeditor_name_binding,
    func,
    input_input_handler,
    input_input_handler_1,
    textarea_input_handler,
    click_handler2,
    click_handler_1,
    screen_binding
  ];
}
class ContactEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$f, safe_not_equal, { contactRef: 14 });
  }
}
var SX_ICON_DOTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-more-vert-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-more-vert-fg" d="M12 8C13.1 8 14 7.1 14 6C14 4.9 13.1 4 12 4C10.9 4 10 4.9 10 6C10 7.1 10.9 8 12 8ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10ZM12 16C10.9 16 10 16.9 10 18C10 19.1 10.9 20 12 20C13.1 20 14 19.1 14 18C14 16.9 13.1 16 12 16Z" fill="#FFB61A"/>\n</svg>\n';
var SX_ICON_SEND = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M9 16h6v-6h4l-7-7-7 7h4v6zm3-10.17L14.17 8H13v6h-2V8H9.83L12 5.83zM5 18h14v2H5z"/>\n</svg>';
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i][0];
  child_ctx[14] = list[i][1];
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_catch_block$3(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[12];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 63) {
        each_value = ctx2[12];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_detail_slot(ctx) {
  let address;
  let t;
  let current;
  address = new Address({
    props: {
      address: Chains.bech32(ctx[14].address + "")
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_prefix_slot(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "icon contact-type svelte-1l93agm");
      attr(span, "slot", "prefix");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_CONTACTS$1;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_tags_slot(ctx) {
  let inlinetags;
  let t;
  let current;
  inlinetags = new InlineTags({
    props: {
      collapsed: true,
      rootStyle: "margin: 0px;",
      resourcePath: ctx[13],
      $$slots: { prefix: [create_prefix_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inlinetags.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(inlinetags, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinetags_changes = {};
      if (dirty & 1048576) {
        inlinetags_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inlinetags.$set(inlinetags_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetags, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$3(ctx) {
  let span;
  let span_transition;
  let current;
  let each_value_1 = ctx[5];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(span, "class", "overlay");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span, null);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 36) {
        each_value_1 = ctx[5];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, slide, { duration: 300, easing: quintOut }, true);
        span_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!span_transition)
        span_transition = create_bidirectional_transition(span, slide, { duration: 300, easing: quintOut }, false);
      span_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_each(each_blocks, detaching);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_each_block_1$1(ctx) {
  let div;
  let span0;
  let raw_value = ctx[17].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[17].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler2(...args) {
    return ctx[9](ctx[17], ctx[14], ...args);
  }
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon");
      attr(span1, "class", "text");
      attr(div, "class", "action");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      span0.innerHTML = raw_value;
      append(div, t0);
      append(div, span1);
      append(span1, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(div, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_status_slot(ctx) {
  let span;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] === ctx[13] && create_if_block$3(ctx);
  return {
    c() {
      span = element("span");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      attr(span, "class", "icon more-menu");
      toggle_class(span, "active", ctx[0] === ctx[13]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_DOTS;
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[4](ctx[13], ctx[14]));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 5) {
        toggle_class(span, "active", ctx[0] === ctx[13]);
      }
      if (ctx[0] === ctx[13]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$3(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$5(ctx) {
  let row;
  let current;
  function click_handler_1(...args) {
    return ctx[10](ctx[14], ...args);
  }
  row = new Row({
    props: {
      resource: ctx[14],
      resourcePath: ctx[13],
      $$slots: {
        status: [create_status_slot],
        tags: [create_tags_slot],
        detail: [create_detail_slot]
      },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_1);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1048577) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$3(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contacts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$e(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    value: 12,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "rows svelte-1l93agm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let $yw_family;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(11, $yw_family = $$value));
  const k_page = getContext("page");
  let { filter = (g) => true } = $$props;
  let { sort = (g_a, g_b) => g_a.name < g_b.name ? -1 : 1 } = $$props;
  let { append: append2 = [] } = $$props;
  async function load_contacts() {
    const ks_agents = await Agents.read();
    return [...ks_agents.contacts($yw_family)];
  }
  const hm_events = /* @__PURE__ */ new WeakMap();
  let si_overlay = "";
  function activate_overlay(p_contact, g_contact) {
    return (d_event) => {
      d_event.stopImmediatePropagation();
      const si_set = p_contact;
      if (hm_events.get(d_event)?.cancelMenu === si_set) {
        $$invalidate(0, si_overlay = "");
        return;
      }
      $$invalidate(0, si_overlay = si_set);
      window.addEventListener("click", () => {
        hm_events.set(d_event, { cancelMenu: si_overlay });
        $$invalidate(0, si_overlay = "");
      }, { capture: true, once: true });
    };
  }
  const a_overlay_actions = [
    {
      label: "Edit",
      icon: SX_ICON_EDIT,
      click(g_contact) {
        k_page.push({
          creator: ContactEdit,
          props: { contact: g_contact }
        });
      }
    },
    {
      label: "Send",
      icon: SX_ICON_SEND,
      click(g_contact) {
        k_page.push({
          creator: Send,
          props: {
            recipient: Chains.bech32(g_contact.address)
          }
        });
      }
    },
    {
      label: "Delete",
      icon: SX_ICON_DELETE,
      click(g_contact) {
        k_page.push({ creator: DeadEnd$1, props: {} });
      }
    }
  ];
  const click_handler2 = (g_action, g_contact, d_event) => {
    d_event.stopPropagation();
    g_action.click(g_contact);
  };
  const click_handler_1 = (g_contact, d_event) => {
    if (!hm_events.get(d_event)?.cancelMenu) {
      k_page.push({
        creator: ContactView,
        props: { contact: g_contact }
      });
    }
  };
  $$self.$$set = ($$props2) => {
    if ("filter" in $$props2)
      $$invalidate(6, filter = $$props2.filter);
    if ("sort" in $$props2)
      $$invalidate(7, sort = $$props2.sort);
    if ("append" in $$props2)
      $$invalidate(8, append2 = $$props2.append);
  };
  return [
    si_overlay,
    k_page,
    load_contacts,
    hm_events,
    activate_overlay,
    a_overlay_actions,
    filter,
    sort,
    append2,
    click_handler2,
    click_handler_1
  ];
}
class ContactList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$e, safe_not_equal, { filter: 6, sort: 7, append: 8 });
  }
}
function create_default_slot_8(ctx) {
  let t;
  return {
    c() {
      t = text("All");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7(ctx) {
  let t;
  return {
    c() {
      t = text("Humans");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6(ctx) {
  let t;
  return {
    c() {
      t = text("Contracts");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5(ctx) {
  let tab0;
  let t0;
  let tab1;
  let t1;
  let tab2;
  let current;
  tab0 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  tab1 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  tab2 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tab0.$$.fragment);
      t0 = space();
      create_component(tab1.$$.fragment);
      t1 = space();
      create_component(tab2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tab0, target, anchor);
      insert(target, t0, anchor);
      mount_component(tab1, target, anchor);
      insert(target, t1, anchor);
      mount_component(tab2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tab0_changes = {};
      if (dirty & 16) {
        tab0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab0.$set(tab0_changes);
      const tab1_changes = {};
      if (dirty & 16) {
        tab1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab1.$set(tab1_changes);
      const tab2_changes = {};
      if (dirty & 16) {
        tab2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab2.$set(tab2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tab0.$$.fragment, local);
      transition_in(tab1.$$.fragment, local);
      transition_in(tab2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tab0.$$.fragment, local);
      transition_out(tab1.$$.fragment, local);
      transition_out(tab2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tab0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(tab1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tab2, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({});
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_3(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({ props: { filter: ctx[2] } });
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({ props: { filter: ctx[3] } });
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let tablist;
  let t0;
  let tabpanel0;
  let t1;
  let tabpanel1;
  let t2;
  let tabpanel2;
  let current;
  tablist = new TabList({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  tabpanel0 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  tabpanel1 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  tabpanel2 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablist.$$.fragment);
      t0 = space();
      create_component(tabpanel0.$$.fragment);
      t1 = space();
      create_component(tabpanel1.$$.fragment);
      t2 = space();
      create_component(tabpanel2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablist, target, anchor);
      insert(target, t0, anchor);
      mount_component(tabpanel0, target, anchor);
      insert(target, t1, anchor);
      mount_component(tabpanel1, target, anchor);
      insert(target, t2, anchor);
      mount_component(tabpanel2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablist_changes = {};
      if (dirty & 16) {
        tablist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablist.$set(tablist_changes);
      const tabpanel0_changes = {};
      if (dirty & 16) {
        tabpanel0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel0.$set(tabpanel0_changes);
      const tabpanel1_changes = {};
      if (dirty & 16) {
        tabpanel1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel1.$set(tabpanel1_changes);
      const tabpanel2_changes = {};
      if (dirty & 16) {
        tabpanel2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel2.$set(tabpanel2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablist.$$.fragment, local);
      transition_in(tabpanel0.$$.fragment, local);
      transition_in(tabpanel1.$$.fragment, local);
      transition_in(tabpanel2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablist.$$.fragment, local);
      transition_out(tabpanel0.$$.fragment, local);
      transition_out(tabpanel1.$$.fragment, local);
      transition_out(tabpanel2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablist, detaching);
      if (detaching)
        detach(t0);
      destroy_component(tabpanel0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tabpanel1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(tabpanel2, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let tabs;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({
    props: { title: "Contacts", buttons: ["Export"] }
  });
  subheader.$on("add_new", ctx[1]);
  tabs = new Tabs({
    props: {
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      create_component(tabs.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      mount_component(tabs, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_changes = {};
      if (dirty & 16) {
        tabs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabs.$set(tabs_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tabs, detaching);
    }
  };
}
function create_fragment$d(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      root: true,
      classNames: "contacts",
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 16) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$b($$self) {
  const k_page = getContext("page");
  const add_new_handler = () => k_page.push({ creator: ContactEdit });
  const func = (g_contact) => ContactAgentType.PERSON === g_contact.agentType;
  const func_12 = (g_contact) => ContactAgentType.CONTRACT === g_contact.agentType;
  return [k_page, add_new_handler, func, func_12];
}
class ContactsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$d, safe_not_equal, {});
  }
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i][0];
  child_ctx[5] = list[i][1];
  return child_ctx;
}
function create_catch_block$2(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$4(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      pfp: ctx[5].pfp,
      name: ctx[5].host,
      resourcePath: ctx[4],
      iconClass: "square pfp"
    }
  });
  row.$on("click", ctx[2]);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$2(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$4(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({
    props: { bare: true, title: "Sites / Apps" }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2,
    value: 3,
    blocks: [, , ,]
  };
  handle_promise(ctx[1](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$c(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "SitesHome",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 256) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$a($$self) {
  const k_page = getContext("page");
  async function load_apps() {
    const ks_apps = await Apps.read();
    return ks_apps.entries();
  }
  const click_handler2 = () => {
    k_page.push({});
  };
  return [k_page, load_apps, click_handler2];
}
class SitesHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$c, safe_not_equal, {});
  }
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i][0];
  child_ctx[7] = list[i][1];
  const constants_0 = child_ctx[0].at(child_ctx[7].chain);
  child_ctx[8] = constants_0;
  return child_ctx;
}
function create_catch_block$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[5];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 7) {
        each_value = ctx2[5];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$3(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      resource: ctx[7],
      resourcePath: ctx[6],
      iconClass: "square pfp",
      detail: `${ctx[8]?.name} (${ctx[8]?.id})`
    }
  });
  row.$on("click", ctx[3]);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const row_changes = {};
      if (dirty & 1)
        row_changes.detail = `${ctx2[8]?.name} (${ctx2[8]?.id})`;
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$1(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$3(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { bare: true, title: "Networks" } });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    value: 5,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$b(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "NetworksHome",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 2049) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  const k_page = getContext("page");
  let ks_chains;
  let ks_networks;
  async function load_networks() {
    $$invalidate(0, [ks_chains, ks_networks] = await Promise.all([Chains.read(), Networks.read()]), ks_chains);
    return ks_networks.entries();
  }
  const click_handler2 = () => {
    k_page.push({});
  };
  return [ks_chains, k_page, load_networks, click_handler2];
}
class NetworksHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$b, safe_not_equal, {});
  }
}
var ThreadId = /* @__PURE__ */ ((ThreadId2) => {
  ThreadId2["DEFAULT"] = "default";
  ThreadId2["INIT"] = "init";
  ThreadId2["SEARCH"] = "search";
  ThreadId2["TOKENS"] = "tokens";
  ThreadId2["NFTS"] = "nfts";
  ThreadId2["CONTACTS"] = "contacts";
  ThreadId2["HISTORY"] = "history";
  ThreadId2["NETWORKS"] = "networks";
  ThreadId2["ACCOUNTS"] = "accounts";
  ThreadId2["TAGS"] = "tags";
  ThreadId2["SITES"] = "sites";
  return ThreadId2;
})(ThreadId || {});
const H_THREADS = {
  ["default"]: Blank,
  ["init"]: Register,
  ["tokens"]: HoldingsHome,
  ["contacts"]: ContactsHome,
  ["networks"]: NetworksHome,
  ["accounts"]: AccountsHome,
  ["sites"]: SitesHome
};
var Overscroll_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => "svg.svelte-1u2i3kk.svelte-1u2i3kk{display:none;z-index:20001;position:absolute;top:10px;left:calc(50% - 16px)}svg.svelte-1u2i3kk .progress.svelte-1u2i3kk{stroke-dasharray:62;stroke-dashoffset:62;stroke-linecap:round;transition:stroke-dasharray 100ms linear}")();
function create_fragment$a(ctx) {
  let svg;
  let style;
  let t;
  let circle0;
  let circle1;
  let circle2;
  return {
    c() {
      svg = svg_element("svg");
      style = svg_element("style");
      t = text(".overscroll .bg {\n  fill: var(--theme-color-text-light);\n}\n.overscroll .ring {\n  fill: transparent;\n  stroke: #c4c4c4;\n}\n.overscroll .progress {\n  fill: transparent;\n  stroke: black;\n}\n");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      attr(style, "lang", "less");
      attr(circle0, "cx", "16");
      attr(circle0, "cy", "16");
      attr(circle0, "r", "16");
      attr(circle0, "class", "bg");
      attr(circle1, "cx", "16");
      attr(circle1, "cy", "16");
      attr(circle1, "r", "10");
      attr(circle1, "class", "ring");
      attr(circle1, "stroke-width", "3");
      set_style(circle1, "opacity", "0.2");
      attr(circle2, "cx", "16");
      attr(circle2, "cy", "16");
      attr(circle2, "r", "10");
      attr(circle2, "class", "progress svelte-1u2i3kk");
      attr(circle2, "stroke-width", "3");
      set_style(circle2, "stroke-dashoffset", 62 - ctx[1] * 62);
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "class", "overscroll svelte-1u2i3kk");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, style);
      append(style, t);
      append(svg, circle0);
      append(svg, circle1);
      append(svg, circle2);
      ctx[2](circle2);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        set_style(circle2, "stroke-dashoffset", 62 - ctx2[1] * 62);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      ctx[2](null);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $yw_overscroll_pct;
  component_subscribe($$self, yw_overscroll_pct, ($$value) => $$invalidate(1, $yw_overscroll_pct = $$value));
  let dm_progress;
  function circle2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_progress = $$value;
      $$invalidate(0, dm_progress);
    });
  }
  return [dm_progress, $yw_overscroll_pct, circle2_binding];
}
class Overscroll extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$a, safe_not_equal, {});
  }
}
var Popup_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ".popup.svelte-rtd9ps.svelte-rtd9ps{pointer-events:none;position:absolute;top:var(--app-window-height);left:0;z-index:1100;width:100%;height:100%;background-color:rgba(0, 0, 0, 0);transition:background-color 0.35s linear}.popup.showing.svelte-rtd9ps.svelte-rtd9ps{top:0;pointer-events:initial;display:block;background-color:rgba(0, 0, 0, 0.85)}.popup.showing.svelte-rtd9ps>.content.svelte-rtd9ps{transform:translateY(24px)}.popup.svelte-rtd9ps>.content.svelte-rtd9ps{position:absolute;top:0;left:var(--ui-padding);width:calc(100% - var(--ui-padding) - var(--ui-padding));height:87%;overflow-y:scroll;scrollbar-width:none;background-color:var(--theme-color-bg);border-radius:8px;box-sizing:border-box;padding:var(--ui-padding);display:flex;flex-direction:column;gap:var(--ui-padding);transition:transform 675ms var(--ease-out-quick);transform:translateY(var(--app-window-height))}.popup.svelte-rtd9ps>.content.svelte-rtd9ps::-webkit-scrollbar{display:none}.popup.svelte-rtd9ps>.content.svelte-rtd9ps::-webkit-scrollbar-track{display:none}.popup.svelte-rtd9ps>.content.svelte-rtd9ps::-webkit-scrollbar-thumb{background-color:rgba(0, 0, 0, 0.2)}")();
function create_fragment$9(ctx) {
  let div;
  let section;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[0];
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
  }
  return {
    c() {
      div = element("div");
      section = element("section");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(section, "class", "screen content svelte-rtd9ps");
      attr(div, "class", "popup svelte-rtd9ps");
      toggle_class(div, "showing", ctx[0] !== null);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, section);
      if (switch_instance) {
        mount_component(switch_instance, section, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(section, "click", click_handler),
          listen(div, "click", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (switch_value !== (switch_value = ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, section, null);
        } else {
          switch_instance = null;
        }
      }
      if (dirty & 1) {
        toggle_class(div, "showing", ctx2[0] !== null);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
}
const click_handler = (d_event) => d_event.stopPropagation();
function instance$7($$self, $$props, $$invalidate) {
  let $yw_popup;
  component_subscribe($$self, yw_popup, ($$value) => $$invalidate(0, $yw_popup = $$value));
  const click_handler_1 = () => set_store_value(yw_popup, $yw_popup = null, $yw_popup);
  return [$yw_popup, click_handler_1];
}
class Popup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$9, safe_not_equal, {});
  }
}
var SX_ICON_EXPAND = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M12 16L18 10L16.59 8.59L12 13.17L7.41 8.59L6 10L12 16Z" />\n</svg>\n';
var SX_ICON_TOKENS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-tokens-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-tokens-fg" d="M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8Zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6ZM3 12a5.99 5.99 0 0 1 4-5.65V4.26C3.55 5.15 1 8.27 1 12c0 3.73 2.55 6.85 6 7.74v-2.09A5.99 5.99 0 0 1 3 12Z" />\n</svg>\n';
var SX_ICON_HISTORY = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-history-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-nav-history-fg" d="M13 3a9 9 0 0 0-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42A8.954 8.954 0 0 0 13 21a9 9 0 0 0 0-18Zm-1 5v5l4.25 2.52.77-1.28-3.52-2.09V8H12Z" />\n</svg>\n';
var SX_ICON_MENU = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-menu-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-menu-fg" d="M4 19h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1Zm0-6h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1ZM3 6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1Z" />\n</svg>\n';
var Nav_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ".font-family_mono.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5{font-family:'PT Mono';white-space:pre}.hide-scrollbar.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5{scrollbar-width:none}.hide-scrollbar.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5::-webkit-scrollbar{display:none}.hide-scrollbar.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5::-webkit-scrollbar-track{display:none}.hide-scrollbar.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5::-webkit-scrollbar-thumb{background-color:rgba(0, 0, 0, 0.2)}nav.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5{--nav-height:72px;position:absolute;bottom:0;height:var(--nav-height);width:100%;background-color:var(--theme-color-bg);display:block;z-index:1000;transition:bottom 1s var(--ease-out-quick);display:none}nav.visible.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5{display:initial}nav.collapsed.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5{bottom:calc(0px - var(--nav-height))}nav.collapsed > .collapse.icon > svg{transform:rotate(-180deg)}nav.svelte-1ylq4j5>.collapse.icon.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5{--button-diameter:32px;--icon-diameter:24px;--svg-color-fg:var(--theme-color-text-light);border:1px solid transparent;position:absolute;right:0;top:calc(0px - var(--button-diameter));border-radius:0;border-bottom-width:0;border-color:var(--theme-color-border);box-sizing:border-box;background-color:var(--theme-color-bg);cursor:pointer}nav > .collapse.icon > svg{transform:rotate(0deg);transition:transform 1s var(--ease-out-quick)}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5{list-style:none;padding:0;margin:0;display:flex;text-align:center;border-top:1px solid var(--theme-color-border)}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5>.button.svelte-1ylq4j5.svelte-1ylq4j5{flex:1;padding-top:11px;padding-bottom:12px;--icon-diameter:24px;--svg-color-fg:var(--theme-color-text-light);cursor:pointer}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5>.button.active.tokens.svelte-1ylq4j5.svelte-1ylq4j5{--svg-color-fg:var(--theme-color-primary)}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5>.button.active.contacts.svelte-1ylq4j5.svelte-1ylq4j5{--svg-color-fg:var(--theme-color-primary)}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5>.button.active.nfts.svelte-1ylq4j5.svelte-1ylq4j5{--svg-color-fg:var(--theme-color-primary)}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5>.button.active.history.svelte-1ylq4j5.svelte-1ylq4j5{--svg-color-fg:var(--theme-color-primary)}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5>.button.active.svelte-1ylq4j5>.label.svelte-1ylq4j5{color:var(--theme-color-text-light)}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5>.button.svelte-1ylq4j5>.icon.svelte-1ylq4j5{--proxy--icon-diameter:var(--icon-diameter)}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5>.button.svelte-1ylq4j5>.icon.svelte-1ylq4j5{--icon-diameter:var(--proxy--icon-diameter)}nav.svelte-1ylq4j5>.bar>.button .notification.svelte-1ylq4j5.svelte-1ylq4j5.svelte-1ylq4j5{position:absolute;width:7px;height:7px;background-color:var(--theme-color-sky);border-radius:7px;margin-top:15px;border:2px solid var(--theme-color-bg);margin-left:-9px}nav.svelte-1ylq4j5>.bar.svelte-1ylq4j5>.button.svelte-1ylq4j5>.label.svelte-1ylq4j5{font-size:11px;color:var(--theme-color-text-med)}")();
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i][0];
  child_ctx[18] = list[i][1];
  return child_ctx;
}
function create_each_block$2(ctx) {
  let li;
  let div0;
  let html_tag;
  let raw_value = ctx[18].svg + "";
  let t0;
  let span;
  let t1;
  let div1;
  let t2_value = ctx[18].label + "";
  let t2;
  let t3;
  let li_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[9](ctx[17]);
  }
  return {
    c() {
      li = element("li");
      div0 = element("div");
      html_tag = new HtmlTag(false);
      t0 = space();
      span = element("span");
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      html_tag.a = t0;
      attr(span, "class", "notification svelte-1ylq4j5");
      toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      attr(div0, "class", "icon svelte-1ylq4j5");
      attr(div1, "class", "label svelte-1ylq4j5");
      attr(li, "class", li_class_value = "button " + ctx[17] + " svelte-1ylq4j5");
      toggle_class(li, "active", ctx[0] === ctx[17]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      html_tag.m(raw_value, div0);
      append(div0, t0);
      append(div0, span);
      append(li, t1);
      append(li, div1);
      append(div1, t2);
      append(li, t3);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 18) {
        toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      }
      if (dirty & 17) {
        toggle_class(li, "active", ctx[0] === ctx[17]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$8(ctx) {
  let nav;
  let div;
  let t;
  let ul;
  let mounted;
  let dispose;
  let each_value = ode(ctx[4]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  return {
    c() {
      nav = element("nav");
      div = element("div");
      t = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "collapse icon svelte-1ylq4j5");
      attr(ul, "class", "bar svelte-1ylq4j5");
      attr(nav, "class", "svelte-1ylq4j5");
      toggle_class(nav, "collapsed", ctx[2]);
      toggle_class(nav, "visible", ctx[3]);
    },
    m(target, anchor) {
      insert(target, nav, anchor);
      append(nav, div);
      div.innerHTML = SX_ICON_EXPAND;
      append(nav, t);
      append(nav, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      if (!mounted) {
        dispose = listen(div, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 83) {
        each_value = ode(ctx2[4]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 4) {
        toggle_class(nav, "collapsed", ctx2[2]);
      }
      if (dirty & 8) {
        toggle_class(nav, "visible", ctx2[3]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(nav);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_thread;
  let $yw_page;
  let $yw_menu_expanded;
  let $yw_overlay_account;
  let $yw_overlay_network;
  let $yw_blur;
  let $yw_notifications;
  let $yw_nav_collapsed;
  let $yw_nav_visible;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(10, $yw_navigator = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(11, $yw_thread = $$value));
  component_subscribe($$self, yw_page, ($$value) => $$invalidate(7, $yw_page = $$value));
  component_subscribe($$self, yw_menu_expanded, ($$value) => $$invalidate(12, $yw_menu_expanded = $$value));
  component_subscribe($$self, yw_overlay_account, ($$value) => $$invalidate(13, $yw_overlay_account = $$value));
  component_subscribe($$self, yw_overlay_network, ($$value) => $$invalidate(14, $yw_overlay_network = $$value));
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(15, $yw_blur = $$value));
  component_subscribe($$self, yw_notifications, ($$value) => $$invalidate(1, $yw_notifications = $$value));
  component_subscribe($$self, yw_nav_collapsed, ($$value) => $$invalidate(2, $yw_nav_collapsed = $$value));
  component_subscribe($$self, yw_nav_visible, ($$value) => $$invalidate(3, $yw_nav_visible = $$value));
  const H_BUTTONS = {
    [ThreadId.TOKENS]: { svg: SX_ICON_TOKENS, label: "Tokens" },
    [ThreadId.CONTACTS]: { svg: SX_ICON_CONTACTS$1, label: "Contacts" },
    [ThreadId.HISTORY]: { svg: SX_ICON_HISTORY, label: "History" },
    menu: { svg: SX_ICON_MENU, label: "Menu" }
  };
  const HM_HOMESCREENS = new Map(oderac(H_THREADS, (si_thread, dc_creator) => [dc_creator, si_thread]));
  let si_thread_head = "";
  function toggle_collapsed() {
    set_store_value(yw_nav_collapsed, $yw_nav_collapsed = !$yw_nav_collapsed, $yw_nav_collapsed);
  }
  function nav_click(si_button) {
    set_store_value(yw_notifications, $yw_notifications = $yw_notifications.filter((si) => si_button !== si), $yw_notifications);
    if ($yw_blur) {
      set_store_value(yw_blur, $yw_blur = false, $yw_blur);
    }
    if ($yw_overlay_network) {
      set_store_value(yw_overlay_network, $yw_overlay_network = false, $yw_overlay_network);
    }
    if ($yw_overlay_account) {
      set_store_value(yw_overlay_account, $yw_overlay_account = false, $yw_overlay_account);
    }
    switch (si_button) {
      case "menu": {
        set_store_value(yw_menu_expanded, $yw_menu_expanded = true, $yw_menu_expanded);
        break;
      }
      case si_thread_head: {
        $yw_navigator.activePage.dom.scrollTo({ top: 0, left: 0, behavior: "smooth" });
        break;
      }
      case $yw_thread.id: {
        const k_previous = $yw_page.peak();
        if (k_previous && HM_HOMESCREENS.get(k_previous.creator) === $yw_thread.id) {
          $yw_page.pop();
        } else {
          $yw_page.reset();
        }
        break;
      }
      default: {
        void $yw_navigator.activateThread(si_button);
        break;
      }
    }
  }
  const click_handler2 = () => toggle_collapsed();
  const click_handler_1 = (si_button) => nav_click(si_button);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(0, si_thread_head = $yw_page ? HM_HOMESCREENS.get($yw_page.creator) || "" : "");
    }
  };
  return [
    si_thread_head,
    $yw_notifications,
    $yw_nav_collapsed,
    $yw_nav_visible,
    H_BUTTONS,
    toggle_collapsed,
    nav_click,
    $yw_page,
    click_handler2,
    click_handler_1
  ];
}
class Nav extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$8, safe_not_equal, {});
  }
}
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
const PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
const MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
const BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
const FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
const AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(...this._findMatches({
          key,
          value: item[keyIndex],
          searcher
        }));
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}
var Search_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ".search.svelte-5f3tva{position:absolute;top:0;left:0;height:100%;width:100%;z-index:1000}")();
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_each_block$1(ctx) {
  let genericrow;
  let current;
  genericrow = new GenericRow({ props: { item: ctx[9] } });
  return {
    c() {
      create_component(genericrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(genericrow, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(genericrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(genericrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(genericrow, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let header;
  let t0;
  let p;
  let t3;
  let div;
  let each_1_anchor;
  let current;
  const header_spread_levels = [
    { network: true },
    { account: true },
    { search: true },
    { isSearchScreen: true },
    ctx[2] || {}
  ];
  let header_props = {};
  for (let i = 0; i < header_spread_levels.length; i += 1) {
    header_props = assign(header_props, header_spread_levels[i]);
  }
  header = new Header({ props: header_props });
  header.$on("search", ctx[5]);
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      p = element("p");
      p.innerHTML = `<span style="color:var(--theme-color-caution);">Disclaimer:</span>
			This temporary search interface does not represent the look and function of the actual search interface currently under development for beta.`;
      t3 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      set_style(p, "font-size", "12px");
      attr(div, "class", "results no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, p, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append(div, each_1_anchor);
      ctx[6](div);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = dirty & 4 ? get_spread_update(header_spread_levels, [
        header_spread_levels[0],
        header_spread_levels[1],
        header_spread_levels[2],
        header_spread_levels[3],
        get_spread_object(ctx2[2] || {})
      ]) : {};
      header.$set(header_changes);
      if (dirty & 8) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(p);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      ctx[6](null);
    }
  };
}
function create_fragment$7(ctx) {
  let div;
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Search",
      root: true,
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(screen.$$.fragment);
      attr(div, "class", "search svelte-5f3tva");
      toggle_class(div, "display_none", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(screen, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 4102) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
      if (dirty & 1) {
        toggle_class(div, "display_none", !ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(screen);
    }
  };
}
var ClassType;
(function(ClassType2) {
  ClassType2["UNKNOWN"] = "unknown";
  ClassType2["FAMILY"] = "family";
  ClassType2["CHAIN"] = "chain";
  ClassType2["NETWORK"] = "network";
  ClassType2["ACCOUNT"] = "account";
  ClassType2["CONTACT"] = "contact";
  ClassType2["CONTRACT"] = "contract";
  ClassType2["TOKEN"] = "token";
  ClassType2["HOLDING"] = "holding";
  ClassType2["APP"] = "app";
  ClassType2["COIN"] = "coin";
  ClassType2["TAG"] = "tag";
  ClassType2["ICON"] = "icon";
  ClassType2["IBCT"] = "ibct";
  ClassType2["SNIP721"] = "snip721";
  ClassType2["TXN"] = "txn";
  ClassType2["OTHER"] = "other";
})(ClassType || (ClassType = {}));
function instance$5($$self, $$props, $$invalidate) {
  let $yw_search;
  let $yw_header_props;
  component_subscribe($$self, yw_search, ($$value) => $$invalidate(0, $yw_search = $$value));
  component_subscribe($$self, yw_header_props, ($$value) => $$invalidate(2, $yw_header_props = $$value));
  let dm_results;
  const a_results = [];
  let a_fuses = [];
  const fuzey = (a_items, a_keys) => new Fuse(a_items, {
    includeScore: true,
    includeMatches: true,
    keys: ["label", ...a_keys.map((s) => `details.${s}`)]
  });
  (async () => {
    const ks_chains = await Chains.read();
    a_fuses = [
      (() => fuzey(ks_chains.entries().map(([p_chain, g_chain]) => ({
        class: ClassType.CHAIN,
        name: g_chain.name,
        resourcePath: p_chain,
        resource: g_chain,
        details: { name: g_chain.name, id: g_chain.id }
      })), ["id"]))(),
      (() => fuzey(ks_chains.entries().flatMap(([p_chain, g_chain]) => oderac(g_chain.coins, (si_coin, g_coin) => ({
        class: ClassType.COIN,
        name: proper(g_coin.extra?.coingecko_id || "Unknown"),
        postname: si_coin,
        resourcePath: `${p_chain}/coin.${si_coin}`,
        resource: {
          name: proper(g_coin.extra?.coingecko_id || "Unknown"),
          pfp: g_chain.pfp,
          ...g_coin
        },
        details: {
          symbol: si_coin,
          denom: g_coin.denom,
          coingecko: g_coin.extra?.coingecko_id || ""
        }
      }))), ["symbol", "denom"]))(),
      ...await Promise.all([
        (async () => {
          const ks_accounts = await Accounts.read();
          return fuzey(ks_accounts.entries().map(([p_account, g_account]) => {
            const a_addrs = [];
            const as_addrs = /* @__PURE__ */ new Set();
            for (const [, g_chain] of ks_chains) {
              as_addrs.add(Chains.addressFor(g_account.pubkey, g_chain));
            }
            a_addrs.push(...as_addrs);
            return {
              class: ClassType.ACCOUNT,
              name: g_account.name,
              resourcePath: p_account,
              resource: g_account,
              details: { name: g_account.name, addresses: a_addrs }
            };
          }), ["addresses"]);
        })(),
        (async () => {
          const ks_agents = await Agents.read();
          return fuzey([...ks_agents.contacts()].map(([p_contact, g_contact]) => ({
            class: ClassType.CONTACT,
            name: g_contact.name,
            resourcePath: p_contact,
            resource: g_contact,
            details: {
              name: g_contact.name,
              notes: g_contact.notes,
              addresses: [...ks_chains.inFamily(g_contact.family)].map(([, g_chain]) => Chains.bech32(g_contact.address, g_chain))
            }
          })), ["notes"]);
        })(),
        (async () => {
          const ks_apps = await Apps.read();
          return fuzey(ks_apps.entries().map(([p_app, g_app]) => ({
            class: ClassType.APP,
            name: g_app.host,
            resourcePath: p_app,
            resource: g_app,
            details: { host: g_app.host }
          })), []);
        })(),
        (async () => {
          const a_tokens = [];
          for (const [, g_chain] of ks_chains.entries()) {
            for (const [si_spec, h_tokens] of ode(await Entities.readFungibleTokens(g_chain))) {
              for (const [p_token, g_token2] of ode(h_tokens)) {
                a_tokens.push({
                  class: ClassType.TOKEN,
                  name: g_token2.name,
                  resourcePath: p_token,
                  resource: g_token2,
                  details: {
                    spec: si_spec,
                    name: g_token2.name,
                    symbol: g_token2.symbol,
                    bech32: g_token2.bech32,
                    codehash: g_token2.hash
                  }
                });
              }
            }
          }
          return fuzey(a_tokens, ["spec", "symbol", "bech32", "codehash"]);
        })()
      ])
    ];
  })();
  function search2(s_search) {
    const a_groups = [];
    const a_hits = [];
    let c_total = 0;
    for (const y_fuse of a_fuses) {
      const a_hits_local = y_fuse.search(s_search);
      if (a_hits_local.length) {
        c_total += a_hits.length;
        a_hits.push(...a_hits_local);
        a_groups.push({
          top: a_hits_local[0].score,
          hits: a_hits_local
        });
      }
    }
    a_hits.sort((g_a, g_b) => g_b.score - g_a.score);
    $$invalidate(1, dm_results.innerHTML = "", dm_results);
    console.log(a_hits);
    for (const g_hit of a_hits) {
      new Row({
        target: dm_results,
        props: { ...g_hit.item, pfpDim: 32 }
      });
    }
  }
  const search_handler = (d_event) => search2(d_event.detail);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_results = $$value;
      $$invalidate(1, dm_results);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        if ($yw_search) {
          search2($yw_search);
        }
      }
    }
  };
  return [
    $yw_search,
    dm_results,
    $yw_header_props,
    a_results,
    search2,
    search_handler,
    div_binding
  ];
}
class Search extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$7, safe_not_equal, {});
  }
}
var Progress_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ".progress.svelte-1hwu1hf.svelte-1hwu1hf{--bar-height:4px;z-index:1001;background-color:black;position:absolute;height:var(--bar-height);top:calc(0px - var(--bar-height));left:0;width:100%;transition:top 0.2s var(--ease-out-cubic)}.progress.visible.svelte-1hwu1hf.svelte-1hwu1hf{top:0}.progress.svelte-1hwu1hf>.bar.svelte-1hwu1hf{background-color:var(--theme-color-primary);height:100%;width:0%;transition:width 1s var(--ease-out-cubic)}.step.svelte-1hwu1hf.svelte-1hwu1hf{font-family:Poppins;font-weight:400;font-size:11px;color:var(--theme-color-text-med);z-index:1001;position:absolute;top:calc(0px - var(--ui-padding));left:0;margin-top:var(--ui-padding);margin-left:var(--ui-padding);opacity:0;transition:all 0.6s var(--ease-out-cubic);transition-delay:0.4s}.step.visible.svelte-1hwu1hf.svelte-1hwu1hf{top:0;opacity:1}")();
function create_fragment$6(ctx) {
  let div1;
  let div0;
  let t0;
  let div2;
  let t1;
  let t2_value = (ctx[0][0] || ctx[0][1]) + "";
  let t2;
  let t3;
  let t4_value = ctx[0][1] + "";
  let t4;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      t1 = text("Step ");
      t2 = text(t2_value);
      t3 = text(" of ");
      t4 = text(t4_value);
      attr(div0, "class", "bar svelte-1hwu1hf");
      set_style(div0, "width", ctx[1] + "%");
      attr(div1, "class", "progress svelte-1hwu1hf");
      toggle_class(div1, "visible", ctx[0][0] > 0);
      attr(div2, "class", "step svelte-1hwu1hf");
      toggle_class(div2, "visible", ctx[0][0] > 0);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      append(div2, t1);
      append(div2, t2);
      append(div2, t3);
      append(div2, t4);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        set_style(div0, "width", ctx2[1] + "%");
      }
      if (dirty & 1) {
        toggle_class(div1, "visible", ctx2[0][0] > 0);
      }
      if (dirty & 1 && t2_value !== (t2_value = (ctx2[0][0] || ctx2[0][1]) + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx2[0][1] + ""))
        set_data(t4, t4_value);
      if (dirty & 1) {
        toggle_class(div2, "visible", ctx2[0][0] > 0);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div2);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let x_width_pct_bar;
  let $yw_progress;
  component_subscribe($$self, yw_progress, ($$value) => $$invalidate(0, $yw_progress = $$value));
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, x_width_pct_bar = $yw_progress[0] / $yw_progress[1] * 100);
    }
  };
  return [$yw_progress, x_width_pct_bar];
}
class Progress extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$6, safe_not_equal, {});
  }
}
var SX_ICON_CONTACTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M9 12c1.93 0 3.5-1.57 3.5-3.5S10.93 5 9 5 5.5 6.57 5.5 8.5 7.07 12 9 12zm0-5c.83 0 1.5.67 1.5 1.5S9.83 10 9 10s-1.5-.67-1.5-1.5S8.17 7 9 7zm.05 10H4.77c.99-.5 2.7-1 4.23-1 .11 0 .23.01.34.01.34-.73.93-1.33 1.64-1.81-.73-.13-1.42-.2-1.98-.2-2.34 0-7 1.17-7 3.5V19h7v-1.5c0-.17.02-.34.05-.5zm7.45-2.5c-1.84 0-5.5 1.01-5.5 3V19h11v-1.5c0-1.99-3.66-3-5.5-3zm1.21-1.82c.76-.43 1.29-1.24 1.29-2.18a2.5 2.5 0 0 0-5 0c0 .94.53 1.75 1.29 2.18.36.2.77.32 1.21.32s.85-.12 1.21-.32z"/>\n</svg>';
var SX_ICON_CHAINS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="m18 16 4-4-4-4v3h-5.06A8.974 8.974 0 0 0 8 3.95 3.005 3.005 0 0 0 5 1C3.34 1 2 2.34 2 4s1.34 3 3 3c.95 0 1.78-.45 2.33-1.14C9.23 6.9 10.6 8.77 10.92 11h-3.1C7.4 9.84 6.3 9 5 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c1.3 0 2.4-.84 2.82-2h3.1c-.32 2.23-1.69 4.1-3.58 5.14C6.78 17.45 5.95 17 5 17c-1.66 0-3 1.34-3 3s1.34 3 3 3a2.99 2.99 0 0 0 2.99-2.95A8.974 8.974 0 0 0 12.93 13H18v3z"/>\n</svg>';
var SX_ICON_ACCOUNTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM7.07 18.28c.43-.9 3.05-1.78 4.93-1.78s4.51.88 4.93 1.78C15.57 19.36 13.86 20 12 20s-3.57-.64-4.93-1.72zm11.29-1.45c-1.43-1.74-4.9-2.33-6.36-2.33s-4.93.59-6.36 2.33A7.95 7.95 0 0 1 4 12c0-4.41 3.59-8 8-8s8 3.59 8 8c0 1.82-.62 3.49-1.64 4.83zM12 6c-1.94 0-3.5 1.56-3.5 3.5S10.06 13 12 13s3.5-1.56 3.5-3.5S13.94 6 12 6zm0 5c-.83 0-1.5-.67-1.5-1.5S11.17 8 12 8s1.5.67 1.5 1.5S12.83 11 12 11z"/>\n</svg>';
var SX_ICON_CONNECTIONS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M22 11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3h7zM7 9H4V5h3v4zm10 6h3v4h-3v-4zm0-10h3v4h-3V5z"/>\n</svg>';
var SX_ICON_LOGOUT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M18 4v16H6V4h12m0-2H6c-1.1 0-2 .9-2 2v18h16V4c0-1.1-.9-2-2-2zm-2.5 8.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5S17 12.83 17 12s-.67-1.5-1.5-1.5z"/>\n</svg>';
var SideMenu_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ":root{--bar-width:78.8%;--animation-duration:1s;--animation-easing:var(--ease-out-quick)}@keyframes svelte-fhv297-fade{0%{background-color:transparent}100%{background-color:rgba(0, 0, 0, 0.8)}}@keyframes svelte-fhv297-slide{0%{right:calc(0% - var(--bar-width))}100%{right:0%}}@keyframes svelte-fhv297-offscreen{0%{top:0}100%{top:var(--app-window-height)}}.side-menu.svelte-fhv297.svelte-fhv297.svelte-fhv297.svelte-fhv297{--item-padding:30px;position:absolute;top:0;left:0;width:var(--app-window-width);height:var(--app-window-height);font-family:Poppins;font-weight:400;font-size:14px;z-index:1001;user-select:none}.side-menu.svelte-fhv297>.backdrop.svelte-fhv297.svelte-fhv297.svelte-fhv297{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(0, 0, 0, 0.8);transition:background-color var(--animation-duration) var(--ease-out-expo)}.side-menu.svelte-fhv297>.bar.svelte-fhv297.svelte-fhv297.svelte-fhv297{position:absolute;top:0;width:var(--bar-width);height:100%;background-color:var(--theme-color-bg);right:0%;transition:right var(--animation-duration) var(--animation-easing)}.side-menu.svelte-fhv297>.bar.svelte-fhv297>.menu.svelte-fhv297.svelte-fhv297{display:flex;flex-direction:column;justify-content:space-evenly;height:100%}.side-menu.svelte-fhv297>.bar>.menu ul.svelte-fhv297.svelte-fhv297.svelte-fhv297{margin:0;padding:0;display:flex;flex-direction:column-reverse}.side-menu.svelte-fhv297>.bar>.menu ul.svelte-fhv297>li.svelte-fhv297.svelte-fhv297{list-style:none;padding:13px 0;padding-left:var(--item-padding);cursor:pointer}.side-menu.svelte-fhv297>.bar>.menu ul.svelte-fhv297>li.svelte-fhv297>.svelte-fhv297{vertical-align:middle}.side-menu.svelte-fhv297>.bar>.menu ul.svelte-fhv297>li.svelte-fhv297>.icon.svelte-fhv297{--icon-diameter:24px;padding:0;padding-right:calc(var(--item-padding) / 2)}.side-menu.svelte-fhv297>.bar>.menu ul.items .icon.svelte-fhv297.svelte-fhv297.svelte-fhv297{--icon-color:var(--theme-color-primary)}.side-menu.svelte-fhv297>.bar>.menu ul.session.svelte-fhv297.svelte-fhv297.svelte-fhv297{padding:calc(var(--item-padding) / 2) 0}.side-menu.svelte-fhv297>.bar>.menu ul.session .icon.svelte-fhv297.svelte-fhv297.svelte-fhv297{--icon-color:var(--theme-color-text-med)}.side-menu.svelte-fhv297>.bar.svelte-fhv297>.menu.svelte-fhv297>.main.svelte-fhv297{flex:1;display:flex;flex-direction:column;justify-content:flex-end;padding-top:15%;padding-bottom:15%}.side-menu.svelte-fhv297>.bar.svelte-fhv297>.menu.svelte-fhv297>.top.svelte-fhv297{flex:0}.side-menu.svelte-fhv297>.bar.svelte-fhv297>.menu.svelte-fhv297>.top.svelte-fhv297{padding-top:15%}.side-menu.collapsed.svelte-fhv297.svelte-fhv297.svelte-fhv297.svelte-fhv297{pointer-events:none;top:0;animation:svelte-fhv297-offscreen var(--animation-duration) steps(2, jump-none) both}.side-menu.collapsed.svelte-fhv297>.backdrop.svelte-fhv297.svelte-fhv297.svelte-fhv297{background-color:rgba(0, 0, 0, 0)}.side-menu.collapsed.svelte-fhv297>.bar.svelte-fhv297.svelte-fhv297.svelte-fhv297{right:calc(0% - var(--bar-width))}.side-menu.svelte-fhv297 hr.svelte-fhv297.svelte-fhv297.svelte-fhv297{margin:0 var(--item-padding);border:none;border-top:1px solid var(--theme-color-border)}.side-menu.svelte-fhv297 .close.svelte-fhv297.svelte-fhv297.svelte-fhv297{position:absolute;top:0;right:0;margin:10px;padding:12px;cursor:pointer;--icon-diameter:24px;--icon-color:var(--theme-color-primary);outline:1px solid var(--theme-color-border);border-radius:0px;transition:border-radius 650ms var(--ease-out-expo);pointer-events:all}.side-menu.svelte-fhv297 .close.svelte-fhv297.svelte-fhv297.svelte-fhv297::before{--occlusion-thickness:4px;content:'';position:absolute;top:calc(var(--occlusion-thickness) / 2);left:calc(var(--occlusion-thickness) / 2);width:calc(100% - var(--occlusion-thickness));height:calc(100% - var(--occlusion-thickness));outline:var(--occlusion-thickness) solid var(--theme-color-bg);box-sizing:border-box;pointer-events:none}.side-menu.svelte-fhv297 .close.svelte-fhv297.svelte-fhv297.svelte-fhv297:hover{border-radius:22px}")();
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let li;
  let span0;
  let raw_value = ctx[8].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[8].label + "";
  let t1;
  let t2;
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon svelte-fhv297");
      attr(span1, "class", "text svelte-fhv297");
      attr(li, "class", "svelte-fhv297");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span0);
      span0.innerHTML = raw_value;
      append(li, t0);
      append(li, span1);
      append(span1, t1);
      append(li, t2);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_each_block(ctx) {
  let li;
  let span0;
  let raw_value = ctx[8].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[8].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler_2() {
    return ctx[5](ctx[8]);
  }
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon svelte-fhv297");
      attr(span1, "class", "text svelte-fhv297");
      attr(li, "class", " svelte-fhv297");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span0);
      span0.innerHTML = raw_value;
      append(li, t0);
      append(li, span1);
      append(span1, t1);
      append(li, t2);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5(ctx) {
  let div6;
  let div0;
  let t0;
  let div5;
  let div1;
  let t1;
  let div4;
  let div2;
  let ul0;
  let t2;
  let hr;
  let t3;
  let div3;
  let ul1;
  let mounted;
  let dispose;
  let each_value_1 = ctx[2];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div6 = element("div");
      div0 = element("div");
      t0 = space();
      div5 = element("div");
      div1 = element("div");
      t1 = space();
      div4 = element("div");
      div2 = element("div");
      ul0 = element("ul");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      hr = element("hr");
      t3 = space();
      div3 = element("div");
      ul1 = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "backdrop svelte-fhv297");
      attr(div1, "class", "close icon svelte-fhv297");
      attr(ul0, "class", "session svelte-fhv297");
      attr(hr, "class", "svelte-fhv297");
      attr(div2, "class", "top svelte-fhv297");
      attr(ul1, "class", "items svelte-fhv297");
      attr(div3, "class", "main svelte-fhv297");
      attr(div4, "class", "menu svelte-fhv297");
      attr(div5, "class", "bar svelte-fhv297");
      attr(div6, "class", "side-menu svelte-fhv297");
      toggle_class(div6, "collapsed", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      append(div6, t0);
      append(div6, div5);
      append(div5, div1);
      div1.innerHTML = SX_ICON_CLOSE;
      append(div5, t1);
      append(div5, div4);
      append(div4, div2);
      append(div2, ul0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(ul0, null);
      }
      append(div2, t2);
      append(div2, hr);
      append(div4, t3);
      append(div4, div3);
      append(div3, ul1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul1, null);
      }
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[3]),
          listen(div1, "click", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value_1 = ctx2[2];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(ul0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & 2) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 1) {
        toggle_class(div6, "collapsed", !ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_menu_expanded;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(6, $yw_navigator = $$value));
  component_subscribe($$self, yw_menu_expanded, ($$value) => $$invalidate(0, $yw_menu_expanded = $$value));
  getContext("page");
  const A_ITEMS = [
    {
      label: "Contacts",
      icon: SX_ICON_CONTACTS,
      click() {
        set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
        void $yw_navigator.activateThread(ThreadId.CONTACTS);
      }
    },
    {
      label: "Accounts",
      icon: SX_ICON_ACCOUNTS,
      click() {
        set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
        void $yw_navigator.activateThread(ThreadId.ACCOUNTS);
      }
    },
    {
      label: "Networks",
      icon: SX_ICON_CHAINS,
      click() {
        set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
        void $yw_navigator.activateThread(ThreadId.NETWORKS);
      }
    },
    {
      label: "Sites",
      icon: SX_ICON_CONNECTIONS,
      click() {
        set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
        void $yw_navigator.activateThread(ThreadId.SITES);
      }
    }
  ];
  const A_SESSION_ITEMS = [
    {
      label: "Log out",
      icon: SX_ICON_LOGOUT,
      click: F_NOOP
    }
  ];
  const click_handler2 = () => set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
  const click_handler_1 = () => set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
  const click_handler_2 = (g_item) => g_item.click();
  return [
    $yw_menu_expanded,
    A_ITEMS,
    A_SESSION_ITEMS,
    click_handler2,
    click_handler_1,
    click_handler_2
  ];
}
class SideMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$5, safe_not_equal, {});
  }
}
var VendorMenu_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ".font-family_mono.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{font-family:'PT Mono';white-space:pre}:root{--bar-width:78.8%;--animation-duration:1s;--animation-easing:var(--ease-out-quick)}@keyframes svelte-1y4wjl5-fade{0%{background-color:transparent}100%{background-color:rgba(0, 0, 0, 0.8)}}@keyframes svelte-1y4wjl5-opacity{0%{opacity:0}100%{opacity:1}}@keyframes svelte-1y4wjl5-offscreen{0%{top:0}100%{top:var(--app-window-height)}}.vendor-menu.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{--item-padding:30px;position:absolute;top:0;left:0;width:var(--app-window-width);height:var(--app-window-height);font-family:Poppins;font-weight:400;font-size:14px;z-index:1001;user-select:none}.vendor-menu.svelte-1y4wjl5>.backdrop.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(0, 0, 0, 0.8);transition:background-color var(--animation-duration) var(--ease-out-expo)}.vendor-menu.svelte-1y4wjl5>.bar.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{position:absolute;top:0;width:var(--bar-width);height:100%;background-color:var(--theme-color-bg);left:0%;opacity:1;transition:left var(--animation-duration) var(--animation-easing), opacity calc(var(--animation-duration) / 3) ease-out}.vendor-menu.svelte-1y4wjl5>.bar.svelte-1y4wjl5>.menu.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{display:flex;flex-direction:column;justify-content:space-evenly;height:100%}.vendor-menu.svelte-1y4wjl5>.bar>.menu ul.items .icon.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{--icon-color:var(--theme-color-black)}.vendor-menu.svelte-1y4wjl5>.bar>.menu ul.session .icon.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{--icon-color:var(--theme-color-text-med)}.vendor-menu.svelte-1y4wjl5>.bar.svelte-1y4wjl5>.menu.svelte-1y4wjl5>.main.svelte-1y4wjl5.svelte-1y4wjl5{flex:1;display:flex;flex-direction:column;justify-content:flex-start;padding-left:1em}.vendor-menu.svelte-1y4wjl5>.bar.svelte-1y4wjl5>.menu.svelte-1y4wjl5>.main.svelte-1y4wjl5>.svelte-1y4wjl5{border-bottom:1px solid var(--theme-color-border)}.vendor-menu.svelte-1y4wjl5>.bar.svelte-1y4wjl5>.menu.svelte-1y4wjl5>.main.svelte-1y4wjl5>.app.svelte-1y4wjl5{margin-top:10px;color:var(--theme-color-text-med);font-family:Poppins;font-weight:400;font-size:11px;padding:16px 0}.vendor-menu.svelte-1y4wjl5>.bar.svelte-1y4wjl5>.menu.svelte-1y4wjl5>.main.svelte-1y4wjl5>.info.svelte-1y4wjl5{padding:16px 0}.vendor-menu.svelte-1y4wjl5>.bar>.menu>.main>.info .name.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{color:var(--theme-color-text-med);font-family:Poppins;font-weight:400;font-size:11px}.vendor-menu.svelte-1y4wjl5>.bar>.menu>.main>.info .value.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{padding-top:4px}.vendor-menu.collapsed.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{pointer-events:none;top:0;animation:svelte-1y4wjl5-offscreen var(--animation-duration) steps(2, jump-none) both}.vendor-menu.collapsed.svelte-1y4wjl5>.backdrop.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{background-color:rgba(0, 0, 0, 0)}.vendor-menu.collapsed.svelte-1y4wjl5>.bar.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{left:calc(0% - var(--bar-width));opacity:0.1}.vendor-menu.svelte-1y4wjl5 .close.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5{position:absolute;top:0;right:0;margin:10px;padding:12px;cursor:pointer;--icon-diameter:24px;--icon-color:var(--theme-color-primary);outline:1px solid var(--theme-color-border);border-radius:0px;transition:border-radius 650ms var(--ease-out-expo);pointer-events:all}.vendor-menu.svelte-1y4wjl5 .close.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5::before{--occlusion-thickness:4px;content:'';position:absolute;top:calc(var(--occlusion-thickness) / 2);left:calc(var(--occlusion-thickness) / 2);width:calc(100% - var(--occlusion-thickness));height:calc(100% - var(--occlusion-thickness));outline:var(--occlusion-thickness) solid var(--theme-color-bg);box-sizing:border-box;pointer-events:none}.vendor-menu.svelte-1y4wjl5 .close.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5.svelte-1y4wjl5:hover{border-radius:22px}")();
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text("[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$2(ctx) {
  let t0_value = (ctx[1] / 1e3).toFixed(2) + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" seconds");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = (ctx2[1] / 1e3).toFixed(2) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_fragment$4(ctx) {
  let div26;
  let div0;
  let t0;
  let div25;
  let div1;
  let t1;
  let div24;
  let div23;
  let div4;
  let t4;
  let div7;
  let div5;
  let t6;
  let div6;
  let t7;
  let t8;
  let div10;
  let div8;
  let t10;
  let div9;
  let span0;
  let t11;
  let t12;
  let div13;
  let div11;
  let t14;
  let div12;
  let span1;
  let t15;
  let t16;
  let div16;
  let div14;
  let t18;
  let div15;
  let t19;
  let t20;
  let t21;
  let div19;
  let div17;
  let t23;
  let div18;
  let t24;
  let div22;
  let div20;
  let t26;
  let div21;
  let t27;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block$2;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div26 = element("div");
      div0 = element("div");
      t0 = space();
      div25 = element("div");
      div1 = element("div");
      t1 = space();
      div24 = element("div");
      div23 = element("div");
      div4 = element("div");
      div4.innerHTML = `<div></div> 

					<div>v0.0.1</div>`;
      t4 = space();
      div7 = element("div");
      div5 = element("div");
      div5.textContent = "Network Status";
      t6 = space();
      div6 = element("div");
      t7 = text(ctx[2]);
      t8 = space();
      div10 = element("div");
      div8 = element("div");
      div8.textContent = "Chain Id";
      t10 = space();
      div9 = element("div");
      span0 = element("span");
      t11 = text(ctx[4]);
      t12 = space();
      div13 = element("div");
      div11 = element("div");
      div11.textContent = "Current Provider";
      t14 = space();
      div12 = element("div");
      span1 = element("span");
      t15 = text(ctx[3]);
      t16 = space();
      div16 = element("div");
      div14 = element("div");
      div14.textContent = "Current Block Height";
      t18 = space();
      div15 = element("div");
      t19 = text("#");
      t20 = text(ctx[0]);
      t21 = space();
      div19 = element("div");
      div17 = element("div");
      div17.textContent = "Average Block Time";
      t23 = space();
      div18 = element("div");
      if_block.c();
      t24 = space();
      div22 = element("div");
      div20 = element("div");
      div20.textContent = "Last Block Seen";
      t26 = space();
      div21 = element("div");
      t27 = text(ctx[5]);
      attr(div0, "class", "backdrop svelte-1y4wjl5");
      attr(div1, "class", "close icon svelte-1y4wjl5");
      attr(div4, "class", "app svelte-1y4wjl5");
      attr(div5, "class", "name svelte-1y4wjl5");
      attr(div6, "class", "value svelte-1y4wjl5");
      attr(div7, "class", "info svelte-1y4wjl5");
      attr(div8, "class", "name svelte-1y4wjl5");
      attr(span0, "class", "font-family_mono svelte-1y4wjl5");
      attr(div9, "class", "value svelte-1y4wjl5");
      attr(div10, "class", "info svelte-1y4wjl5");
      attr(div11, "class", "name svelte-1y4wjl5");
      attr(span1, "class", "font-family_mono svelte-1y4wjl5");
      attr(div12, "class", "value svelte-1y4wjl5");
      attr(div13, "class", "info svelte-1y4wjl5");
      attr(div14, "class", "name svelte-1y4wjl5");
      attr(div15, "class", "value svelte-1y4wjl5");
      attr(div16, "class", "info svelte-1y4wjl5");
      attr(div17, "class", "name svelte-1y4wjl5");
      attr(div18, "class", "value svelte-1y4wjl5");
      attr(div19, "class", "info svelte-1y4wjl5");
      attr(div20, "class", "name svelte-1y4wjl5");
      attr(div21, "class", "value svelte-1y4wjl5");
      attr(div22, "class", "info svelte-1y4wjl5");
      attr(div23, "class", "main svelte-1y4wjl5");
      attr(div24, "class", "menu svelte-1y4wjl5");
      attr(div25, "class", "bar svelte-1y4wjl5");
      attr(div26, "class", "vendor-menu svelte-1y4wjl5");
      toggle_class(div26, "collapsed", !ctx[6]);
    },
    m(target, anchor) {
      insert(target, div26, anchor);
      append(div26, div0);
      append(div26, t0);
      append(div26, div25);
      append(div25, div1);
      append(div25, t1);
      append(div25, div24);
      append(div24, div23);
      append(div23, div4);
      append(div23, t4);
      append(div23, div7);
      append(div7, div5);
      append(div7, t6);
      append(div7, div6);
      append(div6, t7);
      append(div23, t8);
      append(div23, div10);
      append(div10, div8);
      append(div10, t10);
      append(div10, div9);
      append(div9, span0);
      append(span0, t11);
      append(div23, t12);
      append(div23, div13);
      append(div13, div11);
      append(div13, t14);
      append(div13, div12);
      append(div12, span1);
      append(span1, t15);
      append(div23, t16);
      append(div23, div16);
      append(div16, div14);
      append(div16, t18);
      append(div16, div15);
      append(div15, t19);
      append(div15, t20);
      append(div23, t21);
      append(div23, div19);
      append(div19, div17);
      append(div19, t23);
      append(div19, div18);
      if_block.m(div18, null);
      append(div23, t24);
      append(div23, div22);
      append(div22, div20);
      append(div22, t26);
      append(div22, div21);
      append(div21, t27);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[8]),
          listen(div1, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4)
        set_data(t7, ctx2[2]);
      if (dirty & 16)
        set_data(t11, ctx2[4]);
      if (dirty & 8)
        set_data(t15, ctx2[3]);
      if (dirty & 1)
        set_data(t20, ctx2[0]);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div18, null);
        }
      }
      if (dirty & 32)
        set_data(t27, ctx2[5]);
      if (dirty & 64) {
        toggle_class(div26, "collapsed", !ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div26);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $yw_chain_ref;
  let $yw_network;
  let $yw_menu_vendor;
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(11, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_network, ($$value) => $$invalidate(7, $yw_network = $$value));
  component_subscribe($$self, yw_menu_vendor, ($$value) => $$invalidate(6, $yw_menu_vendor = $$value));
  let s_height = "";
  let xt_when = 0;
  let xt_avg_block_time = 0;
  let s_network_status = "Loading";
  let p_provider = "";
  let si_chain = "";
  global_receive({
    blockInfo(g_info) {
      if ($yw_chain_ref === g_info.chain) {
        $$invalidate(2, s_network_status = "Online");
        $$invalidate(4, si_chain = g_info.header.chain_id);
        $$invalidate(0, s_height = g_info.header.height);
        xt_when = Date.now();
        const a_recents = g_info.recents;
        if (a_recents.length > 1) {
          const a_gaps = [];
          for (let i_each = 1; i_each < a_recents.length; i_each++) {
            a_gaps.push(a_recents[i_each] - a_recents[i_each - 1]);
          }
          $$invalidate(1, xt_avg_block_time = a_gaps.reduce((c_out, x_value) => c_out + x_value, 0) / a_gaps.length);
        }
      }
    }
  });
  let s_long_ago = "[...]";
  const i_long_ago = window.setInterval(() => {
    if (xt_when > 0) {
      const xt_ago = Date.now() - xt_when;
      $$invalidate(5, s_long_ago = `${Math.round(xt_ago / 1e3)} seconds ago`);
    }
  }, 500);
  onDestroy(() => {
    clearInterval(i_long_ago);
  });
  const click_handler2 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = false, $yw_menu_vendor);
  const click_handler_1 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = false, $yw_menu_vendor);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      if ($yw_network) {
        $$invalidate(0, s_height = "[...]");
        xt_when = 0;
        $$invalidate(1, xt_avg_block_time = 0);
        $$invalidate(2, s_network_status = "Connecting");
        $$invalidate(3, p_provider = new URL($yw_network.grpcWebUrl).host);
        $$invalidate(4, si_chain = "");
      }
    }
  };
  return [
    s_height,
    xt_avg_block_time,
    s_network_status,
    p_provider,
    si_chain,
    s_long_ago,
    $yw_menu_vendor,
    $yw_network,
    click_handler2,
    click_handler_1
  ];
}
class VendorMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$4, safe_not_equal, {});
  }
}
class Page {
  constructor(gc_page, _kt_parent) {
    __publicField(this, "_dc_creator");
    __publicField(this, "_yc_component");
    __publicField(this, "_h_props");
    __publicField(this, "_h_context");
    __publicField(this, "_dm_page");
    __publicField(this, "_si_page");
    __publicField(this, "_h_events", {});
    __publicField(this, "_sr_path");
    __publicField(this, "_sx_pattern");
    this._kt_parent = _kt_parent;
    ({
      creator: this._dc_creator,
      props: this._h_props = {},
      context: this._h_context = {}
    } = gc_page);
    this._si_page = crypto.randomUUID();
    const dm_buffer = dd("div");
    const hm_context = new Map(ode({
      ...this._h_context,
      page: this
    }));
    this._yc_component = new this._dc_creator({
      target: dm_buffer,
      props: {
        ...this._h_props,
        k_page: this
      },
      context: hm_context
    });
    if (gc_page.events) {
      for (const [si_event, f_listener] of ode(gc_page.events)) {
        this._yc_component.$on(si_event, f_listener);
      }
    }
    const dm_state = dm_buffer.firstElementChild;
    if (!dm_state) {
      throw new Error(`No DOM element was created during page component spawning using: ${JSON.stringify(gc_page)}`);
    }
    this._dm_page = dm_state;
  }
  get id() {
    return this._si_page;
  }
  get index() {
    return this.thread.history.length;
  }
  get thread() {
    return this._kt_parent;
  }
  get creator() {
    return this._dc_creator;
  }
  get component() {
    return this._yc_component;
  }
  get props() {
    return this._h_props;
  }
  get dom() {
    return this._dm_page;
  }
  equivalent(w_other) {
    return w_other.creator === this.creator && !objects_might_differ(w_other.props || {}, this.props);
  }
  peak() {
    return this._kt_parent.peak();
  }
  push(gc_page) {
    return this._kt_parent.push(gc_page, this);
  }
  pop(gc_pop) {
    return this._kt_parent.pop(gc_pop || {}, this);
  }
  jump(gc_page, gc_jump) {
    return this._kt_parent.jump(gc_page, gc_jump || {}, this);
  }
  on(h_events) {
    for (const [si_event, f_listener] of ode(h_events)) {
      if (f_listener) {
        const a_listeners = this._h_events[si_event] = this._h_events[si_event] || [];
        a_listeners.push(f_listener);
      }
    }
  }
  async fire(si_event, a_args) {
    const a_listeners = this._h_events[si_event];
    if (a_listeners) {
      await Promise.all(a_listeners.map((f) => f(...a_args || [])));
    }
  }
  destroy() {
    this._yc_component.$destroy();
  }
  reset() {
    this._kt_parent.reset();
  }
}
class Thread {
  constructor(_si_thread, _gc_default, _k_navigator) {
    __publicField(this, "_dm_thread");
    __publicField(this, "_a_history", []);
    this._si_thread = _si_thread;
    this._gc_default = _gc_default;
    this._k_navigator = _k_navigator;
    this._dm_thread = dd("div", {
      "class": "thread",
      "data-thread-id": this._si_thread,
      "style": "z-index: 100;"
    });
  }
  get id() {
    return this._si_thread;
  }
  get default() {
    return this._gc_default;
  }
  get history() {
    return this._a_history;
  }
  get page() {
    return this._a_history[0];
  }
  get dom() {
    return this._dm_thread;
  }
  _place(gc_page) {
    const kp_new = new Page({
      ...gc_page,
      context: {
        ...this._k_navigator.context,
        ...gc_page.context
      }
    }, this);
    this._dm_thread.appendChild(kp_new.dom);
    this._a_history.unshift(kp_new);
    return kp_new;
  }
  reset(gc_page = this.default, gc_reset) {
    const {
      keepTop: b_keep_top
    } = gc_reset || {};
    const a_history = this._a_history;
    for (let i_state = b_keep_top ? 1 : 0; i_state < a_history.length; i_state++) {
      a_history[i_state].component.$destroy();
    }
    a_history.length = 0;
    const kp_new = this._place(gc_page);
    void this._k_navigator.after_reset(this, kp_new, gc_reset || {});
    return kp_new;
  }
  peak() {
    return this._a_history[1];
  }
  push(gc_page, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from pushing new screen");
    }
    if (!this._k_navigator.before_push(gc_page, kp_src, this)) {
      throw new Error("Prevented inactive thread from pushing new screen");
    }
    const kp_new = this._place(gc_page);
    void this._k_navigator.after_push(this, kp_src, kp_new);
    return kp_new;
  }
  pop(gc_pop, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from popping active screen");
    }
    if (this._a_history.length < 2) {
      throw new Error(`Failed to pop empty history`);
    }
    if (!this._k_navigator.before_pop(gc_pop, this._a_history[1], kp_src, this)) {
      throw new Error("Prevented inactive thread from popping active screen");
    }
    this._a_history.shift();
    const kp_dst = this.page;
    void this._k_navigator.after_pop(this, kp_src, kp_dst, gc_pop);
    return kp_dst;
  }
  jump(gc_page, gc_jump, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from jumping to screen");
    }
    if (!this._k_navigator.before_jump(gc_jump, gc_page, kp_src, this)) {
      throw new Error("Prevented inactive thread from jumping to screen");
    }
    const kp_prev = this._a_history[1];
    if (!gc_jump.force && kp_prev?.equivalent(gc_page)) {
      return this.pop({}, kp_src);
    }
    const kp_dst = new Page(gc_page, this);
    this.reset();
    set_zindex_relatively(kp_dst.dom, kp_src.dom, 1);
    void this._k_navigator.after_jump(this, kp_src, kp_dst, gc_jump).then(() => {
      try {
        kp_src.destroy();
      } catch (e_destroy) {
        console.warn(`Failed to destroy stale component belonging to page: ${kp_src.creator.name + ""}`);
        kp_src.dom.remove();
      }
    });
    return kp_dst;
  }
  hide() {
    this._dm_thread.style.display = "none";
  }
  show() {
    this._dm_thread.style.display = "initial";
  }
}
function set_zindex_relatively(dm_src, dm_dst, n_order) {
  const iz_src = +dm_src.style.zIndex;
  const iz_dst = iz_src + n_order;
  dm_src.style.zIndex = iz_src + "";
  dm_dst.style.zIndex = iz_dst + "";
}
class Navigator {
  constructor(_gc_navigator) {
    __publicField(this, "_h_threads", {});
    __publicField(this, "_h_thread_spawners");
    __publicField(this, "_dm_threads");
    __publicField(this, "_dm_buffer", dd("div"));
    __publicField(this, "_g_hooks");
    __publicField(this, "_h_context");
    __publicField(this, "_si_thread", ThreadId.DEFAULT);
    __publicField(this, "_c_thread_z", 200);
    this._gc_navigator = _gc_navigator;
    ({
      container: this._dm_threads,
      threads: this._h_thread_spawners,
      hooks: this._g_hooks,
      context: this._h_context = {}
    } = _gc_navigator);
    this._new_thread(ThreadId.DEFAULT);
  }
  get context() {
    return this._h_context;
  }
  _new_thread(si_thread, h_props = {}, h_context = {}) {
    const f_spawner = this._h_thread_spawners[si_thread];
    if (!f_spawner) {
      throw new Error(`Navigator has no such thread registered: '${si_thread}'`);
    }
    const kt_new = new Thread(si_thread, f_spawner(h_props, h_context), this);
    this._h_threads[si_thread] = kt_new;
    this._dm_threads.appendChild(kt_new.dom);
    kt_new.reset({
      ...kt_new.default,
      props: {
        ...kt_new.default.props,
        ...h_props
      }
    });
    return kt_new;
  }
  get activeThread() {
    return this._h_threads[this._si_thread];
  }
  get activePage() {
    return this.activeThread.page;
  }
  before_push(gc_page, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (this._g_hooks.before_change?.(kt_child, kp_src, "push") === false)
      return false;
    if (this._g_hooks.before_push?.(kt_child, kp_src, gc_page) === false)
      return false;
    return true;
  }
  before_pop(gc_pop, kp_dst, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (this._g_hooks.before_change?.(kt_child, kp_src, "pop") === false)
      return false;
    if (this._g_hooks.before_pop?.(kt_child, kp_src, kp_dst, gc_pop) === false)
      return false;
    return true;
  }
  before_jump(gc_jump, gc_page, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (this._g_hooks.before_change?.(kt_child, kp_src, "jump") === false)
      return false;
    if (this._g_hooks.before_jump?.(kt_child, kp_src, gc_page, gc_jump) === false)
      return false;
    return true;
  }
  async before_switch(kt_src, si_thread) {
    if (this._g_hooks.before_change?.(kt_src, kt_src.page, "switch") === false)
      throw new Error("Cannot stop thread switch");
    await this._g_hooks.before_switch?.(kt_src, si_thread);
  }
  async after_push(kt_child, kp_src, kp_dst) {
    const h_extra = await this._g_hooks.after_push?.(kt_child, kp_src, kp_dst);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "push", h_extra || {});
  }
  async after_pop(kt_child, kp_src, kp_dst, gc_pop) {
    const h_extra = await this._g_hooks.after_pop?.(kt_child, kp_src, kp_dst, gc_pop);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "pop", h_extra || {});
  }
  async after_jump(kt_child, kp_src, kp_dst, gc_jump) {
    const h_extra = await this._g_hooks.after_jump?.(kt_child, kp_src, kp_dst, gc_jump);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "jump", h_extra || {});
  }
  async after_reset(kt_child, kp_dst, gc_reset) {
    const h_extra = await this._g_hooks.after_reset?.(kt_child, kp_dst, gc_reset);
    await this._g_hooks.after_change?.(kt_child, null, kp_dst, "reset", h_extra || {});
  }
  async after_switch(kt_src, kt_dst) {
    await this._g_hooks.after_switch?.(kt_src, kt_dst);
  }
  async activateThread(si_thread, h_props = {}) {
    const kt_src = this.activeThread;
    const kp_src = this.activePage;
    let kt_dst = this._h_threads[si_thread];
    if (si_thread !== this._si_thread) {
      await this.before_switch(kt_src, si_thread);
      this._si_thread;
      if (!kt_dst) {
        kt_dst = this._new_thread(si_thread, h_props);
      } else if (objects_might_differ(kt_dst.default.props || {}, h_props)) {
        const kp_dst = new Page({
          ...kt_dst.default,
          props: h_props,
          context: this._h_context
        }, kt_dst);
        kt_dst.reset(kp_dst, {
          keepTop: true
        });
        set_zindex_relatively(kp_src.dom, kp_dst.dom, -1);
      }
      this._si_thread = si_thread;
      this.activeThread.show();
      this.activeThread.dom.style.zIndex = this._c_thread_z++ + "";
      await this.after_switch(kt_src, kt_dst);
      return true;
    }
    return false;
  }
}
var System_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ".viewport.svelte-m1b0zj.svelte-m1b0zj{position:relative;width:100%;height:100%;overflow:hidden;color:var(--theme-color-text-light);background-color:var(--theme-color-bg)}.viewport.svelte-m1b0zj>.content.svelte-m1b0zj{position:relative;overflow:hidden;width:100%;height:100%}.viewport.svelte-m1b0zj>.content.exitting.svelte-m1b0zj{position:absolute;top:0;z-index:1001;user-select:none;pointer-events:none}.viewport > .content > .thread{position:absolute;width:100%;height:100%;top:0;left:0;padding-left:calc(50vw - (var(--app-max-width) / 2))}")();
function create_if_block$1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 25,
    blocks: [, , ,]
  };
  handle_promise(Vault.getRootKey(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[25] && create_if_block_1();
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1(ctx) {
  let overscrollsvelte;
  let t0;
  let navsvelte;
  let t1;
  let searchsvelte;
  let t2;
  let vendormenusvelte;
  let t3;
  let sidemenusvelte;
  let t4;
  let popupsvelte;
  let current;
  overscrollsvelte = new Overscroll({});
  navsvelte = new Nav({});
  searchsvelte = new Search({});
  vendormenusvelte = new VendorMenu({});
  sidemenusvelte = new SideMenu({});
  popupsvelte = new Popup({});
  return {
    c() {
      create_component(overscrollsvelte.$$.fragment);
      t0 = space();
      create_component(navsvelte.$$.fragment);
      t1 = space();
      create_component(searchsvelte.$$.fragment);
      t2 = space();
      create_component(vendormenusvelte.$$.fragment);
      t3 = space();
      create_component(sidemenusvelte.$$.fragment);
      t4 = space();
      create_component(popupsvelte.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overscrollsvelte, target, anchor);
      insert(target, t0, anchor);
      mount_component(navsvelte, target, anchor);
      insert(target, t1, anchor);
      mount_component(searchsvelte, target, anchor);
      insert(target, t2, anchor);
      mount_component(vendormenusvelte, target, anchor);
      insert(target, t3, anchor);
      mount_component(sidemenusvelte, target, anchor);
      insert(target, t4, anchor);
      mount_component(popupsvelte, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(overscrollsvelte.$$.fragment, local);
      transition_in(navsvelte.$$.fragment, local);
      transition_in(searchsvelte.$$.fragment, local);
      transition_in(vendormenusvelte.$$.fragment, local);
      transition_in(sidemenusvelte.$$.fragment, local);
      transition_in(popupsvelte.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overscrollsvelte.$$.fragment, local);
      transition_out(navsvelte.$$.fragment, local);
      transition_out(searchsvelte.$$.fragment, local);
      transition_out(vendormenusvelte.$$.fragment, local);
      transition_out(sidemenusvelte.$$.fragment, local);
      transition_out(popupsvelte.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overscrollsvelte, detaching);
      if (detaching)
        detach(t0);
      destroy_component(navsvelte, detaching);
      if (detaching)
        detach(t1);
      destroy_component(searchsvelte, detaching);
      if (detaching)
        detach(t2);
      destroy_component(vendormenusvelte, detaching);
      if (detaching)
        detach(t3);
      destroy_component(sidemenusvelte, detaching);
      if (detaching)
        detach(t4);
      destroy_component(popupsvelte, detaching);
    }
  };
}
function create_pending_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$3(ctx) {
  let main;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2;
  let progresssvelte;
  let t3;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  progresssvelte = new Progress({});
  let if_block = ctx[3] && create_if_block$1(ctx);
  return {
    c() {
      main = element("main");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(progresssvelte.$$.fragment);
      t3 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "content threads svelte-m1b0zj");
      attr(div1, "class", "content exitting svelte-m1b0zj");
      attr(main, "class", "viewport svelte-m1b0zj");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div0);
      ctx[8](div0);
      append(main, t0);
      append(main, div1);
      ctx[9](div1);
      append(main, t1);
      if (default_slot) {
        default_slot.m(main, null);
      }
      append(main, t2);
      mount_component(progresssvelte, main, null);
      append(main, t3);
      if (if_block)
        if_block.m(main, null);
      ctx[10](main);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[6], !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null), null);
        }
      }
      if (ctx2[3])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(progresssvelte.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(progresssvelte.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      ctx[8](null);
      ctx[9](null);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(progresssvelte);
      if (if_block)
        if_block.d();
      ctx[10](null);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_thread;
  let $yw_page;
  let $yw_account_ref;
  let $yw_account;
  let $yw_network_ref;
  let $yw_network_active;
  let $yw_chain_ref;
  let $yw_chain;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(11, $yw_navigator = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(12, $yw_thread = $$value));
  component_subscribe($$self, yw_page, ($$value) => $$invalidate(13, $yw_page = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(14, $yw_account_ref = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(15, $yw_account = $$value));
  component_subscribe($$self, yw_network_ref, ($$value) => $$invalidate(16, $yw_network_ref = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(17, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(18, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(19, $yw_chain = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { page } = $$props;
  const gc_page = page;
  let { mode } = $$props;
  const b_flow = mode === "flow";
  const b_main = mode === "app";
  let dm_viewport;
  let dm_threads;
  let dm_exitting;
  const h_context_all = Object.fromEntries(getAllContexts().entries());
  async function slide2(dm_slide, b_in) {
    await timeout(0);
    return new Promise((fk_resolve) => {
      dm_slide.addEventListener("transitionend", function transition_end(d_event) {
        if (d_event.propertyName === "transform") {
          dm_slide.classList.add("slid");
          fk_resolve();
        }
      });
      dm_slide.style.transform = `translateX(${b_in ? "0px" : "var(--app-window-width)"})`;
    });
  }
  onMount(async () => {
    const gc_navigator = {
      container: dm_threads,
      context: h_context_all,
      threads: {
        default: () => ({ creator: Blank })
      },
      hooks: {
        before_change(kt_context, kp_src, kp_dst) {
          void kp_src.fire("blur");
        },
        after_push(kt_context, kp_src, kp_dst) {
          void tick().then(() => {
            void slide2(kp_dst.dom, true);
          });
        },
        after_pop(kt_context, kp_src, kp_dst, gc_pop) {
          void kp_dst.fire("restore");
          if (!gc_pop.bypassAnimation) {
            kp_src.dom.style.transform = `translateX(var(--app-window-width))`;
          }
        },
        after_change(kt_context, kp_src, kp_dst, s_transition, h_extra = {}) {
          set_store_value(yw_page, $yw_page = kp_dst, $yw_page);
          set_store_value(yw_thread, $yw_thread = kt_context, $yw_thread);
          void kp_dst.fire("focus");
        },
        async before_switch() {
          try {
            await Promise.all([
              $yw_chain || once_store_updates(yw_chain, true),
              Chains.read().then((ks) => set_store_value(yw_chain_ref, $yw_chain_ref = ode(ks.raw)[0][0], $yw_chain_ref)),
              $yw_network_active || once_store_updates(yw_network_active, true),
              Networks.read().then((ks) => set_store_value(yw_network_ref, $yw_network_ref = ode(ks.raw)[0][0], $yw_network_ref)),
              $yw_account || once_store_updates(yw_account, true),
              Accounts.read().then((ks) => set_store_value(yw_account_ref, $yw_account_ref = ode(ks.raw)[0][0], $yw_account_ref))
            ]);
            delete this.before_switch;
          } catch (e_load_default) {
          }
        },
        async after_switch(kt_src, kt_dst) {
          set_store_value(yw_page, $yw_page = kt_dst.page, $yw_page);
          set_store_value(yw_thread, $yw_thread = kt_dst, $yw_thread);
          void kt_dst.page.fire("focus");
          await tick();
          await slide2(kt_dst.page.dom, true);
        }
      }
    };
    if (b_flow) {
      gc_navigator.threads = { default: () => gc_page };
    } else if (b_main) {
      gc_navigator.threads = oderom(H_THREADS, (si_thread, dc_screen) => {
        return {
          [si_thread]: (h_props) => ({ creator: dc_screen, props: h_props })
        };
      });
      gc_navigator.threads.init = (h_props, h_context) => ({
        ...gc_page,
        props: { ...gc_page.props, ...h_props },
        context: { ...gc_page.context, ...h_context }
      });
    }
    const k_navigator = new Navigator(gc_navigator);
    set_store_value(yw_navigator, $yw_navigator = k_navigator, $yw_navigator);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_threads = $$value;
      $$invalidate(1, dm_threads);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_exitting = $$value;
      $$invalidate(2, dm_exitting);
    });
  }
  function main_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_viewport = $$value;
      $$invalidate(0, dm_viewport);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("page" in $$props2)
      $$invalidate(4, page = $$props2.page);
    if ("mode" in $$props2)
      $$invalidate(5, mode = $$props2.mode);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    dm_viewport,
    dm_threads,
    dm_exitting,
    b_main,
    page,
    mode,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    main_binding
  ];
}
class System extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$3, safe_not_equal, { page: 4, mode: 5 });
  }
}
var Authenticate_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ".welcome{align-items:center;justify-content:center;text-align:center;gap:20px;padding-left:16px;padding-right:16px;background-image:url('/media/vendor/orb-1.svg');background-repeat:no-repeat;background-position:center top;background-size:cover;padding-top:calc(50vh - 200px)}.welcome > div.logo,.welcome > div.title{margin-left:auto !important;margin-right:auto !important}.line.svelte-wsweyo{width:calc(100% - 40px);height:1px;background:radial-gradient(50% 50% at 50% 50%, #FFC700 0%, rgba(255, 199, 0, 0) 100%)}")();
function create_if_block(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 2)
        set_data(t, ctx2[1]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_1(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "name", "password");
      attr(input, "placeholder", "Password");
      toggle_class(input, "invalid", ctx[1]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (dirty & 2) {
        toggle_class(input, "invalid", ctx2[1]);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$1(ctx) {
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t3;
  let div3;
  let field;
  let t4;
  let actionsline;
  let t5;
  let log_1;
  let updating_items;
  let current;
  field = new Field({
    props: {
      key: "password",
      name: "",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      confirm: ["Unlock", ctx[3]]
    }
  });
  function log_1_items_binding(value) {
    ctx[5](value);
  }
  let log_1_props = { hide: true };
  if (ctx[2].items !== void 0) {
    log_1_props.items = ctx[2].items;
  }
  log_1 = new Log({ props: log_1_props });
  binding_callbacks.push(() => bind(log_1, "items", log_1_items_binding));
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<img width="96" src="/media/vendor/logo-96px.png" srcset="/media/vendor/logo-96px.png 1x, /media/vendor/logo-192px.png 2x" alt="StarShell"/>`;
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<img src="/media/vendor/title.svg" alt=""/>`;
      t1 = space();
      div2 = element("div");
      div2.textContent = "\xA0";
      t3 = space();
      div3 = element("div");
      create_component(field.$$.fragment);
      t4 = space();
      create_component(actionsline.$$.fragment);
      t5 = space();
      create_component(log_1.$$.fragment);
      attr(div0, "class", "logo");
      attr(div1, "class", "title");
      attr(div2, "class", "line svelte-wsweyo");
      attr(div3, "class", "form flex-rows");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      insert(target, t3, anchor);
      insert(target, div3, anchor);
      mount_component(field, div3, null);
      insert(target, t4, anchor);
      mount_component(actionsline, target, anchor);
      insert(target, t5, anchor);
      mount_component(log_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 1027) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
      const log_1_changes = {};
      if (!updating_items && dirty & 4) {
        updating_items = true;
        log_1_changes.items = ctx2[2].items;
        add_flush_callback(() => updating_items = false);
      }
      log_1.$set(log_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      transition_in(log_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      transition_out(log_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div3);
      destroy_component(field);
      if (detaching)
        detach(t4);
      destroy_component(actionsline, detaching);
      if (detaching)
        detach(t5);
      destroy_component(log_1, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let t;
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Authenticate",
      classNames: "welcome",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1031) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(screen, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const completed = getContext("completed");
  let sh_password = "";
  let s_err_password = "";
  let b_busy = false;
  let xt_start = 0;
  let k_logger = new Logger();
  function log(s_msg) {
    $$invalidate(2, k_logger = k_logger.event(s_msg, Date.now() - xt_start));
  }
  async function attempt_unlock(b_recover = false) {
    if (b_busy)
      return 1;
    b_busy = true;
    const exit = () => (b_busy = false, 1);
    $$invalidate(1, s_err_password = "");
    xt_start = Date.now();
    log("Estimating time to complete");
    {
      const xt_start_est = window.performance.now();
      await Vault.deriveRootBits(ATU8_DUMMY_PHRASE, ATU8_DUMMY_VECTOR, 1 / 50);
      const xt_finish_est = window.performance.now();
      const xt_elapsed = xt_finish_est - xt_start_est;
      const xt_estimate = 2 * (xt_elapsed * 50);
      log(`About ${(xt_estimate / 1e3).toFixed(1)} seconds`);
    }
    try {
      await login(sh_password, b_recover, log);
    } catch (e_login) {
      if (e_login instanceof UnregisteredError) {
        $$invalidate(1, s_err_password = "No accounts detected");
      } else if (e_login instanceof InvalidPassphraseError) {
        $$invalidate(1, s_err_password = "Invalid passphrase");
      } else if (e_login instanceof RecoverableVaultError) {
        $$invalidate(1, s_err_password = "Vault is partially corrupted; attempting recovery...");
        return await attempt_unlock(true);
      } else if (b_recover) {
        $$invalidate(1, s_err_password = `Recovery failed. Vault may be irreparably corrupted.
${e_login.message}`);
      } else if (e_login instanceof CorruptedVaultError) {
        $$invalidate(1, s_err_password = `Vault appears to be irreparably corrupted.
${e_login.message}`);
      } else {
        $$invalidate(1, s_err_password = `Unknown error occurred: ${e_login.stack || e_login.message}`);
      }
      return exit();
    }
    if (completed)
      completed(true);
    return exit();
  }
  function input_input_handler() {
    sh_password = this.value;
    $$invalidate(0, sh_password);
  }
  function log_1_items_binding(value) {
    if ($$self.$$.not_equal(k_logger.items, value)) {
      k_logger.items = value;
      $$invalidate(2, k_logger);
    }
  }
  return [
    sh_password,
    s_err_password,
    k_logger,
    attempt_unlock,
    input_input_handler,
    log_1_items_binding
  ];
}
class Authenticate extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment$2, safe_not_equal, {});
  }
}
const dm_log = qs(document, "section#dom-log");
const dm_log_list = qs(document, "#dom-log-list");
function domlog(si_msg) {
  console.log(si_msg);
  dm_log_list?.append(dd("li", {}, [
    dd("pre", {}, [si_msg])
  ]));
}
var Horizon_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ".horizon.svelte-12kmiz9{width:calc(100% - 40px);height:1px;background:radial-gradient(50% 50% at 50% 50%, #FFC700 0%, rgba(255, 199, 0, 0) 100%);margin-left:auto;margin-right:auto}")();
function create_fragment$1(ctx) {
  let div;
  let raw_value = "&nbsp;";
  return {
    c() {
      div = element("div");
      attr(div, "class", "no-margin horizon svelte-12kmiz9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class Horizon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1, safe_not_equal, {});
  }
}
var PreRegister_svelte_svelte_type_style_lang = /* @__PURE__ */ (() => ".preregister{align-items:center;justify-content:center;text-align:center;gap:20px;padding-left:16px;padding-right:16px;background-image:url('/media/vendor/orb-1.svg');background-repeat:no-repeat;background-position:center top;background-size:cover;padding-top:calc(50vh - 150px)}")();
function create_default_slot(ctx) {
  let starshelllogo;
  let t0;
  let starshelltitle;
  let t1;
  let horizon;
  let t2;
  let div2;
  let t6;
  let p;
  let t7;
  let actionsline;
  let current;
  starshelllogo = new StarShellLogo({ props: { dim: 96 } });
  starshelltitle = new StarShellTitle({});
  horizon = new Horizon({});
  actionsline = new ActionsLine({
    props: {
      confirm: ["Get Started"],
      contd: { creator: Register }
    }
  });
  return {
    c() {
      create_component(starshelllogo.$$.fragment);
      t0 = space();
      create_component(starshelltitle.$$.fragment);
      t1 = space();
      create_component(horizon.$$.fragment);
      t2 = space();
      div2 = element("div");
      div2.innerHTML = `<div>Welcome to the beta program.</div> 
		<div>Thank for you being a tester!</div>`;
      t6 = space();
      p = element("p");
      t7 = space();
      create_component(actionsline.$$.fragment);
      attr(div2, "class", "large");
    },
    m(target, anchor) {
      mount_component(starshelllogo, target, anchor);
      insert(target, t0, anchor);
      mount_component(starshelltitle, target, anchor);
      insert(target, t1, anchor);
      mount_component(horizon, target, anchor);
      insert(target, t2, anchor);
      insert(target, div2, anchor);
      insert(target, t6, anchor);
      insert(target, p, anchor);
      insert(target, t7, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      transition_in(starshelltitle.$$.fragment, local);
      transition_in(horizon.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      transition_out(starshelltitle.$$.fragment, local);
      transition_out(horizon.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starshelllogo, detaching);
      if (detaching)
        detach(t0);
      destroy_component(starshelltitle, detaching);
      if (detaching)
        detach(t1);
      destroy_component(horizon, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(p);
      if (detaching)
        detach(t7);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      root: true,
      classNames: "preregister",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
class PreRegister extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}
export { AccountEdit as A, Blank as B, Header as H, PreRegister as P, Screen as S, ThreadId as T, System as a, domlog as b, Authenticate as c, dm_log as d };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJlUmVnaXN0ZXIuZmVjYjViZDguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0JsYW5rLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL1NjcmVlbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3VpL1N0YXJTaGVsbExvZ28uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9PdmVybGF5U2VsZWN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL2Fycm93LWxlZnQuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3NlYXJjaC5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2FwcC91aS9IZWFkZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9Mb2cuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9TdGFyU2hlbGxUaXRsZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9SZWdpc3RlcldlYWtQYXNzd29yZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9SZWdpc3Rlci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvaWNvbi9hY2NvdW50X2JveC5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vYW5hbHl0aWNzLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvaWNvbi9kb251dF9sYXJnZS5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2FwcC91aS9Bc3NldFNlbGVjdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvaWNvbi9leHBhbmRfbGVzcy5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vZXhwYW5kX21vcmUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvQW1vdW50SW5wdXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9TZW5kZXJTZWxlY3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9JbmxpbmVDb250YWN0U2VsZWN0aW9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvUmVjaXBpZW50U2VsZWN0SXRlbS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3VpL1JlY2lwaWVudFNlbGVjdFNlbGVjdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3VpL1JlY2lwaWVudFNlbGVjdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvaWNvbi91c2VyLWFzdHJvbmF1dC5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vRGVhZEVuZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9TZW5kLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvR2FwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvSW5saW5lUGlsbHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vVG9rZW5zQWRkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jaGFpbi9jb2luLnRzIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSG9sZGluZ1ZpZXcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSG9sZGluZ3NIb21lLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRFZGl0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRDcmVhdGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vQWNjb3VudFZpZXcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vQWNjb3VudHNIb21lLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGFicy9zcmMvaWQuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRhYnMvc3JjL1RhYnMuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10YWJzL3NyYy9UYWIuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10YWJzL3NyYy9UYWJMaXN0LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGFicy9zcmMvVGFiUGFuZWwuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vQ29udGFjdFZpZXcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vaW1hZ2Uuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvSWNvbkVkaXRvci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9Db250YWN0RWRpdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvaWNvbi9tb3JlLXZlcnQuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3VwbG9hZC5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2FwcC91aS9Db250YWN0TGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9Db250YWN0c0hvbWUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vU2l0ZXNIb21lLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL05ldHdvcmtzSG9tZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL2RlZi50cyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL3N5c3RlbS9PdmVyc2Nyb2xsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL3N5c3RlbS9Qb3B1cC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvaWNvbi9leHBhbmQuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3Rva2Vucy5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vaGlzdG9yeS5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vbWVudS5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2FwcC9jb250YWluZXIvc3lzdGVtL05hdi5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UuZXNtLmpzIiwiLi4vLi4vLi4vc3JjL2FwcC9jb250YWluZXIvc3lzdGVtL1NlYXJjaC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vUHJvZ3Jlc3Muc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vc3VwZXJ2aXNvcl9hY2NvdW50LnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvaWNvbi9tZWRpYXRpb24uc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2FjY291bnRfY2lyY2xlLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvaWNvbi9hY2NvdW50X3RyZWUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3NlbnNvcl9kb29yLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vU2lkZU1lbnUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9jb250YWluZXIvc3lzdGVtL1ZlbmRvck1lbnUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9uYXYvcGFnZS50cyIsIi4uLy4uLy4uL3NyYy9hcHAvbmF2L3RocmVhZC50cyIsIi4uLy4uLy4uL3NyYy9hcHAvbmF2L25hdmlnYXRvci50cyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL1N5c3RlbS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9BdXRoZW50aWNhdGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2VudHJ5L2ZhbGxiYWNrLnRzIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9Ib3Jpem9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL1ByZVJlZ2lzdGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3BhbiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj48L3NwYW4+XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIiBsYW5nPVwidHNcIj5cblx0bGV0IGNfc2NyZWVucyA9IDA7XG48L3NjcmlwdD5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYXJyaXZhbCwgeXdfYmx1ciwgeXdfaGVscCwgeXdfbmF2X2NvbGxhcHNlZCwgeXdfbmF2X3Zpc2libGUsIHl3X292ZXJzY3JvbGxfcGN0LCB5d19wcm9ncmVzcyB9IGZyb20gJyMvYXBwL21lbSc7XG5cblx0aW1wb3J0IHR5cGUgeyBQYWdlIH0gZnJvbSAnLi4vc2NyZWVuL19zY3JlZW5zJztcblxuXHRpbXBvcnQgeyB0aW1lb3V0IH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIGdldENvbnRleHQsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgbmF2ID0gZmFsc2U7XG5cdGNvbnN0IGJfbmF2ID0gbmF2O1xuXG5cdGV4cG9ydCBsZXQgZGVidWcgPSAnJztcblx0ZXhwb3J0IGxldCBwcm9ncmVzczogbnVsbCB8IFtudW1iZXIsIG51bWJlcl0gPSBudWxsO1xuXHRleHBvcnQgbGV0IGZ1bGwgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBrZXllZCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGNsYXNzTmFtZXMgPSAnJztcblxuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRleHBvcnQgbGV0IGxlYXZlcyA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IHN3aXBlcyA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IHJvb3QgPSAwID09PSBrX3BhZ2UuaW5kZXg7XG5cdGV4cG9ydCBsZXQgc2xpZGVzID0gIWxlYXZlcyAmJiAhc3dpcGVzICYmICFyb290O1xuXHRjb25zdCBiX3NsaWRlcyA9IHNsaWRlcztcblxuXHRleHBvcnQgbGV0IGZvcm0gPSBmYWxzZTtcblx0Y29uc3QgYl9mb3JtID0gISFmb3JtO1xuXG5cdGV4cG9ydCBsZXQgdHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuXHRsZXQgZG1fc2NyZWVuOiBIVE1MRWxlbWVudDtcblxuXHQvLyBAbXZwXG5cdGxldCBkbV9oZWxwOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG5cdGNvbnN0IHNpX2V4aXQgPSBsZWF2ZXM/ICdsZWF2ZXMnOiBzd2lwZXM/ICdzd2lwZXMnOiAnJztcblxuXHRjb25zdCBkaXNwYXRjaEV2ZW50ID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cdG9uTW91bnQoKCkgPT4ge1xuXHRcdGlmKCFrX3BhZ2UpIHtcblx0XHRcdGNvbnNvbGUud2FybihgJHtkZWJ1ZyB8fCAndW5rbm93bid9IFNjcmVlbiBtaXNzaW5nIHBhZ2UgY29udGV4dGApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGxpc3RlbiBmb3IgcGFnZSBldmVudHNcblx0XHRcdGtfcGFnZS5vbih7XG5cdFx0XHRcdC8vIG9uIHBhZ2UgZm9jdXNcblx0XHRcdFx0Zm9jdXMoKSB7XG5cdFx0XHRcdFx0Ly8gc2V0IG5hdiB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0JHl3X25hdl92aXNpYmxlID0gYl9uYXY7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyAvLyBzY3JvbGxpbmdcblx0XHQvLyBkbV9zY3JlZW4uYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZGVfd2hlZWwpID0+IHtcblx0XHQvLyBcdC8vIG92ZXJzY3JvbGxcblx0XHQvLyBcdGlmKDAgPT09IGRtX3NjcmVlbi5zY3JvbGxUb3ApIHtcblx0XHQvLyBcdFx0aWYoZGVfd2hlZWwuRE9NX0RFTFRBX1BJWEVMID09PSBkZV93aGVlbC5kZWx0YU1vZGUpIHtcblx0XHQvLyBcdFx0XHQvLyBjb25zdCB4X2RlbHRhX3kgPSBkZV93aGVlbC5kZWx0YVk7XG5cdFx0Ly8gXHRcdFx0Ly8gY29uc3QgeF9wY3QgPSBNYXRoLm1pbihNYXRoLmFicyh4X2RlbHRhX3kpLCA1MCkgLyA1MDtcblx0XHQvLyBcdFx0XHQvLyAkeXdfb3ZlcnNjcm9sbF9wY3QgPSB4X3BjdDtcblx0XHQvLyBcdFx0XHQvLyBjb25zb2xlLmxvZygoeF9wY3QgKiAxMDApLnRvRml4ZWQoMikpO1xuXG5cdFx0Ly8gXHRcdFx0Ly8gY29uc29sZS5sb2coe1xuXHRcdC8vIFx0XHRcdC8vIFx0ZGVsdGFZOiBkZV93aGVlbC5kZWx0YVksXG5cdFx0Ly8gXHRcdFx0Ly8gXHQvLyB3aGVlbERlbHRhWTogZGVfd2hlZWwud2hlZWxEZWx0YVksXG5cdFx0Ly8gXHRcdFx0Ly8gXHRzY3JlZW5ZOiBkZV93aGVlbC5zY3JlZW5ZLFxuXHRcdC8vIFx0XHRcdC8vIFx0bW9kZTogZGVfd2hlZWwuZGVsdGFNb2RlLFxuXHRcdC8vIFx0XHRcdC8vIH0pO1xuXHRcdC8vIFx0XHR9XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSk7XG5cblx0XHQvLyBhcnJpdmFsKGRtX3NjcmVlbiwgKCkgPT4ge1xuXHRcdC8vIFx0Y29uc29sZS5sb2coJ2Fycml2ZWQgdG8gc2NyZWVuJyk7XG5cdFx0Ly8gXHQkeXdfbmF2X3Zpc2libGUgPSBuYXY7XG5cdFx0Ly8gXHQvLyAkeXdfbmF2X2NvbGxhcHNlZCA9ICFuYXY7XG5cblx0XHQvLyBcdC8vIGlmKG5hdikge1xuXHRcdC8vIFx0Ly8gXHQkeXdfbmF2X3Zpc2libGUgPSB0cnVlO1xuXHRcdC8vIFx0Ly8gfVxuXG5cdFx0Ly8gXHRpZihwcm9ncmVzcykge1xuXHRcdC8vIFx0XHQkeXdfcHJvZ3Jlc3MgPSBwcm9ncmVzcztcblx0XHQvLyBcdH1cblxuXHRcdC8vIFx0JHl3X2hlbHAgPSBkbV9oZWxwXG5cdFx0Ly8gXHRcdD8gQXJyYXkuZnJvbShkbV9oZWxwLmNsb25lTm9kZSh0cnVlKS5jaGlsZE5vZGVzKSBhcyBIVE1MRWxlbWVudFtdXG5cdFx0Ly8gXHRcdDogW107XG5cblx0XHQvLyBcdGRpc3BhdGNoRXZlbnQoJ2Fycml2ZScpO1xuXHRcdC8vIH0pO1xuXG5cdFx0Ly8gaWYgc2NyZWVuIGhhcyBrZXllZCBzdmVsdGUgY29tcG9uZW50c1xuXHRcdGlmKGtleWVkKSB7XG5cdFx0XHRsZXQgeF9zY3JvbGxfdG9wID0gMDtcblxuXHRcdFx0Ly8gc3ZlbHRlIHdpbGwgcmVwbGFjZSB0aG9zZSBlbGVtZW50cyB3aGVuIGNoYW5naW5nIHNjcmVlbnNcblx0XHRcdChuZXcgTXV0YXRpb25PYnNlcnZlcihhc3luYyhhX211dGF0aW9ucykgPT4ge1xuXHRcdFx0XHQvLyBrZXllZCBjb21wb25lbnQgd2FzIHJlbW92ZWRcblx0XHRcdFx0aWYoYV9tdXRhdGlvbnNbMF0/LmFkZGVkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHhfc2Nyb2xsX3RvcCA9IGRtX3NjcmVlbi5zY3JvbGxUb3A7XG5cdFx0XHRcdFx0fSBjYXRjaChlX251bGwpIHt9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8ga2V5ZWQgY29tcG9uZW50IHdhcyByZXN0b3JlZFxuXHRcdFx0XHRlbHNlIGlmKGFfbXV0YXRpb25zWzBdPy5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYoZG1fc2NyZWVuKSB7XG5cdFx0XHRcdFx0XHRkbV9zY3JlZW4uc2Nyb2xsVG9wID0geF9zY3JvbGxfdG9wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSkpLm9ic2VydmUoZG1fc2NyZWVuLCB7XG5cdFx0XHRcdGNoaWxkTGlzdDogdHJ1ZSxcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0ZXhwb3J0IGxldCBzdHlsZSA9ICcnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdGRpdi5ib3VuZHMge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0cGFkZGluZy1sZWZ0OiBjYWxjKDUwdncgLSAodmFyKC0tYXBwLW1heC13aWR0aCkgLyAyKSk7XG5cdH1cblxuXHQuc2xpZGVzIHtcblx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoY2FsYyh2YXIoLS1hcHAtd2luZG93LXdpZHRoKSAvIDIpKTtcblx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC42cyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdH1cblxuXHRAbWVkaWEocHJlZmVycy1yZWR1Y2VkLW1vdGlvbikge1xuXHRcdC5zbGlkZXMge1xuXHRcdFx0dHJhbnNpdGlvbjogbm9uZSAwcyBsaW5lYXI7XG5cdFx0fVxuXHR9XG5cblx0c2VjdGlvbi5zY3JlZW4sZm9ybS5zY3JlZW4ge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRtYXgtd2lkdGg6IHZhcigtLWFwcC1tYXgtd2lkdGgpO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblxuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblxuXHRcdC5mb250KHJlZ3VsYXIpO1xuXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXG5cdFx0b3BhY2l0eTogMTtcblx0XHRmaWx0ZXI6IGJsdXIoMCk7XG5cblx0XHQvLyB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC42cyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cblx0XHQmLnRyYW5zcGFyZW50IHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdH1cblxuXHRcdCYucHJvZ3Jlc3Mge1xuXHRcdFx0cGFkZGluZy10b3A6IDIycHg7XG5cdFx0fVxuXG5cdFx0Ji5uYXYge1xuXHRcdFx0cGFkZGluZy1ib3R0b206IDcxcHg7XG5cdFx0fVxuXG5cdFx0Ji5mbGV4IHtcblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0YWxpZ24taXRlbXM6IHN0cmV0Y2g7XG5cdFx0XHRnYXA6IHZhcigtLWdhcCwgdmFyKC0tdWktcGFkZGluZykpO1xuXG5cdFx0XHQ+OmZpcnN0LWNoaWxkOm5vdCgubm8tbWFyZ2luKSB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1hcmdpbi10b3A6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCY+KiB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGZsZXg6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ6Z2xvYmFsKCY6bm90KC5uby1tYXJnaW4pKSB7XG5cdFx0XHRcdFx0bWFyZ2luOiAwIHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHQmLnNjcm9sbCB7XG5cdFx0XHRvdmVyZmxvdy15OiBzY3JvbGw7XG5cdFx0XHRvdmVyc2Nyb2xsLWJlaGF2aW9yLXk6IGNvbnRhaW47XG5cdFx0XHQuaGlkZS1zY3JvbGxiYXIoKTtcblx0XHR9XG5cblx0XHQvLyAmLnNsaWRlcyB7XG5cdFx0Ly8gXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoY2FsYyh2YXIoLS1hcHAtd2luZG93LXdpZHRoKSAvIDIpKTtcblx0XHQvLyBcdHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjZzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0XHQvLyB9XG5cblx0XHQmLnNsaWQge1xuXHRcdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuNXMgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdH1cblxuXHRcdCZbZGF0YS1zMi1leGl0XTpub3QoW2RhdGEtczItZXhpdD0nJ10pIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQvLyBsZWZ0OiAwO1xuXHRcdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMHB4KTtcblx0XHRcdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuNXMgdmFyKC0tZWFzZS1vdXQtcXVpbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdEBrZXlmcmFtZXMgZmFkZS1hd2F5IHtcblx0XHRcdDAlIHtcblx0XHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdH1cblxuXHRcdFx0NzUlIHtcblx0XHRcdFx0b3BhY2l0eTogMDtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0QGtleWZyYW1lcyBibHVyLWF3YXkge1xuXHRcdFx0MCUge1xuXHRcdFx0XHRmaWx0ZXI6IGJsdXIoMCk7XG5cdFx0XHR9XG5cblx0XHRcdDEwMCUge1xuXHRcdFx0XHRmaWx0ZXI6IGJsdXIoMTRweCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0QGtleWZyYW1lcyBzY2FsZS11cCB7XG5cdFx0XHQwJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogc2NhbGUoMSk7XG5cdFx0XHR9XG5cblx0XHRcdDEwMCUge1xuXHRcdFx0XHR0cmFuc2Zvcm06IHNjYWxlKDEuNzUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEBrZXlmcmFtZXMgc3VibGltYXRlIHtcblx0XHQvLyBcdDAlIHtcblx0XHQvLyBcdFx0b3BhY2l0eTogMTtcblx0XHQvLyBcdFx0dHJhbnNmb3JtOiBzY2FsZSgxKTtcblx0XHQvLyBcdFx0ZmlsdGVyOiBibHVyKDApO1xuXHRcdC8vIFx0fVxuXG5cdFx0Ly8gXHQyNSUge1xuXHRcdC8vIFx0XHRmaWx0ZXI6IGJsdXIoMTRweCk7XG5cdFx0Ly8gXHR9XG5cblx0XHQvLyBcdDgwJSB7XG5cdFx0Ly8gXHRcdG9wYWNpdHk6IDA7XG5cdFx0Ly8gXHR9XG5cblx0XHQvLyBcdDEwMCUge1xuXHRcdC8vIFx0XHR0cmFuc2Zvcm06IHNjYWxlKDEuNzUpXG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfVxuXG5cdFx0QGtleWZyYW1lcyB0dXJuLWF3YXkge1xuXHRcdFx0MCUge1xuXHRcdFx0XHR0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDBweCkgcm90YXRlWSgwZGVnKTtcblx0XHRcdH1cblxuXHRcdFx0MSUge1xuXHRcdFx0XHR0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDE1MDBweCkgcm90YXRlWSgwZGVnKTtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMTUwMHB4KSByb3RhdGVZKC04MGRlZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0QGtleWZyYW1lcyBmYWRlLW91dCB7XG5cdFx0XHQwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0XHR9XG5cblx0XHRcdDEwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0XHR9XG5cblx0XHRcdDgwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDA7XG5cdFx0XHR9XG5cblx0XHRcdDEwMCUge1xuXHRcdFx0XHRvcGFjaXR5OiAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCYuc3VibGltYXRlIHtcblx0XHRcdC8vIGFuaW1hdGlvbjogXG5cdFx0XHQvLyBcdHNjYWxlLXVwIDEwMDBtcyB2YXIoLS1lYXNlLW91dC1jdWJpYykgZm9yd2FyZHMsXG5cdFx0XHQvLyBcdGZhZGUtYXdheSAxMDAwbXMgdmFyKC0tZWFzZS1vdXQtcXVhZCkgZm9yd2FyZHMsXG5cdFx0XHQvLyBcdGJsdXItYXdheSAyMDBtcyB2YXIoLS1lYXNlLW91dC1xdWFkKSBmb3J3YXJkcztcblxuXHRcdFx0Ly8gLS1taW1pYzogMTAwMG1zIHZhcigtLWVhc2Utb3V0LXF1aW50KSBmb3J3YXJkcztcblx0XHRcdC8vIGFuaW1hdGlvbjogdHVybi1hd2F5IHZhcigtLW1pbWljKSxcblx0XHRcdC8vIFx0ZmFkZS1vdXQgdmFyKC0tbWltaWMpO1xuXHRcdFx0Ly8gdHJhbnNmb3JtLW9yaWdpbjogMTIwJTtcblxuXHRcdFx0dHJhbnNpdGlvbjogb3BhY2l0eSA0MDBtcyB2YXIoLS1lYXNlLW91dC1xdWFkKTtcblx0XHRcdG9wYWNpdHk6IDA7XG5cdFx0fVxuXG5cdFx0Ji5tYXRlcmlhbGl6ZSB7XG5cblx0XHR9XG5cblx0XHQ+Kjpub3QoLmhlYWRlcikge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdHRyYW5zaXRpb246IGZpbHRlciA0MDBtcyB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ji5ibHVyIHtcblx0XHRcdD4qOm5vdCguaGVhZGVyKSB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGZpbHRlcjogYmx1cigycHgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cblxuXHRcdC8qXG5cdFx0XHRDb3BpZWQgZnJvbSBzY3JlZW4ubGVzc1xuXHRcdCovXG5cdFx0KiB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC50ZXh0Om5vdChidXR0b24gLnRleHQpOm5vdCgucm93IC50ZXh0KSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0dXNlci1zZWxlY3Q6IHRleHQ7XG5cdFx0XHRcdGN1cnNvcjogZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpbnB1dCx0ZXh0YXJlYSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0dXNlci1zZWxlY3Q6IGluaXRpYWw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnZhbGlkYXRpb24tbWVzc2FnZSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0LmZvbnQodGlueSk7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1jYXV0aW9uKTtcblx0XHRcdFx0dGV4dC1hbGlnbjogcmlnaHQ7XG5cdFx0XHRcdHdpZHRoOiAxMDAlO1xuXG5cdFx0XHRcdHBhZGRpbmctdG9wOiAzcHg7XG5cdFx0XHRcdG1hcmdpbi1sZWZ0OiAtOXB4O1xuXHRcdFx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnVzZXItc2VsZWN0X2FsbCB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0dXNlci1zZWxlY3Q6IGFsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuYWN0aW9ucy13YWxsLCAuYWN0aW9ucy1saW5lIHtcblx0XHRcdGJ1dHRvbiB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1pbi1oZWlnaHQ6IHZhcigtLXVpLXJvdy1oZWlnaHQpO1xuXHRcdFx0XHRcdG1heC1oZWlnaHQ6IHZhcigtLXVpLXJvdy1oZWlnaHQpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXG5cdFx0XHRcdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0tdWktYm9yZGVyLXJhZGl1cyk7XG5cblx0XHRcdFx0XHR0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDFzIHZhcigtLWVhc2Utb3V0LWV4cG8pLFxuXHRcdFx0XHRcdFx0Y29sb3IgMnMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ji5wcmltYXJ5IHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWRhcmspO1xuXHRcdFx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0JjpkaXNhYmxlZCwmW3JlYWRvbmx5PVwidHJ1ZVwiXSB7XG5cdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdFx0XHRcdFx0Y3Vyc29yOiBub3QtYWxsb3dlZDtcblx0XHRcdFx0XHRcdFx0b3BhY2l0eTogMC40O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJ1dHRvbiB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0XHR9XG5cblx0XHRcdCYucGlsbCB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdC5mb250KHJlZ3VsYXIsIEBzaXplOiAxMXB4LCBAd2VpZ2h0OiA1MDApO1xuXHRcdFx0XHRcdG1hcmdpbjogMDtcblx0XHRcdFx0XHRwYWRkaW5nOiAwLjRlbSAxZW07XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdGJvcmRlci1yYWRpdXM6IDQwMGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aDMge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGZvbnQtd2VpZ2h0OiA1MDA7XG5cdFx0XHRcdG1hcmdpbjogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuYWN0aW9uLXdhbGwge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xuXHRcdFx0XHRnYXA6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0fVxuXG5cdFx0XHQmPmJ1dHRvbiB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGZsZXg6IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRwIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udChyZWd1bGFyLCBAd2VpZ2h0OiAzMDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5mb3JtLWVudHJ5KCkge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0XHRoZWlnaHQ6IHZhcigtLXVpLXJvdy1oZWlnaHQpO1xuXHRcdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0XHRwYWRkaW5nLWxlZnQ6IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHRcdGJvcmRlci1yYWRpdXM6IHZhcigtLXVpLWJvcmRlci1yYWRpdXMpO1xuXHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXG5cdFx0XHRcdGZvbnQtd2VpZ2h0OiAzMDA7XG5cdFx0XHR9XG5cblx0XHRcdCY6OnBsYWNlaG9sZGVyIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0Zm9udC13ZWlnaHQ6IDMwMDtcblx0XHRcdFx0XHQvLyBjb2xvcjogcmdiKDExNywxMTcsMTE3KTtcblx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdG9wYWNpdHk6IDAuNztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQmOmZvY3VzIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0b3V0bGluZTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aW5wdXQge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGZvbnQtc2l6ZTogaW5oZXJpdDtcblx0XHRcdH1cblxuXHRcdFx0Jlt0eXBlPVwidGV4dFwiXSwmW3R5cGU9XCJwYXNzd29yZFwiXSwmW3R5cGU9XCJudW1iZXJcIl0ge1xuXHRcdFx0XHQuZm9ybS1lbnRyeSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQmLmludmFsaWQ6bm90KDpmb2N1cykge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1jYXV0aW9uKSAhaW1wb3J0YW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCYuYWRkcmVzcyB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdC5mb250KG1vbm8tdGlueSk7XG5cdFx0XHRcdFx0bGV0dGVyLXNwYWNpbmc6IDAuMjVweDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5zZWxlY3RDb250YWluZXIuaW52YWxpZCB7XG5cdFx0XHRpbnB1dCB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pICFpbXBvcnRhbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZXh0YXJlYSB7XG5cdFx0XHQuZm9ybS1lbnRyeSgpO1xuXG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0LmZvbnQocmVndWxhcik7XG5cblx0XHRcdFx0cGFkZGluZzogMWV4IDJleDtcblx0XHRcdFx0aGVpZ2h0OiAxMC43NWV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0LmZsZXgtcm93cyB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0YWxpZ24taXRlbXM6IHN0cmV0Y2g7XG5cdFx0XHRcdGdhcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHR9XG5cblx0XHRcdCY+KiB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGZsZXg6IDA7XG5cdFx0XHRcdFx0bWFyZ2luLXRvcDogMDtcblx0XHRcdFx0XHRtYXJnaW4tYm90dG9tOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmZvbnQtdmFyaWFudF9tb25vIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udChtb25vKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuZm9udC12YXJpYW50X21vbm8tdGlueSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0LmZvbnQobW9uby10aW55KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuY29sb3ItaWNvbi1zZW5kIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3Itb3JhbmdlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuY29sb3ItaWNvbi1yZWN2IHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3Itc2xpbWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5saW5rIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdH1cblxuXHRcdFx0Jjpob3ZlciB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnN2ZWx0ZS10YWJzIHtcblx0XHRcdD51bC5zdmVsdGUtdGFic19fdGFiLWxpc3Qge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRcdGp1c3RpZnktY29udGVudDogc3RyZXRjaDtcblxuXHRcdFx0XHRcdG1hcmdpbi1sZWZ0OiBjYWxjKDBweCAtIHZhcigtLXVpLXBhZGRpbmcpKTtcblx0XHRcdFx0XHRtYXJnaW4tcmlnaHQ6IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHRcdFx0XHRcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0PmxpLnN2ZWx0ZS10YWJzX190YWIge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0ZmxleDogMTtcblx0XHRcdFx0XHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblxuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWdyYXltZWQpO1xuXHRcdFx0XHRcdFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRcdFx0XHRcdFx0cGFkZGluZzogMTJweCAwLjc1ZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ji5zdmVsdGUtdGFic19fc2VsZWN0ZWQge1xuXHRcdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHRcdFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQ+ZGl2LnN2ZWx0ZS10YWJzX190YWItcGFuZWwge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRtYXJnaW4tdG9wOiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG48L3N0eWxlPlxuPCEtLSBjbGFzczpzbGlkZXM9e3NsaWRlc30gLS0+XG5cbjxkaXYgY2xhc3M9XCJib3VuZHNcIlxuXHRjbGFzczpzbGlkZXM9e2Jfc2xpZGVzfVxuPlxuXHQ8Zm9ybVxuXHRcdGNsYXNzPVwic2NyZWVuIHtjbGFzc05hbWVzfVwiXG5cdFx0Y2xhc3M6ZmxleD17dHJ1ZX1cblx0XHRjbGFzczpzY3JvbGw9e3RydWV9XG5cdFx0Y2xhc3M6bmF2PXtiX25hdn1cblx0XHRjbGFzczpwcm9ncmVzcz17cHJvZ3Jlc3N9XG5cdFx0Y2xhc3M6dHJhbnNwYXJlbnQ9e3RyYW5zcGFyZW50fVxuXHRcdGNsYXNzOnN1YmxpbWF0ZT17ZmFsc2V9XG5cdFx0Y2xhc3M6Ymx1cj17JHl3X2JsdXJ9XG5cdFx0ZGF0YS1zMi1leGl0PXtzaV9leGl0fVxuXHRcdGJpbmQ6dGhpcz17ZG1fc2NyZWVufVxuXHRcdG9uOnN1Ym1pdD17ZF9ldmVudCA9PiB2b2lkIGRfZXZlbnQucHJldmVudERlZmF1bHQoKX1cblx0XHRvbjpzdWJtaXRcblx0XHRzdHlsZT1cIntzdHlsZX1cIlxuXHRcdGF1dG9jb21wbGV0ZT1cIm9mZlwiXG5cdD5cblx0XHQ8c2xvdD48L3Nsb3Q+XG5cblx0XHR7I2lmICdoZWxwJyBpbiAkJHNsb3RzfVxuXHRcdFx0PGRpdiBjbGFzcz1cImRpc3BsYXlfbm9uZVwiIGJpbmQ6dGhpcz17ZG1faGVscH0+XG5cdFx0XHRcdDxzbG90IG5hbWU9XCJoZWxwXCIgLz5cblx0XHRcdDwvZGl2PlxuXHRcdHsvaWZ9XG5cdDwvZm9ybT5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgRl9OT09QIH0gZnJvbSBcIiMvdXRpbC9iZWx0XCI7XG5cblx0LyoqXG5cdCAqIHRhcmdldCBkaW1lbnNpbm9zXG5cdCAqL1xuXHRleHBvcnQgbGV0IGRpbTogMzIgfCA0OCB8IDY0IHwgOTYgfCAxMjg7XG5cdGNvbnN0IHhfZGltID0gZGltO1xuXG5cdC8qKlxuXHQgKiBhbHRlcm5hdGl2ZSB0ZXh0XG5cdCAqL1xuXHRleHBvcnQgbGV0IGFsdCA9ICdTdGFyU2hlbGwgbG9nbyc7XG5cdGNvbnN0IHNfYWx0ID0gYWx0O1xuXG5cdGNvbnN0IGZfc3JjID0gKHg6IG51bWJlcikgPT4gYC9tZWRpYS92ZW5kb3IvbG9nby0ke3h9cHgucG5nYDtcblxuXHRjb25zdCBzcl9kZWZhdWx0ID0gZl9zcmMoeF9kaW0pO1xuXHRjb25zdCBzcl9kb3VibGUgPSBmX3NyYyh4X2RpbSAqIDIpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQubG9nbyB7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0Ym9yZGVyOiAwO1xuXHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0bWFyZ2luLWxlZnQ6IGF1dG87XG5cdFx0bWFyZ2luLXJpZ2h0OiBhdXRvO1xuXG5cdFx0aW1nIHtcblx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPHBpY3R1cmUgY2xhc3M9XCJuby1tYXJnaW4gbG9nb1wiIHN0eWxlPVwid2lkdGg6e3hfZGltfXB4OyBoZWlnaHQ6e3hfZGltfXB4O1wiIG9uOmNsaWNrPlxuXHQ8c291cmNlIHNyY3NldD1cIntzcl9kb3VibGV9XCIgbWVkaWE9XCIobWluLXJlc29sdXRpb246IDJkcHB4KVwiPlxuXHQ8aW1nIGFsdD17c19hbHR9IHNyYz1cIntzcl9kZWZhdWx0fVwiIC8+XG48L3BpY3R1cmU+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge3l3X2JsdXJ9IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCBTWF9JQ09OX0FERF9TTUFMTCBmcm9tICcjL2ljb24vYWRkLXNtYWxsLnN2Zz9yYXcnO1xuXHRcblx0ZXhwb3J0IGxldCB0aXRsZTogc3RyaW5nO1xuXHRleHBvcnQgbGV0IG9wZW4gPSB0cnVlO1xuXG5cdCQ6ICR5d19ibHVyID0gb3BlbjtcblxuXHRsZXQgYl9zaG93aW5nID0gZmFsc2U7XG5cdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdGJfc2hvd2luZyA9IHRydWU7XG5cdH0sIDEwKTtcblxuXHRmdW5jdGlvbiBwYXVzZShkbTogSFRNTEVsZW1lbnQsIGdjOiBhbnkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZHVyYXRpb246IDIwMCxcblx0XHR9O1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LmNhbmNlbCB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHR6LWluZGV4OiA1MDAwO1xuXG5cdFx0Ji5zaG93aW5nIHtcblx0XHRcdD4ub3ZlcmxheSB7XG5cdFx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0XHRcdC8vIGhlaWdodDogYXV0bztcblx0XHRcdFx0aGVpZ2h0OiAzMjBweDtcblxuXHRcdFx0XHRtYXgtaGVpZ2h0OiAzMjBweDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQub3ZlcmxheSB7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHR0b3A6IDRlbTtcblx0XHRcdHJpZ2h0OiAyMHB4O1xuXHRcdFx0ei1pbmRleDogMTAwMDtcblx0XHRcdHdpZHRoOiAzMDBweDtcblx0XHRcdHBhZGRpbmctbGVmdDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHRwYWRkaW5nLXJpZ2h0OiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdHBhZGRpbmctYm90dG9tOiB2YXIoLS11aS1wYWRkaW5nKTtcblxuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjk1KTtcblx0XHRcdGJvcmRlci1yYWRpdXM6IDhweDtcblx0XHRcdG1heC1oZWlnaHQ6IDMyMHB4O1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRvdmVyc2Nyb2xsLWJlaGF2aW9yOiBjb250YWluO1xuXHRcdFx0b3ZlcmZsb3c6IHNjcm9sbDtcblx0XHRcdC5oaWRlLXNjcm9sbGJhcigpO1xuXG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0b3BhY2l0eTogMC4yNTtcblx0XHRcdHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXMgbGluZWFyLCBoZWlnaHQgMjUwbXMgdmFyKC0tZWFzZS1vdXQtZXhwbyk7XG5cdFx0XHRoZWlnaHQ6IDA7XG5cblx0XHRcdD4udG9wIHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXG5cdFx0XHRcdD5oMyB7XG5cdFx0XHRcdFx0bWFyZ2luOiAxNnB4IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LmFkZC1uZXcge1xuXHRcdFx0XHRcdD4uaWNvbiB7XG5cdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDhweDtcblx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdD4ucm93cyB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdC0tcm93LXBhZGRpbmc6IDEycHg7XG5cblxuXHRcdFx0XHQub3ZlcmxheS1zZWxlY3QuaWNvbiB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDIwcHg7XG5cdFx0XHRcdFx0XHRhbGlnbi1zZWxmOiBjZW50ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5yb3cge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0cGFkZGluZy10b3A6IHZhcigtLXJvdy1wYWRkaW5nKSAhaW1wb3J0YW50O1xuXHRcdFx0XHRcdFx0cGFkZGluZy1sZWZ0OiAwICFpbXBvcnRhbnQ7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLXJpZ2h0OiB2YXIoLS1yb3ctcGFkZGluZykgIWltcG9ydGFudDtcblx0XHRcdFx0XHRcdHBhZGRpbmctYm90dG9tOiB2YXIoLS1yb3ctcGFkZGluZykgIWltcG9ydGFudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJjYW5jZWxcIlxuXHRjbGFzczpzaG93aW5nPXtiX3Nob3dpbmd9XG5cdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0Yl9zaG93aW5nID0gZmFsc2U7XG5cdFx0b3BlbiA9IGZhbHNlO1xuXHR9fVxuPlxuXHQ8ZGl2IGNsYXNzPVwib3ZlcmxheSBzZWxlY3RcIiBvdXQ6cGF1c2U+XG5cdFx0PGRpdiBjbGFzcz1cInRvcFwiPlxuXHRcdFx0PGgzPlxuXHRcdFx0XHR7dGl0bGV9XG5cdFx0XHQ8L2gzPlxuXG5cdFx0XHQ8YnV0dG9uIGNsYXNzPVwicGlsbCBhZGQtbmV3XCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdHtAaHRtbCBTWF9JQ09OX0FERF9TTUFMTH1cblx0XHRcdFx0XHQ8IS0tIDxpbWcgc3JjPVwiL21lZGlhL2FjdGlvbi9hZGQtc21hbGwuc3ZnXCIgYWx0PVwiXCI+IC0tPlxuXHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdFx0QWRkIE5ld1xuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJyb3dzXCI+XG5cdFx0XHQ8c2xvdCBuYW1lPVwicm93c1wiPjwvc2xvdD5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLWFycm93LWxlZnQtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0PC9zdHlsZT5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLWFycm93LWxlZnQtZmdcXFwiIGQ9XFxcIk0yMCwxMVYxM0g4TDEzLjUsMTguNUwxMi4wOCwxOS45Mkw0LjE2LDEyTDEyLjA4LDQuMDhMMTMuNSw1LjVMOCwxMUgyMFpcXFwiLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItc2VhcmNoLWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1zZWFyY2gtZmdcXFwiIGQ9XFxcIk0xNS41IDE0aC0uNzlsLS4yOC0uMjdBNi40NzEgNi40NzEgMCAwIDAgMTYgOS41IDYuNSA2LjUgMCAxIDAgOS41IDE2YzEuNjEgMCAzLjA5LS41OSA0LjIzLTEuNTdsLjI3LjI4di43OWw1IDQuOTlMMjAuNDkgMTlsLTQuOTktNXptLTYgMEM3LjAxIDE0IDUgMTEuOTkgNSA5LjVTNy4wMSA1IDkuNSA1IDE0IDcuMDEgMTQgOS41IDExLjk5IDE0IDkuNSAxNHpcXFwiLz5cXG48L3N2Zz5cXG5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IFN0YXJTaGVsbExvZ28gZnJvbSAnLi9TdGFyU2hlbGxMb2dvLnN2ZWx0ZSc7XG5cdGltcG9ydCBPdmVybGF5U2VsZWN0IGZyb20gJy4vT3ZlcmxheVNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgUGZwRGlzcGxheSBmcm9tICcuL1BmcERpc3BsYXkuc3ZlbHRlJztcblx0aW1wb3J0IENsb3NlIGZyb20gJy4vQ2xvc2Uuc3ZlbHRlJztcblx0aW1wb3J0IFJvdyBmcm9tICcuL1Jvdy5zdmVsdGUnO1xuXG5cdGltcG9ydCBTWF9JQ09OX0FSUk9XX0xFRlQgZnJvbSAnIy9pY29uL2Fycm93LWxlZnQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX1NFQVJDSCBmcm9tICcjL2ljb24vc2VhcmNoLnN2Zz9yYXcnO1xuXHRcblx0aW1wb3J0IHtcblx0XHR5d19hY2NvdW50LFxuXHRcdHl3X2NhbmNlbF9zZWFyY2gsXG5cdFx0eXdfY2hhaW4sXG5cdFx0eXdfY2hhaW5fcmVmLFxuXHRcdHl3X21lbnVfdmVuZG9yLFxuXHRcdHl3X292ZXJsYXlfYWNjb3VudCxcblx0XHR5d19vdmVybGF5X25ldHdvcmssXG5cdFx0eXdfc2VhcmNoLFxuXHRcdHl3X3RocmVhZCxcblx0fSBmcm9tICcuLi9tZW0nO1xuXG5cdGltcG9ydCB0eXBlIHtcblx0XHRQYWdlLFxuXHR9IGZyb20gJyMjL3NjcmVlbi9fc2NyZWVucyc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgQWNjb3VudHMgfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHsgcXMgfSBmcm9tICcjL3V0aWwvZG9tJztcblx0XG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIGluY2x1ZGVzIGEgYmFjayBidXR0b24gdG8gcG9wIHRoaXMgcGFnZSBmcm9tIHRoZSBzdGFja1xuXHQgKi9cblx0ZXhwb3J0IGxldCBwb3BzID0gZmFsc2U7XG5cdGNvbnN0IGJfcG9wcyA9IHBvcHM7XG5cblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgaW5jbHVkZXMgYW4gZXhpdCBidXR0b24gdG8gcmVzZXQgdGhlIHN0YWNrXG5cdCAqL1xuXHRleHBvcnQgbGV0IGV4aXRzID0gZmFsc2U7XG5cdGNvbnN0IGJfZXhpdHMgPSBleGl0cztcblxuXHQvKipcblx0ICogSWYgYHRydWVgLCBkb2VzIG5vdCBkaXNwbGF5IHRoZSBsb2dvIGluIGNhc2VzIHdoZXJlIHRoZSBsb2dvIHdvdWxkIGRpc3BsYXlcblx0ICovXG5cdGV4cG9ydCBsZXQgcGxhaW4gPSBmYWxzZTtcblx0Y29uc3QgYl9wbGFpbiA9IHBsYWluO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIGFsbG93cyB0aGUgYWNjb3VudCB0byBiZSBzd2l0Y2hlZFxuXHQgKi9cblx0ZXhwb3J0IGxldCBhY2NvdW50ID0gZmFsc2U7XG5cdGNvbnN0IGJfYWNjb3VudCA9IGFjY291bnQ7XG5cblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgYWxsb3dzIHRoZSBuZXR3b3JrIHRvIGJlIHN3aXRjaGVkXG5cdCAqL1xuXHRleHBvcnQgbGV0IG5ldHdvcmsgPSBmYWxzZTtcblx0Y29uc3QgYl9uZXR3b3JrID0gbmV0d29yaztcblxuXHQvKipcblx0ICogSWYgYHRydWVgLCBpbmNsdWRlcyBhIHNlYXJjaCBpbnB1dCBib3hcblx0ICovXG5cdGV4cG9ydCBsZXQgc2VhcmNoID0gZmFsc2U7XG5cdGNvbnN0IGJfc2VhcmNoID0gc2VhcmNoO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJpbWFyeSB0aXRsZSB0byBkaXNwbGF5XG5cdCAqL1xuXHRleHBvcnQgbGV0IHRpdGxlID0gJyc7XG5cdGNvbnN0IHNfdGl0bGUgPSB0aXRsZTtcblxuXHQvKipcblx0ICogQSBzaG9ydCBzdHJpbmcgdG8gZGlzcGxheSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgdGhlIHRpdGxlXG5cdCAqL1xuXHRleHBvcnQgbGV0IHN5bWJvbCA9ICcnO1xuXHRjb25zdCBzX3N5bWJvbCA9IHN5bWJvbDtcblxuXHQvKipcblx0ICogVGhlIHN1YnN0aXRsZSB0byBkaXNwbGF5IHVuZGVyIHRoZSBwcmltYXJ5IHRpdGxlXG5cdCAqL1xuXHRleHBvcnQgbGV0IHN1YnRpdGxlID0gJyc7XG5cdGNvbnN0IHNfc3VidGl0bGUgPSBzdWJ0aXRsZTtcblxuXHQvLyBldmVudCBkaXNwYXRjaGVyIGZvciBwYXJlbnQgY29tcG9uZW50XG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cblx0Ly8gZGltZW5zaW9uIG9mIHRoZSBhY2NvdW50IGFuZCBuZXR3b3JrIGljb25zXG5cdGNvbnN0IG92ZXJsYXlfcGZwX3Byb3BzID0gKGJfbWlycm9yPWZhbHNlKSA9PiAoe1xuXHRcdGRpbTogMjEsXG5cdFx0Ymc6ICdzYXRpbicsXG5cdFx0Z2VuU3R5bGU6ICdmb250LXNpemU6MjFweDsnLFxuXHRcdHJvb3RTdHlsZTogYFxuXHRcdFx0cGFkZGluZzogNXB4IDZweDtcblx0XHRcdGJvcmRlcjogMnB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRib3JkZXItcmFkaXVzOiAke2JfbWlycm9yPyAnMCA0cHggNHB4IDAnOiAnNHB4IDAgMCA0cHgnfTtcblx0XHRgLnJlcGxhY2UoL1xccysvZywgJyAnKSxcblx0fSkgYXMgY29uc3Q7XG5cblx0Ly8gZ2V0IHBhZ2UgZnJvbSBjb250ZXh0XG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHQvLyAkOiBwX2FjY291bnRfaWNvbiA9IGJfYWNjb3VudD8gJHl3X2FjY291bnQ/LmRlZj8uaWNvblJlZjogbnVsbDtcblxuXG5cdGxldCBkbV9oZWFkZXI6IEhUTUxFbGVtZW50O1xuXG5cdGxldCBkbV9zZWFyY2g6IEhUTUxFbGVtZW50O1xuXG5cdC8vIGltcG9ydCBTWF9TRUFSQ0ggZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvZmlsbGVkL3NlYXJjaC5zdmc/cmF3JztcblxuXHQvLyBpbXBvcnQgU1hfTE9HTyBmcm9tICcjL2Fzc2V0L3ZlbmRvci9sb2dvLnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfRFJPUF9ET1dOIGZyb20gJyMvYXNzZXQvbmF2L2Ryb3AtZG93bi5zdmc/cmF3JztcblxuXHQvLyBpbXBvcnQgU1hfQ0hFQ0tFRCBmcm9tICcjL2Fzc2V0L25hdi9jaGVja2VkLWNpcmNsZS5zdmc/cmF3JztcblxuXHQvLyBpbXBvcnQgUHV0IGZyb20gJy4vUHV0LnN2ZWx0ZSc7XG5cdC8vIGltcG9ydCB7IGZvcm1hdF9maWF0LCBIX0FDQ09VTlRTLCBIX0NIQUlOUywgSF9IT0xESU5HUywgSF9JQ09OUywgSF9UT0tFTlMsIEhfVkVSU1VTX1VTRCB9IGZyb20gJyMvc2ltL2RhdGEnO1xuXHQvLyBpbXBvcnQgeyBtaWNyb3Rhc2ssIG9kZSwgdGltZW91dCB9IGZyb20gJyMvdXRpbC9iZWx0Jztcblx0Ly8gaW1wb3J0IHsgcXMgfSBmcm9tICcjL3V0aWwvZG9tJztcblx0Ly8gaW1wb3J0IENsb3NlIGZyb20gJy4vQ2xvc2Uuc3ZlbHRlJztcblx0Ly8gaW1wb3J0IE92ZXJsYXlTZWxlY3QgZnJvbSAnLi9PdmVybGF5U2VsZWN0LnN2ZWx0ZSc7XG5cdC8vIGltcG9ydCBSb3cgZnJvbSAnLi9Sb3cuc3ZlbHRlJztcblxuXHQvLyBpbXBvcnQge1xuXHQvLyBcdEFjY291bnQsXG5cdC8vIFx0SWNvbixcblx0Ly8gXHRIb2xkaW5nLFxuXHQvLyB9IGZyb20gJyMvb2JqZWN0cyc7XG5cdC8vIGltcG9ydCBQZnAgZnJvbSAnLi9QZnAuc3ZlbHRlJztcblxuXG5cblx0ZXhwb3J0IGxldCBpc1NlYXJjaFNjcmVlbiA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IHNlYXJjaF9pbnB1dCA9ICcnO1xuXG5cdGxldCBzX3NlYXJjaCA9ICR5d19zZWFyY2g7XG5cblxuXHQvLyBvbk1vdW50KCgpID0+IHtcblx0Ly8gXHRpZigkeXdfc2VhcmNoKSB7XG5cdC8vIFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0Ly8gXHRcdFx0Y29uc29sZS5sb2coJ3N0ZWFsaW5nIGZvY3VzIGZvciBlbnRyeSBzZWFyY2gnKTtcblx0Ly8gXHRcdFx0ZG1fc2VhcmNoLmZvY3VzKCk7XG5cdC8vIFx0XHR9LCAwKTtcblx0Ly8gXHR9XG5cdC8vIH0pO1xuXG5cdHl3X3NlYXJjaC5zdWJzY3JpYmUoKHNfdmFsdWUpID0+IHtcblx0XHRpZihpc1NlYXJjaFNjcmVlbiAmJiBzX3ZhbHVlKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnc2VhcmNoIHNjcmVlbiBhbmQgc2VhcmNoIHRleHQnKTtcblx0XHRcdHNfc2VhcmNoID0gc192YWx1ZTtcblx0XHRcdGlmKGRtX3NlYXJjaCkge1xuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRkbV9zZWFyY2guZm9jdXMoKTtcblx0XHRcdFx0fSwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYoIXNfdmFsdWUpIHtcblx0XHRcdHNfc2VhcmNoID0gJyc7XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiB1cGRhdGVfc2VhcmNoKGRfZXZlbnQ6IEV2ZW50KSB7XG5cdFx0Ly8gY3VycmVudGx5IGluIHNlYXJjaCB0aHJlYWRcblx0XHRpZihpc1NlYXJjaFNjcmVlbikge1xuXHRcdFx0Ly8gc2VhcmNoIGlzIGJlaW5nIGNhbmNlbGxlZFxuXHRcdFx0aWYoIXNfc2VhcmNoKSB7XG5cdFx0XHRcdCR5d19zZWFyY2ggPSAnJztcblx0XHRcdFx0JHl3X2NhbmNlbF9zZWFyY2goKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRkaXNwYXRjaCgnc2VhcmNoJywgc19zZWFyY2gpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBub3Qgc2VhcmNoIHNjcmVlbiwgYnV0IHVzZXIgdHlwZWQgc29tZXRoaW5nXG5cdFx0ZWxzZSBpZihzX3NlYXJjaCkge1xuXHRcdFx0Y29uc3Qgc2lfY2FjaGUgPSAkeXdfdGhyZWFkLmlkO1xuXG5cdFx0XHRjb25zdCBkbV9mb2N1cyA9IHFzKGRtX2hlYWRlciwgJzpmb2N1cycpIGFzIEhUTUxFbGVtZW50O1xuXHRcdFx0aWYoZG1fZm9jdXMpIHtcblx0XHRcdFx0ZG1fZm9jdXMuYmx1cigpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkbV9oZWFkZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG5cdFx0XHQvLyBjb25zdCBkbV9jbG9uZSA9ICR5d19zY3JlZW5fZG9tLmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRWxlbWVudDtcblx0XHRcdC8vICR5d19leGl0dGluZ19kb20uYXBwZW5kKGRtX2Nsb25lKVxuXG5cdFx0XHQvLyAkeXdfaGVhZGVyX3Byb3BzID0ge1xuXHRcdFx0Ly8gXHRwb3BzLFxuXHRcdFx0Ly8gXHRhY2NvdW50LFxuXHRcdFx0Ly8gXHRuZXR3b3JrLFxuXHRcdFx0Ly8gXHRzZWFyY2gsXG5cdFx0XHQvLyBcdG5hbWUsXG5cdFx0XHQvLyBcdHN5bWJvbCxcblx0XHRcdC8vIFx0c3VibmFtZSxcblx0XHRcdC8vIFx0c2VhcmNoX2lucHV0OiAkeXdfc2VhcmNoLFxuXHRcdFx0Ly8gfTtcblxuXHRcdFx0JHl3X2NhbmNlbF9zZWFyY2ggPSAoKSA9PiB7XG5cdFx0XHRcdC8vIGRtX2hlYWRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXHRcdFx0XHQvLyAkeXdfc2VhcmNoID0gJyc7XG5cblx0XHRcdFx0Ly8gJHl3X3RocmVhZF9pZCA9IHNpX2NhY2hlO1xuXG5cdFx0XHRcdHNfc2VhcmNoID0gJyc7XG5cblx0XHRcdFx0Y29uc29sZS5sb2coJ3N0ZWFsaW5nIGZvY3VzIGZvciBjYW5jZWwgc2VhcmNoJyk7XG5cdFx0XHRcdGRtX3NlYXJjaC5mb2N1cygpO1xuXHRcdFx0fTtcblxuXG5cdFx0XHQvLyBzYXZlIHNlYXJjaCBzdHJpbmdcblx0XHRcdCR5d19zZWFyY2ggPSBzX3NlYXJjaDtcblxuXHRcdFx0Ly8gLy8gc2V0IHRocmVhZFxuXHRcdFx0Ly8gJHl3X3RocmVhZF9pZCA9IFRocmVhZElkLlNFQVJDSDtcblx0XHR9XG5cdH1cblxuXHQvLyBhc3luYyBmdW5jdGlvbiBzZWFyY2hfaW5wdXQoKSB7XG5cdC8vIFx0YXdhaXQgdGljaygpO1xuXHQvLyBcdGRlYnVnZ2VyO1xuXHQvLyBcdGlmKHNfc2VhcmNoX2lucHV0KSB7XG5cdC8vIFx0XHRpZihUaHJlYWRJZC5TRUFSQ0ggIT09ICR5d190aHJlYWRfaWQpIHtcblx0Ly8gXHRcdFx0ZG1faGVhZGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0Ly8gXHRcdFx0Ly8gY29uc3QgZG1fY2xvbmUgPSBkbV9oZWFkZXIuY2xvbmVOb2RlKHRydWUpO1xuXHRcdFx0XHRcblx0Ly8gXHRcdFx0JHl3X3RocmVhZF9pZCA9IFRocmVhZElkLlNFQVJDSDtcblx0Ly8gXHRcdH1cblx0Ly8gXHR9IFxuXHQvLyB9XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0LmhlYWRlciB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdGdhcDogMTZweDtcblxuXHRcdCYuYmx1ciB7XG5cdFx0XHQ+Kjpub3QoLnRvcCkge1xuXHRcdFx0XHRmaWx0ZXI6IGJsdXIoMnB4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQ+Kjpub3QoLnRvcCkge1xuXHRcdFx0dHJhbnNpdGlvbjogYmx1ciA0MDBtcyB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cdFx0fVxuXHR9XG5cblx0LnRvcCB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcblxuXHRcdD4uYmFjayB7XG5cdFx0XHRmbGV4OiAxO1xuXHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0bWF4LXdpZHRoOiAyNHB4O1xuXHRcdFx0bWFyZ2luLXJpZ2h0OiAyMHB4O1xuXHRcdH1cblxuXHRcdD4ubG9nby5pY29uIHtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMzJweDtcblx0XHRcdHRyYW5zZm9ybTogc2NhbGUoMS40MjUpO1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdH1cblxuXHRcdD4ubWFpbiB7XG5cdFx0XHRmbGV4OiAzO1xuXHRcdFx0Ly8gbWF4LXdpZHRoOiBmaXQtY29udGVudDtcblx0XHRcdGN1cnNvcjogZGVmYXVsdDtcblx0XHRcdG1hcmdpbi1yaWdodDogMWVtO1xuXHRcdFx0bWluLXdpZHRoOiAyNSU7XG5cblx0XHRcdD4udGl0bGUge1xuXHRcdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdFx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHRcdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblxuXHRcdFx0XHQ+Lm5hbWUge1xuXHRcdFx0XHRcdGZvbnQtd2VpZ2h0OiA1MDA7XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5zeW1ib2wge1xuXHRcdFx0XHRcdGZvbnQtd2VpZ2h0OiA0MDA7XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQ+LnN1YnRpdGxlIHtcblx0XHRcdFx0Zm9udC1zaXplOiAxMnB4O1xuXHRcdFx0XHRmb250LXdlaWdodDogNTAwO1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdD4ucmlnaHQge1xuXHRcdFx0ZmxleDogNTtcblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRtYXgtd2lkdGg6IG1heC1jb250ZW50O1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdGdhcDogMWVtO1xuXG5cdFx0XHQvLyAvLyBmb3IgYWJzb2x1dGUtcG9zaXRpb25lZCBvdmVybGF5IGNoaWxkXG5cdFx0XHQvLyBwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0XHRcdCYuaGVpZ2h0bGVzcyB7XG5cdFx0XHRcdGhlaWdodDogMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gPi5uZXR3b3JrIHtcblx0XHRcdC8vIFx0ZmxleDogMztcblx0XHRcdC8vIFx0bWF4LXdpZHRoOiBmaXQtY29udGVudDtcblx0XHRcdC8vIFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0Ly8gXHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdFx0Ly8gXHRtYXJnaW4tdG9wOiAtMTdweDtcblxuXHRcdFx0Ly8gXHQ+Lmljb24ge1xuXHRcdFx0Ly8gXHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHQvLyBcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0Ly8gXHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdFx0XHQvLyBcdFx0bWFyZ2luLWxlZnQ6IC00cHg7XG5cdFx0XHQvLyBcdH1cblx0XHRcdC8vIH1cblxuXHRcdFx0Pi5jbHVzdGVyIHtcblx0XHRcdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0XHRcdEByYWRpdXM6IDVweDtcblxuXHRcdFx0XHQ+KiB7XG5cdFx0XHRcdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjb2xsYXBzZSBhZGphY2VudCBib3JkZXJzXG5cdFx0XHRcdD46bnRoLWNoaWxkKG4rMSkge1xuXHRcdFx0XHRcdG1hcmdpbi1sZWZ0OiAtMnB4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gPnNwYW4ubmV0d29yayB7XG5cdFx0XHRcdC8vIFx0LS1pY29uLWRpYW1ldGVyOiAyNnB4O1xuXHRcdFx0XHQvLyBcdC0tYnV0dG9uLWRpYW1ldGVyOiAzMnB4O1xuXHRcdFx0XHQvLyBcdG1hcmdpbi1ib3R0b206IC0xcHg7XG5cdFx0XHRcdC8vIH1cblxuXHRcdFx0XHQvLyA+LmFjY291bnQsPi5uZXR3b3JrIHtcblx0XHRcdFx0Ly8gXHQtLWljb24tZGlhbWV0ZXI6IDMycHg7XG5cblx0XHRcdFx0Ly8gXHRmbGV4OiAxO1xuXHRcdFx0XHQvLyBcdG1heC13aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdC8vIFx0bWluLXdpZHRoOiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdFx0Ly8gXHRtYXJnaW4tYm90dG9tOiAtNXB4O1xuXHRcdFx0XHQvLyBcdGN1cnNvcjogcG9pbnRlcjtcblxuXHRcdFx0XHQvLyBcdC5mYWNlIHtcblx0XHRcdFx0Ly8gXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHRcdFx0Ly8gXHRcdHdpZHRoOiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdFx0Ly8gXHRcdGhlaWdodDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdC8vIFx0XHRib3JkZXItcmFkaXVzOiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdFx0Ly8gXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHQvLyBcdH1cblx0XHRcdFx0Ly8gfVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC5zZWFyY2gge1xuXHRcdGZvbnQtd2VpZ2h0OiA0MDA7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdFx0Pi5hY3Rpb24ge1xuXHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyMHB4O1xuXHRcdFx0d2lkdGg6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0aGVpZ2h0OiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdGZpbGw6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRyaWdodDogMTJweDtcblx0XHRcdHRvcDogY2FsYyg1MCUgLSAodmFyKC0taWNvbi1kaWFtZXRlcikgLyAyKSk7XG5cblx0XHRcdD5zdmcge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJoZWFkZXJcIiBiaW5kOnRoaXM9e2RtX2hlYWRlcn0+ICA8IS0tIGNsYXNzOmJsdXI9eyR5d19ibHVyfSAtLT5cblx0PCEtLSB0b3Agcm93IC0tPlxuXHQ8ZGl2IGNsYXNzPVwidG9wXCI+XG5cdFx0PCEtLSBsZWZ0bW9zdCBhY3Rpb24vYnV0dG9uIC0tPlxuXHRcdHsjaWYgYl9wb3BzfVxuXHRcdFx0PHNwYW4gY2xhc3M9XCJiYWNrXCIgb246Y2xpY2s9eygpID0+IGtfcGFnZS5wb3AoKX0+XG5cdFx0XHRcdHtAaHRtbCBTWF9JQ09OX0FSUk9XX0xFRlR9XG5cdFx0XHRcdDwhLS0gPEFycm93QmFja0ljb24gc2l6ZT0nMjRweCcgLz4gLS0+XG5cdFx0XHRcdDwhLS0gPGltZyBzcmM9XCIvbWVkaWEvbmF2L2Fycm93LWxlZnQuc3ZnXCIgYWx0PVwiQ2xpY2sgdG8gZ28gYmFja1wiIC8+IC0tPlxuXHRcdFx0PC9zcGFuPlxuXHRcdHs6ZWxzZSBpZiAhYl9leGl0cyAmJiAhYl9wbGFpbn1cblx0XHRcdDxTdGFyU2hlbGxMb2dvIGRpbT17NDh9IGFsdD1cIkNsaWNrIHRvIHZpZXcgZ2VuZXJhbCBzdGF0dXNcIiBvbjpjbGljaz17KCkgPT4gJHl3X21lbnVfdmVuZG9yID0gdHJ1ZX0gLz5cblx0XHR7L2lmfVxuXG5cdFx0PCEtLSBtYWluIHRpdGxlIHNlY3Rpb24gb24gdGhlIGxlZnQgLS0+XG5cdFx0PHNwYW4gY2xhc3M9XCJtYWluXCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidGl0bGVcIj5cblx0XHRcdFx0eyNpZiBzX3RpdGxlfVxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0e3NfdGl0bGV9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdHsjaWYgc19zeW1ib2x9XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInN5bWJvbFwiPlxuXHRcdFx0XHRcdFx0XHQtIHtzX3N5bWJvbH1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHR7L2lmfVxuXHRcdFx0PC9kaXY+XG5cblx0XHRcdDxkaXYgY2xhc3M9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0XHR7c19zdWJ0aXRsZX1cblx0XHRcdDwvZGl2PlxuXHRcdDwvc3Bhbj5cblxuXHRcdDwhLS0gYWxsIHRvcCBhY3Rpb25zIHRoYXQgYXBwZWFyIG9uIHRoZSByaWdodCBzaWRlIC0tPlxuXHRcdDxzcGFuIGNsYXNzPVwicmlnaHRcIiBjbGFzczpoZWlnaHRsZXNzPXshYl9uZXR3b3JrICYmIGJfZXhpdHN9PlxuXHRcdFx0PCEtLSBhY2NvdW50L25ldHdvcmsgc3dpdGNoIGNsdXN0ZXIgLS0+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImNsdXN0ZXJcIj5cblx0XHRcdFx0PCEtLSBuZXR3b3JrIHN3aXRjaGVyIC0tPlxuXHRcdFx0XHR7I2lmIGJfbmV0d29ya31cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm5ldHdvcmtcIiBvbjpjbGljaz17KGRfZXZlbnQpID0+IHtcblx0XHRcdFx0XHRcdGRfZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHQkeXdfb3ZlcmxheV9uZXR3b3JrID0gISR5d19vdmVybGF5X25ldHdvcms7XG5cdFx0XHRcdFx0fX0+XG5cdFx0XHRcdFx0XHR7I2tleSAkeXdfY2hhaW59XG5cdFx0XHRcdFx0XHRcdDxQZnBEaXNwbGF5XG5cdFx0XHRcdFx0XHRcdFx0cmVzb3VyY2U9eyR5d19jaGFpbn1cblx0XHRcdFx0XHRcdFx0XHR7Li4ub3ZlcmxheV9wZnBfcHJvcHMoZmFsc2UpfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0ey9rZXl9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0eyNpZiAkeXdfb3ZlcmxheV9uZXR3b3JrfVxuXHRcdFx0XHRcdFx0PE92ZXJsYXlTZWxlY3Rcblx0XHRcdFx0XHRcdFx0dGl0bGU9J1N3aXRjaCBOZXR3b3JrJ1xuXHRcdFx0XHRcdFx0XHRiaW5kOm9wZW49eyR5d19vdmVybGF5X25ldHdvcmt9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInJvd3NcIj5cblx0XHRcdFx0XHRcdFx0XHR7I2F3YWl0IENoYWlucy5yZWFkKCl9XG5cdFx0XHRcdFx0XHRcdFx0XHQuLi5cblx0XHRcdFx0XHRcdFx0XHR7OnRoZW4ga3NfY2hhaW5zfSBcblx0XHRcdFx0XHRcdFx0XHRcdHsjZWFjaCBrc19jaGFpbnMuZW50cmllcygpIGFzIFtwX2NoYWluLCBnX2NoYWluXX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc291cmNlPXtnX2NoYWlufVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRldGFpbD0nRGVmYXVsdCBQcm92aWRlcidcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHl3X2NoYWluX3JlZiA9IHBfY2hhaW47XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfb3ZlcmxheV9uZXR3b3JrID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInJpZ2h0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7I2lmICR5d19jaGFpbl9yZWYgPT09IHBfY2hhaW59XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwib3ZlcmxheS1zZWxlY3QgaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwhLS0ge0BodG1sIFNYX0NIRUNLRUR9IC0tPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHRcdFx0XHR7L2F3YWl0fVxuXHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0XHRcdDwvT3ZlcmxheVNlbGVjdD5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHR7L2lmfVxuXG5cdFx0XHRcdDwhLS0gYWNjb3VudCBzd2l0Y2hlciAtLT5cblx0XHRcdFx0eyNpZiBiX2FjY291bnR9XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJhY2NvdW50XCIgb246Y2xpY2s9eyhkX2V2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRkX2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0JHl3X292ZXJsYXlfYWNjb3VudCA9ICEkeXdfb3ZlcmxheV9hY2NvdW50O1xuXHRcdFx0XHRcdH19PlxuXHRcdFx0XHRcdFx0eyNrZXkgJHl3X2FjY291bnR9XG5cdFx0XHRcdFx0XHRcdDxQZnBEaXNwbGF5XG5cdFx0XHRcdFx0XHRcdFx0cmVzb3VyY2U9eyR5d19hY2NvdW50fVxuXHRcdFx0XHRcdFx0XHRcdHsuLi5vdmVybGF5X3BmcF9wcm9wcyh0cnVlKX1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdHsva2V5fVxuXG5cdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0eyNpZiAkeXdfb3ZlcmxheV9hY2NvdW50fVxuXHRcdFx0XHRcdFx0PE92ZXJsYXlTZWxlY3Rcblx0XHRcdFx0XHRcdFx0dGl0bGU9J1N3aXRjaCBBY2NvdW50J1xuXHRcdFx0XHRcdFx0XHRiaW5kOm9wZW49eyR5d19vdmVybGF5X2FjY291bnR9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInJvd3NcIj5cblx0XHRcdFx0XHRcdFx0XHR7I2F3YWl0IEFjY291bnRzLnJlYWQoKX1cblx0XHRcdFx0XHRcdFx0XHRcdC4uLlxuXHRcdFx0XHRcdFx0XHRcdHs6dGhlbiBrc19hY2NvdW50c31cblx0XHRcdFx0XHRcdFx0XHRcdDwhLS0geyNpZiBrc19hY2NvdW50cy5lbnRyaWVzKCkubGVuZ3RoID4gMn1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5hbWU9XCJBbGwgQWNjb3VudHNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRldGFpbD17Zm9ybWF0X2ZpYXQoT2JqZWN0LnZhbHVlcyhIX0FDQ09VTlRTKS5yZWR1Y2UoKGNfc3VtLCBrX2FjY291bnQpID0+IGNfc3VtICsgKGtfYWNjb3VudC5hZ2dyZWdhdG9yPyAwOiBIb2xkaW5nLnVzZFN1bShrX2FjY291bnQuaG9sZGluZ3MoSF9IT0xESU5HUywgJHl3X2NoYWluKSwgSF9UT0tFTlMsIEhfVkVSU1VTX1VTRCkpLCAwKSl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHBfYWNjb3VudF9hbGwgPSBBY2NvdW50LnJlZkZyb21JZCgnKicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHl3X2FjY291bnQgPSBIX0FDQ09VTlRTW3BfYWNjb3VudF9hbGxdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHl3X292ZXJsYXlfYWNjb3VudCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJyaWdodFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyNpZiAkeXdfYWNjb3VudC5kZWYuaXJpID09PSBBY2NvdW50LnJlZkZyb21JZCgnKicpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm92ZXJsYXktc2VsZWN0IGljb25cIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgU1hfQ0hFQ0tFRH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cImljb25cIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwicGZwIHNxdWFyZSBpY29uIGFnZ3JlZ2F0b3JcIiBzdHlsZT1cImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOjMwcHg7IG1hcmdpbi1sZWZ0OmF1dG87IG1hcmdpbi1yaWdodDphdXRvO1wiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9Sb3c+XG5cdFx0XHRcdFx0XHRcdFx0XHR7L2lmfVxuXG5cdFx0XHRcdFx0XHRcdFx0XHR7I2VhY2gga3NfYWNjb3VudHMuZW50cmllcygpLmZpbHRlcigoWyxrXSkgPT4gIWsuYWdncmVnYXRvcikgYXMgW3BfYWNjb3VudCwga19hY2NvdW50XX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5hbWU9e2tfYWNjb3VudC5kZWYubGFiZWx9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGV0YWlsPXtmb3JtYXRfZmlhdChIb2xkaW5nLnVzZFN1bShrX2FjY291bnQuaG9sZGluZ3MoSF9IT0xESU5HUywgJHl3X2NoYWluKSwgSF9UT0tFTlMsIEhfVkVSU1VTX1VTRCkpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfYWNjb3VudCA9IGtfYWNjb3VudDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCR5d19vdmVybGF5X2FjY291bnQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicmlnaHRcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsjaWYgJHl3X2FjY291bnQuZGVmLmlyaSA9PT0gcF9hY2NvdW50fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm92ZXJsYXktc2VsZWN0IGljb25cIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgU1hfQ0hFQ0tFRH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cImljb25cIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwicGZwIHNxdWFyZSBpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxQdXQgZWxlbWVudD17SF9JQ09OU1trX2FjY291bnQuZGVmLmljb25SZWZdLnJlbmRlcigpfSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0XHRcdFx0XHRcdHsvZWFjaH0gLS0+XG5cdFx0XHRcdFx0XHRcdFx0ey9hd2FpdH1cblx0XHRcdFx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHQ8L092ZXJsYXlTZWxlY3Q+XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0ey9pZn1cblx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0PCEtLSBleGl0IGJ1dHRvbiAtLT5cblx0XHRcdHsjaWYgYl9leGl0c31cblx0XHRcdFx0PENsb3NlIG9uOmNsaWNrPXsoKSA9PiBkaXNwYXRjaCgnY2xvc2UnKX0gLz5cblx0XHRcdHsvaWZ9XG5cdFx0PC9zcGFuPlxuXHQ8L2Rpdj5cblx0eyNpZiBiX3NlYXJjaH1cblx0XHQ8ZGl2IGNsYXNzPVwic2VhcmNoXCI+XG5cdFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIlxuXHRcdFx0XHRhdXRvZm9jdXM9e2lzU2VhcmNoU2NyZWVufVxuXHRcdFx0XHRwbGFjZWhvbGRlcj0nU2VhcmNoIGFueXRoaW5nOiB0b2tlbiwgYWNjb3VudCwgY29udGFjdCwgdHhuLi4uJ1xuXHRcdFx0XHRiaW5kOnZhbHVlPXtzX3NlYXJjaH1cblx0XHRcdFx0b246aW5wdXQ9e3VwZGF0ZV9zZWFyY2h9XG5cdFx0XHRcdGJpbmQ6dGhpcz17ZG1fc2VhcmNofVxuXHRcdFx0PlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJhY3Rpb25cIj5cblx0XHRcdFx0PCEtLSA8aW1nIHNyYz1cIi9hc3NldHMvbWVkaWEvbmF2L3NlYXJjaC5zdmdcIiBhbHQ9XCJcIiAvPiAtLT5cblx0XHRcdFx0e0BodG1sIFNYX0lDT05fU0VBUkNIfVxuXHRcdFx0PC9zcGFuPlxuXHRcdDwvZGl2PlxuXHR7L2lmfVxuPC9kaXY+XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIiBsYW5nPVwidHNcIj5cblx0ZXhwb3J0IG5hbWVzcGFjZSBMb2dJdGVtIHtcblx0XHRleHBvcnQgaW50ZXJmYWNlIFN0cmluZyB7XG5cdFx0XHR0eXBlOiAnc3RyaW5nJztcblx0XHRcdHZhbHVlOiBzdHJpbmc7XG5cdFx0fVxuXG5cdFx0ZXhwb3J0IGludGVyZmFjZSBFdmVudCB7XG5cdFx0XHR0eXBlOiAnZXZlbnQnO1xuXHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0bWVzc2FnZTogc3RyaW5nO1xuXHRcdFx0XHRvZmZzZXQ6IG51bWJlcjtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZXhwb3J0IHR5cGUgQW55ID0gU3RyaW5nIHwgRXZlbnQ7XG5cdH1cblxuXHRleHBvcnQgdHlwZSBMb2dJdGVtID0gTG9nSXRlbS5Bbnk7XG5cblx0ZXhwb3J0IGNsYXNzIExvZ2dlciB7XG5cdFx0Ly8gcHJpdmF0ZSBfYV9pdGVtczogTG9nSXRlbVtdID0gW107XG5cblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMuX2FfaXRlbXMgPSBbXTtcblx0XHR9XG5cblx0XHRnZXQgaXRlbXMoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYV9pdGVtcztcblx0XHR9XG5cblx0XHRzZXQgaXRlbXMoYV9pdGVtczogTG9nSXRlbVtdKSB7XG5cdFx0XHR0aGlzLl9hX2l0ZW1zID0gYV9pdGVtcztcblx0XHR9XG5cblx0XHRldmVudChzX21zZzogc3RyaW5nLCB4dF9vZmZzZXQ6IG51bWJlcik6IHRoaXMge1xuXHRcdFx0dGhpcy5fYV9pdGVtcy5wdXNoKHtcblx0XHRcdFx0dHlwZTogJ2V2ZW50Jyxcblx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRtZXNzYWdlOiBzX21zZyxcblx0XHRcdFx0XHRvZmZzZXQ6IHh0X29mZnNldCxcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5cdGV4cG9ydCBsZXQgaXRlbXM6IExvZ0l0ZW1bXTtcblxuXHRleHBvcnQgbGV0IGhpZGUgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBmb3JtYXRfbXMobl9tczogbnVtYmVyKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKG5fbXMgLyAxMDAwKS50b0ZpeGVkKDIpLnBhZFN0YXJ0KDUsICcwJyk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0LmxvZy1jb250YWluZXIge1xuXHRcdGZvbnQtZmFtaWx5OiAnUFQgTW9ubycsIG1vbm9zcGFjZTtcblxuXHRcdD5vbCB7XG5cdFx0XHQ+bGkge1xuXHRcdFx0XHQ+c3BhbiB7XG5cdFx0XHRcdFx0Ji5zdHJpbmcge1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ji5ldmVudCB7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwibG9nLWNvbnRhaW5lclwiIGNsYXNzOmRpc3BsYXlfbm9uZT17aGlkZX0+XG5cdDxvbD5cblx0XHR7I2VhY2ggaXRlbXMgYXMgZ19pdGVtfVxuXHRcdFx0PGxpPlxuXHRcdFx0XHR7I2lmICdzdHJpbmcnID09PSBnX2l0ZW0udHlwZX1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInN0cmluZ1wiPntnX2l0ZW0udmFsdWV9PC9zcGFuPlxuXHRcdFx0XHR7OmVsc2UgaWYgJ2V2ZW50JyA9PT0gZ19pdGVtLnR5cGV9XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJldmVudFwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJvZmZzZXRcIj4re2Zvcm1hdF9tcyhnX2l0ZW0udmFsdWUub2Zmc2V0KX1tczogPC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJtZXNzYWdlXCI+e2dfaXRlbS52YWx1ZS5tZXNzYWdlfTwvc3Bhbj5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHQ8L2xpPlxuXHRcdHsvZWFjaH1cblx0PC9vbD5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0Ly8gdGFyZ2V0IHdpZHRoXG5cdGV4cG9ydCBsZXQgd2lkdGggPSAxODA7XG5cdGNvbnN0IHhfd2lkdGggPSB3aWR0aDtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0LnRpdGxlIHtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRib3JkZXI6IDA7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cblx0XHRtYXJnaW4tbGVmdDogYXV0bztcblx0XHRtYXJnaW4tcmlnaHQ6IGF1dG87XG5cblx0XHRoZWlnaHQ6IGF1dG87XG5cblx0XHRpbWcge1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwibm8tbWFyZ2luIHRpdGxlXCIgc3R5bGU9XCJ3aWR0aDp7eF93aWR0aH1weDtcIj5cblx0PGltZyBhbHQ9XCJTdGFyU2hlbGwgdGl0bGVcIiBzcmM9XCIvbWVkaWEvdmVuZG9yL3RpdGxlLnN2Z1wiIC8+XG48L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7Z2V0Q29udGV4dH0gZnJvbSAnc3ZlbHRlJztcblxuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcblx0aW1wb3J0IHtTY3JlZW4sIHR5cGUgUGFnZX0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblxuXHRleHBvcnQgbGV0IGF0dGVtcHRfcmVnaXN0ZXI6IFZvaWRGdW5jdGlvbjtcblx0ZXhwb3J0IGxldCB3ZWFrbmVzczogbnVtYmVyO1xuXHRjb25zdCBpX3dlYWtuZXNzID0gd2Vha25lc3M7XG5cblx0Ly8gZ2V0IHBhZ2UgZnJvbSBjb250ZXh0XG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRmdW5jdGlvbiB1c2VfYW55d2F5KCkge1xuXHRcdGF0dGVtcHRfcmVnaXN0ZXIoKTtcblx0XHRrX3BhZ2UucG9wKCk7XG5cdH1cbjwvc2NyaXB0PlxuXG48U2NyZWVuPlxuXHQ8aDM+XG5cdFx0V2VhayBQYXNzd29yZCBXYXJuaW5nXG5cdDwvaDM+XG5cblx0PHA+XG5cdFx0VGhlIHBhc3N3b3JkIHlvdSBlbnRlcmVkIHdhcyBmb3VuZCBvbiBhIGxpc3Qgb2YgdGhlIHRvcCB0ZW4gdGhvdXNhbmQgbW9zdCBjb21tb25seSB1c2VkIHBhc3N3b3Jkcy5cblx0PC9wPlxuXG5cdDxwPlxuXHRcdEluIG9yZGVyIHRvIGhlbHAgcHJldmVudCB0aGUgbG9zcyBvZiBmdW5kcywgeW91IGFyZSBlbmNvdXJhZ2VkIHRvIGNyZWF0ZSBhIHN0cm9uZywgdW5pcXVlIHBhc3N3b3JkLlxuXHQ8L3A+XG5cblx0PHA+XG5cdFx0SG93IGRvIHlvdSB3YW50IHRvIHByb2NlZWQ/XG5cdDwvcD5cblxuXHQ8QWN0aW9uc0xpbmUgY2FuY2VsPSdwb3AnIGNvbmZpcm09e1snVXNlIGFueXdheScsIHVzZV9hbnl3YXldfSB3YWl0PXs1MDAwfSAvPlxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBQYWdlLCBTY3JlZW4gfSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRpbXBvcnQgRmllbGQgZnJvbSAnIy9hcHAvdWkvRmllbGQuc3ZlbHRlJztcblx0aW1wb3J0IExvZywgeyBMb2dnZXIgfSBmcm9tICcjL2FwcC91aS9Mb2cuc3ZlbHRlJztcblxuXHRpbXBvcnQgeyBWYXVsdCB9IGZyb20gJyMvY3J5cHRvL3ZhdWx0Jztcblx0aW1wb3J0IHtcblx0XHRBVFU4X0RVTU1ZX1BIUkFTRSxcblx0XHRBVFU4X0RVTU1ZX1ZFQ1RPUixcblx0XHRhY2NlcHRhYmxlLFxuXHRcdGxvZ2luLFxuXHRcdHJlZ2lzdGVyLFxuXHRcdEFscmVhZHlSZWdpc3RlcmVkRXJyb3IsXG5cdFx0SW52YWxpZFBhc3NwaHJhc2VFcnJvcixcblx0XHROTF9QQVNTUEhSQVNFX01JTklNVU0sXG5cdFx0TkxfUEFTU1BIUkFTRV9NQVhJTVVNLFxuXHR9IGZyb20gJyMvc2hhcmUvYXV0aCc7XG5cblx0aW1wb3J0IHR5cGUgeyBDb21wbGV0ZWQgfSBmcm9tICcjL2VudHJ5L2Zsb3cnO1xuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcblx0aW1wb3J0IHsgc2xpZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XG5cdGltcG9ydCBTdGFyU2hlbGxMb2dvIGZyb20gJy4uL3VpL1N0YXJTaGVsbExvZ28uc3ZlbHRlJztcblx0aW1wb3J0IFN0YXJTaGVsbFRpdGxlIGZyb20gJy4uL3VpL1N0YXJTaGVsbFRpdGxlLnN2ZWx0ZSc7XG5cdGltcG9ydCBSZWdpc3RlcldlYWtQYXNzd29yZFN2ZWx0ZSBmcm9tICcuL1JlZ2lzdGVyV2Vha1Bhc3N3b3JkLnN2ZWx0ZSc7XG5cblx0Ly8gZ2V0IHBhZ2UgZnJvbSBjb250ZXh0XG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHQvLyB3aWxsIGJlIHNldCBpZiB0aGlzIGlzIHBhcnQgb2YgYSBmbG93XG5cdGNvbnN0IGNvbXBsZXRlZCA9IGdldENvbnRleHQ8Q29tcGxldGVkIHwgdW5kZWZpbmVkPignY29tcGxldGVkJyk7XG5cblx0Ly8gYmluZGluZ3Ncblx0bGV0IHNoX3BocmFzZSA9ICcnO1xuXHRsZXQgc2hfdmVyaWZ5ID0gJyc7XG5cdGxldCBzX2Vycm9yID0gJyc7XG5cblx0bGV0IHNfZXJyX3Bhc3N3b3JkID0gJyc7XG5cdGxldCBzX2Vycl92ZXJpZnkgPSAnJztcblxuXHQvLyB0aW1lIHN0YXJ0ZWQgcmVnaXN0cmF0aW9uXG5cdGxldCB4dF9zdGFydCA9IDA7XG5cblx0Ly8gbG9nZ2VyIGluc3RhY2Vcblx0bGV0IGtfbG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG5cdC8vIGxvZyB0byBsb2dnZXJcblx0ZnVuY3Rpb24gbG9nKHNfbXNnOiBzdHJpbmcpIHtcblx0XHRrX2xvZ2dlciA9IGtfbG9nZ2VyLmV2ZW50KHNfbXNnLCBEYXRlLm5vdygpIC0geHRfc3RhcnQpO1xuXHR9XG5cblxuXHQvLyBjb250aW51b3VzbHkgY2hlY2sgdGhlIGFjY2VwdGFiaWxpdHkgb2YgdGhlIHBhc3N3b3JkXG5cdCQ6IGJfcGFzc3dvcmRfYWNjZXB0YWJsZSA9ICEhc2hfcGhyYXNlICYmIHNoX3BocmFzZSA9PT0gc2hfdmVyaWZ5ICYmIGFjY2VwdGFibGUoc2hfcGhyYXNlKTtcblxuXHQvLyB1cGRhdGUgdGhlIGNvbmZpcm0gYWN0aW9uXG5cdCQ6IGFfY29uZmlybV9hY3Rpb24gPSBbJ0NvbnRpbnVlJywgcHJlcGFyZV9yZWdpc3RlciwgIWJfcGFzc3dvcmRfYWNjZXB0YWJsZV0gYXMgY29uc3Q7XG5cblxuXHQvLyBsaXN0ZW4gZm9yIHBhZ2UgZXZlbnQgcmVzdG9yZVxuXHRrX3BhZ2Uub24oe1xuXHRcdHJlc3RvcmUoKSB7XG5cdFx0XHQvLyBjbGVhciBwYXNzd29yZHNcblx0XHRcdHNoX3BocmFzZSA9IHNoX3ZlcmlmeSA9ICcnO1xuXHRcdH0sXG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGNoZWNrX3Bhc3N3b3JkKCkge1xuXHRcdGlmKHNoX3BocmFzZSAmJiAhYWNjZXB0YWJsZShzaF9waHJhc2UpKSB7XG5cdFx0XHRpZihzaF9waHJhc2UubGVuZ3RoIDwgTkxfUEFTU1BIUkFTRV9NSU5JTVVNKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gJ1Bhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgNSBjaGFyYWN0ZXJzJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoc2hfcGhyYXNlLmxlbmd0aCA+IE5MX1BBU1NQSFJBU0VfTUFYSU1VTSkge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9ICdQYXNzd29yZCBtdXN0IGJlIDEwMjQgY2hhcmFjdGVycyBvciBmZXdlcic7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSAnUGFzc3dvcmQgaXMgbm90IGFjY2VwdGFibGUnO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c19lcnJfcGFzc3dvcmQgPSAnJztcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrX3ZlcmlmeSgpIHtcblx0XHRpZihzaF9waHJhc2UgJiYgIXNfZXJyX3Bhc3N3b3JkICYmIHNoX3BocmFzZSAhPT0gc2hfdmVyaWZ5KSB7XG5cdFx0XHRzX2Vycl92ZXJpZnkgPSAnUGFzc3dvcmRzIGRvIG5vdCBtYXRjaCc7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c19lcnJfdmVyaWZ5ID0gJyc7XG5cdH1cblxuXHQvLyBkb3dubG9hZCB0b3AgMTBrIGxpc3QgYW5kIHBhcnNlIGl0XG5cdGNvbnN0IGRwX3Bhc3N3b3JkcyA9IChhc3luYygpID0+IHtcblx0XHRjb25zdCBkX3JlcyA9IGF3YWl0IGZldGNoKCcvZGF0YS9wYXNzd29yZHMtdG9wLTEway50eHQnKTtcblx0XHRjb25zdCBzX2xpc3QgPSBhd2FpdCBkX3Jlcy50ZXh0KCk7XG5cdFx0cmV0dXJuIHNfbGlzdC5zcGxpdCgnXFxuJyk7XG5cdH0pKCk7XG5cblx0Ly8gcHJlcGFyZSB0byByZWdpc3RlclxuXHRhc3luYyBmdW5jdGlvbiBwcmVwYXJlX3JlZ2lzdGVyKCkge1xuXHRcdC8vIGNoZWNrIGFnYWluc3QgdG9wIDEwayBsaXN0XG5cdFx0Y29uc3QgYV9wYXNzd29yZHMgPSBhd2FpdCBkcF9wYXNzd29yZHM7XG5cblx0XHQvLyBwYXNzd29yZCBmb3VuZCBpbiBsaXN0XG5cdFx0aWYoYV9wYXNzd29yZHMuaW5jbHVkZXMoc2hfcGhyYXNlKSkge1xuXHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRjcmVhdG9yOiBSZWdpc3RlcldlYWtQYXNzd29yZFN2ZWx0ZSxcblx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRhdHRlbXB0X3JlZ2lzdGVyLFxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8vIHBhc3N3b3JkIG5vdCBpbiBsaXN0XG5cdFx0ZWxzZSB7XG5cdFx0XHRhd2FpdCBhdHRlbXB0X3JlZ2lzdGVyKCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gcmVnaXN0cmF0aW9uIGlzIGJ1c3lcblx0bGV0IGJfYnVzeSA9IGZhbHNlO1xuXHRcblx0Ly8gYXR0ZW1wdCB0byByZWdpc3RlclxuXHRhc3luYyBmdW5jdGlvbiBhdHRlbXB0X3JlZ2lzdGVyKCk6IFByb21pc2U8MT4ge1xuXHRcdC8vIGludmFsaWQgc3RhdGVcblx0XHRpZighYl9wYXNzd29yZF9hY2NlcHRhYmxlKSByZXR1cm4gMTtcblxuXHRcdC8vIGRvIG5vdCBpbnRlcnVwdDsgbG9ja1xuXHRcdGlmKGJfYnVzeSkgcmV0dXJuIDE7IGJfYnVzeSA9IHRydWU7XG5cblx0XHQvLyBwcmVwIGdyYWNlZnVsIGV4aXRcblx0XHRjb25zdCBleGl0ID0gKCk6IDEgPT4gKGJfYnVzeSA9IGZhbHNlLCAxKTtcblxuXHRcdC8vIHJlc2V0IGVycm9yXG5cdFx0c19lcnJvciA9ICcnO1xuXG5cdFx0Ly8gc3RhcnQgdGltZXJcblx0XHR4dF9zdGFydCA9IERhdGUubm93KCk7XG5cblx0XHRsb2coJ0VzdGltYXRpbmcgdGltZSB0byBjb21wbGV0ZScpO1xuXG5cdFx0Ly8gZXN0aW1hdGUgdGltZSB0byBjb21wbGV0ZVxuXHRcdHtcblx0XHRcdGNvbnN0IHh0X3N0YXJ0X2VzdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdGF3YWl0IFZhdWx0LmRlcml2ZVJvb3RCaXRzKEFUVThfRFVNTVlfUEhSQVNFLCBBVFU4X0RVTU1ZX1ZFQ1RPUiwgMSAvIDUwKTtcblx0XHRcdGNvbnN0IHh0X2ZpbmlzaF9lc3QgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHRcdGNvbnN0IHh0X2VsYXBzZWRfZXN0ID0geHRfZmluaXNoX2VzdCAtIHh0X3N0YXJ0X2VzdDtcblx0XHRcdGNvbnN0IHh0X2VzdGltYXRlID0gMiAqICgyICogKHh0X2VsYXBzZWRfZXN0ICogNTApKTtcblx0XHRcdGxvZyhgQWJvdXQgJHsoeHRfZXN0aW1hdGUgLyAxMDAwKS50b0ZpeGVkKDEpfSBzZWNvbmRzYCk7XG5cdFx0fVxuXG5cdFx0Ly8gYXR0ZW1wdCB0byByZWdpc3RlclxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCByZWdpc3RlcihzaF9waHJhc2UsIGxvZyk7XG5cdFx0fVxuXHRcdC8vIGhhbmRsZSBlcnJvclxuXHRcdGNhdGNoKGVfcmVnaXN0ZXIpIHtcblx0XHRcdGlmKGVfcmVnaXN0ZXIgaW5zdGFuY2VvZiBBbHJlYWR5UmVnaXN0ZXJlZEVycm9yKSB7XG5cdFx0XHRcdHNfZXJyb3IgPSAnQSBwYXNzcGhyYXNlIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCc7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGVfcmVnaXN0ZXIgaW5zdGFuY2VvZiBJbnZhbGlkUGFzc3BocmFzZUVycm9yKSB7XG5cdFx0XHRcdHNfZXJyb3IgPSAnSW52YWxpZCBwYXNzcGhyYXNlJztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzX2Vycm9yID0gYFVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byByZWdpc3RlcjpcXG4ke2VfcmVnaXN0ZXIuc3RhY2sgfHwgZV9yZWdpc3Rlci5tZXNzYWdlfWA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGV4aXRcblx0XHRcdHJldHVybiBleGl0KCk7XG5cdFx0fVxuXG5cdFx0bG9nKCdWZXJpZnlpbmcgcGFzc3BocmFzZScpO1xuXG5cdFx0Ly8gYXR0ZW1wdCBsb2dpblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBsb2dpbihzaF9waHJhc2UsIGZhbHNlLCBsb2cpO1xuXHRcdH1cblx0XHQvLyBmYWlsZWQgdG8gdmVyaWZ5XG5cdFx0Y2F0Y2goZV9sb2dpbikge1xuXHRcdFx0c19lcnJvciA9ICdGYWlsZWQgdG8gdmVyaWZ5IHBhc3NwaHJhc2UgaW1tZWRpYXRlbHkgYWZ0ZXIgcmVnaXN0cmF0aW9uJztcblxuXHRcdFx0Ly8gcmVzZXQgdmF1bHRcblx0XHRcdGF3YWl0IFZhdWx0LmVyYXNlQmFzZSgpO1xuXG5cdFx0XHQvLyBleGl0XG5cdFx0XHRyZXR1cm4gZXhpdCgpO1xuXHRcdH1cblxuXHRcdGxvZygnRG9uZScpO1xuXG5cdFx0Ly8gcHJvY2VlZFxuXHRcdHNfZXJyb3IgPSAnU3VjY2Vzcyc7XG5cblx0XHQvLyBjb21wbGV0ZVxuXHRcdGlmKGNvbXBsZXRlZCkgY29tcGxldGVkKHRydWUpO1xuXG5cdFx0Ly8gZG9uZVxuXHRcdHJldHVybiBleGl0KCk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHQuaW50cm8ge1xuXHRcdG1hcmdpbi10b3A6IDFlbTtcblx0XHQvLyBtYXJnaW4tYm90dG9tOiA0ZW07XG5cdFx0bWFyZ2luLWJvdHRvbTogMDtcblxuXHRcdC5sZWFkIHtcblx0XHRcdG1hcmdpbi10b3A6IDFlbTtcblx0XHRcdG1hcmdpbi1ib3R0b206IDA7XG5cdFx0fVxuXG5cdFx0LnRpdGxlIHtcblx0XHRcdGxldHRlci1zcGFjaW5nOiAxcHg7XG5cdFx0XHRmb250LXdlaWdodDogMTAwO1xuXHRcdFx0Zm9udC1zaXplOiAyN3B4O1xuXHRcdFx0Y29sb3I6ICNkMGQwZDA7XG5cdFx0XHRtYXJnaW46IDA7XG5cblx0XHRcdGVtIHtcblx0XHRcdFx0Zm9udC1zaXplOiAzMnB4O1xuXHRcdFx0XHRmb250LXN0eWxlOiBub3JtYWw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmxvZ28ge1xuXHRcdFx0aGVpZ2h0OiAzNHZoO1xuXHRcdFx0d2lkdGg6IGF1dG87XG5cdFx0fVxuXG5cdFx0Lmljb24ge1xuXHRcdFx0LS1zdmctY29sb3ItZmc6IHNpbHZlcjtcblx0XHRcdC8vIC0tc3ZnLWNvbG9yLWJnOiAjZjUyNTI1O1xuXHRcdFx0d2lkdGg6IGNhbGMoMTAwJSAtIDYwcHgpO1xuXHRcdFx0aGVpZ2h0OiBhdXRvO1xuXG5cdFx0XHQuZ3JhcGhpYyh7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdHdpZHRoOiAxNzJweDtcblx0XHRcdFx0XHRoZWlnaHQ6IDEzN3B4O1xuXHRcdFx0XHRcdG1hcmdpbjogMTBweCAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0PnN2ZyB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1hcmdpbjogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0fVxuXG5cdC5uYXJyb3cge1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0Zm9udC13ZWlnaHQ6IDMwMDtcblx0XHRtYXgtd2lkdGg6IDE4ZW07XG5cdH1cbjwvc3R5bGU+XG5cbjxTY3JlZW4+XG5cdDxjZW50ZXI+XG5cdFx0PGRpdiBjbGFzcz1cImludHJvXCI+XG5cdFx0XHQ8U3RhclNoZWxsTG9nbyBkaW09ezk2fSAvPlxuXG5cdFx0XHQ8U3RhclNoZWxsVGl0bGUgd2lkdGg9ezE1MH0gLz5cblx0XHQ8L2Rpdj5cblxuXHRcdDxwIGNsYXNzPVwibmFycm93XCI+XG5cdFx0XHRDcmVhdGUgYSBuZXcgcGFzc3dvcmQgdG8gcHJvdGVjdCB5b3VyIHdhbGxldCdzIGRhdGEuXG5cdFx0PC9wPlxuXHQ8L2NlbnRlcj5cblxuXHQ8ZGl2IGNsYXNzPVwiZm9ybSBmbGV4LXJvd3NcIj5cblx0XHQ8aW5wdXQgaGlkZGVuXG5cdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRuYW1lPVwidXNlcm5hbWVcIlxuXHRcdFx0YXV0b2NvbXBsZXRlPVwidXNlcm5hbWVcIlxuXHRcdFx0dmFsdWU9XCJTdGFyU2hlbGwgV2FsbGV0IFVzZXJcIj5cblxuXHRcdDxGaWVsZCBrZXk9XCJwYXNzd29yZFwiIG5hbWU9XCJOZXcgcGFzc3dvcmRcIj5cblx0XHRcdDxpbnB1dFxuXHRcdFx0XHR0eXBlPVwicGFzc3dvcmRcIlxuXHRcdFx0XHRhdXRvY29tcGxldGU9XCJuZXctcGFzc3dvcmRcIlxuXHRcdFx0XHRuYW1lPVwicGFzc3dvcmRcIlxuXHRcdFx0XHRwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCJcblx0XHRcdFx0b246Ymx1cj17KCkgPT4gY2hlY2tfcGFzc3dvcmQoKX1cblx0XHRcdFx0YmluZDp2YWx1ZT17c2hfcGhyYXNlfT5cblxuXHRcdFx0eyNpZiAhYl9wYXNzd29yZF9hY2NlcHRhYmxlICYmIHNfZXJyX3Bhc3N3b3JkfVxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsaWRhdGlvbi1tZXNzYWdlXCIgdHJhbnNpdGlvbjpzbGlkZT17e2R1cmF0aW9uOjMwMH19PlxuXHRcdFx0XHRcdHtzX2Vycl9wYXNzd29yZH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXHRcdDwvRmllbGQ+XG5cblx0XHQ8RmllbGQga2V5PVwidmVyaWZ5LXBhc3N3b3JkXCIgbmFtZT1cIlZlcmlmeSBwYXNzd29yZFwiPlxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdHR5cGU9XCJwYXNzd29yZFwiXG5cdFx0XHRcdGF1dG9jb21wbGV0ZT1cIm5ldy1wYXNzd29yZFwiXG5cdFx0XHRcdG5hbWU9XCJ2ZXJpZnlcIlxuXHRcdFx0XHRwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCJcblx0XHRcdFx0b246Ymx1cj17KCkgPT4gY2hlY2tfdmVyaWZ5KCl9XG5cdFx0XHRcdGJpbmQ6dmFsdWU9e3NoX3ZlcmlmeX0+XG5cblx0XHRcdHsjaWYgIWJfcGFzc3dvcmRfYWNjZXB0YWJsZSAmJiBzX2Vycl92ZXJpZnl9XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzAwfX0+XG5cdFx0XHRcdFx0e3NfZXJyX3ZlcmlmeX1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXHRcdDwvRmllbGQ+XG5cblx0PC9kaXY+XG5cblx0PExvZyBiaW5kOml0ZW1zPXtrX2xvZ2dlci5pdGVtc30gLz5cblxuXHR7I2lmIHNfZXJyb3J9XG5cdFx0PHByZT57c19lcnJvcn08L3ByZT5cblx0ey9pZn1cblxuXG5cdDxBY3Rpb25zTGluZSBjb25maXJtPXthX2NvbmZpcm1fYWN0aW9ufSAvPlxuPC9TY3JlZW4+XG4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTE5IDV2MTRINVY1aDE0bTAtMkg1YTIgMiAwIDAgMC0yIDJ2MTRhMiAyIDAgMCAwIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0tNyA5Yy0xLjY1IDAtMy0xLjM1LTMtM3MxLjM1LTMgMy0zIDMgMS4zNSAzIDMtMS4zNSAzLTMgM3ptMC00Yy0uNTUgMC0xIC40NS0xIDFzLjQ1IDEgMSAxIDEtLjQ1IDEtMS0uNDUtMS0xLTF6bTYgMTBINnYtMS41M2MwLTIuNSAzLjk3LTMuNTggNi0zLjU4czYgMS4wOCA2IDMuNThWMTh6bS05LjY5LTJoNy4zOGMtLjY5LS41Ni0yLjM4LTEuMTItMy42OS0xLjEycy0zLjAxLjU2LTMuNjkgMS4xMnpcXFwiLz5cXG48L3N2Zz5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItYW5hbHl0aWNzLWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1hbmFseXRpY3MtZmdcXFwiIGQ9XFxcIk0xOSAzSDVjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptMCAxNkg1VjVoMTR2MTR6XFxcIi8+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1hbmFseXRpY3MtZmdcXFwiIGQ9XFxcIk03IDEyaDJ2NUg3em04LTVoMnYxMGgtMnptLTQgN2gydjNoLTJ6bTAtNGgydjJoLTJ6XFxcIi8+XFxuPC9zdmc+XCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTEzIDUuMDhBNyA3IDAgMCAxIDE4LjkyIDExaDMuMDNjLS40Ny00LjcyLTQuMjMtOC40OC04Ljk1LTguOTV2My4wM3pNMTguOTIgMTNBNyA3IDAgMCAxIDEzIDE4LjkydjMuMDNjNC43Mi0uNDcgOC40OC00LjIzIDguOTUtOC45NWgtMy4wM3pNMTEgMTguOTJjLTMuMzktLjQ5LTYtMy40LTYtNi45MnMyLjYxLTYuNDMgNi02LjkyVjIuMDVjLTUuMDUuNS05IDQuNzYtOSA5Ljk1IDAgNS4xOSAzLjk1IDkuNDUgOSA5Ljk1di0zLjAzelxcXCIvPlxcbjwvc3ZnPlwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IFN0YXJTZWxlY3QsIHsgU2VsZWN0T3B0aW9uIH0gZnJvbSAnLi9TdGFyU2VsZWN0LnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHtvZGUsIG9kZXJhZn0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCB7eXdfYWNjb3VudCwgeXdfY2hhaW4sIHl3X293bmVyfSBmcm9tICcjIy9tZW0nO1xuXHRpbXBvcnQgdHlwZSB7IFJlc291cmNlIH0gZnJvbSAnIy9tZXRhL3Jlc291cmNlJztcblx0aW1wb3J0IHR5cGUgeyBUb2tlbiwgVG9rZW5QYXRoLCBUb2tlblNwZWNLZXkgfSBmcm9tICcjL21ldGEvdG9rZW4nO1xuXHRpbXBvcnQgeyBFbnRpdGllcyB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgdHlwZSB7IEVudGl0eVBhdGggfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB0eXBlIHsgUGZwUGF0aCB9IGZyb20gJyMvbWV0YS9wZnAnO1xuXHRpbXBvcnQgeyBsb2FkX3BmcHMgfSBmcm9tICcuLi9zdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgYXNzZXRSZWY6IEVudGl0eVBhdGggfCAnJyA9ICcnO1xuXG5cdGNvbnN0IHNpX2NoYWluID0gJHl3X2NoYWluPy5pZCB8fCAnKic7XG5cblx0bGV0IGhfYXNzZXRfcGZwczogUmVjb3JkPFBmcFBhdGgsIEhUTUxFbGVtZW50PiA9IHt9O1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYXNzZXRzKCkge1xuXHRcdGNvbnN0IGFfaXRlbXM6IFNlbGVjdE9wdGlvbltdID0gW107XG5cblx0XHRoX2Fzc2V0X3BmcHMgPSBhd2FpdCBsb2FkX3BmcHMoJHl3X2NoYWluLmNvaW5zLCB7XG5cdFx0XHRkaW06IDE5LFxuXHRcdH0pO1xuXG5cdFx0Zm9yKGNvbnN0IFtzaV9jb2luLCBnX2NvaW5dIG9mIG9kZSgkeXdfY2hhaW4uY29pbnMpKSB7XG5cdFx0XHRhX2l0ZW1zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogRW50aXRpZXMuaG9sZGluZ1BhdGhGb3IoJHl3X293bmVyLCBzaV9jb2luKSxcblx0XHRcdFx0b2JqZWN0OiBnX2NvaW4sXG5cdFx0XHRcdHByaW1hcnk6IHNpX2NvaW4sXG5cdFx0XHRcdHNlY29uZGFyeTogZ19jb2luLm5hbWUsXG5cdFx0XHRcdHBmcDogZ19jb2luLnBmcCxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhX2l0ZW1zO1xuXHR9XG5cblx0Ly8gdGhlIGN1cnJlbnQgaXRlbSBzZWxlY3RlZCBieSB1c2VyXG5cdGxldCBnX2l0ZW06IFNlbGVjdE9wdGlvbjxFbnRpdHlQYXRoPiA9IHtcblx0XHR2YWx1ZTogYXNzZXRSZWYgYXMgRW50aXR5UGF0aCxcblx0XHRvYmplY3Q6IG51bGwhLFxuXHRcdHByaW1hcnk6ICcnLFxuXHRcdHNlY29uZGFyeTogJycsXG5cdFx0cGZwOiAnJyBhcyBQZnBQYXRoLFxuXHR9O1xuXHQkOiB7XG5cdFx0Ly8gcHJvcGFnYXRlIGNoYW5nZSBiYWNrIHRvIGV4cG9ydGVkIGJpbmRpbmdcblx0XHRhc3NldFJlZiA9IGdfaXRlbT8udmFsdWUgfHwgJyc7XG5cdH1cblxuXHQvLyBhc3luYyBmdW5jdGlvbiBsb2FkX3Rva2VucygpIHtcblx0Ly8gXHQvLyBwcmVwIGFuIG91dHB1dCBsaXN0IG9mIHNlbGVjdCBpdGVtc1xuXHQvLyBcdGNvbnN0IGFfaXRlbXMgPSBbXTtcblxuXHQvLyBcdC8vIHJlYWQgYWxsIGZ1bmdpYmxlIHRva2VucyBmb3IgdGhpcyBjaGFpblxuXHQvLyBcdGNvbnN0IGhfaW50ZXJmYWNlcyA9IGF3YWl0IEVudGl0aWVzLnJlYWRGdW5naWJsZVRva2VucygkeXdfY2hhaW4pO1xuXG5cdC8vIFx0Ly8gZWFjaCBpbnRlcmZhY2Vcblx0Ly8gXHRmb3IoY29uc3Qgc2lfaW50ZXJmYWNlIGluIGhfaW50ZXJmYWNlcykge1xuXHQvLyBcdFx0Ly8gcmVmIHRva2VuIGRpY3Rcblx0Ly8gXHRcdGNvbnN0IGhfdG9rZW5zID0gaF9pbnRlcmZhY2VzW3NpX2ludGVyZmFjZSBhcyBUb2tlblNwZWNLZXldO1xuXG5cdC8vIFx0XHQvLyBlYWNoIHRva2VuXG5cdC8vIFx0XHRmb3IoY29uc3QgcF90b2tlbiBpbiBoX3Rva2Vucykge1xuXHQvLyBcdFx0XHQvLyByZWYgdG9rZW5cblx0Ly8gXHRcdFx0Y29uc3QgZ190b2tlbiA9IGhfdG9rZW5zW3BfdG9rZW4gYXMgVG9rZW5QYXRoXTtcblxuXHQvLyBcdFx0XHQvLyBhZGQgdG8gc2VsZWN0IGl0ZW1zIGxpc3Rcblx0Ly8gXHRcdFx0YV9pdGVtcy5wdXNoKHtcblx0Ly8gXHRcdFx0XHR2YWx1ZTogcF90b2tlbixcblx0Ly8gXHRcdFx0XHRsYWJlbDogYCR7Z190b2tlbi5iZWNoMzJ9ICR7Z190b2tlbi5zeW1ib2x9ICR7Z190b2tlbi5uYW1lfWAsXG5cdC8vIFx0XHRcdH0pO1xuXHQvLyBcdFx0fVxuXHQvLyBcdH1cblx0Ly8gfVxuXG5cdC8vIGNvbnN0IGFfdG9rZW5zID0gb2RlcmFmKEhfVE9LRU5TLCAoXywga190b2tlbikgPT4ge1xuXHQvLyBcdGNvbnN0IGtfY2hhaW4gPSBIX0NIQUlOU1trX3Rva2VuLmRlZi5jaGFpblJlZl07XG5cblx0Ly8gXHRpZihzaV9jaGFpbiA9PT0ga19jaGFpbi5kZWYuaWQpIHtcblx0Ly8gXHRcdHJldHVybiBbe1xuXHQvLyBcdFx0XHR2YWx1ZToga190b2tlbi5kZWYuaXJpLFxuXHQvLyBcdFx0XHRsYWJlbDogYCR7a190b2tlbi5kZWYuYWRkcmVzc30gJHtrX3Rva2VuLmRlZi5zeW1ib2x9ICR7a190b2tlbi5kZWYubGFiZWx9YCxcblx0Ly8gXHRcdFx0cHJpbWFyeToga190b2tlbi5kZWYuc3ltYm9sLFxuXHQvLyBcdFx0XHRzZWNvbmRhcnk6IGtfdG9rZW4uZGVmLmxhYmVsLFxuXHQvLyBcdFx0XHR0b2tlbjoga190b2tlbixcblx0Ly8gXHRcdH1dO1xuXHQvLyBcdH1cblxuXHQvLyBcdHJldHVybiBbXTtcblx0Ly8gfSk7XG5cblx0Ly8gbGV0IGdfdG9rZW5fc2VsZWN0ID0ga190b2tlbj8gYV90b2tlbnMuZmluZChnID0+IGcudmFsdWUgPT09IGtfdG9rZW4uZGVmLmlyaSk6IHZvaWQgMDtcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImFzc2V0XCI+XG5cdHsjYXdhaXQgbG9hZF9hc3NldHMoKX1cblx0XHRMb2FkaW5nIGFzc2V0cy4uLlxuXHR7OnRoZW4gYV9hc3NldHN9XG5cdFx0PFN0YXJTZWxlY3QgaWQ9XCJhc3NldC1zZWxlY3RcIlxuXHRcdFx0cGZwTWFwPXtoX2Fzc2V0X3BmcHN9XG5cdFx0XHRwbGFjZWhvbGRlcj1cIlNlbGVjdCBhc3NldFwiXG5cdFx0XHRpdGVtcz17YV9hc3NldHN9XG5cdFx0XHRiaW5kOnZhbHVlPXtnX2l0ZW19XG5cdFx0Lz5cblx0ey9hd2FpdH1cbjwvZGl2PiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJtMTIgOC02IDYgMS40MSAxLjQxTDEyIDEwLjgzbDQuNTkgNC41OEwxOCAxNGwtNi02elxcXCIvPlxcbjwvc3ZnPlwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIk0xNi41OSA4LjU5IDEyIDEzLjE3IDcuNDEgOC41OSA2IDEwbDYgNiA2LTYtMS40MS0xLjQxelxcXCIvPlxcbjwvc3ZnPlwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5cdC8vIGltcG9ydCB7IHl3X2Fzc2V0X3NlbmQsIHl3X2hvbGRpbmdfc2VuZCB9IGZyb20gJyMjL21lbSc7XG5cblx0aW1wb3J0IFNYX0lDT05fSU5DUkVNRU5UIGZyb20gJyMvaWNvbi9leHBhbmRfbGVzcy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fREVDUkVNRU5UIGZyb20gJyMvaWNvbi9leHBhbmRfbW9yZS5zdmc/cmF3Jztcblx0aW1wb3J0IHR5cGUgeyBFbnRpdHksIEVudGl0eVBhdGgsIE5hdGl2ZUNvaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgeyBFbnRpdGllcyB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgeyB5d19hY2NvdW50LCB5d19jaGFpbiwgeXdfbmV0d29ya19hY3RpdmUsIHl3X293bmVyIH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IHsgWFRfTUlOVVRFUyB9IGZyb20gJyMvc2hhcmUvY29uc3RhbnRzJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBmb3JtYXRfYW1vdW50IH0gZnJvbSAnIy91dGlsL2Zvcm1hdCc7XG5cdGltcG9ydCB7IENvaW5HZWNrbyB9IGZyb20gJyMvc3RvcmUvd2ViLWFwaXMnO1xuXG5cdGV4cG9ydCBsZXQgdmFsdWUgPSAnJztcblxuXHRjb25zdCBZR19aRVJPID0gbmV3IEJpZ051bWJlcigwKTtcblx0Y29uc3QgWUdfT05FID0gbmV3IEJpZ051bWJlcigxKTtcblxuXHRleHBvcnQgbGV0IGFzc2V0UmVmOiBFbnRpdHlQYXRoIHwgJycgPSAnJztcblxuXHQvKipcblx0ICogTGVhdmUgYSBidWZmZXIgZm9yIHRoZSBtYXhpbXVtIGFtb3VudCB0aGF0IGNhbiBiZSB1c2VkXG5cdCAqL1xuXHRleHBvcnQgbGV0IGJ1ZmZlck1heDogQmlnTnVtYmVyIHwgbnVtYmVyID0gMDtcblxuXHRsZXQgZ19hc3NldDogTmF0aXZlQ29pbiB8IG51bGw7XG5cblx0bGV0IHlnX21heDogQmlnTnVtYmVyID0gWUdfWkVSTztcblx0bGV0IHlnX3N0ZXA6IEJpZ051bWJlciA9IFlHX1pFUk87XG5cdGxldCBzX2ZpYXRfZXF1aXZhbGVudCA9ICcnO1xuXG5cdCQ6IHtcblx0XHRpZihhc3NldFJlZikge1xuXHRcdFx0dm9pZCByZWxvYWRfYXNzZXQoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRnX2Fzc2V0ID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRsZXQgc2lfY29pbmdlY2tvID0gJyc7XG5cdCQ6IHtcblx0XHRpZihzaV9jb2luZ2Vja28pIHtcblx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0Y29uc3QgaF92ZXJzdXMgPSBhd2FpdCBDb2luR2Vja28uY29pbnNWZXJzdXMoW3NpX2NvaW5nZWNrb10sICd1c2QnLCAxKlhUX01JTlVURVMpO1xuXHRcdFx0XHRpZihzaV9jb2luZ2Vja28gaW4gaF92ZXJzdXMpIHtcblx0XHRcdFx0XHRzX2ZpYXRfZXF1aXZhbGVudCA9IGZvcm1hdF9hbW91bnQoK3ZhbHVlICogK2hfdmVyc3VzW3NpX2NvaW5nZWNrb10sIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHNfZmlhdF9lcXVpdmFsZW50ID0gJyg/KSc7XG5cdFx0XHRcdH1cblx0XHRcdH0pKCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c19maWF0X2VxdWl2YWxlbnQgPSAnJztcblx0XHR9XG5cdH1cblxuXHRhc3luYyBmdW5jdGlvbiByZWxvYWRfYXNzZXQoKSB7XG5cdFx0c19maWF0X2VxdWl2YWxlbnQgPSAnWy4uLl0nO1xuXG5cdFx0Y29uc3QgZ19lbnRpdHkgPSBFbnRpdGllcy5wYXJzZUVudGl0eVBhdGgoYXNzZXRSZWYgYXMgRW50aXR5UGF0aCk7XG5cdFx0aWYoJ2hvbGRpbmcnID09PSBnX2VudGl0eT8udHlwZSkge1xuXHRcdFx0Y29uc3Qgc2lfY29pbiA9IGdfZW50aXR5LmNvaW47XG5cblx0XHRcdGdfYXNzZXQgPSAkeXdfY2hhaW4uY29pbnNbc2lfY29pbl07XG5cblx0XHRcdGNvbnN0IGdfY2FjaGVkID0gJHl3X25ldHdvcmtfYWN0aXZlLmNhY2hlZEJhbGFuY2UoJHl3X293bmVyLCBzaV9jb2luKTtcblxuXHRcdFx0aWYoZ19jYWNoZWQgJiYgZ19jYWNoZWQudGltZXN0YW1wID4gRGF0ZS5ub3coKSAtICg1ICogWFRfTUlOVVRFUykpIHtcblx0XHRcdFx0eWdfbWF4ID0gbmV3IEJpZ051bWJlcihnX2NhY2hlZC5kYXRhLmFtb3VudCkuc2hpZnRlZEJ5KC1nX2Fzc2V0LmRlY2ltYWxzKS5taW51cyhuZXcgQmlnTnVtYmVyKGJ1ZmZlck1heCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnX2J1bmRsZSA9IGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5iYW5rQmFsYW5jZSgkeXdfb3duZXIsIHNpX2NvaW4pO1xuXG5cdFx0XHQvLyBzdGlsbCBvbiBzYW1lIGNvaW5cblx0XHRcdGlmKGFzc2V0UmVmID09PSBnX2J1bmRsZS5ob2xkaW5nKSB7XG5cdFx0XHRcdGNvbnN0IHlnX2Ftb3VudCA9IG5ldyBCaWdOdW1iZXIoZ19idW5kbGUuYmFsYW5jZS5hbW91bnQpLnNoaWZ0ZWRCeSgtZ19hc3NldC5kZWNpbWFscykubWludXMobmV3IEJpZ051bWJlcihidWZmZXJNYXgpKTtcblx0XHRcdFx0aWYoIXlnX2Ftb3VudC5lcSh5Z19tYXgpKSB7XG5cdFx0XHRcdFx0eWdfbWF4ID0geWdfYW1vdW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZ19jb2luID0gJHl3X2NoYWluLmNvaW5zW3NpX2NvaW5dO1xuXG5cdFx0XHRcdHNpX2NvaW5nZWNrbyA9IGdfY29pbj8uZXh0cmE/LmNvaW5nZWNrb19pZCB8fCAnJztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZigndG9rZW4nID09PSBnX2VudGl0eT8udHlwZSkge1xuXHRcdFx0Ly8gY29uc3QgaF9pbnRlcmZhY2VzID0gRW50aXRpZXMuaW5mb0ZvclRva2VuKCk7XG5cdFx0XHQvLyAuLi5cblx0XHRcdC8vIFRPRE86IGltcGxlbWVudFxuXHRcdFx0Z19hc3NldCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYoZ19hc3NldCkge1xuXHRcdFx0eWdfc3RlcCA9IFlHX09ORS5zaGlmdGVkQnkoLWdfYXNzZXQuZGVjaW1hbHMpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHlnX3N0ZXAgPSBZR19aRVJPO1xuXHRcdFx0eWdfbWF4ID0gWUdfWkVSTztcblx0XHR9XG5cdH1cblxuXG5cdC8vICQ6IHhnX2Ftb3VudCA9IEJpZ0ludCgobmV3IEJpZ051bWJlcih2YWx1ZSkpLnNoaWZ0ZWRCeSgkeXdfYXNzZXRfc2VuZD8uZGVmLmRlY2ltYWxzIHx8IDApKycnKTtcblxuXHQvLyAkOiB5Z19zdGVwID0gZ19hc3NldD8gWUdfT05FLnNoaWZ0ZWRCeSgtZ19hc3NldC5kZWNpbWFscyk6IFlHX1pFUk87XG5cdC8vICQ6IHlnX21heCA9IENoYWlucy5cblx0Ly8gZ19hc3NldD8uYW1vdW50KEhfVE9LRU5TKSB8fCBZR19aRVJPO1xuXG5cdC8vIC8vIGZpeCBzdmVsdGUncyBzdHVwaWQgbWlzdGFrZSBvZiBjb2VyY2luZyBpbnB1dFt0eXBlPVwibnVtYmVyXCJdIHZhbHVlcyB0byBlcyBudW1iZXJzXG5cdC8vICQ6IHtcblx0Ly8gXHRpZignbnVtYmVyJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG5cdC8vIFx0XHR2YWx1ZSA9IGRtX2lucHV0LnZhbHVlO1xuXHQvLyBcdH1cblx0Ly8gfVxuXG5cdGZ1bmN0aW9uIGNhcHR1cmVfaW5wdXQoZF9ldmVudDogRXZlbnQpIHtcblx0XHR2YWx1ZSA9IChkX2V2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluY3JlbWVudCgpIHtcblx0XHRjb25zdCB5Z19uZXh0ID0geWdfc3RlcC5wbHVzKHZhbHVlIHx8IDApO1xuXG5cdFx0aWYoeWdfbmV4dC5sdGUoeWdfbWF4KSkge1xuXHRcdFx0dmFsdWUgPSB5Z19uZXh0KycnO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZhbHVlID0geWdfbWF4KycnO1xuXHRcdH1cblxuXHRcdGNoZWNrX3ZhbGlkaXR5KCk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNyZW1lbnQoKSB7XG5cdFx0Y29uc3QgeWdfbmV4dCA9IHlnX3N0ZXAubmVnYXRlZCgpLnBsdXModmFsdWUgfHwgMCk7XG5cdFx0aWYoeWdfbmV4dC5ndGUoMCkpIHtcblx0XHRcdGlmKHlnX25leHQuZ3QoeWdfbWF4KSkge1xuXHRcdFx0XHR2YWx1ZSA9IHlnX21heCsnJztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IHlnX25leHQrJyc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFsdWUgPSAnMCc7XG5cdFx0fVxuXG5cdFx0Y2hlY2tfdmFsaWRpdHkoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvbmdfcHJlc3MoZl9hY3Rpb246IFZvaWRGdW5jdGlvbikge1xuXHRcdGxldCBpX3RpY2tlciA9IDA7XG5cdFx0Y29uc3QgaV9idWZmZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRpX3RpY2tlciA9IHdpbmRvdy5zZXRJbnRlcnZhbChmX2FjdGlvbiwgOTApO1xuXHRcdH0sIDEwMDApO1xuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB7XG5cdFx0XHRjbGVhclRpbWVvdXQoaV9idWZmZXIpO1xuXHRcdFx0Y2xlYXJJbnRlcnZhbChpX3RpY2tlcik7XG5cdFx0fSwge1xuXHRcdFx0b25jZTogdHJ1ZSxcblx0XHR9KTtcblx0fVxuXG5cdGV4cG9ydCBsZXQgZXJyb3IgPSAnJztcblx0bGV0IGRtX2lucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xuXG5cdGZ1bmN0aW9uIGludmFsaWRhdGUoc19tc2c6IHN0cmluZykge1xuXHRcdGRtX2lucHV0LnNldEN1c3RvbVZhbGlkaXR5KHNfbXNnKTtcblx0XHRlcnJvciA9IHNfbXNnO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tfdmFsaWRpdHkoKSB7XG5cdFx0aWYoIXZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaW52YWxpZGF0ZSgnRW50ZXIgYW4gYW1vdW50Jyk7XG5cdFx0fVxuXG5cdFx0bGV0IHlnX2lucHV0ITogQmlnTnVtYmVyO1xuXHRcdHRyeSB7XG5cdFx0XHR5Z19pbnB1dCA9IG5ldyBCaWdOdW1iZXIodmFsdWUpO1xuXHRcdH1cblx0XHRjYXRjaChlX3BhcnNlKSB7XG5cdFx0XHRyZXR1cm4gaW52YWxpZGF0ZSgnSW52YWxpZCBudW1iZXInKTtcblx0XHR9XG5cblx0XHRpZih5Z19pbnB1dC5sdChZR19aRVJPKSkge1xuXHRcdFx0cmV0dXJuIGludmFsaWRhdGUoJ1ZhbHVlIG11c3QgYmUgcG9zaXRpdmUnKTtcblx0XHR9XG5cblx0XHRpZih5Z19pbnB1dC5ndCh5Z19tYXgpKSB7XG5cdFx0XHRyZXR1cm4gaW52YWxpZGF0ZSgnSW5zdWZmaWNpZW50IGJhbGFuY2UnKTtcblx0XHR9XG5cblx0XHRlcnJvciA9ICcnO1xuXHR9XG5cblx0ZXhwb3J0IGxldCBzaG93VmFsaWRhdGlvbiA9IDA7XG5cdCQ6IHtcblx0XHRpZihzaG93VmFsaWRhdGlvbikge1xuXHRcdFx0Y2hlY2tfdmFsaWRpdHkoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZighdmFsdWUpIHtcblx0XHRcdGVycm9yID0gJyc7XG5cdFx0fVxuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0aW5wdXRbdHlwZT1cIm51bWJlclwiXSB7XG5cdFx0YXBwZWFyYW5jZTogdGV4dGZpZWxkO1xuXG5cdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiwgJjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XG5cdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG5cdFx0fVxuXHR9XG5cblx0LmFtb3VudC1pbnB1dCB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHR9XG5cblx0Lm9jY3VweSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblx0XHRoZWlnaHQ6IHZhcigtLXVpLXJvdy1oZWlnaHQpO1xuXG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXG5cdFx0LmFkanVzdCB7XG5cblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0XHRnYXA6IDRweDtcblx0XHRcdG1hcmdpbi1yaWdodDogOHB4O1xuXG5cdFx0XHQuaWNvbiB7XG5cdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdFx0cGFkZGluZzogMHB4IDhweDtcblx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAxNnB4O1xuXHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXG5cdFx0XHRcdC5pbmNyZW1lbnQge1xuXHRcdFx0XHRcdHBhZGRpbmctdG9wOiA0cHg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQuZGVjcmVtZW50IHtcblx0XHRcdFx0XHRwYWRkaW5nLWJvdHRvbTogNHB4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmVxdWl2YWxlbnQge1xuXHRcdFx0LmZvbnQocmVndWxhciwgQHNpemU6IDEzcHgsIEB3ZWlnaHQ6IDMwMCk7XG5cblx0XHRcdC5hbW91bnQge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHQuZmlhdCB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJhbW91bnQtaW5wdXRcIj5cblx0PGlucHV0XG5cdFx0ZGlzYWJsZWQ9eyFhc3NldFJlZn1cblx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRtaW49XCIwXCJcblx0XHRtYXg9e3lnX21heCsnJyB8fCAnMCd9XG5cdFx0c3RlcD1cIjAueycwJy5yZXBlYXQoKGdfYXNzZXQ/LmRlY2ltYWxzIHx8IDEpIC0gMSl9MVwiXG5cdFx0cmVxdWlyZWRcblx0XHRvbjpjaGFuZ2U9eygpID0+IGNoZWNrX3ZhbGlkaXR5KCl9XG5cdFx0b246aW5wdXQ9e2NhcHR1cmVfaW5wdXR9XG5cdFx0e3ZhbHVlfVxuXHRcdGJpbmQ6dGhpcz17ZG1faW5wdXR9XG5cdFx0b246aW52YWxpZD17ZCA9PiBkLnByZXZlbnREZWZhdWx0KCl9XG5cdFx0Y2xhc3M6aW52YWxpZD17ZXJyb3J9XG5cdD5cblxuXHR7I2lmIGdfYXNzZXR9XG5cdFx0PHNwYW4gY2xhc3M9XCJvY2N1cHlcIj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiZXF1aXZhbGVudFwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImFtb3VudFwiPlxuXHRcdFx0XHRcdD0ge3NfZmlhdF9lcXVpdmFsZW50fVxuXHRcdFx0XHRcdDwhLS0gIGFtb3VudF90b19maWF0KCt2YWx1ZSwgJHl3X2Fzc2V0X3NlbmQsIHRydWUpIC0tPlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiZmlhdFwiPlxuXHRcdFx0XHRcdFVTRFxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L3NwYW4+XG5cblx0XHRcdDxzcGFuIGNsYXNzPVwiYWRqdXN0XCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvbiBpbmNyZW1lbnQgY2xpY2thYmxlXCJcblx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gaW5jcmVtZW50KCl9XG5cdFx0XHRcdFx0b246bW91c2Vkb3duPXsoKSA9PiBsb25nX3ByZXNzKGluY3JlbWVudCl9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9JTkNSRU1FTlR9XG5cdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb24gZGVjcmVtZW50IGNsaWNrYWJsZVwiXG5cdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IGRlY3JlbWVudCgpfVxuXHRcdFx0XHRcdG9uOm1vdXNlZG93bj17KCkgPT4gbG9uZ19wcmVzcyhkZWNyZW1lbnQpfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fREVDUkVNRU5UfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9zcGFuPlxuXHR7L2lmfVxuXG5cdHsjaWYgZXJyb3J9XG5cdFx0PHNwYW4gY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIj5cblx0XHRcdHtlcnJvcn1cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG48L2Rpdj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyB5d19hY2NvdW50X3JlZiwgeXdfY2hhaW59IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB0eXBlIHtBY2NvdW50LCBBY2NvdW50UGF0aH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQgeyBvZGUsIG9kZXJhYyB9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXG5cdGltcG9ydCBTdGFyU2VsZWN0LCB7IFNlbGVjdE9wdGlvbiB9IGZyb20gJy4vU3RhclNlbGVjdC5zdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgYWNjb3VudFJlZjogQWNjb3VudFBhdGggPSAkeXdfYWNjb3VudF9yZWY7XG5cdGNvbnN0IHBfYWNjb3VudCA9IGFjY291bnRSZWY7XG5cblxuXHRjb25zdCBta19hY2NvdW50ID0gKHBfYWNjOiBBY2NvdW50UGF0aCwgZ19hY2M6IEFjY291bnRbJ2ludGVyZmFjZSddKSA9PiAoe1xuXHRcdHZhbHVlOiBwX2FjYyxcblx0XHRwcmltYXJ5OiBnX2FjYy5uYW1lLFxuXHRcdHNlY29uZGFyeTogJyQkJyxcblx0XHQvLyBzZWNvbmRhcnk6IGZvcm1hdF9maWF0KGdfYWNjLmhvbGRpbmdzKEhfSE9MRElOR1MsICR5d19jaGFpbilcblx0XHRcdC8vIC5yZWR1Y2UoKGNfc3VtLCBrX2hvbGRpbmcpID0+IGNfc3VtICsga19ob2xkaW5nLnRvVXNkKEhfVE9LRU5TLCBIX1ZFUlNVU19VU0QpLCAwKSksXG5cdH0pO1xuXG5cdGxldCBnX3NlbGVjdGVkOiBTZWxlY3RPcHRpb248QWNjb3VudFBhdGg+OyAgLy8gPSBta19hY2NvdW50KCR5d19hY2NvdW50X3JlZiwgJHl3X2FjY291bnQpO1xuXHRsZXQgYV9vcHRpb25zOiB0eXBlb2YgZ19zZWxlY3RlZFtdO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYWNjb3VudHMoKSB7XG5cdFx0Y29uc3Qga3NfYWNjb3VudHMgPSBhd2FpdCBBY2NvdW50cy5yZWFkKCk7XG5cblx0XHRhX29wdGlvbnMgPSBvZGVyYWMoa3NfYWNjb3VudHMucmF3LCBta19hY2NvdW50KTtcblx0XHRnX3NlbGVjdGVkID0gYV9vcHRpb25zLmZpbmQoZyA9PiBwX2FjY291bnQgPT09IGcudmFsdWUpITtcblxuXHRcdHJldHVybiBhX29wdGlvbnM7XG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcbjwvc3R5bGU+XG5cblxuPGRpdiBjbGFzcz1cInNlbmRlclwiPlxuXHR7I2F3YWl0IGxvYWRfYWNjb3VudHMoKX1cblx0XHRMb2FkaW5nIGFjY291bnRzLi4uXG5cdHs6dGhlbiBhX29wdGlvbnN9XG5cdFx0PFN0YXJTZWxlY3QgaWQ9XCJzZW5kZXItc2VsZWN0XCJcblx0XHRcdHBsYWNlaG9sZGVyPVwiU2VsZWN0IGFjY291bnRcIlxuXHRcdFx0c2Vjb25kYXJ5Q2xhc3M9J2JhbGFuY2UnXG5cdFx0XHRpdGVtcz17YV9vcHRpb25zfVxuXHRcdFx0YmluZDp2YWx1ZT17Z19zZWxlY3RlZH1cblx0XHQvPlxuXHR7L2F3YWl0fVxuPC9kaXY+IiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCIgbGFuZz1cInRzXCI+XG5cdGV4cG9ydCBpbnRlcmZhY2UgQ29udGFjdE9wdGlvbiB7XG5cdFx0dmFsdWU6IENoYWluLkJlY2gzMlN0cmluZztcblx0XHRsYWJlbDogc3RyaW5nO1xuXHRcdGNvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddO1xuXHR9XG48L3NjcmlwdD5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHt5d19jaGFpbiwgeXdfZmFtaWx5fSBmcm9tICcjIy9tZW0nO1xuXHRpbXBvcnQgdHlwZSB7IENoYWluIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IHR5cGUgeyBDb250YWN0LCBDb250YWN0UGF0aCB9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHsgQWdlbnRzIH0gZnJvbSAnIy9zdG9yZS9hZ2VudHMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IHN1YnNjcmliZV9zdG9yZSB9IGZyb20gJyMvc3RvcmUvX2Jhc2UnO1xuXHRpbXBvcnQgeyBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgUGZwRGlzcGxheSBmcm9tICcuL1BmcERpc3BsYXkuc3ZlbHRlJztcblxuXHQvKipcblx0ICogUmVzb3VyY2UgcGF0aCB0byB0aGUgY29udGFjdFxuXHQgKi9cblx0ZXhwb3J0IGxldCBjb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSB8IG51bGwgPSBudWxsO1xuXHRsZXQgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSA9IGNvbnRhY3QhO1xuXG5cdC8qKlxuXHQgKiBNYW51YWxseSBlbnRlcmVkIGFkZHJlc3Ncblx0ICovXG5cdGV4cG9ydCBsZXQgYWRkcmVzczogQ2hhaW4uQmVjaDMyU3RyaW5nID0gJyc7XG5cblx0Ly8gLy8gcmVzb2x2ZWQgY29udGFjdFxuXHQvLyBsZXQgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXTtcblxuXHQvLyBsb2FkIGNvbnRhY3QgZGVmIGZyb20gc3RvcmVcblx0YXN5bmMgZnVuY3Rpb24gcmVsb2FkX2NvbnRhY3RzKCkge1xuXHRcdC8vIGxvYWQgYWdlbnRzIHN0b3JlXG5cdFx0Y29uc3Qga3NfYWdlbnRzID0gYXdhaXQgQWdlbnRzLnJlYWQoKTtcblxuXHRcdC8vIGNvbnRhY3QgaXRlcmF0b3Jcblx0XHRjb25zdCBkaV9jb250YWN0cyA9IGtzX2FnZW50cy5jb250YWN0cygkeXdfZmFtaWx5KTtcbi8vIGRlYnVnZ2VyO1xuLy8gXHRcdC8vIGNvbnRhY3QgaXMgcHJlc2VudFxuLy8gXHRcdGlmKGdfY29udGFjdCkge1xuLy8gXHRcdFx0Ly8gZWFjaCBjb250YWN0XG4vLyBcdFx0XHRmb3IoY29uc3QgW3BfY29udGFjdF9lYWNoLCBnX2NvbnRhY3RfZWFjaF0gb2YgZGlfY29udGFjdHMpIHtcbi8vIFx0XHRcdFx0Ly8gZm91bmQgbWF0Y2hcbi8vIFx0XHRcdFx0aWYocF9jb250YWN0ID09PSBwX2NvbnRhY3RfZWFjaCkge1xuLy8gXHRcdFx0XHRcdGdfY29udGFjdCA9IGdfY29udGFjdF9lYWNoO1xuLy8gXHRcdFx0XHRcdGJyZWFrO1xuLy8gXHRcdFx0XHR9XG4vLyBcdFx0XHR9XG4vLyBcdFx0fVxuXHRcdC8vIG9ubHkgYWRkcmVzcyB3YXMgZ2l2ZW5cblx0XHRpZighZ19jb250YWN0ICYmIGFkZHJlc3MpIHtcblx0XHRcdC8vIGVhY2ggY29udGFjdFxuXHRcdFx0Zm9yKGNvbnN0IFssIGdfY29udGFjdF9lYWNoXSBvZiBkaV9jb250YWN0cykge1xuXHRcdFx0XHQvLyBjaGVjayBpZiBhZGRyZXNzIGV4aXN0cyBpbiBjb250YWN0cywgZm91bmQgbWF0Y2hcblx0XHRcdFx0aWYoYWRkcmVzcyA9PT0gQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3RfZWFjaC5hZGRyZXNzKSkge1xuXHRcdFx0XHRcdGdfY29udGFjdCA9IGdfY29udGFjdF9lYWNoO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dm9pZCByZWxvYWRfY29udGFjdHMoKTtcblx0Y29uc3QgZl91bnN1Yl9hZ2VudHMgPSBzdWJzY3JpYmVfc3RvcmUoJ2FnZW50cycsIHJlbG9hZF9jb250YWN0cyk7XG5cdG9uRGVzdHJveSgoKSA9PiB7XG5cdFx0Zl91bnN1Yl9hZ2VudHMoKTtcblx0fSk7XG5cblxuXHQvLyBleHBvcnQgbGV0IGdfaXRlbToge1xuXHQvLyBcdGNvbnRhY3Q6IENvbnRhY3Q7XG5cdC8vIFx0aXNHcm91cEhlYWRlcj86IGJvb2xlYW47XG5cdC8vIFx0aXNHcm91cEl0ZW0/OiBib29sZWFuO1xuXHQvLyBcdGlzQ3JlYXRvcj86IGJvb2xlYW47XG5cdC8vIH0gfCB1bmRlZmluZWQgPSB2b2lkIDA7XG5cblx0PC9zY3JpcHQ+XG5cdFxuXHQ8c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0XHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblx0XG5cdFx0LmNvbnRhY3Qge1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiByb3c7XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcblx0XHRcdC8vIHBhZGRpbmctdG9wOiAzcHg7XG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94Oztcblx0XG5cdFx0XHQ+LmNvbnRhY3QtcGZwIHtcblx0XHRcdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0XHRcdC0tcHJveHktaWNvbi1kaWFtZXRlcjogMjZweDtcblx0XHRcdFx0bGluZS1oZWlnaHQ6IDI2cHg7XG5cdFx0XHRcdG1hcmdpbi1yaWdodDogNnB4O1xuXHRcblx0XHRcdFx0Pi5pY29uIHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdGJvcmRlci1yYWRpdXM6IDIwJTtcblx0XHRcdFx0XHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdFx0XHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC5pY29uLWRvbSB7XG5cdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiB1bnNldDtcblx0XHRcdFx0XHRcdFx0Zm9udC1zaXplOiAxNHB4OyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQ+LmluZm8ge1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdFx0XHRtYXgtd2lkdGg6IDE3MnB4O1xuXHRcblx0XHRcdFx0Pi5uYW1lIHtcblx0XHRcdFx0XHRsaW5lLWhlaWdodDogMS4yZW07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdD4uYWRkcmVzcyB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHQvLyAuZm9udChtb25vLXRpbnkpO1xuXHRcdFx0XHRcdFx0bGluZS1oZWlnaHQ6IDEuMmVtO1xuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyA+KiB7XG5cdFx0XHQvLyBcdDpnbG9iYWwoJikge1xuXHRcdFx0Ly8gXHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdFx0XHQvLyBcdH1cblx0XHRcdC8vIH1cblx0XHR9XG5cdFxuXHRcdC5tYW51YWwge1xuXHRcdFx0LmFkZHJlc3Mge1xuXHRcdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gMy41Y2gpO1xuXHRcdFx0fVxuXHRcdH1cblx0PC9zdHlsZT5cblx0XG5cdHsjaWYgZ19jb250YWN0fVxuXHRcdDxkaXYgY2xhc3M9XCJjb250YWN0XCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImNvbnRhY3QtcGZwXCI+XG5cdFx0XHRcdHsjaWYgZ19jb250YWN0fVxuXHRcdFx0XHRcdDxQZnBEaXNwbGF5IGRpbT17Mjh9IHJlc291cmNlPXtnX2NvbnRhY3R9IGdlblN0eWxlPSdmb250LXNpemU6MThweDsnIC8+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHQ8L3NwYW4+XG5cdFxuXHRcdFx0PHNwYW4gY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdHtnX2NvbnRhY3QubmFtZX1cblx0XHRcdFx0PC9zcGFuPlxuXHRcblx0XHRcdFx0PEFkZHJlc3MgYWRkcmVzcz17Q2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcyl9IC8+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9kaXY+XG5cdHs6ZWxzZSBpZiBhZGRyZXNzfVxuXHRcdDxzcGFuIGNsYXNzPVwibWFudWFsXCI+XG5cdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXthZGRyZXNzfSAvPlxuXHRcdDwvc3Bhbj5cblx0ezplbHNlfVxuXHRcdDxzcGFuIGNsYXNzPVwid2FybmluZ1wiPlxuXHRcdFx0RmFpbGVkIHRvIGxvY2F0ZSBjb250YWN0XG5cdFx0PC9zcGFuPlxuXHR7L2lmfSIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdFBhdGh9IGZyb20gJyMvbWV0YS9jb250YWN0JztcblxuXHRpbXBvcnQgSW5saW5lQ29udGFjdFNlbGVjdGlvbiwgeyBDb250YWN0T3B0aW9uIH0gZnJvbSAnLi9JbmxpbmVDb250YWN0U2VsZWN0aW9uLnN2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBpc0FjdGl2ZSA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGlzRmlyc3QgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBpc0hvdmVyID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgaXNTZWxlY3RhYmxlID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgZ2V0T3B0aW9uTGFiZWwgPSB2b2lkIDA7XG5cdGV4cG9ydCBsZXQgaXRlbTogQ29udGFjdE9wdGlvbjtcblx0Ly8gXHRpc0dyb3VwSGVhZGVyPzogYm9vbGVhbjtcblx0Ly8gXHRpc0dyb3VwSXRlbT86IGJvb2xlYW47XG5cdC8vIH07XG5cdGV4cG9ydCBsZXQgZmlsdGVyVGV4dCA9ICcnO1xuXG5cdGxldCBpdGVtQ2xhc3NlcyA9ICcnO1xuXG5cdCQ6IHtcblx0XHRjb25zdCBjbGFzc2VzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdGlmKGlzQWN0aXZlKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2FjdGl2ZScpO1xuXHRcdH1cblx0XG5cdFx0aWYoaXNGaXJzdCkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmaXJzdCcpO1xuXHRcdH1cblx0XG5cdFx0aWYoaXNIb3Zlcikge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdob3ZlcicpO1xuXHRcdH1cblx0XG5cdFx0Ly8gaWYoaXRlbS5pc0dyb3VwSGVhZGVyKSB7XG5cdFx0Ly8gXHRjbGFzc2VzLnB1c2goJ2dyb3VwSGVhZGVyJyk7XG5cdFx0Ly8gfVxuXHRcblx0XHQvLyBpZihpdGVtLmlzR3JvdXBJdGVtKSB7XG5cdFx0Ly8gXHRjbGFzc2VzLnB1c2goJ2dyb3VwSXRlbScpO1xuXHRcdC8vIH1cblx0XG5cdFx0aWYoIWlzU2VsZWN0YWJsZSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdub3RTZWxlY3RhYmxlJyk7XG5cdFx0fVxuXHRcblx0XHRpdGVtQ2xhc3NlcyA9IGNsYXNzZXMuam9pbignICcpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5pdGVtIHtcblx0XHRjdXJzb3I6IGRlZmF1bHQ7XG5cdFx0aGVpZ2h0OiB2YXIoLS1oZWlnaHQsIDQycHgpO1xuXHRcdGxpbmUtaGVpZ2h0OiB2YXIoLS1oZWlnaHQsIDQycHgpO1xuXHRcdHBhZGRpbmc6IHZhcigtLWl0ZW1QYWRkaW5nLCAwIDIwcHgpO1xuXHRcdGNvbG9yOiB2YXIoLS1pdGVtQ29sb3IsIGluaGVyaXQpO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRwYWRkaW5nLWxlZnQ6IDhweDtcblx0fVxuXG5cdC5ncm91cEhlYWRlciB7XG5cdFx0dGV4dC10cmFuc2Zvcm06IHZhcigtLWdyb3VwVGl0bGVUZXh0VHJhbnNmb3JtLCB1cHBlcmNhc2UpO1xuXHR9XG5cblx0Lmdyb3VwSXRlbSB7XG5cdFx0cGFkZGluZy1sZWZ0OiB2YXIoLS1ncm91cEl0ZW1QYWRkaW5nTGVmdCwgNDBweCk7XG5cdH1cblxuXHQuaXRlbTphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6IHZhcigtLWl0ZW1BY3RpdmVCYWNrZ3JvdW5kLCAjYjlkYWZmKTtcblx0fVxuXG5cdC5pdGVtLmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogdmFyKC0taXRlbUlzQWN0aXZlQkcsICMwMDdhZmYpO1xuXHRcdGNvbG9yOiB2YXIoLS1pdGVtSXNBY3RpdmVDb2xvciwgI2ZmZik7XG5cdH1cblxuXHQuaXRlbS5ub3RTZWxlY3RhYmxlIHtcblx0XHRjb2xvcjogdmFyKC0taXRlbUlzTm90U2VsZWN0YWJsZUNvbG9yLCAjOTk5KTtcblx0fVxuXG5cdC5pdGVtLmZpcnN0IHtcblx0XHRib3JkZXItcmFkaXVzOiB2YXIoLS1pdGVtRmlyc3RCb3JkZXJSYWRpdXMsIDRweCA0cHggMCAwKTtcblx0fVxuXG5cdC5pdGVtLmhvdmVyOm5vdCguYWN0aXZlKSB7XG5cdFx0YmFja2dyb3VuZDogdmFyKC0taXRlbUhvdmVyQkcsICNlN2YyZmYpO1xuXHRcdGNvbG9yOiB2YXIoLS1pdGVtSG92ZXJDb2xvciwgaW5oZXJpdCk7XG5cdH1cbjwvc3R5bGU+XG5cblxuPGRpdiBjbGFzcz1cIml0ZW0ge2l0ZW1DbGFzc2VzfVwiIGNsYXNzOmRpc3BsYXlfbm9uZT17aXNBY3RpdmUgfHwgIWl0ZW0udmFsdWV9PlxuXHQ8SW5saW5lQ29udGFjdFNlbGVjdGlvbiBjb250YWN0PXtpdGVtLmNvbnRhY3R9IGFkZHJlc3M9e2l0ZW0udmFsdWV9IC8+XG48L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdFBhdGh9IGZyb20gJyMvbWV0YS9jb250YWN0JztcblxuXHRpbXBvcnQgSW5saW5lQ29udGFjdFNlbGVjdGlvbiwgeyBDb250YWN0T3B0aW9uIH0gZnJvbSAnLi9JbmxpbmVDb250YWN0U2VsZWN0aW9uLnN2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBnZXRTZWxlY3Rpb25MYWJlbDtcblx0ZXhwb3J0IGxldCBpdGVtOiBDb250YWN0T3B0aW9uO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQuc2VsZWN0aW9uIHtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHRvdmVyZmxvdy14OiBoaWRkZW47XG5cdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0cGFkZGluZy1sZWZ0OiA4cHg7XG5cblx0XHQubWFudWFsPi5hZGRyZXNzIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gMy41Y2gpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwic2VsZWN0aW9uXCI+XG5cdDxJbmxpbmVDb250YWN0U2VsZWN0aW9uIGNvbnRhY3Q9e2l0ZW0uY29udGFjdH0gYWRkcmVzcz17aXRlbS52YWx1ZX0gLz5cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7eXdfYWNjb3VudCwgeXdfY2hhaW4sIHl3X2ZhbWlseSwgeXdfaGVscH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgUmVjaXBpZW50U2VsZWN0SXRlbSBmcm9tICcuL1JlY2lwaWVudFNlbGVjdEl0ZW0uc3ZlbHRlJztcblxuXHRpbXBvcnQgU2VsZWN0IGZyb20gJ3N2ZWx0ZS1zZWxlY3QnO1xuXHRpbXBvcnQgU1hfSUNPTl9TQ0FOIGZyb20gJyMvaWNvbi9xcl9jb2RlX3NjYW5uZXIuc3ZnP3Jhdyc7XG5cdGltcG9ydCBSZWNpcGllbnRTZWxlY3RTZWxlY3Rpb24gZnJvbSAnLi9SZWNpcGllbnRTZWxlY3RTZWxlY3Rpb24uc3ZlbHRlJztcblx0aW1wb3J0IHtvZGVyYWN9IGZyb20gJyMvdXRpbC9iZWx0Jztcblx0aW1wb3J0IHtvbk1vdW50fSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQge2RkLCBxc30gZnJvbSAnIy91dGlsL2RvbSc7XG5cdGltcG9ydCB0eXBlIHtBZ2VudFBhdGgsIENoYWlufSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgdHlwZSB7IENvbnRhY3QgfSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgdHlwZSB7IENvbnRhY3RPcHRpb24gfSBmcm9tICcuL0lubGluZUNvbnRhY3RTZWxlY3Rpb24uc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IGFkZHJlc3M6IENoYWluLkJlY2gzMlN0cmluZyA9ICcnO1xuXHRjb25zdCBzYV9pbnB1dCA9IGFkZHJlc3M7XG5cblx0ZXhwb3J0IGxldCBlcnJvciA9ICcnO1xuXG5cdGxldCBzX21hbnVhbF9pbnB1dDogc3RyaW5nO1xuXHRsZXQgZ19pdGVtX3NlbGVjdDogQ29udGFjdE9wdGlvbjtcblxuXHRsZXQgYV9jb250YWN0czogW0FnZW50UGF0aCwgQ29udGFjdFsnaW50ZXJmYWNlJ11dW107XG5cblx0Y29uc3QgY29udGFjdF90b19vcHRpb24gPSAoZzogQ29udGFjdFsnaW50ZXJmYWNlJ10pOiBDb250YWN0T3B0aW9uID0+ICh7XG5cdFx0dmFsdWU6IENoYWlucy5iZWNoMzIoZy5hZGRyZXNzKSxcblx0XHRsYWJlbDogZy5uYW1lLFxuXHRcdGNvbnRhY3Q6IGcsXG5cdH0pO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfY29udGFjdHMoKTogUHJvbWlzZTxDb250YWN0T3B0aW9uW10+IHtcblx0XHRjb25zdCBrc19hZ2VudHMgPSBhd2FpdCBBZ2VudHMucmVhZCgpO1xuXG5cdFx0Y29uc3QgYV9vcHRpb25zOiBDb250YWN0T3B0aW9uW10gPSBbe1xuXHRcdFx0dmFsdWU6ICcnLFxuXHRcdFx0bGFiZWw6ICcnLFxuXHRcdFx0Y29udGFjdDogbnVsbCEsXG5cdFx0fV07XG5cblx0XHRhX2NvbnRhY3RzID0gWy4uLmtzX2FnZW50cy5jb250YWN0cygkeXdfZmFtaWx5KV07XG5cdFx0Zm9yKGNvbnN0IFssIGdfY29udGFjdF0gb2YgYV9jb250YWN0cykge1xuXHRcdFx0Y29uc3QgZ19vcHRpb24gPSBjb250YWN0X3RvX29wdGlvbihnX2NvbnRhY3QpO1xuXG5cdFx0XHRjb25zdCBzYV9jb250YWN0ID0gQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcyk7XG5cdFx0XHRpZihzYV9pbnB1dCAmJiBzYV9jb250YWN0ID09PSBzYV9pbnB1dCkge1xuXHRcdFx0XHRnX2l0ZW1fc2VsZWN0ID0gZ19vcHRpb247XG5cdFx0XHR9XG5cblx0XHRcdGFfb3B0aW9ucy5wdXNoKGdfb3B0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYV9vcHRpb25zO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VsZWN0KGRfZXZlbnQ6IEN1c3RvbUV2ZW50PENvbnRhY3RPcHRpb24+KSB7XG5cdFx0YWRkcmVzcyA9IGRfZXZlbnQuZGV0YWlsLnZhbHVlO1xuXHRcdGVycm9yID0gJyc7XG5cdH1cblxuXHRmdW5jdGlvbiBjbGVhcigpIHtcblx0XHRhZGRyZXNzID0gJyc7XG5cdH1cblxuXHRsZXQgc19hY2NlcHRlZF9pbnB1dCA9ICcnO1xuXHRsZXQgYl9oaWRlX2N1cnNvciA9IGZhbHNlO1xuXG5cdGxldCBiX2xpc3Rfb3BlbiA9IGZhbHNlO1xuXG5cdCQ6IHtcblx0XHRiX2hpZGVfY3Vyc29yID0gZmFsc2U7XG5cblx0XHRpZihzX21hbnVhbF9pbnB1dCkge1xuXHRcdFx0Y2hlY2tfbWFudWFsX2lucHV0KCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Yl9oaWRlX2N1cnNvciA9ICEhc19hY2NlcHRlZF9pbnB1dDtcblx0XHRcdHNfYWNjZXB0ZWRfaW5wdXQgPSAnJztcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja19tYW51YWxfaW5wdXQoKSB7XG5cdFx0c19hY2NlcHRlZF9pbnB1dCA9ICcnO1xuXG5cdFx0aWYoISR5d19jaGFpbikge1xuXHRcdFx0Ly8gc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGdldCBoZXJlIHdpdGhvdXQgYmVpbmcgb24gYSBjaGFpblxuXHRcdFx0ZXJyb3IgPSAnTm8gY2hhaW4gc2V0Jztcblx0XHR9XG5cdFx0ZWxzZSBpZighQ2hhaW5zLmlzVmFsaWRBZGRyZXNzRm9yKCR5d19jaGFpbiwgc19tYW51YWxfaW5wdXQsICdhY2MnKSkge1xuXHRcdFx0ZXJyb3IgPSAnSW52YWxpZCBhZGRyZXNzIGZvciB0aGlzIGNoYWluJztcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRlcnJvciA9ICcnO1xuXG5cdFx0XHQvLyBzZWFyY2ggZm9yIGFkZHJlc3MgaW4gY29udGFjdHNcblx0XHRcdGZvcihjb25zdCBbLCBnX2NvbnRhY3RdIG9mIGFfY29udGFjdHMpIHtcblx0XHRcdFx0Ly8gY29udGFjdCBleGlzdHNcblx0XHRcdFx0aWYoc19tYW51YWxfaW5wdXQgPT09IENoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MpKSB7XG5cdFx0XHRcdFx0Ly8gY2xlYXIgZmlsdGVyIHRleHRcblx0XHRcdFx0XHRzX21hbnVhbF9pbnB1dCA9ICcnO1xuXHRcblx0XHRcdFx0XHQvLyBzZWxlY3QgY29udGFjdCBpbnN0ZWFkIG9mIHVzaW5nIHJhdyBhZGRyZXNzXG5cdFx0XHRcdFx0Z19pdGVtX3NlbGVjdCA9IGNvbnRhY3RfdG9fb3B0aW9uKGdfY29udGFjdCk7XG5cblx0XHRcdFx0XHQvLyBjbG9zZSBsaXN0XG5cdFx0XHRcdFx0Yl9saXN0X29wZW4gPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIGhpZGUgY3Vyc29yXG5cdFx0XHRcdFx0Yl9oaWRlX2N1cnNvciA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNfYWNjZXB0ZWRfaW5wdXQgPSBzX21hbnVhbF9pbnB1dDtcblxuXHRcdFx0Ly8gc2VsZWN0IGFkZHJlc3MgaW1tZWRpYXRlbHlcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHQocXMoZG1fc2VuZGVyLCAnLm1hbnVhbD4uYWRkcmVzcycpIGFzIEhUTUxFbGVtZW50KS5jbGljaygpO1xuXHRcdFx0XHRiX2xpc3Rfb3BlbiA9IGZhbHNlO1xuXHRcdFx0fSwgMCk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGRtX3NlbmRlcjogSFRNTEVsZW1lbnQ7XG5cdFxuXHRleHBvcnQgbGV0IHNob3dWYWxpZGF0aW9uID0gMDtcblx0JDoge1xuXHRcdGlmKHNob3dWYWxpZGF0aW9uKSB7XG5cdFx0XHRpZighYWRkcmVzcykge1xuXHRcdFx0XHRpZihzX21hbnVhbF9pbnB1dCkge1xuXHRcdFx0XHRcdGNoZWNrX21hbnVhbF9pbnB1dCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGVycm9yID0gJ0VudGVyIGEgcmVjaXBpZW50Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZighQ2hhaW5zLmlzVmFsaWRBZGRyZXNzRm9yKCR5d19jaGFpbiwgYWRkcmVzcywgJ2FjYycpKSB7XG5cdFx0XHRcdGVycm9yID0gJ0ludmFsaWQgYWRkcmVzcyBmb3IgdGhpcyBjaGFpbic7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZXJyb3IgPSAnJztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZighYWRkcmVzcykge1xuXHRcdFx0ZXJyb3IgPSAnJztcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblxuXHQuc2VuZGVyIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0XHQuc3R5bGUtc3ZlbHRlLXNlbGVjdCgpO1xuXHRcdC5mb250KHJlZ3VsYXIsIDQwMCwgMTNweCk7XG5cblx0XHQtLWlucHV0UGFkZGluZzogMTZweDtcblx0XHQtLXBhZGRpbmc6IDAgNHB4O1xuXHRcdC0taXRlbVBhZGRpbmc6IDA7XG5cdFx0LS1zZWxlY3RlZEl0ZW1QYWRkaW5nOiAwO1xuXG5cdFx0PmlucHV0IHtcblx0XHRcdCY6OmFmdGVyIHtcblx0XHRcdFx0Y29udGVudDogJyc7XG5cdFx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdFx0cmlnaHQ6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pi5pY29uIHtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRyaWdodDogMDtcblx0XHRcdHBhZGRpbmc6IDEycHg7XG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0fVxuXG5cdFx0Lmxpc3RDb250YWluZXIgLmVtcHR5IHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ji5oaWRlLWN1cnNvciB7XG5cdFx0XHQuc2VsZWN0Q29udGFpbmVyIGlucHV0W3R5cGU9XCJ0ZXh0XCJdIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0Y2FyZXQtY29sb3I6IHRyYW5zcGFyZW50Oztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwic2VuZGVyXCIgYmluZDp0aGlzPXtkbV9zZW5kZXJ9IGNsYXNzOmhpZGUtY3Vyc29yPXtiX2hpZGVfY3Vyc29yfT5cblx0eyNhd2FpdCBsb2FkX2NvbnRhY3RzKCl9XG5cdFx0TG9hZGluZyBjb250YWN0cy4uLlxuXHR7OnRoZW4gYV9jb250YWN0c31cblx0XHQ8U2VsZWN0IGlkPVwicmVjaXBpZW50LXNlbGVjdFwiXG5cdFx0XHRwbGFjZWhvbGRlcj1cIkFkZHJlc3Mgb3IgY29udGFjdFwiXG5cdFx0XHRsaXN0T2Zmc2V0PXsxfVxuXHRcdFx0aXNDbGVhcmFibGU9eyEhYWRkcmVzc31cblx0XHRcdGlzQ3JlYXRhYmxlPXshIXNfYWNjZXB0ZWRfaW5wdXR9XG5cdFx0XHRJdGVtPXtSZWNpcGllbnRTZWxlY3RJdGVtfVxuXHRcdFx0U2VsZWN0aW9uPXtSZWNpcGllbnRTZWxlY3RTZWxlY3Rpb259XG5cdFx0XHRpdGVtcz17YV9jb250YWN0c31cblx0XHRcdHZhbHVlPXtnX2l0ZW1fc2VsZWN0fVxuXHRcdFx0bm9PcHRpb25zTWVzc2FnZT17J1N0b3AgdHlwaW5nIGluIHRoZSBhZGRyZXNzLiBcXG4gVXNlIGNvcHkvcGFzdGUgaW5zdGVhZCEnfVxuXHRcdFx0YmluZDpmaWx0ZXJUZXh0PXtzX21hbnVhbF9pbnB1dH1cblx0XHRcdGJpbmQ6bGlzdE9wZW49e2JfbGlzdF9vcGVufVxuXHRcdFx0b246c2VsZWN0PXtzZWxlY3R9XG5cdFx0XHRvbjpjbGVhcj17Y2xlYXJ9XG5cdFx0XHRjb250YWluZXJDbGFzc2VzPXtlcnJvcj8gJ2ludmFsaWQnOiAnJ31cblx0XHQvPlxuXHR7L2F3YWl0fVxuXG5cbjwhLS0gXG5cdDxzcGFuIGNsYXNzPVwiaWNvblwiIGNsYXNzOnZpc2liaWxpdHlfaGlkZGVuPXshIWFkZHJlc3N9IG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0JHl3X2hlbHAgPSBbXG5cdFx0XHRkZCgnYnInKSxcblx0XHRcdGRkKCdwJywge30sIFtgTm8gUVIgY29kZSBzY2FubmVyIGluIE1WUC4gQnV0IHlvdSBjYW4gdHJ5IGNvcHlpbmcgdGhlIGFkZHJlc3MgdGV4dCBieSB1c2luZyB5b3VyIGRldmljZSdzIGJ1aWx0LWluIGNhbWVyYSBhcHAuYF0pLFxuXHRcdFx0ZGQoJ2JyJyksXG5cdFx0XHRkZCgnYnInKSxcblx0XHRdO1xuXHR9fT5cblx0XHR7QGh0bWwgU1hfSUNPTl9TQ0FOfVxuXHQ8L3NwYW4+IC0tPlxuXG5cdHsjaWYgZXJyb3J9XG5cdFx0PHNwYW4gY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIj5cblx0XHRcdHtlcnJvcn1cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG48L2Rpdj4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNDQ4IDUxMlxcXCI+PCEtLSBGb250IEF3ZXNvbWUgRnJlZSA1LjE1LjQgYnkgQGZvbnRhd2Vzb21lIC0gaHR0cHM6Ly9mb250YXdlc29tZS5jb20gTGljZW5zZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tL2xpY2Vuc2UvZnJlZSAoSWNvbnM6IENDIEJZIDQuMCwgRm9udHM6IFNJTCBPRkwgMS4xLCBDb2RlOiBNSVQgTGljZW5zZSkgLS0+PHBhdGggZD1cXFwiTTY0IDIyNGgxMy41YzI0LjcgNTYuNSA4MC45IDk2IDE0Ni41IDk2czEyMS44LTM5LjUgMTQ2LjUtOTZIMzg0YzguOCAwIDE2LTcuMiAxNi0xNnYtOTZjMC04LjgtNy4yLTE2LTE2LTE2aC0xMy41QzM0NS44IDM5LjUgMjg5LjYgMCAyMjQgMFMxMDIuMiAzOS41IDc3LjUgOTZINjRjLTguOCAwLTE2IDcuMi0xNiAxNnY5NmMwIDguOCA3LjIgMTYgMTYgMTZ6bTQwLTg4YzAtMjIuMSAyMS41LTQwIDQ4LTQwaDE0NGMyNi41IDAgNDggMTcuOSA0OCA0MHYyNGMwIDUzLTQzIDk2LTk2IDk2aC00OGMtNTMgMC05Ni00My05Ni05NnYtMjR6bTcyIDcybDEyLTM2IDM2LTEyLTM2LTEyLTEyLTM2LTEyIDM2LTM2IDEyIDM2IDEyIDEyIDM2em0xNTEuNiAxMTMuNEMyOTcuNyAzNDAuNyAyNjIuMiAzNTIgMjI0IDM1MnMtNzMuNy0xMS4zLTEwMy42LTMwLjZDNTIuOSAzMjguNSAwIDM4NSAwIDQ1NC40djkuNmMwIDI2LjUgMjEuNSA0OCA0OCA0OGg4MHYtNjRjMC0xNy43IDE0LjMtMzIgMzItMzJoMTI4YzE3LjcgMCAzMiAxNC4zIDMyIDMydjY0aDgwYzI2LjUgMCA0OC0yMS41IDQ4LTQ4di05LjZjMC02OS40LTUyLjktMTI1LjktMTIwLjQtMTMzek0yNzIgNDQ4Yy04LjggMC0xNiA3LjItMTYgMTZzNy4yIDE2IDE2IDE2IDE2LTcuMiAxNi0xNi03LjItMTYtMTYtMTZ6bS05NiAwYy04LjggMC0xNiA3LjItMTYgMTZ2NDhoMzJ2LTQ4YzAtOC44LTcuMi0xNi0xNi0xNnpcXFwiLz48L3N2Zz5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cblx0aW1wb3J0IFNYX0lDT05fQVNUUk9OQVVUIGZyb20gJyMvaWNvbi91c2VyLWFzdHJvbmF1dC5zdmc/cmF3Jztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IFRocmVhZElkIH0gZnJvbSAnLi4vZGVmJztcblx0aW1wb3J0IHsgeXdfbmF2aWdhdG9yIH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IHR5cGUgeyBQYWdlIH0gZnJvbSAnLi4vbmF2L3BhZ2UnO1xuXHRpbXBvcnQgeyBTY3JlZW4sIEhlYWRlciB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGV4cG9ydCBsZXQgcmVzZXQgPSBmYWxzZTtcblx0Y29uc3QgYl9yZXNldCA9IHJlc2V0O1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRmdW5jdGlvbiBjb250KCkge1xuXHRcdGlmKGJfcmVzZXQpIHtcblx0XHRcdGtfcGFnZS5yZXNldCgpO1xuXHRcdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKFRocmVhZElkLlRPS0VOUyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0a19wYWdlLnBvcCgpO1xuXHRcdH1cblx0fVxuXHQ8L3NjcmlwdD5cblx0XG5cdDxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcdC5pY29uIHtcblx0XHRcdHBhZGRpbmctdG9wOiAyNSU7XG5cdFx0fVxuXHQ8L3N0eWxlPlxuXHRcblx0PFNjcmVlbj5cblx0XHQ8SGVhZGVyIHBvcHNcblx0XHRcdHRpdGxlPVwiTm90IHlldCBhdmFpbGFibGVcIlxuXHRcdC8+XG5cdFxuXHRcdDxoMz5cblx0XHRcdE5vdGhpbmcgdG8gc2VlIGhlcmUhXG5cdFx0PC9oMz5cblx0XG5cdFx0PHA+XG5cdFx0XHRUaGlzIHNjcmVlbiBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLlxuXHRcdDwvcD5cblx0XG5cdFx0PHA+XG5cdFx0XHRQbGVhc2UgY29udGludWUgZXhwbG9yaW5nIHRoZSBiZXRhLlxuXHRcdDwvcD5cblx0XG5cdFx0PGNlbnRlcj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9BU1RST05BVVR9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9jZW50ZXI+XG5cdFxuXHRcdDxkaXYgY2xhc3M9XCJhY3Rpb24tbGluZVwiPlxuXHRcdFx0PGJ1dHRvbiBjbGFzcz1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gY29udCgpfT5cblx0XHRcdFx0Q29udGludWVcblx0XHRcdDwvYnV0dG9uPlxuXHRcdDwvZGl2PlxuXHQ8L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0LCBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblxuXHRpbXBvcnQge1xuXHRcdHl3X2FjY291bnQsXG5cdFx0eXdfY2hhaW4sXG5cdFx0eXdfY2hhaW5fcmVmLFxuXHRcdHl3X25ldHdvcmtfYWN0aXZlLFxuXHRcdHl3X293bmVyLFxuXHRcdHl3X3NlbmRfYXNzZXQsXG5cdFx0Ly8geXdfYXNzZXRfc2VuZCxcblx0XHQvLyB5d19ob2xkaW5nX3NlbmQsXG5cdH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgU1hfSUNPTl9QRVJTT05BTCBmcm9tICcjL2ljb24vYWNjb3VudF9ib3guc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NPTlRSQUNUIGZyb20gJyMvaWNvbi9hbmFseXRpY3Muc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0xPQURJTkcgZnJvbSAnIy9pY29uL2RvbnV0X2xhcmdlLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9JTkZPIGZyb20gJyMvaWNvbi9pbmZvLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9EUk9QRE9XTiBmcm9tICcjL2ljb24vZHJvcC1kb3duLnN2Zz9yYXcnO1xuXG5cdGltcG9ydCBBc3NldFNlbGVjdCBmcm9tICcjIy91aS9Bc3NldFNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgQW1vdW50SW5wdXQgZnJvbSAnIyMvdWkvQW1vdW50SW5wdXQuc3ZlbHRlJztcblx0aW1wb3J0IENoZWNrYm94RmllbGQgZnJvbSAnIyMvdWkvQ2hlY2tib3hGaWVsZC5zdmVsdGUnO1xuXHRpbXBvcnQgSGVhZGVyIGZyb20gJyMjL3VpL0hlYWRlci5zdmVsdGUnO1xuXHRpbXBvcnQgRmllbGQgZnJvbSAnIyMvdWkvRmllbGQuc3ZlbHRlJztcblxuXHQvLyBpbXBvcnQgRXhlY3V0ZSBmcm9tICcuL0V4ZWN1dGUuc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBBY2NvdW50IH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXG5cdGltcG9ydCB7IFNjcmVlbiwgdHlwZSBQYWdlIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cdGltcG9ydCB0eXBlIHsgVG9rZW4gfSBmcm9tICcjL21ldGEvdG9rZW4nO1xuXHRpbXBvcnQgeyBFbnRpdGllcyB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgU2VuZGVyU2VsZWN0IGZyb20gJy4uL3VpL1NlbmRlclNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgUmVjaXBpZW50U2VsZWN0IGZyb20gJy4uL3VpL1JlY2lwaWVudFNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IENoYWluLCBFbnRpdHlQYXRoLCBOYXRpdmVDb2luIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IHR5cGUgeyBDb250YWN0LCBDb250YWN0UGF0aCB9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHsgc3Vic2NyaWJlX3N0b3JlIH0gZnJvbSAnIy9zdG9yZS9fYmFzZSc7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHsgZm9sZCwgb2ZlIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IENvaW5HZWNrbyB9IGZyb20gJyMvc3RvcmUvd2ViLWFwaXMnO1xuXHRpbXBvcnQgeyBmb3JtYXRfYW1vdW50LCBmb3JtYXRfZmlhdCB9IGZyb20gJyMvdXRpbC9mb3JtYXQnO1xuXHRpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cdGltcG9ydCB7IFhUX01JTlVURVMgfSBmcm9tICcjL3NoYXJlL2NvbnN0YW50cyc7XG5pbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcbmltcG9ydCBEZWFkRW5kIGZyb20gJy4vRGVhZEVuZC5zdmVsdGUnO1xuXG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8qKlxuXHQgKiBXaGljaCBhY2NvdW50IHRvIGluaXRpYXRlIHNlbmQgZnJvbVxuXHQgKi9cblx0ZXhwb3J0IGxldCBzZW5kZXI6IEFjY291bnRbJ2ludGVyZmFjZSddIHwgbnVsbCA9IG51bGw7XG5cdGxldCBnX3NlbmRlciA9IHNlbmRlciB8fCB5d19hY2NvdW50O1xuXG5cdC8qKlxuXHQgKiBOYXRpdmUgY29pbiBzeW1ib2wgdG8gdXNlIGZvciB0aGUgdHJhbnNmZXJcblx0ICovXG5cdGV4cG9ydCBsZXQgbmF0aXZlOiBrZXlvZiB0eXBlb2YgJHl3X2NoYWluLmNvaW5zID0gT2JqZWN0LmtleXMoJHl3X2NoYWluLmNvaW5zKVswXTtcblx0bGV0IHNpX25hdGl2ZSA9IG5hdGl2ZTtcblxuXHQvKipcblx0ICogVG9rZW4gdG8gdXNlIGZvciB0cmFuc2ZlciAoaW5zdGVhZCBvZiBuYXRpdmUgY29pbilcblx0ICovXG5cdGV4cG9ydCBsZXQgdG9rZW46IFRva2VuWydpbnRlcmZhY2UnXSB8IG51bGwgPSBudWxsO1xuXHRsZXQgZ190b2tlbiA9IHRva2VuO1xuXG5cblx0LyoqXG5cdCAqIEFkZHJlc3Mgb2YgaW5pdGlhbCByZWNlaXZlclxuXHQgKi9cblx0ZXhwb3J0IGxldCByZWNpcGllbnQgPSAnJztcblx0bGV0IHNhX3JlY2lwaWVudCA9IHJlY2lwaWVudDtcblxuXG5cdGxldCBwX2Fzc2V0OiBFbnRpdHlQYXRoIHwgJycgPSBzaV9uYXRpdmVcblx0XHQ/IEVudGl0aWVzLmhvbGRpbmdQYXRoRm9yKCR5d19vd25lciwgc2lfbmF0aXZlKVxuXHRcdDogJyc7XG5cdFx0Ly8gOiBFbnRpdGllcy5wYXRoRnJvbShnX3Rva2VuKTtcblxuXG5cdC8vIHJlYWN0aXZlbHkgYXNzaWduIHRoZSBjb2luIHN0cnVjdCBmb3IgdGhlIG5hdGl2ZSBhc3NldFxuXHQkOiBnX2NvaW4gPSBwX2Fzc2V0ICYmICdob2xkaW5nJyA9PT0gRW50aXRpZXMucGFyc2VFbnRpdHlQYXRoKHBfYXNzZXQpPy50eXBlICYmIHNpX25hdGl2ZT8gJHl3X2NoYWluLmNvaW5zPy5bc2lfbmF0aXZlXTogbnVsbDtcblx0XG5cdC8vIHJlYWN0aXZlbHkgYXNzaWduIHRoZSB0b2tlbidzIHBhdGhcblx0JDogcF90b2tlbiA9IHBfYXNzZXQgJiYgJ3Rva2VuJyA9PT0gRW50aXRpZXMucGFyc2VFbnRpdHlQYXRoKHBfYXNzZXQpPy50eXBlICYmIGdfdG9rZW4/IEVudGl0aWVzLnBhdGhGcm9tKGdfdG9rZW4pOiAnJztcblxuXG5cdC8vIGNhY2hlIG9mIGNvbnRhY3RzXG5cdGxldCBoX2NvbnRhY3RzOiBSZWNvcmQ8Q29udGFjdFBhdGgsIENvbnRhY3RbJ2ludGVyZmFjZSddPjtcblxuXHQvLyBhZGRyZXNzIHRvIGNvbnRhY3QgbG9va3VwIGNhY2hlXG5cdGxldCBoX2FkZHJfdG9fY29udGFjdDogUmVjb3JkPENoYWluLkJlY2gzMlN0cmluZywgQ29udGFjdFBhdGg+O1xuXG5cdC8vIGFzc2V0IHN5bWJvbFxuXHQkOiBzX3N5bWJvbCA9IHNpX25hdGl2ZSB8fCBnX3Rva2VuPy5zeW1ib2wgfHwgJyc7XG5cblxuXG5cblx0bGV0IGJfYnVzeV9hZ2VudHMgPSBmYWxzZTtcblx0YXN5bmMgZnVuY3Rpb24gcmVsb2FkX2FnZW50cyhiX2luaXQ9ZmFsc2UpIHtcblx0XHQvLyBhbHJlYWR5IGJ1c3kgcmVsb2FkaW5nXG5cdFx0aWYoYl9idXN5X2FnZW50cykgcmV0dXJuO1xuXG5cdFx0Ly8gbm93IGl0J3MgYnVzeVxuXHRcdGJfYnVzeV9hZ2VudHMgPSB0cnVlO1xuXG5cdFx0Ly8gbG9hZCBhZ2VudHMgc3RvcmVcblx0XHRjb25zdCBrc19hZ2VudHMgPSBhd2FpdCBBZ2VudHMucmVhZCgpO1xuXG5cdFx0Ly8gcmVhZCBjb250YWN0IGVudHJpZXNcblx0XHRjb25zdCBhX2NvbnRhY3RzID0gWy4uLmtzX2FnZW50cy5jb250YWN0cygpXTtcblxuXHRcdC8vIHJlcGxhY2UgY2FjaGVcblx0XHRoX2NvbnRhY3RzID0gb2ZlKGFfY29udGFjdHMpO1xuXG5cdFx0Ly8gcmVwbGFjZSBhZGRyZXNzIGxvb2t1cCBjYWNoZVxuXHRcdGhfYWRkcl90b19jb250YWN0ID0gZm9sZChhX2NvbnRhY3RzLCAoW3BfY29udGFjdCwgZ19jb250YWN0XSkgPT4gKHtcblx0XHRcdFtDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKV06IHBfY29udGFjdCxcblx0XHR9KSk7XG5cblx0XHQvLyBubyBsb25nZXIgYnVzeVxuXHRcdGJfYnVzeV9hZ2VudHMgPSBmYWxzZTtcblx0fVxuXG5cdC8vIHN1YnNjcmlwdGlvbnNcblx0e1xuXHRcdC8vIHJlbG9hZCBhZ2VudHMgd2hlbiBhZ2VudHMgc3RvcmUgdXBkYXRlc1xuXHRcdGNvbnN0IGZfdW5zdWJfYWdlbnRzID0gc3Vic2NyaWJlX3N0b3JlKCdhZ2VudHMnLCByZWxvYWRfYWdlbnRzKTtcblxuXHRcdC8vIHJlbG9hZCBhZ2VudHMgd2hlbiBjaGFpbiBjaGFuZ2VzXG5cdFx0Y29uc3QgZl91bnN1Yl9jaGFpbiA9IHl3X2NoYWluLnN1YnNjcmliZShyZWxvYWRfYWdlbnRzIGFzIFZvaWRGdW5jdGlvbik7XG5cblx0XHQvLyB1bnN1YnNjcmliZSB3aGVuIHNjcmVlbiBpcyBkZXN0cm95ZWRcblx0XHRvbkRlc3Ryb3koKCkgPT4ge1xuXHRcdFx0Zl91bnN1Yl9hZ2VudHMoKTtcblx0XHRcdGZfdW5zdWJfY2hhaW4oKTtcblx0XHR9KTtcblx0fVxuXG5cdCQ6IHtcblx0XHRjb25zb2xlLmxvZyh7XG5cdFx0XHRzaV9uYXRpdmUsXG5cdFx0XHRnX2NvaW4sXG5cdFx0XHRwX2Fzc2V0LFxuXHRcdFx0cF90b2tlbixcblx0XHRcdGdfdG9rZW4sXG5cdFx0fSk7XG5cdH1cblxuXHQvLyByZWFjdGl2ZWx5IGNvbXB1dGUgdGhlIGJhbGFuY2Ugb2YgdGhlIHNlbGVjdGVkIGFzc2V0XG5cdGxldCB5Z19iYWxhbmNlOiBCaWdOdW1iZXIgfCBudWxsID0gbnVsbDtcblx0JDogc19iYWxhbmNlID0geWdfYmFsYW5jZT8gZm9ybWF0X2Ftb3VudCh5Z19iYWxhbmNlLnNoaWZ0ZWRCeSgtKGdfY29pbiB8fCBnX3Rva2VuKSEuZGVjaW1hbHMpLnRvTnVtYmVyKCkpOiAnJztcblx0JDoge1xuXHRcdC8vIHJlYWN0IHRvIGFjY291bnQgYW5kIGFzc2V0IGNoYW5nZXNcblx0XHRpZigkeXdfYWNjb3VudCAmJiBwX2Fzc2V0KSB7XG5cdFx0XHR5Z19iYWxhbmNlID0gbnVsbDtcblxuXHRcdFx0Ly8gZ28gYXN5bmNcblx0XHRcdHF1ZXVlTWljcm90YXNrKGFzeW5jKCkgPT4ge1xuXHRcdFx0XHQvLyBpbmRpY2F0ZSBsb2FkaW5nIHN0YXRlXG5cdFx0XHRcdHNfYmFsYW5jZSA9ICdbLi4uXSc7XG5cblx0XHRcdFx0Ly8gc3RhcnQgd2l0aCB0aGUgY2FjaGVkIGJhbGFuY2UgaWYgaXQgZXhpc3RzXG5cdFx0XHRcdGNvbnN0IGdfY2FjaGVkID0gJHl3X25ldHdvcmtfYWN0aXZlLmNhY2hlZEJhbGFuY2UoJHl3X293bmVyLCBzaV9uYXRpdmUpO1xuXHRcdFx0XHRpZihnX2NhY2hlZCAmJiBnX2NhY2hlZC50aW1lc3RhbXAgPiBEYXRlLm5vdygpIC0gKDUgKiBYVF9NSU5VVEVTKSkge1xuXHRcdFx0XHRcdHlnX2JhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKGdfY2FjaGVkLmRhdGEuYW1vdW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGdldCB0aGUgbGF0ZXN0IGJhbGFuY2Vcblx0XHRcdFx0Y29uc3QgZ19idW5kbGUgPSBhd2FpdCAkeXdfbmV0d29ya19hY3RpdmUuYmFua0JhbGFuY2UoJHl3X293bmVyLCBzaV9uYXRpdmUpO1xuXHRcdFx0XHRpZihnX2J1bmRsZSkge1xuXHRcdFx0XHRcdHlnX2JhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKGdfYnVuZGxlLmJhbGFuY2UuYW1vdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBpbnB1dCBhbW91bnQgdXNlciBpbnRlbmRzIHRvIHNlbmRcblx0bGV0IHNfYW1vdW50ID0gJyc7XG5cblx0Ly8gYXBwbHkgdGhlIG1heGltdW0gYW1vdW50IHRoZSB1c2VyIGNhbiBwb3NzaWJseSBzZW5kXG5cdGZ1bmN0aW9uIHVzZV9tYXgoKSB7XG5cdFx0c19hbW91bnQgPSBzX2JhbGFuY2U7XG5cblx0XHQvLyB0YWtlIGF3YXkgZnJvbSBnYXMgZmVlXG5cdFx0aWYoZ19jb2luKSB7XG5cdFx0XHRzX2Ftb3VudCA9IG5ldyBCaWdOdW1iZXIoc19hbW91bnQpLm1pbnVzKHhfZmVlKS50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdGNfc2hvd192YWxpZGF0aW9ucysrO1xuXHR9XG5cblx0Ly8gcmVhY3RpdmVseSBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBtYXggaXMgY3VycmVudGx5IGJlaW5nIHVzZWRcblx0JDogYl91c2luZ19tYXggPSBzX2Ftb3VudCA9PT0gc19iYWxhbmNlO1xuXG5cdC8vICQ6IHtcblx0Ly8gXHRpZihnX3Rva2VuICYmIEVudGl0aWVzLnBhdGhGcm9tKGdfdG8pICE9PSBwX2VudGl0eSkge1xuXHQvLyBcdFx0c19hbW91bnQgPSAnJztcblx0Ly8gXHRcdGNfc2hvd192YWxpZGF0aW9ucyA9IDA7XG5cdC8vIFx0XHRwX2VudGl0eSA9IGdfdG9rZW4uaXJpO1xuXHQvLyBcdH1cblx0Ly8gfVxuXG5cblxuXHQvLyByZWFjdGl2ZWx5IGFzc2lnbiB0aGUgY29pbmdlY2tvIGlkIGZyb20gdGhlIGFzc2V0IHN0cnVjdFxuXHQkOiBzaV9jb2luZ2Vja28gPSAoZ190b2tlbiB8fCBnX2NvaW4pPy5leHRyYT8uY29pbmdlY2tvX2lkIHx8ICcnO1xuXG5cdC8vIHJlYWN0aXZlbHkgZmV0Y2ggdGhlIHdvcnRoIG9mIHRoZSBhc3NldFxuXHRsZXQgeF93b3J0aDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cdGxldCBzX3dvcnRoID0gJyc7XG5cdGNvbnN0IHNpX3ZlcnN1cyA9ICd1c2QnO1xuXHQkOiB7XG5cdFx0Ly8gY29pbmdlY2tvIGlkIGlzIHNldFxuXHRcdGlmKHNpX2NvaW5nZWNrbykge1xuXHRcdFx0Ly8gaW5kaWNhdGUgbG9hZGluZyBzdGF0ZVxuXHRcdFx0c193b3J0aCA9ICdbLi4uXSc7XG5cblx0XHRcdC8vIGdvIGFzeW5jXG5cdFx0XHQoYXN5bmMoKSA9PiB7XG5cdFx0XHRcdC8vIGxvYWQgdGhlIGFzc2V0J3Mgd29ydGggZnJvbSBjb2luZ2Vja29cblx0XHRcdFx0Y29uc3QgaF92ZXJzdXMgPSBhd2FpdCBDb2luR2Vja28uY29pbnNWZXJzdXMoW3NpX2NvaW5nZWNrb10gYXMgc3RyaW5nW10sIHNpX3ZlcnN1cyk7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBmaWF0IGRpc3BsYXlcblx0XHRcdFx0eF93b3J0aCA9IGhfdmVyc3VzW3NpX2NvaW5nZWNrb107XG5cdFx0XHRcdGlmKCdudW1iZXInID09PSB0eXBlb2YgeF93b3J0aCkge1xuXHRcdFx0XHRcdHNfd29ydGggPSBmb3JtYXRfZmlhdCh4X3dvcnRoLCBzaV92ZXJzdXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNldCBlcnJvciBpbmRpY2F0aW9uXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHNfd29ydGggPSAnKD8pJztcblx0XHRcdFx0fVxuXHRcdFx0fSkoKTtcblx0XHR9XG5cdFx0Ly8gZG9uJ3QgZGlzcGxheSBhbnl0aGluZ1xuXHRcdGVsc2Uge1xuXHRcdFx0c193b3J0aCA9ICcnO1xuXHRcdH1cblx0fVxuXG5cblx0bGV0IHhfZmVlID0gMC4wMTtcblx0XG5cdCQ6IHNfZmVlX2ZpYXQgPSAnbnVtYmVyJyA9PT0gdHlwZW9mIHhfd29ydGg/IGZvcm1hdF9maWF0KHhfZmVlICogeF93b3J0aCwgJ3VzZCcpOiAnJztcblxuXHRcblx0XG5cdC8vIC8vIFxuXHQvLyBpZigkeXdfYXNzZXRfc2VuZCkge1xuXHQvLyBcdCR5d19jaGFpbl9yZWYgPSAkeXdfYXNzZXRfc2VuZC5jaGFpblJlZjtcblx0Ly8gfVxuXG5cdGNvbnN0IEhfQUREUkVTU19UWVBFUyA9IHtcblx0XHRub25lOiB7XG5cdFx0XHRpY29uOiAnPHN2Zz48L3N2Zz4nLFxuXHRcdFx0dGV4dDogJycsXG5cdFx0fSxcblxuXHRcdHVua25vd246IHtcblx0XHRcdGljb246IFNYX0lDT05fTE9BRElORyxcblx0XHRcdHRleHQ6ICdEZXRlcm1pbmluZyBhZGRyZXNzIHR5cGUuLi4nLFxuXHRcdH0sXG5cblx0XHRwZXJzb25hbDoge1xuXHRcdFx0aWNvbjogU1hfSUNPTl9QRVJTT05BTCxcblx0XHRcdHRleHQ6ICdQZXJzb25hbCBhZGRyZXNzJyxcblx0XHR9LFxuXG5cdFx0Y29udHJhY3Q6IHtcblx0XHRcdGljb246IFNYX0lDT05fQ09OVFJBQ1QsXG5cdFx0XHR0ZXh0OiAnQ29udHJhY3QgYWRkcmVzcycsXG5cdFx0fSxcblx0fSBhcyBjb25zdDtcblxuXHRsZXQgc2lfYWRkcmVzc190eXBlOiBrZXlvZiB0eXBlb2YgSF9BRERSRVNTX1RZUEVTID0gJ25vbmUnO1xuXHQkOiBnX2FkZHJlc3NfdHlwZSA9IEhfQUREUkVTU19UWVBFU1tzaV9hZGRyZXNzX3R5cGVdO1xuXG5cblxuXHQkOiB7XG5cdFx0aWYoIXNhX3JlY2lwaWVudCkge1xuXHRcdFx0c2lfYWRkcmVzc190eXBlID0gJ25vbmUnO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHNpX2FkZHJlc3NfdHlwZSA9ICd1bmtub3duJztcblxuXHRcdFx0KGFzeW5jKCkgPT4ge1xuXHRcdFx0XHRpZihhd2FpdCAkeXdfbmV0d29ya19hY3RpdmUuaXNDb250cmFjdChzYV9yZWNpcGllbnQpKSB7XG5cdFx0XHRcdFx0c2lfYWRkcmVzc190eXBlID0gJ2NvbnRyYWN0Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzaV9hZGRyZXNzX3R5cGUgPSAncGVyc29uYWwnO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSgpO1xuXHRcdH1cblx0fVxuXG5cblxuXG5cdGxldCBiX21lbW9fZXhwYW5kZWQgPSBmYWxzZTtcblx0bGV0IHNfbWVtbyA9ICcnO1xuXG5cdGxldCBiX3N1Ym1pdHRlZCA9IGZhbHNlO1xuXG5cdC8vIGZ1bmN0aW9uIHN1Ym1pdCgpIHtcblx0Ly8gXHRpZighYl9mb3JtX3ZhbGlkKSB7XG5cdC8vIFx0XHRjX3Nob3dfdmFsaWRhdGlvbnMrKztcblx0Ly8gXHRcdHJldHVybjtcblx0Ly8gXHR9XG5cdC8vIFx0ZWxzZSB7XG5cdC8vIFx0XHRpZihiX3N1Ym1pdHRlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdC8vIFx0XHRiX3N1Ym1pdHRlZCA9IHRydWU7XG5cblx0Ly8gXHRcdGlmKCR5d19hc3NldF9zZW5kIS5uYXRpdmUpIHtcblx0Ly8gXHRcdFx0Ly8gcHVzaF9zY3JlZW4oU2VuZE5hdGl2ZSwge30pO1xuXHQvLyBcdFx0fVxuXHQvLyBcdFx0ZWxzZSB7XG5cdC8vIFx0XHRcdGtfcGFnZS5wdXN5d19zZW5kX2Fzc2V0XG5cdC8vIFx0XHRcdFx0Y3JlYXRvcjogRXhlY3V0ZSxcblx0Ly8gXHRcdFx0XHRwcm9wczoge1xuXHQvLyBcdFx0XHRcdFx0Y29udHJhY3Q6ICR5d19hc3NldF9zZW5kPy5hZGRyZXNzLFxuXHQvLyBcdFx0XHRcdFx0c25pcDIwOiB5d19zZW5kX2Fzc2V0XG5cdC8vIFx0XHRcdFx0XHRcdHRyYW5zZmVyOiB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0cmVjaXBpZW50OiBzYV9yZWNlaXZlcixcblx0Ly8gXHRcdFx0XHRcdFx0XHRhbW91bnQ6ICR5d19hc3NldF9zZW5kPy5kZW5vbUZyb21TdHJpbmcoc19hbW91bnQpIHx8ICcwJyxcblx0Ly8gXHRcdFx0XHRcdFx0fSxcblx0Ly8gXHRcdFx0XHRcdH0sXG5cdC8vIFx0XHRcdFx0fSxcblx0Ly8gXHRcdFx0fSk7XG5cdC8vIFx0XHR9XG5cdC8vIFx0fVxuXHQvLyB9XG5cblx0bGV0IGNfc2hvd192YWxpZGF0aW9ucyA9IDA7XG5cblx0bGV0IGJfY2hlY2tlZF9zYXZlX2NvbnRhY3QgPSBmYWxzZTtcblx0bGV0IGJfZGVhZCA9IGZhbHNlO1xuXG5cblx0bGV0IHNfZXJyX3JlY2lwaWVudCA9ICcnO1xuXHRsZXQgc19lcnJfYW1vdW50ID0gJyc7XG5cblx0JDogYl9uZXdfYWRkcmVzcyA9IHNhX3JlY2lwaWVudCAmJiBoX2FkZHJfdG9fY29udGFjdCAmJiAhKHNhX3JlY2lwaWVudCBpbiBoX2FkZHJfdG9fY29udGFjdCk7XG5cblxuXHRjb25zdCBSX0NPTlRBQ1RfTkFNRSA9IC9eXFxTLnswLDEwMjN9JC87XG5cdFxuXHRsZXQgc19uZXdfY29udGFjdCA9ICcnO1xuXHQkOiBzX2Vycl9uZXdfY29udGFjdCA9IGJfY2hlY2tlZF9zYXZlX2NvbnRhY3QgJiYgKGNfc2hvd192YWxpZGF0aW9ucyB8fCB0cnVlKVxuXHRcdD8gc19uZXdfY29udGFjdFxuXHRcdFx0PyBSX0NPTlRBQ1RfTkFNRS50ZXN0KHNfbmV3X2NvbnRhY3QpXG5cdFx0XHRcdD8gJydcblx0XHRcdFx0OiBzX25ld19jb250YWN0Lmxlbmd0aCA+IDEwMjRcblx0XHRcdFx0XHQ/ICdUaGF0IG5hbWUgaXMgd2F5IHRvbyBsb25nJ1xuXHRcdFx0XHRcdDogJ0Nhbm5vdCBiZWdpbiB3aXRoIHNwYWNlJ1xuXHRcdFx0OiAnRW50ZXIgYSBjb250YWN0IG5hbWUgdG8gc2F2ZSBuZXcgYWRkcmVzcydcblx0XHQ6ICcnO1xuXG5cdCQ6IHtcblx0XHRpZihiX2NoZWNrZWRfc2F2ZV9jb250YWN0ICYmICFjX3Nob3dfdmFsaWRhdGlvbnMpIHtcblx0XHRcdHNfZXJyX25ld19jb250YWN0ID0gJyc7XG5cdFx0fVxuXHR9XG5cblx0JDogYl9mb3JtX3ZhbGlkID0gKHNhX3JlY2lwaWVudFxuXHRcdCYmIHNfYW1vdW50XG5cdFx0JiYgIXNfZXJyX3JlY2lwaWVudFxuXHRcdCYmICFzX2Vycl9hbW91bnRcblx0XHQmJiAoIWJfbmV3X2FkZHJlc3MgfHwgIWJfY2hlY2tlZF9zYXZlX2NvbnRhY3QgfHwgKHNfbmV3X2NvbnRhY3QgJiYgIXNfZXJyX25ld19jb250YWN0KSlcblx0KSB8fCBmYWxzZTtcblxuXHQkOiB7XG5cdFx0Y29uc29sZS5sb2coe1xuXHRcdFx0dG86IHNhX3JlY2lwaWVudCxcblx0XHRcdHNfYW1vdW50LFxuXHRcdFx0c19lcnJfcmVjaXBpZW50LFxuXHRcdFx0c19lcnJfYW1vdW50LFxuXHRcdH0pO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBpbnB1dF9uZXdfY29udGFjdChkX2V2ZW50OiBFdmVudCkge1xuXHRcdHNfbmV3X2NvbnRhY3QgPSAoZF9ldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblxuXHRAa2V5ZnJhbWVzIHNwaW4ge1xuXHRcdGZyb20ge1xuXHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdFx0fVxuXHRcdHRvIHtcblx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG5cdFx0fVxuXHR9XG5cblx0I2ZpZWxkLXJlY2lwaWVudC1zdGF0dXMge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0bWFyZ2luLXRvcDogLTEycHg7XG5cdFx0XHRwYWRkaW5nLWxlZnQ6IDZweDtcblx0XHR9XG5cblx0XHQuc3RhdHVzIHtcblx0XHRcdDpnbG9iYWwoJi51bmtub3duPi5pY29uKSB7XG5cdFx0XHRcdGFuaW1hdGlvbjogc3BpbiAxcyBsaW5lYXIgaW5maW5pdGU7XG5cdFx0XHR9XG5cdFx0XHQ6Z2xvYmFsKCYuY29udHJhY3Q+Lmljb24pIHtcblx0XHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xuXHRcdFx0fVxuXHRcdFx0Omdsb2JhbCgmLmNvbnRyYWN0Pi5pY29uKSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQuc3RhdHVzIHtcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItZ3JheW1lZCk7XG5cblx0XHQ+KiB7XG5cdFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdH1cblxuXHRcdD4uaWNvbiB7XG5cdFx0XHQtLXByb3h5LWljb24tZGlhbWV0ZXI6IDIwcHg7XG5cdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWdyYXltZWQpO1xuXG5cdFx0XHQ6Z2xvYmFsKHN2Zykge1xuXHRcdFx0XHR3aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdGhlaWdodDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pi50ZXh0IHtcblx0XHRcdC5mb250KHRpbnkpO1xuXHRcdH1cblx0fVxuXG5cblx0I2ZpZWxkLWJhbGFuY2Uge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0bWFyZ2luLXRvcDogLTEycHg7XG5cdFx0fVxuXHR9XG5cblx0LmJhbGFuY2UtbGluZSB7XG5cdFx0LmZvbnQodGlueSwgQHNpemU6IDEycHgsIEB3ZWlnaHQ6IDMwMCk7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cblx0XHQ+LmJhbGFuY2Uge1xuXHRcdFx0Pi5sYWJlbCB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHR9XG5cblx0XHRcdD4uYW1vdW50IHtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC5mZWUtZmlhdCB7XG5cdFx0LmZvbnQodGlueSk7XG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0fVxuXG5cdCNmaWVsZC1mZWUge1xuXHRcdC5maWVsZC12YWx1ZSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZmxleDogMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQubWFudWFsLWZlZSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZmxleDogMjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQjZmllbGQtbWFudWFsLWZlZSB7XG5cdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRtYXJnaW4tdG9wOiAtMTJweDtcblx0XHR9XG5cdH1cblxuXHQubWFudWFsLWZlZSB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGdhcDogMC41ZW07XG5cblx0XHQ+Lmljb24uaW5mbyB7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDE4cHg7XG5cdFx0XHRwYWRkaW5nOiAycHg7XG5cdFx0fVxuXHR9XG5cblx0Lm1lbW8ge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRnYXA6IDAuNzVlbTtcblxuXHRcdC50aXRsZSB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0Z2FwOiA0cHg7XG5cdFx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0XHRcdC5pY29uIHtcblx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyMnB4O1xuXHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0fVxuXHRcblx0XHRcdD4uZGlzY2xhaW1lciB7XG5cdFx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItY2F1dGlvbik7XG5cdFx0XHRcdHJpZ2h0OiAwO1xuXHRcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdGJvdHRvbTogMC41ZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmRyb3Bkb3duLmljb24ge1xuXHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMzAwbXMgdmFyKC0tZWFzZS1vdXQtcXVhZCk7XG5cdFx0fVxuXG5cdFx0Ji5leHBhbmRlZCB7XG5cdFx0XHQuZHJvcGRvd24uaWNvbiB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKC0xODBkZWcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC5uZXctYWRkcmVzcyB7XG5cdFx0bWFyZ2luLXRvcDogMTJweDtcblx0fVxuXG5cdC5kaXNhYmxlZC5saW5rIHtcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdGZvbnQtc3R5bGU6IGl0YWxpYztcblx0XHR0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcblx0fVxuPC9zdHlsZT5cblxuXG48U2NyZWVuIGZvcm0gc2xpZGVzIG9uOnN1Ym1pdD17KGRfc3VibWl0KSA9PiB7XG5cdGRfc3VibWl0LnByZXZlbnREZWZhdWx0KCk7XG59fT5cblx0PEhlYWRlciBwb3BzXG5cdFx0dGl0bGU9e2dfdG9rZW4/ICdUcmFuc2ZlcnJpbmcnOiAnU2VuZGluZyd9XG5cdFx0c3ltYm9sPXtnX3Rva2VuPyBnX3Rva2VuLnN5bWJvbDogJyd9XG5cdFx0c3VidGl0bGU9eyR5d19jaGFpbj8ubmFtZSB8fCAnPyd9XG5cdC8+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdzZW5kZXItc2VsZWN0J1xuXHRcdG5hbWU9J0Zyb20nXG5cdD5cblx0XHQ8U2VuZGVyU2VsZWN0IC8+XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdyZWNpcGllbnQtc2VsZWN0J1xuXHRcdG5hbWU9J1RvJ1xuXHQ+XG5cdFx0PFJlY2lwaWVudFNlbGVjdFxuXHRcdFx0YmluZDplcnJvcj17c19lcnJfcmVjaXBpZW50fVxuXHRcdFx0YmluZDphZGRyZXNzPXtzYV9yZWNpcGllbnR9XG5cdFx0XHRzaG93VmFsaWRhdGlvbj17Y19zaG93X3ZhbGlkYXRpb25zfVxuXHRcdC8+XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdyZWNpcGllbnQtc3RhdHVzJ1xuXHRcdG5hbWU9Jydcblx0PlxuXHRcdDxzcGFuIGNsYXNzPVwic3RhdHVzIHtzaV9hZGRyZXNzX3R5cGV9XCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0e0BodG1sIGdfYWRkcmVzc190eXBlLmljb259XG5cdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0e2dfYWRkcmVzc190eXBlLnRleHR9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9zcGFuPlxuXG5cdFx0eyNpZiBiX25ld19hZGRyZXNzfVxuXHRcdFx0PGRpdiBjbGFzcz1cIm5ldy1hZGRyZXNzXCI+XG5cdFx0XHRcdDxDaGVja2JveEZpZWxkIGlkPVwic2F2ZS1jb250YWN0XCIgYmluZDpjaGVja2VkPXtiX2NoZWNrZWRfc2F2ZV9jb250YWN0fSA+XG5cdFx0XHRcdFx0U2F2ZSB0byBjb250YWN0c1xuXHRcdFx0XHQ8L0NoZWNrYm94RmllbGQ+XG5cdFx0XHQ8L2Rpdj5cblx0XHR7L2lmfVxuXHQ8L0ZpZWxkPlxuXG5cdHsjaWYgYl9uZXdfYWRkcmVzcyAmJiBiX2NoZWNrZWRfc2F2ZV9jb250YWN0fVxuXHRcdDxGaWVsZCBzaG9ydCBzbGlkZXNcblx0XHRcdGtleT0nbmV3LWNvbnRhY3QtbmFtZSdcblx0XHRcdG5hbWU9J0NvbnRhY3QgTmFtZSdcblx0XHQ+XG5cdFx0XHQ8aW5wdXQgaWQ9XCJuZXctY29udGFjdC1uYW1lLXZhbHVlXCIgdHlwZT1cInRleHRcIiBvbjppbnB1dD17aW5wdXRfbmV3X2NvbnRhY3R9IGNsYXNzOmludmFsaWQ9e3NfZXJyX25ld19jb250YWN0fT5cblxuXHRcdFx0eyNpZiBzX2Vycl9uZXdfY29udGFjdH1cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIj5cblx0XHRcdFx0XHR7c19lcnJfbmV3X2NvbnRhY3R9XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdHsvaWZ9XG5cdFx0PC9GaWVsZD5cblx0ey9pZn1cblxuXHQ8aHI+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdhc3NldC1zZWxlY3QnXG5cdFx0bmFtZT0nQXNzZXQnXG5cdD5cblx0XHQ8QXNzZXRTZWxlY3QgYmluZDphc3NldFJlZj17cF9hc3NldH0gLz5cblx0PC9GaWVsZD5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2Ftb3VudCdcblx0XHRuYW1lPSdBbW91bnQnXG5cdD5cblx0XHQ8QW1vdW50SW5wdXRcblx0XHRcdGJ1ZmZlck1heD17Z19jb2luPyB4X2ZlZTogMH1cblx0XHRcdGFzc2V0UmVmPXtwX2Fzc2V0fVxuXHRcdFx0YmluZDplcnJvcj17c19lcnJfYW1vdW50fVxuXHRcdFx0YmluZDp2YWx1ZT17c19hbW91bnR9XG5cdFx0XHRzaG93VmFsaWRhdGlvbj17Y19zaG93X3ZhbGlkYXRpb25zfVxuXHRcdC8+XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdiYWxhbmNlJ1xuXHRcdG5hbWU9Jydcblx0PlxuXHRcdDxzcGFuIGNsYXNzPVwiYmFsYW5jZS1saW5lXCI+XG5cdFx0XHR7I2lmIHBfYXNzZXR9XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiYmFsYW5jZVwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibGFiZWxcIj5cblx0XHRcdFx0XHRcdEJhbGFuY2Vcblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJhbW91bnRcIj5cblx0XHRcdFx0XHRcdHtzX2JhbGFuY2V9IHtzX3N5bWJvbH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cInVzZS1tYXhcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImxpbmtcIiBjbGFzczpkaXNhYmxlZD17Yl91c2luZ19tYXh9IG9uOmNsaWNrPXsoKSA9PiB1c2VfbWF4KCl9PlVTRSBNQVg8L3NwYW4+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdHsvaWZ9XG5cdFx0PC9zcGFuPlxuXHQ8L0ZpZWxkPlxuXG5cdDxocj5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2ZlZSdcblx0XHRuYW1lPSdGZWUnXG5cdD5cblx0XHQ8ZGl2IGNsYXNzPVwiZmVlLWFtb3VudFwiPlxuXHRcdFx0e3hfZmVlfSBTQ1JUXG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwiZmVlLWZpYXRcIj5cblx0XHRcdHtzX2ZlZV9maWF0fVxuXHRcdDwvZGl2PlxuXG5cdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicG9zdFwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cIm1hbnVhbC1mZWVcIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsaW5rIGRpc2FibGVkXCI+U2V0IGZlZSBtYW51YWxseTwvc3Bhbj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGluZm9cIj5cblx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9JTkZPfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0PC9GaWVsZD5cblxuXHQ8aHI+XG5cblx0PGRpdiBjbGFzcz1cIm1lbW9cIiBjbGFzczpleHBhbmRlZD17Yl9tZW1vX2V4cGFuZGVkfT5cblx0XHQ8ZGl2IGNsYXNzPVwidGl0bGUgY2xpY2thYmxlXCIgb246Y2xpY2s9eygpID0+IGJfbWVtb19leHBhbmRlZCA9ICFiX21lbW9fZXhwYW5kZWR9PlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGRyb3Bkb3duXCI+XG5cdFx0XHRcdHtAaHRtbCBTWF9JQ09OX0RST1BET1dOfVxuXHRcdFx0PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdEFkZCBtZW1vXG5cdFx0XHQ8L3NwYW4+XG5cblx0XHRcdHsjaWYgYl9tZW1vX2V4cGFuZGVkfVxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImRpc2NsYWltZXJcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzUwLCBkZWxheTo0MDB9fT5cblx0XHRcdFx0XHRDYXV0aW9uOiBNZW1vcyBhcmUgTk9UIHByaXZhdGVcblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0ey9pZn1cblx0XHQ8L2Rpdj5cblxuXHRcdHsjaWYgYl9tZW1vX2V4cGFuZGVkfVxuXHRcdFx0PGRpdiBjbGFzcz1cImlucHV0XCIgdHJhbnNpdGlvbjpzbGlkZT17e2R1cmF0aW9uOjM1MH19PlxuXHRcdFx0XHQ8dGV4dGFyZWEgYmluZDp2YWx1ZT17c19tZW1vfT48L3RleHRhcmVhPlxuXHRcdFx0PC9kaXY+XG5cdFx0ey9pZn1cblx0PC9kaXY+XG5cblx0PEFjdGlvbnNMaW5lIGNhbmNlbD0ncG9wJyBjb25maXJtPXtbJ05leHQnLCAoKSA9PiBrX3BhZ2UucHVzaCh7XG5cdFx0Y3JlYXRvcjogRGVhZEVuZCxcblx0XHRwcm9wczoge30sXG5cdH0pLCAhYl9mb3JtX3ZhbGlkXX0gLz5cblxuPCEtLSBcblx0PGRpdiBjbGFzcz1cImFjdGlvbi1saW5lXCIgY2xhc3M6cG9pbnRlci1ldmVudHNfbm9uZT17Yl9kZWFkfT5cblx0XHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17KCkgPT4gKChiX2RlYWQgPSB0cnVlKSAmJiBrX3BhZ2UucG9wKCkpfT5cblx0XHRcdENhbmNlbFxuXHRcdDwvYnV0dG9uPiAtLT5cbjwhLS0gXG5cdFx0PGJ1dHRvbiBjbGFzcz1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gc3VibWl0KCl9IHJlYWRvbmx5PXshYl9mb3JtX3ZhbGlkfT5cblx0XHRcdE5leHRcblx0XHQ8L2J1dHRvbj4gLS0+XG5cdDwhLS0gPC9kaXY+IC0tPlxuPC9TY3JlZW4+IiwiPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5nYXAge1xuXHRcdGhlaWdodDogOHB4O1xuXHRcdGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xuXHRcdG1hcmdpbi1ib3R0b206IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiZ2FwIG5vLW1hcmdpblwiPiZuYnNwOzwvZGl2PiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiIGxhbmc9XCJ0c1wiPlxuXHRleHBvcnQgaW50ZXJmYWNlIFBpbGxJdGVtPHdfZGF0YSBleHRlbmRzIGFueT1hbnk+IHtcblx0XHRpZDogc3RyaW5nO1xuXHRcdHBmcFBhdGg6IFBmcFBhdGg7XG5cdFx0bmFtZTogc3RyaW5nO1xuXHRcdGRhdGE6IHdfZGF0YTtcblx0XHRjb2xvcj86IHN0cmluZztcblx0fVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7XG5cdFx0Y3ViaWNPdXQsXG5cdH0gZnJvbSAnc3ZlbHRlL2Vhc2luZyc7XG5cblx0aW1wb3J0IHR5cGUge1xuXHRcdFNsaWRlUGFyYW1zLFxuXHRcdFRyYW5zaXRpb25Db25maWcsXG5cdH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXG5cdGltcG9ydCBTWF9JQ09OX0FERCBmcm9tICcjL2ljb24vYWRkLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9FRElUIGZyb20gJyMvaWNvbi9lZGl0LXNtYWxsLnN2Zz9yYXcnO1xuXG5cdGltcG9ydCBQZnBEaXNwbGF5IGZyb20gJy4vUGZwRGlzcGxheS5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IFBmcFBhdGggfSBmcm9tICcjL21ldGEvcGZwJztcblxuXHQvKipcblx0ICogTGlzdCBvZiBpdGVtcyBiZWluZyBkaXNwbGF5ZWRcblx0ICovXG5cdGV4cG9ydCBsZXQgaXRlbXM6IFBpbGxJdGVtW107XG5cblx0Ly8gLyoqXG5cdC8vICAqIFBhdGggdG8gdGhlIHJlc291cmNlIHRvIGZldGNoIHRhZ3MgZm9yXG5cdC8vICAqL1xuXHQvLyBleHBvcnQgbGV0IHJlc291cmNlUGF0aDogc3RyaW5nO1xuXHQvLyBjb25zdCBwX3Jlc291cmNlID0gcmVzb3VyY2VQYXRoO1xuXG5cdC8qKlxuXHQgKiBFbmFibGVzIGVkaXR0aW5nIHRoZSB0YWdzIGhlcmVcblx0ICovXG5cdGV4cG9ydCBsZXQgZWRpdGFibGUgPSBmYWxzZTtcblx0Y29uc3QgYl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIGRpc3BsYXlzIHRoZSB0YWdzIGluIGNvbGxhcHNlZCBmb3JtXG5cdCAqL1xuXHRleHBvcnQgbGV0IGNvbGxhcHNlZCA9IGZhbHNlO1xuXHRjb25zdCBiX2NvbGxhcHNlZCA9IGNvbGxhcHNlZDtcblxuXHRleHBvcnQgbGV0IHByZWZpeENsYXNzID0gJyc7XG5cdGV4cG9ydCBsZXQgc3VmZml4Q2xhc3MgPSAnJztcblxuXHRleHBvcnQgbGV0IHJvb3RTdHlsZSA9ICcnO1xuXG5cdC8vIHN1YnNjcmliZSB0byB0YWcgc3RvcmUgY2hhbmdlcyBhbmQgcmVsb2FkXG5cdGxldCBjX3JlbG9hZF9pdGVtcyA9IDA7XG5cdC8vIGNvbnN0IGZfdW5zdWJzY3JpYmUgPSB5d19zdG9yZV90YWdzLnN1YnNjcmliZSgoKSA9PiBjX3JlbG9hZF9pdGVtcysrKTtcblx0Ly8gb25EZXN0cm95KCgpID0+IHtcblx0Ly8gXHRmX3Vuc3Vic2NyaWJlKCk7XG5cdC8vIH0pO1xuXG5cdC8vIGlmKGJfZWRpdGFibGUpIHtcblx0Ly8gXHR5d19jb250ZXh0X3BvcHVwLnN1YnNjcmliZSgoZ19jdHg6IERpY3Q8YW55PiB8IG51bGwpID0+IHtcblx0Ly8gXHRcdGlmKGdfY3R4Py50YWdzKSB7XG5cdC8vIFx0XHRcdGFfdGFncyA9IGdfY3R4LnRhZ3M7XG5cdC8vIFx0XHR9XG5cdC8vIFx0fSk7XG5cblx0Ly8gXHRvbkRlc3Ryb3koKCkgPT4ge1xuXHQvLyBcdFx0JHl3X2NvbnRleHRfcG9wdXA9IG51bGw7XG5cdC8vIFx0fSk7XG5cdC8vIH1cblxuXHRsZXQgZG1fY2x1c3RlcjogSFRNTEVsZW1lbnQ7XG5cblx0ZnVuY3Rpb24gcmVtb3ZlX2l0ZW0oZ19pdGVtOiBQaWxsSXRlbSkge1xuXHRcdC8vIGZpbmQgaXRlbSBieSBpZFxuXHRcdGNvbnN0IGlfaXRlbSA9IGl0ZW1zLmZpbmRJbmRleChnID0+IGcuaWQgPT09IGdfaXRlbS5pZCk7XG5cblx0XHQvLyByZW1vdmUgaXQgZnJvbSB0aGUgbXV0YWJsZSBsaXN0XG5cdFx0aXRlbXMuc3BsaWNlKGlfaXRlbSwgMSk7XG5cblx0XHQvLyByZWFjdGl2ZWx5IHJlbG9hZFxuXHRcdGl0ZW1zID0gaXRlbXM7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHNzbGlkZShkbV9ub2RlOiBFbGVtZW50LCB7XG5cdFx0ZGVsYXk6IHh0X2RlbGF5ID0gMCxcblx0XHRkdXJhdGlvbjogeHRfZHVyYXRpb24gPSA0MDAsXG5cdFx0ZWFzaW5nOiBmX2Vhc2luZyA9IGN1YmljT3V0LFxuXHR9OiBTbGlkZVBhcmFtcyA9IHt9KTogVHJhbnNpdGlvbkNvbmZpZyB7XG5cdFx0Y29uc3QgZF9zdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG1fbm9kZSk7XG5cdFx0Y29uc3QgeF9vcGFjaXR5ID0gK2Rfc3R5bGUub3BhY2l0eTtcblx0XHRjb25zdCB4X3dpZHRoID0gcGFyc2VGbG9hdChkX3N0eWxlLndpZHRoKTtcblx0XHRjb25zdCB4X3BhZGRpbmdfbGVmdCA9IHBhcnNlRmxvYXQoZF9zdHlsZS5wYWRkaW5nTGVmdCk7XG5cdFx0Y29uc3QgeF9wYWRkaW5nX3JpZ2h0ID0gcGFyc2VGbG9hdChkX3N0eWxlLnBhZGRpbmdSaWdodCk7XG5cdFx0Y29uc3QgeF9tYXJnaW5fbGVmdCA9IHBhcnNlRmxvYXQoZF9zdHlsZS5tYXJnaW5MZWZ0KTtcblx0XHRjb25zdCB4X21hcmdpbl9yaWdodCA9IHBhcnNlRmxvYXQoZF9zdHlsZS5tYXJnaW5SaWdodCk7XG5cdFx0Y29uc3QgeF9ib3JkZXJfbGVmdF93aWR0aCA9IHBhcnNlRmxvYXQoZF9zdHlsZS5ib3JkZXJMZWZ0V2lkdGgpO1xuXHRcdGNvbnN0IHhfYm9yZGVyX3JpZ2h0X3dpZHRoID0gcGFyc2VGbG9hdChkX3N0eWxlLmJvcmRlclJpZ2h0V2lkdGgpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGRlbGF5OiB4dF9kZWxheSxcblx0XHRcdGR1cmF0aW9uOiB4dF9kdXJhdGlvbixcblx0XHRcdGVhc2luZzogZl9lYXNpbmcsXG5cdFx0XHRjc3M6IHh0ID0+XG5cdFx0XHRcdCctLWRlbGV0ZS1kaXNwbGF5OiBub25lOycgK1xuXHRcdFx0XHQnb3ZlcmZsb3c6IGhpZGRlbjsnICtcblx0XHRcdFx0YG9wYWNpdHk6ICR7TWF0aC5taW4oeHQgKiAyMCwgMSkgKiB4X29wYWNpdHl9O2AgK1xuXHRcdFx0XHRgd2lkdGg6ICR7eHQgKiB4X3dpZHRofXB4O2AgK1xuXHRcdFx0XHRgcGFkZGluZy1sZWZ0OiAke3h0ICogeF9wYWRkaW5nX2xlZnR9cHg7YCArXG5cdFx0XHRcdGBwYWRkaW5nLXJpZ2h0OiAke3h0ICogeF9wYWRkaW5nX3JpZ2h0fXB4O2AgK1xuXHRcdFx0XHRgbWFyZ2luLWxlZnQ6ICR7eHQgKiB4X21hcmdpbl9sZWZ0fXB4O2AgK1xuXHRcdFx0XHRgbWFyZ2luLXJpZ2h0OiAke3h0ICogeF9tYXJnaW5fcmlnaHR9cHg7YCArXG5cdFx0XHRcdGBib3JkZXItbGVmdC13aWR0aDogJHt4dCAqIHhfYm9yZGVyX2xlZnRfd2lkdGh9cHg7YCArXG5cdFx0XHRcdGBib3JkZXItcmlnaHQtd2lkdGg6ICR7eHQgKiB4X2JvcmRlcl9yaWdodF93aWR0aH1weDtgXG5cdFx0fTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdC5jbHVzdGVyIHtcblx0XHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0Z2FwOiA0cHg7XG5cdFx0ZmxleC1mbG93OiByb3cgd3JhcDtcblx0XHRcblx0XHQmLmNvbGxhcHNlZCB7XG5cdFx0XHRtYXJnaW46IHZhcigtLXRhZy1jbHVzdGVyLW1hcmdpbiwgMCk7XG5cdFx0XHRtYXJnaW4tdG9wOiA1cHg7XG5cdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdH1cblxuXHRcdCYuZWRpdGFibGUge1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuXHRcdFx0Ly8gbWFyZ2luOiB2YXIoLS10YWctY2x1c3Rlci1tYXJnaW4sIDAgdmFyKC0tdWktcGFkZGluZykpO1xuXG5cdFx0XHQ+Lml0ZW0ge1xuXHRcdFx0XHRwYWRkaW5nLXJpZ2h0OiAycHg7XG5cdFx0XHR9XG5cblx0XHRcdCBtYXJnaW4tdG9wOi0xMHB4O1xuXHRcdFx0IG1hcmdpbi1ib3R0b206NXB4O1xuXHRcdH1cblxuXHRcdD4uaXRlbSB7XG5cdFx0XHQtLWl0ZW0td2lkdGg6IGF1dG87XG5cdFx0XHQtLWl0ZW0taGVpZ2h0OiAyMnB4O1xuXG5cdFx0XHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0XHRcdHdpZHRoOiB2YXIoLS10YWctd2lkdGgpO1xuXHRcdFx0aGVpZ2h0OiB2YXIoLS10YWctaGVpZ2h0KTtcblx0XHRcdGJvcmRlci1yYWRpdXM6IDFlbTtcblx0XHRcdHBhZGRpbmc6IDAgMWNoO1xuXHRcdFx0Zm9udC1zaXplOiAxM3B4O1xuXG5cdFx0XHQ+LmxhYmVsIHtcblx0XHRcdFx0bWFyZ2luLXRvcDogMXB4O1xuXHRcdFx0XHR0ZXh0LXNoYWRvdzogLTFweCAxcHggMS4zcHggcmdiKDAgMCAwIC8gNDAlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gJjpudGgtY2hpbGQobisyKSB7XG5cdFx0XHQvLyBcdG1hcmdpbi1sZWZ0OiA4cHg7XG5cdFx0XHQvLyB9XG5cblx0XHRcdCYuY29sbGFwc2VkIHtcblx0XHRcdFx0LS1pdGVtLXdpZHRoOiB2YXIoLS1hcHAtdGFnLWRpYW1ldGVyKTtcblx0XHRcdFx0LS1pdGVtLWhlaWdodDogdmFyKC0tYXBwLXRhZy1kaWFtZXRlcik7XG5cdFx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHR9XG5cblx0XHRcdC5kZWxldGUuaWNvbiB7XG5cdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjJweDtcblx0XHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xuXHRcdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMjAwbXMgZWFzZS1vdXQsIGZpbHRlciAyMDBtcyBlYXNlLW91dDtcblx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0XHRmaWx0ZXI6IGRyb3Atc2hhZG93KDBweCAwcHggMHB4IGJsYWNrKTtcblx0XHRcdFx0ZGlzcGxheTogdmFyKC0tZGVsZXRlLWRpc3BsYXksIGluaXRpYWwpO1xuXG5cdFx0XHRcdCY6aG92ZXIge1xuXHRcdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKSBzY2FsZSgxLjA3NSk7XG5cdFx0XHRcdFx0ZmlsdGVyOiBkcm9wLXNoYWRvdygtMXB4IDNweCAycHggcmdiYSgwLCAwLCAwLCAwLjQpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdD4uZWRpdCB7XG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cblx0XHRcdD4uaWNvbiB7XG5cdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjJweDtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cblx0XHRcdFx0Ly8gLS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0Ly8gLS1pY29uLWRpYW1ldGVyOiAxNnB4O1xuXHRcdFx0XHQvLyAtLWJ1dHRvbi1kaWFtZXRlcjogMjJweDtcblx0XHRcdFx0Ly8gZGlzcGxheTogZmxleDtcblx0XHRcdFx0Ly8gcGFkZGluZzogMnB4O1xuXHRcdFx0XHQvLyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblxuXHRcdFx0XHQvLyBtYXJnaW4tbGVmdDogNHB4O1xuXG5cdFx0XHRcdC8vICY6OmJlZm9yZSB7XG5cdFx0XHRcdC8vIFx0LS1vZmZzZXQ6IDBweDtcblx0XHRcdFx0Ly8gXHRjb250ZW50OiBcIlwiO1xuXHRcdFx0XHQvLyBcdG91dGxpbmU6IDJweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0Ly8gXHRib3JkZXItcmFkaXVzOiB2YXIoLS1idXR0b24tZGlhbWV0ZXIpO1xuXHRcdFx0XHQvLyBcdG1pbi13aWR0aDogY2FsYyh2YXIoLS1idXR0b24tZGlhbWV0ZXIpIC0gKDIgKiB2YXIoLS1vZmZzZXQpKSk7XG5cdFx0XHRcdC8vIFx0bWluLWhlaWdodDogY2FsYyh2YXIoLS1idXR0b24tZGlhbWV0ZXIpIC0gKDIgKiB2YXIoLS1vZmZzZXQpKSk7XG5cdFx0XHRcdC8vIFx0bWFyZ2luLWxlZnQ6IC0zcHg7XG5cdFx0XHRcdC8vIFx0bWFyZ2luLXRvcDogMXB4O1xuXHRcdFx0XHQvLyBcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdFx0Ly8gfVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5wcmVmaXgsLnN1ZmZpeCB7XG5cdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPHNwYW4gY2xhc3M9XCJjbHVzdGVyXCIgY2xhc3M6ZWRpdGFibGU9e2JfZWRpdGFibGV9IGNsYXNzOmNvbGxhcHNlZD17Yl9jb2xsYXBzZWR9IGJpbmQ6dGhpcz17ZG1fY2x1c3Rlcn0gc3R5bGU9e3Jvb3RTdHlsZX0+XG5cdHsjaWYgJCRzbG90cy5wcmVmaXh9XG5cdFx0PHNwYW4gY2xhc3M9XCJwcmVmaXgge3ByZWZpeENsYXNzfVwiPlxuXHRcdFx0PHNsb3QgbmFtZT1cInByZWZpeFwiPjwvc2xvdD5cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG5cblx0eyNrZXkgY19yZWxvYWRfaXRlbXN9XG5cdFx0eyNlYWNoIGl0ZW1zIGFzIGdfaXRlbSwgaV9pdGVtfVxuXHRcdFx0PHNwYW4gY2xhc3M9XCJpdGVtXCIgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOntnX2l0ZW0uY29sb3IgfHwgJ3RyYW5zcGFyZW50J307XCIgY2xhc3M6Y29sbGFwc2VkPXtiX2NvbGxhcHNlZH0gb3V0OnNzbGlkZT17e2R1cmF0aW9uOmJfZWRpdGFibGU/IDMwMDogMH19PlxuXHRcdFx0XHR7I2lmIGdfaXRlbS5wZnBQYXRofVxuXHRcdFx0XHRcdDxQZnBEaXNwbGF5IGRpbT17MTZ9IGNpcmN1bGFyPXt0cnVlfSBuYW1lPXtnX2l0ZW0ubmFtZX0gcmVmPXtnX2l0ZW0ucGZwUGF0aH0gLz5cblx0XHRcdFx0ey9pZn1cblxuXHRcdFx0XHR7I2lmICFiX2NvbGxhcHNlZH1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImxhYmVsXCI+XG5cdFx0XHRcdFx0XHR7Z19pdGVtLm5hbWV9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHR7L2lmfVxuXG5cdFx0XHRcdHsjaWYgYl9lZGl0YWJsZX1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImRlbGV0ZSBpY29uXCIgb246Y2xpY2s9eygpID0+IHJlbW92ZV9pdGVtKGdfaXRlbSl9PlxuXHRcdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fQUREfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0ey9pZn1cblx0XHRcdDwvc3Bhbj5cblx0XHR7L2VhY2h9XG5cdHsva2V5fVxuXG5cdHsjaWYgJCRzbG90cy5zdWZmaXh9XG5cdFx0PHNwYW4gY2xhc3M9XCJzdWZmaXgge3N1ZmZpeENsYXNzfVwiPlxuXHRcdFx0PHNsb3QgbmFtZT1cInN1ZmZpeFwiPjwvc2xvdD5cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG48L3NwYW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBUb2tlbiB9IGZyb20gXCIjL21ldGEvdG9rZW5cIjtcblx0aW1wb3J0IHR5cGUgeyBEaWN0IH0gZnJvbSBcIiMvdXRpbC9iZWx0XCI7XG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cdGltcG9ydCB7IHl3X2NoYWluIH0gZnJvbSBcIi4uL21lbVwiO1xuXHRpbXBvcnQgUm93IGZyb20gXCIuLi91aS9Sb3cuc3ZlbHRlXCI7XG5cdGltcG9ydCB7IFNjcmVlbiwgSGVhZGVyLCB0eXBlIFBhZ2UgfSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRpbXBvcnQgU1hfSUNPTl9BREQgZnJvbSAnIy9pY29uL2FkZC5zdmc/cmF3Jztcblx0aW1wb3J0IElubGluZVBpbGxzLCB7IFBpbGxJdGVtIH0gZnJvbSBcIi4uL3VpL0lubGluZVBpbGxzLnN2ZWx0ZVwiO1xuXG5cdGNvbnN0IEhfUkVHSVNUUlk6IERpY3Q8VG9rZW5bJ2ludGVyZmFjZSddW10+ID0ge1xuXHRcdCdwdWxzYXItMic6IFtcblx0XHRcdHtcblx0XHRcdFx0Y2hhaW46ICcvZmFtaWx5LmNvc21vcy9jaGFpbi5wdWxzYXItMicsXG5cdFx0XHRcdG5hbWU6ICdTZWNyZXQgU2VjcmV0Jyxcblx0XHRcdFx0c3ltYm9sOiAnc1NDUlQnLFxuXHRcdFx0XHRwZnA6ICcvdGVtcGxhdGUucGZwL2lkLjEnLFxuXHRcdFx0XHRoYXNoOiAnOTU4N0Q2MEI4RTZCMDc4QUNFMTIwMTRDRUVFRTA4OTUzMEI5RkFCQ0Q3NjUzNUQ5MzY2NkE2QzEyN0FEODgxMycsXG5cdFx0XHRcdGV4dHJhOiB7XG5cdFx0XHRcdFx0Y29pbmdlY2tvX2lkOiAnc2VjcmV0Jyxcblx0XHRcdFx0fSxcblx0XHRcdFx0b3JpZ2luOiAnYnVpbHQtaW4nLFxuXHRcdFx0XHRzcGVjOiAnc25pcC0yMCcsXG5cdFx0XHRcdGJlY2gzMjogJ3NlY3JldDE4dmQ4ZnB3eHpjazkzcWx3Z2hhajZhcmg0cDdjNW44OTc4dnN5ZycsXG5cdFx0XHR9LFxuXHRcdF0sXG5cdH07XG5cblx0bGV0IGFfc3RhZ2VkOiBQaWxsSXRlbTxUb2tlblsnaW50ZXJmYWNlJ10+W10gPSBbXTtcblxuXHRmdW5jdGlvbiBhZGRfdG9rZW4oZ190b2tlbjogVG9rZW5bJ2ludGVyZmFjZSddKSB7XG5cdFx0YV9zdGFnZWQgPSBhX3N0YWdlZC5jb25jYXQoW3tcblx0XHRcdGlkOiBnX3Rva2VuLmJlY2gzMixcblx0XHRcdG5hbWU6IGdfdG9rZW4ubmFtZSxcblx0XHRcdHBmcFBhdGg6IGdfdG9rZW4ucGZwLFxuXHRcdFx0ZGF0YTogZ190b2tlbixcblx0XHR9XSk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0LnN0YWdlZCB7XG5cdFx0aGVpZ2h0OiAxMDBweDtcblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbj5cblx0PEhlYWRlciBwb3BzIHRpdGxlPSdBZGQgVG9rZW5zJ1xuXHQvPlxuXG5cdDxkaXYgY2xhc3M9XCJzdGFnZWRcIj5cblx0XHQ8SW5saW5lUGlsbHMgYmluZDppdGVtcz17YV9zdGFnZWR9IC8+XG5cdDwvZGl2PlxuXG5cdHsjaWYgSF9SRUdJU1RSWVskeXdfY2hhaW4uaWRdfVxuXHRcdHsjZWFjaCBIX1JFR0lTVFJZWyR5d19jaGFpbi5pZF0gYXMgZ190b2tlbn1cblx0XHRcdDxSb3cgcmVzb3VyY2U9e2dfdG9rZW59IHBvc3RuYW1lPXtnX3Rva2VuLnN5bWJvbH0gcGZwRGltPXszMn1cblx0XHRcdFx0LS1pY29uLWRpYW1ldGVyPSczMnB4J1xuXHRcdFx0PlxuXHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJyaWdodFwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiYWRkIGljb24gdGV4dC1hbGlnbl9yaWdodFwiIHN0eWxlPVwiLS1pY29uLWRpYW1ldGVyOjIycHg7IC0taWNvbi1jb2xvcjp2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcIiBvbjpjbGljaz17KCkgPT4gYWRkX3Rva2VuKGdfdG9rZW4pfT5cblx0XHRcdFx0XHRcdHtAaHRtbCBTWF9JQ09OX0FERH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0PC9Sb3c+XG5cdFx0ey9lYWNofVxuXHR7L2lmfVxuPC9TY3JlZW4+IiwiaW1wb3J0IHR5cGUge05hdGl2ZUNvaW59IGZyb20gJyMvbWV0YS9jaGFpbic7XG5pbXBvcnQgdHlwZSB7Q29pbn0gZnJvbSAnY29zbW9zLWdycGMvZGlzdC9jb3Ntb3MvYmFzZS92MWJldGExL2NvaW4nO1xuXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQge0NvaW5HZWNrb30gZnJvbSAnIy9zdG9yZS93ZWItYXBpcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc19hbW91bnQoZ19iYWxhbmNlOiBDb2luLCBnX2NvaW46IE5hdGl2ZUNvaW4pOiBzdHJpbmcge1xuXHRjb25zdCBzX25vcm0gPSBnX2JhbGFuY2UuYW1vdW50LnBhZFN0YXJ0KGdfY29pbi5kZWNpbWFscyArIDIsICcwJyk7XG5cblx0cmV0dXJuIHNfbm9ybS5zbGljZSgwLCAtZ19jb2luLmRlY2ltYWxzKS5yZXBsYWNlKC9eMCsvLCAnMCcpKycuJytzX25vcm0uc2xpY2UoLWdfY29pbi5kZWNpbWFscyk7XG5cblx0Ly8gLy8gZ19jb2luLmRlY2ltYWxzXG5cdC8vIHJldHVybiBnX2JhbGFuY2UuYW1vdW50O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9fZmlhdChnX2JhbGFuY2U6IENvaW4sIGdfY29pbjogTmF0aXZlQ29pbiwgc2lfdmVyc3VzPSd1c2QnKTogUHJvbWlzZTxCaWdOdW1iZXI+IHtcblx0Ly8gemVyb1xuXHRpZignMCcgPT09IGdfYmFsYW5jZS5hbW91bnQpIHJldHVybiBuZXcgQmlnTnVtYmVyKDApO1xuXG5cdC8vIGxvb2t1cCBwcmljZVxuXHRjb25zdCBzaV9nZWNrbyA9IGdfY29pbi5leHRyYSEuY29pbmdlY2tvX2lkO1xuXHRjb25zdCBnX3ZlcnN1cyA9IGF3YWl0IENvaW5HZWNrby5jb2luc1ZlcnN1cyhbc2lfZ2Vja29dLCBzaV92ZXJzdXMpO1xuXG5cdC8vIHBhcnNlIGJhbGFuY2UgYW5kIG11bHRpcGx5IGJ5IHZhbHVlXG5cdHJldHVybiBuZXcgQmlnTnVtYmVyKGdfYmFsYW5jZS5hbW91bnQpLnNoaWZ0ZWRCeSgtZ19jb2luLmRlY2ltYWxzKS50aW1lcyhnX3ZlcnN1c1tzaV9nZWNrb10pO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29pbkZvcm1hdHMge1xuXHQvKipcblx0ICogVGhlIGlkIG9mIHRoZSBmaWF0IHRoaXMgY29pbiBpcyB2ZXJzdXNcblx0ICovXG5cdHZlcnN1czogc3RyaW5nO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFsYW5jZSBvZiB0aGUgaG9sZGluZ1xuXHQgKi9cblx0YmFsYW5jZTogQmlnTnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBUaGUgdG90YWwgXG5cdCAqL1xuXHRmaWF0OiBudW1iZXI7XG5cblx0LyoqXG5cdCAqIFRoZSB3b3J0aCBvZiBleGFjdGx5IDEgY29pbiB2ZXJzdXMgdGhlIGdpdmVuIGZpYXRcblx0ICovXG5cdHdvcnRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb2luX2Zvcm1hdHMoZ19iYWxhbmNlOiBDb2luLCBnX2NvaW46IE5hdGl2ZUNvaW4sIHNpX3ZlcnN1cz0ndXNkJyk6IFByb21pc2U8Q29pbkZvcm1hdHM+IHtcblx0Ly8gbG9va3VwIHByaWNlXG5cdGNvbnN0IHNpX2dlY2tvID0gZ19jb2luLmV4dHJhIS5jb2luZ2Vja29faWQ7XG5cdGNvbnN0IGdfdmVyc3VzID0gYXdhaXQgQ29pbkdlY2tvLmNvaW5zVmVyc3VzKFtzaV9nZWNrb10sIHNpX3ZlcnN1cyk7XG5cblx0Y29uc3QgeF93b3J0aCA9IGdfdmVyc3VzW3NpX2dlY2tvXTtcblxuXHRjb25zdCB5Z19iYWxhbmNlID0gbmV3IEJpZ051bWJlcihnX2JhbGFuY2UuYW1vdW50KS5zaGlmdGVkQnkoLWdfY29pbi5kZWNpbWFscykudGltZXMoeF93b3J0aClcblxuXHQvLyBwYXJzZSBiYWxhbmNlIGFuZCBtdWx0aXBseSBieSB2YWx1ZVxuXHRyZXR1cm4ge1xuXHRcdHZlcnN1czogc2lfdmVyc3VzLFxuXHRcdGJhbGFuY2U6IHlnX2JhbGFuY2UsXG5cdFx0ZmlhdDogeWdfYmFsYW5jZS50aW1lcyh4X3dvcnRoKS50b051bWJlcigpLFxuXHRcdHdvcnRoOiB4X3dvcnRoLFxuXHR9O1xufVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5cdGltcG9ydCBTWF9JQ09OX1NFTkQgZnJvbSAnIy9pY29uL3NlbmQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX1JFQ1YgZnJvbSAnIy9pY29uL3JlY3Yuc3ZnP3Jhdyc7XG5cblx0Ly8gaW1wb3J0IHtkZWZpbml0aW9ufSBmcm9tICdAZm9ydGF3ZXNvbWUvZnJlZS1zb2xpZC1zdmctaWNvbnMvZmFSb2JvdCc7XG5cdC8vIGNvbnN0IFNYUF9ST0JPVCA9IGRlZmluaXRpb24uaWNvbls0XTtcblx0Y29uc3QgU1hQX1JPQk9UID0gJyc7XG5cblx0Ly8gaW1wb3J0IFNYX05PUlRIX0VBU1QgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvZmlsbGVkL25vcnRoX2Vhc3Quc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9FRElUIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL2ZpbGxlZC9lZGl0LnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfSU5GTyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9pbmZvLnN2Zz9yYXcnO1xuXG5cdGltcG9ydCBTWF9JQ09OX1BFUlNPTkFMIGZyb20gJyMvaWNvbi9hY2NvdW50X2JveC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ09OVFJBQ1QgZnJvbSAnIy9pY29uL2FuYWx5dGljcy5zdmc/cmF3Jztcblx0aW1wb3J0IHsgSGVhZGVyLCBTY3JlZW4sIHR5cGUgUGFnZSB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgUG9ydHJhaXQsIHsgQWN0aW9ucyB9IGZyb20gJy4uL3VpL1BvcnRyYWl0LnN2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgRW50aXR5UGF0aCwgTmF0aXZlQ29pbiB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB7IEVudGl0aWVzIH0gZnJvbSAnIy9zdG9yZS9lbnRpdGllcyc7XG5cdGltcG9ydCB7IHl3X2NoYWluLCB5d19jaGFpbl9yZWYsIHl3X25ldHdvcmtfYWN0aXZlIH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IHsgU0lfU1RPUkVfQ0hBSU5TLCBYVF9NSU5VVEVTIH0gZnJvbSAnIy9zaGFyZS9jb25zdGFudHMnO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IFNlbmQgZnJvbSAnLi9TZW5kLnN2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgVG9rZW4sIFRva2VuUGF0aCB9IGZyb20gJyMvbWV0YS90b2tlbic7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgY29pbl9mb3JtYXRzLCB0b19maWF0IH0gZnJvbSAnIy9jaGFpbi9jb2luJztcblx0aW1wb3J0IHsgZm9ybWF0X2Ftb3VudCwgZm9ybWF0X2ZpYXQgfSBmcm9tICcjL3V0aWwvZm9ybWF0Jztcblx0aW1wb3J0IHR5cGUgeyBDb2luIH0gZnJvbSAnY29zbW9zLWdycGMvZGlzdC9jb3Ntb3MvYmFzZS92MWJldGExL2NvaW4nO1xuXHRpbXBvcnQgdHlwZSB7IFBmcFBhdGggfSBmcm9tICcjL21ldGEvcGZwJztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0LyoqXG5cdCAqIEVudGl0eSBwYXRoIHNob3VsZCBiZSBlaXRoZXIgYSBob2xkaW5nIG9yIHRva2VuXG5cdCAqL1xuXHRleHBvcnQgbGV0IGVudGl0eVJlZjogRW50aXR5UGF0aDtcblx0Y29uc3QgcF9lbnRpdHkgPSBlbnRpdHlSZWY7XG5cblxuXHQvLyBlaXRoZXIgYSBuYXRpdmUgY29pbiBvciBhIGZ1bmdpYmxlIHRva2VuXG5cdGxldCBzaV90eXBlOiAnY29pbicgfCAndG9rZW4nIHwgJycgPSAnJztcblxuXHQvLyB0aGUgY29pbidzIGlkIGFuZCBvYmplY3QgKGlmIGl0cyBhIGNvaW4pXG5cdGxldCBzaV9jb2luID0gJyc7XG5cdGxldCBnX2NvaW46IE5hdGl2ZUNvaW4gfCBudWxsID0gbnVsbDtcblxuXHQvLyB0aGUgdG9rZW4ncyBwYXRoIGFuZCBvYmplY3QgKGlmIGl0J3MgYSB0b2tlbilcblx0bGV0IHBfdG9rZW46IFRva2VuUGF0aCB8ICcnID0gJyc7XG5cdGxldCBnX3Rva2VuOiBUb2tlblsnaW50ZXJmYWNlJ10gfCBudWxsID0gbnVsbDtcblxuXG5cdC8vIGl0cyBwZnBcblx0bGV0IHBfcGZwOiBQZnBQYXRoIHwgJycgPSAnJztcblxuXHQvLyBpdHMgU1lNQkxcblx0bGV0IHNfc3ltYm9sID0gJyc7XG5cblx0Ly8gaXRzIG5hbWVcblx0bGV0IHNfbmFtZSA9ICcnO1xuXHRcblx0Ly8gdGhlIGFtb3VudCB0aGUgb3duZXIgaG9sZHNcblx0bGV0IHlnX2Ftb3VudDogQmlnTnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cblx0Ly8gdGhlIGVxdWl2YWxlbnQgaW4gZmlhdFxuXHRsZXQgc19maWF0ID0gJyc7XG5cblx0Ly8gdGhlIGZpYXQgd29ydGggb2YgZXhhY3RseSAxIGNvaW4vdG9rZW5cblx0bGV0IHNfd29ydGggPSAnJztcblxuXG5cdC8vIGNvbnN0IHhfdmVyc3VzX3VzZCA9IEhfVkVSU1VTX1VTRFtwX3Rva2VuXS52YWx1ZTtcblxuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfZW50aXR5KCkge1xuXHRcdGNvbnN0IGtzX2VudGl0aWVzID0gYXdhaXQgRW50aXRpZXMucmVhZCgpO1xuXG5cdFx0Y29uc3QgZ19pbmZvID0gRW50aXRpZXMucGFyc2VFbnRpdHlQYXRoKHBfZW50aXR5KTtcblxuXHRcdGlmKCFnX2luZm8pIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGxvYWQgaG9sZGluZyB2aWV3IG9uIG5vbi1lbnRpdHkgcGF0aCBcIiR7cF9lbnRpdHl9XCJgKTtcblx0XHR9XG5cblx0XHRzd2l0Y2goZ19pbmZvLnR5cGUpIHtcblx0XHRcdC8vIG5hdGl2ZSBjb2luXG5cdFx0XHRjYXNlICdob2xkaW5nJzoge1xuXHRcdFx0XHRzaV90eXBlID0gJ2NvaW4nO1xuXG5cdFx0XHRcdC8vIGRlc3RydWN0dXJlXG5cdFx0XHRcdCh7XG5cdFx0XHRcdFx0Y29pbjogc2lfY29pbixcblx0XHRcdFx0fSA9IGdfaW5mbyk7XG5cblx0XHRcdFx0Ly8gbG9va3VwIGRldGFpbHMgZnJvbSBjaGFpblxuXHRcdFx0XHRjb25zdCBwX2NoYWluID0gZ19pbmZvLmNoYWluUmVmO1xuXHRcdFx0XHRjb25zdCBnX2NoYWluID0gcF9jaGFpbiA9PT0gJHl3X2NoYWluX3JlZj8gJHl3X2NoYWluOiAoYXdhaXQgQ2hhaW5zLmF0KHBfY2hhaW4pKSE7XG5cdFx0XHRcdGdfY29pbiA9IGdfY2hhaW4uY29pbnNbc2lfY29pbl07XG5cblx0XHRcdFx0Ly8gc2V0IGRldGFpbHNcblx0XHRcdFx0c19zeW1ib2wgPSBzaV9jb2luO1xuXHRcdFx0XHRzX25hbWUgPSBnX2NvaW4ubmFtZTtcblx0XHRcdFx0cF9wZnAgPSBnX2NvaW4ucGZwO1xuXG5cdFx0XHRcdC8vIHJlYWQgY2FjaGVcblx0XHRcdFx0Y29uc3QgZ19jYWNoZWQgPSAkeXdfbmV0d29ya19hY3RpdmUuY2FjaGVkQmFsYW5jZShnX2luZm8uYmVjaDMyLCBzaV9jb2luKTtcblxuXHRcdFx0XHRsZXQgZ19iYWxhbmNlOiBDb2luO1xuXG5cdFx0XHRcdC8vIGNhY2hlIGlzIHdpdGhpbiBhc2tpbmcgdGltZVxuXHRcdFx0XHRpZihnX2NhY2hlZCAmJiBnX2NhY2hlZC50aW1lc3RhbXAgPj0gRGF0ZS5ub3coKSAtICgyICogWFRfTUlOVVRFUykpIHtcblx0XHRcdFx0XHRnX2JhbGFuY2UgPSBnX2NhY2hlZC5kYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIGRlc3RydWN0dXJlIGJhbGFuY2Vcblx0XHRcdFx0XHQoe1xuXHRcdFx0XHRcdFx0YmFsYW5jZTogZ19iYWxhbmNlLFxuXHRcdFx0XHRcdH0gPSBhd2FpdCAkeXdfbmV0d29ya19hY3RpdmUuYmFua0JhbGFuY2UoZ19pbmZvLmJlY2gzMiwgc2lfY29pbikpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2V0IGFtb3VudFxuXHRcdFx0XHR5Z19hbW91bnQgPSBuZXcgQmlnTnVtYmVyKGdfYmFsYW5jZS5hbW91bnQpLnNoaWZ0ZWRCeSgtZ19jb2luLmRlY2ltYWxzKTtcblxuXHRcdFx0XHQvLyBzZXQgZmlhdCBhbW91bnQgYXN5bmNocm9ub3VzbHlcblx0XHRcdFx0dm9pZCBjb2luX2Zvcm1hdHMoZ19iYWxhbmNlLCBnX2NvaW4pLnRoZW4oKGdfZm9ybWF0cykgPT4ge1xuXHRcdFx0XHRcdHNfZmlhdCA9IGZvcm1hdF9maWF0KGdfZm9ybWF0cy5maWF0LCBnX2Zvcm1hdHMudmVyc3VzKTtcblx0XHRcdFx0XHRzX3dvcnRoID0gZm9ybWF0X2ZpYXQoZ19mb3JtYXRzLndvcnRoLCBnX2Zvcm1hdHMudmVyc3VzKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRva2VuXG5cdFx0XHRjYXNlICd0b2tlbic6IHtcblx0XHRcdFx0c2lfdHlwZSA9ICd0b2tlbic7XG5cblx0XHRcdFx0Ly8gc2V0IHRva2VuIHBhdGhcblx0XHRcdFx0cF90b2tlbiA9IHBfZW50aXR5IGFzIFRva2VuUGF0aDtcblxuXHRcdFx0XHQvLyByZWFkIHRva2VuIGludGVyZmFjZXNcblx0XHRcdFx0Y29uc3Qga3NfZW50aXRlcyA9IGF3YWl0IEVudGl0aWVzLnJlYWQoKTtcblx0XHRcdFx0Y29uc3QgaF9pZmFjZXMgPSBrc19lbnRpdGVzLnRva2VucyhnX2luZm8uZW50aXR5UmVmLCBFbnRpdGllcy5mdW5naWJsZUludGVyZmFjZXNGb3IoJHl3X2NoYWluKSk7XG5cdFx0XHRcdGRlYnVnZ2VyO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGVudGl0eSB0eXBlOiBcIiR7Z19pbmZvLnR5cGV9XCJgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRsb2FkX2VudGl0eSgpO1xuXG5cdC8vIGV4cG9ydCBjb25zdCBhY2NvdW50SWQgPSBPYmplY3QudmFsdWVzKEhfQUNDT1VOVFMpLmZpbmQoKGspID0+IGsuYWRkcmVzcyhrX2NoYWluKSA9PT0gaG9sZGluZy5kZWYuaG9sZGVyQWRkcik/LmRlZi5pZCB8fCAkeXdfY2hhaW4uZGVmLmlkO1xuXG5cdC8vIGNvbnN0IGtfYWNjb3VudCA9ICR5d19hY2NvdW50O1xuXHQvLyB5d19hY2NvdW50LnN1YnNjcmliZSgoX2tfYWNjb3VudCkgPT4ge1xuXHQvLyBcdGlmKCR5d19wYXR0ZXJuLmVuZHNXaXRoKCcvdG9rZW5zL3t0b2tlbklkfS9ob2xkaW5ncy97YWNjb3VudElkfS92aWV3JykgJiYga19hY2NvdW50LmRlZi5wdWJrZXkgIT09IF9rX2FjY291bnQuZGVmLnB1YmtleSkge1xuXHQvLyBcdFx0cmVzdGFydCgpO1xuXHQvLyBcdH1cblx0Ly8gfSk7XG5cblx0Ly8gY29uc3QgSF9UWE5fSUNPTlMgPSB7XG5cdC8vIFx0W1R4bi5UeXBlLlVOS05dOiBJY29uLkJMQU5LLFxuXHQvLyBcdFtUeG4uVHlwZS5TRU5EXTogSWNvbi5mcm9tSHRtbChTWF9JQ09OX1NFTkQsIHtjbGFzczonaWNvbi0yMCd9KSxcblx0Ly8gXHRbVHhuLlR5cGUuUkVDVl06IEljb24uZnJvbUh0bWwoU1hfSUNPTl9SRUNWLCB7Y2xhc3M6J2ljb24tMjAnfSksXG5cdC8vIFx0W1R4bi5UeXBlLkNPTVBdOiBJY29uLmZyb21IdG1sKGA8c3ZnPjxwYXRoIGQ9XCIke1NYUF9ST0JPVH1cIi8+PC9zdmc+YCwge2NsYXNzOidpY29uLTIwJ30pLFxuXHQvLyBcdFtUeG4uVHlwZS5TTklQMjBfWEZFUl06IEljb24uZnJvbUh0bWwoU1hfSUNPTl9SRUNWLCB7Y2xhc3M6J2ljb24tMjAnfSksXG5cdC8vIH0gYXMgUmVjb3JkPFR4bi5UeXBlIHwgVHhuLkJhbmtpc2hUeXBlLCBJY29uPjtcblxuXHQvLyBjb25zdCBIX1NVTU1BUklaRVJTID0ge1xuXHQvLyBcdFtUeG4uVHlwZS5VTktOXTogKF8pID0+ICdVbmtub3duJyxcblx0Ly8gXHRbVHhuLlR5cGUuU0VORF06IChrKSA9PiBgU2VuZCBvbiAke2suZGF0ZSgpfWAsXG5cdC8vIFx0W1R4bi5UeXBlLlJFQ1ZdOiAoaykgPT4gYFJlY2VpdmUgb24gJHtrLmRhdGUoKX1gLFxuXHQvLyBcdFtUeG4uVHlwZS5DT01QXTogKGspID0+IGBDb21wdXRlIG9uICR7ay5kYXRlKCl9YCxcblx0Ly8gfSBhcyBSZWNvcmQ8VHhuLlR5cGUgfCBUeG4uQmFua2lzaFR5cGUsIChrX3R4bjogVHhuKSA9PiBzdHJpbmc+O1xuXG5cdC8vIGNvbnN0IEhfVFhOX0NMQVNTRVMgPSB7XG5cdC8vIFx0W1R4bi5UeXBlLlNFTkRdOiAnY29sb3ItaWNvbi1zZW5kJyxcblx0Ly8gXHRbVHhuLlR5cGUuUkVDVl06ICdjb2xvci1pY29uLXJlY3YnLFxuXHQvLyB9IGFzIFJlY29yZDxUeG4uVHlwZSB8IFR4bi5CYW5raXNoVHlwZSwgc3RyaW5nPjtcblxuXHQvLyB0aGUgc2V0IG9mIGFjdGlvbnMgYXZhaWxhYmxlIG9uIHRoaXMgYXNzZXRcblx0Y29uc3QgZ2NfYWN0aW9uczogQWN0aW9ucyA9IHtcblx0XHRzZW5kOiB7XG5cdFx0XHRsYWJlbDogJ1NlbmQnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IFNlbmQsXG5cdFx0XHRcdFx0cHJvcHM6IGdfdG9rZW5cblx0XHRcdFx0XHRcdD8ge1xuXHRcdFx0XHRcdFx0XHR0b2tlbjogZ190b2tlbixcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdDogc2lfY29pblxuXHRcdFx0XHRcdFx0XHQ/IHtcblx0XHRcdFx0XHRcdFx0XHRuYXRpdmU6IFNJX1NUT1JFX0NIQUlOUyxcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQ6IHt9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0fTtcblxuXHQvLyAvLyBob21lIHRva2VuXG5cdC8vIGNvbnN0IGtfaWJjdF9uYXRpdmUgPSBIX0lCQ1RTW0liY3QucmVmRnJvbUhvbWVUb2tlbihnZF90b2tlbi5pcmkpXTtcblx0Ly8gaWYoa19pYmN0X25hdGl2ZSkge1xuXHQvLyBcdGdjX2FjdGlvbnMud3JhcCA9IHtcblx0Ly8gXHRcdGxhYmVsOiAnV3JhcCcsXG5cdC8vIFx0XHR0cmlnZ2VyKCkge1xuXHQvLyBcdFx0XHRwdXNoX3NjcmVlbihEZWFkRW5kKTtcblx0Ly8gXHRcdH0sXG5cdC8vIFx0fTtcblx0Ly8gfVxuXG5cdC8vIC8vIGNvbG9ueSB0b2tlblxuXHQvLyBpZihrX3Rva2VuLmliY3QpIHtcblx0Ly8gXHRnY19hY3Rpb25zLnVud3JhcCA9IHtcblx0Ly8gXHRcdGxhYmVsOiAnVW53cmFwJyxcblx0Ly8gXHRcdHRyaWdnZXIoKSB7XG5cdC8vIFx0XHRcdHB1c2hfc2NyZWVuKERlYWRFbmQpO1xuXHQvLyBcdFx0fSxcblx0Ly8gXHR9O1xuXHQvLyB9XG5cblx0Ly8gLy8gbm9uLW5hdGl2ZSB0b2tlblxuXHQvLyBpZighZ2RfdG9rZW4ubmF0aXZlKSB7XG5cdC8vIFx0T2JqZWN0LmFzc2lnbihnY19hY3Rpb25zLCB7XG5cdC8vIFx0XHRlZGl0OiB7XG5cdC8vIFx0XHRcdGxhYmVsOiAnRWRpdCcsXG5cdC8vIFx0XHRcdHRyaWdnZXIoKSB7XG5cdC8vIFx0XHRcdFx0cHVzaF9zY3JlZW4oVG9rZW5FZGl0LCB7XG5cdC8vIFx0XHRcdFx0XHR0b2tlbjoga190b2tlbixcblx0Ly8gXHRcdFx0XHR9KTtcblx0Ly8gXHRcdFx0fSxcblx0Ly8gXHRcdH0sXG5cdC8vIFx0fSk7XG5cdC8vIH1cblxuXHQvLyBmdW5jdGlvbiBkZXRhaWxfYmFua2lzaChnX2Jhbmtpc2g/OiBUeG4uQmFua2lzaCB8IG51bGwpOiB7cHJlZml4OnN0cmluZywgbmFtZTpzdHJpbmcsIGljb246c3RyaW5nfSB7XG5cdC8vIFx0aWYoIWdfYmFua2lzaCkgcmV0dXJuIHtwcmVmaXg6JycsIG5hbWU6JycsIGljb246Jyd9O1xuXG5cdC8vIFx0Y29uc3Qga19jb250YWN0ID0gSF9BRERSX1RPX0NPTlRBQ1RbZ19iYW5raXNoLmFkZHJlc3NdO1xuXG5cdC8vIFx0cmV0dXJuIHtcblx0Ly8gXHRcdHByZWZpeDogKFR4bi5CYW5raXNoVHlwZS5TRU5EID09PSBnX2Jhbmtpc2gudHlwZT8gJ3RvJzogJ2ZyJykrJzonLFxuXHQvLyBcdFx0bmFtZToga19jb250YWN0PyBrX2NvbnRhY3QuZGVmLmxhYmVsOiAnJyxcblx0Ly8gXHRcdGljb246IGtfY29udGFjdFxuXHQvLyBcdFx0XHQ/IENvbnRhY3QuVHlwZS5QRVJTT04gPT09IGtfY29udGFjdC5kZWYudHlwZVxuXHQvLyBcdFx0XHRcdD8gU1hfSUNPTl9QRVJTT05BTFxuXHQvLyBcdFx0XHRcdDogU1hfSUNPTl9DT05UUkFDVFxuXHQvLyBcdFx0XHQ6ICcnLFxuXHQvLyBcdH07XG5cdC8vIH1cblxuXHRcblx0Ly8gY29uc3QgYV9hbGxvd2FuY2VzID0gZ2RfdG9rZW4uYWxsb3dhbmNlcy5tYXAoKGdfYWxsb3dhbmNlKSA9PiB7XG5cdC8vIFx0Y29uc3Qga19zcGVuZGVyID0gSF9BRERSX1RPX0NPTlRSQUNUW2dfYWxsb3dhbmNlLnNwZW5kZXJdO1xuXHQvLyBcdGlmKCFrX3NwZW5kZXIpIHtcblx0Ly8gXHRcdGRlYnVnZ2VyO1xuXHQvLyBcdH1cblxuXHQvLyBcdGxldCBzX2Ftb3VudDtcblx0Ly8gXHRjb25zdCB5Z19hbW91bnQgPSBuZXcgQmlnTnVtYmVyKGdfYWxsb3dhbmNlLmFtb3VudCk7XG5cdC8vIFx0aWYoeWdfYW1vdW50LmlzR3JlYXRlclRoYW4obmV3IEJpZ051bWJlcignMTAwMDAwMDAwMDAwMDAwMDAwMCcpKSkge1xuXHQvLyBcdFx0c19hbW91bnQgPSAnTGltaXRsZXNzJztcblx0Ly8gXHR9XG5cdC8vIFx0ZWxzZSB7XG5cdC8vIFx0XHRmb3JtYXRfYW1vdW50KGtfdG9rZW4uYXBwcm94KEJpZ0ludChnX2FsbG93YW5jZS5hbW91bnQpKSk7XG5cdC8vIFx0fVxuXG5cdC8vIFx0bGV0IHNfZXhwaXJ5O1xuXHQvLyBcdGNvbnN0IHhfZXhwaXJlcyA9IGdfYWxsb3dhbmNlLmV4cGlyYXRpb247XG5cdC8vIFx0aWYoeF9leHBpcmVzKSB7XG5cdC8vIFx0XHRjb25zdCBkdF93aGVuID0gbmV3IERhdGUoeF9leHBpcmVzICogMWUzKTtcblxuXHQvLyBcdFx0c19leHBpcnkgPSBkdF93aGVuLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7XG5cdC8vIFx0XHRcdG1vbnRoOiAnc2hvcnQnLFxuXHQvLyBcdFx0XHRkYXk6ICdudW1lcmljJyxcblx0Ly8gXHRcdFx0eWVhcjogZHRfd2hlbi5nZXRGdWxsWWVhcigpICE9PSAobmV3IERhdGUoKSkuZ2V0RnVsbFllYXIoKT8gJ251bWVyaWMnOiB2b2lkIDAsXG5cdC8vIFx0XHR9KTtcblx0Ly8gXHR9XG5cdC8vIFx0ZWxzZSB7XG5cdC8vIFx0XHRzX2V4cGlyeSA9ICdOZXZlciBleHBpcmVzJztcblx0Ly8gXHR9XG5cblx0Ly8gXHRyZXR1cm4ge1xuXHQvLyBcdFx0Li4uZ19hbGxvd2FuY2UsXG5cdC8vIFx0XHRrX3NwZW5kZXIsXG5cdC8vIFx0XHRzX2Ftb3VudCxcblx0Ly8gXHRcdHNfZXhwaXJ5LFxuXHQvLyBcdH07XG5cdC8vIH0pO1xuXG5cdC8vIGlmKFRhc2tzLlZFUklGWSA9PT0gJHl3X3Rhc2sgJiYgJ0FUT00nID09PSBnZF90b2tlbi5zeW1ib2wgJiYgZ2RfdG9rZW4ubmF0aXZlICYmICcyJyA9PT0gJHl3X2FjY291bnQuZGVmLmlkKSB7XG5cdC8vIFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdC8vIFx0XHQkeXdfdGFzayA9IC0keXdfdGFzaztcblx0Ly8gXHR9LCAxNDAwKTtcblx0Ly8gfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdC50eG5zIHtcblx0XHQucm93IC5pY29uIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0XHRcdGJvcmRlci1yYWRpdXM6IDMycHg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LnNlY3Rpb24ge1xuXHRcdG1hcmdpbjogMDtcblx0XHRib3JkZXItdG9wOiA2cHggc29saWQgYmxhY2s7XG5cdFx0Ym9yZGVyLWJvdHRvbTogNnB4IHNvbGlkIGJsYWNrO1xuXG5cdFx0LmJhciB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdHBhZGRpbmc6IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHQubGVmdCB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdGdhcDogMC41ZXg7XG5cblx0XHRcdFx0Pi50aXRsZSB7XG5cdFx0XHRcdFx0LmZvbnQocmVndWxhcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LmluZm8ge1xuXHRcdFx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LnJpZ2h0IHtcblxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC50eG4tdHlwZS5pY29uIHtcblx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdC0taWNvbi1kaWFtZXRlcjogMThweDtcblx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbiBkZWJ1Zz0nSG9sZGluZ1ZpZXcnIG5hdiBzbGlkZXM+XG5cdDxIZWFkZXIgcG9wcyBhY2NvdW50IG5ldHdvcmtcblx0XHR0aXRsZT17c19zeW1ib2x9XG5cdFx0c3VidGl0bGU9e3NfbmFtZX1cblx0PlxuXHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInRpdGxlXCI+XG5cblx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0PC9IZWFkZXI+XG5cblx0PFBvcnRyYWl0XG5cdFx0cGZwPXtwX3BmcH1cblx0XHRyZXNvdXJjZT17Z19jb2luIHx8IGdfdG9rZW4gfHwgbnVsbH1cblx0XHRyZXNvdXJjZVBhdGg9e3BfZW50aXR5fVxuXHRcdHRpdGxlPXt5Z19hbW91bnQ/IGAke2Zvcm1hdF9hbW91bnQoeWdfYW1vdW50LnRvTnVtYmVyKCkpfSAke3Nfc3ltYm9sfWA6ICcuLi4nfVxuXHRcdHN1YnRpdGxlPXtgJHtzX2ZpYXR9ICgke3Nfd29ydGh9IHBlciAke3NpX3R5cGV9KWB9XG5cdFx0YWN0aW9ucz17Z2NfYWN0aW9uc31cblx0Lz5cblxuXHQ8ZGl2IGNsYXNzPVwidHhucyBuby1tYXJnaW5cIj5cblxuXHRcdDwhLS0geyNpZiBrX2liY3RfbmF0aXZlfVxuXHRcdFx0PGRpdiBjbGFzcz1cInNlY3Rpb25cIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImJhclwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibGVmdFwiPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxhYmVsXCI+XG5cdFx0XHRcdFx0XHRcdFN0YWtlXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0XHRcdEVhcm4gdXAgdG8gMjQlIHBlciB5ZWFyXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJyaWdodFwiPlxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cInBpbGxcIj5cblx0XHRcdFx0XHRcdFx0U3Rha2Uge2dkX3Rva2VuLnN5bWJvbH1cblx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdCAtLT5cblx0XHQ8IS0tIHs6ZWxzZSBpZiAkeXdfY2hhaW4uZGVmLmlkLnN0YXJ0c1dpdGgoJ3NlY3JldC0nKX0gLS0+XG48IS0tIFxuXHRcdFx0PGRpdiBjbGFzcz1cInNlY3Rpb25cIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImJhclwiIHN0eWxlPXthX2FsbG93YW5jZXMubGVuZ3RoPyBcImJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1wiOiAnJ30+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsZWZ0XCI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibGFiZWxcIj5cblx0XHRcdFx0XHRcdFx0QWxsb3dhbmNlcyAoe2dkX3Rva2VuLmFsbG93YW5jZXMubGVuZ3RofSlcblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHRcdFx0QWNjb3VudHMgYWxsb3dlZCB0byBzcGVuZCB0aGlzIHRva2VuXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJyaWdodFwiPlxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cInBpbGxcIiBvbjpjbGljaz17KCkgPT4gcHVzaF9zY3JlZW4oRGVhZEVuZCl9PlxuXHRcdFx0XHRcdFx0XHRNYW5hZ2Vcblx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0eyNlYWNoIGFfYWxsb3dhbmNlcyBhcyBnX2FsbG93YW5jZSwgaV9hbGxvd2FuY2V9XG5cdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0bmFtZT17Z19hbGxvd2FuY2Uua19zcGVuZGVyLmRlZi5sYWJlbH1cblx0XHRcdFx0XHRcdGFkZHJlc3M9e2dfYWxsb3dhbmNlLmtfc3BlbmRlci5kZWYuYWRkcmVzc31cblx0XHRcdFx0XHRcdGFtb3VudD17Z19hbGxvd2FuY2Uuc19hbW91bnR9XG5cdFx0XHRcdFx0XHRmaWF0PXtnX2FsbG93YW5jZS5zX2V4cGlyeX1cblx0XHRcdFx0XHRcdGljb25SZWY9e2dfYWxsb3dhbmNlLmtfc3BlbmRlci5kZWYuaWNvblJlZn1cblx0XHRcdFx0XHRcdGljb25DbGFzcz0nc2l0ZSdcblx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiBwdXNoX3NjcmVlbihEZWFkRW5kKX1cblx0XHRcdFx0XHRcdHJvb3RTdHlsZT17aV9hbGxvd2FuY2UgPT09IGFfYWxsb3dhbmNlcy5sZW5ndGgtMT8gJ2JvcmRlci1ib3R0b206IG5vbmU7JzogJyd9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdDwvUm93PlxuXHRcdFx0XHR7L2VhY2h9XG5cdFx0XHQ8L2Rpdj4gLS0+XG5cblx0XHQ8IS0tIHsvaWZ9IC0tPlxuPCEtLSBcblx0XHR7I2VhY2ggYV9oaXN0b3J5IGFzIGtfdHhufVxuXHRcdFx0e0Bjb25zdCBnX2Jhbmtpc2ggPSBrX3R4bi5iYW5raXNoKCR5d19hY2NvdW50LmFkZHJlc3MoJHl3X2NoYWluKSl9XG5cdFx0XHR7QGNvbnN0IGdkX3R4biA9IGtfdHhuLmRlZn1cblx0XHRcdHtAY29uc3QgZ19kZXRhaWwgPSBkZXRhaWxfYmFua2lzaChnX2Jhbmtpc2gpfVxuXG5cdFx0XHR7I2lmIGdfYmFua2lzaH1cblx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdGljb249e0hfVFhOX0lDT05TW2dfYmFua2lzaC50eXBlXX1cblx0XHRcdFx0XHRpY29uQ2xhc3M9e0hfVFhOX0NMQVNTRVNbZ19iYW5raXNoLnR5cGVdIHx8ICcnfVxuXHRcdFx0XHRcdG5hbWU9e0hfU1VNTUFSSVpFUlNbZ19iYW5raXNoLnR5cGVdKGtfdHhuKX1cblx0XHRcdFx0XHRhZGRyZXNzPXtnX2Jhbmtpc2guYWRkcmVzc31cblx0XHRcdFx0XHRkZXRhaWw9e2dfZGV0YWlsLm5hbWV9XG5cdFx0XHRcdFx0cHJlZml4PXtnX2RldGFpbC5wcmVmaXh9XG5cdFx0XHRcdFx0YW1vdW50PXtmb3JtYXRfYW1vdW50KGtfdG9rZW4uYXBwcm94KGdfYmFua2lzaC5hbW91bnQpKX1cblx0XHRcdFx0XHRmaWF0PXthbW91bnRfdG9fZmlhdChrX3Rva2VuLmFwcHJveChnX2Jhbmtpc2guYW1vdW50KSwga190b2tlbil9XG5cdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHB1c2hfc2NyZWVuKERlYWRFbmQpfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwiZGV0YWlsXCI+XG5cdFx0XHRcdFx0XHR7I2lmIGdfZGV0YWlsLmljb259XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwidHhuLXR5cGUgaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBnX2RldGFpbC5pY29ufVxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdFx0eyNpZiBnX2RldGFpbC5uYW1lfVxuXHRcdFx0XHRcdFx0XHR7Z19kZXRhaWwubmFtZX1cblx0XHRcdFx0XHRcdHs6ZWxzZSBpZiBnX2Jhbmtpc2guYWRkcmVzc31cblx0XHRcdFx0XHRcdFx0PEFkZHJlc3MgYWRkcmVzcz17Z19iYW5raXNoLmFkZHJlc3N9IC8+XG5cdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHQ8L1Jvdz5cblx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdGljb249e0hfVFhOX0lDT05TW2dkX3R4bi50eXBlXX1cblx0XHRcdFx0XHRpY29uQ2xhc3M9e0hfVFhOX0NMQVNTRVNbZ2RfdHhuLnR5cGVdIHx8ICcnfVxuXHRcdFx0XHRcdG5hbWU9e0hfU1VNTUFSSVpFUlNbZ2RfdHhuLnR5cGVdKGtfdHhuKX1cblx0XHRcdFx0XHRhZGRyZXNzPXtnZF90eG4uYWRkcmVzc31cblx0XHRcdFx0XHRhbW91bnQ9e2Zvcm1hdF9hbW91bnQoa190b2tlbi5hcHByb3goZ2RfdHhuLmFtb3VudCkpfVxuXHRcdFx0XHRcdGZpYXQ9e2Ftb3VudF90b19maWF0KGtfdG9rZW4uYXBwcm94KGdkX3R4bi5hbW91bnQpLCBrX3Rva2VuKX1cblx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gcHVzaF9zY3JlZW4oRGVhZEVuZCl9XG5cdFx0XHRcdC8+XG5cdFx0XHR7L2lmfVxuXHRcdHsvZWFjaH0gLS0+XG5cdDwvZGl2PlxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBUb2tlblNwZWNLZXkgfSBmcm9tICcjL21ldGEvdG9rZW4nO1xuXG5cdGltcG9ydCB7IEVudGl0aWVzLCBUb2tlbkRpY3QgfSBmcm9tICcjL3N0b3JlL2VudGl0aWVzJztcblx0aW1wb3J0IHsgRGljdCwgZm9yZXZlciwgb2RlLCBvZGVyb20sIFByb21pc2FibGUgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyB5d19hY2NvdW50LCB5d19hY2NvdW50X3JlZiwgeXdfY2hhaW4sIHl3X2NoYWluX3JlZiwgeXdfcG9wdXAsIHl3X2NvbnRleHRfcG9wdXAsIHBvcHVwX3JlY2VpdmUsIHl3X25ldHdvcmssIHl3X25ldHdvcmtfYWN0aXZlLCB5d19vd25lciB9IGZyb20gJy4uL21lbSc7XG5cdGltcG9ydCBQb3J0cmFpdCBmcm9tICcuLi91aS9Qb3J0cmFpdC5zdmVsdGUnO1xuXHRpbXBvcnQgU2VuZCBmcm9tICcuL1NlbmQuc3ZlbHRlJztcblx0aW1wb3J0IFBvcHVwUmVjZWl2ZSBmcm9tICcuLi91aS9Qb3B1cFJlY2VpdmUuc3ZlbHRlJztcblx0aW1wb3J0IFJvdyBmcm9tICcuLi91aS9Sb3cuc3ZlbHRlJztcblx0aW1wb3J0IHsgSGVhZGVyLCBTY3JlZW4sIHR5cGUgUGFnZSB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IENvaW5HZWNrbyB9IGZyb20gJyMvc3RvcmUvd2ViLWFwaXMnO1xuXHRpbXBvcnQgeyBmb3JtYXRfYW1vdW50LCBmb3JtYXRfZmlhdCB9IGZyb20gJyMvdXRpbC9mb3JtYXQnO1xuXHRpbXBvcnQgdHlwZSB7IENvaW4gfSBmcm9tICdjb3Ntb3MtZ3JwYy9kaXN0L2Nvc21vcy9iYXNlL3YxYmV0YTEvY29pbic7XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4sIE5hdGl2ZUNvaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgdHlwZSB7IFZhbHVlcyB9IGZyb20gJyMvbWV0YS9iZWx0Jztcblx0aW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuXHRpbXBvcnQgQWRkcmVzcyBmcm9tICcuLi91aS9BZGRyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBHYXAgZnJvbSAnLi4vdWkvR2FwLnN2ZWx0ZSc7XG5cdGltcG9ydCB7IG9wZW5fZXh0ZXJuYWxfbGluayB9IGZyb20gJyMvdXRpbC9kb20nO1xuXHRpbXBvcnQgVG9rZW5zQWRkIGZyb20gJy4vVG9rZW5zQWRkLnN2ZWx0ZSc7XG5cdGltcG9ydCB7IGFzX2Ftb3VudCwgdG9fZmlhdCB9IGZyb20gJyMvY2hhaW4vY29pbic7XG5cdGltcG9ydCBIb2xkaW5nVmlldyBmcm9tICcuL0hvbGRpbmdWaWV3LnN2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgQmFsYW5jZUJ1bmRsZSB9IGZyb20gJyMvc3RvcmUvbmV0d29ya3MnO1xuXHRpbXBvcnQgeyBzeXNlcnIgfSBmcm9tICcuLi9jb21tb24nO1xuXG5cdC8vICQ6IHNhX293bmVyID0gQ2hhaW5zLmFkZHJlc3NGb3IoJHl3X2FjY291bnQucHVia2V5LCAkeXdfY2hhaW4pO1xuXG5cdGNvbnN0IG1lcmdlX2Z1bmdpYmxlX3Rva2VucyA9IChoX2Z1bmdpYmxlczogUmVjb3JkPFRva2VuU3BlY0tleSwgVG9rZW5EaWN0PikgPT4gb2Rlcm9tKGhfZnVuZ2libGVzLCAoXywgaCkgPT4gaCk7XG5cblx0Ly8gZ2V0IHBhZ2UgZnJvbSBjb250ZXh0XG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRsZXQgeWdfdG90YWwgPSBuZXcgQmlnTnVtYmVyKDApO1xuXHRsZXQgY19iYWxhbmNlcyA9IDA7XG5cdGxldCBiX2JhbGFuY2VzX3JlYWR5ID0gdHJ1ZTtcblx0bGV0IGFfbm9fZ2FzOiBzdHJpbmdbXSA9IFtdO1xuXG5cdGxldCBma19yZXNvbHZlX3RvdGFsOiAoc190b3RhbDogc3RyaW5nKSA9PiB2b2lkO1xuXHRsZXQgZHBfdG90YWwgPSBuZXcgUHJvbWlzZTxzdHJpbmc+KChma19yZXNvbHZlKSA9PiB7XG5cdFx0ZmtfcmVzb2x2ZV90b3RhbCA9IGZrX3Jlc29sdmU7XG5cdH0pO1xuXG5cdGxldCBnX2NoYWluX2NhY2hlZCA9ICR5d19jaGFpbjtcblx0JDoge1xuXHRcdGlmKCR5d19jaGFpbiAhPT0gZ19jaGFpbl9jYWNoZWQpIHtcblx0XHRcdGdfY2hhaW5fY2FjaGVkID0gJHl3X2NoYWluO1xuXHRcdFx0eWdfdG90YWwgPSBuZXcgQmlnTnVtYmVyKDApO1xuXHRcdFx0Y19iYWxhbmNlcyA9IDA7XG5cdFx0XHRkcF90b3RhbCA9IG5ldyBQcm9taXNlPHN0cmluZz4oKGZrX3Jlc29sdmUpID0+IHtcblx0XHRcdFx0ZmtfcmVzb2x2ZV90b3RhbCA9IGZrX3Jlc29sdmU7XG5cdFx0XHR9KTtcblx0XHRcdGFfbm9fZ2FzID0gW107XG5cdFx0fVxuXHR9XG5cblxuXHRmdW5jdGlvbiBjaGVja190b3RhbCgpIHtcblx0XHRjX2JhbGFuY2VzIC09IDE7XG5cdFx0aWYoYl9iYWxhbmNlc19yZWFkeSAmJiAhY19iYWxhbmNlcykge1xuXHRcdFx0ZmtfcmVzb2x2ZV90b3RhbChmb3JtYXRfZmlhdCh5Z190b3RhbC50b051bWJlcigpLCAndXNkJykpO1xuXHRcdH1cblx0fVxuXG5cdHR5cGUgU3VibWl0dGVyID0gKHpfb3V0OiBQcm9taXNhYmxlPEJpZ051bWJlcj4pID0+IFByb21pc2U8QmlnTnVtYmVyPjtcblxuXHQvLyBhc3luYyBmdW5jdGlvbiB3aXRoX2JhbGFuY2U8d192YWx1ZT4oZHBfdGhpbmc6IFByb21pc2FibGU8d192YWx1ZT4pOiBQcm9taXNlPFt3X3ZhbHVlLCBTdWJtaXR0ZXJdPiB7XG5cdC8vIFx0Y19iYWxhbmNlcyArPSAxO1xuXG5cdC8vIFx0Y29uc3Qgd192YWx1ZSA9IGF3YWl0IGRwX3RoaW5nO1xuXG5cdC8vIFx0cmV0dXJuIFtcblx0Ly8gXHRcdHdfdmFsdWUsXG5cdC8vIFx0XHRhc3luYyh6X291dDogUHJvbWlzYWJsZTxCaWdOdW1iZXI+KTogUHJvbWlzZTxCaWdOdW1iZXI+ID0+IHtcblx0Ly8gXHRcdFx0Y29uc3QgeWdfYmFsYW5jZSA9IGF3YWl0IHpfb3V0O1xuXG5cdC8vIFx0XHRcdHlnX3RvdGFsID0geWdfdG90YWwucGx1cyh5Z19iYWxhbmNlKTtcblxuXHQvLyBcdFx0XHRjaGVja190b3RhbCgpO1xuXHQvLyBcdFx0XHRyZXR1cm4geWdfYmFsYW5jZTtcblx0Ly8gXHRcdH0sXG5cdC8vIFx0XTtcblx0Ly8gfVxuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfbmF0aXZlX2JhbGFuY2VzKCkge1xuXHRcdGxldCBoX2JhbGFuY2VzOiBEaWN0PEJhbGFuY2VCdW5kbGU+O1xuXHRcdHRyeSB7XG5cdFx0XHRoX2JhbGFuY2VzID0gYXdhaXQgJHl3X25ldHdvcmtfYWN0aXZlLmJhbmtCYWxhbmNlcygkeXdfb3duZXIpO1xuXHRcdH1cblx0XHRjYXRjaChlX25ldHdvcmspIHtcblx0XHRcdHN5c2Vycih7XG5cdFx0XHRcdGVycm9yOiBlX25ldHdvcmsgYXMgRXJyb3IsXG5cdFx0XHRcdHRleHQ6ICdOZXR3b3JrIGVycm9yJyxcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFfb3V0czogW3N0cmluZywgTmF0aXZlQ29pbiwgQ29pbiwgU3VibWl0dGVyXVtdID0gW107XG5cblx0XHRmb3IoY29uc3QgW3NpX2NvaW4sIGdfY29pbl0gb2Ygb2RlKCR5d19jaGFpbi5jb2lucykpIHtcblx0XHRcdGNvbnN0IGdfYnVuZGxlID0gaF9iYWxhbmNlc1tzaV9jb2luXTtcblxuXHRcdFx0aWYoIWdfYnVuZGxlIHx8ICcwJyA9PT0gZ19idW5kbGUuYmFsYW5jZS5hbW91bnQpIHtcblx0XHRcdFx0YV9ub19nYXMucHVzaChzaV9jb2luKTtcblx0XHRcdH1cblxuXHRcdFx0Y19iYWxhbmNlcyArPSAxO1xuXG5cdFx0XHRhX291dHMucHVzaChbXG5cdFx0XHRcdHNpX2NvaW4sXG5cdFx0XHRcdCR5d19jaGFpbi5jb2luc1tzaV9jb2luXSxcblx0XHRcdFx0Z19idW5kbGU/LmJhbGFuY2UgfHwge2Ftb3VudDonMCcsIGRlbm9tOmdfY29pbi5kZW5vbX0sXG5cdFx0XHRcdGFzeW5jKHpfb3V0OiBQcm9taXNhYmxlPEJpZ051bWJlcj4pOiBQcm9taXNlPEJpZ051bWJlcj4gPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHlnX2JhbGFuY2UgPSBhd2FpdCB6X291dDtcblxuXHRcdFx0XHRcdHlnX3RvdGFsID0geWdfdG90YWwucGx1cyh5Z19iYWxhbmNlKTtcblxuXHRcdFx0XHRcdGNoZWNrX3RvdGFsKCk7XG5cdFx0XHRcdFx0cmV0dXJuIHlnX2JhbGFuY2U7XG5cdFx0XHRcdH0sXG5cdFx0XHRdKTtcblx0XHR9XG5cblx0XHRhX25vX2dhcyA9IGFfbm9fZ2FzO1xuXG5cdFx0cmV0dXJuIGFfb3V0cztcblx0fVxuXG5cblx0Y29uc3QgSF9GQVVDRVRTID0ge1xuXHRcdCd0aGV0YS10ZXN0bmV0LTAwMSc6ICdodHRwczovL2Rpc2NvcmQuY29tL2NoYW5uZWxzLzY2OTI2ODM0NzczNjY4NjYxMi85NTM2OTc3OTM0NzY4MjEwOTInLFxuXHRcdCdwdWxzYXItMic6ICdodHRwczovL2ZhdWNldC5zZWNyZXR0ZXN0bmV0LmlvLycsXG5cdH07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LnRlc3RuZXQtcmVtaW5kZXIge1xuXHRcdC5mb250KHRpbnkpO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdHRyYW5zZm9ybTogc2NhbGVYKDEuMjUpO1xuXHRcdG1hcmdpbi1ib3R0b206IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykgLSB2YXIoLS1pbmxpbmUtcGFkZGluZykpO1xuXHR9XG5cblx0LnN1YmluZm8ge1xuXHRcdGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdHBhZGRpbmctdG9wOiB2YXIoLS11aS1wYWRkaW5nKTtcblx0fVxuXG5cdC5uby1nYXMge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRnYXA6IHZhcigtLWlubGluZS1wYWRkaW5nKTtcblx0XHQubWVzc2FnZSB7XG5cdFx0XHQuZm9udCh0aW55KTtcblx0XHR9XG5cdH1cblxuXHQub3duZXItYWRkcmVzcyB7XG5cdH1cblxuPC9zdHlsZT5cblxuPFNjcmVlbiBkZWJ1Zz0nSG9sZGluZ3NIb21lJyBuYXYgcm9vdCBrZXllZD5cblxuXHQ8SGVhZGVyIHNlYXJjaCBuZXR3b3JrIGFjY291bnQgPlxuXHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInRpdGxlXCI+XG5cblx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0PC9IZWFkZXI+XG5cblx0eyNpZiAkeXdfY2hhaW4udGVzdG5ldH1cblx0XHQ8ZGl2IGNsYXNzPVwidGVzdG5ldC1yZW1pbmRlciBuby1tYXJnaW5cIj5cblx0XHRcdFRFU0VUTkVUXG5cdFx0PC9kaXY+XG5cdHsvaWZ9XG5cblx0PCEtLSB0aXRsZT17Zm9ybWF0X2ZpYXQoeF91c2RfYmFsYW5jZSl9IC0tPlxuXHQ8UG9ydHJhaXRcblx0XHR0aXRsZT17ZHBfdG90YWx9XG5cdFx0c3VidGl0bGU9eyR5d19hY2NvdW50Lm5hbWV9XG5cdFx0cmVzb3VyY2U9eyR5d19hY2NvdW50fVxuXHRcdHJlc291cmNlUGF0aD17JHl3X2FjY291bnRfcmVmfVxuXHRcdGFjdGlvbnM9e3tcblx0XHRcdHNlbmQ6IHtcblx0XHRcdFx0bGFiZWw6ICdTZW5kJyxcblx0XHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRjcmVhdG9yOiBTZW5kLFxuXHRcdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdFx0ZnJvbTogJHl3X2FjY291bnQsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblx0XHRcdHJlY3Y6IHtcblx0XHRcdFx0bGFiZWw6ICdSZWNlaXZlJyxcblx0XHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0XHRwb3B1cF9yZWNlaXZlKCR5d19hY2NvdW50X3JlZik7XG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdFx0YWRkOiB7XG5cdFx0XHRcdGxhYmVsOiAnQWRkIFRva2VuJyxcblx0XHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRjcmVhdG9yOiBUb2tlbnNBZGQsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdH19XG5cdC8+XG5cblx0eyNrZXkgJHl3X2NoYWlufVxuXHRcdHsjaWYgYV9ub19nYXMubGVuZ3RofVxuXHRcdFx0PGRpdiBjbGFzcz1cIm5vLWdhcyB0ZXh0LWFsaWduX2NlbnRlciBzdWJpbmZvXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJtZXNzYWdlXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+V2FybmluZzo8L3NwYW4+IHlvdSBkb24ndCBoYXZlIGFueSB7JHl3X2NoYWluLnRlc3RuZXQ/ICd0ZXN0bmV0ICc6Jyd9e2Ffbm9fZ2FzLmpvaW4oJyBvciAnKX0gdG8gcGF5IGdhcyBmZWVzLlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYnV0dG9uc1wiPlxuXHRcdFx0XHRcdHsjaWYgJHl3X2NoYWluLnRlc3RuZXR9XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwicGlsbFwiIG9uOmNsaWNrPXsoKSA9PiBvcGVuX2V4dGVybmFsX2xpbmsoSF9GQVVDRVRTWyR5d19jaGFpbi5pZF0pfT5HZXQge2Ffbm9fZ2FzLmpvaW4oJyBvciAnKX0gZnJvbSBmYXVjZXQ8L2J1dHRvbj5cblx0XHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwicGlsbFwiPkJ1eSB7YV9ub19nYXMuam9pbignIG9yICcpfTwvYnV0dG9uPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0ey9pZn1cblxuXHRcdDxkaXYgY2xhc3M9XCJvd25lci1hZGRyZXNzIHN1YmluZm9cIj5cblx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9eyR5d19vd25lcn0gY29weWFibGU9J3RleHQnIC8+XG5cdFx0PC9kaXY+XG5cdHsva2V5fVxuXG5cblx0PEdhcCAvPlxuXG5cdDwhLS0geyNrZXkgYV9ob2xkaW5nc31cblx0XHQ8SG9sZGluZ3NMaXN0IGhvbGRpbmdzPXthX2hvbGRpbmdzfSAvPlxuXHR7L2tleX0gLS0+XG5cblx0eyNrZXkgJHl3X25ldHdvcmtfYWN0aXZlfVxuXHRcdDxkaXYgY2xhc3M9XCJyb3dzIG5vLW1hcmdpblwiPlxuXHRcdFx0PCEtLSBuYXRpdmUgY29pbihzKSAtLT5cblx0XHRcdHsjYXdhaXQgbG9hZF9uYXRpdmVfYmFsYW5jZXMoKX1cblx0XHRcdFx0eyNlYWNoIG9kZSgkeXdfY2hhaW4uY29pbnMpIGFzIFtzaV9jb2luLCBnX2J1bmRsZV19XG5cdFx0XHRcdFx0e0Bjb25zdCBwX2VudGl0eSA9IEVudGl0aWVzLmhvbGRpbmdQYXRoRm9yKCR5d19vd25lciwgc2lfY29pbil9XG5cdFx0XHRcdFx0PFJvdyBsb2NrSWNvbiBkZXRhaWw9J05hdGl2ZSBDb2luJ1xuXHRcdFx0XHRcdFx0bmFtZT17c2lfY29pbn1cblx0XHRcdFx0XHRcdHBmcD17JHl3X2NoYWluLnBmcH1cblx0XHRcdFx0XHRcdGFtb3VudD17Zm9yZXZlcignJyl9XG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0Y3JlYXRvcjogSG9sZGluZ1ZpZXcsXG5cdFx0XHRcdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGVudGl0eVJlZjogcF9lbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHs6dGhlbiBhX2JhbGFuY2VzfVxuXHRcdFx0XHR7I2VhY2ggYV9iYWxhbmNlcyBhcyBbc2lfY29pbiwgZ19jb2luLCBnX2JhbGFuY2UsIGZfc3VibWl0XX1cblx0XHRcdFx0e0Bjb25zdCBwX2VudGl0eSA9IEVudGl0aWVzLmhvbGRpbmdQYXRoRm9yKCR5d19vd25lciwgc2lfY29pbil9XG5cdFx0XHRcdFx0e0Bjb25zdCBnX3Jlc291cmNlID0ge1xuXHRcdFx0XHRcdFx0bmFtZTogc2lfY29pbixcblx0XHRcdFx0XHRcdHBmcDogJHl3X2NoYWluLnBmcCxcblx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdHtAY29uc3QgZHBfd29ydGggPSBmX3N1Ym1pdCh0b19maWF0KGdfYmFsYW5jZSwgZ19jb2luKSl9XG5cdFx0XHRcdFx0PFJvdyBsb2NrSWNvbiBkZXRhaWw9J05hdGl2ZSBDb2luJ1xuXHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoPXtwX2VudGl0eX1cblx0XHRcdFx0XHRcdHJlc291cmNlPXtnX3Jlc291cmNlfVxuXHRcdFx0XHRcdFx0YW1vdW50PXthc19hbW91bnQoZ19iYWxhbmNlLCBnX2NvaW4pfVxuXHRcdFx0XHRcdFx0ZmlhdD17ZHBfd29ydGgudGhlbih5ZyA9PiBmb3JtYXRfZmlhdCh5Zy50b051bWJlcigpLCAndXNkJykpfVxuXHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdGNyZWF0b3I6IEhvbGRpbmdWaWV3LFxuXHRcdFx0XHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbnRpdHlSZWY6IHBfZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR7L2VhY2h9XG5cdFx0XHR7L2F3YWl0fVxuXG5cblx0XHRcdHsjYXdhaXQgRW50aXRpZXMucmVhZEZ1bmdpYmxlVG9rZW5zKCR5d19jaGFpbil9XG5cdFx0XHRcdExvYWRpbmcgdG9rZW5zLi4uXG5cdFx0XHR7OnRoZW4gaF9mdW5naWJsZXN9XG5cdFx0XHRcdHsjZWFjaCBvZGUobWVyZ2VfZnVuZ2libGVfdG9rZW5zKGhfZnVuZ2libGVzKSkgYXMgW3BfdG9rZW4sIGdfdG9rZW5dfVxuXHRcdFx0XHRcdHtnX3Rva2VuLnNwZWN9XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHsvYXdhaXR9XG5cdFx0PC9kaXY+XG5cdHsva2V5fVxuPC9TY3JlZW4+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuXHRpbXBvcnQgdHlwZSB7IENvbXBsZXRlZCB9IGZyb20gJyMvZW50cnkvZmxvdyc7XG5cblx0aW1wb3J0IHR5cGUge0FjY291bnQsIEFjY291bnRQYXRofSBmcm9tICcjL21ldGEvYWNjb3VudCc7XG5cdGltcG9ydCB0eXBlIHtCZWNoMzJ9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB7QWNjb3VudHN9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQge0NoYWluc30gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQge3l3X2FjY291bnRfcmVmLCB5d19jaGFpbn0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IEFjdGlvbnNMaW5lIGZyb20gJy4uL3VpL0FjdGlvbnNMaW5lLnN2ZWx0ZSc7XG5cdGltcG9ydCBBZGRyZXNzIGZyb20gJy4uL3VpL0FkZHJlc3Muc3ZlbHRlJztcblx0aW1wb3J0IEZpZWxkIGZyb20gJy4uL3VpL0ZpZWxkLnN2ZWx0ZSc7XG5cdGltcG9ydCBJbmxpbmVUYWdzIGZyb20gJy4uL3VpL0lubGluZVRhZ3Muc3ZlbHRlJztcblx0aW1wb3J0IEluZm8gZnJvbSAnIyMvdWkvSW5mby5zdmVsdGUnO1xuXHRpbXBvcnQge1NjcmVlbiwgdHlwZSBQYWdlfSBmcm9tICcuL19zY3JlZW5zJztcblxuXG5cdGV4cG9ydCBsZXQgYWNjb3VudDogQWNjb3VudFBhdGg7XG5cdGNvbnN0IHBfYWNjb3VudCA9IGFjY291bnQ7XG5cblx0bGV0IGdfYWNjb3VudDogQWNjb3VudFsnaW50ZXJmYWNlJ107XG5cblx0bGV0IHNfbmFtZSA9ICcnO1xuXHRsZXQgc2FfYWNjb3VudDogQmVjaDMyLlN0cmluZztcblxuXHQkOiBiX2Zvcm1fdmFsaWQgPSAhIXNfbmFtZTtcblxuXHQkOiBzYV9hY2NvdW50ID0gZ19hY2NvdW50PyBDaGFpbnMuYWRkcmVzc0ZvcihnX2FjY291bnQucHVia2V5LCAkeXdfY2hhaW4pOiAnJztcblxuXHRjb25zdCBjb21wbGV0ZWQgPSBnZXRDb250ZXh0PENvbXBsZXRlZCB8IHVuZGVmaW5lZD4oJ2NvbXBsZXRlZCcpO1xuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9hY2NvdW50KCkge1xuXHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXHRcdGdfYWNjb3VudCA9IGtzX2FjY291bnRzLmF0KHBfYWNjb3VudCkhO1xuXHRcdHNfbmFtZSA9IGdfYWNjb3VudC5uYW1lO1xuXHR9XG5cblx0YXN5bmMgZnVuY3Rpb24gc2F2ZV9hY2NvdW50KCkge1xuXHRcdE9iamVjdC5hc3NpZ24oZ19hY2NvdW50LCB7XG5cdFx0XHRuYW1lOiBzX25hbWUsXG5cdFx0fSk7XG5cblx0XHRhd2FpdCBBY2NvdW50cy5vcGVuKGtzX2FjY291bnRzID0+IGtzX2FjY291bnRzLnB1dChnX2FjY291bnQpKTtcblxuXHRcdGlmKGNvbXBsZXRlZCkge1xuXHRcdFx0Y29tcGxldGVkKHRydWUpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGtfcGFnZS5yZXNldCgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIGZ1bmN0aW9uIHNhdmUoKSB7XG5cdC8vIFx0aWYoIWJfZm9ybV92YWxpZCkgcmV0dXJuO1xuXG5cdC8vIFx0Y29uc3QgZ19zYXZlID0ge1xuXHQvLyBcdFx0bGFiZWw6IGFjY291bnROYW1lLFxuXHQvLyBcdFx0dGFnUmVmczogYV90YWdzLm1hcChrID0+IGsuZGVmLmlyaSksXG5cdC8vIFx0fTtcblxuXHQvLyBcdGlmKGFjY291bnQpIHtcblx0Ly8gXHRcdE9iamVjdC5hc3NpZ24oYWNjb3VudC5kZWYsIGdfc2F2ZSk7XG5cblx0Ly8gXHRcdHJlc3RhcnQoKTtcblxuXHQvLyBcdFx0aWYoVGFza3MuQUREX1RBRyA9PT0gJHl3X3Rhc2spIHtcblx0Ly8gXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdC8vIFx0XHRcdFx0JHl3X3Rhc2sgPSAtJHl3X3Rhc2s7XG5cdC8vIFx0XHRcdH0sIDEyMDApO1xuXHQvLyBcdFx0fVxuXHQvLyBcdH1cblx0Ly8gXHRlbHNlIHtcblx0Ly8gXHRcdGNvbnN0IGdkX2FjY291bnQgPSBBY2NvdW50LkRlZi5mcm9tQ29uZmlnKHtcblx0Ly8gXHRcdFx0Li4uZ19zYXZlLFxuXHQvLyBcdFx0XHRwdWJrZXk6IHNhX2FjY291bnQucmVwbGFjZSgvXlxcdysxL2csICcnKSxcblx0Ly8gXHRcdFx0aWNvblJlZjogcF9pY29uLFxuXHQvLyBcdFx0fSk7XG5cblx0Ly8gXHRcdGNvbnN0IGtfYWNjb3VudCA9IEhfQUNDT1VOVFNbZ2RfYWNjb3VudC5pcmldID0gbmV3IEFjY291bnQoZ2RfYWNjb3VudCk7XG5cblx0Ly8gXHRcdHJlc3RhcnQoKTtcblxuXHQvLyBcdFx0cHVzaF9zY3JlZW4oQWNjb3VudFZpZXcsIHtcblx0Ly8gXHRcdFx0YWNjb3VudDoga19hY2NvdW50LFxuXHQvLyBcdFx0fSk7XG5cdC8vIFx0fVxuXHQvLyB9XG5cbjwvc2NyaXB0PlxuXG48U2NyZWVuPlxuXHQ8aDM+XG5cdFx0e2FjY291bnQ/ICdFZGl0JzogJ05ldyd9IGFjY291bnRcblx0PC9oMz5cblxuXHR7I2F3YWl0IGxvYWRfYWNjb3VudCgpfVxuXHRcdExvYWRpbmcgYWNjb3VudHMuLi5cblx0ezp0aGVufVxuXHRcdDxGaWVsZCBrZXk9XCJwcm9maWxlLWljb25cIiBuYW1lPVwiUHJvZmlsZSBpY29uXCI+XG5cdFx0XHQ8IS0tIDxJY29uRWRpdG9yIGludGVudD0ncGVyc29uJyBpY29uUmVmPXtwX2ljb259IC8+IC0tPlxuXHRcdDwvRmllbGQ+XG5cblx0XHQ8RmllbGQga2V5PVwiYWNjb3VudC1uYW1lXCIgbmFtZT1cIk5hbWVcIj5cblx0XHRcdDxpbnB1dCBpZD1cImFjY291bnQtbmFtZVwiIHR5cGU9XCJ0ZXh0XCIgYmluZDp2YWx1ZT17c19uYW1lfSBwbGFjZWhvbGRlcj1cIlNhdG9zaGlcIj5cblx0XHQ8L0ZpZWxkPlxuXG5cdFx0PCEtLSA8RmllbGQga2V5PVwiYWNjb3VudC1wYXRoXCIgbmFtZT1cIkRlcml2YXRpb24gcGF0aFwiPlxuXHRcdFx0PEluZm8ga2V5PVwiYWNjb3VudC1wYXRoXCI+XG5cdFx0XHRcdG0vNDQnLzExOCcvMCcvMC97T2JqZWN0LnZhbHVlcyhIX0FDQ09VTlRTKS5sZW5ndGh9XG5cdFx0XHQ8L0luZm8+XG5cdFx0PC9GaWVsZD4gLS0+XG5cblx0XHQ8RmllbGQga2V5PVwiYWNjb3VudC1hZGRyZXNzXCIgbmFtZT1cIlB1YmxpYyBhZGRyZXNzXCI+XG5cdFx0XHQ8SW5mbyBhZGRyZXNzIGtleT1cImFjY291bnQtYWRkcmVzc1wiPlxuXHRcdFx0XHQ8QWRkcmVzcyBjb3B5YWJsZSBhZGRyZXNzPXtzYV9hY2NvdW50fSAvPlxuXHRcdFx0PC9JbmZvPlxuXHRcdDwvRmllbGQ+XG5cblx0XHQ8RmllbGQga2V5PVwiYWNjb3VudC10YWdzXCIgbmFtZT1cIkFkZCB0YWdzXCI+XG5cdFx0XHQ8SW5saW5lVGFncyBlZGl0YWJsZSByZXNvdXJjZVBhdGg9e3BfYWNjb3VudH0gLz5cblx0XHQ8L0ZpZWxkPlxuXG5cdFx0PEFjdGlvbnNMaW5lIGNhbmNlbD17IWNvbXBsZXRlZH0gYmFjayBjb25maXJtPXtbJ0ZpbmlzaCcsIHNhdmVfYWNjb3VudCwgIWJfZm9ybV92YWxpZF19IC8+XG5cblx0XHQ8IS0tIDxkaXYgY2xhc3M9XCJhY3Rpb24tbGluZSBjbGlja2FibGVcIj5cblx0XHRcdDxidXR0b24gb246Y2xpY2s9eygpID0+IHBvcCgpfT5cblx0XHRcdFx0Q2FuY2VsXG5cdFx0XHQ8L2J1dHRvbj5cblxuXHRcdFx0PGJ1dHRvbiBjbGFzcz1cInByaW1hcnlcIiByZWFkb25seT17IWJfZm9ybV92YWxpZH0gb246Y2xpY2s9eygpID0+IHNhdmUoKX0+XG5cdFx0XHRcdEZpbmlzaFxuXHRcdFx0PC9idXR0b24+XG5cdFx0PC9kaXY+IC0tPlxuXHR7L2F3YWl0fVxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IHtcblx0XHRTY3JlZW4sXG5cdFx0SGVhZGVyLFxuXHRcdHR5cGUgUGFnZSxcblx0fSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRpbXBvcnQgdHlwZSB7QWNjb3VudFBhdGh9IGZyb20gJyMvbWV0YS9hY2NvdW50Jztcblx0aW1wb3J0IEFjY291bnRFZGl0IGZyb20gJy4vQWNjb3VudEVkaXQuc3ZlbHRlJztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQuaGQtcGF0aCB7XG5cdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48U2NyZWVuIG5hdiBzbGlkZXM+XG5cdDxIZWFkZXIgcG9wc1xuXHRcdHRpdGxlPVwiQWRkIGFjY291bnRcIlxuXHQ+XG5cdDwvSGVhZGVyPlxuXG5cdDxocj5cblxuXHQ8cD5cblx0XHRDcmVhdGUgYSBuZXcgYWNjb3VudCwgaW1wb3J0IGFuIGV4aXN0aW5nIG9uZSwgb3IgY29ubmVjdCB0byBhIGhhcmR3YXJ3YXJlIHdhbGxldC5cblx0PC9wPlxuXG5cdDxkaXYgY2xhc3M9XCJhY3Rpb24td2FsbFwiPlxuXHRcdDxidXR0b24gY2xhc3M9XCJwcmltYXJ5XCIgb246Y2xpY2s9eygpID0+IGtfcGFnZS5wdXNoKHtcblx0XHRcdGNyZWF0b3I6IEFjY291bnRFZGl0LFxuXHRcdH0pfT5cblx0XHRcdENyZWF0ZSBuZXcgU3RhclNlaGxsIGFjY291bnRcblx0XHQ8L2J1dHRvbj5cblxuXHRcdDxidXR0b24gb246Y2xpY2s9eygpID0+IGtfcGFnZS5wdXNoKHtcblx0XHRcdGNyZWF0b3I6IERlYWRFbmQsXG5cdFx0fSl9PlxuXHRcdFx0SW1wb3J0IHdpdGggcHJpdmF0ZSBrZXlcblx0XHQ8L2J1dHRvbj5cblxuXHRcdDxidXR0b24gb246Y2xpY2s9eygpID0+IGtfcGFnZS5wdXNoKHtcblx0XHRcdGNyZWF0b3I6IERlYWRFbmQsXG5cdFx0fSl9PlxuXHRcdFx0Q29ubmVjdCB0byBoYXJkd2FyZVxuXHRcdDwvYnV0dG9uPlxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHtBY2NvdW50LCBBY2NvdW50UGF0aH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXHRpbXBvcnQge0FjY291bnRzfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHtDaGFpbnN9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblxuXHRpbXBvcnQge2dldENvbnRleHR9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7cG9wdXBfcmVjZWl2ZX0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi4vdWkvQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgUG9ydHJhaXQgZnJvbSAnLi4vdWkvUG9ydHJhaXQuc3ZlbHRlJztcblx0aW1wb3J0IEFjY291bnRFZGl0IGZyb20gJy4vQWNjb3VudEVkaXQuc3ZlbHRlJztcblx0aW1wb3J0IFNlbmQgZnJvbSAnLi9TZW5kLnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHtcblx0XHRTY3JlZW4sXG5cdFx0SGVhZGVyLFxuXHRcdHR5cGUgUGFnZSxcblx0fSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRleHBvcnQgbGV0IGFjY291bnRSZWY6IEFjY291bnRQYXRoO1xuXHRjb25zdCBwX2FjY291bnQgPSBhY2NvdW50UmVmO1xuXG5cdGxldCBnX2FjY291bnQ6IEFjY291bnRbJ2ludGVyZmFjZSddO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYWNjb3VudCgpOiBQcm9taXNlPEFjY291bnRbJ2ludGVyZmFjZSddPiB7XG5cdFx0Y29uc3Qga3NfYWNjb3VudHMgPSBhd2FpdCBBY2NvdW50cy5yZWFkKCk7XG5cblx0XHRyZXR1cm4gZ19hY2NvdW50ID0ga3NfYWNjb3VudHMuYXQocF9hY2NvdW50KSE7XG5cdH1cblxuXHRjb25zdCBnY19hY3Rpb25zID0ge1xuXHRcdHNlbmQ6IHtcblx0XHRcdGxhYmVsOiAnU2VuZCcsXG5cdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogU2VuZCxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0ZnJvbTogQ2hhaW5zLmFkZHJlc3NGb3IoZ19hY2NvdW50LnB1YmtleSksXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0cmVjdjoge1xuXHRcdFx0bGFiZWw6ICdSZWNlaXZlJyxcblx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdHBvcHVwX3JlY2VpdmUocF9hY2NvdW50KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHRlZGl0OiB7XG5cdFx0XHRsYWJlbDogJ0VkaXQnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IEFjY291bnRFZGl0LFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRhY2NvdW50OiBwX2FjY291bnQsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdH07XG5cbjwvc2NyaXB0PlxuXG48IS0tIFxuPHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicGZwXCI+XG5cdHsjaWYgSF9JQ09OU1thY2NvdW50LmRlZi5pY29uUmVmXX1cblx0XHQ8UHV0IGVsZW1lbnQ9e0hfSUNPTlNbYWNjb3VudC5kZWYuaWNvblJlZl0ucmVuZGVyKCl9IC8+XG5cdHs6ZWxzZX1cblx0XHQ8c3BhbiBjbGFzcz1cInBmcC1nZW5cIj5cblx0XHRcdHthY2NvdW50LmRlZi5sYWJlbFswXX1cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG48L3N2ZWx0ZTpmcmFnbWVudD4gLS0+XG5cbjxTY3JlZW4gbmF2PlxuXHQ8SGVhZGVyIHBvcHMgc2VhcmNoIG5ldHdvcmtcblx0XHR0aXRsZT1cIkFjY291bnRcIlxuXHQ+PC9IZWFkZXI+XG5cblx0eyNhd2FpdCBsb2FkX2FjY291bnQoKX1cblx0XHRMb2FkaW5nLi4uXG5cdHs6dGhlbn1cblx0XHQ8UG9ydHJhaXRcblx0XHRcdHJlc291cmNlPXtnX2FjY291bnR9XG5cdFx0XHRyZXNvdXJjZVBhdGg9e3BfYWNjb3VudH1cblx0XHRcdGFjdGlvbnM9e2djX2FjdGlvbnN9XG5cdFx0PlxuXHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwic3VidGl0bGVcIj5cblx0XHRcdFx0PEFkZHJlc3MgY29weWFibGUgYWRkcmVzcz17Q2hhaW5zLmFkZHJlc3NGb3IoZ19hY2NvdW50LnB1YmtleSl9IC8+XG5cdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHQ8L1BvcnRyYWl0PlxuXHR7L2F3YWl0fVxuXG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgdHlwZSB7IEFjY291bnQsIEFjY291bnRQYXRoIH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IHl3X2NoYWluIH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi4vdWkvQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgUm93IGZyb20gJy4uL3VpL1Jvdy5zdmVsdGUnO1xuXHRpbXBvcnQgQWNjb3VudENyZWF0ZSBmcm9tICcuL0FjY291bnRDcmVhdGUuc3ZlbHRlJztcblx0aW1wb3J0IEFjY291bnRWaWV3IGZyb20gJy4vQWNjb3VudFZpZXcuc3ZlbHRlJztcblxuXHRpbXBvcnQge1xuXHRcdFNjcmVlbixcblx0XHRIZWFkZXIsXG5cdFx0U3ViSGVhZGVyLFxuXHRcdHR5cGUgUGFnZSxcblx0fSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0bGV0IGFfYWNjb3VudHM6IFtBY2NvdW50UGF0aCwgQWNjb3VudFsnaW50ZXJmYWNlJ11dW107XG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYWNjb3VudHMoKTogUHJvbWlzZTx0eXBlb2YgYV9hY2NvdW50cz4ge1xuXHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXG5cdFx0cmV0dXJuIGFfYWNjb3VudHMgPSBrc19hY2NvdW50cy5lbnRyaWVzKCk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQuaGQtcGF0aCB7XG5cdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdBY2NvdW50cycgbmF2IHJvb3Q+XG5cdDxIZWFkZXIgc2VhcmNoIG5ldHdvcmsgYWNjb3VudFxuXHQ+XG5cdDwvSGVhZGVyPlxuXG5cdDxTdWJIZWFkZXJcblx0XHR0aXRsZT1cIkFjY291bnRzXCJcblx0XHRvbjphZGRfbmV3PXsoKSA9PiBrX3BhZ2UucHVzaCh7XG5cdFx0XHRjcmVhdG9yOiBBY2NvdW50Q3JlYXRlLFxuXHRcdH0pfVxuXHQvPlxuXG5cdDxkaXYgY2xhc3M9XCJyb3dzIG5vLW1hcmdpblwiPlxuXHRcdHsjYXdhaXQgbG9hZF9hY2NvdW50cygpfVxuXHRcdFx0TG9hZGluZy4uLlxuXHRcdHs6dGhlbn1cblx0XHRcdHsja2V5ICR5d19jaGFpbn1cblx0XHRcdFx0eyNlYWNoIGFfYWNjb3VudHMgYXMgW3BfYWNjb3VudCwgZ19hY2NvdW50XX1cblx0XHRcdFx0XHR7QGNvbnN0IHNhX293bmVyID0gQ2hhaW5zLmFkZHJlc3NGb3IoZ19hY2NvdW50LnB1YmtleSl9XG5cdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0cmVzb3VyY2U9e2dfYWNjb3VudH1cblx0XHRcdFx0XHRcdHJlc291cmNlUGF0aD17cF9hY2NvdW50fVxuXHRcdFx0XHRcdFx0YWRkcmVzcz17c2Ffb3duZXJ9XG5cdFx0XHRcdFx0XHRpY29uQ2xhc3M9eydzcXVhcmUgcGZwJ31cblx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiBrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdGNyZWF0b3I6IEFjY291bnRWaWV3LFxuXHRcdFx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0XHRcdGFjY291bnRSZWY6IHBfYWNjb3VudCxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0pfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cImRldGFpbFwiPlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaGQtcGF0aFwiPlxuXHRcdFx0XHRcdFx0XHRcdFN0YXJTaGVsbCAtIC0gbS80NCcvMTE4Jy8wJy8wLz8/XG5cdFx0XHRcdFx0XHRcdFx0PCEtLSBTdGFyU2hlbGwgLSBtLzQ0Jy8xMTgnLzAnLzAveytnX2FjY291bnQuaWQtMX0gLS0+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9e3NhX293bmVyfSAvPlxuXHRcdFx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdFx0XHRcdFx0PC9Sb3c+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHsva2V5fVxuXHRcdHsvYXdhaXR9XG5cdDwvZGl2PlxuPC9TY3JlZW4+IiwibGV0IGlkID0gMTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SWQoKSB7XG4gIHJldHVybiBgc3ZlbHRlLXRhYnMtJHtpZCsrfWA7XG59XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cbiAgZXhwb3J0IGNvbnN0IFRBQlMgPSB7fTtcbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSwgc2V0Q29udGV4dCwgb25EZXN0cm95LCBvbk1vdW50LCB0aWNrIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuXG4gIGV4cG9ydCBsZXQgaW5pdGlhbFNlbGVjdGVkSW5kZXggPSAwO1xuXG4gIGNvbnN0IHRhYkVsZW1lbnRzID0gW107XG4gIGNvbnN0IHRhYnMgPSBbXTtcbiAgY29uc3QgcGFuZWxzID0gW107XG5cbiAgY29uc3QgY29udHJvbHMgPSB3cml0YWJsZSh7fSk7XG4gIGNvbnN0IGxhYmVsZWRCeSA9IHdyaXRhYmxlKHt9KTtcblxuICBjb25zdCBzZWxlY3RlZFRhYiA9IHdyaXRhYmxlKG51bGwpO1xuICBjb25zdCBzZWxlY3RlZFBhbmVsID0gd3JpdGFibGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kVXBkYXRlU2VsZWN0ZWQoYXJyLCBpdGVtLCBzZWxlY3RlZFN0b3JlKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBzZWxlY3RlZFN0b3JlLnVwZGF0ZShzZWxlY3RlZCA9PiBzZWxlY3RlZCA9PT0gaXRlbSA/IChhcnJbaW5kZXhdIHx8IGFyclthcnIubGVuZ3RoIC0gMV0pIDogc2VsZWN0ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJJdGVtKGFyciwgaXRlbSwgc2VsZWN0ZWRTdG9yZSkge1xuICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgIHNlbGVjdGVkU3RvcmUudXBkYXRlKHNlbGVjdGVkID0+IHNlbGVjdGVkIHx8IGl0ZW0pO1xuICAgIG9uRGVzdHJveSgoKSA9PiByZW1vdmVBbmRVcGRhdGVTZWxlY3RlZChhcnIsIGl0ZW0sIHNlbGVjdGVkU3RvcmUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdFRhYih0YWIpIHtcbiAgICBjb25zdCBpbmRleCA9IHRhYnMuaW5kZXhPZih0YWIpO1xuICAgIHNlbGVjdGVkVGFiLnNldCh0YWIpO1xuICAgIHNlbGVjdGVkUGFuZWwuc2V0KHBhbmVsc1tpbmRleF0pO1xuICB9XG5cbiAgc2V0Q29udGV4dChUQUJTLCB7XG4gICAgcmVnaXN0ZXJUYWIodGFiKSB7XG4gICAgICByZWdpc3Rlckl0ZW0odGFicywgdGFiLCBzZWxlY3RlZFRhYik7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyVGFiRWxlbWVudCh0YWJFbGVtZW50KSB7XG4gICAgICB0YWJFbGVtZW50cy5wdXNoKHRhYkVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICByZWdpc3RlclBhbmVsKHBhbmVsKSB7XG4gICAgICByZWdpc3Rlckl0ZW0ocGFuZWxzLCBwYW5lbCwgc2VsZWN0ZWRQYW5lbCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRhYixcblxuICAgIHNlbGVjdGVkVGFiLFxuICAgIHNlbGVjdGVkUGFuZWwsXG5cbiAgICBjb250cm9scyxcbiAgICBsYWJlbGVkQnlcbiAgfSk7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgc2VsZWN0VGFiKHRhYnNbaW5pdGlhbFNlbGVjdGVkSW5kZXhdKTtcbiAgfSk7XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgY29udHJvbHMudXBkYXRlKGNvbnRyb2xzRGF0YSA9PiAoey4uLmNvbnRyb2xzRGF0YSwgW3RhYnNbaV0uaWRdOiBwYW5lbHNbaV0uaWR9KSk7XG4gICAgICBsYWJlbGVkQnkudXBkYXRlKGxhYmVsZWRCeURhdGEgPT4gKHsuLi5sYWJlbGVkQnlEYXRhLCBbcGFuZWxzW2ldLmlkXTogdGFic1tpXS5pZH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc3ZlbHRlLXRhYnNfX3RhYicpKSB7XG4gICAgICBsZXQgc2VsZWN0ZWRJbmRleCA9IHRhYnMuaW5kZXhPZigkc2VsZWN0ZWRUYWIpO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICBzZWxlY3RlZEluZGV4ICs9IDE7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPiB0YWJzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxlY3RUYWIodGFic1tzZWxlY3RlZEluZGV4XSk7XG4gICAgICAgICAgdGFiRWxlbWVudHNbc2VsZWN0ZWRJbmRleF0uZm9jdXMoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgIHNlbGVjdGVkSW5kZXggLT0gMTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSB0YWJzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdFRhYih0YWJzW3NlbGVjdGVkSW5kZXhdKTtcbiAgICAgICAgICB0YWJFbGVtZW50c1tzZWxlY3RlZEluZGV4XS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJzdmVsdGUtdGFic1wiIG9uOmtleWRvd249e2hhbmRsZUtleURvd259PlxuICA8c2xvdD48L3Nsb3Q+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQsIG9uTW91bnQsIHRpY2sgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGltcG9ydCBnZXRJZCBmcm9tICcuL2lkJztcbiAgaW1wb3J0IHsgVEFCUyB9IGZyb20gJy4vVGFicy5zdmVsdGUnO1xuXG4gIGxldCB0YWJFbDtcblxuICBjb25zdCB0YWIgPSB7XG4gICAgaWQ6IGdldElkKClcbiAgfTtcbiAgY29uc3QgeyByZWdpc3RlclRhYiwgcmVnaXN0ZXJUYWJFbGVtZW50LCBzZWxlY3RUYWIsIHNlbGVjdGVkVGFiLCBjb250cm9scyB9ID0gZ2V0Q29udGV4dChUQUJTKTtcblxuICBsZXQgaXNTZWxlY3RlZDtcbiAgJDogaXNTZWxlY3RlZCA9ICRzZWxlY3RlZFRhYiA9PT0gdGFiO1xuXG4gIHJlZ2lzdGVyVGFiKHRhYik7XG5cbiAgb25Nb3VudChhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgdGljaygpO1xuICAgIHJlZ2lzdGVyVGFiRWxlbWVudCh0YWJFbCk7XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LnN2ZWx0ZS10YWJzX190YWIge1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRib3JkZXItYm90dG9tOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0Y29sb3I6ICMwMDAwMDA7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIHBhZGRpbmc6IDAuNWVtIDAuNzVlbTtcblx0fVxuXHRcbiAgLnN2ZWx0ZS10YWJzX190YWI6Zm9jdXMge1xuICAgIG91dGxpbmU6IHRoaW4gZG90dGVkO1xuICB9XG5cblx0LnN2ZWx0ZS10YWJzX19zZWxlY3RlZCB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICM0RjgxRTU7XG4gICAgY29sb3I6ICM0RjgxRTU7XG5cdH1cbjwvc3R5bGU+XG5cbjxsaVxuICBiaW5kOnRoaXM9e3RhYkVsfVxuICByb2xlPVwidGFiXCJcbiAgaWQ9e3RhYi5pZH1cbiAgYXJpYS1jb250cm9scz17JGNvbnRyb2xzW3RhYi5pZF19XG4gIGFyaWEtc2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gIHRhYmluZGV4PVwie2lzU2VsZWN0ZWQgPyAwIDogLTF9XCJcbiAgY2xhc3M6c3ZlbHRlLXRhYnNfX3NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICBjbGFzcz1cInN2ZWx0ZS10YWJzX190YWJcIlxuICBvbjpjbGljaz17KCkgPT4gc2VsZWN0VGFiKHRhYil9PlxuXHQ8c2xvdD48L3Nsb3Q+XG48L2xpPlxuIiwiPHN0eWxlPlxuXHQuc3ZlbHRlLXRhYnNfX3RhYi1saXN0IHtcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0NDQ0NDQztcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcblx0fVxuPC9zdHlsZT5cblxuPHVsIHJvbGU9XCJ0YWJsaXN0XCIgY2xhc3M9XCJzdmVsdGUtdGFic19fdGFiLWxpc3RcIj5cbiAgPHNsb3Q+PC9zbG90PlxuPC91bD5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGltcG9ydCBnZXRJZCBmcm9tICcuL2lkJztcbiAgaW1wb3J0IHsgVEFCUyB9IGZyb20gJy4vVGFicy5zdmVsdGUnO1xuXG4gIGNvbnN0IHBhbmVsID0ge1xuICAgIGlkOiBnZXRJZCgpXG4gIH07XG4gIGNvbnN0IHsgcmVnaXN0ZXJQYW5lbCwgc2VsZWN0ZWRQYW5lbCwgbGFiZWxlZEJ5IH0gPSBnZXRDb250ZXh0KFRBQlMpO1xuXG4gIHJlZ2lzdGVyUGFuZWwocGFuZWwpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLnN2ZWx0ZS10YWJzX190YWItcGFuZWwge1xuICAgIG1hcmdpbi10b3A6IDAuNWVtO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2IFxuICBpZD17cGFuZWwuaWR9XG4gIGFyaWEtbGFiZWxsZWRieT17JGxhYmVsZWRCeVtwYW5lbC5pZF19XG4gIGNsYXNzPVwic3ZlbHRlLXRhYnNfX3RhYi1wYW5lbFwiXG4gIHJvbGU9XCJ0YWJwYW5lbFwiPlxuICB7I2lmICRzZWxlY3RlZFBhbmVsID09PSBwYW5lbH1cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIHsvaWZ9XG48L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7eXdfYWNjb3VudCwgeXdfY2hhaW59IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdCwgQ29udGFjdFBhdGggfSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0XG5cdGltcG9ydCB7IEhlYWRlciwgdHlwZSBQYWdlLCBTY3JlZW4gfSBmcm9tICcuLi9zY3JlZW4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgQWRkcmVzcyBmcm9tICcjIy91aS9BZGRyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBQb3J0cmFpdCBmcm9tICcjIy91aS9Qb3J0cmFpdC5zdmVsdGUnO1xuXHRpbXBvcnQgU2VuZCBmcm9tICcjIy9zY3JlZW4vU2VuZC5zdmVsdGUnO1xuXHQvLyBpbXBvcnQgVHhuTGlzdCwgeyBUeG5Db250ZXh0IH0gZnJvbSAnIyMvdWkvVHhuTGlzdC5zdmVsdGUnO1xuXHRpbXBvcnQgQ29udGFjdEVkaXQgZnJvbSAnLi9Db250YWN0RWRpdC5zdmVsdGUnO1xuXHRpbXBvcnQgRGVhZEVuZCBmcm9tICcuL0RlYWRFbmQuc3ZlbHRlJztcblxuXG5cdGV4cG9ydCBsZXQgY29udGFjdFJlZjogQ29udGFjdFBhdGg7XG5cdGNvbnN0IHBfY29udGFjdCA9IGNvbnRhY3RSZWY7XG5cblx0bGV0IGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ107XG5cdHZvaWQgQWdlbnRzLmdldENvbnRhY3QocF9jb250YWN0KS50aGVuKGcgPT4gZ19jb250YWN0ID0gZyEpO1xuXG5cdCQ6IHNhX2NvbnRhY3QgPSBnX2NvbnRhY3Q/IENoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MpOiAnJztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0Y29uc3QgZ2NfYWN0aW9ucyA9IHtcblx0XHRzZW5kOiB7XG5cdFx0XHRsYWJlbDogJ1NlbmQnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IFNlbmQsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdHRvOiBDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHRlZGl0OiB7XG5cdFx0XHRsYWJlbDogJ0VkaXQnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IENvbnRhY3RFZGl0LFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRjb250YWN0UmVmOiBwX2NvbnRhY3QsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0ZGVsZXRlOiB7XG5cdFx0XHRsYWJlbDogJ0RlbGV0ZScsXG5cdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogRGVhZEVuZCxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdH07XG5cblx0Ly8gJDogYV90eG5zID0gQV9UWE5TLmZpbHRlcigoa190eG4pID0+IHtcblx0Ly8gXHRjb25zdCBnZF90eG4gPSBrX3R4bi5kZWY7XG5cblx0Ly8gXHRpZihzYV9jb250YWN0ID09PSBnZF90eG4uYWRkcmVzcykgcmV0dXJuIHRydWU7XG5cblx0Ly8gXHRjb25zdCBnX2Jhbmtpc2ggPSBrX3R4bi5iYW5raXNoKCR5d19hY2NvdW50LmFkZHJlc3MoJHl3X2NoYWluKSk7XG5cdC8vIFx0aWYoZ19iYW5raXNoKSB7XG5cdC8vIFx0XHRyZXR1cm4gc2FfY29udGFjdCA9PT0gZ19iYW5raXNoLmFkZHJlc3M7XG5cdC8vIFx0fVxuXG5cdC8vIFx0cmV0dXJuIGZhbHNlO1xuXHQvLyB9KTtcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblxuXG5cdC5wZnAtZ2VuIHtcblx0XHQuZm9udChodWdlLCBAc2l6ZTogMzBweCk7XG5cdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Ym9yZGVyLXJhZGl1czogMjAlO1xuXHRcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoZWxsaXBzZSBmYXJ0aGVzdC1zaWRlIGF0IGJvdHRvbSByaWdodCwgIzA3MDgwYSwgIzBmMTMxNyk7XG5cdH1cbjwvc3R5bGU+XG5cblxuPFNjcmVlbiBuYXYgc2xpZGVzPlxuXHQ8SGVhZGVyIHBvcHMgc2VhcmNoIG5ldHdvcmsgYWNjb3VudCAvPlxuXG5cdHsjaWYgIWdfY29udGFjdH1cblx0XHRMb2FkaW5nIGNvbnRhY3QuLi5cblx0ezplbHNlfVxuXHRcdDxQb3J0cmFpdFxuXHRcdFx0cmVzb3VyY2U9e2dfY29udGFjdH1cblx0XHRcdHJlc291cmNlUGF0aD17cF9jb250YWN0fVxuXHRcdFx0YWN0aW9ucz17Z2NfYWN0aW9uc31cblx0XHQ+XG5cdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0XHQ8QWRkcmVzcyBjb3B5YWJsZSBhZGRyZXNzPXtDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKX0gLz5cblx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PmFkZHJlc3Ncblx0XHQ8L1BvcnRyYWl0PlxuPCEtLSBcblx0XHQ8VHhuTGlzdFxuXHRcdFx0Y29udGV4dD17VHhuQ29udGV4dC5DT05UQUNUfVxuXHRcdFx0dHhucz17YV90eG5zfVxuXHRcdC8+IC0tPlxuXHQ8IS0tIFxuXHRcdDxkaXYgY2xhc3M9XCJ0eG5zIG5vLW1hcmdpblwiPlxuXHRcdFx0eyNpZiAhYV90eG5zLmxlbmd0aH1cblx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRObyB0cmFuc2FjdGlvbnMgeWV0XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9pZn1cblxuXHRcdFx0eyNlYWNoIGFfdHhucyBhcyBrX3R4bn1cblx0XHRcdFx0e0Bjb25zdCBnZF90eG4gPSBrX3R4bi5kZWZ9XG5cdFx0XHRcdHtAY29uc3Qga190b2tlbiA9IEhfQUREUkVTU19UT19UT0tFTltrX3R4bi5kZWYuYWRkcmVzc119XG5cdFx0XHRcdHtAY29uc3QgZ19iYW5raXNoID0ga190eG4uYmFua2lzaCgkeXdfYWNjb3VudC5hZGRyZXNzKCR5d19jaGFpbikpfVxuXHRcdFx0XHR7QGNvbnN0IGFfZGVidWcgPSBbZ19iYW5raXNoLCBrX3R4bl19XG5cdFx0XHRcdDwvIS0tIHtAZGVidWcgYV9kZWJ1Z30gLS0vPlxuXG5cdFx0XHRcdHsjaWYgVHhuLlR5cGUuUkVDViA9PT0gZ2RfdHhuLnR5cGV9XG5cdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0bmFtZT1cIlJlY2VpdmVkIFNDUlRcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0XHQ8LyEtLSBhcHByb3goZ2RfdHhuLmFtb3VudCkgLS0vPlxuXHRcdFx0XHR7OmVsc2UgaWYgVHhuLlR5cGUuU0VORCA9PT0gZ2RfdHhuLnR5cGV9XG5cdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0bmFtZT1cIlNlbnQgU0NSVFwiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdDwvUm93PlxuXHRcdFx0XHR7L2lmfVxuXHRcdFx0ey9lYWNofVxuXHRcdDwvZGl2PiAtLT5cblx0ey9pZn1cblxuPC9TY3JlZW4+IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTkgNXYxNEg1VjVoMTRtMC0ySDVjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptLTQuODYgOC44Ni0zIDMuODdMOSAxMy4xNCA2IDE3aDEybC0zLjg2LTUuMTR6XFxcIi8+XFxuPC9zdmc+XCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgU1hfSUNPTl9JTUFHRSBmcm9tICcjL2ljb24vaW1hZ2Uuc3ZnP3Jhdyc7XG5cdGltcG9ydCB0eXBlIHsgUGZwLCBQZnBQYXRoIH0gZnJvbSAnIy9tZXRhL3BmcCc7XG5cdGltcG9ydCB7IFBmcHMgfSBmcm9tICcjL3N0b3JlL3BmcHMnO1xuXHRpbXBvcnQgeyBGX05PT1AgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IFBmcERpc3BsYXkgZnJvbSAnLi9QZnBEaXNwbGF5LnN2ZWx0ZSc7XG5cdFxuXHRleHBvcnQgbGV0IHBmcFJlZjogJycgfCBQZnBQYXRoO1xuXHRjb25zdCBwX3BmcCA9IHBmcFJlZiB8fCAnJztcblxuXHRleHBvcnQgbGV0IG5hbWUgPSAnJztcblx0Y29uc3Qgc19uYW1lID0gbmFtZTtcblxuXHRleHBvcnQgbGV0IGludGVudDogJ3Rva2VuJyB8ICdwZXJzb24nID0gJ3Rva2VuJztcblx0Y29uc3Qgc2lfaW50ZW50ID0gaW50ZW50O1xuXG5cdGxldCBnX3BmcDogUGZwWydpbnRlcmZhY2UnXTtcblxuXHQoYXN5bmMoKSA9PiB7XG5cdFx0aWYocF9wZnApIHtcblx0XHRcdGdfcGZwID0gKGF3YWl0IFBmcHMuYXQocF9wZnApKSE7XG5cdFx0fVxuXHR9KSgpO1xuXG5cdC8vIGNvbnN0IHBfaWNvbiA9IGljb25SZWYgfHwgSWNvbi5EZWYuQkxBTksuaXJpO1xuXG5cdC8vIGNvbnN0IGtfaWNvbiA9IHBfaWNvbj8gSF9JQ09OU1twX2ljb25dOiBJY29uLkJMQU5LO1xuPC9zY3JpcHQ+XG5cdFxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LmFyZWEge1xuXHRcdGJvcmRlcjogMXB4IGRhc2hlZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdGJvcmRlci1yYWRpdXM6IDRweDtcblxuXHRcdD4ucm93IHtcblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0XHRtYXJnaW46IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHQ+KiB7XG5cdFx0XHRcdGZsZXg6IGF1dG87XG5cdFx0XHR9XG5cblx0XHRcdD4ubGVmdCB7XG5cdFx0XHRcdGZsZXg6IDE7XG5cblx0XHRcdFx0Pi5pY29uLnBmcCB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHQtLWJ1dHRvbi1kaWFtZXRlcjogNjRweDtcblx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogNjRweDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Pi5yaWdodCB7XG5cdFx0XHRcdGZsZXg6IDM7XG5cdFx0XHRcdHBhZGRpbmc6IDAgY2FsYyh2YXIoLS11aS1wYWRkaW5nKSAvIDIpO1xuXHRcdFx0XHRtYXJnaW4tdG9wOiAtNHB4O1xuXHRcdFx0XHQvLyBwYWRkaW5nLXRvcDogY2FsYyh2YXIoLS11aS1wYWRkaW5nKSAvIDEuNSk7XG5cblx0XHRcdFx0Pi5kaXNjbGFpbWVyIHtcblx0XHRcdFx0XHQuZm9udCh0aW55KTtcblxuXHRcdFx0XHRcdD4ud2FybmluZyB7XG5cdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItY2F1dGlvbik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pi5pbmZvIHtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwYWRkaW5nLWJvdHRvbTogMjBweDtcblxuXHRcdFx0LmFjdGlvbnMge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdG1hcmdpbi10b3A6IDRweDtcblxuXHRcdFx0XHQvLyB3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdFx0XHQvLyBwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdC8vIG1hcmdpbi10b3A6IDRweDtcblx0XHRcdFx0Ly8gbWFyZ2luLWxlZnQ6IC00cHg7XG5cblx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblxuXHRcdFx0XHRcdCY6aG92ZXIge1xuXHRcdFx0XHRcdFx0Pi50ZXh0IHtcblx0XHRcdFx0XHRcdFx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+Lmljb24ge1xuXHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjBweDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJhcmVhXCIgY2xhc3M6aW50ZW50LXBlcnNvbj17J3BlcnNvbicgPT09IHNpX2ludGVudH0+XG5cdDxkaXYgY2xhc3M9XCJyb3dcIj5cblx0XHQ8c3BhbiBjbGFzcz1cImxlZnRcIj5cblx0XHRcdDwhLS0gPHNwYW4gY2xhc3M9XCJpY29uIHBmcFwiIGNsYXNzOnNxdWFyZT17J3BlcnNvbicgPT09IGludGVudH0+XG5cdFx0XHRcdDxQdXQgZWxlbWVudD17SF9JQ09OU1twX2ljb25dLnJlbmRlcigpfSAvPlxuXHRcdFx0PC9zcGFuPiAtLT5cblx0XHRcdHsjaWYgcF9wZnB9XG5cdFx0XHRcdDxQZnBEaXNwbGF5IGRpbT17NDh9IHJlZj17cF9wZnB9IG5hbWU9e3NfbmFtZX0gLz5cblx0XHRcdHsvaWZ9XG5cdFx0XHQ8IS0tIDxQZnBEaXNwbGF5IGJpbmQ6aWNvblJlZj17aWNvblJlZn0gYmluZDpuYW1lPXtuYW1lfSAvPiAtLT5cblx0XHQ8L3NwYW4+XG5cblx0XHQ8c3BhbiBjbGFzcz1cInJpZ2h0XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiZGlzY2xhaW1lclwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5cblx0XHRcdFx0XHROb3RpY2U6XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0VXBsb2FkZWQgaWNvbnMgd2lsbCBiZSByZXNpemVkIHRvIGJlIHNxdWFyZS4gT25seSBKUEcgJiBQTkcgZmlsZXMgbGVzcyB0aGFuIDFNQiBhbGxvd2VkLlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PGRpdiBjbGFzcz1cImFjdGlvbnNcIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInVwbG9hZFwiIG9uOmNsaWNrPXsoKSA9PiBGX05PT1B9PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fSU1BR0V9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuXHRcdFx0XHRcdFx0VXBsb2FkIEljb25cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9zcGFuPlxuXHQ8L2Rpdj5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtnZXRDb250ZXh0LCBTdmVsdGVDb21wb25lbnR9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7bWljcm90YXNrLCBvZGUsIG9mZSwgcHJvcGVyfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IHsgQ29udGFjdCwgQ29udGFjdEFnZW50VHlwZSwgQ29udGFjdFBhdGggfSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHR5cGUgeyBQYWdlIH0gZnJvbSAnLi4vbmF2L3BhZ2UnO1xuXHRpbXBvcnQgeyB5d19jaGFpbiwgeXdfZmFtaWx5IH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBSX0JFQ0gzMiB9IGZyb20gJyMvc2hhcmUvY29uc3RhbnRzJztcblx0aW1wb3J0IHsgVGFncyB9IGZyb20gJyMvc3RvcmUvdGFncyc7XG5cdGltcG9ydCB7IEhlYWRlciwgU2NyZWVuIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cdGltcG9ydCBDb250YWN0VmlldyBmcm9tICcuL0NvbnRhY3RWaWV3LnN2ZWx0ZSc7XG5cdGltcG9ydCBGaWVsZCBmcm9tICcuLi91aS9GaWVsZC5zdmVsdGUnO1xuXHRpbXBvcnQgSW5mbyBmcm9tICcuLi91aS9JbmZvLnN2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4sIENoYWluUGF0aCB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCBJbmxpbmVUYWdzIGZyb20gJy4uL3VpL0lubGluZVRhZ3Muc3ZlbHRlJztcblx0aW1wb3J0IEljb25FZGl0b3IgZnJvbSAnLi4vdWkvSWNvbkVkaXRvci5zdmVsdGUnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHQvKipcblx0ICogQ29udGFjdCByZXNvdXJjZSBwYXRoXG5cdCAqL1xuXHRleHBvcnQgbGV0IGNvbnRhY3RSZWY6IENvbnRhY3RQYXRoIHwgJycgPSAnJztcblx0Y29uc3QgcF9jb250YWN0ID0gY29udGFjdFJlZiB8fCAnJztcblxuXHQvLyBwcmVwIG9iamVjdCBwbGFjZWhvbGRlclxuXHRsZXQgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXTtcblxuXHQvLyBwYXRoIHdhcyBnaXZlbjsgbG9hZCBjb250YWN0XG5cdGlmKHBfY29udGFjdCkgdm9pZCBBZ2VudHMuZ2V0Q29udGFjdChwX2NvbnRhY3QpLnRoZW4oZyA9PiBnX2NvbnRhY3QgPSBnISk7XG5cblx0Ly8gbG9hZCBhbGwgY2hhaW5zXG5cdGxldCBoX2NoYWluczogUmVjb3JkPENoYWluUGF0aCwgQ2hhaW5bJ2ludGVyZmFjZSddPiA9IHt9O1xuXHQoYXN5bmMgZnVuY3Rpb24gbG9hZF9jaGFpbnMoKSB7XG5cdFx0aF9jaGFpbnMgPSBvZmUoKGF3YWl0IENoYWlucy5yZWFkKCkpLmVudHJpZXMoKSk7XG5cdH0pKCk7XG5cblx0Ly8gcmVhY3RpdmVseSBkZXN0cnVjdHVyZSBjb250YWN0J3MgcHJvcGVydGllc1xuXHQkOiBzX25hbWUgPSBnX2NvbnRhY3Q/Lm5hbWUgfHwgJyc7XG5cdCQ6IHNfYWRkciA9IGdfY29udGFjdD8uYWRkcmVzcyB8fCAnJztcblx0JDogc2FfYmVjaDMyID0gc19hZGRyPyBDaGFpbnMuYmVjaDMyKHNfYWRkciBhcyBzdHJpbmcpOiAnJztcblx0JDogc19ub3RlcyA9IGdfY29udGFjdD8ubm90ZXMgfHwgJyc7XG5cdCQ6IHNpX2FnZW50X3R5cGUgPSBnX2NvbnRhY3Q/LmFnZW50VHlwZSB8fCBDb250YWN0QWdlbnRUeXBlLlBFUlNPTjtcblxuXHRsZXQgc19lcnJfbmFtZSA9ICcnO1xuXHRsZXQgc19lcnJfYWRkcmVzcyA9ICcnO1xuXG5cdGZ1bmN0aW9uIHB1YmtleV9mcm9tX2FkZHIoc2FfYWRkcmVzczogc3RyaW5nLCBiX3Nob3dfZXJyPWZhbHNlKTogc3RyaW5nIHtcblx0XHRjb25zdCBtX2JlY2ggPSBSX0JFQ0gzMi5leGVjKHNhX2FkZHJlc3MpO1xuXHRcdGlmKCFtX2JlY2gpIHtcblx0XHRcdGlmKGJfc2hvd19lcnIpIHtcblx0XHRcdFx0c19lcnJfYWRkcmVzcyA9ICdJbnZhbGlkIEJlY2gzMiBhZGRyZXNzJztcblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0Y29uc3QgWywgc19jaGFpbiwgc19wdWJrZXlfbG9jYWxdID0gbV9iZWNoO1xuXG5cdFx0bGV0IGtfY2hhaW5fbWF0Y2ggPSBudWxsO1xuXHRcdGZvcihjb25zdCBbLCBrX2NoYWluXSBvZiBvZGUoSF9DSEFJTlMpKSB7XG5cdFx0XHRpZihrX2NoYWluLmRlZi5iZWNoUHJlZml4ID09PSBzX2NoYWluKSB7XG5cdFx0XHRcdGtfY2hhaW5fbWF0Y2ggPSBrX2NoYWluO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihiX3Nob3dfZXJyKSB7XG5cdFx0XHRpZigha19jaGFpbl9tYXRjaCkge1xuXHRcdFx0XHRzX2Vycl9hZGRyZXNzID0gYE5vIENvc21vcyBTREsgY2hhaW5zIG1hdGNoZWQgJyR7c19jaGFpbn0nYDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzX2Vycl9hZGRyZXNzID0gJyc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNfYWRkciA9IHNfcHVia2V5X2xvY2FsO1xuXHR9XG5cblx0JDogYl9mb3JtX3ZhbGlkID0gISEoc19uYW1lICYmIHB1YmtleV9mcm9tX2FkZHIoc2FfYmVjaDMyKSk7XG5cdGxldCBjX3Nob3dfdmFsaWRhdGlvbnMgPSAwO1xuXG5cdCQ6IHtcblx0XHRpZihjX3Nob3dfdmFsaWRhdGlvbnMpIHtcblx0XHRcdHNfZXJyX25hbWUgPSBzX25hbWU/ICcnOiAnTmFtZSBtdXN0IG5vdCBiZSBlbXB0eSc7XG5cdFx0XHRwdWJrZXlfZnJvbV9hZGRyKHNhX2JlY2gzMiwgdHJ1ZSk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGJfYnVzeSA9IGZhbHNlO1xuXG5cdGxldCB5X3NjcmVlbjogU3ZlbHRlQ29tcG9uZW50O1xuXHRhc3luYyBmdW5jdGlvbiBzYXZlKCkge1xuXHRcdGlmKCFiX2Zvcm1fdmFsaWQpIHtcblx0XHRcdGNfc2hvd192YWxpZGF0aW9ucysrO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVsc2UgaWYocF9jb250YWN0KSB7XG5cdFx0XHRPYmplY3QuYXNzaWduKGdfY29udGFjdCwge1xuXHRcdFx0XHRuYW1lOiBzX25hbWUsXG5cdFx0XHRcdGFkZHJlc3M6IHNfYWRkcixcblx0XHRcdFx0cGZwOiBnX2NvbnRhY3QucGZwLFxuXHRcdFx0XHRhZ2VudFR5cGU6IHNpX2FnZW50X3R5cGUsXG5cdFx0XHRcdG5vdGVzOiBzX25vdGVzLFxuXHRcdFx0fSk7XG5cblx0XHRcdGtfcGFnZS5yZXNldCgpO1xuXHRcdFx0Ly8gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHQvLyBcdHRyeSB7XG5cdFx0XHQvLyBcdFx0eV9zY3JlZW4uJGRlc3Ryb3koKTtcblx0XHRcdC8vIFx0fVxuXHRcdFx0Ly8gXHRjYXRjaChlKSB7fVxuXHRcblx0XHRcdC8vIFx0Y29udGFjdCA9IEhfQ09OVEFDVFNbY29udGFjdC5kZWYuaXJpXTtcblx0XHRcdC8vIFx0cHVzaF9zY3JlZW4oQ29udGFjdFZpZXcsIHtcblx0XHRcdC8vIFx0XHRjb250YWN0LFxuXHRcdFx0Ly8gXHR9KTtcblx0XHRcdC8vIH0sIDUpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGdfY29udGFjdCA9IHtcblx0XHRcdFx0bmFtZTogc19uYW1lLFxuXHRcdFx0XHRmYW1pbHk6ICR5d19mYW1pbHksXG5cdFx0XHRcdGFkZHJlc3M6IHNfYWRkcixcblx0XHRcdFx0cGZwOiBnX2NvbnRhY3QucGZwLFxuXHRcdFx0XHRhZ2VudFR5cGU6IHNpX2FnZW50X3R5cGUsXG5cdFx0XHRcdG5vdGVzOiBzX25vdGVzLFxuXHRcdFx0XHRzcGFjZTogJ2FjYycsXG5cdFx0XHRcdG9yaWdpbjogJ3VzZXInLFxuXHRcdFx0XHRjaGFpbnM6IHt9LFxuXHRcdFx0fTtcblx0XHR9XG5cblxuXHRcdGJfYnVzeSA9IHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IEFnZW50cy5vcGVuKGFzeW5jKGtzX2FnZW50cykgPT4ge1xuXHRcdFx0XHRhd2FpdCBrc19hZ2VudHMucHV0Q29udGFjdChnX2NvbnRhY3QpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGtfcGFnZS5yZXNldCgpO1xuXG5cdFx0XHQvLyBpbW1lZGlhdGVseSBvcGVuIG5ldyBjb250YWN0XG5cdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdGNyZWF0b3I6IENvbnRhY3RWaWV3LFxuXHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdGNvbnRhY3RSZWY6IHBfY29udGFjdCxcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRjYXRjaChlX3dyaXRlKSB7XG5cdFx0XHRiX2J1c3kgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvLyBsZXQgcF9pY29uOiBJY29uLlJlZiA9IGNvbnRhY3Q/LmRlZi5pY29uUmVmIHx8ICcnIGFzIEljb24uUmVmO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdCNjaGFpbi1mYW1pbHkge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0ZmxleDogMTtcblx0XHRcdGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcblx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblxuXHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbiBiaW5kOnRoaXM9e3lfc2NyZWVufSBsZWF2ZXM+XG5cdDxIZWFkZXJcblx0XHRwbGFpbiBwb3BzXG5cdFx0dGl0bGU9XCJ7cF9jb250YWN0PyAnRWRpdCc6ICdBZGQgTmV3J30gQ29udGFjdFwiXG5cdC8+XG5cblx0PEZpZWxkXG5cdFx0a2V5PVwiY29udGFjdC1wZnBcIlxuXHRcdG5hbWU9XCJQcm9maWxlIEljb25cIlxuXHQ+XG5cdFx0PEljb25FZGl0b3IgaW50ZW50PSdwZXJzb24nIHBmcFJlZj17Z19jb250YWN0Py5wZnB9IGJpbmQ6bmFtZT17c19uYW1lfSAvPlxuXHQ8L0ZpZWxkPlxuXG5cdDxGaWVsZFxuXHRcdGtleT1cImNoYWluLWZhbWlseVwiXG5cdFx0bmFtZT1cIkNoYWluIEZhbWlseVwiXG5cdD5cblx0XHQ8SW5mbyBrZXk9XCJjaGFpbi1mYW1pbHlcIj5cblx0XHRcdDxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcdFx0XHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdFx0XHRcdC50aXRsZSB7XG5cdFx0XHRcdFx0LmZvbnQocmVndWxhcik7XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LmV4YW1wbGVzIHtcblx0XHRcdFx0XHRtYXJnaW4tbGVmdDogMC41ZW07XG5cdFx0XHRcdH1cblx0XHRcdDwvc3R5bGU+XG5cblx0XHRcdDxzcGFuIGNsYXNzPVwidGl0bGVcIj5cblx0XHRcdFx0e3Byb3BlcigkeXdfZmFtaWx5KX1cblx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0PHNwYW4gY2xhc3M9XCJleGFtcGxlc1wiPlxuXHRcdFx0XHQoe29kZShoX2NoYWlucykuZmlsdGVyKChbLCBnXSkgPT4gJHl3X2ZhbWlseSA9PT0gZy5mYW1pbHkpLm1hcCgoWywgZ10pID0+IGcuYmVjaDMycy5hY2MuaHJwKS5qb2luKCcsICcpfSlcblx0XHRcdDwvc3Bhbj5cblx0XHQ8L0luZm8+XG5cdDwvRmllbGQ+XG5cblxuXHQ8RmllbGRcblx0XHRrZXk9XCJjb250YWN0LW5hbWVcIlxuXHRcdG5hbWU9XCJOYW1lXCJcblx0PlxuXHRcdDxpbnB1dCBjbGFzczppbnZhbGlkPXtzX2Vycl9uYW1lfSB0eXBlPVwidGV4dFwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiIGJpbmQ6dmFsdWU9e3NfbmFtZX0gcGxhY2Vob2xkZXI9XCJFbnRlciBhIG5hbWVcIj5cblxuXHRcdHsjaWYgc19lcnJfbmFtZX1cblx0XHRcdDxzcGFuIGNsYXNzPVwidmFsaWRhdGlvbi1tZXNzYWdlXCI+XG5cdFx0XHRcdHtzX2Vycl9uYW1lfVxuXHRcdFx0PC9zcGFuPlxuXHRcdHsvaWZ9XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkXG5cdFx0a2V5PVwiY29udGFjdC1hZGRyZXNzXCJcblx0XHRuYW1lPVwiQWRkcmVzc1wiXG5cdD5cblx0XHQ8aW5wdXRcblx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdGNsYXNzPVwiYWRkcmVzc1wiXG5cdFx0XHRjbGFzczppbnZhbGlkPXtzX2Vycl9hZGRyZXNzfVxuXHRcdFx0c3BlbGxjaGVjaz1cImZhbHNlXCJcblx0XHRcdHBsYWNlaG9sZGVyPVwieyR5d19jaGFpbi5iZWNoMzJzLmFjY30xLi4uXCJcblx0XHRcdGJpbmQ6dmFsdWU9e3NhX2JlY2gzMn1cblx0XHQ+XG5cblx0XHR7I2lmIHNfZXJyX2FkZHJlc3N9XG5cdFx0XHQ8c3BhbiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiPlxuXHRcdFx0XHR7c19lcnJfYWRkcmVzc31cblx0XHRcdDwvc3Bhbj5cblx0XHR7L2lmfVxuXHQ8L0ZpZWxkPlxuXG5cdDxGaWVsZFxuXHRcdGtleT1cImNvbnRhY3Qtbm90ZXNcIlxuXHRcdG5hbWU9XCJTZWN1cmUgTm90ZXNcIlxuXHQ+XG5cdFx0PHRleHRhcmVhIGJpbmQ6dmFsdWU9e3Nfbm90ZXN9IHBsYWNlaG9sZGVyPVwiXCI+PC90ZXh0YXJlYT5cblx0PC9GaWVsZD5cblxuXHQ8aHI+XG5cblx0PGgzPlxuXHRcdHtwX2NvbnRhY3Q/ICdFZGl0JzogJ0FkZCd9IFRhZ3Ncblx0PC9oMz5cblxuXHQ8SW5saW5lVGFncyBlZGl0YWJsZSByZXNvdXJjZVBhdGg9e3BfY29udGFjdH0gLz5cblxuXHQ8ZGl2IGNsYXNzPVwiYWN0aW9uLWxpbmVcIj5cblx0XHQ8YnV0dG9uIG9uOmNsaWNrPXsoKSA9PiBrX3BhZ2UucG9wKCl9PlxuXHRcdFx0QmFja1xuXHRcdDwvYnV0dG9uPlxuXG5cdFx0PGJ1dHRvbiBjbGFzcz1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gc2F2ZSgpfSByZWFkb25seT17IWJfZm9ybV92YWxpZH0+XG5cdFx0XHR7cF9jb250YWN0PyAnU2F2ZSc6ICdBZGQnfVxuXHRcdDwvYnV0dG9uPlxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItbW9yZS12ZXJ0LWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1tb3JlLXZlcnQtZmdcXFwiIGQ9XFxcIk0xMiA4QzEzLjEgOCAxNCA3LjEgMTQgNkMxNCA0LjkgMTMuMSA0IDEyIDRDMTAuOSA0IDEwIDQuOSAxMCA2QzEwIDcuMSAxMC45IDggMTIgOFpNMTIgMTBDMTAuOSAxMCAxMCAxMC45IDEwIDEyQzEwIDEzLjEgMTAuOSAxNCAxMiAxNEMxMy4xIDE0IDE0IDEzLjEgMTQgMTJDMTQgMTAuOSAxMy4xIDEwIDEyIDEwWk0xMiAxNkMxMC45IDE2IDEwIDE2LjkgMTAgMThDMTAgMTkuMSAxMC45IDIwIDEyIDIwQzEzLjEgMjAgMTQgMTkuMSAxNCAxOEMxNCAxNi45IDEzLjEgMTYgMTIgMTZaXFxcIiBmaWxsPVxcXCIjRkZCNjFBXFxcIi8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTkgMTZoNnYtNmg0bC03LTctNyA3aDR2NnptMy0xMC4xN0wxNC4xNyA4SDEzdjZoLTJWOEg5LjgzTDEyIDUuODN6TTUgMThoMTR2Mkg1elxcXCIvPlxcbjwvc3ZnPlwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtxdWludE91dH0gZnJvbSAnc3ZlbHRlL2Vhc2luZyc7XG5cdGltcG9ydCB7eXdfZmFtaWx5fSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCBTWF9JQ09OX0RPVFMgZnJvbSAnIy9pY29uL21vcmUtdmVydC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fRURJVCBmcm9tICcjL2ljb24vZWRpdC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fU0VORCBmcm9tICcjL2ljb24vdXBsb2FkLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9ERUxFVEUgZnJvbSAnIy9pY29uL2RlbGV0ZS5zdmc/cmF3JztcblxuXHRpbXBvcnQgU1hfSUNPTl9QRVJTT05BTCBmcm9tICcjL2ljb24vYWNjb3VudF9ib3guc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NPTlRSQUNUIGZyb20gJyMvaWNvbi9hbmFseXRpY3Muc3ZnP3Jhdyc7XG5cblx0aW1wb3J0IHtzbGlkZX0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXHRpbXBvcnQgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3Muc3ZlbHRlJztcblx0aW1wb3J0IFJvdyBmcm9tICcuL1Jvdy5zdmVsdGUnO1xuXHRpbXBvcnQgUHV0IGZyb20gJy4vUHV0LnN2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHtEaWN0LCBKc29uUHJpbWl0aXZlfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IElubGluZVRhZ3MgZnJvbSAnLi9JbmxpbmVUYWdzLnN2ZWx0ZSc7XG5cblx0aW1wb3J0IENvbnRhY3RFZGl0IGZyb20gJyMjL3NjcmVlbi9Db250YWN0RWRpdC5zdmVsdGUnO1xuXHRpbXBvcnQgU2VuZCBmcm9tICcjIy9zY3JlZW4vU2VuZC5zdmVsdGUnO1xuXHRpbXBvcnQgRGVhZEVuZCBmcm9tICcjIy9zY3JlZW4vRGVhZEVuZC5zdmVsdGUnO1xuXHRpbXBvcnQgQ29udGFjdFZpZXcgZnJvbSAnIyMvc2NyZWVuL0NvbnRhY3RWaWV3LnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHR5cGUge0NvbnRhY3QsIENvbnRhY3RQYXRofSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cdGltcG9ydCB7QWdlbnRzfSBmcm9tICcjL3N0b3JlL2FnZW50cyc7XG5cdGltcG9ydCB7Q2hhaW5zfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cblx0aW1wb3J0IHR5cGUge1BhZ2V9IGZyb20gJy4uL3NjcmVlbi9fc2NyZWVucyc7XG5cdGltcG9ydCB7Z2V0Q29udGV4dH0gZnJvbSAnc3ZlbHRlJztcblxuXHQvLyBnZXQgcGFnZSBmcm9tIGNvbnRleHRcblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cblx0ZXhwb3J0IGxldCBmaWx0ZXI6IChnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddKSA9PiBib29sZWFuID0gZyA9PiB0cnVlO1xuXG5cdGV4cG9ydCBsZXQgc29ydDogKGdfYTogQ29udGFjdFsnaW50ZXJmYWNlJ10sIGdfYjogQ29udGFjdFsnaW50ZXJmYWNlJ10pID0+IG51bWJlciA9IChnX2EsIGdfYikgPT4gZ19hLm5hbWUgPCBnX2IubmFtZT8gLTE6IDE7XG5cblx0ZXhwb3J0IGxldCBhcHBlbmQ6IENvbnRhY3RbJ2ludGVyZmFjZSddW10gPSBbXTtcblxuXG5cdC8vIGxvYWQgYWxsIGNvbnRhY3RzIGZvciB0aGUgY3VycmVudCBjaGFpbidzIGZhbWlseSBhcyBhIGxpc3Rcblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9jb250YWN0cygpOiBQcm9taXNlPFtDb250YWN0UGF0aCwgQ29udGFjdFsnaW50ZXJmYWNlJ11dW10+IHtcblx0XHQvLyByZWFkIGZyb20gYWdlbnRzIHN0b3JlXG5cdFx0Y29uc3Qga3NfYWdlbnRzID0gYXdhaXQgQWdlbnRzLnJlYWQoKTtcblxuXHRcdC8vIHNwcmVhZCBpdGVyYXRvciBpbnRvIGFycmF5XG5cdFx0cmV0dXJuIFsuLi5rc19hZ2VudHMuY29udGFjdHMoJHl3X2ZhbWlseSldO1xuXHR9XG5cblx0Y29uc3QgaG1fZXZlbnRzID0gbmV3IFdlYWtNYXA8RXZlbnQsIERpY3Q8SnNvblByaW1pdGl2ZT4+KCk7XG5cblx0bGV0IHNpX292ZXJsYXkgPSAnJztcblx0ZnVuY3Rpb24gYWN0aXZhdGVfb3ZlcmxheShwX2NvbnRhY3Q6IHN0cmluZywgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSk6IChkOiBNb3VzZUV2ZW50KSA9PiB2b2lkIHtcblx0XHRyZXR1cm4gKGRfZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcblx0XHRcdC8vIHByZXZlbnQgZXZlbnQgZnJvbSBidWJibGluZ1xuXHRcdFx0ZF9ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0Ly8gcmVmIGVudHJ5IGlkXG5cdFx0XHRjb25zdCBzaV9zZXQgPSBwX2NvbnRhY3Q7XG5cblx0XHRcdC8vIG92ZXJsYXkgYWxyZWFkeSBzZXQgdG8gdGhpcyBlbnRyeTsgaGlkZSBpdFxuXHRcdFx0aWYoaG1fZXZlbnRzLmdldChkX2V2ZW50KT8uY2FuY2VsTWVudSA9PT0gc2lfc2V0KSB7XG5cdFx0XHRcdHNpX292ZXJsYXkgPSAnJztcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgb3ZlcmxheSB0byB0aGlzIGVudHJ5XG5cdFx0XHRzaV9vdmVybGF5ID0gc2lfc2V0O1xuXG5cdFx0XHQvLyByZW1vdmUgb24gY2xpY2sgZXZlbnRcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcblx0XHRcdFx0aG1fZXZlbnRzLnNldChkX2V2ZW50LCB7XG5cdFx0XHRcdFx0Y2FuY2VsTWVudTogc2lfb3ZlcmxheSxcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNpX292ZXJsYXkgPSAnJztcblx0XHRcdH0sIHtcblx0XHRcdFx0Y2FwdHVyZTogdHJ1ZSxcblx0XHRcdFx0b25jZTogdHJ1ZSxcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblxuXHRjb25zdCBhX292ZXJsYXlfYWN0aW9uczoge1xuXHRcdGxhYmVsOiBzdHJpbmc7XG5cdFx0aWNvbjogc3RyaW5nO1xuXHRcdGNsaWNrKGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ10pOiB2b2lkO1xuXHR9W10gPSBbXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdFZGl0Jyxcblx0XHRcdGljb246IFNYX0lDT05fRURJVCxcblx0XHRcdGNsaWNrKGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ10pIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IENvbnRhY3RFZGl0LFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRjb250YWN0OiBnX2NvbnRhY3QsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdTZW5kJyxcblx0XHRcdGljb246IFNYX0lDT05fU0VORCxcblx0XHRcdGNsaWNrKGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ10pIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IFNlbmQsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdHJlY2lwaWVudDogQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcyksXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdEZWxldGUnLFxuXHRcdFx0aWNvbjogU1hfSUNPTl9ERUxFVEUsXG5cdFx0XHRjbGljayhnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddKSB7XG5cdFx0XHRcdC8vIFRPRE86XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBEZWFkRW5kLFxuXHRcdFx0XHRcdHByb3BzOiB7fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdF07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LnJvd3Mge1xuXHRcdG1hcmdpbi1sZWZ0OiBjYWxjKDBweCAtIHZhcigtLXVpLXBhZGRpbmcpKTtcblx0XHRtYXJnaW4tcmlnaHQ6IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXG5cdFx0LnJvdyB7XG5cdFx0XHQuc3RhdHVzIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Lmljb24ubW9yZS1tZW51IHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdHBhZGRpbmctdG9wOiA1MCU7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLWJvdHRvbTogNTAlO1xuXHRcdFx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHRcdG91dGxpbmU6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb246IDM1MG1zIG91dGxpbmUtY29sb3IgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdDpnbG9iYWwoJjpob3Zlcikge1xuXHRcdFx0XHRcdFx0b3V0bGluZS1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ6Z2xvYmFsKCY6YWN0aXZlKSwgOmdsb2JhbCgmLmFjdGl2ZSkge1xuXHRcdFx0XHRcdFx0b3V0bGluZS1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Lm92ZXJsYXkge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHRcdFx0cGFkZGluZzogMTBweCAxNHB4O1xuXHRcdFx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuXHRcdFx0XHRcdFx0Ym9yZGVyLXJhZGl1czogOHB4O1xuXHRcdFx0XHRcdFx0cmlnaHQ6IDI2cHg7XG5cdFx0XHRcdFx0XHR0b3A6IC0xOHB4O1xuXHRcdFx0XHRcdFx0bWluLXdpZHRoOiAxMjBweDtcblx0XHRcdFx0XHRcdHotaW5kZXg6IDEwMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+LmFjdGlvbiB7XG5cdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0XHRcdFx0cGFkZGluZzogMTBweCA4cHg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdD4udGV4dCB7XG5cdFx0XHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0XHRcdHBhZGRpbmctbGVmdDogMTBweDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC5pY29uIHtcblx0XHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Lmljb24uY29udGFjdC10eXBlIHtcblx0XHQtLWljb24tZGlhbWV0ZXI6IDE2cHg7XG5cdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdH1cblxuXHQucGZwLWdlbiB7XG5cdFx0LmZvbnQoaHVnZSk7XG5cdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Ym9yZGVyLXJhZGl1czogMjAlO1xuXHRcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoZWxsaXBzZSBmYXJ0aGVzdC1zaWRlIGF0IGJvdHRvbSByaWdodCwgIzA3MDgwYSwgIzBmMTMxNyk7XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJyb3dzXCI+XG5cdHsjYXdhaXQgbG9hZF9jb250YWN0cygpfVxuXHRcdExvYWRpbmcgY29udGFjdHMuLi5cblx0ezp0aGVuIGFfbGlzdH1cblx0XHR7I2VhY2ggYV9saXN0IGFzIFtwX2NvbnRhY3QsIGdfY29udGFjdF19XG5cdFx0XHQ8Um93XG5cdFx0XHRcdHJlc291cmNlPXtnX2NvbnRhY3R9XG5cdFx0XHRcdHJlc291cmNlUGF0aD17cF9jb250YWN0fVxuXHRcdFx0XHRvbjpjbGljaz17KGRfZXZlbnQpID0+IHtcblx0XHRcdFx0XHRpZighaG1fZXZlbnRzLmdldChkX2V2ZW50KT8uY2FuY2VsTWVudSkge1xuXHRcdFx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRjcmVhdG9yOiBDb250YWN0Vmlldyxcblx0XHRcdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdFx0XHRjb250YWN0OiBnX2NvbnRhY3QsXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH19XG5cdFx0XHQ+XG5cdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cImRldGFpbFwiPlxuXHRcdFx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9e0NoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MrJycpfSAvPlxuXHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblxuXHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJ0YWdzXCI+XG5cdFx0XHRcdFx0PElubGluZVRhZ3MgY29sbGFwc2VkIHJvb3RTdHlsZT0nbWFyZ2luOiAwcHg7J1xuXHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoPXtwX2NvbnRhY3R9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGNvbnRhY3QtdHlwZVwiIHNsb3Q9XCJwcmVmaXhcIj5cblx0XHRcdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fUEVSU09OQUx9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PC9JbmxpbmVUYWdzPlxuXHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblxuXHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdGF0dXNcIj5cblx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJpY29uIG1vcmUtbWVudVwiXG5cdFx0XHRcdFx0XHRjbGFzczphY3RpdmU9e3NpX292ZXJsYXkgPT09IHBfY29udGFjdH1cblx0XHRcdFx0XHRcdG9uOmNsaWNrPXthY3RpdmF0ZV9vdmVybGF5KHBfY29udGFjdCwgZ19jb250YWN0KX1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9ET1RTfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdHsjaWYgc2lfb3ZlcmxheSA9PT0gcF9jb250YWN0fVxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJvdmVybGF5XCIgdHJhbnNpdGlvbjpzbGlkZT17e2R1cmF0aW9uOjMwMCwgZWFzaW5nOnF1aW50T3V0fX0+XG5cdFx0XHRcdFx0XHRcdHsjZWFjaCBhX292ZXJsYXlfYWN0aW9ucyBhcyBnX2FjdGlvbn1cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYWN0aW9uXCIgb246Y2xpY2s9eyhkX2V2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkX2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Z19hY3Rpb24uY2xpY2soZ19jb250YWN0KTtcblx0XHRcdFx0XHRcdFx0XHR9fT5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgZ19hY3Rpb24uaWNvbn1cblx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHtnX2FjdGlvbi5sYWJlbH1cblx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0PC9Sb3c+XG5cdFx0ey9lYWNofVxuXHR7L2F3YWl0fVxuPC9kaXY+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtnZXRDb250ZXh0fSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCB7XG5cdFx0VGFicyxcblx0XHRUYWIsXG5cdFx0VGFiTGlzdCxcblx0XHRUYWJQYW5lbCxcblx0fSBmcm9tICdzdmVsdGUtdGFicyc7XG5cblx0aW1wb3J0IHtcblx0XHRTY3JlZW4sXG5cdFx0SGVhZGVyLFxuXHRcdHR5cGUgUGFnZSxcblx0fSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRpbXBvcnQgQ29udGFjdEVkaXQgZnJvbSAnLi9Db250YWN0RWRpdC5zdmVsdGUnO1xuXHRpbXBvcnQgU3ViSGVhZGVyIGZyb20gJy4uL3VpL1N1YkhlYWRlci5zdmVsdGUnO1xuXHRpbXBvcnQgQ29udGFjdExpc3QgZnJvbSAnLi4vdWkvQ29udGFjdExpc3Quc3ZlbHRlJztcblx0aW1wb3J0IHtDb250YWN0QWdlbnRUeXBlfSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LnNjcmVlbi5jb250YWN0cyBkaXYuc3ZlbHRlLXRhYnM+ZGl2LnN2ZWx0ZS10YWJzX190YWItcGFuZWwge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0bWFyZ2luLXRvcDogLTFweDtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxTY3JlZW4gbmF2IHJvb3QgY2xhc3NOYW1lcz0nY29udGFjdHMnPlxuXHQ8SGVhZGVyIHNlYXJjaCBuZXR3b3JrIGFjY291bnRcblx0PlxuXHQ8L0hlYWRlcj5cblxuXHQ8U3ViSGVhZGVyIHRpdGxlPVwiQ29udGFjdHNcIlxuXHRcdG9uOmFkZF9uZXc9eygpID0+IGtfcGFnZS5wdXNoKHtjcmVhdG9yOkNvbnRhY3RFZGl0fSl9XG5cdFx0YnV0dG9ucz17WydFeHBvcnQnXX1cblx0Lz5cblx0XG5cdDxUYWJzPlxuXHRcdDxUYWJMaXN0PlxuXHRcdFx0PFRhYj5cblx0XHRcdFx0QWxsXG5cdFx0XHQ8L1RhYj5cblxuXHRcdFx0PFRhYj5cblx0XHRcdFx0SHVtYW5zXG5cdFx0XHQ8L1RhYj5cblxuXHRcdFx0PFRhYj5cblx0XHRcdFx0Q29udHJhY3RzXG5cdFx0XHQ8L1RhYj5cblx0XHQ8L1RhYkxpc3Q+XG5cblxuXHRcdDwhLS0gQWxsIC0tPlxuXHRcdDxUYWJQYW5lbD5cblx0XHRcdDxDb250YWN0TGlzdCAvPlxuXHRcdDwvVGFiUGFuZWw+XG5cblxuXHRcdDwhLS0gSHVtYW5zIC0tPlxuXHRcdDxUYWJQYW5lbD5cblx0XHRcdDxDb250YWN0TGlzdFxuXHRcdFx0XHRmaWx0ZXI9e2dfY29udGFjdCA9PiBDb250YWN0QWdlbnRUeXBlLlBFUlNPTiA9PT0gZ19jb250YWN0LmFnZW50VHlwZX1cblx0XHRcdC8+XG5cdFx0PC9UYWJQYW5lbD5cblxuXHRcdFxuXHRcdDwhLS0gQ29udHJhY3RzIC0tPlxuXHRcdDxUYWJQYW5lbD5cblx0XHRcdDxDb250YWN0TGlzdFxuXHRcdFx0XHRmaWx0ZXI9e2dfY29udGFjdCA9PiBDb250YWN0QWdlbnRUeXBlLkNPTlRSQUNUID09PSBnX2NvbnRhY3QuYWdlbnRUeXBlfVxuXHRcdFx0Lz5cblx0XHQ8L1RhYlBhbmVsPlxuXG5cdDwvVGFicz5cblxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgQXBwcyB9IGZyb20gXCIjL3N0b3JlL2FwcHNcIjtcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gXCJzdmVsdGVcIjtcblx0aW1wb3J0IEhlYWRlciBmcm9tIFwiLi4vdWkvSGVhZGVyLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgUm93IGZyb20gXCIuLi91aS9Sb3cuc3ZlbHRlXCI7XG5cdGltcG9ydCB7IFBhZ2UsIFNjcmVlbiwgU3ViSGVhZGVyIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYXBwcygpIHtcblx0XHRjb25zdCBrc19hcHBzID0gYXdhaXQgQXBwcy5yZWFkKCk7XG5cblx0XHRyZXR1cm4ga3NfYXBwcy5lbnRyaWVzKCk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0XG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdTaXRlc0hvbWUnIG5hdiByb290PlxuXHQ8SGVhZGVyIHNlYXJjaCBuZXR3b3JrIGFjY291bnQgLz5cblxuXHQ8U3ViSGVhZGVyIGJhcmVcblx0XHR0aXRsZT0nU2l0ZXMgLyBBcHBzJ1xuXHQvPlxuXG5cdDxkaXYgY2xhc3M9XCJyb3dzIG5vLW1hcmdpblwiPlxuXHRcdHsjYXdhaXQgbG9hZF9hcHBzKCl9XG5cdFx0XHRMb2FkaW5nLi4uXG5cdFx0ezp0aGVuIGFfYXBwc30gXG5cdFx0XHR7I2VhY2ggYV9hcHBzIGFzIFtwX2FwcCwgZ19hcHBdfVxuXHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0cGZwPXtnX2FwcC5wZnB9XG5cdFx0XHRcdFx0bmFtZT17Z19hcHAuaG9zdH1cblx0XHRcdFx0XHRyZXNvdXJjZVBhdGg9e3BfYXBwfVxuXHRcdFx0XHRcdGljb25DbGFzcz17J3NxdWFyZSBwZnAnfVxuXHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdC8vIGNyZWF0b3I6IFNpdGVWaWV3LFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fX1cblx0XHRcdFx0PlxuXHRcdFx0XHQ8L1Jvdz5cblx0XHRcdHsvZWFjaH1cblx0XHR7L2F3YWl0fVxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7Q2hhaW5zfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7TmV0d29ya3N9IGZyb20gJyMvc3RvcmUvbmV0d29ya3MnO1xuXHRpbXBvcnQge2dldENvbnRleHR9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBIZWFkZXIgZnJvbSAnLi4vdWkvSGVhZGVyLnN2ZWx0ZSc7XG5cdGltcG9ydCBSb3cgZnJvbSAnLi4vdWkvUm93LnN2ZWx0ZSc7XG5cdGltcG9ydCB7UGFnZSwgU2NyZWVuLCBTdWJIZWFkZXJ9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRsZXQga3NfY2hhaW5zOiBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIENoYWlucy5yZWFkPj47XG5cdGxldCBrc19uZXR3b3JrczogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBOZXR3b3Jrcy5yZWFkPj47XG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfbmV0d29ya3MoKSB7XG5cdFx0W1xuXHRcdFx0a3NfY2hhaW5zLFxuXHRcdFx0a3NfbmV0d29ya3MsXG5cdFx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcblx0XHRcdENoYWlucy5yZWFkKCksXG5cdFx0XHROZXR3b3Jrcy5yZWFkKCksXG5cdFx0XSk7XG5cblx0XHRyZXR1cm4ga3NfbmV0d29ya3MuZW50cmllcygpO1xuXHR9XG5cblx0Ly8gZnVuY3Rpb24gYWRkX25ld19uZXR3b3JrKCkge1xuXHQvLyBcdGtfcGFnZS5wdXNoKHtcblx0Ly8gXHRcdGNyZWF0b3I6IE5ldHdvcmtDcmVhdGUsXG5cdC8vIFx0fSk7XG5cdC8vIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0XG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdOZXR3b3Jrc0hvbWUnIG5hdiByb290PlxuXHQ8SGVhZGVyIHNlYXJjaCBuZXR3b3JrIGFjY291bnQgLz5cblxuXHQ8U3ViSGVhZGVyIGJhcmVcblx0XHR0aXRsZT0nTmV0d29ya3MnXG5cdC8+XG5cdFx0PCEtLSBvbjphZGRfbmV3PXthZGRfbmV3X25ldHdvcmt9IC0tPlxuXG5cdDxkaXYgY2xhc3M9XCJyb3dzIG5vLW1hcmdpblwiPlxuXHRcdHsjYXdhaXQgbG9hZF9uZXR3b3JrcygpfVxuXHRcdFx0TG9hZGluZy4uLlxuXHRcdHs6dGhlbiBhX25ldHdvcmtzfSBcblx0XHRcdHsjZWFjaCBhX25ldHdvcmtzIGFzIFtwX25ldHdvcmssIGdfbmV0d29ya119XG5cdFx0XHRcdHtAY29uc3QgZ19jaGFpbiA9IGtzX2NoYWlucy5hdChnX25ldHdvcmsuY2hhaW4pfVxuXHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0cmVzb3VyY2U9e2dfbmV0d29ya31cblx0XHRcdFx0XHRyZXNvdXJjZVBhdGg9e3BfbmV0d29ya31cblx0XHRcdFx0XHRpY29uQ2xhc3M9eydzcXVhcmUgcGZwJ31cblx0XHRcdFx0XHRkZXRhaWw9e2Ake2dfY2hhaW4/Lm5hbWV9ICgke2dfY2hhaW4/LmlkfSlgfVxuXHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdC8vIGNyZWF0b3I6IFNpdGVWaWV3LFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fX1cblx0XHRcdFx0PlxuXHRcdFx0XHQ8L1Jvdz5cblx0XHRcdHsvZWFjaH1cblx0XHR7L2F3YWl0fVxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsImltcG9ydCBCbGFua1N2ZWx0ZSBmcm9tICcuL3NjcmVlbi9CbGFuay5zdmVsdGUnO1xuaW1wb3J0IFJlZ2lzdGVyU3ZlbHRlIGZyb20gJy4vc2NyZWVuL1JlZ2lzdGVyLnN2ZWx0ZSc7XG5pbXBvcnQgSG9sZGluZ3NIb21lU3ZlbHRlIGZyb20gJy4vc2NyZWVuL0hvbGRpbmdzSG9tZS5zdmVsdGUnO1xuaW1wb3J0IEFjY291bnRIb21lU3ZlbHRlIGZyb20gJy4vc2NyZWVuL0FjY291bnRzSG9tZS5zdmVsdGUnO1xuaW1wb3J0IENvbnRhY3RzSG9tZVN2ZWx0ZSBmcm9tICcuL3NjcmVlbi9Db250YWN0c0hvbWUuc3ZlbHRlJztcbmltcG9ydCBTaXRlc0hvbWVTdmVsdGUgZnJvbSAnLi9zY3JlZW4vU2l0ZXNIb21lLnN2ZWx0ZSc7XG5pbXBvcnQgTmV0d29ya3NIb21lU3ZlbHRlIGZyb20gJy4vc2NyZWVuL05ldHdvcmtzSG9tZS5zdmVsdGUnO1xuXG5leHBvcnQgZW51bSBUaHJlYWRJZCB7XG5cdERFRkFVTFQ9J2RlZmF1bHQnLFxuXHRJTklUPSdpbml0Jyxcblx0U0VBUkNIPSdzZWFyY2gnLFxuXHRUT0tFTlM9J3Rva2VucycsXG5cdE5GVFM9J25mdHMnLFxuXHRDT05UQUNUUz0nY29udGFjdHMnLFxuXHRISVNUT1JZPSdoaXN0b3J5Jyxcblx0TkVUV09SS1M9J25ldHdvcmtzJyxcblx0QUNDT1VOVFM9J2FjY291bnRzJyxcblx0VEFHUz0ndGFncycsXG5cdFNJVEVTPSdzaXRlcycsXG59XG5cbmV4cG9ydCBjb25zdCBIX1RIUkVBRFMgPSB7XG5cdFtUaHJlYWRJZC5ERUZBVUxUXTogQmxhbmtTdmVsdGUsXG5cdFtUaHJlYWRJZC5JTklUXTogUmVnaXN0ZXJTdmVsdGUsXG5cdC8vIFtUaHJlYWRJZC5TRUFSQ0hdOiBTZWFyY2gsXG5cdFtUaHJlYWRJZC5UT0tFTlNdOiBIb2xkaW5nc0hvbWVTdmVsdGUsXG5cdC8vIFtUaHJlYWRJZC5ORlRTXTogR2FsbGVyeSxcblx0W1RocmVhZElkLkNPTlRBQ1RTXTogQ29udGFjdHNIb21lU3ZlbHRlLFxuXHQvLyBbVGhyZWFkSWQuSElTVE9SWV06IEhpc3RvcnksXG5cdFtUaHJlYWRJZC5ORVRXT1JLU106IE5ldHdvcmtzSG9tZVN2ZWx0ZSxcblx0W1RocmVhZElkLkFDQ09VTlRTXTogQWNjb3VudEhvbWVTdmVsdGUsXG5cdC8vIC8vIFtUaHJlYWRJZC5UYWdzXTogVGFncyxcblx0W1RocmVhZElkLlNJVEVTXTogU2l0ZXNIb21lU3ZlbHRlLFxufSBhcyBjb25zdDtcbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7XG5cdFx0eXdfb3ZlcnNjcm9sbF9wY3QsXG5cdH0gZnJvbSAnIyMvbWVtJztcblxuXHRsZXQgZG1fcHJvZ3Jlc3M6IFNWR0NpcmNsZUVsZW1lbnQ7XG5cblx0Ly8gJDoge1xuXHQvLyBcdGRtX3Byb2dyZXNzLnN0eWxlLiR5d19vdmVyc2Nyb2xsX3BjdFxuXHQvLyB9XG48L3NjcmlwdD5cblxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0c3ZnIHtcblx0XHRkaXNwbGF5OiBub25lO1xuXHRcdHotaW5kZXg6IDIwMDAxO1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDEwcHg7XG5cdFx0bGVmdDogY2FsYyg1MCUgLSAxNnB4KTtcblxuXHRcdC5wcm9ncmVzcyB7XG5cdFx0XHRzdHJva2UtZGFzaGFycmF5OiA2Mjtcblx0XHRcdHN0cm9rZS1kYXNob2Zmc2V0OiA2Mjtcblx0XHRcdHN0cm9rZS1saW5lY2FwOiByb3VuZDtcblx0XHRcdHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgMTAwbXMgbGluZWFyO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuXG48c3ZnIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJvdmVyc2Nyb2xsXCI+XG5cdDxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcdC5vdmVyc2Nyb2xsIHtcblx0XHRcdC5iZyB7XG5cdFx0XHRcdGZpbGw6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQucmluZyB7XG5cdFx0XHRcdGZpbGw6IHRyYW5zcGFyZW50O1xuXHRcdFx0XHRzdHJva2U6ICNjNGM0YzQ7XG5cdFx0XHR9XG5cblx0XHRcdC5wcm9ncmVzcyB7XG5cdFx0XHRcdGZpbGw6IHRyYW5zcGFyZW50O1xuXHRcdFx0XHRzdHJva2U6IGJsYWNrO1xuXHRcdFx0fVxuXHRcdH1cblx0PC9zdHlsZT5cblxuXHQ8Y2lyY2xlIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjE2XCIgY2xhc3M9XCJiZ1wiIC8+XG5cblx0PGNpcmNsZSBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxMFwiIGNsYXNzPVwicmluZ1wiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHlsZT1cIm9wYWNpdHk6MC4yO1wiIC8+XG5cblx0PGNpcmNsZSBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxMFwiIGNsYXNzPVwicHJvZ3Jlc3NcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3R5bGU9XCJzdHJva2UtZGFzaG9mZnNldDp7NjIgLSAoJHl3X292ZXJzY3JvbGxfcGN0ICogNjIpfVwiIGJpbmQ6dGhpcz17ZG1fcHJvZ3Jlc3N9IC8+XG5cdFxuXHQ8IS0tIDxwYXRoIGQ9XCJNMTYgMTYgQTE2IDYge3hhX3BjdH0ge3hhX3BjdH1cIiBjbGFzcz1cInMyci1vdmVyZmxvdy1mZ1wiIC8+IC0tPlxuPC9zdmc+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtcblx0XHR5d19wb3B1cCxcblx0fSBmcm9tICcjIy9tZW0nO1xuXG5cblx0XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0LnBvcHVwIHtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IHZhcigtLWFwcC13aW5kb3ctaGVpZ2h0KTtcblx0XHRsZWZ0OiAwO1xuXHRcdHotaW5kZXg6IDExMDA7XG5cblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuXHRcdHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4zNXMgbGluZWFyO1xuXG5cdFx0Ji5zaG93aW5nIHtcblx0XHRcdHRvcDogMDtcblx0XHRcdHBvaW50ZXItZXZlbnRzOiBpbml0aWFsO1xuXHRcdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuXG5cdFx0XHQ+LmNvbnRlbnQge1xuXHRcdFx0XHQvLyB0b3A6IDI0cHg7XG5cdFx0XHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgyNHB4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQ+LmNvbnRlbnQge1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0Ly8gdG9wOiB2YXIoLS1hcHAtd2luZG93LWhlaWdodCk7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRsZWZ0OiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdHdpZHRoOiBjYWxjKDEwMCUgLSB2YXIoLS11aS1wYWRkaW5nKSAtIHZhcigtLXVpLXBhZGRpbmcpKTtcblx0XHRcdGhlaWdodDogODclO1xuXHRcdFx0b3ZlcmZsb3cteTogc2Nyb2xsO1xuXHRcdFx0LmhpZGUtc2Nyb2xsYmFyKCk7XG5cblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblx0XHRcdGJvcmRlci1yYWRpdXM6IDhweDtcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRwYWRkaW5nOiB2YXIoLS11aS1wYWRkaW5nKTtcblxuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRnYXA6IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHQvLyB0cmFuc2l0aW9uOiB0b3AgNjc1bXMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDY3NW1zIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0XHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSh2YXIoLS1hcHAtd2luZG93LWhlaWdodCkpO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInBvcHVwXCIgY2xhc3M6c2hvd2luZz17bnVsbCAhPT0gJHl3X3BvcHVwfSBvbjpjbGljaz17KCkgPT4gJHl3X3BvcHVwID0gbnVsbH0+XG5cdDxzZWN0aW9uIGNsYXNzPVwic2NyZWVuIGNvbnRlbnRcIiBvbjpjbGljaz17KGRfZXZlbnQpID0+IGRfZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9PlxuXHRcdDxzdmVsdGU6Y29tcG9uZW50IHRoaXM9eyR5d19wb3B1cH0+PC9zdmVsdGU6Y29tcG9uZW50PlxuXHQ8L3NlY3Rpb24+XG48L2Rpdj5cbiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTIgMTZMMTggMTBMMTYuNTkgOC41OUwxMiAxMy4xN0w3LjQxIDguNTlMNiAxMEwxMiAxNlpcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLXRva2Vucy1mZyB7XFxuXFx0XFx0XFx0ZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcblxcdFxcdH1cXG5cXHQ8L3N0eWxlPlxcblxcdDxwYXRoIGNsYXNzPVxcXCJzMnItdG9rZW5zLWZnXFxcIiBkPVxcXCJNMTUgNGMtNC40MiAwLTggMy41OC04IDhzMy41OCA4IDggOCA4LTMuNTggOC04LTMuNTgtOC04LThabTAgMTRjLTMuMzEgMC02LTIuNjktNi02czIuNjktNiA2LTYgNiAyLjY5IDYgNi0yLjY5IDYtNiA2Wk0zIDEyYTUuOTkgNS45OSAwIDAgMSA0LTUuNjVWNC4yNkMzLjU1IDUuMTUgMSA4LjI3IDEgMTJjMCAzLjczIDIuNTUgNi44NSA2IDcuNzR2LTIuMDlBNS45OSA1Ljk5IDAgMCAxIDMgMTJaXFxcIiAvPlxcbjwvc3ZnPlxcblwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+XFxuXFx0XFx0LnMyci1oaXN0b3J5LWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1uYXYtaGlzdG9yeS1mZ1xcXCIgZD1cXFwiTTEzIDNhOSA5IDAgMCAwLTkgOUgxbDMuODkgMy44OS4wNy4xNEw5IDEySDZjMC0zLjg3IDMuMTMtNyA3LTdzNyAzLjEzIDcgNy0zLjEzIDctNyA3Yy0xLjkzIDAtMy42OC0uNzktNC45NC0yLjA2bC0xLjQyIDEuNDJBOC45NTQgOC45NTQgMCAwIDAgMTMgMjFhOSA5IDAgMCAwIDAtMThabS0xIDV2NWw0LjI1IDIuNTIuNzctMS4yOC0zLjUyLTIuMDlWOEgxMlpcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLW1lbnUtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0PC9zdHlsZT5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLW1lbnUtZmdcXFwiIGQ9XFxcIk00IDE5aDE2Yy41NSAwIDEtLjQ1IDEtMXMtLjQ1LTEtMS0xSDRjLS41NSAwLTEgLjQ1LTEgMXMuNDUgMSAxIDFabTAtNmgxNmMuNTUgMCAxLS40NSAxLTFzLS40NS0xLTEtMUg0Yy0uNTUgMC0xIC40NS0xIDFzLjQ1IDEgMSAxWk0zIDZjMCAuNTUuNDUgMSAxIDFoMTZjLjU1IDAgMS0uNDUgMS0xcy0uNDUtMS0xLTFINGMtLjU1IDAtMSAuNDUtMSAxWlxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IEhfVEhSRUFEUywgVGhyZWFkSWQgfSBmcm9tICcjIy9kZWYnO1xuXHRpbXBvcnQge1xuXHRcdHl3X3BhdHRlcm4sXG5cdFx0eXdfbmF2X2NvbGxhcHNlZCxcblx0XHQvLyB5d190aHJlYWRfaWQsXG5cdFx0eXdfbmF2X3Zpc2libGUsXG5cdFx0eXdfbWVudV9leHBhbmRlZCxcblx0XHR5d19ibHVyLFxuXHRcdHl3X292ZXJsYXlfbmV0d29yayxcblx0XHR5d19vdmVybGF5X2FjY291bnQsXG5cdFx0eXdfbm90aWZpY2F0aW9ucyxcblx0XHR5d19uYXZpZ2F0b3IsXG5cdFx0eXdfcGFnZSxcblx0XHR5d190aHJlYWQsXG5cdH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgeyBvZGUsIG9kZXJhYywgb2Rlcm9tIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCBTWF9JQ09OX0VYUEFORCBmcm9tICcjL2ljb24vZXhwYW5kLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9UT0tFTlMgZnJvbSAnIy9pY29uL3Rva2Vucy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ09OVEFDVFMgZnJvbSAnIy9pY29uL2FjY291bnRfYm94LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9ISVNUT1JZIGZyb20gJyMvaWNvbi9oaXN0b3J5LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9ORlQgZnJvbSAnIy9pY29uL25mdHMuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX01FTlUgZnJvbSAnIy9pY29uL21lbnUuc3ZnP3Jhdyc7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IFBhZ2UgfSBmcm9tICcjL2FwcC9uYXYvcGFnZSc7XG5cdGltcG9ydCBIb2xkaW5nc0hvbWUgZnJvbSAnIy9hcHAvc2NyZWVuL0hvbGRpbmdzSG9tZS5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvciB9IGZyb20gJyMvbWV0YS9zdmVsdGUnO1xuXG5cdC8vIG5hdiBiYXIgZGVmaW5pdGlvblxuXHRjb25zdCBIX0JVVFRPTlMgPSB7XG5cdFx0W1RocmVhZElkLlRPS0VOU106IHtcblx0XHRcdHN2ZzogU1hfSUNPTl9UT0tFTlMsXG5cdFx0XHRsYWJlbDogJ1Rva2VucycsXG5cdFx0fSxcblx0XHRbVGhyZWFkSWQuQ09OVEFDVFNdOiB7XG5cdFx0XHRzdmc6IFNYX0lDT05fQ09OVEFDVFMsXG5cdFx0XHRsYWJlbDogJ0NvbnRhY3RzJyxcblx0XHR9LFxuXHRcdC8vIFtUaHJlYWRJZC5ORlRTXToge1xuXHRcdC8vIFx0c3ZnOiBTWF9JQ09OX05GVCxcblx0XHQvLyBcdGxhYmVsOiAnTkZUcycsXG5cdFx0Ly8gfSxcblx0XHRbVGhyZWFkSWQuSElTVE9SWV06IHtcblx0XHRcdHN2ZzogU1hfSUNPTl9ISVNUT1JZLFxuXHRcdFx0bGFiZWw6ICdIaXN0b3J5Jyxcblx0XHR9LFxuXHRcdG1lbnU6IHtcblx0XHRcdHN2ZzogU1hfSUNPTl9NRU5VLFxuXHRcdFx0bGFiZWw6ICdNZW51Jyxcblx0XHR9LFxuXHR9IGFzIFJlY29yZDxzdHJpbmcsIHtcblx0XHRzdmc6IHN0cmluZztcblx0XHRsYWJlbDogc3RyaW5nO1xuXHR9PjtcblxuXHRjb25zdCBITV9IT01FU0NSRUVOUyA9IG5ldyBNYXA8UGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yLCBUaHJlYWRJZD4oXG5cdFx0b2RlcmFjKEhfVEhSRUFEUywgKHNpX3RocmVhZCwgZGNfY3JlYXRvcikgPT4gW2RjX2NyZWF0b3IsIHNpX3RocmVhZCBhcyBUaHJlYWRJZF0pKTtcblxuXHRsZXQgc2lfdGhyZWFkX2hlYWQ6ICcnIHwgVGhyZWFkSWQgPSAnJztcblx0JDogc2lfdGhyZWFkX2hlYWQgPSAkeXdfcGFnZT8gSE1fSE9NRVNDUkVFTlMuZ2V0KCR5d19wYWdlLmNyZWF0b3IpIHx8ICcnOiAnJztcblxuXHRcblx0ZnVuY3Rpb24gdG9nZ2xlX2NvbGxhcHNlZCgpIHtcblx0XHQkeXdfbmF2X2NvbGxhcHNlZCA9ICEkeXdfbmF2X2NvbGxhcHNlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIG5hdl9jbGljayhzaV9idXR0b246IHN0cmluZykge1xuXHRcdC8vIHJlbW92ZSBub3RpZmljYXRpb25cblx0XHQkeXdfbm90aWZpY2F0aW9ucyA9ICR5d19ub3RpZmljYXRpb25zLmZpbHRlcihzaSA9PiBzaV9idXR0b24gIT09IHNpKTtcblxuXHRcdC8vIGJsdXIgaXMgYWN0aXZlXG5cdFx0aWYoJHl3X2JsdXIpIHtcblx0XHRcdC8vIGNhbmNlbCBibHVyXG5cdFx0XHQkeXdfYmx1ciA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIG5ldHdvcmsgb3ZlcmxheSBpcyBhY3RpdmVcblx0XHRpZigkeXdfb3ZlcmxheV9uZXR3b3JrKSB7XG5cdFx0XHQkeXdfb3ZlcmxheV9uZXR3b3JrID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gYWNjb3VudCBvdmVybGF5IGlzIGFjdGl2ZVxuXHRcdGlmKCR5d19vdmVybGF5X2FjY291bnQpIHtcblx0XHRcdCR5d19vdmVybGF5X2FjY291bnQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBkZXBlbmRpbmcgb24gYnV0dG9uIGNsaWNrXG5cdFx0c3dpdGNoKHNpX2J1dHRvbikge1xuXHRcdFx0Ly8gbWVudVxuXHRcdFx0Y2FzZSAnbWVudSc6IHtcblx0XHRcdFx0Ly8gZXhwYW5kIG1lbnVcblx0XHRcdFx0JHl3X21lbnVfZXhwYW5kZWQgPSB0cnVlO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjdXJyZW50IHRocmVhZCBoZWFkIGxvYWRlZFxuXHRcdFx0Y2FzZSBzaV90aHJlYWRfaGVhZDoge1xuXHRcdFx0XHQvLyBzY3JvbGwgdG8gdG9wIHNtb290aGx5XG5cdFx0XHRcdCR5d19uYXZpZ2F0b3IuYWN0aXZlUGFnZS5kb20uc2Nyb2xsVG8oe1xuXHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdGJlaGF2aW9yOiAnc21vb3RoJyxcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdpdGhpbiB0aGlzIHRocmVhZFxuXHRcdFx0Y2FzZSAkeXdfdGhyZWFkLmlkOiB7XG5cdFx0XHRcdC8vIHByZXZpb3VzOyBwb3Bcblx0XHRcdFx0Y29uc3Qga19wcmV2aW91cyA9ICR5d19wYWdlLnBlYWsoKTtcblx0XHRcdFx0aWYoa19wcmV2aW91cyAmJiBITV9IT01FU0NSRUVOUy5nZXQoa19wcmV2aW91cy5jcmVhdG9yKSA9PT0gJHl3X3RocmVhZC5pZCkge1xuXHRcdFx0XHRcdCR5d19wYWdlLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGN1cnJlbnQgdGhyZWFkIHdvbid0IGNhdXNlIHVwZGF0ZVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQkeXdfcGFnZS5yZXNldCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN3aXRjaCB0aHJlYWRcblx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0Ly8gJHl3X3RocmVhZF9pZCA9IHNpX2J1dHRvbiBhcyBUaHJlYWRJZDtcblx0XHRcdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKHNpX2J1dHRvbiBhcyBUaHJlYWRJZCk7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBjb25zdCBITV9IT01FU0NSRUVOUyA9IG5ldyBNYXA8UGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yLCBUaHJlYWRJZD4oW1xuXHQvLyBcdFtIb2xkaW5ncywgVGhyZWFkSWQuVE9LRU5TXSxcblx0Ly8gXHRbQ29udGFjdExpc3QsIFRocmVhZElkLkNPTlRBQ1RTXSxcblx0Ly8gXSk7XG5cblx0Ly8gY29uc3QgSF9IT01FUzogUmVjb3JkPHN0cmluZywgVGhyZWFkSWQ+ID0ge1xuXHQvLyBcdCcvZmFtaWxpZXMve2ZhbWlseUlkfS9jaGFpbnMve2NoYWluSWR9L2hvbGRpbmdzL3thY2NvdW50SWR9JzogVGhyZWFkSWQuVE9LRU5TLFxuXHQvLyBcdCcvZmFtaWxpZXMve2ZhbWlseUlkfS9jaGFpbnMve2NoYWluSWR9L2dhbGxlcnkve2FjY291bnRJZH0nOiBUaHJlYWRJZC5ORlRTLFxuXHQvLyBcdCcvY29udGFjdHMnOiBUaHJlYWRJZC5DT05UQUNUUyxcblx0Ly8gXHQvLyAnL25ldHdvcmtzJzogVGhyZWFkSWQuTkVUV09SS1MsXG5cdC8vIFx0Jy9hY2NvdW50cyc6IFRocmVhZElkLkFDQ09VTlRTLFxuXHQvLyBcdCcvaGlzdG9yeSc6IFRocmVhZElkLkhJU1RPUlksXG5cdC8vIH07XG5cblx0Ly8gbGV0IHNpX3RocmVhZF9oZWFkOiAnJyB8IFRocmVhZElkID0gJyc7XG5cdC8vICQ6IHtcblx0Ly8gXHQkeXdfcGFnZVxuXHQvLyBcdCR5d190aHJlYWRcblx0Ly8gXHQvLyBjb25zdCBzeF9wYXR0ZXJuID0gJHl3X3BhdHRlcm47XG5cblx0Ly8gXHRzaV90aHJlYWRfaGVhZCA9IEhfSE9NRVNbc3hfcGF0dGVybl0gfHwgJyc7XG5cdC8vIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHRuYXYge1xuXHRcdC0tbmF2LWhlaWdodDogNzJweDtcblxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRib3R0b206IDA7XG5cdFx0aGVpZ2h0OiB2YXIoLS1uYXYtaGVpZ2h0KTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0ei1pbmRleDogMTAwMDtcblxuXHRcdHRyYW5zaXRpb246IGJvdHRvbSAxcyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cblx0XHRkaXNwbGF5OiBub25lO1xuXHRcdCYudmlzaWJsZSB7XG5cdFx0XHRkaXNwbGF5OiBpbml0aWFsO1xuXHRcdH1cblxuXHRcdCYuY29sbGFwc2VkIHtcblx0XHRcdGJvdHRvbTogY2FsYygwcHggLSB2YXIoLS1uYXYtaGVpZ2h0KSk7XG5cblx0XHRcdD4uY29sbGFwc2UuaWNvbj5zdmcge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHR0cmFuc2Zvcm06IHJvdGF0ZSgtMTgwZGVnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdD4uY29sbGFwc2UuaWNvbiB7XG5cdFx0XHQtLWJ1dHRvbi1kaWFtZXRlcjogMzJweDtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblxuXHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRyaWdodDogMDtcblx0XHRcdHRvcDogY2FsYygwcHggLSB2YXIoLS1idXR0b24tZGlhbWV0ZXIpKTtcblxuXHRcdFx0Ym9yZGVyLXJhZGl1czogMDtcblx0XHRcdGJvcmRlci1ib3R0b20td2lkdGg6IDA7XG5cdFx0XHRib3JkZXItY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXG5cdFx0XHQ+c3ZnIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDFzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0fVxuXG5cdFx0Pi5iYXIge1xuXHRcdFx0bGlzdC1zdHlsZTogbm9uZTtcblx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRtYXJnaW46IDA7XG5cblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cblx0XHRcdGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXG5cdFx0XHQ+LmJ1dHRvbiB7XG5cdFx0XHRcdGZsZXg6IDE7XG5cdFx0XHRcdHBhZGRpbmctdG9wOiAxMXB4O1xuXHRcdFx0XHRwYWRkaW5nLWJvdHRvbTogMTJweDtcblxuXHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblxuXHRcdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cblx0XHRcdFx0Ji5hY3RpdmUge1xuXHRcdFx0XHRcdCYudG9rZW5zIHtcblx0XHRcdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ji5jb250YWN0cyB7XG5cdFx0XHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCYubmZ0cyB7XG5cdFx0XHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCYuaGlzdG9yeSB7XG5cdFx0XHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pi5sYWJlbCB7XG5cdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5pY29uIHtcblx0XHRcdFx0XHQuaW5oZXJpdCgtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Lm5vdGlmaWNhdGlvbiB7XG5cdFx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHRcdHdpZHRoOiA3cHg7XG5cdFx0XHRcdFx0aGVpZ2h0OiA3cHg7XG5cdFx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3Itc2t5KTtcblx0XHRcdFx0XHRib3JkZXItcmFkaXVzOiA3cHg7XG5cdFx0XHRcdFx0bWFyZ2luLXRvcDogMTVweDtcblx0XHRcdFx0XHRib3JkZXI6IDJweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRcdFx0bWFyZ2luLWxlZnQ6IC05cHg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LmxhYmVsIHtcblx0XHRcdFx0XHRmb250LXNpemU6IDExcHg7XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPG5hdiBjbGFzczpjb2xsYXBzZWQ9eyR5d19uYXZfY29sbGFwc2VkfSBjbGFzczp2aXNpYmxlPXskeXdfbmF2X3Zpc2libGV9PlxuXHQ8ZGl2IGNsYXNzPVwiY29sbGFwc2UgaWNvblwiIG9uOmNsaWNrPXsoKSA9PiB0b2dnbGVfY29sbGFwc2VkKCl9PlxuXHRcdHtAaHRtbCBTWF9JQ09OX0VYUEFORH1cblx0PC9kaXY+XG5cdDx1bCBjbGFzcz1cImJhclwiPlxuXHRcdHsjZWFjaCBvZGUoSF9CVVRUT05TKSBhcyBbc2lfYnV0dG9uLCBnX2J1dHRvbl19XG5cdFx0XHQ8bGkgY2xhc3M9XCJidXR0b24ge3NpX2J1dHRvbn1cIiBjbGFzczphY3RpdmU9e3NpX3RocmVhZF9oZWFkID09PSBzaV9idXR0b259IG9uOmNsaWNrPXsoKSA9PiBuYXZfY2xpY2soc2lfYnV0dG9uKX0+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0e0BodG1sIGdfYnV0dG9uLnN2Z31cblxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibm90aWZpY2F0aW9uXCIgY2xhc3M6ZGlzcGxheV9ub25lPXshJHl3X25vdGlmaWNhdGlvbnMuaW5jbHVkZXMoc2lfYnV0dG9uKX0+PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImxhYmVsXCI+XG5cdFx0XHRcdFx0e2dfYnV0dG9uLmxhYmVsfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvbGk+XG5cdFx0ey9lYWNofVxuXHRcdDwvdWw+XG48L25hdj5cbiIsIi8qKlxuICogRnVzZS5qcyB2Ni42LjIgLSBMaWdodHdlaWdodCBmdXp6eS1zZWFyY2ggKGh0dHA6Ly9mdXNlanMuaW8pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIyIEtpcm8gUmlzayAoaHR0cDovL2tpcm8ubWUpXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiBBcGFjaGUgU29mdHdhcmUgTGljZW5zZSAyLjBcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheVxuICAgID8gZ2V0VGFnKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWx1ZSlcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzXG5jb25zdCBJTkZJTklUWSA9IDEgLyAwO1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBsZXQgcmVzdWx0ID0gdmFsdWUgKyAnJztcbiAgcmV0dXJuIHJlc3VsdCA9PSAnMCcgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/ICctMCcgOiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9pc0Jvb2xlYW4uanNcbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlID09PSB0cnVlIHx8XG4gICAgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSAnW29iamVjdCBCb29sZWFuXScpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuLy8gQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNCbGFuayh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlLnRyaW0oKS5sZW5ndGhcbn1cblxuLy8gR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvZ2V0VGFnLmpzXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJ1tvYmplY3QgVW5kZWZpbmVkXSdcbiAgICAgIDogJ1tvYmplY3QgTnVsbF0nXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbmNvbnN0IEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSA9ICdFeHRlbmRlZCBzZWFyY2ggaXMgbm90IGF2YWlsYWJsZSc7XG5cbmNvbnN0IElOQ09SUkVDVF9JTkRFWF9UWVBFID0gXCJJbmNvcnJlY3QgJ2luZGV4JyB0eXBlXCI7XG5cbmNvbnN0IExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWSA9IChrZXkpID0+XG4gIGBJbnZhbGlkIHZhbHVlIGZvciBrZXkgJHtrZXl9YDtcblxuY29uc3QgUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFID0gKG1heCkgPT5cbiAgYFBhdHRlcm4gbGVuZ3RoIGV4Y2VlZHMgbWF4IG9mICR7bWF4fS5gO1xuXG5jb25zdCBNSVNTSU5HX0tFWV9QUk9QRVJUWSA9IChuYW1lKSA9PiBgTWlzc2luZyAke25hbWV9IHByb3BlcnR5IGluIGtleWA7XG5cbmNvbnN0IElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRSA9IChrZXkpID0+XG4gIGBQcm9wZXJ0eSAnd2VpZ2h0JyBpbiBrZXkgJyR7a2V5fScgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgO1xuXG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5jbGFzcyBLZXlTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fa2V5TWFwID0ge307XG5cbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxldCBvYmogPSBjcmVhdGVLZXkoa2V5KTtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcblxuICAgICAgdGhpcy5fa2V5cy5wdXNoKG9iaik7XG4gICAgICB0aGlzLl9rZXlNYXBbb2JqLmlkXSA9IG9iajtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIE5vcm1hbGl6ZSB3ZWlnaHRzIHNvIHRoYXQgdGhlaXIgc3VtIGlzIGVxdWFsIHRvIDFcbiAgICB0aGlzLl9rZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAga2V5LndlaWdodCAvPSB0b3RhbFdlaWdodDtcbiAgICB9KTtcbiAgfVxuICBnZXQoa2V5SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5TWFwW2tleUlkXVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2tleXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICBsZXQgcGF0aCA9IG51bGw7XG4gIGxldCBpZCA9IG51bGw7XG4gIGxldCBzcmMgPSBudWxsO1xuICBsZXQgd2VpZ2h0ID0gMTtcbiAgbGV0IGdldEZuID0gbnVsbDtcblxuICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBpc0FycmF5KGtleSkpIHtcbiAgICBzcmMgPSBrZXk7XG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgoa2V5KTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChrZXksICduYW1lJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX0tFWV9QUk9QRVJUWSgnbmFtZScpKVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBrZXkubmFtZTtcbiAgICBzcmMgPSBuYW1lO1xuXG4gICAgaWYgKGhhc093bi5jYWxsKGtleSwgJ3dlaWdodCcpKSB7XG4gICAgICB3ZWlnaHQgPSBrZXkud2VpZ2h0O1xuXG4gICAgICBpZiAod2VpZ2h0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRShuYW1lKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoID0gY3JlYXRlS2V5UGF0aChuYW1lKTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKG5hbWUpO1xuICAgIGdldEZuID0ga2V5LmdldEZuO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aCwgaWQsIHdlaWdodCwgc3JjLCBnZXRGbiB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVBhdGgoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkgOiBrZXkuc3BsaXQoJy4nKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlJZChrZXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkoa2V5KSA/IGtleS5qb2luKCcuJykgOiBrZXlcbn1cblxuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICBsZXQgbGlzdCA9IFtdO1xuICBsZXQgYXJyID0gZmFsc2U7XG5cbiAgY29uc3QgZGVlcEdldCA9IChvYmosIHBhdGgsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQob2JqKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcGF0aFtpbmRleF0pIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGF0aCBsZWZ0LCB3ZSd2ZSBhcnJpdmVkIGF0IHRoZSBvYmplY3Qgd2UgY2FyZSBhYm91dC5cbiAgICAgIGxpc3QucHVzaChvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQga2V5ID0gcGF0aFtpbmRleF07XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGxhc3QgdmFsdWUgaW4gdGhlIHBhdGgsIGFuZCBpZiBpdCdzIGEgc3RyaW5nL251bWJlci9ib29sLFxuICAgICAgLy8gYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgICBpZiAoXG4gICAgICAgIGluZGV4ID09PSBwYXRoLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc051bWJlcih2YWx1ZSkgfHwgaXNCb29sZWFuKHZhbHVlKSlcbiAgICAgICkge1xuICAgICAgICBsaXN0LnB1c2godG9TdHJpbmcodmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYXJyID0gdHJ1ZTtcbiAgICAgICAgLy8gU2VhcmNoIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGRlZXBHZXQodmFsdWVbaV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gQW4gb2JqZWN0LiBSZWN1cnNlIGZ1cnRoZXIuXG4gICAgICAgIGRlZXBHZXQodmFsdWUsIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChzaW5jZSBwYXRoIHVzZWQgdG8gYmUgYSBzdHJpbmcpXG4gIGRlZXBHZXQob2JqLCBpc1N0cmluZyhwYXRoKSA/IHBhdGguc3BsaXQoJy4nKSA6IHBhdGgsIDApO1xuXG4gIHJldHVybiBhcnIgPyBsaXN0IDogbGlzdFswXVxufVxuXG5jb25zdCBNYXRjaE9wdGlvbnMgPSB7XG4gIC8vIFdoZXRoZXIgdGhlIG1hdGNoZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgc2V0LiBXaGVuIGB0cnVlYCwgZWFjaCByZWNvcmQgaW4gdGhlIHJlc3VsdFxuICAvLyBzZXQgd2lsbCBpbmNsdWRlIHRoZSBpbmRpY2VzIG9mIHRoZSBtYXRjaGVkIGNoYXJhY3RlcnMuXG4gIC8vIFRoZXNlIGNhbiBjb25zZXF1ZW50bHkgYmUgdXNlZCBmb3IgaGlnaGxpZ2h0aW5nIHB1cnBvc2VzLlxuICBpbmNsdWRlTWF0Y2hlczogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICAvLyBhIHBlcmZlY3QgbWF0Y2ggaGFzIGFscmVhZHkgYmVlbiBsb2NhdGVkIGluIHRoZSBzdHJpbmcuXG4gIGZpbmRBbGxNYXRjaGVzOiBmYWxzZSxcbiAgLy8gTWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgbWF0Y2hlZCBiZWZvcmUgYSByZXN1bHQgaXMgY29uc2lkZXJlZCBhIG1hdGNoXG4gIG1pbk1hdGNoQ2hhckxlbmd0aDogMVxufTtcblxuY29uc3QgQmFzaWNPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGFsZ29yaXRobSBjb250aW51ZXMgc2VhcmNoaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IGV2ZW4gaWYgYSBwZXJmZWN0XG4gIC8vIG1hdGNoIGlzIGZvdW5kIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBzYW1lIGlucHV0LlxuICBpc0Nhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAvLyBXaGVuIHRydWUsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIHRvIHRoZSBlbmQgb2YgYSBzZWFyY2ggcGF0dGVybiBldmVuIGlmXG4gIGluY2x1ZGVTY29yZTogZmFsc2UsXG4gIC8vIExpc3Qgb2YgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQuIFRoaXMgYWxzbyBzdXBwb3J0cyBuZXN0ZWQgcHJvcGVydGllcy5cbiAga2V5czogW10sXG4gIC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgcmVzdWx0IGxpc3QsIGJ5IHNjb3JlXG4gIHNob3VsZFNvcnQ6IHRydWUsXG4gIC8vIERlZmF1bHQgc29ydCBmdW5jdGlvbjogc29ydCBieSBhc2NlbmRpbmcgc2NvcmUsIGFzY2VuZGluZyBpbmRleFxuICBzb3J0Rm46IChhLCBiKSA9PlxuICAgIGEuc2NvcmUgPT09IGIuc2NvcmUgPyAoYS5pZHggPCBiLmlkeCA/IC0xIDogMSkgOiBhLnNjb3JlIDwgYi5zY29yZSA/IC0xIDogMVxufTtcblxuY29uc3QgRnV6enlPcHRpb25zID0ge1xuICAvLyBBcHByb3hpbWF0ZWx5IHdoZXJlIGluIHRoZSB0ZXh0IGlzIHRoZSBwYXR0ZXJuIGV4cGVjdGVkIHRvIGJlIGZvdW5kP1xuICBsb2NhdGlvbjogMCxcbiAgLy8gQXQgd2hhdCBwb2ludCBkb2VzIHRoZSBtYXRjaCBhbGdvcml0aG0gZ2l2ZSB1cC4gQSB0aHJlc2hvbGQgb2YgJzAuMCcgcmVxdWlyZXMgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIChvZiBib3RoIGxldHRlcnMgYW5kIGxvY2F0aW9uKSwgYSB0aHJlc2hvbGQgb2YgJzEuMCcgd291bGQgbWF0Y2ggYW55dGhpbmcuXG4gIHRocmVzaG9sZDogMC42LFxuICAvLyBEZXRlcm1pbmVzIGhvdyBjbG9zZSB0aGUgbWF0Y2ggbXVzdCBiZSB0byB0aGUgZnV6enkgbG9jYXRpb24gKHNwZWNpZmllZCBhYm92ZSkuXG4gIC8vIEFuIGV4YWN0IGxldHRlciBtYXRjaCB3aGljaCBpcyAnZGlzdGFuY2UnIGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBmdXp6eSBsb2NhdGlvblxuICAvLyB3b3VsZCBzY29yZSBhcyBhIGNvbXBsZXRlIG1pc21hdGNoLiBBIGRpc3RhbmNlIG9mICcwJyByZXF1aXJlcyB0aGUgbWF0Y2ggYmUgYXRcbiAgLy8gdGhlIGV4YWN0IGxvY2F0aW9uIHNwZWNpZmllZCwgYSB0aHJlc2hvbGQgb2YgJzEwMDAnIHdvdWxkIHJlcXVpcmUgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIHRvIGJlIHdpdGhpbiA4MDAgY2hhcmFjdGVycyBvZiB0aGUgZnV6enkgbG9jYXRpb24gdG8gYmUgZm91bmQgdXNpbmcgYSAwLjggdGhyZXNob2xkLlxuICBkaXN0YW5jZTogMTAwXG59O1xuXG5jb25zdCBBZHZhbmNlZE9wdGlvbnMgPSB7XG4gIC8vIFdoZW4gYHRydWVgLCBpdCBlbmFibGVzIHRoZSB1c2Ugb2YgdW5peC1saWtlIHNlYXJjaCBjb21tYW5kc1xuICB1c2VFeHRlbmRlZFNlYXJjaDogZmFsc2UsXG4gIC8vIFRoZSBnZXQgZnVuY3Rpb24gdG8gdXNlIHdoZW4gZmV0Y2hpbmcgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gVGhlIGRlZmF1bHQgd2lsbCBzZWFyY2ggbmVzdGVkIHBhdGhzICppZSBmb28uYmFyLmJheipcbiAgZ2V0Rm46IGdldCxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHNlYXJjaCB3aWxsIGlnbm9yZSBgbG9jYXRpb25gIGFuZCBgZGlzdGFuY2VgLCBzbyBpdCB3b24ndCBtYXR0ZXJcbiAgLy8gd2hlcmUgaW4gdGhlIHN0cmluZyB0aGUgcGF0dGVybiBhcHBlYXJzLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZnV6emluZXNzLXNjb3JlXG4gIGlnbm9yZUxvY2F0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBjYWxjdWxhdGlvbiBmb3IgdGhlIHJlbGV2YW5jZSBzY29yZSAodXNlZCBmb3Igc29ydGluZykgd2lsbFxuICAvLyBpZ25vcmUgdGhlIGZpZWxkLWxlbmd0aCBub3JtLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZmllbGQtbGVuZ3RoLW5vcm1cbiAgaWdub3JlRmllbGROb3JtOiBmYWxzZSxcbiAgLy8gVGhlIHdlaWdodCB0byBkZXRlcm1pbmUgaG93IG11Y2ggZmllbGQgbGVuZ3RoIG5vcm0gZWZmZWN0cyBzY29yaW5nLlxuICBmaWVsZE5vcm1XZWlnaHQ6IDFcbn07XG5cbnZhciBDb25maWcgPSB7XG4gIC4uLkJhc2ljT3B0aW9ucyxcbiAgLi4uTWF0Y2hPcHRpb25zLFxuICAuLi5GdXp6eU9wdGlvbnMsXG4gIC4uLkFkdmFuY2VkT3B0aW9uc1xufTtcblxuY29uc3QgU1BBQ0UgPSAvW14gXSsvZztcblxuLy8gRmllbGQtbGVuZ3RoIG5vcm06IHRoZSBzaG9ydGVyIHRoZSBmaWVsZCwgdGhlIGhpZ2hlciB0aGUgd2VpZ2h0LlxuLy8gU2V0IHRvIDMgZGVjaW1hbHMgdG8gcmVkdWNlIGluZGV4IHNpemUuXG5mdW5jdGlvbiBub3JtKHdlaWdodCA9IDEsIG1hbnRpc3NhID0gMykge1xuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbSA9IE1hdGgucG93KDEwLCBtYW50aXNzYSk7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQodmFsdWUpIHtcbiAgICAgIGNvbnN0IG51bVRva2VucyA9IHZhbHVlLm1hdGNoKFNQQUNFKS5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMobnVtVG9rZW5zKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG51bVRva2VucylcbiAgICAgIH1cblxuICAgICAgLy8gRGVmYXVsdCBmdW5jdGlvbiBpcyAxL3NxcnQoeCksIHdlaWdodCBtYWtlcyB0aGF0IHZhcmlhYmxlXG4gICAgICBjb25zdCBub3JtID0gMSAvIE1hdGgucG93KG51bVRva2VucywgMC41ICogd2VpZ2h0KTtcblxuICAgICAgLy8gSW4gcGxhY2Ugb2YgYHRvRml4ZWQobWFudGlzc2EpYCwgZm9yIGZhc3RlciBjb21wdXRhdGlvblxuICAgICAgY29uc3QgbiA9IHBhcnNlRmxvYXQoTWF0aC5yb3VuZChub3JtICogbSkgLyBtKTtcblxuICAgICAgY2FjaGUuc2V0KG51bVRva2Vucywgbik7XG5cbiAgICAgIHJldHVybiBuXG4gICAgfSxcbiAgICBjbGVhcigpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1c2VJbmRleCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZXRGbiA9IENvbmZpZy5nZXRGbixcbiAgICBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHRoaXMubm9ybSA9IG5vcm0oZmllbGROb3JtV2VpZ2h0LCAzKTtcbiAgICB0aGlzLmdldEZuID0gZ2V0Rm47XG4gICAgdGhpcy5pc0NyZWF0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0SW5kZXhSZWNvcmRzKCk7XG4gIH1cbiAgc2V0U291cmNlcyhkb2NzID0gW10pIHtcbiAgICB0aGlzLmRvY3MgPSBkb2NzO1xuICB9XG4gIHNldEluZGV4UmVjb3JkcyhyZWNvcmRzID0gW10pIHtcbiAgICB0aGlzLnJlY29yZHMgPSByZWNvcmRzO1xuICB9XG4gIHNldEtleXMoa2V5cyA9IFtdKSB7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLl9rZXlzTWFwID0ge307XG4gICAga2V5cy5mb3JFYWNoKChrZXksIGlkeCkgPT4ge1xuICAgICAgdGhpcy5fa2V5c01hcFtrZXkuaWRdID0gaWR4O1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZSgpIHtcbiAgICBpZiAodGhpcy5pc0NyZWF0ZWQgfHwgIXRoaXMuZG9jcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuaXNDcmVhdGVkID0gdHJ1ZTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8U3RyaW5nPlxuICAgIGlmIChpc1N0cmluZyh0aGlzLmRvY3NbMF0pKSB7XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdCBpcyBBcnJheTxPYmplY3Q+XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm5vcm0uY2xlYXIoKTtcbiAgfVxuICAvLyBBZGRzIGEgZG9jIHRvIHRoZSBlbmQgb2YgdGhlIGluZGV4XG4gIGFkZChkb2MpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnNpemUoKTtcblxuICAgIGlmIChpc1N0cmluZyhkb2MpKSB7XG4gICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBpZHgpO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmVzIHRoZSBkb2MgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvZiB0aGUgaW5kZXhcbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5yZWNvcmRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgLy8gQ2hhbmdlIHJlZiBpbmRleCBvZiBldmVyeSBzdWJzcXVlbnQgZG9jXG4gICAgZm9yIChsZXQgaSA9IGlkeCwgbGVuID0gdGhpcy5zaXplKCk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5yZWNvcmRzW2ldLmkgLT0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCkge1xuICAgIHJldHVybiBpdGVtW3RoaXMuX2tleXNNYXBba2V5SWRdXVxuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb3Jkcy5sZW5ndGhcbiAgfVxuICBfYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpIHx8IGlzQmxhbmsoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJlY29yZCA9IHtcbiAgICAgIHY6IGRvYyxcbiAgICAgIGk6IGRvY0luZGV4LFxuICAgICAgbjogdGhpcy5ub3JtLmdldChkb2MpXG4gICAgfTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgX2FkZE9iamVjdChkb2MsIGRvY0luZGV4KSB7XG4gICAgbGV0IHJlY29yZCA9IHsgaTogZG9jSW5kZXgsICQ6IHt9IH07XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgdGhpcy5rZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGtleS5nZXRGbiA/IGtleS5nZXRGbihkb2MpIDogdGhpcy5nZXRGbihkb2MsIGtleS5wYXRoKTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbeyBuZXN0ZWRBcnJJbmRleDogLTEsIHZhbHVlIH1dO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB7IG5lc3RlZEFyckluZGV4LCB2YWx1ZSB9ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAgICAgICBpOiBuZXN0ZWRBcnJJbmRleCxcbiAgICAgICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN1YlJlY29yZHMucHVzaChzdWJSZWNvcmQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGspID0+IHtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgbmVzdGVkQXJySW5kZXg6IGssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZHM7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICByZWNvcmRzOiB0aGlzLnJlY29yZHNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5kZXgoXG4gIGtleXMsXG4gIGRvY3MsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiwgZmllbGROb3JtV2VpZ2h0IH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cy5tYXAoY3JlYXRlS2V5KSk7XG4gIG15SW5kZXguc2V0U291cmNlcyhkb2NzKTtcbiAgbXlJbmRleC5jcmVhdGUoKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gcGFyc2VJbmRleChcbiAgZGF0YSxcbiAgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiwgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodCB9ID0ge31cbikge1xuICBjb25zdCB7IGtleXMsIHJlY29yZHMgfSA9IGRhdGE7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMpO1xuICBteUluZGV4LnNldEluZGV4UmVjb3JkcyhyZWNvcmRzKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlJDEoXG4gIHBhdHRlcm4sXG4gIHtcbiAgICBlcnJvcnMgPSAwLFxuICAgIGN1cnJlbnRMb2NhdGlvbiA9IDAsXG4gICAgZXhwZWN0ZWRMb2NhdGlvbiA9IDAsXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgYWNjdXJhY3kgPSBlcnJvcnMgLyBwYXR0ZXJuLmxlbmd0aDtcblxuICBpZiAoaWdub3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm4gYWNjdXJhY3lcbiAgfVxuXG4gIGNvbnN0IHByb3hpbWl0eSA9IE1hdGguYWJzKGV4cGVjdGVkTG9jYXRpb24gLSBjdXJyZW50TG9jYXRpb24pO1xuXG4gIGlmICghZGlzdGFuY2UpIHtcbiAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3lcbiAgfVxuXG4gIHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIGRpc3RhbmNlXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRNYXNrVG9JbmRpY2VzKFxuICBtYXRjaG1hc2sgPSBbXSxcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aFxuKSB7XG4gIGxldCBpbmRpY2VzID0gW107XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGxldCBsZW4gPSBtYXRjaG1hc2subGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaG1hc2tbaV07XG4gICAgaWYgKG1hdGNoICYmIHN0YXJ0ID09PSAtMSkge1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgZW5kID0gaSAtIDE7XG4gICAgICBpZiAoZW5kIC0gc3RhcnQgKyAxID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgICAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBlbmRdKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLy8gKGktMSAtIHN0YXJ0KSArIDEgPT4gaSAtIHN0YXJ0XG4gIGlmIChtYXRjaG1hc2tbaSAtIDFdICYmIGkgLSBzdGFydCA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBpIC0gMV0pO1xuICB9XG5cbiAgcmV0dXJuIGluZGljZXNcbn1cblxuLy8gTWFjaGluZSB3b3JkIHNpemVcbmNvbnN0IE1BWF9CSVRTID0gMzI7XG5cbmZ1bmN0aW9uIHNlYXJjaChcbiAgdGV4dCxcbiAgcGF0dGVybixcbiAgcGF0dGVybkFscGhhYmV0LFxuICB7XG4gICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRShNQVhfQklUUykpXG4gIH1cblxuICBjb25zdCBwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGg7XG4gIC8vIFNldCBzdGFydGluZyBsb2NhdGlvbiBhdCBiZWdpbm5pbmcgdGV4dCBhbmQgaW5pdGlhbGl6ZSB0aGUgYWxwaGFiZXQuXG4gIGNvbnN0IHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gbG9jYXRpb24gPiB0ZXh0Lmxlbmd0aFxuICBjb25zdCBleHBlY3RlZExvY2F0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jYXRpb24sIHRleHRMZW4pKTtcbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgbGV0IGN1cnJlbnRUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgbGV0IGJlc3RMb2NhdGlvbiA9IGV4cGVjdGVkTG9jYXRpb247XG5cbiAgLy8gUGVyZm9ybWFuY2U6IG9ubHkgY29tcHV0ZXIgbWF0Y2hlcyB3aGVuIHRoZSBtaW5NYXRjaENoYXJMZW5ndGggPiAxXG4gIC8vIE9SIGlmIGBpbmNsdWRlTWF0Y2hlc2AgaXMgdHJ1ZS5cbiAgY29uc3QgY29tcHV0ZU1hdGNoZXMgPSBtaW5NYXRjaENoYXJMZW5ndGggPiAxIHx8IGluY2x1ZGVNYXRjaGVzO1xuICAvLyBBIG1hc2sgb2YgdGhlIG1hdGNoZXMsIHVzZWQgZm9yIGJ1aWxkaW5nIHRoZSBpbmRpY2VzXG4gIGNvbnN0IG1hdGNoTWFzayA9IGNvbXB1dGVNYXRjaGVzID8gQXJyYXkodGV4dExlbikgOiBbXTtcblxuICBsZXQgaW5kZXg7XG5cbiAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzLCBoZXJlIGZvciBzcGVlZCB1cFxuICB3aGlsZSAoKGluZGV4ID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGJlc3RMb2NhdGlvbikpID4gLTEpIHtcbiAgICBsZXQgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBjdXJyZW50TG9jYXRpb246IGluZGV4LFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBNYXRoLm1pbihzY29yZSwgY3VycmVudFRocmVzaG9sZCk7XG4gICAgYmVzdExvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuXG4gICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHBhdHRlcm5MZW4pIHtcbiAgICAgICAgbWF0Y2hNYXNrW2luZGV4ICsgaV0gPSAxO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgdGhlIGJlc3QgbG9jYXRpb25cbiAgYmVzdExvY2F0aW9uID0gLTE7XG5cbiAgbGV0IGxhc3RCaXRBcnIgPSBbXTtcbiAgbGV0IGZpbmFsU2NvcmUgPSAxO1xuICBsZXQgYmluTWF4ID0gcGF0dGVybkxlbiArIHRleHRMZW47XG5cbiAgY29uc3QgbWFzayA9IDEgPDwgKHBhdHRlcm5MZW4gLSAxKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkgKz0gMSkge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSB0aGUgbWF0Y2ggbG9jYXRpb24gd2UgY2FuIHN0cmF5XG4gICAgLy8gYXQgdGhpcyBlcnJvciBsZXZlbC5cbiAgICBsZXQgYmluTWluID0gMDtcbiAgICBsZXQgYmluTWlkID0gYmluTWF4O1xuXG4gICAgd2hpbGUgKGJpbk1pbiA8IGJpbk1pZCkge1xuICAgICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgIGVycm9yczogaSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLFxuICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICBiaW5NaW4gPSBiaW5NaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgICB9XG5cbiAgICAgIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICBiaW5NYXggPSBiaW5NaWQ7XG5cbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCgxLCBleHBlY3RlZExvY2F0aW9uIC0gYmluTWlkICsgMSk7XG4gICAgbGV0IGZpbmlzaCA9IGZpbmRBbGxNYXRjaGVzXG4gICAgICA/IHRleHRMZW5cbiAgICAgIDogTWF0aC5taW4oZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCwgdGV4dExlbikgKyBwYXR0ZXJuTGVuO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgYml0IGFycmF5XG4gICAgbGV0IGJpdEFyciA9IEFycmF5KGZpbmlzaCArIDIpO1xuXG4gICAgYml0QXJyW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xuXG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgaiAtPSAxKSB7XG4gICAgICBsZXQgY3VycmVudExvY2F0aW9uID0gaiAtIDE7XG4gICAgICBsZXQgY2hhck1hdGNoID0gcGF0dGVybkFscGhhYmV0W3RleHQuY2hhckF0KGN1cnJlbnRMb2NhdGlvbildO1xuXG4gICAgICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICAgICAgLy8gU3BlZWQgdXA6IHF1aWNrIGJvb2wgdG8gaW50IGNvbnZlcnNpb24gKGkuZSwgYGNoYXJNYXRjaCA/IDEgOiAwYClcbiAgICAgICAgbWF0Y2hNYXNrW2N1cnJlbnRMb2NhdGlvbl0gPSArISFjaGFyTWF0Y2g7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IHBhc3M6IGV4YWN0IG1hdGNoXG4gICAgICBiaXRBcnJbal0gPSAoKGJpdEFycltqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcblxuICAgICAgLy8gU3Vic2VxdWVudCBwYXNzZXM6IGZ1enp5IG1hdGNoXG4gICAgICBpZiAoaSkge1xuICAgICAgICBiaXRBcnJbal0gfD1cbiAgICAgICAgICAoKGxhc3RCaXRBcnJbaiArIDFdIHwgbGFzdEJpdEFycltqXSkgPDwgMSkgfCAxIHwgbGFzdEJpdEFycltqICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChiaXRBcnJbal0gJiBtYXNrKSB7XG4gICAgICAgIGZpbmFsU2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cbiAgICAgICAgaWYgKGZpbmFsU2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIEluZGVlZCBpdCBpc1xuICAgICAgICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBmaW5hbFNjb3JlO1xuICAgICAgICAgIGJlc3RMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcblxuICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGBsb2NgLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgaWYgKGJlc3RMb2NhdGlvbiA8PSBleHBlY3RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBgYmVzdExvY2F0aW9uYCwgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gYGV4cGVjdGVkTG9jYXRpb25gLlxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGV4cGVjdGVkTG9jYXRpb24gLSBiZXN0TG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgIGVycm9yczogaSArIDEsXG4gICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHNjb3JlID4gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBsYXN0Qml0QXJyID0gYml0QXJyO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlzTWF0Y2g6IGJlc3RMb2NhdGlvbiA+PSAwLFxuICAgIC8vIENvdW50IGV4YWN0IG1hdGNoZXMgKHRob3NlIHdpdGggYSBzY29yZSBvZiAwKSB0byBiZSBcImFsbW9zdFwiIGV4YWN0XG4gICAgc2NvcmU6IE1hdGgubWF4KDAuMDAxLCBmaW5hbFNjb3JlKVxuICB9O1xuXG4gIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgIGNvbnN0IGluZGljZXMgPSBjb252ZXJ0TWFza1RvSW5kaWNlcyhtYXRjaE1hc2ssIG1pbk1hdGNoQ2hhckxlbmd0aCk7XG4gICAgaWYgKCFpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybikge1xuICBsZXQgbWFzayA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IHBhdHRlcm4uY2hhckF0KGkpO1xuICAgIG1hc2tbY2hhcl0gPSAobWFza1tjaGFyXSB8fCAwKSB8ICgxIDw8IChsZW4gLSBpIC0gMSkpO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tcbn1cblxuY2xhc3MgQml0YXBTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgdGhpcy5jaHVua3MgPSBbXTtcblxuICAgIGlmICghdGhpcy5wYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYWRkQ2h1bmsgPSAocGF0dGVybiwgc3RhcnRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh7XG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIGFscGhhYmV0OiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybiksXG4gICAgICAgIHN0YXJ0SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA+IE1BWF9CSVRTKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCByZW1haW5kZXIgPSBsZW4gJSBNQVhfQklUUztcbiAgICAgIGNvbnN0IGVuZCA9IGxlbiAtIHJlbWFpbmRlcjtcblxuICAgICAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihpLCBNQVhfQklUUyksIGkpO1xuICAgICAgICBpICs9IE1BWF9CSVRTO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtYWluZGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBsZW4gLSBNQVhfQklUUztcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihzdGFydEluZGV4KSwgc3RhcnRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybiwgMCk7XG4gICAgfVxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHsgaXNDYXNlU2Vuc2l0aXZlLCBpbmNsdWRlTWF0Y2hlcyB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFpc0Nhc2VTZW5zaXRpdmUpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRXhhY3QgbWF0Y2hcbiAgICBpZiAodGhpcy5wYXR0ZXJuID09PSB0ZXh0KSB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICBzY29yZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgIHJlc3VsdC5pbmRpY2VzID0gW1swLCB0ZXh0Lmxlbmd0aCAtIDFdXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgdXNlIEJpdGFwIGFsZ29yaXRobVxuICAgIGNvbnN0IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCBhbGxJbmRpY2VzID0gW107XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG5cbiAgICB0aGlzLmNodW5rcy5mb3JFYWNoKCh7IHBhdHRlcm4sIGFscGhhYmV0LCBzdGFydEluZGV4IH0pID0+IHtcbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaCh0ZXh0LCBwYXR0ZXJuLCBhbHBoYWJldCwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24gKyBzdGFydEluZGV4LFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBoYXNNYXRjaGVzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdG90YWxTY29yZSArPSBzY29yZTtcblxuICAgICAgaWYgKGlzTWF0Y2ggJiYgaW5kaWNlcykge1xuICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIGlzTWF0Y2g6IGhhc01hdGNoZXMsXG4gICAgICBzY29yZTogaGFzTWF0Y2hlcyA/IHRvdGFsU2NvcmUgLyB0aGlzLmNodW5rcy5sZW5ndGggOiAxXG4gICAgfTtcblxuICAgIGlmIChoYXNNYXRjaGVzICYmIGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmNsYXNzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICB9XG4gIHN0YXRpYyBpc011bHRpTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLm11bHRpUmVnZXgpXG4gIH1cbiAgc3RhdGljIGlzU2luZ2xlTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLnNpbmdsZVJlZ2V4KVxuICB9XG4gIHNlYXJjaCgvKnRleHQqLykge31cbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2gocGF0dGVybiwgZXhwKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXR0ZXJuLm1hdGNoKGV4cCk7XG4gIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IG51bGxcbn1cblxuLy8gVG9rZW46ICdmaWxlXG5cbmNsYXNzIEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXj1cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL149KC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dCA9PT0gdGhpcy5wYXR0ZXJuO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIWZpcmVcblxuY2xhc3MgSW52ZXJzZUV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGV4dC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgY29uc3QgaXNNYXRjaCA9IGluZGV4ID09PSAtMTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiBeZmlsZVxuXG5jbGFzcyBQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3ByZWZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5zdGFydHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhXmZpcmVcblxuY2xhc3MgSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1wcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcXF5cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46IC5maWxlJFxuXG5jbGFzcyBTdWZmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3N1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCJcXCQkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogW3RleHQubGVuZ3RoIC0gdGhpcy5wYXR0ZXJuLmxlbmd0aCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIS5maWxlJFxuXG5jbGFzcyBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLXN1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopXFwkJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSAhdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1enp5TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gICAgdGhpcy5fYml0YXBTZWFyY2ggPSBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2Z1enp5J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRhcFNlYXJjaC5zZWFyY2hJbih0ZXh0KVxuICB9XG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBJbmNsdWRlTWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW5jbHVkZSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eJ1wiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXicoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGxldCBsb2NhdGlvbiA9IDA7XG4gICAgbGV0IGluZGV4O1xuXG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHBhdHRlcm5MZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzXG4gICAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4sIGxvY2F0aW9uKSkgPiAtMSkge1xuICAgICAgbG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG4gICAgICBpbmRpY2VzLnB1c2goW2luZGV4LCBsb2NhdGlvbiAtIDFdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01hdGNoID0gISFpbmRpY2VzLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXNcbiAgICB9XG4gIH1cbn1cblxuLy8g4p2XT3JkZXIgaXMgaW1wb3J0YW50LiBETyBOT1QgQ0hBTkdFLlxuY29uc3Qgc2VhcmNoZXJzID0gW1xuICBFeGFjdE1hdGNoLFxuICBJbmNsdWRlTWF0Y2gsXG4gIFByZWZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCxcbiAgU3VmZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZUV4YWN0TWF0Y2gsXG4gIEZ1enp5TWF0Y2hcbl07XG5cbmNvbnN0IHNlYXJjaGVyc0xlbiA9IHNlYXJjaGVycy5sZW5ndGg7XG5cbi8vIFJlZ2V4IHRvIHNwbGl0IGJ5IHNwYWNlcywgYnV0IGtlZXAgYW55dGhpbmcgaW4gcXVvdGVzIHRvZ2V0aGVyXG5jb25zdCBTUEFDRV9SRSA9IC8gKyg/PSg/OlteXFxcIl0qXFxcIlteXFxcIl0qXFxcIikqW15cXFwiXSokKS87XG5jb25zdCBPUl9UT0tFTiA9ICd8JztcblxuLy8gUmV0dXJuIGEgMkQgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXJ5LCBmb3Igc2ltcGxlciBwYXJzaW5nLlxuLy8gRXhhbXBsZTpcbi8vIFwiXmNvcmUgZ28kIHwgcmIkIHwgcHkkIHh5JFwiID0+IFtbXCJeY29yZVwiLCBcImdvJFwiXSwgW1wicmIkXCJdLCBbXCJweSRcIiwgXCJ4eSRcIl1dXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gcGF0dGVybi5zcGxpdChPUl9UT0tFTikubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IHF1ZXJ5ID0gaXRlbVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KFNQQUNFX1JFKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiAhIWl0ZW0udHJpbSgpKTtcblxuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBxdWVyeUl0ZW0gPSBxdWVyeVtpXTtcblxuICAgICAgLy8gMS4gSGFuZGxlIG11bHRpcGxlIHF1ZXJ5IG1hdGNoIChpLmUsIG9uY2UgdGhhdCBhcmUgcXVvdGVkLCBsaWtlIGBcImhlbGxvIHdvcmxkXCJgKVxuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoIWZvdW5kICYmICsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzTXVsdGlNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBIYW5kbGUgc2luZ2xlIHF1ZXJ5IG1hdGNoZXMgKGkuZSwgb25jZSB0aGF0IGFyZSAqbm90KiBxdW90ZWQpXG4gICAgICBpZHggPSAtMTtcbiAgICAgIHdoaWxlICgrK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc1NpbmdsZU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfSlcbn1cblxuLy8gVGhlc2UgZXh0ZW5kZWQgbWF0Y2hlcnMgY2FuIHJldHVybiBhbiBhcnJheSBvZiBtYXRjaGVzLCBhcyBvcHBvc2VkXG4vLyB0byBhIHNpbmdsIG1hdGNoXG5jb25zdCBNdWx0aU1hdGNoU2V0ID0gbmV3IFNldChbRnV6enlNYXRjaC50eXBlLCBJbmNsdWRlTWF0Y2gudHlwZV0pO1xuXG4vKipcbiAqIENvbW1hbmQtbGlrZSBzZWFyY2hpbmdcbiAqID09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBHaXZlbiBtdWx0aXBsZSBzZWFyY2ggdGVybXMgZGVsaW1pdGVkIGJ5IHNwYWNlcy5lLmcuIGBeanNjcmlwdCAucHl0aG9uJCBydWJ5ICFqYXZhYCxcbiAqIHNlYXJjaCBpbiBhIGdpdmVuIHRleHQuXG4gKlxuICogU2VhcmNoIHN5bnRheDpcbiAqXG4gKiB8IFRva2VuICAgICAgIHwgTWF0Y2ggdHlwZSAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IGBqc2NyaXB0YCAgIHwgZnV6enktbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGZ1enp5IG1hdGNoIGBqc2NyaXB0YCAgICAgICB8XG4gKiB8IGA9c2NoZW1lYCAgIHwgZXhhY3QtbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGFyZSBgc2NoZW1lYCAgICAgICAgICAgICAgICB8XG4gKiB8IGAncHl0aG9uYCAgIHwgaW5jbHVkZS1tYXRjaCAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGluY2x1ZGUgYHB5dGhvbmAgICAgICAgICAgICB8XG4gKiB8IGAhcnVieWAgICAgIHwgaW52ZXJzZS1leGFjdC1tYXRjaCAgICAgICAgfCBJdGVtcyB0aGF0IGRvIG5vdCBpbmNsdWRlIGBydWJ5YCAgICAgICB8XG4gKiB8IGBeamF2YWAgICAgIHwgcHJlZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IHN0YXJ0IHdpdGggYGphdmFgICAgICAgICAgICB8XG4gKiB8IGAhXmVhcmxhbmdgIHwgaW52ZXJzZS1wcmVmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGBlYXJsYW5nYCB8XG4gKiB8IGAuanMkYCAgICAgIHwgc3VmZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IGVuZCB3aXRoIGAuanNgICAgICAgICAgICAgICB8XG4gKiB8IGAhLmdvJGAgICAgIHwgaW52ZXJzZS1zdWZmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBlbmQgd2l0aCBgLmdvYCAgICAgICB8XG4gKlxuICogQSBzaW5nbGUgcGlwZSBjaGFyYWN0ZXIgYWN0cyBhcyBhbiBPUiBvcGVyYXRvci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmdcbiAqIHF1ZXJ5IG1hdGNoZXMgZW50cmllcyB0aGF0IHN0YXJ0IHdpdGggYGNvcmVgIGFuZCBlbmQgd2l0aCBlaXRoZXJgZ29gLCBgcmJgLFxuICogb3JgcHlgLlxuICpcbiAqIGBgYFxuICogXmNvcmUgZ28kIHwgcmIkIHwgcHkkXG4gKiBgYGBcbiAqL1xuY2xhc3MgRXh0ZW5kZWRTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvbixcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2VcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIGlnbm9yZUxvY2F0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucXVlcnkgPSBwYXJzZVF1ZXJ5KHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25kaXRpb24oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoXG4gIH1cblxuICBzZWFyY2hJbih0ZXh0KSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuXG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICAgIHNjb3JlOiAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmNsdWRlTWF0Y2hlcywgaXNDYXNlU2Vuc2l0aXZlIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0ZXh0ID0gaXNDYXNlU2Vuc2l0aXZlID8gdGV4dCA6IHRleHQudG9Mb3dlckNhc2UoKTtcblxuICAgIGxldCBudW1NYXRjaGVzID0gMDtcbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcblxuICAgIC8vIE9Sc1xuICAgIGZvciAobGV0IGkgPSAwLCBxTGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgcUxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzZWFyY2hlcnMgPSBxdWVyeVtpXTtcblxuICAgICAgLy8gUmVzZXQgaW5kaWNlc1xuICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgbnVtTWF0Y2hlcyA9IDA7XG5cbiAgICAgIC8vIEFORHNcbiAgICAgIGZvciAobGV0IGogPSAwLCBwTGVuID0gc2VhcmNoZXJzLmxlbmd0aDsgaiA8IHBMZW47IGogKz0gMSkge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tqXTtcbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBpbmRpY2VzLCBzY29yZSB9ID0gc2VhcmNoZXIuc2VhcmNoKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbnVtTWF0Y2hlcyArPSAxO1xuICAgICAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG4gICAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc2VhcmNoZXIuY29uc3RydWN0b3IudHlwZTtcbiAgICAgICAgICAgIGlmIChNdWx0aU1hdGNoU2V0Lmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcy5wdXNoKGluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbFNjb3JlID0gMDtcbiAgICAgICAgICBudW1NYXRjaGVzID0gMDtcbiAgICAgICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPUiBjb25kaXRpb24sIHNvIGlmIFRSVUUsIHJldHVyblxuICAgICAgaWYgKG51bU1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICAgIHNjb3JlOiB0b3RhbFNjb3JlIC8gbnVtTWF0Y2hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3RoaW5nIHdhcyBtYXRjaGVkXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgc2NvcmU6IDFcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmVnaXN0ZXJlZFNlYXJjaGVycyA9IFtdO1xuXG5mdW5jdGlvbiByZWdpc3RlciguLi5hcmdzKSB7XG4gIHJlZ2lzdGVyZWRTZWFyY2hlcnMucHVzaCguLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucykge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVnaXN0ZXJlZFNlYXJjaGVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBzZWFyY2hlckNsYXNzID0gcmVnaXN0ZXJlZFNlYXJjaGVyc1tpXTtcbiAgICBpZiAoc2VhcmNoZXJDbGFzcy5jb25kaXRpb24ocGF0dGVybiwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBuZXcgc2VhcmNoZXJDbGFzcyhwYXR0ZXJuLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwgb3B0aW9ucylcbn1cblxuY29uc3QgTG9naWNhbE9wZXJhdG9yID0ge1xuICBBTkQ6ICckYW5kJyxcbiAgT1I6ICckb3InXG59O1xuXG5jb25zdCBLZXlUeXBlID0ge1xuICBQQVRIOiAnJHBhdGgnLFxuICBQQVRURVJOOiAnJHZhbCdcbn07XG5cbmNvbnN0IGlzRXhwcmVzc2lvbiA9IChxdWVyeSkgPT5cbiAgISEocXVlcnlbTG9naWNhbE9wZXJhdG9yLkFORF0gfHwgcXVlcnlbTG9naWNhbE9wZXJhdG9yLk9SXSk7XG5cbmNvbnN0IGlzUGF0aCA9IChxdWVyeSkgPT4gISFxdWVyeVtLZXlUeXBlLlBBVEhdO1xuXG5jb25zdCBpc0xlYWYgPSAocXVlcnkpID0+XG4gICFpc0FycmF5KHF1ZXJ5KSAmJiBpc09iamVjdChxdWVyeSkgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSk7XG5cbmNvbnN0IGNvbnZlcnRUb0V4cGxpY2l0ID0gKHF1ZXJ5KSA9PiAoe1xuICBbTG9naWNhbE9wZXJhdG9yLkFORF06IE9iamVjdC5rZXlzKHF1ZXJ5KS5tYXAoKGtleSkgPT4gKHtcbiAgICBba2V5XTogcXVlcnlba2V5XVxuICB9KSlcbn0pO1xuXG4vLyBXaGVuIGBhdXRvYCBpcyBgdHJ1ZWAsIHRoZSBwYXJzZSBmdW5jdGlvbiB3aWxsIGluZmVyIGFuZCBpbml0aWFsaXplIGFuZCBhZGRcbi8vIHRoZSBhcHByb3ByaWF0ZSBgU2VhcmNoZXJgIGluc3RhbmNlXG5mdW5jdGlvbiBwYXJzZShxdWVyeSwgb3B0aW9ucywgeyBhdXRvID0gdHJ1ZSB9ID0ge30pIHtcbiAgY29uc3QgbmV4dCA9IChxdWVyeSkgPT4ge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMocXVlcnkpO1xuXG4gICAgY29uc3QgaXNRdWVyeVBhdGggPSBpc1BhdGgocXVlcnkpO1xuXG4gICAgaWYgKCFpc1F1ZXJ5UGF0aCAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICAgIHJldHVybiBuZXh0KGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KSlcbiAgICB9XG5cbiAgICBpZiAoaXNMZWFmKHF1ZXJ5KSkge1xuICAgICAgY29uc3Qga2V5ID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVEhdIDoga2V5c1swXTtcblxuICAgICAgY29uc3QgcGF0dGVybiA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRURVJOXSA6IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWShrZXkpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIGtleUlkOiBjcmVhdGVLZXlJZChrZXkpLFxuICAgICAgICBwYXR0ZXJuXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXV0bykge1xuICAgICAgICBvYmouc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIGxldCBub2RlID0ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgb3BlcmF0b3I6IGtleXNbMF1cbiAgICB9O1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV4dChpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBpZiAoIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICBxdWVyeSA9IGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KHF1ZXJ5KVxufVxuXG4vLyBQcmFjdGljYWwgc2NvcmluZyBmdW5jdGlvblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKFxuICByZXN1bHRzLFxuICB7IGlnbm9yZUZpZWxkTm9ybSA9IENvbmZpZy5pZ25vcmVGaWVsZE5vcm0gfVxuKSB7XG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAxO1xuXG4gICAgcmVzdWx0Lm1hdGNoZXMuZm9yRWFjaCgoeyBrZXksIG5vcm0sIHNjb3JlIH0pID0+IHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IGtleSA/IGtleS53ZWlnaHQgOiBudWxsO1xuXG4gICAgICB0b3RhbFNjb3JlICo9IE1hdGgucG93KFxuICAgICAgICBzY29yZSA9PT0gMCAmJiB3ZWlnaHQgPyBOdW1iZXIuRVBTSUxPTiA6IHNjb3JlLFxuICAgICAgICAod2VpZ2h0IHx8IDEpICogKGlnbm9yZUZpZWxkTm9ybSA/IDEgOiBub3JtKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC5zY29yZSA9IHRvdGFsU2NvcmU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXRjaGVzKHJlc3VsdCwgZGF0YSkge1xuICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoZXM7XG4gIGRhdGEubWF0Y2hlcyA9IFtdO1xuXG4gIGlmICghaXNEZWZpbmVkKG1hdGNoZXMpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQobWF0Y2guaW5kaWNlcykgfHwgIW1hdGNoLmluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IGluZGljZXMsIHZhbHVlIH0gPSBtYXRjaDtcblxuICAgIGxldCBvYmogPSB7XG4gICAgICBpbmRpY2VzLFxuICAgICAgdmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKG1hdGNoLmtleSkge1xuICAgICAgb2JqLmtleSA9IG1hdGNoLmtleS5zcmM7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmlkeCA+IC0xKSB7XG4gICAgICBvYmoucmVmSW5kZXggPSBtYXRjaC5pZHg7XG4gICAgfVxuXG4gICAgZGF0YS5tYXRjaGVzLnB1c2gob2JqKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNjb3JlKHJlc3VsdCwgZGF0YSkge1xuICBkYXRhLnNjb3JlID0gcmVzdWx0LnNjb3JlO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoXG4gIHJlc3VsdHMsXG4gIGRvY3MsXG4gIHtcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpbmNsdWRlU2NvcmUgPSBDb25maWcuaW5jbHVkZVNjb3JlXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IFtdO1xuXG4gIGlmIChpbmNsdWRlTWF0Y2hlcykgdHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtTWF0Y2hlcyk7XG4gIGlmIChpbmNsdWRlU2NvcmUpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybVNjb3JlKTtcblxuICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IHsgaWR4IH0gPSByZXN1bHQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgaXRlbTogZG9jc1tpZHhdLFxuICAgICAgcmVmSW5kZXg6IGlkeFxuICAgIH07XG5cbiAgICBpZiAodHJhbnNmb3JtZXJzLmxlbmd0aCkge1xuICAgICAgdHJhbnNmb3JtZXJzLmZvckVhY2goKHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgICAgIHRyYW5zZm9ybWVyKHJlc3VsdCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9KVxufVxuXG5jbGFzcyBGdXNlIHtcbiAgY29uc3RydWN0b3IoZG9jcywgb3B0aW9ucyA9IHt9LCBpbmRleCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uQ29uZmlnLCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2ggJiZcbiAgICAgICF0cnVlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVhURU5ERURfU0VBUkNIX1VOQVZBSUxBQkxFKVxuICAgIH1cblxuICAgIHRoaXMuX2tleVN0b3JlID0gbmV3IEtleVN0b3JlKHRoaXMub3B0aW9ucy5rZXlzKTtcblxuICAgIHRoaXMuc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCk7XG4gIH1cblxuICBzZXRDb2xsZWN0aW9uKGRvY3MsIGluZGV4KSB7XG4gICAgdGhpcy5fZG9jcyA9IGRvY3M7XG5cbiAgICBpZiAoaW5kZXggJiYgIShpbmRleCBpbnN0YW5jZW9mIEZ1c2VJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihJTkNPUlJFQ1RfSU5ERVhfVFlQRSlcbiAgICB9XG5cbiAgICB0aGlzLl9teUluZGV4ID1cbiAgICAgIGluZGV4IHx8XG4gICAgICBjcmVhdGVJbmRleCh0aGlzLm9wdGlvbnMua2V5cywgdGhpcy5fZG9jcywge1xuICAgICAgICBnZXRGbjogdGhpcy5vcHRpb25zLmdldEZuLFxuICAgICAgICBmaWVsZE5vcm1XZWlnaHQ6IHRoaXMub3B0aW9ucy5maWVsZE5vcm1XZWlnaHRcbiAgICAgIH0pO1xuICB9XG5cbiAgYWRkKGRvYykge1xuICAgIGlmICghaXNEZWZpbmVkKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2RvY3MucHVzaChkb2MpO1xuICAgIHRoaXMuX215SW5kZXguYWRkKGRvYyk7XG4gIH1cblxuICByZW1vdmUocHJlZGljYXRlID0gKC8qIGRvYywgaWR4ICovKSA9PiBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9kb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLl9kb2NzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShkb2MsIGkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICAgIGkgLT0gMTtcbiAgICAgICAgbGVuIC09IDE7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMuX2RvY3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgdGhpcy5fbXlJbmRleC5yZW1vdmVBdChpZHgpO1xuICB9XG5cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX215SW5kZXhcbiAgfVxuXG4gIHNlYXJjaChxdWVyeSwgeyBsaW1pdCA9IC0xIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgaW5jbHVkZVNjb3JlLFxuICAgICAgc2hvdWxkU29ydCxcbiAgICAgIHNvcnRGbixcbiAgICAgIGlnbm9yZUZpZWxkTm9ybVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgcmVzdWx0cyA9IGlzU3RyaW5nKHF1ZXJ5KVxuICAgICAgPyBpc1N0cmluZyh0aGlzLl9kb2NzWzBdKVxuICAgICAgICA/IHRoaXMuX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpXG4gICAgICAgIDogdGhpcy5fc2VhcmNoT2JqZWN0TGlzdChxdWVyeSlcbiAgICAgIDogdGhpcy5fc2VhcmNoTG9naWNhbChxdWVyeSk7XG5cbiAgICBjb21wdXRlU2NvcmUocmVzdWx0cywgeyBpZ25vcmVGaWVsZE5vcm0gfSk7XG5cbiAgICBpZiAoc2hvdWxkU29ydCkge1xuICAgICAgcmVzdWx0cy5zb3J0KHNvcnRGbik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKGxpbWl0KSAmJiBsaW1pdCA+IC0xKSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdChyZXN1bHRzLCB0aGlzLl9kb2NzLCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZVxuICAgIH0pXG4gIH1cblxuICBfc2VhcmNoU3RyaW5nTGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBzdHJpbmcgaW4gdGhlIGluZGV4XG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICBpZiAoIWlzRGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgaXRlbTogdGV4dCxcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgbWF0Y2hlczogW3sgc2NvcmUsIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIF9zZWFyY2hMb2dpY2FsKHF1ZXJ5KSB7XG5cbiAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UocXVlcnksIHRoaXMub3B0aW9ucyk7XG5cbiAgICBjb25zdCBldmFsdWF0ZSA9IChub2RlLCBpdGVtLCBpZHgpID0+IHtcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCB7IGtleUlkLCBzZWFyY2hlciB9ID0gbm9kZTtcblxuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgIGtleTogdGhpcy5fa2V5U3RvcmUuZ2V0KGtleUlkKSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5fbXlJbmRleC5nZXRWYWx1ZUZvckl0ZW1BdEtleUlkKGl0ZW0sIGtleUlkKSxcbiAgICAgICAgICBzZWFyY2hlclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXZhbHVhdGUoY2hpbGQsIGl0ZW0sIGlkeCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzLnB1c2goLi4ucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm9wZXJhdG9yID09PSBMb2dpY2FsT3BlcmF0b3IuQU5EKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9O1xuXG4gICAgY29uc3QgcmVjb3JkcyA9IHRoaXMuX215SW5kZXgucmVjb3JkcztcbiAgICBjb25zdCByZXN1bHRNYXAgPSB7fTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmIChpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgbGV0IGV4cFJlc3VsdHMgPSBldmFsdWF0ZShleHByZXNzaW9uLCBpdGVtLCBpZHgpO1xuXG4gICAgICAgIGlmIChleHBSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIERlZHVwZSB3aGVuIGFkZGluZ1xuICAgICAgICAgIGlmICghcmVzdWx0TWFwW2lkeF0pIHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpZHhdID0geyBpZHgsIGl0ZW0sIG1hdGNoZXM6IFtdIH07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0TWFwW2lkeF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBSZXN1bHRzLmZvckVhY2goKHsgbWF0Y2hlcyB9KSA9PiB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XS5tYXRjaGVzLnB1c2goLi4ubWF0Y2hlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoT2JqZWN0TGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyAkOiBpdGVtLCBpOiBpZHggfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBrZXkgKGkuZSwgcGF0aCksIGFuZCBmZXRjaCB0aGUgdmFsdWUgYXQgdGhhdCBrZXlcbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5LCBrZXlJbmRleCkgPT4ge1xuICAgICAgICBtYXRjaGVzLnB1c2goXG4gICAgICAgICAgLi4udGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGl0ZW1ba2V5SW5kZXhdLFxuICAgICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG4gIF9maW5kTWF0Y2hlcyh7IGtleSwgdmFsdWUsIHNlYXJjaGVyIH0pIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKHsgdjogdGV4dCwgaTogaWR4LCBuOiBub3JtIH0pID0+IHtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3JlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICBub3JtLFxuICAgICAgICAgICAgaW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB2OiB0ZXh0LCBuOiBub3JtIH0gPSB2YWx1ZTtcblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7IHNjb3JlLCBrZXksIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzXG4gIH1cbn1cblxuRnVzZS52ZXJzaW9uID0gJzYuNi4yJztcbkZ1c2UuY3JlYXRlSW5kZXggPSBjcmVhdGVJbmRleDtcbkZ1c2UucGFyc2VJbmRleCA9IHBhcnNlSW5kZXg7XG5GdXNlLmNvbmZpZyA9IENvbmZpZztcblxue1xuICBGdXNlLnBhcnNlUXVlcnkgPSBwYXJzZTtcbn1cblxue1xuICByZWdpc3RlcihFeHRlbmRlZFNlYXJjaCk7XG59XG5cbmV4cG9ydCB7IEZ1c2UgYXMgZGVmYXVsdCB9O1xuIiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCIgdHlwZT1cInRzXCI+XHRcblx0ZXhwb3J0IGVudW0gQ2xhc3NUeXBlIHtcblx0XHRVTktOT1dOID0gJ3Vua25vd24nLFxuXG5cdFx0Ly8gc2V0IG9mIGNoYWlucyB3aGljaCBzaGFyZSBhIGNvbW1vbiBhZGRyZXNzIHNwYWNlLCBzdWNoIHRoYXQgdXNlciBhY2NvdW50cyBhcmUgdHJhbnNsYXRhYmxlIGFjcm9zcyBtZW1iZXJzXG5cdFx0RkFNSUxZID0gJ2ZhbWlseScsXG5cblx0XHQvLyBzcGVjaWZpYyBibG9ja2NoYWluXG5cdFx0Q0hBSU4gPSAnY2hhaW4nLFxuXG5cdFx0Ly8gY29uZmlndXJhdGlvbiBmb3IgaG93IHRvIGNvbW11bmljYXRlIHdpdGggY2hhaW5cblx0XHRORVRXT1JLID0gJ25ldHdvcmsnLFxuXG5cdFx0Ly8gXG5cdFx0QUNDT1VOVCA9ICdhY2NvdW50JyxcblxuXHRcdC8vIHB1YmtleSBhc3NvY2lhdGVkIHdpdGggZGlzdGluY3QgZmFtaWx5ICdtZW1iZXInXG5cdFx0Q09OVEFDVCA9ICdjb250YWN0JyxcblxuXHRcdC8vIG9uLWNoYWluIHJlc291cmNlIHRoYXQgb25seSBleGlzdHMgdGhpcyBjaGFpblxuXHRcdENPTlRSQUNUID0gJ2NvbnRyYWN0JyxcblxuXHRcdC8vIGFkZHJlc3NhYmxlIGFzc2V0IGFzc29jaWF0ZWQgd2l0aCBkaXN0aW5jdCBjaGFpblxuXHRcdFRPS0VOID0gJ3Rva2VuJyxcblxuXHRcdC8vIGFzc2V0IGhvbGRpbmdzXG5cdFx0SE9MRElORyA9ICdob2xkaW5nJyxcblxuXHRcdC8vIGFwcCBjb25uZWN0aW9uXG5cdFx0QVBQID0gJ2FwcCcsXG5cblx0XHQvLyBuYXRpdmUgY29pblxuXHRcdENPSU4gPSAnY29pbicsXG5cblx0XHRUQUcgPSAndGFnJyxcblx0XHRJQ09OID0gJ2ljb24nLFxuXG5cdFx0SUJDVCA9ICdpYmN0Jyxcblx0XHRTTklQNzIxID0gJ3NuaXA3MjEnLFxuXHRcdFRYTiA9ICd0eG4nLFxuXHRcdE9USEVSID0gJ290aGVyJyxcblx0fVxuXG5cdGV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoSXRlbSB7XG5cdFx0Y2xhc3M6IENsYXNzVHlwZTtcblx0XHRyZXNvdXJjZVBhdGg6IFJlc291cmNlLlBhdGg7XG5cdFx0bmFtZTogc3RyaW5nO1xuXHRcdHJlc291cmNlOiBSZXNvdXJjZVsnaW50ZXJmYWNlJ107XG5cdFx0ZGV0YWlsczogRGljdDxKc29uVmFsdWU+O1xuXHR9XG5cblx0ZXhwb3J0IGludGVyZmFjZSBTZWFyY2hHcm91cCB7XG5cdFx0c291cmNlOiBQcm9taXNhYmxlPHR5cGVvZiBXcml0YWJsZVN0b3JlTWFwICYgU3RhdGljU3RvcmUgfCBBcnJheTxhbnk+Pjtcblx0XHR0cmFuc2Zvcm0oZ190aGluZzogUmVzb3VyY2VbJ2ludGVyZmFjZSddKTogT21pdDxTZWFyY2hJdGVtLCAncmVmJz47XG5cdFx0a2V5czogc3RyaW5nW107XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0IHR5cGU9XCJ0c1wiPlxuXHRpbXBvcnQgRnVzZSBmcm9tICdmdXNlLmpzJztcblxuXHRpbXBvcnQge1xuXHRcdHl3X2NhbmNlbF9zZWFyY2gsXG5cdFx0eXdfaGVhZGVyX3Byb3BzLFxuXHRcdHl3X3NlYXJjaCxcblx0fSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCB7XG5cdFx0U2NyZWVuLFxuXHRcdEhlYWRlcixcblx0fSBmcm9tICcjIy9zY3JlZW4vX3NjcmVlbnMnO1xuXG5cdC8vIGltcG9ydCBHZW5lcmljUm93IGZyb20gJyMvdWkvR2VuZXJpY1Jvdy5zdmVsdGUnO1xuXHRpbXBvcnQge0FjY291bnRzfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHtBZ2VudHN9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHtBcHBzfSBmcm9tICcjL3N0b3JlL2FwcHMnO1xuXHRpbXBvcnQge0NoYWluc30gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQge0VudGl0aWVzfSBmcm9tICcjL3N0b3JlL2VudGl0aWVzJztcblx0aW1wb3J0IHtNZWRpYXN9IGZyb20gJyMvc3RvcmUvbWVkaWFzJztcblx0aW1wb3J0IHtOZXR3b3Jrc30gZnJvbSAnIy9zdG9yZS9uZXR3b3Jrcyc7XG5cdGltcG9ydCB7UGZwc30gZnJvbSAnIy9zdG9yZS9wZnBzJztcblx0aW1wb3J0IHR5cGUge1Jlc291cmNlfSBmcm9tICcjL21ldGEvcmVzb3VyY2UnO1xuXHRpbXBvcnQgdHlwZSB7QWNjb3VudCwgQWNjb3VudFBhdGh9IGZyb20gJyMvbWV0YS9hY2NvdW50Jztcblx0aW1wb3J0IHtEaWN0LCBKc29uT2JqZWN0LCBKc29uVmFsdWUsIG9kZSwgb2RlcmFjLCBQcm9taXNhYmxlLCBwcm9wZXJ9IGZyb20gJyMvdXRpbC9iZWx0Jztcblx0aW1wb3J0IHR5cGUge1N0YXRpY1N0b3JlLCBXcml0YWJsZVN0b3JlTWFwfSBmcm9tICcjL3N0b3JlL19iYXNlJztcblx0aW1wb3J0IHR5cGUge0FnZW50LCBBZ2VudFBhdGgsIENoYWluUGF0aH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IFJvdyBmcm9tICcjL2FwcC91aS9Sb3cuc3ZlbHRlJztcblxuXHRsZXQgZG1fcmVzdWx0czogSFRNTEVsZW1lbnQ7XG5cdGNvbnN0IGFfcmVzdWx0czogU2VhcmNoSXRlbVtdID0gW107XG5cblxuXHQvLyBsZXQgeV9mdXNlOiBGdXNlPFNlYXJjaEl0ZW0+O1xuXHRsZXQgYV9mdXNlczogRnVzZTxTZWFyY2hJdGVtPltdID0gW107XG5cblx0Y29uc3QgZnV6ZXkgPSAoYV9pdGVtczogU2VhcmNoSXRlbVtdLCBhX2tleXM6IHN0cmluZ1tdKSA9PiBuZXcgRnVzZShhX2l0ZW1zLCB7XG5cdFx0aW5jbHVkZVNjb3JlOiB0cnVlLFxuXHRcdGluY2x1ZGVNYXRjaGVzOiB0cnVlLFxuXHRcdGtleXM6IFtcblx0XHRcdCdsYWJlbCcsXG5cdFx0XHQuLi5hX2tleXMubWFwKHMgPT4gYGRldGFpbHMuJHtzfWApLFxuXHRcdF0sXG5cdH0pO1xuXG5cdChhc3luYygpID0+IHtcblx0XHRjb25zdCBoX3N0b3JlcyA9IHt9O1xuXG5cdFx0Y29uc3Qga3NfY2hhaW5zID0gYXdhaXQgQ2hhaW5zLnJlYWQoKTtcblxuXHRcdGFfZnVzZXMgPSBbXG5cdFx0XHQvLyBjaGFpbnNcblx0XHRcdCgoKSA9PiBmdXpleShrc19jaGFpbnMuZW50cmllcygpLm1hcCgoW3BfY2hhaW4sIGdfY2hhaW5dKSA9PiAoe1xuXHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLkNIQUlOLFxuXHRcdFx0XHRuYW1lOiBnX2NoYWluLm5hbWUsXG5cdFx0XHRcdHJlc291cmNlUGF0aDogcF9jaGFpbixcblx0XHRcdFx0cmVzb3VyY2U6IGdfY2hhaW4sXG5cdFx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0XHRuYW1lOiBnX2NoYWluLm5hbWUsXG5cdFx0XHRcdFx0aWQ6IGdfY2hhaW4uaWQsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KSksIFsnaWQnXSkpKCksXG5cblx0XHRcdC8vIGNvaW5zXG5cdFx0XHQoKCkgPT4gZnV6ZXkoa3NfY2hhaW5zLmVudHJpZXMoKS5mbGF0TWFwKChbcF9jaGFpbiwgZ19jaGFpbl0pID0+IG9kZXJhYyhnX2NoYWluLmNvaW5zLCAoc2lfY29pbiwgZ19jb2luKSA9PiAoe1xuXHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLkNPSU4sXG5cdFx0XHRcdG5hbWU6IHByb3BlcihnX2NvaW4uZXh0cmE/LmNvaW5nZWNrb19pZCB8fCAnVW5rbm93bicpLFxuXHRcdFx0XHRwb3N0bmFtZTogc2lfY29pbixcblx0XHRcdFx0cmVzb3VyY2VQYXRoOiBgJHtwX2NoYWlufS9jb2luLiR7c2lfY29pbn1gLFxuXHRcdFx0XHRyZXNvdXJjZToge1xuXHRcdFx0XHRcdG5hbWU6IHByb3BlcihnX2NvaW4uZXh0cmE/LmNvaW5nZWNrb19pZCB8fCAnVW5rbm93bicpLFxuXHRcdFx0XHRcdHBmcDogZ19jaGFpbi5wZnAsXG5cdFx0XHRcdFx0Li4uZ19jb2luLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0c3ltYm9sOiBzaV9jb2luLFxuXHRcdFx0XHRcdGRlbm9tOiBnX2NvaW4uZGVub20sXG5cdFx0XHRcdFx0Y29pbmdlY2tvOiBnX2NvaW4uZXh0cmE/LmNvaW5nZWNrb19pZCB8fCAnJyxcblx0XHRcdFx0fSxcblx0XHRcdH0pKSksIFsnc3ltYm9sJywgJ2Rlbm9tJ10pKSgpLFxuXG5cdFx0XHQuLi5hd2FpdCBQcm9taXNlLmFsbChbXG5cdFx0XHRcdC8vIGFjY291bnRzXG5cdFx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0XHRjb25zdCBrc19hY2NvdW50cyA9IGF3YWl0IEFjY291bnRzLnJlYWQoKTtcblxuXHRcdFx0XHRcdHJldHVybiBmdXpleShrc19hY2NvdW50cy5lbnRyaWVzKCkubWFwKChbcF9hY2NvdW50LCBnX2FjY291bnRdKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBhX2FkZHJzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRcdFx0Y29uc3QgYXNfYWRkcnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuXHRcdFx0XHRcdFx0Zm9yKGNvbnN0IFssIGdfY2hhaW5dIG9mIGtzX2NoYWlucykge1xuXHRcdFx0XHRcdFx0XHRhc19hZGRycy5hZGQoQ2hhaW5zLmFkZHJlc3NGb3IoZ19hY2NvdW50LnB1YmtleSwgZ19jaGFpbikpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRhX2FkZHJzLnB1c2goLi4uYXNfYWRkcnMpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLkFDQ09VTlQsXG5cdFx0XHRcdFx0XHRcdG5hbWU6IGdfYWNjb3VudC5uYW1lLFxuXHRcdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg6IHBfYWNjb3VudCxcblx0XHRcdFx0XHRcdFx0cmVzb3VyY2U6IGdfYWNjb3VudCxcblx0XHRcdFx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IGdfYWNjb3VudC5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdGFkZHJlc3NlczogYV9hZGRycyxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSksIFsnYWRkcmVzc2VzJ10pO1xuXHRcdFx0XHR9KSgpLFxuXG5cdFx0XHRcdC8vIGNvbnRhY3RzXG5cdFx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0XHRjb25zdCBrc19hZ2VudHMgPSBhd2FpdCBBZ2VudHMucmVhZCgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZ1emV5KFsuLi5rc19hZ2VudHMuY29udGFjdHMoKV0ubWFwKChbcF9jb250YWN0LCBnX2NvbnRhY3RdKSA9PiAoe1xuXHRcdFx0XHRcdFx0Y2xhc3M6IENsYXNzVHlwZS5DT05UQUNULFxuXHRcdFx0XHRcdFx0bmFtZTogZ19jb250YWN0Lm5hbWUsXG5cdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg6IHBfY29udGFjdCxcblx0XHRcdFx0XHRcdHJlc291cmNlOiBnX2NvbnRhY3QsXG5cdFx0XHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IGdfY29udGFjdC5uYW1lLFxuXHRcdFx0XHRcdFx0XHRub3RlczogZ19jb250YWN0Lm5vdGVzLFxuXHRcdFx0XHRcdFx0XHRhZGRyZXNzZXM6IFsuLi5rc19jaGFpbnMuaW5GYW1pbHkoZ19jb250YWN0LmZhbWlseSldXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgoWywgZ19jaGFpbl0pID0+IENoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MsIGdfY2hhaW4pKSxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSkpLCBbJ25vdGVzJ10pO1xuXHRcdFx0XHR9KSgpLFxuXG5cdFx0XHRcdC8vIGFwcHNcblx0XHRcdFx0KGFzeW5jKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGtzX2FwcHMgPSBhd2FpdCBBcHBzLnJlYWQoKTtcblxuXHRcdFx0XHRcdHJldHVybiBmdXpleShrc19hcHBzLmVudHJpZXMoKS5tYXAoKFtwX2FwcCwgZ19hcHBdKSA9PiAoe1xuXHRcdFx0XHRcdFx0Y2xhc3M6IENsYXNzVHlwZS5BUFAsXG5cdFx0XHRcdFx0XHRuYW1lOiBnX2FwcC5ob3N0LFxuXHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoOiBwX2FwcCxcblx0XHRcdFx0XHRcdHJlc291cmNlOiBnX2FwcCxcblx0XHRcdFx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0XHRcdFx0aG9zdDogZ19hcHAuaG9zdCxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSkpLCBbXSk7XG5cdFx0XHRcdH0pKCksXG5cblx0XHRcdFx0Ly8gdG9rZW5zXG5cdFx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0XHRjb25zdCBhX3Rva2VuczogU2VhcmNoSXRlbVtdID0gW107XG5cblx0XHRcdFx0XHRmb3IoY29uc3QgWywgZ19jaGFpbl0gb2Yga3NfY2hhaW5zLmVudHJpZXMoKSkge1xuXHRcdFx0XHRcdFx0Zm9yKGNvbnN0IFtzaV9zcGVjLCBoX3Rva2Vuc10gb2Ygb2RlKGF3YWl0IEVudGl0aWVzLnJlYWRGdW5naWJsZVRva2VucyhnX2NoYWluKSkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yKGNvbnN0IFtwX3Rva2VuLCBnX3Rva2VuXSBvZiBvZGUoaF90b2tlbnMpKSB7XG5cdFx0XHRcdFx0XHRcdFx0YV90b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLlRPS0VOLFxuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZTogZ190b2tlbi5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoOiBwX3Rva2VuLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVzb3VyY2U6IGdfdG9rZW4sXG5cdFx0XHRcdFx0XHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNwZWM6IHNpX3NwZWMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IGdfdG9rZW4ubmFtZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3ltYm9sOiBnX3Rva2VuLnN5bWJvbCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0YmVjaDMyOiBnX3Rva2VuLmJlY2gzMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29kZWhhc2g6IGdfdG9rZW4uaGFzaCxcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gZnV6ZXkoYV90b2tlbnMsIFtcblx0XHRcdFx0XHRcdCdzcGVjJyxcblx0XHRcdFx0XHRcdCdzeW1ib2wnLFxuXHRcdFx0XHRcdFx0J2JlY2gzMicsXG5cdFx0XHRcdFx0XHQnY29kZWhhc2gnLFxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9KSgpLFxuXG5cdFx0XHRcdC8vIEVudGl0aWVzLFxuXHRcdFx0XHQvLyBOZXR3b3Jrcyxcblx0XHRcdF0pLFxuXHRcdF07XG5cdH0pKCk7XG5cblx0ZnVuY3Rpb24gc2VhcmNoKHNfc2VhcmNoOiBzdHJpbmcpIHtcblx0XHRjb25zdCBhX2dyb3Vwczoge3RvcDpudW1iZXIsIGhpdHM6RnVzZS5GdXNlUmVzdWx0PFNlYXJjaEl0ZW0+W119W10gPSBbXTtcblx0XHRjb25zdCBhX2hpdHM6IEZ1c2UuRnVzZVJlc3VsdDxTZWFyY2hJdGVtPltdID0gW107XG5cdFx0bGV0IGNfdG90YWwgPSAwO1xuXG5cdFx0Zm9yKGNvbnN0IHlfZnVzZSBvZiBhX2Z1c2VzKSB7XG5cdFx0XHRjb25zdCBhX2hpdHNfbG9jYWwgPSB5X2Z1c2Uuc2VhcmNoKHNfc2VhcmNoKTtcblxuXHRcdFx0aWYoYV9oaXRzX2xvY2FsLmxlbmd0aCkge1xuXHRcdFx0XHRjX3RvdGFsICs9IGFfaGl0cy5sZW5ndGg7XG5cblx0XHRcdFx0YV9oaXRzLnB1c2goLi4uYV9oaXRzX2xvY2FsKTtcblxuXHRcdFx0XHRhX2dyb3Vwcy5wdXNoKHtcblx0XHRcdFx0XHR0b3A6IGFfaGl0c19sb2NhbFswXS5zY29yZSEsXG5cdFx0XHRcdFx0aGl0czogYV9oaXRzX2xvY2FsLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IGFsbCBoaXRzXG5cdFx0YV9oaXRzLnNvcnQoKGdfYSwgZ19iKSA9PiBnX2Iuc2NvcmUhIC0gZ19hLnNjb3JlISk7XG5cblx0XHQvLyBjbGVhciByZXN1bHRzIGxpc3Rcblx0XHRkbV9yZXN1bHRzLmlubmVySFRNTCA9ICcnO1xuXG5cdFx0Y29uc29sZS5sb2coYV9oaXRzKTtcblxuXHRcblx0XHRmb3IoY29uc3QgZ19oaXQgb2YgYV9oaXRzKVx0e1xuXHRcdFx0bmV3IFJvdyh7XG5cdFx0XHRcdHRhcmdldDogZG1fcmVzdWx0cyxcblx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHQuLi5nX2hpdC5pdGVtLFxuXHRcdFx0XHRcdHBmcERpbTogMzIsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQkOiB7XG5cdFx0aWYoJHl3X3NlYXJjaCkge1xuXHRcdFx0c2VhcmNoKCR5d19zZWFyY2gpO1xuXHRcdH1cblx0fVxuXG5cdC8vIG9uTW91bnQoKCkgPT4ge1xuXHQvLyBcdHNlYXJjaCgkeXdfc2VhcmNoKTtcblx0Ly8gfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5zZWFyY2gge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0ei1pbmRleDogMTAwMDtcblxuXHRcdC5yZXN1bHRzIHtcblxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwic2VhcmNoXCIgY2xhc3M6ZGlzcGxheV9ub25lPXshJHl3X3NlYXJjaH0+XG5cdDxTY3JlZW4gZGVidWc9J1NlYXJjaCcgcm9vdD5cblx0XHQ8SGVhZGVyIG5ldHdvcmsgYWNjb3VudCBzZWFyY2hcblx0XHRcdGlzU2VhcmNoU2NyZWVuIHsuLi4oJHl3X2hlYWRlcl9wcm9wcyB8fCB7fSl9IG9uOnNlYXJjaD17ZF9ldmVudCA9PiBzZWFyY2goZF9ldmVudC5kZXRhaWwpfVxuXHRcdC8+XG5cblx0XHQ8cCBzdHlsZT0nZm9udC1zaXplOjEycHgnPlxuXHRcdFx0PHNwYW4gc3R5bGU9J2NvbG9yOnZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pOyc+RGlzY2xhaW1lcjogPC9zcGFuPlxuXHRcdFx0VGhpcyB0ZW1wb3Jhcnkgc2VhcmNoIGludGVyZmFjZSBkb2VzIG5vdCByZXByZXNlbnQgdGhlIGxvb2sgYW5kIGZ1bmN0aW9uIG9mIHRoZSBhY3R1YWwgc2VhcmNoIGludGVyZmFjZSBjdXJyZW50bHkgdW5kZXIgZGV2ZWxvcG1lbnQgZm9yIGJldGEuXG5cdFx0PC9wPlxuXG5cdFx0PGRpdiBjbGFzcz1cInJlc3VsdHMgbm8tbWFyZ2luXCIgYmluZDp0aGlzPXtkbV9yZXN1bHRzfT5cblx0XHRcdHsja2V5IGFfcmVzdWx0c31cblx0XHRcdFx0eyNlYWNoIGFfcmVzdWx0cyBhcyBnX3Jlc3VsdH1cblx0XHRcdFx0XHQ8R2VuZXJpY1JvdyBpdGVtPXtnX3Jlc3VsdH0gLz5cblx0XHRcdFx0ey9lYWNofVxuXHRcdFx0ey9rZXl9XG5cdFx0PC9kaXY+XG5cdDwvU2NyZWVuPlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyB5d19wcm9ncmVzcyB9IGZyb20gJyMjL21lbSc7XG5cblx0JDogeF93aWR0aF9wY3RfYmFyID0gKCR5d19wcm9ncmVzc1swXSAvICR5d19wcm9ncmVzc1sxXSkgKiAxMDA7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0LnByb2dyZXNzIHtcblx0XHQtLWJhci1oZWlnaHQ6IDRweDtcblx0XHR6LWluZGV4OiAxMDAxO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRoZWlnaHQ6IHZhcigtLWJhci1oZWlnaHQpO1xuXHRcdHRvcDogY2FsYygwcHggLSB2YXIoLS1iYXItaGVpZ2h0KSk7XG5cdFx0bGVmdDogMDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHR0cmFuc2l0aW9uOiB0b3AgMC4ycyB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cblx0XHQmLnZpc2libGUge1xuXHRcdFx0dG9wOiAwO1xuXHRcdH1cblxuXHRcdD4uYmFyIHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0d2lkdGg6IDAlO1xuXHRcdFx0dHJhbnNpdGlvbjogd2lkdGggMXMgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdH1cblx0fVxuXG5cdC5zdGVwIHtcblx0XHQuZm9udCh0aW55KTtcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXG5cdFx0ei1pbmRleDogMTAwMTtcblxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHRcdGxlZnQ6IDA7XG5cdFx0Ly8gbGVmdDogY2FsYygwcHggLSAodmFyKC0tYXBwLXdpbmRvdy13aWR0aCkgKiAwLjI1KSk7XG5cdFx0XG5cdFx0bWFyZ2luLXRvcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0bWFyZ2luLWxlZnQ6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFxuXHRcdG9wYWNpdHk6IDA7XG5cdFx0dHJhbnNpdGlvbjogYWxsIDAuNnMgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdHRyYW5zaXRpb24tZGVsYXk6IDAuNHM7XG5cblx0XHQmLnZpc2libGUge1xuXHRcdFx0Ly8gbGVmdDogMDtcblx0XHRcdHRvcDogMDtcblx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG5cbjxkaXYgY2xhc3M9XCJwcm9ncmVzc1wiIGNsYXNzOnZpc2libGU9eyR5d19wcm9ncmVzc1swXSA+IDB9PlxuXHQ8ZGl2IGNsYXNzPVwiYmFyXCIgc3R5bGU9XCJ3aWR0aDoge3hfd2lkdGhfcGN0X2Jhcn0lO1wiPjwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJzdGVwXCIgY2xhc3M6dmlzaWJsZT17JHl3X3Byb2dyZXNzWzBdID4gMH0+XG5cdFN0ZXAgeyR5d19wcm9ncmVzc1swXSB8fCAkeXdfcHJvZ3Jlc3NbMV19IG9mIHskeXdfcHJvZ3Jlc3NbMV19XG48L2Rpdj5cbiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTkgMTJjMS45MyAwIDMuNS0xLjU3IDMuNS0zLjVTMTAuOTMgNSA5IDUgNS41IDYuNTcgNS41IDguNSA3LjA3IDEyIDkgMTJ6bTAtNWMuODMgMCAxLjUuNjcgMS41IDEuNVM5LjgzIDEwIDkgMTBzLTEuNS0uNjctMS41LTEuNVM4LjE3IDcgOSA3em0uMDUgMTBINC43N2MuOTktLjUgMi43LTEgNC4yMy0xIC4xMSAwIC4yMy4wMS4zNC4wMS4zNC0uNzMuOTMtMS4zMyAxLjY0LTEuODEtLjczLS4xMy0xLjQyLS4yLTEuOTgtLjItMi4zNCAwLTcgMS4xNy03IDMuNVYxOWg3di0xLjVjMC0uMTcuMDItLjM0LjA1LS41em03LjQ1LTIuNWMtMS44NCAwLTUuNSAxLjAxLTUuNSAzVjE5aDExdi0xLjVjMC0xLjk5LTMuNjYtMy01LjUtM3ptMS4yMS0xLjgyYy43Ni0uNDMgMS4yOS0xLjI0IDEuMjktMi4xOGEyLjUgMi41IDAgMCAwLTUgMGMwIC45NC41MyAxLjc1IDEuMjkgMi4xOC4zNi4yLjc3LjMyIDEuMjEuMzJzLjg1LS4xMiAxLjIxLS4zMnpcXFwiLz5cXG48L3N2Zz5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwibTE4IDE2IDQtNC00LTR2M2gtNS4wNkE4Ljk3NCA4Ljk3NCAwIDAgMCA4IDMuOTUgMy4wMDUgMy4wMDUgMCAwIDAgNSAxQzMuMzQgMSAyIDIuMzQgMiA0czEuMzQgMyAzIDNjLjk1IDAgMS43OC0uNDUgMi4zMy0xLjE0QzkuMjMgNi45IDEwLjYgOC43NyAxMC45MiAxMWgtMy4xQzcuNCA5Ljg0IDYuMyA5IDUgOWMtMS42NiAwLTMgMS4zNC0zIDNzMS4zNCAzIDMgM2MxLjMgMCAyLjQtLjg0IDIuODItMmgzLjFjLS4zMiAyLjIzLTEuNjkgNC4xLTMuNTggNS4xNEM2Ljc4IDE3LjQ1IDUuOTUgMTcgNSAxN2MtMS42NiAwLTMgMS4zNC0zIDNzMS4zNCAzIDMgM2EyLjk5IDIuOTkgMCAwIDAgMi45OS0yLjk1QTguOTc0IDguOTc0IDAgMCAwIDEyLjkzIDEzSDE4djN6XFxcIi8+XFxuPC9zdmc+XCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIk0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyek03LjA3IDE4LjI4Yy40My0uOSAzLjA1LTEuNzggNC45My0xLjc4czQuNTEuODggNC45MyAxLjc4QzE1LjU3IDE5LjM2IDEzLjg2IDIwIDEyIDIwcy0zLjU3LS42NC00LjkzLTEuNzJ6bTExLjI5LTEuNDVjLTEuNDMtMS43NC00LjktMi4zMy02LjM2LTIuMzNzLTQuOTMuNTktNi4zNiAyLjMzQTcuOTUgNy45NSAwIDAgMSA0IDEyYzAtNC40MSAzLjU5LTggOC04czggMy41OSA4IDhjMCAxLjgyLS42MiAzLjQ5LTEuNjQgNC44M3pNMTIgNmMtMS45NCAwLTMuNSAxLjU2LTMuNSAzLjVTMTAuMDYgMTMgMTIgMTNzMy41LTEuNTYgMy41LTMuNVMxMy45NCA2IDEyIDZ6bTAgNWMtLjgzIDAtMS41LS42Ny0xLjUtMS41UzExLjE3IDggMTIgOHMxLjUuNjcgMS41IDEuNVMxMi44MyAxMSAxMiAxMXpcXFwiLz5cXG48L3N2Zz5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTIyIDExVjNoLTd2M0g5VjNIMnY4aDdWOGgydjEwaDR2M2g3di04aC03djNoLTJWOGgydjNoN3pNNyA5SDRWNWgzdjR6bTEwIDZoM3Y0aC0zdi00em0wLTEwaDN2NGgtM1Y1elxcXCIvPlxcbjwvc3ZnPlwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTggNHYxNkg2VjRoMTJtMC0ySDZjLTEuMSAwLTIgLjktMiAydjE4aDE2VjRjMC0xLjEtLjktMi0yLTJ6bS0yLjUgOC41Yy0uODMgMC0xLjUuNjctMS41IDEuNXMuNjcgMS41IDEuNSAxLjVTMTcgMTIuODMgMTcgMTJzLS42Ny0xLjUtMS41LTEuNXpcXFwiLz5cXG48L3N2Zz5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IEZfTk9PUCwgdGltZW91dCB9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXHRpbXBvcnQge1xuXHRcdHl3X21lbnVfZXhwYW5kZWQsIHl3X25hdmlnYXRvcixcblx0fSBmcm9tICcjL2FwcC9tZW0nO1xuXG5cdGltcG9ydCBTWF9JQ09OX0NPTlRBQ1RTIGZyb20gJyMvaWNvbi9zdXBlcnZpc29yX2FjY291bnQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NIQUlOUyBmcm9tICcjL2ljb24vbWVkaWF0aW9uLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9BQ0NPVU5UUyBmcm9tICcjL2ljb24vYWNjb3VudF9jaXJjbGUuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX1RBR1MgZnJvbSAnIy9pY29uL2Jvb2ttYXJrcy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ09OTkVDVElPTlMgZnJvbSAnIy9pY29uL2FjY291bnRfdHJlZS5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fU0VUVElOR1MgZnJvbSAnIy9pY29uL3NldHRpbmdzLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9MT0dPVVQgZnJvbSAnIy9pY29uL3NlbnNvcl9kb29yLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9DTE9TRSBmcm9tICcjL2ljb24vY2xvc2Uuc3ZnP3Jhdyc7XG5cdGltcG9ydCB7IFRocmVhZElkIH0gZnJvbSAnIy9hcHAvZGVmJztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgUGFnZSB9IGZyb20gJyMjL3NjcmVlbi9fc2NyZWVucyc7XG5cblx0aW50ZXJmYWNlIEl0ZW0ge1xuXHRcdGNsaWNrOiBWb2lkRnVuY3Rpb247XG5cdFx0bGFiZWw6IHN0cmluZztcblx0XHQvLyBpY29uOiBJY29uO1xuXHRcdGljb246IHN0cmluZztcblx0fVxuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRjb25zdCBBX0lURU1TID0gW1xuXHRcdHtcblx0XHRcdGxhYmVsOiAnQ29udGFjdHMnLFxuXHRcdFx0Ly8gaWNvbjogSWNvbi5mcm9tSHRtbChTWF9JQ09OX0NPTlRBQ1RTKSxcblx0XHRcdGljb246IFNYX0lDT05fQ09OVEFDVFMsXG5cdFx0XHRjbGljaygpIHtcblx0XHRcdFx0JHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZTtcblx0XHRcdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKFRocmVhZElkLkNPTlRBQ1RTKTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRsYWJlbDogJ0FjY291bnRzJyxcblx0XHRcdC8vIGljb246IEljb24uZnJvbUh0bWwoU1hfSUNPTl9BQ0NPVU5UUyksXG5cdFx0XHRpY29uOiBTWF9JQ09OX0FDQ09VTlRTLFxuXHRcdFx0Y2xpY2soKSB7XG5cdFx0XHRcdCR5d19tZW51X2V4cGFuZGVkID0gZmFsc2U7XG5cdFx0XHRcdHZvaWQgJHl3X25hdmlnYXRvci5hY3RpdmF0ZVRocmVhZChUaHJlYWRJZC5BQ0NPVU5UUyk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdOZXR3b3JrcycsXG5cdFx0XHQvLyBpY29uOiBJY29uLmZyb21IdG1sKFNYX0lDT05fQ0hBSU5TKSxcblx0XHRcdGljb246IFNYX0lDT05fQ0hBSU5TLFxuXHRcdFx0Y2xpY2soKSB7XG5cdFx0XHRcdCR5d19tZW51X2V4cGFuZGVkID0gZmFsc2U7XG5cdFx0XHRcdHZvaWQgJHl3X25hdmlnYXRvci5hY3RpdmF0ZVRocmVhZChUaHJlYWRJZC5ORVRXT1JLUyk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0Ly8ge1xuXHRcdC8vIFx0bGFiZWw6ICdUYWdzJyxcblx0XHQvLyBcdC8vIGljb246IEljb24uZnJvbUh0bWwoU1hfSUNPTl9UQUdTKSxcblx0XHQvLyBcdGljb246IFNYX0lDT05fVEFHUyxcblx0XHQvLyBcdGNsaWNrKCkge1xuXHRcdC8vIFx0XHQkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlO1xuXHRcdC8vIFx0XHQvLyBrX3BhZ2UucHVzaCh7XG5cdFx0Ly8gXHRcdC8vIFx0Y3JlYXRvcjogRGVhZEVuZCxcblx0XHQvLyBcdFx0Ly8gfSk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdTaXRlcycsXG5cdFx0XHQvLyBpY29uOiBJY29uLmZyb21IdG1sKFNYX0lDT05fQ09OTkVDVElPTlMpLFxuXHRcdFx0aWNvbjogU1hfSUNPTl9DT05ORUNUSU9OUyxcblx0XHRcdGNsaWNrKCkge1xuXHRcdFx0XHQkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlO1xuXHRcdFx0XHR2b2lkICR5d19uYXZpZ2F0b3IuYWN0aXZhdGVUaHJlYWQoVGhyZWFkSWQuU0lURVMpO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRcdC8vIHtcblx0XHQvLyBcdGxhYmVsOiAnU2V0dGluZ3MnLFxuXHRcdC8vIFx0Ly8gaWNvbjogSWNvbi5mcm9tSHRtbChTWF9JQ09OX1NFVFRJTkdTKSxcblx0XHQvLyBcdGljb246IFNYX0lDT05fU0VUVElOR1MsXG5cdFx0Ly8gXHRjbGljazogKCkgPT4ge1xuXHRcdC8vIFx0XHQkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlO1xuXHRcdC8vIFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0Ly8gXHRcdFx0Y3JlYXRvcjogRGVhZEVuZCxcblx0XHQvLyBcdFx0fSk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdF07XG5cblx0Y29uc3QgQV9TRVNTSU9OX0lURU1TID0gW1xuXHRcdHtcblx0XHRcdGxhYmVsOiAnTG9nIG91dCcsXG5cdFx0XHRpY29uOiBTWF9JQ09OX0xPR09VVCxcblx0XHRcdGNsaWNrOiBGX05PT1AsXG5cdFx0fSxcblx0XTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vc2NyZWVuL19iYXNlLmxlc3MnO1xuXG5cdDpyb290IHtcblx0XHQtLWJhci13aWR0aDogNzguOCU7XG5cdFx0LS1hbmltYXRpb24tZHVyYXRpb246IDFzO1xuXHRcdC0tYW5pbWF0aW9uLWVhc2luZzogdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHR9XG5cblx0QGtleWZyYW1lcyBmYWRlIHtcblx0XHQwJSB7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHR9XG5cblx0XHQxMDAlIHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcblx0XHR9XG5cdH1cblxuXHRAa2V5ZnJhbWVzIHNsaWRlIHtcblx0XHQwJSB7XG5cdFx0XHRyaWdodDogY2FsYygwJSAtIHZhcigtLWJhci13aWR0aCkpO1xuXHRcdH1cblxuXHRcdDEwMCUge1xuXHRcdFx0cmlnaHQ6IDAlO1xuXHRcdH1cblx0fVxuXG5cdEBrZXlmcmFtZXMgb2Zmc2NyZWVuIHtcblx0XHQwJSB7XG5cdFx0XHR0b3A6IDA7XG5cdFx0fVxuXG5cdFx0MTAwJSB7XG5cdFx0XHR0b3A6IHZhcigtLWFwcC13aW5kb3ctaGVpZ2h0KTtcblx0XHR9XG5cdH1cblxuXHQuYWJzb2x1dGUoQGRpbXM6ICcnKSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXG5cdFx0d2lkdGg6IGlmKCcnID0gQGRpbXMsIHZhcigtLWFwcC13aW5kb3ctd2lkdGgpLCBAZGltcyk7XG5cdFx0aGVpZ2h0OiBpZignJyA9IEBkaW1zLCB2YXIoLS1hcHAtd2luZG93LWhlaWdodCksIEBkaW1zKTtcblx0fVxuXG5cdC5zaWRlLW1lbnUge1xuXHRcdC0taXRlbS1wYWRkaW5nOiAzMHB4O1xuXG5cdFx0LmFic29sdXRlKCk7XG5cdFx0LmZvbnQocmVndWxhcik7XG5cdFx0ei1pbmRleDogMTAwMTtcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdD4uYmFja2Ryb3Age1xuXHRcdFx0LmFic29sdXRlKDEwMCUpO1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuXHRcdFx0dHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciB2YXIoLS1hbmltYXRpb24tZHVyYXRpb24pIHZhcigtLWVhc2Utb3V0LWV4cG8pO1xuXHRcdH1cblxuXHRcdD4uYmFyIHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdHdpZHRoOiB2YXIoLS1iYXItd2lkdGgpO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0cmlnaHQ6IDAlO1xuXHRcdFx0dHJhbnNpdGlvbjogcmlnaHQgdmFyKC0tYW5pbWF0aW9uLWR1cmF0aW9uKSB2YXIoLS1hbmltYXRpb24tZWFzaW5nKTtcblxuXHRcdFx0Pi5tZW51IHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XG5cdFx0XHRcdGhlaWdodDogMTAwJTtcblxuXHRcdFx0XHR1bCB7XG5cdFx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG5cblx0XHRcdFx0XHQ+bGkge1xuXHRcdFx0XHRcdFx0bGlzdC1zdHlsZTogbm9uZTtcblx0XHRcdFx0XHRcdHBhZGRpbmc6IDEzcHggMDtcblx0XHRcdFx0XHRcdHBhZGRpbmctbGVmdDogdmFyKC0taXRlbS1wYWRkaW5nKTtcblx0XHRcdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblxuXHRcdFx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ+Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmctcmlnaHQ6IGNhbGModmFyKC0taXRlbS1wYWRkaW5nKSAvIDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCYuaXRlbXMge1xuXHRcdFx0XHRcdFx0Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCYuc2Vzc2lvbiB7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiBjYWxjKHZhcigtLWl0ZW0tcGFkZGluZykgLyAyKSAwO1xuXG5cdFx0XHRcdFx0XHQuaWNvbiB7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4ubWFpbiB7XG5cdFx0XHRcdFx0ZmxleDogMTtcblx0XHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcblx0XHRcdFx0XHRwYWRkaW5nLXRvcDogMTUlO1xuXHRcdFx0XHRcdHBhZGRpbmctYm90dG9tOiAxNSU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LmJvdHRvbSw+LnRvcCB7XG5cdFx0XHRcdFx0ZmxleDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4udG9wIHtcblx0XHRcdFx0XHRwYWRkaW5nLXRvcDogMTUlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ji5jb2xsYXBzZWQge1xuXHRcdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRhbmltYXRpb246IG9mZnNjcmVlbiB2YXIoLS1hbmltYXRpb24tZHVyYXRpb24pIHN0ZXBzKDIsIGp1bXAtbm9uZSkgYm90aDtcblx0XHRcdFxuXHRcdFx0Pi5iYWNrZHJvcCB7XG5cdFx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdD4uYmFyIHtcblx0XHRcdFx0cmlnaHQ6IGNhbGMoMCUgLSB2YXIoLS1iYXItd2lkdGgpKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGhyIHtcblx0XHRcdG1hcmdpbjogMCB2YXIoLS1pdGVtLXBhZGRpbmcpO1xuXHRcdFx0Ym9yZGVyOiBub25lO1xuXHRcdFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0fVxuXG5cdFx0LmNsb3NlIHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdHJpZ2h0OiAwO1xuXHRcdFx0bWFyZ2luOiAxMHB4O1xuXHRcdFx0cGFkZGluZzogMTJweDtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cblx0XHRcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0Ym9yZGVyLXJhZGl1czogMHB4O1xuXHRcdFx0dHJhbnNpdGlvbjogYm9yZGVyLXJhZGl1cyA2NTBtcyB2YXIoLS1lYXNlLW91dC1leHBvKTtcblx0XHRcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cblx0XHRcdCY6OmJlZm9yZSB7XG5cdFx0XHRcdC0tb2NjbHVzaW9uLXRoaWNrbmVzczogNHB4O1xuXG5cdFx0XHRcdGNvbnRlbnQ6ICcnO1xuXHRcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdHRvcDogY2FsYyh2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSAvIDIpO1xuXHRcdFx0XHRsZWZ0OiBjYWxjKHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIC8gMik7XG5cdFx0XHRcdHdpZHRoOiBjYWxjKDEwMCUgLSB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSk7XG5cdFx0XHRcdGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykpO1xuXHRcdFx0XHRvdXRsaW5lOiB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdFx0fVxuXG5cdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0Ym9yZGVyLXJhZGl1czogMjJweDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXZcblx0Y2xhc3M9XCJzaWRlLW1lbnVcIlxuXHRjbGFzczpjb2xsYXBzZWQ9eyEkeXdfbWVudV9leHBhbmRlZH1cbj5cblx0PGRpdiBjbGFzcz1cImJhY2tkcm9wXCJcblx0XHRvbjpjbGljaz17KCkgPT4gJHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZX1cblx0Lz5cblxuXHQ8ZGl2IGNsYXNzPVwiYmFyXCI+XG5cdFx0PGRpdiBjbGFzcz1cImNsb3NlIGljb25cIiBvbjpjbGljaz17KCkgPT4gJHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZX0+XG5cdFx0XHR7QGh0bWwgU1hfSUNPTl9DTE9TRX1cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJtZW51XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidG9wXCI+XG5cdFx0XHRcdDx1bCBjbGFzcz1cInNlc3Npb25cIj5cblx0XHRcdFx0XHR7I2VhY2ggQV9TRVNTSU9OX0lURU1TIGFzIGdfaXRlbX1cblx0XHRcdFx0XHRcdDxsaT5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0e0BodG1sIGdfaXRlbS5pY29ufVxuXHRcdFx0XHRcdFx0XHRcdDwhLS0gPFB1dCBlbGVtZW50PXtnX2l0ZW0uaWNvbi5yZW5kZXIoKX0gLz4gLS0+XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0e2dfaXRlbS5sYWJlbH1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdDwvdWw+XG5cblx0XHRcdFx0PGhyPlxuXHRcdFx0PC9kaXY+XG5cblx0XHRcdDxkaXYgY2xhc3M9XCJtYWluXCI+XG5cdFx0XHRcdDx1bCBjbGFzcz1cIml0ZW1zXCI+XG5cdFx0XHRcdFx0eyNlYWNoIEFfSVRFTVMgYXMgZ19pdGVtfVxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzPVwiXCIgb246Y2xpY2s9eygpID0+IGdfaXRlbS5jbGljaygpfT5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0e0BodG1sIGdfaXRlbS5pY29ufVxuXHRcdFx0XHRcdFx0XHRcdDwhLS0gPFB1dCBlbGVtZW50PXtnX2l0ZW0uaWNvbi5yZW5kZXIoKX0gLz4gLS0+XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0e2dfaXRlbS5sYWJlbH1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdDwvdWw+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBGX05PT1AgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IHtcblx0XHR5d19tZW51X2V4cGFuZGVkLFxuXHRcdHl3X21lbnVfdmVuZG9yLFxuXHRcdHl3X2NoYWluX3JlZixcblx0XHR5d19jaGFpbixcblx0XHR5d19uZXR3b3JrX3JlZixcbnl3X25ldHdvcmssXG5cdH0gZnJvbSAnIyMvbWVtJztcbmltcG9ydCB7IGdsb2JhbF9yZWNlaXZlIH0gZnJvbSAnIy9zY3JpcHQvbXNnLWdsb2JhbCc7XG5pbXBvcnQgeyBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnO1xuXG5cdC8vIGltcG9ydCB7XG5cdC8vIFx0SWNvbixcblx0Ly8gfSBmcm9tICcjL29iamVjdHMnO1xuXG5cdC8vIGltcG9ydCB7XG5cdC8vIFx0UHV0LFxuXHQvLyAgfSBmcm9tICcjL3VpJztcblxuXHQvLyBpbXBvcnQgU1hfQ09OVEFDVFMgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvc3VwZXJ2aXNvcl9hY2NvdW50LnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfQ0hBSU5TIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL21lZGlhdGlvbi5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0FDQ09VTlRTIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL2FjY291bnRfY2lyY2xlLnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfVEFHUyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9ib29rbWFya3Muc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9DT05ORUNUSU9OUyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9hY2NvdW50X3RyZWUuc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9TRVRUSU5HUyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9zZXR0aW5ncy5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0xPR09VVCBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9zZW5zb3JfZG9vci5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0NMT1NFIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL2Nsb3NlLnN2Zz9yYXcnO1xuXG5cdC8vIGltcG9ydCBTWF9USVRMRSBmcm9tICcjL2Fzc2V0L3ZlbmRvci9zdGFyc2hlbGwtdGl0bGUuc3ZnP3Jhdyc7XG5cblx0Ly8gJHl3X21lbnVfZXhwYW5kZWRcblxuXHRpbnRlcmZhY2UgSXRlbSB7XG5cdFx0Y2xpY2s6IFZvaWRGdW5jdGlvbjtcblx0XHRsYWJlbDogc3RyaW5nO1xuXHRcdC8vIGljb246IEljb247XG5cdH1cblxuXHQvLyBsZXQgc19sYXRlbmN5ID0gJzEyMG1zJztcblxuXHRsZXQgc19oZWlnaHQgPSAnJztcblx0bGV0IHh0X3doZW4gPSAwO1xuXHRsZXQgeHRfYXZnX2Jsb2NrX3RpbWUgPSAwO1xuXG5cdGxldCBzX25ldHdvcmtfc3RhdHVzID0gJ0xvYWRpbmcnO1xuXHRsZXQgcF9wcm92aWRlciA9ICcnO1xuXHRsZXQgc2lfY2hhaW4gPSAnJztcblxuXHRsZXQgc19ncnBjd19zdGF0dXMgPSAnJztcblx0bGV0IHNfcnBjX3N0YXR1cyA9ICcnO1xuXG5cblx0Ly8gd2hlbiB0aGUgbmV0d29yayBpcyBjaGFuZ2VkXG5cdCQ6IGlmKCR5d19uZXR3b3JrKSB7XG5cdFx0c19oZWlnaHQgPSAnWy4uLl0nO1xuXHRcdHh0X3doZW4gPSAwO1xuXHRcdHh0X2F2Z19ibG9ja190aW1lID0gMDtcblx0XHRzX25ldHdvcmtfc3RhdHVzID0gJ0Nvbm5lY3RpbmcnO1xuXHRcdHBfcHJvdmlkZXIgPSBuZXcgVVJMKCR5d19uZXR3b3JrLmdycGNXZWJVcmwpLmhvc3Q7XG5cdFx0c2lfY2hhaW4gPSAnJztcblx0fVxuXG5cdGdsb2JhbF9yZWNlaXZlKHtcblx0XHRibG9ja0luZm8oZ19pbmZvKSB7XG5cdFx0XHRpZigkeXdfY2hhaW5fcmVmID09PSBnX2luZm8uY2hhaW4pIHtcblx0XHRcdFx0c19uZXR3b3JrX3N0YXR1cyA9ICdPbmxpbmUnO1xuXHRcdFx0XHRzaV9jaGFpbiA9IGdfaW5mby5oZWFkZXIuY2hhaW5faWQgYXMgc3RyaW5nO1xuXG5cdFx0XHRcdHNfaGVpZ2h0ID0gZ19pbmZvLmhlYWRlci5oZWlnaHQgYXMgc3RyaW5nO1xuXHRcdFx0XHR4dF93aGVuID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0XHRjb25zdCBhX3JlY2VudHMgPSBnX2luZm8ucmVjZW50cztcblx0XHRcdFx0aWYoYV9yZWNlbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRjb25zdCBhX2dhcHM6IG51bWJlcltdID0gW107XG5cdFx0XHRcdFx0Zm9yKGxldCBpX2VhY2g9MTsgaV9lYWNoPGFfcmVjZW50cy5sZW5ndGg7IGlfZWFjaCsrKSB7XG5cdFx0XHRcdFx0XHRhX2dhcHMucHVzaChhX3JlY2VudHNbaV9lYWNoXSAtIGFfcmVjZW50c1tpX2VhY2gtMV0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHh0X2F2Z19ibG9ja190aW1lID0gYV9nYXBzLnJlZHVjZSgoY19vdXQsIHhfdmFsdWUpID0+IGNfb3V0ICsgeF92YWx1ZSwgMCkgLyBhX2dhcHMubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG5cblx0bGV0IHNfbG9uZ19hZ28gPSAnWy4uLl0nO1xuXHRjb25zdCBpX2xvbmdfYWdvID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcblx0XHRpZih4dF93aGVuID4gMCkge1xuXHRcdFx0Y29uc3QgeHRfYWdvID0gRGF0ZS5ub3coKSAtIHh0X3doZW47XG5cdFx0XHRzX2xvbmdfYWdvID0gYCR7TWF0aC5yb3VuZCh4dF9hZ28gLyAxZTMpfSBzZWNvbmRzIGFnb2A7XG5cdFx0fVxuXHR9LCA1MDApO1xuXHRcblx0b25EZXN0cm95KCgpID0+IHtcblx0XHRjbGVhckludGVydmFsKGlfbG9uZ19hZ28pO1xuXHR9KTtcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdDpyb290IHtcblx0XHQtLWJhci13aWR0aDogNzguOCU7XG5cdFx0LS1hbmltYXRpb24tZHVyYXRpb246IDFzO1xuXHRcdC0tYW5pbWF0aW9uLWVhc2luZzogdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHR9XG5cblx0QGtleWZyYW1lcyBmYWRlIHtcblx0XHQwJSB7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHR9XG5cblx0XHQxMDAlIHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcblx0XHR9XG5cdH1cblxuXHQvLyBAa2V5ZnJhbWVzIHNsaWRlIHtcblx0Ly8gXHQwJSB7XG5cdC8vIFx0XHRsZWZ0OiBjYWxjKDAlIC0gdmFyKC0tYmFyLXdpZHRoKSk7XG5cdC8vIFx0fVxuXG5cdC8vIFx0MTAwJSB7XG5cdC8vIFx0XHRsZWZ0OiAwJTtcblx0Ly8gXHR9XG5cdC8vIH1cdFxuXG5cdEBrZXlmcmFtZXMgb3BhY2l0eSB7XG5cdFx0MCUge1xuXHRcdFx0b3BhY2l0eTogMDtcblx0XHR9XG5cblx0XHQxMDAlIHtcblx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0fVxuXHR9XG5cblxuXHRAa2V5ZnJhbWVzIG9mZnNjcmVlbiB7XG5cdFx0MCUge1xuXHRcdFx0dG9wOiAwO1xuXHRcdH1cblxuXHRcdDEwMCUge1xuXHRcdFx0dG9wOiB2YXIoLS1hcHAtd2luZG93LWhlaWdodCk7XG5cdFx0fVxuXHR9XG5cblx0LmFic29sdXRlKEBkaW1zOiAnJykge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblxuXHRcdHdpZHRoOiBpZignJyA9IEBkaW1zLCB2YXIoLS1hcHAtd2luZG93LXdpZHRoKSwgQGRpbXMpO1xuXHRcdGhlaWdodDogaWYoJycgPSBAZGltcywgdmFyKC0tYXBwLXdpbmRvdy1oZWlnaHQpLCBAZGltcyk7XG5cdH1cblxuXHQudmVuZG9yLW1lbnUge1xuXHRcdC0taXRlbS1wYWRkaW5nOiAzMHB4O1xuXG5cdFx0LmFic29sdXRlKCk7XG5cdFx0LmZvbnQocmVndWxhcik7XG5cdFx0ei1pbmRleDogMTAwMTtcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblx0XHQvLyBjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmxhY2spO1xuXG5cdFx0Pi5iYWNrZHJvcCB7XG5cdFx0XHQuYWJzb2x1dGUoMTAwJSk7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG5cdFx0XHR0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgdmFyKC0tZWFzZS1vdXQtZXhwbyk7XG5cdFx0fVxuXG5cdFx0Pi5iYXIge1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0d2lkdGg6IHZhcigtLWJhci13aWR0aCk7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHQvLyBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblx0XHRcdGxlZnQ6IDAlO1xuXHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdHRyYW5zaXRpb246IGxlZnQgdmFyKC0tYW5pbWF0aW9uLWR1cmF0aW9uKSB2YXIoLS1hbmltYXRpb24tZWFzaW5nKSxcblx0XHRcdFx0b3BhY2l0eSBjYWxjKHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgLyAzKSBlYXNlLW91dDtcblxuXHRcdFx0Pi5tZW51IHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XG5cdFx0XHRcdGhlaWdodDogMTAwJTtcblxuXHRcdFx0XHR1bCB7XG5cdFx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0XHRcdHBhZGRpbmc6IDA7XG5cblx0XHRcdFx0XHQ+bGkge1xuXHRcdFx0XHRcdFx0bGlzdC1zdHlsZTogbm9uZTtcblx0XHRcdFx0XHRcdHBhZGRpbmc6IDEzcHggMDtcblx0XHRcdFx0XHRcdHBhZGRpbmctbGVmdDogdmFyKC0taXRlbS1wYWRkaW5nKTtcblx0XHRcdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblxuXHRcdFx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ+Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmctcmlnaHQ6IGNhbGModmFyKC0taXRlbS1wYWRkaW5nKSAvIDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCYuaXRlbXMge1xuXHRcdFx0XHRcdFx0Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJsYWNrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmLnNlc3Npb24ge1xuXHRcdFx0XHRcdFx0cGFkZGluZzogY2FsYyh2YXIoLS1pdGVtLXBhZGRpbmcpIC8gMikgMDtcblxuXHRcdFx0XHRcdFx0Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+Lm1haW4ge1xuXHRcdFx0XHRcdGZsZXg6IDE7XG5cdFx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRcdGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcblx0XHRcdFx0XHQvLyBwYWRkaW5nLXRvcDogMTUlO1xuXG5cdFx0XHRcdFx0cGFkZGluZy1sZWZ0OiAxZW07XG5cblx0XHRcdFx0XHQ+KiB7XG5cdFx0XHRcdFx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+LmFwcCB7XG5cdFx0XHRcdFx0XHQvLyBtYXJnaW4tdG9wOiAyNSU7XG5cdFx0XHRcdFx0XHRtYXJnaW4tdG9wOiAxMHB4O1xuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0XHRcdFx0cGFkZGluZzogMTZweCAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdD4uaW5mbyB7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiAxNnB4IDA7XG5cblx0XHRcdFx0XHRcdC5uYW1lIHtcblx0XHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHRcdFx0LmZvbnQodGlueSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC52YWx1ZSB7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmctdG9wOiA0cHg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5ib3R0b20ge1xuXHRcdFx0XHRcdGZsZXg6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQmLmNvbGxhcHNlZCB7XG5cdFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdGFuaW1hdGlvbjogb2Zmc2NyZWVuIHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgc3RlcHMoMiwganVtcC1ub25lKSBib3RoO1xuXHRcdFx0XG5cdFx0XHQ+LmJhY2tkcm9wIHtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0Pi5iYXIge1xuXHRcdFx0XHRsZWZ0OiBjYWxjKDAlIC0gdmFyKC0tYmFyLXdpZHRoKSk7XG5cdFx0XHRcdG9wYWNpdHk6IDAuMTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGhyIHtcblx0XHRcdG1hcmdpbjogMCB2YXIoLS1pdGVtLXBhZGRpbmcpO1xuXHRcdFx0Ym9yZGVyOiBub25lO1xuXHRcdFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gLmNsb3NlLWRhcmsge1xuXHRcdC8vIFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdC8vIFx0dG9wOiAwO1xuXHRcdC8vIFx0cmlnaHQ6IDA7XG5cdFx0Ly8gXHRtYXJnaW46IDEwcHg7XG5cdFx0Ly8gXHRwYWRkaW5nOiAxMnB4O1xuXHRcdC8vIFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdC8vIFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdC8vIFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ibGFjayk7XG5cblx0XHQvLyBcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdC8vIFx0Ym9yZGVyLXJhZGl1czogMHB4O1xuXHRcdC8vIFx0dHJhbnNpdGlvbjogYm9yZGVyLXJhZGl1cyA2NTBtcyB2YXIoLS1lYXNlLW91dC1leHBvKTtcblx0XHQvLyBcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cblx0XHQvLyBcdCY6OmJlZm9yZSB7XG5cdFx0Ly8gXHRcdC0tb2NjbHVzaW9uLXRoaWNrbmVzczogNHB4O1xuXG5cdFx0Ly8gXHRcdGNvbnRlbnQ6ICcnO1xuXHRcdC8vIFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0Ly8gXHRcdHRvcDogY2FsYyh2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSAvIDIpO1xuXHRcdC8vIFx0XHRsZWZ0OiBjYWxjKHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIC8gMik7XG5cdFx0Ly8gXHRcdHdpZHRoOiBjYWxjKDEwMCUgLSB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSk7XG5cdFx0Ly8gXHRcdGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykpO1xuXHRcdC8vIFx0XHRvdXRsaW5lOiB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHQvLyBcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHQvLyBcdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0Ly8gXHR9XG5cblx0XHQvLyBcdCY6aG92ZXIge1xuXHRcdC8vIFx0XHRib3JkZXItcmFkaXVzOiAyMnB4O1xuXHRcdC8vIFx0fVxuXHRcdC8vIH1cblxuXHRcdC5jbG9zZSB7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRyaWdodDogMDtcblx0XHRcdG1hcmdpbjogMTBweDtcblx0XHRcdHBhZGRpbmc6IDEycHg7XG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXG5cdFx0XHRvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdGJvcmRlci1yYWRpdXM6IDBweDtcblx0XHRcdHRyYW5zaXRpb246IGJvcmRlci1yYWRpdXMgNjUwbXMgdmFyKC0tZWFzZS1vdXQtZXhwbyk7XG5cdFx0XHRwb2ludGVyLWV2ZW50czogYWxsO1xuXG5cdFx0XHQmOjpiZWZvcmUge1xuXHRcdFx0XHQtLW9jY2x1c2lvbi10aGlja25lc3M6IDRweDtcblxuXHRcdFx0XHRjb250ZW50OiAnJztcblx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHR0b3A6IGNhbGModmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgLyAyKTtcblx0XHRcdFx0bGVmdDogY2FsYyh2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSAvIDIpO1xuXHRcdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykpO1xuXHRcdFx0XHRoZWlnaHQ6IGNhbGMoMTAwJSAtIHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpKTtcblx0XHRcdFx0b3V0bGluZTogdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRcdH1cblxuXHRcdFx0Jjpob3ZlciB7XG5cdFx0XHRcdGJvcmRlci1yYWRpdXM6IDIycHg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHR9XG48L3N0eWxlPlxuXG48ZGl2XG5cdGNsYXNzPVwidmVuZG9yLW1lbnVcIlxuXHRjbGFzczpjb2xsYXBzZWQ9eyEkeXdfbWVudV92ZW5kb3J9XG4+XG5cdDxkaXYgY2xhc3M9XCJiYWNrZHJvcFwiXG5cdFx0b246Y2xpY2s9eygpID0+ICR5d19tZW51X3ZlbmRvciA9IGZhbHNlfVxuXHQvPlxuXG5cdDxkaXYgY2xhc3M9XCJiYXJcIj5cblx0XHQ8ZGl2IGNsYXNzPVwiY2xvc2UgaWNvblwiIG9uOmNsaWNrPXsoKSA9PiAkeXdfbWVudV92ZW5kb3IgPSBmYWxzZX0+XG5cdFx0XHQ8IS0tIDxpbWcgYWx0PVwiQ2xvc2UgaWNvblwiIHNyYz1cIi9hc3NldHMvbWVkaWEvbmF2L2Nsb3NlLnN2Z1wiPiAtLT5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJtZW51XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwibWFpblwiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYXBwXCI+XG5cdFx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRcdDwhLS0ge0BodG1sIFNYX1RJVExFfSAtLT5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHR2MC4wLjFcblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PCEtLSA8ZGl2PlxuXHRcdFx0XHRcdEN1cnJlbnQgZEFwcFxuXHRcdFx0XHQ8L2Rpdj4gLS0+XG5cblx0XHRcdFx0PCEtLSA8ZGl2PlxuXHRcdFx0XHRcdGRvbWFpbjogc2VjcmV0c3dhcC5pb1xuXHRcdFx0XHQ8L2Rpdj4gLS0+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0TmV0d29yayBTdGF0dXNcblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0e3NfbmV0d29ya19zdGF0dXN9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdENoYWluIElkXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsdWVcIj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiZm9udC1mYW1pbHlfbW9ub1wiPlxuXHRcdFx0XHRcdFx0XHR7c2lfY2hhaW59XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdEN1cnJlbnQgUHJvdmlkZXJcblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJmb250LWZhbWlseV9tb25vXCI+XG5cdFx0XHRcdFx0XHRcdHtwX3Byb3ZpZGVyfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHRDdXJyZW50IEJsb2NrIEhlaWdodFxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbHVlXCI+XG5cdFx0XHRcdFx0XHQje3NfaGVpZ2h0fVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHRBdmVyYWdlIEJsb2NrIFRpbWVcblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0eyNpZiB4dF9hdmdfYmxvY2tfdGltZX1cblx0XHRcdFx0XHRcdFx0eyh4dF9hdmdfYmxvY2tfdGltZSAvIDFlMykudG9GaXhlZCgyKX0gc2Vjb25kc1xuXHRcdFx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdFx0XHRbLi4uXVxuXHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0TGFzdCBCbG9jayBTZWVuXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsdWVcIj5cblx0XHRcdFx0XHRcdHtzX2xvbmdfYWdvfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8IS0tIDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdE5leHQgYmxvY2sgaW5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0IHNlY29uZHNcblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+IC0tPlxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj5cbiIsImltcG9ydCB0eXBlIHsgUGxhaW5PYmplY3QgfSBmcm9tICcjL21ldGEvYmVsdCc7XG5pbXBvcnQgdHlwZSB7IFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvciB9IGZyb20gJyMvbWV0YS9zdmVsdGUnO1xuaW1wb3J0IHtcblx0RGljdCwgb2JqZWN0c19taWdodF9kaWZmZXIsIG9kZSwgUHJvbWlzYWJsZSxcbn0gZnJvbSAnIy91dGlsL2JlbHQnO1xuaW1wb3J0IHsgZGQgfSBmcm9tICcjL3V0aWwvZG9tJztcbmltcG9ydCB0eXBlIHsgSnVtcENvbmZpZywgUG9wQ29uZmlnLCBUaHJlYWQgfSBmcm9tICcuL3RocmVhZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZUNvbmZpZzxcblx0aF9wcm9wcyBleHRlbmRzIERpY3Q8dW5rbm93bj49RGljdDx1bmtub3duPixcblx0ZGNfY3JlYXRvciBleHRlbmRzIFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvcjxoX3Byb3BzPj1QYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3I8aF9wcm9wcz4sXG4+IHtcblx0Y3JlYXRvcjogZGNfY3JlYXRvcjtcblx0cHJvcHM/OiBoX3Byb3BzO1xuXHRjb250ZXh0PzogUGxhaW5PYmplY3Q7XG5cdGV2ZW50cz86IERpY3Q8KGRfZXZlbnQ6IEN1c3RvbUV2ZW50PHVua25vd24+KSA9PiBQcm9taXNhYmxlPHZvaWQ+Pjtcblx0cGF0aD86IHN0cmluZztcblx0cGF0dGVybj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdlRXZlbnRDb25maWcge1xuXHQvKipcblx0ICogRmlyZWQgYW55dGltZSBhIHBhZ2UgbG9zZXMgZm9jdXMgKGluY2x1ZGluZyBvbiB0aHJlYWQgc3dpdGNoKVxuXHQgKi9cblx0Ymx1cj8oKTogUHJvbWlzYWJsZTx2b2lkPjtcblxuXHQvKipcblx0ICogRmlyZWQgYW55dGltZSBhIHBhZ2UgcmVjZWl2ZXMgZm9jdXMgKGluY2x1ZGluZyBvbiB0aHJlYWQgc3dpdGNoKVxuXHQgKi9cblx0Zm9jdXM/KCk6IFByb21pc2FibGU8dm9pZD47XG5cblx0LyoqXG5cdCAqIEZpcmVkIHdoZW4gYSBwcmV2aW91c2x5IGV4aXN0aW5nIHBhZ2UgaXMgcmVzdG9yZWQgZnJvbSBoaXN0b3J5IChlLmcuLCB2aWEgcG9wKVxuXHQgKi9cblx0cmVzdG9yZT8oKTogUHJvbWlzYWJsZTx2b2lkPjtcbn1cblxudHlwZSBQYWdlRXZlbnRJZCA9IGtleW9mIFBhZ2VFdmVudENvbmZpZztcblxuZXhwb3J0IGNsYXNzIFBhZ2U8XG5cdGhfcHJvcHMgZXh0ZW5kcyBEaWN0PHVua25vd24+PURpY3Q8dW5rbm93bj4sXG5cdGRjX2NyZWF0b3IgZXh0ZW5kcyBQYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3I8aF9wcm9wcz49UGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yPGhfcHJvcHM+LFxuXHR5Y19jb21wb25lbnQgZXh0ZW5kcyBJbnN0YW5jZVR5cGU8ZGNfY3JlYXRvcj49SW5zdGFuY2VUeXBlPGRjX2NyZWF0b3I+LFxuPiB7XG5cdHByb3RlY3RlZCBfZGNfY3JlYXRvcjogZGNfY3JlYXRvcjtcblx0cHJvdGVjdGVkIF95Y19jb21wb25lbnQ6IHljX2NvbXBvbmVudDtcblx0cHJvdGVjdGVkIF9oX3Byb3BzOiBoX3Byb3BzO1xuXHRwcm90ZWN0ZWQgX2hfY29udGV4dDogUGxhaW5PYmplY3Q7XG5cdHByb3RlY3RlZCBfZG1fcGFnZTogSFRNTEVsZW1lbnQ7XG5cblx0cHJvdGVjdGVkIF9zaV9wYWdlOiBzdHJpbmc7XG5cdHByb3RlY3RlZCBfaF9ldmVudHM6IFBhcnRpYWw8UmVjb3JkPFBhZ2VFdmVudElkLCBBcnJheTwoLi4uYV9hcmdzOiBhbnlbXSkgPT4gUHJvbWlzYWJsZTx2b2lkPj4+PiA9IHt9O1xuXG5cdHByb3RlY3RlZCBfc3JfcGF0aDogc3RyaW5nO1xuXHRwcm90ZWN0ZWQgX3N4X3BhdHRlcm46IHN0cmluZztcblxuXHRjb25zdHJ1Y3RvcihnY19wYWdlOiBQYWdlQ29uZmlnPGhfcHJvcHMsIGRjX2NyZWF0b3I+LCBwcm90ZWN0ZWQgX2t0X3BhcmVudDogVGhyZWFkKSB7XG5cdFx0KHtcblx0XHRcdGNyZWF0b3I6IHRoaXMuX2RjX2NyZWF0b3IsXG5cdFx0XHRwcm9wczogdGhpcy5faF9wcm9wcz17fSBhcyBoX3Byb3BzLFxuXHRcdFx0Y29udGV4dDogdGhpcy5faF9jb250ZXh0PXt9IGFzIFBsYWluT2JqZWN0LFxuXHRcdFx0Ly8gcGF0aDogdGhpcy5fc3JfcGF0aD0nJyxcblx0XHRcdC8vIHBhdHRlcm46IHRoaXMuX3N4X3BhdHRlcm49JycsXG5cdFx0fSA9IGdjX3BhZ2UgYXMgUmVxdWlyZWQ8dHlwZW9mIGdjX3BhZ2U+KTtcblxuXHRcdC8vIHNldCB1bmlxdWUgcGFnZSBpZFxuXHRcdHRoaXMuX3NpX3BhZ2UgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuXG5cdFx0Ly8gY3JlYXRlIGJ1ZmZlciBlbGVtZW50XG5cdFx0Y29uc3QgZG1fYnVmZmVyID0gZGQoJ2RpdicpO1xuXG5cdFx0Y29uc3QgaG1fY29udGV4dCA9IG5ldyBNYXAob2RlKHtcblx0XHRcdC4uLnRoaXMuX2hfY29udGV4dCxcblx0XHRcdHBhZ2U6IHRoaXMsXG5cdFx0fSkpO1xuXG5cdFx0Ly8gc3Bhd24gY29tcG9uZW50XG5cdFx0dGhpcy5feWNfY29tcG9uZW50ID0gbmV3IHRoaXMuX2RjX2NyZWF0b3Ioe1xuXHRcdFx0dGFyZ2V0OiBkbV9idWZmZXIsXG5cdFx0XHRwcm9wczoge1xuXHRcdFx0XHQuLi50aGlzLl9oX3Byb3BzLFxuXHRcdFx0XHRrX3BhZ2U6IHRoaXMsXG5cdFx0XHR9LFxuXHRcdFx0Y29udGV4dDogaG1fY29udGV4dCxcblx0XHR9KSBhcyB5Y19jb21wb25lbnQ7XG5cblx0XHQvLyBiaW5kIGV2ZW50c1xuXHRcdGlmKGdjX3BhZ2UuZXZlbnRzKSB7XG5cdFx0XHRmb3IoY29uc3QgW3NpX2V2ZW50LCBmX2xpc3RlbmVyXSBvZiBvZGUoZ2NfcGFnZS5ldmVudHMpKSB7XG5cdFx0XHRcdHRoaXMuX3ljX2NvbXBvbmVudC4kb24oc2lfZXZlbnQsIGZfbGlzdGVuZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGZldGNoIGRvbVxuXHRcdGNvbnN0IGRtX3N0YXRlID0gZG1fYnVmZmVyLmZpcnN0RWxlbWVudENoaWxkIGFzIG51bGwgfCBIVE1MRWxlbWVudDtcblx0XHRpZighZG1fc3RhdGUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgTm8gRE9NIGVsZW1lbnQgd2FzIGNyZWF0ZWQgZHVyaW5nIHBhZ2UgY29tcG9uZW50IHNwYXduaW5nIHVzaW5nOiAke0pTT04uc3RyaW5naWZ5KGdjX3BhZ2UpfWApO1xuXHRcdH1cblxuXHRcdC8vIHNldCBmaWVsZFxuXHRcdHRoaXMuX2RtX3BhZ2UgPSBkbV9zdGF0ZTtcblx0fVxuXG5cdGdldCBpZCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9zaV9wYWdlO1xuXHR9XG5cblx0Z2V0IGluZGV4KCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmhpc3RvcnkubGVuZ3RoO1xuXHR9XG5cblx0Z2V0IHRocmVhZCgpOiBUaHJlYWQge1xuXHRcdHJldHVybiB0aGlzLl9rdF9wYXJlbnQ7XG5cdH1cblxuXHRnZXQgY3JlYXRvcigpOiBkY19jcmVhdG9yIHtcblx0XHRyZXR1cm4gdGhpcy5fZGNfY3JlYXRvcjtcblx0fVxuXG5cdGdldCBjb21wb25lbnQoKTogeWNfY29tcG9uZW50IHtcblx0XHRyZXR1cm4gdGhpcy5feWNfY29tcG9uZW50O1xuXHR9XG5cblx0Z2V0IHByb3BzKCk6IGhfcHJvcHMge1xuXHRcdHJldHVybiB0aGlzLl9oX3Byb3BzO1xuXHR9XG5cblx0Z2V0IGRvbSgpOiBIVE1MRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2RtX3BhZ2U7XG5cdH1cblxuXHRlcXVpdmFsZW50KHdfb3RoZXI6IFBhZ2UgfCBQYWdlQ29uZmlnKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHdfb3RoZXIuY3JlYXRvciA9PT0gdGhpcy5jcmVhdG9yXG5cdFx0XHQmJiAhb2JqZWN0c19taWdodF9kaWZmZXIod19vdGhlci5wcm9wcyB8fCB7fSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRwZWFrKCk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLl9rdF9wYXJlbnQucGVhaygpO1xuXHR9XG5cblx0cHVzaChnY19wYWdlOiBQYWdlQ29uZmlnKTogUGFnZSB7XG5cdFx0cmV0dXJuIHRoaXMuX2t0X3BhcmVudC5wdXNoKGdjX3BhZ2UsIHRoaXMpO1xuXHR9XG5cblx0cG9wKGdjX3BvcD86IFBvcENvbmZpZyk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLl9rdF9wYXJlbnQucG9wKGdjX3BvcCB8fCB7fSwgdGhpcyk7XG5cdH1cblxuXHRqdW1wKGdjX3BhZ2U6IFBhZ2VDb25maWcsIGdjX2p1bXA/OiBKdW1wQ29uZmlnKTogUGFnZSB7XG5cdFx0cmV0dXJuIHRoaXMuX2t0X3BhcmVudC5qdW1wKGdjX3BhZ2UsIGdjX2p1bXAgfHwge30sIHRoaXMpO1xuXHR9XG5cblx0b24oaF9ldmVudHM6IFBhZ2VFdmVudENvbmZpZyk6IHZvaWQge1xuXHRcdGZvcihjb25zdCBbc2lfZXZlbnQsIGZfbGlzdGVuZXJdIG9mIG9kZShoX2V2ZW50cykpIHtcblx0XHRcdGlmKGZfbGlzdGVuZXIpIHtcblx0XHRcdFx0Y29uc3QgYV9saXN0ZW5lcnMgPSB0aGlzLl9oX2V2ZW50c1tzaV9ldmVudF0gPSB0aGlzLl9oX2V2ZW50c1tzaV9ldmVudF0gfHwgW107XG5cdFx0XHRcdGFfbGlzdGVuZXJzLnB1c2goZl9saXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgZmlyZShzaV9ldmVudDogUGFnZUV2ZW50SWQsIGFfYXJncz86IGFueVtdKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgYV9saXN0ZW5lcnMgPSB0aGlzLl9oX2V2ZW50c1tzaV9ldmVudF07XG5cblx0XHRpZihhX2xpc3RlbmVycykge1xuXHRcdFx0YXdhaXQgUHJvbWlzZS5hbGwoYV9saXN0ZW5lcnMubWFwKGYgPT4gZiguLi5hX2FyZ3MgfHwgW10gYXMgY29uc3QpKSk7XG5cdFx0fVxuXHR9XG5cblx0ZGVzdHJveSgpOiB2b2lkIHtcblx0XHR0aGlzLl95Y19jb21wb25lbnQuJGRlc3Ryb3koKTtcblx0fVxuXG5cdHJlc2V0KCk6IHZvaWQge1xuXHRcdHRoaXMuX2t0X3BhcmVudC5yZXNldCgpO1xuXHR9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvciB9IGZyb20gJyMvbWV0YS9zdmVsdGUnO1xuaW1wb3J0IHsgRGljdCwgRl9OT09QIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuaW1wb3J0IHsgZGQgfSBmcm9tICcjL3V0aWwvZG9tJztcbmltcG9ydCB0eXBlIHtUaHJlYWRJZH0gZnJvbSAnLi4vZGVmJztcbmltcG9ydCB7IE5hdmlnYXRvciwgc2V0X3ppbmRleF9yZWxhdGl2ZWx5IH0gZnJvbSAnLi9uYXZpZ2F0b3InO1xuaW1wb3J0IHtQYWdlLCBQYWdlQ29uZmlnfSBmcm9tICcuL3BhZ2UnO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzZXRDb25maWcge1xuXHRrZWVwVG9wPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb3BDb25maWcge1xuXHRieXBhc3NBbmltYXRpb24/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEp1bXBDb25maWcge1xuXHRmb3JjZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBUaHJlYWQge1xuXHRwcm90ZWN0ZWQgX2RtX3RocmVhZDogSFRNTERpdkVsZW1lbnQ7XG5cblx0cHJvdGVjdGVkIF9hX2hpc3Rvcnk6IFBhZ2VbXSA9IFtdO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfc2lfdGhyZWFkOiBUaHJlYWRJZCwgcHJvdGVjdGVkIF9nY19kZWZhdWx0OiBQYWdlQ29uZmlnLCBwcm90ZWN0ZWQgX2tfbmF2aWdhdG9yOiBOYXZpZ2F0b3IpIHtcblx0XHR0aGlzLl9kbV90aHJlYWQgPSBkZCgnZGl2Jywge1xuXHRcdFx0J2NsYXNzJzogJ3RocmVhZCcsXG5cdFx0XHQnZGF0YS10aHJlYWQtaWQnOiB0aGlzLl9zaV90aHJlYWQsXG5cdFx0XHQnc3R5bGUnOiAnei1pbmRleDogMTAwOycsXG5cdFx0fSk7XG5cdH1cblxuXHRnZXQgaWQoKTogVGhyZWFkSWQge1xuXHRcdHJldHVybiB0aGlzLl9zaV90aHJlYWQ7XG5cdH1cblxuXHRnZXQgZGVmYXVsdCgpOiBQYWdlQ29uZmlnIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2NfZGVmYXVsdDtcblx0fVxuXG5cdGdldCBoaXN0b3J5KCk6IFBhZ2VbXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FfaGlzdG9yeTtcblx0fVxuXG5cdGdldCBwYWdlKCk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLl9hX2hpc3RvcnlbMF07XG5cdH1cblxuXHRnZXQgZG9tKCk6IEhUTUxFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fZG1fdGhyZWFkO1xuXHR9XG5cblx0Ly8gcGxhY2UgcGFnZVxuXHRwcm90ZWN0ZWQgX3BsYWNlKGdjX3BhZ2U6IFBhZ2VDb25maWcpOiBQYWdlIHtcblx0XHQvLyBjcmVhdGUgbmV3IHBhZ2Vcblx0XHRjb25zdCBrcF9uZXcgPSBuZXcgUGFnZSh7XG5cdFx0XHQuLi5nY19wYWdlLFxuXHRcdFx0Y29udGV4dDoge1xuXHRcdFx0XHQuLi50aGlzLl9rX25hdmlnYXRvci5jb250ZXh0LFxuXHRcdFx0XHQuLi5nY19wYWdlLmNvbnRleHQsXG5cdFx0XHR9LFxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0Ly8gYXBwZW5kIHRvIGRvbVxuXHRcdHRoaXMuX2RtX3RocmVhZC5hcHBlbmRDaGlsZChrcF9uZXcuZG9tKTtcblxuXHRcdC8vIHB1c2ggc3RhdGUgdG8gZnJvbnQgb2Ygc3RhY2tcblx0XHR0aGlzLl9hX2hpc3RvcnkudW5zaGlmdChrcF9uZXcpO1xuXG5cdFx0Ly8gcmV0dXJuIG5ldyBwYWdlXG5cdFx0cmV0dXJuIGtwX25ldztcblx0fVxuXG5cblx0cmVzZXQoZ2NfcGFnZTogUGFnZUNvbmZpZz10aGlzLmRlZmF1bHQsIGdjX3Jlc2V0PzogUmVzZXRDb25maWcpOiBQYWdlIHtcblx0XHQvLyBcblx0XHRjb25zdCB7XG5cdFx0XHRrZWVwVG9wOiBiX2tlZXBfdG9wLFxuXHRcdH0gPSBnY19yZXNldCB8fCB7fTtcblxuXHRcdC8vIHJlZiBoaXN0b3J5XG5cdFx0Y29uc3QgYV9oaXN0b3J5ID0gdGhpcy5fYV9oaXN0b3J5O1xuXG5cdFx0Ly8gLy8ga2VlcCB0b3AgaXMgZW5hYmxlZDsgZ3JhYiBzcmMgc3R5bGVcblx0XHQvLyBjb25zdCBkX3N0eWxlID0gYl9rZWVwX3RvcD8gYV9oaXN0b3J5WzBdLmRvbS5zdHlsZTogbnVsbDtcblxuXHRcdC8vIGRyb3AgYWxsIHN0YWxlIHN0YXRlcyBpbiBoaXN0b3J5XG5cdFx0Zm9yKGxldCBpX3N0YXRlPWJfa2VlcF90b3A/IDE6IDA7IGlfc3RhdGU8YV9oaXN0b3J5Lmxlbmd0aDsgaV9zdGF0ZSsrKSB7XG5cdFx0XHRhX2hpc3RvcnlbaV9zdGF0ZV0uY29tcG9uZW50LiRkZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVzZXQgaGlzdG9yeVxuXHRcdGFfaGlzdG9yeS5sZW5ndGggPSAwO1xuXG5cdFx0Ly8gcGxhY2UgbmV3IHBhZ2Vcblx0XHRjb25zdCBrcF9uZXcgPSB0aGlzLl9wbGFjZShnY19wYWdlKTtcblxuXHRcdC8vIGZpcmUgY2hhbmdlIG9uIG5ldyBwYWdlXG5cdFx0dm9pZCB0aGlzLl9rX25hdmlnYXRvci5hZnRlcl9yZXNldCh0aGlzLCBrcF9uZXcsIGdjX3Jlc2V0IHx8IHt9KTtcblxuXHRcdC8vIC8vIGtlZXAgdG9wIGlzIGVuYWJsZWRcblx0XHQvLyBpZihkX3N0eWxlKSB7XG5cdFx0Ly8gXHQvLyBzZXQgbmV3IHNjcmVlbiBiZWxvd1xuXHRcdC8vIFx0a3NfbmV3LmRvbS5zdHlsZS56SW5kZXggPSAoKCtkX3N0eWxlLnpJbmRleCkrMSkrJyc7XG5cdFx0Ly8gfVxuXG5cdFx0cmV0dXJuIGtwX25ldztcblx0fVxuXG5cdHBlYWsoKTogUGFnZSB8IHVuZGVmaW5lZCB7XG5cdFx0cmV0dXJuIHRoaXMuX2FfaGlzdG9yeVsxXTtcblx0fVxuXG5cdHB1c2goZ2NfcGFnZTogUGFnZUNvbmZpZywga3Bfc3JjOiBQYWdlKTogUGFnZSB7XG5cdFx0Ly8gY2FsbGVyIGlzIHByZXNlbnQgYnV0IGl0IGlzIG5vdCB0aGUgYWN0aXZlIHBhZ2Vcblx0XHRpZihrcF9zcmMgIT09IHRoaXMucGFnZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcmV2ZW50ZWQgaW5hY3RpdmUgcGFnZSBmcm9tIHB1c2hpbmcgbmV3IHNjcmVlbicpO1xuXHRcdH1cblxuXHRcdC8vIGdldCBhcHByb3ZhbCBmcm9tIHBhcmVudFxuXHRcdGlmKCF0aGlzLl9rX25hdmlnYXRvci5iZWZvcmVfcHVzaChnY19wYWdlLCBrcF9zcmMsIHRoaXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZXZlbnRlZCBpbmFjdGl2ZSB0aHJlYWQgZnJvbSBwdXNoaW5nIG5ldyBzY3JlZW4nKTtcblx0XHR9XG5cblx0XHQvLyBwbGFjZSBwYWdlXG5cdFx0Y29uc3Qga3BfbmV3ID0gdGhpcy5fcGxhY2UoZ2NfcGFnZSk7XG5cblx0XHQvLyBjYWxsIGhvb2tzIG9uIHBhcmVudFxuXHRcdHZvaWQgdGhpcy5fa19uYXZpZ2F0b3IuYWZ0ZXJfcHVzaCh0aGlzLCBrcF9zcmMsIGtwX25ldyk7XG5cblx0XHQvLyByZXR1cm4gbmV3IHBhZ2Vcblx0XHRyZXR1cm4ga3BfbmV3O1xuXHR9XG5cblx0cG9wKGdjX3BvcDogUG9wQ29uZmlnLCBrcF9zcmM6IFBhZ2UpOiBQYWdlIHtcblx0XHQvLyBjYWxsZXIgaXMgcHJlc2VudCBidXQgaXQgaXMgbm90IHRoZSBhY3RpdmUgcGFnZVxuXHRcdGlmKGtwX3NyYyAhPT0gdGhpcy5wYWdlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZXZlbnRlZCBpbmFjdGl2ZSBwYWdlIGZyb20gcG9wcGluZyBhY3RpdmUgc2NyZWVuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gdG9vIHNob3J0XG5cdFx0aWYodGhpcy5fYV9oaXN0b3J5Lmxlbmd0aCA8IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBvcCBlbXB0eSBoaXN0b3J5YCk7XG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IGFwcHJvdmFsIGZyb20gcGFyZW50XG5cdFx0aWYoIXRoaXMuX2tfbmF2aWdhdG9yLmJlZm9yZV9wb3AoZ2NfcG9wLCB0aGlzLl9hX2hpc3RvcnlbMV0sIGtwX3NyYywgdGhpcykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUHJldmVudGVkIGluYWN0aXZlIHRocmVhZCBmcm9tIHBvcHBpbmcgYWN0aXZlIHNjcmVlbicpO1xuXHRcdH1cblxuXHRcdC8vIHNoaWZ0IGhpc3Rvcnlcblx0XHR0aGlzLl9hX2hpc3Rvcnkuc2hpZnQoKTtcblxuXHRcdC8vIGFjcXVpcmUgZGVzdGluYXRpb24gcGFnZVxuXHRcdGNvbnN0IGtwX2RzdCA9IHRoaXMucGFnZTtcblxuXHRcdC8vIGNhbGwgaG9va3Mgb24gcGFyZW50XG5cdFx0dm9pZCB0aGlzLl9rX25hdmlnYXRvci5hZnRlcl9wb3AodGhpcywga3Bfc3JjLCBrcF9kc3QsIGdjX3BvcCk7XG5cblx0XHQvLyByZXR1cm4gZHN0IHBhZ2Vcblx0XHRyZXR1cm4ga3BfZHN0O1xuXHR9XG5cblx0anVtcChnY19wYWdlOiBQYWdlQ29uZmlnLCBnY19qdW1wOiBKdW1wQ29uZmlnLCBrcF9zcmM6IFBhZ2UpOiBQYWdlIHtcblx0XHQvLyBjYWxsZXIgaXMgcHJlc2VudCBidXQgaXQgaXMgbm90IHRoZSBhY3RpdmUgcGFnZVxuXHRcdGlmKGtwX3NyYyAhPT0gdGhpcy5wYWdlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZXZlbnRlZCBpbmFjdGl2ZSBwYWdlIGZyb20ganVtcGluZyB0byBzY3JlZW4nKTtcblx0XHR9XG5cblx0XHQvLyBnZXQgYXBwcm92YWwgZnJvbSBwYXJlbnRcblx0XHRpZighdGhpcy5fa19uYXZpZ2F0b3IuYmVmb3JlX2p1bXAoZ2NfanVtcCwgZ2NfcGFnZSwga3Bfc3JjLCB0aGlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcmV2ZW50ZWQgaW5hY3RpdmUgdGhyZWFkIGZyb20ganVtcGluZyB0byBzY3JlZW4nKTtcblx0XHR9XG5cblx0XHQvLyBub3QgYmVpbmcgZm9yY2VkIGFuZCB0aGUgcHJldmlvdXMgaXRlbSBpbiBoaXN0b3J5IG1hdGNoZXMgdGhlIHRhcmdldFxuXHRcdGNvbnN0IGtwX3ByZXYgPSB0aGlzLl9hX2hpc3RvcnlbMV0gYXMgUGFnZSB8IHVuZGVmaW5lZDtcblx0XHRpZighZ2NfanVtcC5mb3JjZSAmJiBrcF9wcmV2Py5lcXVpdmFsZW50KGdjX3BhZ2UpKSB7XG5cdFx0XHQvLyBkZWZlciB0byBwb3Agb3BlcmF0aW9uXG5cdFx0XHRyZXR1cm4gdGhpcy5wb3Aoe30sIGtwX3NyYyk7XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIG5ldyBwYWdlXG5cdFx0Y29uc3Qga3BfZHN0ID0gbmV3IFBhZ2UoZ2NfcGFnZSwgdGhpcyk7XG5cblx0XHQvLyBkZXN0cm95IGFsbCBjb21wb25lbnRzIGZ1cnRoZXIgYmFjayBpbiB0aGUgc3RhY2tcblx0XHR0aGlzLnJlc2V0KCk7XG5cblx0XHQvLyBtb3ZlIGRlYWRcblx0XHRzZXRfemluZGV4X3JlbGF0aXZlbHkoa3BfZHN0LmRvbSwga3Bfc3JjLmRvbSwgKzEpO1xuXG5cdFx0Ly8gd2FpdCBmb3IgY2FsbCBob29rcyB0byByZXNvbHZlXG5cdFx0dm9pZCB0aGlzLl9rX25hdmlnYXRvci5hZnRlcl9qdW1wKHRoaXMsIGtwX3NyYywga3BfZHN0LCBnY19qdW1wKS50aGVuKCgpID0+IHtcblx0XHRcdC8vIGF0dGVtcHQgdG8gZGVzdHJveSBzcmMgcGFnZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0a3Bfc3JjLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoKGVfZGVzdHJveSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYEZhaWxlZCB0byBkZXN0cm95IHN0YWxlIGNvbXBvbmVudCBiZWxvbmdpbmcgdG8gcGFnZTogJHtrcF9zcmMuY3JlYXRvci5uYW1lKycnfWApO1xuXG5cdFx0XHRcdC8vIGF0dGVtcHQgdG8gZm9yY2libHkgcmVtb3ZlIHRoZSBkb21cblx0XHRcdFx0a3Bfc3JjLmRvbS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHJldHVybiBuZXcgcGFnZVxuXHRcdHJldHVybiBrcF9kc3Q7XG5cdH1cblxuXHRoaWRlKCk6IHZvaWQge1xuXHRcdHRoaXMuX2RtX3RocmVhZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHR9XG5cblx0c2hvdygpOiB2b2lkIHtcblx0XHR0aGlzLl9kbV90aHJlYWQuc3R5bGUuZGlzcGxheSA9ICdpbml0aWFsJztcblx0fVxufVxuIiwiaW1wb3J0IHR5cGUgeyBQbGFpbk9iamVjdCB9IGZyb20gJyMvbWV0YS9iZWx0JztcbmltcG9ydCB7IERpY3QsIG9iamVjdHNfbWlnaHRfZGlmZmVyLCBQcm9taXNhYmxlIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuaW1wb3J0IHsgZGQgfSBmcm9tICcjL3V0aWwvZG9tJztcbmltcG9ydCB0eXBlIHsgTWVyZ2UgfSBmcm9tICd0cy10b29sYmVsdC9vdXQvT2JqZWN0L01lcmdlJztcbmltcG9ydCB7IFRocmVhZElkIH0gZnJvbSAnLi4vZGVmJztcbmltcG9ydCB7IFBhZ2UsIFBhZ2VDb25maWcgfSBmcm9tICcuL3BhZ2UnO1xuaW1wb3J0IHsgSnVtcENvbmZpZywgUG9wQ29uZmlnLCBSZXNldENvbmZpZywgVGhyZWFkIH0gZnJvbSAnLi90aHJlYWQnO1xuXG5cbmludGVyZmFjZSBIb29rcyB7XG5cdGJlZm9yZV9jaGFuZ2U/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBzX3RyYW5zaXRpb246IHN0cmluZywgaF9leHRyYT86IERpY3QpOiB2b2lkIHwgYm9vbGVhbjtcblxuXHRiZWZvcmVfcHVzaD8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGdjX2RzdDogUGFnZUNvbmZpZyk6IHZvaWQgfCBib29sZWFuO1xuXHRiZWZvcmVfcG9wPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19wb3A6IFBvcENvbmZpZyk6IHZvaWQgfCBib29sZWFuO1xuXHRiZWZvcmVfanVtcD8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGdjX3BhZ2U6IFBhZ2VDb25maWcsIGdjX2p1bXA6IEp1bXBDb25maWcpOiB2b2lkIHwgYm9vbGVhbjtcblxuXHRhZnRlcl9jaGFuZ2U/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlIHwgbnVsbCwga3BfZHN0OiBQYWdlLCBzX3RyYW5zaXRpb246IHN0cmluZywgaF9leHRyYT86IERpY3QpOiBQcm9taXNhYmxlPHZvaWQ+O1xuXG5cdGFmdGVyX3B1c2g/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBrcF9kc3Q6IFBhZ2UpOiBQcm9taXNhYmxlPHZvaWQgfCBEaWN0Pjtcblx0YWZ0ZXJfcG9wPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19wb3A6IFBvcENvbmZpZyk6IFByb21pc2FibGU8dm9pZCB8IERpY3Q+O1xuXHRhZnRlcl9qdW1wPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19qdW1wOiBKdW1wQ29uZmlnKTogUHJvbWlzYWJsZTx2b2lkIHwgRGljdD47XG5cdGFmdGVyX3Jlc2V0PyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX2RzdDogUGFnZSwgZ2NfanVtcDogUmVzZXRDb25maWcpOiBQcm9taXNhYmxlPHZvaWQgfCBEaWN0PjtcblxuXHRiZWZvcmVfc3dpdGNoPyhrdF9zcmM6IFRocmVhZCwgc2lfdGhyZWFkX2RzdDogVGhyZWFkSWQpOiBQcm9taXNhYmxlPHZvaWQ+O1xuXHRhZnRlcl9zd2l0Y2g/KGt0X3NyYzogVGhyZWFkLCBrdF9kc3Q6IFRocmVhZCk6IFByb21pc2FibGU8dm9pZD47XG59XG5cblxudHlwZSBUaHJlYWRTcGF3bmVyID0gKGhfcGFyYW1zOiBQbGFpbk9iamVjdCwgaF9jb250ZXh0PzogUGxhaW5PYmplY3QpID0+IFBhZ2VDb25maWc7XG5cbnR5cGUgVGhyZWFkc0NvbmZpZyA9IE1lcmdlPHtcblx0ZGVmYXVsdDogVGhyZWFkU3Bhd25lcjtcbn0sIFBhcnRpYWw8UmVjb3JkPFRocmVhZElkLCBUaHJlYWRTcGF3bmVyPj4+O1xuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRvckNvbmZpZyB7XG5cdGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG5cdGhvb2tzOiBIb29rcztcblx0dGhyZWFkczogVGhyZWFkc0NvbmZpZztcblxuXHRjb250ZXh0OiBQbGFpbk9iamVjdCB8IG5ldmVyO1xuXG5cdC8vIHNpbmdsZVRocmVhZE1vZGU/OiBib29sZWFuO1xuXG5cdC8vIHJvdXRlcjogUm91dGVyO1xuXHQvLyB0aHJlYWRzOiBNZXJnZTx7XG5cdC8vIFx0ZGVmYXVsdDogVGhyZWFkU3Bhd25lcjtcblx0Ly8gfSwgUmVjb3JkPFRocmVhZElkLCBUaHJlYWRTcGF3bmVyPj47XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNldF96aW5kZXhfcmVsYXRpdmVseShkbV9zcmM6IEhUTUxFbGVtZW50LCBkbV9kc3Q6IEhUTUxFbGVtZW50LCBuX29yZGVyOiBudW1iZXIpOiB2b2lkIHtcblx0Y29uc3QgaXpfc3JjID0gK2RtX3NyYy5zdHlsZS56SW5kZXg7XG5cdGNvbnN0IGl6X2RzdCA9IGl6X3NyYyArIG5fb3JkZXI7XG5cdGRtX3NyYy5zdHlsZS56SW5kZXggPSBpel9zcmMrJyc7XG5cdGRtX2RzdC5zdHlsZS56SW5kZXggPSBpel9kc3QrJyc7XG59XG5cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0b3Ige1xuXHRwcm90ZWN0ZWQgX2hfdGhyZWFkczogUGFydGlhbDxSZWNvcmQ8VGhyZWFkSWQsIFRocmVhZD4+ID0ge307XG5cdHByb3RlY3RlZCBfaF90aHJlYWRfc3Bhd25lcnM6IFRocmVhZHNDb25maWc7XG5cdHByb3RlY3RlZCBfZG1fdGhyZWFkczogSFRNTEVsZW1lbnQ7XG5cdC8vIHByb3RlY3RlZCBfYl9tb2RlX3NpbmdsZV90aHJlYWQ/OiBib29sZWFuID0gZmFsc2U7XG5cdC8vIHByb3RlY3RlZCBfa19yb3V0ZXI6IFI7XG5cblx0Ly8gYnVmZmVyIGVsZW1lbnRcblx0cHJvdGVjdGVkIF9kbV9idWZmZXIgPSBkZCgnZGl2Jyk7XG5cblx0Ly8gaG9va3Ncblx0cHJvdGVjdGVkIF9nX2hvb2tzOiBIb29rcztcblxuXHQvLyBjb250ZXh0c1xuXHRwcm90ZWN0ZWQgX2hfY29udGV4dDogUGxhaW5PYmplY3Q7XG5cblx0Ly8gY3VycmVudGx5IGFjdGl2ZSB0aHJlYWQgaWRcblx0cHJvdGVjdGVkIF9zaV90aHJlYWQ6IFRocmVhZElkID0gVGhyZWFkSWQuREVGQVVMVDtcblxuXHQvLyBydW5uaW5nIHotaW5kZXggY291bnRlciBmb3IgbmV3IHRocmVhZHNcblx0cHJvdGVjdGVkIF9jX3RocmVhZF96ID0gMjAwO1xuXG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIF9nY19uYXZpZ2F0b3I6IE5hdmlnYXRvckNvbmZpZykge1xuXHRcdC8vIHRocmVhZCBjb250YWluZXIgZG9tXG5cdFx0KHtcblx0XHRcdGNvbnRhaW5lcjogdGhpcy5fZG1fdGhyZWFkcyxcblx0XHRcdHRocmVhZHM6IHRoaXMuX2hfdGhyZWFkX3NwYXduZXJzLFxuXHRcdFx0aG9va3M6IHRoaXMuX2dfaG9va3MsXG5cdFx0XHRjb250ZXh0OiB0aGlzLl9oX2NvbnRleHQ9e30sXG5cdFx0XHQvLyByb3V0ZXI6IHRoaXMuX2tfcm91dGVyLFxuXHRcdFx0Ly8gc2luZ2xlVGhyZWFkTW9kZTogdGhpcy5fYl9tb2RlX3NpbmdsZV90aHJlYWQ9ZmFsc2UsXG5cdFx0fSA9IF9nY19uYXZpZ2F0b3IpO1xuXG5cdFx0Ly8gY3JlYXRlIGRlZmF1bHQgdGhyZWFkXG5cdFx0dGhpcy5fbmV3X3RocmVhZChUaHJlYWRJZC5ERUZBVUxUKTtcblx0fVxuXG5cdGdldCBjb250ZXh0KCk6IFBsYWluT2JqZWN0IHtcblx0XHRyZXR1cm4gdGhpcy5faF9jb250ZXh0O1xuXHR9XG5cblx0cHJpdmF0ZSBfbmV3X3RocmVhZChzaV90aHJlYWQ6IFRocmVhZElkLCBoX3Byb3BzOiBEaWN0PHVua25vd24+PXt9LCBoX2NvbnRleHQ6IFBsYWluT2JqZWN0PXt9KTogVGhyZWFkIHtcblx0XHQvLyBubyBzdWNoIHRocmVhZCBzcGF3bmVyXG5cdFx0Y29uc3QgZl9zcGF3bmVyID0gdGhpcy5faF90aHJlYWRfc3Bhd25lcnNbc2lfdGhyZWFkXTtcblx0XHRpZighZl9zcGF3bmVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYE5hdmlnYXRvciBoYXMgbm8gc3VjaCB0aHJlYWQgcmVnaXN0ZXJlZDogJyR7c2lfdGhyZWFkfSdgKTtcblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgbmV3IHRocmVhZFxuXHRcdGNvbnN0IGt0X25ldyA9IG5ldyBUaHJlYWQoc2lfdGhyZWFkLCBmX3NwYXduZXIoaF9wcm9wcywgaF9jb250ZXh0KSwgdGhpcyk7XG5cblx0XHQvLyBzYXZlIHRvIHRocmVhZHNcblx0XHR0aGlzLl9oX3RocmVhZHNbc2lfdGhyZWFkXSA9IGt0X25ldztcblxuXHRcdC8vIGFwcGVuZCB0aHJlYWQgdG8gY29udGFpbmVyXG5cdFx0dGhpcy5fZG1fdGhyZWFkcy5hcHBlbmRDaGlsZChrdF9uZXcuZG9tKTtcblxuXHRcdC8vIGNyZWF0ZSBuZXcgZGVmYXVsdCBwYWdlIGFuZCBtZXJnZSBwcm9wc1xuXHRcdGt0X25ldy5yZXNldCh7XG5cdFx0XHQuLi5rdF9uZXcuZGVmYXVsdCxcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdC4uLmt0X25ldy5kZWZhdWx0LnByb3BzLFxuXHRcdFx0XHQuLi5oX3Byb3BzLFxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdC8vIHJldHVybiBuZXcgdGhyZWFkXG5cdFx0cmV0dXJuIGt0X25ldztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRocmVhZC5cblx0ICovXG5cdGdldCBhY3RpdmVUaHJlYWQoKTogVGhyZWFkIHtcblx0XHRyZXR1cm4gdGhpcy5faF90aHJlYWRzW3RoaXMuX3NpX3RocmVhZF0hO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnRseSBhY3RpdmUgcGFnZS5cblx0ICovXG5cdGdldCBhY3RpdmVQYWdlKCk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLmFjdGl2ZVRocmVhZC5wYWdlO1xuXHR9XG5cblx0Ly8gLyoqXG5cdC8vICAqIFB1c2hlcyBhIG5ldyBwYWdlIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRocmVhZC5cblx0Ly8gICovXG5cdC8vIHB1c2goZ2NfcGFnZTogUGFnZUNvbmZpZyk6IFBhZ2Uge1xuXHQvLyBcdC8vIHJlZiBjdXJyZW50IChzb29uIHRvIGJlIG9sZCkgcGFnZVxuXHQvLyBcdGNvbnN0IGtwX29sZCA9IHRoaXMuYWN0aXZlUGFnZTtcblxuXHQvLyBcdC8vIGNyZWF0ZSBuZXcgcGFnZVxuXHQvLyBcdGNvbnN0IGtwX25ldyA9IHRoaXMuYWN0aXZlVGhyZWFkLnB1c2goZ2NfcGFnZSk7XG5cblx0Ly8gXHQvLyAvLyBjYWxsIGhvb2tzXG5cdC8vIFx0Ly8gdGhpcy5fZl9wdXNoKGtwX29sZCwga3BfbmV3KTtcblx0Ly8gXHQvLyB0aGlzLl9hcnJpdmUoa3Bfb2xkLCAnJywgJ3B1c2gnKTtcblxuXHQvLyBcdC8vIHJldHVybiBuZXcgcGFnZVxuXHQvLyBcdHJldHVybiBrcF9uZXc7XG5cdC8vIH1cblxuXHQvLyAvKipcblx0Ly8gICogUG9wcyB0aGUgYWN0aXZlIHBhZ2UgZnJvbSB0aGUgc3RhY2suXG5cdC8vICAqL1xuXHQvLyBwb3AoZ2NfcG9wPzogUG9wQ29uZmlnKTogUGFnZSB7XG5cdC8vIFx0Ly8gZGVzdHJ1Y3R1cmUgb3B0aW9uc1xuXHQvLyBcdGNvbnN0IHtcblx0Ly8gXHRcdGJ5cGFzc0FuaW1hdGlvbjogYl9ieXBhc3NfYW5pbWF0aW9uPWZhbHNlLFxuXHQvLyBcdH0gPSBnY19wb3AgfHwge307XG5cblx0Ly8gXHQvLyB0b28gc2hvcnRcblx0Ly8gXHRpZih0aGlzLmFjdGl2ZVRocmVhZC5oaXN0b3J5Lmxlbmd0aCA8IDIpIHtcblx0Ly8gXHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBvcCBlbXB0eSBoaXN0b3J5YCk7XG5cdC8vIFx0fVxuXG5cdC8vIFx0Ly8gcG9wIGZyb20gZnJvbnQgb2Ygc3RhY2tcblx0Ly8gXHRjb25zdCBrcF9zcmMgPSB0aGlzLmFjdGl2ZVRocmVhZC5wb3AoKTtcblxuXHQvLyBcdC8vIC8vIGVtcHR5IGhpc3Rvcnlcblx0Ly8gXHQvLyBpZigha3Nfc3JjKSB7XG5cdC8vIFx0Ly8gXHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwb3AgZW1wdHkgaGlzdG9yeWApO1xuXHQvLyBcdC8vIH1cblxuXHQvLyBcdC8vIC8vIGNhbGwgaG9va3Ncblx0Ly8gXHQvLyB0aGlzLl9mX3BvcChrcF9zcmMsIHRoaXMuc3RhdGUsIGJfYnlwYXNzX2FuaW1hdGlvbik7XG5cdC8vIFx0Ly8gdGhpcy5fYXJyaXZlKGtwX3NyYywgJycsIGJfYnlwYXNzX2FuaW1hdGlvbj8gJ3BvcC5ieXBhc3MnOiAncG9wJykudGhlbigoKSA9PiB7XG5cdC8vIFx0Ly8gXHR0cnkge1xuXHQvLyBcdC8vIFx0XHRrcF9zcmMuY29tcG9uZW50LiRkZXN0cm95KCk7XG5cdC8vIFx0Ly8gXHR9XG5cdC8vIFx0Ly8gXHRjYXRjaChlX2Rlc3Ryb3kpIHtcblx0Ly8gXHQvLyBcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGRlc3Ryb3kgc3RhbGUgY29tcG9uZW50IGJlbG9uZ2luZyB0byBTdGF0ZTogJHtrcF9zcmMucGF0dGVybn1gKTtcblx0Ly8gXHQvLyBcdH1cblx0Ly8gXHQvLyB9KTtcblxuXHQvLyBcdC8vIHJldHVybiBvbGQgcGFnZVxuXHQvLyBcdHJldHVybiBrcF9zcmM7XG5cdC8vIH1cblxuXG5cdGJlZm9yZV9wdXNoKGdjX3BhZ2U6IFBhZ2VDb25maWcsIGtwX3NyYzogUGFnZSwga3RfY2hpbGQ6IFRocmVhZCk6IGJvb2xlYW4ge1xuXHRcdC8vIG5vdCBhY3RpdmUgdGhyZWFkOyBkZW55XG5cdFx0aWYodGhpcy5hY3RpdmVUaHJlYWQgIT09IGt0X2NoaWxkKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBjYWxsIHByZXB1c2ggaG9va3Ncblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfY2hhbmdlPy4oa3RfY2hpbGQsIGtwX3NyYywgJ3B1c2gnKSkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9wdXNoPy4oa3RfY2hpbGQsIGtwX3NyYywgZ2NfcGFnZSkpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vIGFwcHJvdmVkXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXG5cdGJlZm9yZV9wb3AoZ2NfcG9wOiBQb3BDb25maWcsIGtwX2RzdDogUGFnZSwga3Bfc3JjOiBQYWdlLCBrdF9jaGlsZDogVGhyZWFkKTogYm9vbGVhbiB7XG5cdFx0Ly8gbm90IGFjdGl2ZSB0aHJlYWQ7IGRlbnlcblx0XHRpZih0aGlzLmFjdGl2ZVRocmVhZCAhPT0ga3RfY2hpbGQpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vIGNhbGwgcHJlcHVzaCBob29rc1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9jaGFuZ2U/LihrdF9jaGlsZCwga3Bfc3JjLCAncG9wJykpIHJldHVybiBmYWxzZTtcblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfcG9wPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0LCBnY19wb3ApKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBhcHByb3ZlZFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0YmVmb3JlX2p1bXAoZ2NfanVtcDogSnVtcENvbmZpZywgZ2NfcGFnZTogUGFnZUNvbmZpZywga3Bfc3JjOiBQYWdlLCBrdF9jaGlsZDogVGhyZWFkKTogYm9vbGVhbiB7XG5cdFx0Ly8gbm90IGFjdGl2ZSB0aHJlYWQ7IGRlbnlcblx0XHRpZih0aGlzLmFjdGl2ZVRocmVhZCAhPT0ga3RfY2hpbGQpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vIGNhbGwgcHJlanVtcCBob29rc1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9jaGFuZ2U/LihrdF9jaGlsZCwga3Bfc3JjLCAnanVtcCcpKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYoZmFsc2UgPT09IHRoaXMuX2dfaG9va3MuYmVmb3JlX2p1bXA/LihrdF9jaGlsZCwga3Bfc3JjLCBnY19wYWdlLCBnY19qdW1wKSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Ly8gYXBwcm92ZWRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jIGJlZm9yZV9zd2l0Y2goa3Rfc3JjOiBUaHJlYWQsIHNpX3RocmVhZDogVGhyZWFkSWQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfY2hhbmdlPy4oa3Rfc3JjLCBrdF9zcmMucGFnZSwgJ3N3aXRjaCcpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdG9wIHRocmVhZCBzd2l0Y2gnKTtcblxuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYmVmb3JlX3N3aXRjaD8uKGt0X3NyYywgc2lfdGhyZWFkKTtcblx0fVxuXG5cdGFzeW5jIGFmdGVyX3B1c2goa3RfY2hpbGQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBrcF9kc3Q6IFBhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBoX2V4dHJhID0gYXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9wdXNoPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0KTtcblxuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfY2hhbmdlPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0LCAncHVzaCcsIGhfZXh0cmEgfHwge30pO1xuXHR9XG5cblx0YXN5bmMgYWZ0ZXJfcG9wKGt0X2NoaWxkOiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19wb3A6IFBvcENvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGhfZXh0cmEgPSBhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX3BvcD8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCwgZ2NfcG9wKTtcblxuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfY2hhbmdlPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0LCAncG9wJywgaF9leHRyYSB8fCB7fSk7XG5cdH1cblxuXHRhc3luYyBhZnRlcl9qdW1wKGt0X2NoaWxkOiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19qdW1wOiBKdW1wQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgaF9leHRyYSA9IGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfanVtcD8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCwgZ2NfanVtcCk7XG5cblx0XHRhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX2NoYW5nZT8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCwgJ2p1bXAnLCBoX2V4dHJhIHx8IHt9KTtcblx0fVxuXG5cdGFzeW5jIGFmdGVyX3Jlc2V0KGt0X2NoaWxkOiBUaHJlYWQsIGtwX2RzdDogUGFnZSwgZ2NfcmVzZXQ6IFJlc2V0Q29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgaF9leHRyYSA9IGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfcmVzZXQ/LihrdF9jaGlsZCwga3BfZHN0LCBnY19yZXNldCk7XG5cblx0XHRhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX2NoYW5nZT8uKGt0X2NoaWxkLCBudWxsLCBrcF9kc3QsICdyZXNldCcsIGhfZXh0cmEgfHwge30pO1xuXHR9XG5cblx0YXN5bmMgYWZ0ZXJfc3dpdGNoKGt0X3NyYzogVGhyZWFkLCBrdF9kc3Q6IFRocmVhZCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfc3dpdGNoPy4oa3Rfc3JjLCBrdF9kc3QpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFjdGl2YXRlcyBhIHRocmVhZCBieSB0aGUgZ2l2ZW4gdGhyZWFkIGlkLlxuXHQgKi9cblx0YXN5bmMgYWN0aXZhdGVUaHJlYWQoc2lfdGhyZWFkOiBUaHJlYWRJZCwgaF9wcm9wczogUGxhaW5PYmplY3Q9e30pOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHQvLyByZWYgY3VycmVudCB0aHJlYWRcblx0XHRjb25zdCBrdF9zcmMgPSB0aGlzLmFjdGl2ZVRocmVhZDtcblxuXHRcdC8vIHJlZiBwcmV2aW91cyBwYWdlXG5cdFx0Y29uc3Qga3Bfc3JjID0gdGhpcy5hY3RpdmVQYWdlO1xuXG5cdFx0Ly8gbG9va3VwIGV4aXN0aW5nIHRocmVhZFxuXHRcdGxldCBrdF9kc3QgPSB0aGlzLl9oX3RocmVhZHNbc2lfdGhyZWFkXTtcblxuXHRcdC8vIHRocmVhZCBjaGFuZ2Vcblx0XHRpZihzaV90aHJlYWQgIT09IHRoaXMuX3NpX3RocmVhZCkge1xuXHRcdFx0Ly8gLy8gc2luZ2xlIHRocmVhZCBtb2RlOyBhYm9ydFxuXHRcdFx0Ly8gaWYodGhpcy5fYl9tb2RlX3NpbmdsZV90aHJlYWQpIHtcblx0XHRcdC8vIFx0dGhyb3cgbmV3IEVycm9yKGBOYXZpZ2F0b3Igb3BlcmF0aW5nIGluIHNpbmdsZSB0aHJlYWQgbW9kZSByZWZ1c2luZyB0byBhY3RpdmF0ZSB0aGVhZCAnJHtzaV90aHJlYWR9Jy5gKTtcblx0XHRcdC8vIH1cblxuXHRcdFx0Ly8gY2FsbCBwcmVzd2l0Y2ggaG9va3Ncblx0XHRcdGF3YWl0IHRoaXMuYmVmb3JlX3N3aXRjaChrdF9zcmMsIHNpX3RocmVhZCk7XG5cblx0XHRcdC8vIHByZXYgdGhyZWFkXG5cdFx0XHRjb25zdCBzaV90aHJlYWRfcHJldiA9IHRoaXMuX3NpX3RocmVhZDtcblxuXHRcdFx0Ly8gbm8gZXhpc3RpbmcgdGhyZWFkOyBjcmVhdGUgbmV3IG9uZVxuXHRcdFx0aWYoIWt0X2RzdCkge1xuXHRcdFx0XHRrdF9kc3QgPSB0aGlzLl9uZXdfdGhyZWFkKHNpX3RocmVhZCwgaF9wcm9wcyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBwcm9wcyBkaWZmZXJcblx0XHRcdGVsc2UgaWYob2JqZWN0c19taWdodF9kaWZmZXIoa3RfZHN0LmRlZmF1bHQucHJvcHMgfHwge30sIGhfcHJvcHMpKSB7XG5cdFx0XHRcdC8vIGNyZWF0ZSBuZXcgcGFnZVxuXHRcdFx0XHRjb25zdCBrcF9kc3QgPSBuZXcgUGFnZSh7XG5cdFx0XHRcdFx0Li4ua3RfZHN0LmRlZmF1bHQsXG5cdFx0XHRcdFx0cHJvcHM6IGhfcHJvcHMsXG5cdFx0XHRcdFx0Y29udGV4dDogdGhpcy5faF9jb250ZXh0LFxuXHRcdFx0XHR9LCBrdF9kc3QpO1xuXG5cdFx0XHRcdC8vIHJlc2V0IHRocmVhZCBoaXN0b3J5XG5cdFx0XHRcdGt0X2RzdC5yZXNldChrcF9kc3QsIHtcblx0XHRcdFx0XHRrZWVwVG9wOiB0cnVlLFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBwbGFjZSBpbmNvbWluZyBzdGF0ZSBiZWxvd1xuXHRcdFx0XHRzZXRfemluZGV4X3JlbGF0aXZlbHkoa3Bfc3JjLmRvbSwga3BfZHN0LmRvbSwgLTEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgdGhyZWFkXG5cdFx0XHR0aGlzLl9zaV90aHJlYWQgPSBzaV90aHJlYWQ7XG5cblx0XHRcdC8vIHBsYWNlIHRocmVhZCBpbiBmcm9udFxuXHRcdFx0dGhpcy5hY3RpdmVUaHJlYWQuc2hvdygpO1xuXHRcdFx0dGhpcy5hY3RpdmVUaHJlYWQuZG9tLnN0eWxlLnpJbmRleCA9ICh0aGlzLl9jX3RocmVhZF96KyspKycnO1xuXG5cdFx0XHQvLyAvLyBhcnJpdmVcblx0XHRcdC8vIHRoaXMuX2Fycml2ZShrcF9zcmMsIHNpX3RocmVhZF9wcmV2LCAndGhyZWFkJykudGhlbigoKSA9PiB7XG5cdFx0XHQvLyBcdC8vIC8vIGhpZGUgcHJldmlvdXMgdGhyZWFkXG5cdFx0XHQvLyBcdC8vIGlmKGt0X2RzdCAmJiBrdF9zcmMgJiYga3Rfc3JjICE9PSBrdF9kc3QpIHtcblx0XHRcdC8vIFx0Ly8gXHQvLyBkZWJ1Z2dlcjtcblx0XHRcdC8vIFx0Ly8gXHQvLyBrdF9zcmMuaGlkZSgpO1xuXHRcdFx0Ly8gXHQvLyB9XG5cdFx0XHQvLyB9KTtcblxuXHRcdFx0Ly8gY2FsbCBwb3N0c3dpdGNoIGhvb2tzXG5cdFx0XHRhd2FpdCB0aGlzLmFmdGVyX3N3aXRjaChrdF9zcmMsIGt0X2RzdCk7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHQvLyAvLyBzYW1lIHRocmVhZFxuXHRcdC8vIGVsc2Uge1xuXHRcdC8vIFx0Ly8gdGhyZWFkIGRlZmF1bHQgaXMgcHJldmlvdXMgaW4gaGlzdG9yeVxuXHRcdC8vIFx0ZGVidWdnZXI7XG5cdFx0Ly8gXHRjb25zb2xlLmluZm8oa190aHJlYWQ/LmRlZmF1bHQucGF0aCk7XG5cdFx0Ly8gfVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge1xuXHRcdGdldEFsbENvbnRleHRzLFxuXHRcdG9uTW91bnQsXG5cdFx0dGljayxcblx0fSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCB0eXBlIHsgUGxhaW5PYmplY3QgfSBmcm9tICcjL21ldGEvYmVsdCc7XG5cdGltcG9ydCB7XG5cdFx0b2RlLFxuXHRcdG9kZXJvbSxcblx0XHR0aW1lb3V0LFxuXHR9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXHRpbXBvcnQgT3ZlcnNjcm9sbFN2ZWx0ZSBmcm9tICcuL3N5c3RlbS9PdmVyc2Nyb2xsLnN2ZWx0ZSc7XG5cdGltcG9ydCBQb3B1cFN2ZWx0ZSBmcm9tICcuL3N5c3RlbS9Qb3B1cC5zdmVsdGUnO1xuXHRpbXBvcnQgTmF2U3ZlbHRlIGZyb20gJy4vc3lzdGVtL05hdi5zdmVsdGUnO1xuXHRpbXBvcnQgU2VhcmNoU3ZlbHRlIGZyb20gJy4vc3lzdGVtL1NlYXJjaC5zdmVsdGUnO1xuXHRpbXBvcnQgUHJvZ3Jlc3NTdmVsdGUgZnJvbSAnLi9zeXN0ZW0vUHJvZ3Jlc3Muc3ZlbHRlJztcblx0aW1wb3J0IFNpZGVNZW51U3ZlbHRlIGZyb20gJy4vc3lzdGVtL1NpZGVNZW51LnN2ZWx0ZSc7XG5cdGltcG9ydCBWZW5kb3JNZW51U3ZlbHRlIGZyb20gJy4vc3lzdGVtL1ZlbmRvck1lbnUuc3ZlbHRlJztcblxuXHRpbXBvcnQgQmxhbmtTdmVsdGUgZnJvbSAnIyMvc2NyZWVuL0JsYW5rLnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHR5cGUgeyBQYWdlLCBQYWdlQ29uZmlnIH0gZnJvbSAnIyMvbmF2L3BhZ2UnO1xuXHRpbXBvcnQgdHlwZSB7IFBvcENvbmZpZywgVGhyZWFkIH0gZnJvbSAnIyMvbmF2L3RocmVhZCc7XG5cdGltcG9ydCB7IE5hdmlnYXRvciwgTmF2aWdhdG9yQ29uZmlnIH0gZnJvbSAnIyMvbmF2L25hdmlnYXRvcic7XG5cblx0aW1wb3J0IHsgSF9USFJFQURTIH0gZnJvbSAnIyMvZGVmJztcblx0aW1wb3J0IHsgeXdfYWNjb3VudCwgeXdfYWNjb3VudF9yZWYsIHl3X2NoYWluLCB5d19jaGFpbl9yZWYsIHl3X25hdmlnYXRvciwgeXdfbmF2X3Zpc2libGUsIHl3X25ldHdvcmssIHl3X25ldHdvcmtfYWN0aXZlLCB5d19uZXR3b3JrX3JlZiwgeXdfcGFnZSwgeXdfdGhyZWFkIH0gZnJvbSAnIyMvbWVtJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQgeyBvbmNlX3N0b3JlX3VwZGF0ZXMgfSBmcm9tICcuLi9zdmVsdGUnO1xuXHRpbXBvcnQgeyBOZXR3b3JrcyB9IGZyb20gJyMvc3RvcmUvbmV0d29ya3MnO1xuXHRpbXBvcnQgeyBWYXVsdCB9IGZyb20gJyMvY3J5cHRvL3ZhdWx0JztcblxuXHRleHBvcnQgbGV0IHBhZ2U6IFBhZ2VDb25maWc7XG5cdGNvbnN0IGdjX3BhZ2UgPSBwYWdlO1xuXG5cdGV4cG9ydCBsZXQgbW9kZTogJ2FwcCcgfCAnZmxvdyc7XG5cdGNvbnN0IGJfZmxvdyA9ICdmbG93JyA9PT0gbW9kZTtcblx0Y29uc3QgYl9tYWluID0gJ2FwcCcgPT09IG1vZGU7XG5cblx0bGV0IGRtX3ZpZXdwb3J0OiBIVE1MRWxlbWVudDtcblx0bGV0IGRtX3RocmVhZHM6IEhUTUxFbGVtZW50O1xuXHRsZXQgZG1fY29udGVudDogSFRNTEVsZW1lbnQ7XG5cdGxldCBkbV9leGl0dGluZzogSFRNTEVsZW1lbnQ7XG5cblx0Ly8gZ2V0IGFsbCBjb250ZXh0c1xuXHRjb25zdCBoX2NvbnRleHRfYWxsID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldEFsbENvbnRleHRzKCkuZW50cmllcygpKTtcblxuXHRhc3luYyBmdW5jdGlvbiBzbGlkZShkbV9zbGlkZTogSFRNTEVsZW1lbnQsIGJfaW49ZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHQvLyBzbW9vdGhlciwgYWxsb3cgZm9yIHByZXZpb3VzIG1vZHMgdG8gbWFrZSBlbGVtZW50IHZpc2libGVcblx0XHRhd2FpdCB0aW1lb3V0KDApO1xuXG5cdFx0Ly8gZ28gYXN5bmNcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKGZrX3Jlc29sdmUpID0+IHtcblx0XHRcdC8vIHdhaXQgZm9yIHRyYW5zaXRpb24gdG8gY29tcGxldGVcblx0XHRcdGRtX3NsaWRlLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiB0cmFuc2l0aW9uX2VuZChkX2V2ZW50KSB7XG5cdFx0XHRcdGlmKCd0cmFuc2Zvcm0nID09PSBkX2V2ZW50LnByb3BlcnR5TmFtZSkge1xuXHRcdFx0XHRcdC8vIGNoYW5nZSBjbGFzc1xuXHRcdFx0XHRcdGRtX3NsaWRlLmNsYXNzTGlzdC5hZGQoJ3NsaWQnKTtcblxuXHRcdFx0XHRcdGZrX3Jlc29sdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIGFwcGx5IHRyYW5zZm9ybVxuXHRcdFx0ZG1fc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHtiX2luPyAnMHB4JzogJ3ZhcigtLWFwcC13aW5kb3ctd2lkdGgpJ30pYDtcblx0XHR9KTtcblx0fVxuXG5cdG9uTW91bnQoYXN5bmMoKSA9PiB7XG5cdFx0Ly8gbmF2aWdhdG9yIGNvbmZpZ1xuXHRcdGNvbnN0IGdjX25hdmlnYXRvcjogTmF2aWdhdG9yQ29uZmlnID0ge1xuXHRcdFx0Ly8gdGhyZWFkcyBjb250YWluZXJcblx0XHRcdGNvbnRhaW5lcjogZG1fdGhyZWFkcyxcblxuXHRcdFx0Ly8gZm9yd2FyZCBhbGwgY29udGV4dHNcblx0XHRcdGNvbnRleHQ6IGhfY29udGV4dF9hbGwsXG5cblx0XHRcdC8vIGRlZmF1bHQgdGhyZWFkcyBjb25maWdcblx0XHRcdHRocmVhZHM6IHtcblx0XHRcdFx0ZGVmYXVsdDogKCkgPT4gKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBCbGFua1N2ZWx0ZSxcblx0XHRcdFx0fSksXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBkZWZhdWx0IGhvb2tzXG5cdFx0XHRob29rczoge1xuXHRcdFx0XHRiZWZvcmVfY2hhbmdlKGt0X2NvbnRleHQsIGtwX3NyYywga3BfZHN0KSB7XG5cdFx0XHRcdFx0Ly8gYmx1ciBvbiBwYWdlXG5cdFx0XHRcdFx0dm9pZCBrcF9zcmMuZmlyZSgnYmx1cicpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIG9uY2UgYSBuZXcgcGFnZSBoYXMgYmVlbiBwdXNoZWRcblx0XHRcdFx0YWZ0ZXJfcHVzaChrdF9jb250ZXh0LCBrcF9zcmMsIGtwX2RzdCkge1xuXHRcdFx0XHRcdC8vIC8vIHB1c2ggc3RhdGUgdG8gbmF2aWdhdG9yIGhpc3Rvcnlcblx0XHRcdFx0XHQvLyBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCAnJywgJyNwYWdlOicra3BfZHN0LmlkKTtcblxuXHRcdFx0XHRcdC8vIHdhaXQgZm9yIHN2ZWx0ZSB0byByZW5kZXIgY29tcG9uZW50IGJlZm9yZSBxdWVyeWluZyBjb250YWluZXJcblx0XHRcdFx0XHR2b2lkIHRpY2soKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRcdC8vIHF1ZXJ5IGNvbnRhaW5lciBmb3IgbGFzdCBlbGVtZW50IGNoaWxkXG5cdFx0XHRcdFx0XHR2b2lkIHNsaWRlKGtwX2RzdC5kb20sIHRydWUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIG9uY2UgYSBwYWdlIGhhcyBiZWVuIHBvcHBlZFxuXHRcdFx0XHRhZnRlcl9wb3Aoa3RfY29udGV4dCwga3Bfc3JjLCBrcF9kc3QsIGdjX3BvcCkge1xuXHRcdFx0XHRcdC8vIG5vdGlmeSBkc3QgcGFnZVxuXHRcdFx0XHRcdHZvaWQga3BfZHN0LmZpcmUoJ3Jlc3RvcmUnKTtcblxuXHRcdFx0XHRcdC8vIGRvIG5vdCBieXBhc3MgYW5pbWF0aW9uXG5cdFx0XHRcdFx0aWYoIWdjX3BvcC5ieXBhc3NBbmltYXRpb24pIHtcblx0XHRcdFx0XHRcdC8vIGFwcGx5IHRyYW5zbGF0aW9uIHRyYW5zZm9ybSB0byBzcmMgcGFnZVxuXHRcdFx0XHRcdFx0a3Bfc3JjLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCh2YXIoLS1hcHAtd2luZG93LXdpZHRoKSlgO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyB1cG9uIGFueSBwYWdlIGNoYW5nZVxuXHRcdFx0XHRhZnRlcl9jaGFuZ2Uoa3RfY29udGV4dCwga3Bfc3JjLCBrcF9kc3QsIHNfdHJhbnNpdGlvbiwgaF9leHRyYT17fSkge1xuXHRcdFx0XHRcdC8vIHNldCBnbG9iYWwgcGFnZSBhbmQgdGhyZWFkXG5cdFx0XHRcdFx0JHl3X3BhZ2UgPSBrcF9kc3Q7XG5cdFx0XHRcdFx0JHl3X3RocmVhZCA9IGt0X2NvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBub3RpZnkgZHN0IHBhZ2Vcblx0XHRcdFx0XHR2b2lkIGtwX2RzdC5maXJlKCdmb2N1cycpO1xuXG5cdFx0XHRcdFx0Ly8gLy8gbWFpbnRhaW4gc2Nyb2xsVG9wIG9mIHRoZSBzcmMgcGFnZVxuXHRcdFx0XHRcdC8vIGNvbnN0IHhfc2Nyb2xsX3RvcCA9IGtwX3NyYy5kb20uc2Nyb2xsVG9wO1xuXG5cdFx0XHRcdFx0Ly8gZGVidWdnZXI7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0YXN5bmMgYmVmb3JlX3N3aXRjaCgpIHtcblx0XHRcdFx0XHQvLyBhbGxvdyB0aGVzZSB0byBmYWlsIGluIG9yZGVyIHRvIHJlY292ZXIgZnJvbSBkaXNhc3RlcnNcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Ly8gc2V0IGRlZmF1bHRzXG5cdFx0XHRcdFx0XHRhd2FpdCBQcm9taXNlLmFsbChbXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmF1bHQgY2hhaW5cblx0XHRcdFx0XHRcdFx0JHl3X2NoYWluIHx8IG9uY2Vfc3RvcmVfdXBkYXRlcyh5d19jaGFpbiwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdENoYWlucy5yZWFkKCkudGhlbihrcyA9PiAkeXdfY2hhaW5fcmVmID0gb2RlKGtzLnJhdylbMF1bMF0pLFxuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmF1bHQgbmV0d29ya1xuXHRcdFx0XHRcdFx0XHQkeXdfbmV0d29ya19hY3RpdmUgfHwgb25jZV9zdG9yZV91cGRhdGVzKHl3X25ldHdvcmtfYWN0aXZlLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0TmV0d29ya3MucmVhZCgpLnRoZW4oa3MgPT4gJHl3X25ldHdvcmtfcmVmID0gb2RlKGtzLnJhdylbMF1bMF0pLFxuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmF1bHQgYWNjb3VudFxuXHRcdFx0XHRcdFx0XHQkeXdfYWNjb3VudCB8fCBvbmNlX3N0b3JlX3VwZGF0ZXMoeXdfYWNjb3VudCwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdEFjY291bnRzLnJlYWQoKS50aGVuKGtzID0+ICR5d19hY2NvdW50X3JlZiA9IG9kZShrcy5yYXcpWzBdWzBdKSxcblx0XHRcdFx0XHRcdF0pO1xuXG5cdFx0XHRcdFx0XHQvLyBvbmx5IG5lZWRzIHRvIGhhcHBlbiBvbmNlXG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5iZWZvcmVfc3dpdGNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaChlX2xvYWRfZGVmYXVsdCkge1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coZV9sb2FkX2RlZmF1bHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRhc3luYyBhZnRlcl9zd2l0Y2goa3Rfc3JjLCBrdF9kc3QpIHtcblx0XHRcdFx0XHQvLyBzZXQgZ2xvYmFsIHBhZ2UgYW5kIHRocmVhZFxuXHRcdFx0XHRcdCR5d19wYWdlID0ga3RfZHN0LnBhZ2U7XG5cdFx0XHRcdFx0JHl3X3RocmVhZCA9IGt0X2RzdDtcblxuXHRcdFx0XHRcdC8vIGZvY3VzIG9uIHBhZ2Vcblx0XHRcdFx0XHR2b2lkIGt0X2RzdC5wYWdlLmZpcmUoJ2ZvY3VzJyk7XG5cblx0XHRcdFx0XHQvLyB3YWl0IGZvciBzdmVsdGUgdG8gcmVuZGVyIGNvbXBvbmVudCBiZWZvcmUgcXVlcnlpbmcgY29udGFpbmVyXG5cdFx0XHRcdFx0YXdhaXQgdGljaygpO1xuXG5cdFx0XHRcdFx0Ly8gcXVlcnkgY29udGFpbmVyIGZvciBsYXN0IGVsZW1lbnQgY2hpbGRcblx0XHRcdFx0XHRhd2FpdCBzbGlkZShrdF9kc3QucGFnZS5kb20sIHRydWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0Ly8gc3BlY2lmaWMgcGFnZSBnaXZlblxuXHRcdGlmKGJfZmxvdykge1xuXHRcdFx0Ly8gb3ZlcnJpZGUgdGhyZWFkcyBjb25maWdcblx0XHRcdGdjX25hdmlnYXRvci50aHJlYWRzID0ge1xuXHRcdFx0XHRkZWZhdWx0OiAoKSA9PiBnY19wYWdlLFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0Ly8gbWFpbiBzeXN0ZW1cblx0XHRlbHNlIGlmKGJfbWFpbikge1xuXHRcdFx0Ly8gb3ZlcnJpZGUgdGhyZWFkcyBjb25maWdcblx0XHRcdGdjX25hdmlnYXRvci50aHJlYWRzID0gb2Rlcm9tKEhfVEhSRUFEUywgKHNpX3RocmVhZCwgZGNfc2NyZWVuKSA9PiB7XG5cdFx0XHRcdC8vIC8vIGxvb2t1cCByb3V0ZXIgbm9kZSBjb3JyZXNwb25kaW5nIHRvIHNjcmVlbiBjbGFzc1xuXHRcdFx0XHQvLyBjb25zdCBrX25vZGUgPSBLX1JPVVRFUi5sb29rdXBfc2NyZWVuKGRjX3NjcmVlbik7XG5cblx0XHRcdFx0Ly8gLy8gcmVmIHBhdGggcGF0dGVyblxuXHRcdFx0XHQvLyBjb25zdCBzeF9wYXR0ZXJuID0ga19ub2RlLnBhdGhfcGF0dGVybjtcblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFtzaV90aHJlYWRdOiAoaF9wcm9wczogUGxhaW5PYmplY3QpID0+ICh7XG5cdFx0XHRcdFx0XHRjcmVhdG9yOiBkY19zY3JlZW4sXG5cdFx0XHRcdFx0XHRwcm9wczogaF9wcm9wcyxcblx0XHRcdFx0XHRcdC8vIHBhdGg6IGtfbm9kZS5yZXZlcnNlX3Jlc29sdmUoaF9wcm9wcyksXG5cdFx0XHRcdFx0XHQvLyBwYXR0ZXJuOiBzeF9wYXR0ZXJuLFxuXHRcdFx0XHRcdFx0Ly8gc2NyZWVuOiBkY19zY3JlZW4sXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdH0gYXMgUmVjb3JkPHR5cGVvZiBzaV90aHJlYWQsIChoX3Byb3BzOiBQbGFpbk9iamVjdCkgPT4gUGFnZUNvbmZpZz47XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gc2V0IGluaXRcblx0XHRcdGdjX25hdmlnYXRvci50aHJlYWRzLmluaXQgPSAoaF9wcm9wczogUGxhaW5PYmplY3QsIGhfY29udGV4dD86IFBsYWluT2JqZWN0KSA9PiAoe1xuXHRcdFx0XHQuLi5nY19wYWdlLFxuXHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdC4uLmdjX3BhZ2UucHJvcHMsXG5cdFx0XHRcdFx0Li4uaF9wcm9wcyxcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29udGV4dDoge1xuXHRcdFx0XHRcdC4uLmdjX3BhZ2UuY29udGV4dCxcblx0XHRcdFx0XHQuLi5oX2NvbnRleHQsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRjb25zdCBrX25hdmlnYXRvciA9IG5ldyBOYXZpZ2F0b3IoZ2NfbmF2aWdhdG9yKTtcblx0XHQkeXdfbmF2aWdhdG9yID0ga19uYXZpZ2F0b3I7XG5cblxuXG5cdFx0Ly8gaGFuZGxlIHBvcCBzdGF0ZVxuXHRcdC8vIHdpbmRvdy5vbnBvcHN0YXRlID0gZnVuY3Rpb24oZF9ldmVudDogUG9wU3RhdGVFdmVudCkge1xuXHRcdC8vIFx0a19uYXZpZ2F0b3IuYWN0aXZlUGFnZS5wb3Aoe1xuXHRcdC8vIFx0XHRleHRlcm5hbDogdHJ1ZSxcblx0XHQvLyBcdH0pO1xuXHRcdC8vIH07XG5cblx0XHQvLyAkeXdfZXhpdHRpbmdfZG9tID0gZG1fZXhpdHRpbmc7XG5cblx0XHQvLyBjb25zdCBrX3N0YXRlX3Jvb3QgPSBuZXcgU3RhdGUoJy9sb2NrZWQnLCBudWxsIGFzIHVua25vd24gYXMgU3ZlbHRlQ29tcG9uZW50LCAnL2xvY2tlZCcpO1xuXHRcdC8vIGNvbnN0IGtfdGhyZWFkX3Jvb3QgPSBuZXcgU3RhdGVUaHJlYWQoa19zdGF0ZV9yb290KTtcblxuXHQvLyBcdGluaXRpYWxpemUobmV3IFN0YXRlTWFuYWdlcih7XG5cdC8vIFx0XHRyb3V0ZXI6IEtfUk9VVEVSLFxuXG5cdC8vIFx0XHRhcnJpdmUodGhpczogU3RhdGVNYW5hZ2VyLCBrc19zcmM6IFN0YXRlLCBrc19kc3Q6IFN0YXRlLCBzaV90aHJlYWRfc3JjOiBzdHJpbmcsIHNfdHJhbnNpdGlvbj0nJyk6IFByb21pc2U8dm9pZD4ge1xuXHQvLyBcdFx0XHQvLyBtYWludGFpbiBzY3JvbGxUb3Bcblx0Ly8gXHRcdFx0Y29uc3QgeF9zY3JvbGxfdG9wID0ga3Nfc3JjLmRvbS5zY3JvbGxUb3A7XG5cblx0Ly8gXHRcdFx0Y29uc29sZS5sb2coe1xuXHQvLyBcdFx0XHRcdHR5cGU6ICdhcnJpdmUnLFxuXHQvLyBcdFx0XHRcdGtzX3NyYyxcblx0Ly8gXHRcdFx0XHRrc19kc3QsXG5cdC8vIFx0XHRcdFx0c2lfdGhyZWFkX3NyYyxcblx0Ly8gXHRcdFx0XHRzX3RyYW5zaXRpb24sXG5cdC8vIFx0XHRcdH0pO1xuXG5cdC8vIFx0XHRcdC8vIG5ldyBNdXRhdGlvbk9ic2VydmVyKChtKSA9PiB7XG5cdC8vIFx0XHRcdC8vIFx0ZGVidWdnZXI7XG5cdC8vIFx0XHRcdC8vIH0pLm9ic2VydmUoa3Nfc3JjLmRvbSwge1xuXHQvLyBcdFx0XHQvLyBcdGF0dHJpYnV0ZXM6IHRydWUsXG5cdC8vIFx0XHRcdC8vIFx0Y2hpbGRMaXN0OiB0cnVlLFxuXHQvLyBcdFx0XHQvLyB9KTtcblxuXHQvLyBcdFx0XHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoa3Nfc3JjLmRvbSwgJ3Njcm9sbFRvcCcsIHtcblx0Ly8gXHRcdFx0Ly8gXHRnZXQoKSB7XG5cdC8vIFx0XHRcdC8vIFx0XHRyZXR1cm4geF9zY3JvbGxfdG9wO1xuXHQvLyBcdFx0XHQvLyBcdH0sXG5cdC8vIFx0XHRcdC8vIFx0c2V0KHhfdG86IG51bWJlcikge1xuXHQvLyBcdFx0XHQvLyBcdFx0Y29uc29sZS5sb2coYFNFVCBUTzogJHt4X3RvfWApO1xuXHQvLyBcdFx0XHQvLyBcdFx0ZGVidWdnZXI7XG5cdC8vIFx0XHRcdC8vIFx0fSxcblx0Ly8gXHRcdFx0Ly8gfSk7XG5cblx0Ly8gXHRcdFx0Ly8gbmV1dGVyIHNyYyBmcmFtZVxuXHQvLyBcdFx0XHRrc19zcmMuZG9tLmNsYXNzTGlzdC5hZGQoJ2Zyb3plbicpO1xuXG5cdC8vIFx0XHRcdC8vIGVuc3VyZSBpbmNvbWluZyBmcmFtZSBpcyBub3QgZnJvemVuXG5cdC8vIFx0XHRcdGtzX2RzdC5kb20uY2xhc3NMaXN0LnJlbW92ZSgnZnJvemVuJyk7XG5cblx0Ly8gXHRcdFx0Y29uc3QgZ2NfcGFyYW1zID0geXdfcGFyYW1zLmdldCgpO1xuXHQvLyBcdFx0XHQvLyBjb25zdCBnY19wYXJhbXMgPSB7fTtcblxuXHQvLyBcdFx0XHQkeXdfcGF0aCA9IGtzX2RzdC5wYXRoO1xuXHQvLyBcdFx0XHQkeXdfcGF0dGVybiA9IGtzX2RzdC5wYXR0ZXJuO1xuXG5cdC8vIFx0XHRcdGNvbnN0IGdjX3Byb3BzID0ga3NfZHN0LnByb3BzO1xuXG5cdC8vIFx0XHRcdCR5d19wYXJhbXMgPSB7XG5cdC8vIFx0XHRcdFx0ZmFtaWx5SWQ6IGdjX3Byb3BzLmZhbWlseUlkIGFzIHN0cmluZyB8fCBnY19wYXJhbXMuZmFtaWx5SWQsXG5cdC8vIFx0XHRcdFx0Y2hhaW5JZDogZ2NfcHJvcHMuY2hhaW5JZCBhcyBzdHJpbmcgfHwgZ2NfcGFyYW1zLmNoYWluSWQsXG5cdC8vIFx0XHRcdFx0YWNjb3VudElkOiBnY19wcm9wcy5hY2NvdW50SWQgYXMgc3RyaW5nIHx8IGdjX3BhcmFtcy5hY2NvdW50SWQsXG5cdC8vIFx0XHRcdH07XG5cblx0Ly8gXHRcdFx0aWYoZ2NfcHJvcHMuZmFtaWx5SWQpIHtcblx0Ly8gXHRcdFx0XHRjb25zdCBwX2ZhbWlseSA9IEZhbWlseS5yZWZGcm9tSWQoZ2NfcHJvcHMuZmFtaWx5SWQgYXMgc3RyaW5nKTtcblx0Ly8gXHRcdFx0XHRpZighSF9GQU1JTElFU1twX2ZhbWlseV0pIGRlYnVnZ2VyO1xuXHQvLyBcdFx0XHRcdCR5d19mYW1pbHkgPSBIX0ZBTUlMSUVTW3BfZmFtaWx5XTtcblx0Ly8gXHRcdFx0fVxuXG5cdC8vIFx0XHRcdC8vIGlmKGdjX3Byb3BzLmNoYWluSWQpIHtcblx0Ly8gXHRcdFx0Ly8gXHRpZighJHl3X2ZhbWlseSkgZGVidWdnZXI7XG5cdC8vIFx0XHRcdC8vIFx0Y29uc3QgcF9jaGFpbiA9IENoYWluLnJlZkZyb21GYW1pbHlJZCgkeXdfZmFtaWx5LmRlZi5pcmksIGdjX3Byb3BzLmNoYWluSWQgYXMgc3RyaW5nKTtcblx0Ly8gXHRcdFx0Ly8gXHQkeXdfY2hhaW4gPSBIX0NIQUlOU1twX2NoYWluXSB8fCBudWxsO1xuXHQvLyBcdFx0XHQvLyB9XG5cblx0Ly8gXHRcdFx0Ly8gaWYoZ2NfcHJvcHMuYWNjb3VudElkKSB7XG5cdC8vIFx0XHRcdC8vIFx0Y29uc29sZS53YXJuKGA8JHskeXdfcGF0aH0+IHByb3BzIHNldCBhY2NvdW50SWQgPSAke2djX3Byb3BzLmFjY291bnRJZH1gKTtcblx0Ly8gXHRcdFx0Ly8gXHQkeXdfYWNjb3VudCA9IEhfQUNDT1VOVFNbQWNjb3VudC5yZWZGcm9tSWQoZ2NfcHJvcHMuYWNjb3VudElkIGFzIHN0cmluZyldO1xuXHQvLyBcdFx0XHQvLyB9XG5cblx0Ly8gXHRcdFx0JHl3X3NjcmVlbl9kb20gPSBrc19kc3QuZG9tO1xuXG5cdC8vIFx0XHRcdC8vIHRyaWdnZXIgY29tcG9uZW50IHNldHRpbmdzXG5cdC8vIFx0XHRcdGNvbnN0IGZrX2Fycml2ZSA9IGhtX2Fycml2YWxzLmdldChrc19kc3QuZG9tKTtcblx0Ly8gXHRcdFx0aWYoZmtfYXJyaXZlKSBma19hcnJpdmUoKTtcblxuXHQvLyBcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblx0Ly8gXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jKGZrX3Jlc29sdmUpID0+IHtcblx0Ly8gXHRcdFx0XHQvLyByZWYgc3JjIHN0YXRlJ3MgZG9tXG5cdC8vIFx0XHRcdFx0bGV0IGRtX3NyYyA9IGtzX3NyYy5kb207XG5cblx0Ly8gXHRcdFx0XHQvLyByZWYgY2xhc3NsaXN0XG5cdC8vIFx0XHRcdFx0Y29uc3QgZF9jbGFzc19saXN0ID0gZG1fc3JjLmNsYXNzTGlzdDtcblxuXHQvLyBcdFx0XHRcdC8vIHNob3J0IGNpcmN1aXQgZXhwZW5zaXZlIGNvbXB1dGVkIHN0eWxlIGNhbGxcblx0Ly8gXHRcdFx0XHRsZXQgYl90cmFuc2l0aW9ucyA9IGZhbHNlO1xuXHQvLyBcdFx0XHRcdGlmKCdnb3RvJyA9PT0gc190cmFuc2l0aW9uKSB7XG5cdC8vIFx0XHRcdFx0XHRpZihkX2NsYXNzX2xpc3QuY29udGFpbnMoJ3NsaWRlcycpKSB7XG5cdC8vIFx0XHRcdFx0XHRcdC8vIGNoYW5naW5nIHRocmVhZHNcblx0Ly8gXHRcdFx0XHRcdFx0aWYoc2lfdGhyZWFkX3NyYykge1xuXHQvLyBcdFx0XHRcdFx0XHRcdGRtX3NyYyA9IGRtX3NyYy5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG5cdC8vIFx0XHRcdFx0XHRcdFx0ZG1fZXhpdHRpbmcucmVwbGFjZUNoaWxkcmVuKGRtX3NyYyk7XG5cdC8vIFx0XHRcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdFx0XHRkbV9zcmMuc3R5bGUuekluZGV4ID0gJzEwMDEnO1xuXG5cdC8vIFx0XHRcdFx0XHRcdGF3YWl0IHRpbWVvdXQoMCk7XG5cblx0Ly8gXHRcdFx0XHRcdFx0Ly8gZG1fc3JjLnN0eWxlLmxlZnQgPSBgLSR7WFBfQVBQX1dJRFRIfXB4YDtcblx0Ly8gXHRcdFx0XHRcdFx0ZG1fc3JjLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoLSR7WFBfQVBQX1dJRFRIfXB4KWA7XG5cdC8vIFx0XHRcdFx0XHRcdGJfdHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdFx0ZWxzZSB7XG5cdC8vIFx0XHRcdFx0XHRcdGNvbnN0IHNpX2V4aXQgPSBkbV9zcmMuZ2V0QXR0cmlidXRlKCdkYXRhLXMyLWV4aXQnKSBhcyBzdHJpbmc7XG5cblx0Ly8gXHRcdFx0XHRcdFx0c3dpdGNoKHNpX2V4aXQpIHtcblx0Ly8gXHRcdFx0XHRcdFx0XHRjYXNlICdzd2lwZXMnOiB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRkbV9zcmMuc3R5bGUubGVmdCA9IGAtJHtYUF9BUFBfV0lEVEh9cHhgO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0ZG1fc3JjLnN0eWxlLnpJbmRleCA9ICcxMDAxJztcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGJfdHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdC8vIFx0XHRcdFx0XHRcdFx0fVxuXG5cdC8vIFx0XHRcdFx0XHRcdFx0Y2FzZSAnbGVhdmVzJzoge1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0Ly8gY2hhbmdpbmcgdGhyZWFkc1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0aWYoc2lfdGhyZWFkX3NyYykge1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0XHRkbV9zcmMgPSBkbV9zcmMuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50O1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0XHRkbV9leGl0dGluZy5yZXBsYWNlQ2hpbGRyZW4oZG1fc3JjKTtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdFx0XHRcdFx0ZG1fc3JjLnN0eWxlLnpJbmRleCA9ICcxMDAxJztcblxuXHQvLyBcdFx0XHRcdFx0XHRcdFx0YXdhaXQgdGltZW91dCgwKTtcblxuXHQvLyBcdFx0XHRcdFx0XHRcdFx0Ly8gZG1fc3JjLnN0eWxlLmxlZnQgPSBgLSR7WFBfQVBQX1dJRFRIfXB4YDtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGRtX3NyYy5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKC0ke1hQX0FQUF9XSURUSH1weClgO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0Yl90cmFuc2l0aW9ucyA9IHRydWU7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0Ly8gXHRcdFx0XHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHRjYXNlICdyZXZlYWxzJzoge1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0ZG1fc3JjLmNsYXNzTGlzdC5hZGQoJ3JldmVhbCcpO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0Yl90cmFuc2l0aW9ucyA9IHRydWU7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0Ly8gXHRcdFx0XHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgYXR0cmlidXRlIHZhbHVlOiBcIiR7c2lfZXhpdCA/PyAnJ31cImApO1xuXHQvLyBcdFx0XHRcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdC8vIG5vdCBjaGFuZ2luZyB0aHJlYWRzXG5cdC8vIFx0XHRcdFx0aWYoIXNpX3RocmVhZF9zcmMpIHtcblx0Ly8gXHRcdFx0XHRcdC8vIC8vIHNyYyBsZWF2ZXNcblx0Ly8gXHRcdFx0XHRcdC8vIGlmKGRfY2xhc3NfbGlzdC5jb250YWlucygnbGVhdmVzJykpIHtcblx0Ly8gXHRcdFx0XHRcdC8vIFx0ZG1fc3JjLnN0eWxlLmxlZnQgPSBgLSR7WFBfQVBQX1dJRFRIfXB4YDtcblx0Ly8gXHRcdFx0XHRcdC8vIFx0ZG1fc3JjLnN0eWxlLnpJbmRleCA9ICcxMDAxJztcblx0Ly8gXHRcdFx0XHRcdC8vIFx0Yl90cmFuc2l0aW9ucyA9IHRydWU7XG5cdC8vIFx0XHRcdFx0XHQvLyB9XG5cblx0Ly8gXHRcdFx0XHRcdC8vIHNyYyBzbGlkZXMgb3V0XG5cdC8vIFx0XHRcdFx0XHRpZihkX2NsYXNzX2xpc3QuY29udGFpbnMoJ3NsaWRlcycpKSB7XG5cdC8vIFx0XHRcdFx0XHRcdGJfdHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHQvLyBjaGFuZ2luZyB0aHJlYWRzXG5cdC8vIFx0XHRcdFx0ZWxzZSB7XG5cdC8vIFx0XHRcdFx0XHQvLyBnb2luZyB0byBzZWFyY2hcblx0Ly8gXHRcdFx0XHRcdGlmKCcvc2VhcmNoJyA9PT0ga3NfZHN0LnBhdHRlcm4pIHtcblx0Ly8gXHRcdFx0XHRcdFx0ZG1fc3JjLmNsYXNzTGlzdC5hZGQoJ3N1YmxpbWF0ZScpO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdFx0Ly8gbGVhdmluZyBzZWFyY2hcblx0Ly8gXHRcdFx0XHRcdGVsc2UgaWYoJy9zZWFyY2gnID09PSBrc19zcmMucGF0dGVybikge1xuXHQvLyBcdFx0XHRcdFx0XHRrc19kc3QuZG9tLmNsYXNzTGlzdC5yZW1vdmUoJ3N1YmxpbWF0ZScpO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdC8vIFxuXHQvLyBcdFx0XHRcdGF3YWl0IG1pY3JvdGFzaygpO1xuXG5cdC8vIFx0XHRcdFx0Ly8gZWxlbWVudCBpcyB0cmFuc2l0aW9uaW5nXG5cdC8vIFx0XHRcdFx0aWYoIXNfdHJhbnNpdGlvbi5lbmRzV2l0aCgnLmJ5cGFzcycpKSB7XG5cdC8vIFx0XHRcdFx0XHRpZihiX3RyYW5zaXRpb25zIHx8IFNYX05PX1RSQU5TSVRJT04gIT09IGdldENvbXB1dGVkU3R5bGUoZG1fc3JjKS50cmFuc2l0aW9uKSB7XG5cdC8vIFx0XHRcdFx0XHRcdC8vIHdhaXQgZm9yIHRyYW5zaXRpb24gdG8gZW5kXG5cdC8vIFx0XHRcdFx0XHRcdGRtX3NyYy5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gdHJhbnNpdGlvbl9lbmQoZF9ldmVudCkge1xuXHQvLyBcdFx0XHRcdFx0XHRcdC8vIG5vdCBhIHBvc2l0aW9uIHByb3BlcnR5XG5cdC8vIFx0XHRcdFx0XHRcdFx0aWYoJ3RyYW5zZm9ybScgIT09IGRfZXZlbnQucHJvcGVydHlOYW1lKSByZXR1cm47XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHQvLyByZW1vdmUgc2VsZlxuXHQvLyBcdFx0XHRcdFx0XHRcdGRtX3NyYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdHJhbnNpdGlvbl9lbmQpO1xuXG5cdC8vIFx0XHRcdFx0XHRcdFx0Ly8gcmVzb2x2ZVxuXHQvLyBcdFx0XHRcdFx0XHRcdGZrX3Jlc29sdmUoKTtcblx0Ly8gXHRcdFx0XHRcdFx0fSk7XG5cblx0Ly8gXHRcdFx0XHRcdFx0Ly8gd2FpdCBmb3IgY2FsbGJhY2tcblx0Ly8gXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdGZrX3Jlc29sdmUoKTtcblx0Ly8gXHRcdFx0fSk7XG5cdC8vIFx0XHR9LFxuXHQvLyBcdH0pKTtcblx0fSk7XG5cdFxuPC9zY3JpcHQ+XG5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0LmZ1bGwoQHR5cGUpIHtcblx0XHRwb3NpdGlvbjogQHR5cGU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG5cblx0LmZ1bGwoYWJzb2x1dGUpIHtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0fVxuXG5cdC52aWV3cG9ydCB7XG5cdFx0LmZ1bGwocmVsYXRpdmUpO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXG5cdFx0Pi5jb250ZW50IHtcblx0XHRcdC5mdWxsKHJlbGF0aXZlKTtcblx0XHRcdG92ZXJmbG93OiBoaWRkZW47XG5cblx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXG5cdFx0XHQmLmV4aXR0aW5nIHtcblx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHR0b3A6IDA7XG5cdFx0XHRcdHotaW5kZXg6IDEwMDE7XG5cdFx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHRcdFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRcdH1cblxuXHRcdFx0Pi50aHJlYWQge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHQuZnVsbChhYnNvbHV0ZSk7XG5cdFx0XHRcdFx0cGFkZGluZy1sZWZ0OiBjYWxjKDUwdncgLSAodmFyKC0tYXBwLW1heC13aWR0aCkgLyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyA6Z2xvYmFsKCY+c2VjdGlvbikge1xuXHRcdFx0Ly8gXHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHQvLyBcdHRvcDogMHB4O1xuXHRcdFx0Ly8gXHR0cmFuc2l0aW9uOiBsZWZ0IDAuNnMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdFx0Ly8gfVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPG1haW4gY2xhc3M9XCJ2aWV3cG9ydFwiIGJpbmQ6dGhpcz17ZG1fdmlld3BvcnR9PlxuXHQ8ZGl2IGNsYXNzPVwiY29udGVudCB0aHJlYWRzXCIgYmluZDp0aGlzPXtkbV90aHJlYWRzfSAvPlxuXHQ8ZGl2IGNsYXNzPVwiY29udGVudCBleGl0dGluZ1wiIGJpbmQ6dGhpcz17ZG1fZXhpdHRpbmd9IC8+XG5cdDxzbG90Pjwvc2xvdD5cblxuXHQ8UHJvZ3Jlc3NTdmVsdGUgLz5cblx0XG5cdHsjaWYgYl9tYWlufVxuXHRcdHsjYXdhaXQgVmF1bHQuZ2V0Um9vdEtleSgpIHRoZW4gZGtfcm9vdH1cblx0XHRcdHsjaWYgZGtfcm9vdH1cblx0XHRcdFx0PE92ZXJzY3JvbGxTdmVsdGUgLz5cblx0XHRcdFx0PE5hdlN2ZWx0ZSAvPlxuXHRcdFx0XHQ8U2VhcmNoU3ZlbHRlIC8+XG5cdFx0XHRcdDxWZW5kb3JNZW51U3ZlbHRlIC8+XG5cdFx0XHRcdDxTaWRlTWVudVN2ZWx0ZSAvPlxuXHRcdFx0XHQ8UG9wdXBTdmVsdGUgLz5cblx0XHRcdHsvaWZ9XG5cdFx0ey9hd2FpdH1cblx0ey9pZn1cbjwvbWFpbj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCBMb2csIHsgTG9nZ2VyIH0gZnJvbSAnIy9hcHAvdWkvTG9nLnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHsgVmF1bHQgfSBmcm9tICcjL2NyeXB0by92YXVsdCc7XG5cdGltcG9ydCB0eXBlIHsgQ29tcGxldGVkIH0gZnJvbSAnIy9lbnRyeS9mbG93JztcblxuXHRpbXBvcnQge1xuXHRcdEFUVThfRFVNTVlfUEhSQVNFLFxuXHRcdEFUVThfRFVNTVlfVkVDVE9SLFxuXHRcdGxvZ2luLFxuXHRcdENvcnJ1cHRlZFZhdWx0RXJyb3IsXG5cdFx0SW52YWxpZFBhc3NwaHJhc2VFcnJvcixcblx0XHRSZWNvdmVyYWJsZVZhdWx0RXJyb3IsXG5cdFx0VW5yZWdpc3RlcmVkRXJyb3IsXG5cdH0gZnJvbSAnIy9zaGFyZS9hdXRoJztcblxuXHRpbXBvcnQgeyBTY3JlZW4sIHR5cGUgUGFnZSB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnIy9hcHAvdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcblx0aW1wb3J0IEZpZWxkIGZyb20gJyMvYXBwL3VpL0ZpZWxkLnN2ZWx0ZSc7XG5cdGltcG9ydCB7IHNsaWRlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXG5cdC8vIHdpbGwgYmUgc2V0IGlmIHBhcnQgb2YgZmxvd1xuXHRjb25zdCBjb21wbGV0ZWQgPSBnZXRDb250ZXh0PENvbXBsZXRlZCB8IHVuZGVmaW5lZD4oJ2NvbXBsZXRlZCcpO1xuXG5cdC8vIHBhc3N3b3JkIHZhbHVlIGJpbmRpbmdcblx0bGV0IHNoX3Bhc3N3b3JkID0gJyc7XG5cblx0Ly8gcGFzc3dvcmQgZXJyb3Jcblx0bGV0IHNfZXJyX3Bhc3N3b3JkID0gJyc7XG5cblx0Ly8gYnVzeSBhdHRlbXB0aW5nIHVubG9ja1xuXHRsZXQgYl9idXN5ID0gZmFsc2U7XG5cblxuXHRsZXQgeHRfc3RhcnQgPSAwO1xuXHRsZXQga19sb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cdGZ1bmN0aW9uIGxvZyhzX21zZzogc3RyaW5nKSB7XG5cdFx0a19sb2dnZXIgPSBrX2xvZ2dlci5ldmVudChzX21zZywgRGF0ZS5ub3coKSAtIHh0X3N0YXJ0KTtcblx0fVxuXG5cdGFzeW5jIGZ1bmN0aW9uIGF0dGVtcHRfdW5sb2NrKGJfcmVjb3Zlcj1mYWxzZSk6IFByb21pc2U8MT4ge1xuXHRcdC8vIGRvIG5vdCBpbnRlcnVwdDsgbG9ja1xuXHRcdGlmKGJfYnVzeSkgcmV0dXJuIDE7IGJfYnVzeSA9IHRydWU7XG5cblx0XHQvLyBwcmVwIGdyYWNlZnVsIGV4aXRcblx0XHRjb25zdCBleGl0ID0gKCk6IDEgPT4gKGJfYnVzeSA9IGZhbHNlLCAxKTtcblxuXHRcdC8vIHJlc2V0IGVycm9yXG5cdFx0c19lcnJfcGFzc3dvcmQgPSAnJztcblxuXHRcdC8vIHN0YXJ0IHRpbWVyXG5cdFx0eHRfc3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0bG9nKCdFc3RpbWF0aW5nIHRpbWUgdG8gY29tcGxldGUnKTtcblxuXHRcdC8vIGVzdGltYXRlIHRpbWUgdG8gY29tcGxldGVcblx0XHR7XG5cdFx0XHRjb25zdCB4dF9zdGFydF9lc3QgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHRhd2FpdCBWYXVsdC5kZXJpdmVSb290Qml0cyhBVFU4X0RVTU1ZX1BIUkFTRSwgQVRVOF9EVU1NWV9WRUNUT1IsIDEgLyA1MCk7XG5cdFx0XHRjb25zdCB4dF9maW5pc2hfZXN0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0XHRjb25zdCB4dF9lbGFwc2VkID0geHRfZmluaXNoX2VzdCAtIHh0X3N0YXJ0X2VzdDtcblx0XHRcdGNvbnN0IHh0X2VzdGltYXRlID0gKDIgKiAoeHRfZWxhcHNlZCAqIDUwKSk7XG5cdFx0XHRsb2coYEFib3V0ICR7KHh0X2VzdGltYXRlIC8gMTAwMCkudG9GaXhlZCgxKX0gc2Vjb25kc2ApO1xuXHRcdH1cblxuXHRcdC8vIGF0dGVtcHQgbG9naW5cblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgbG9naW4oc2hfcGFzc3dvcmQsIGJfcmVjb3ZlciwgbG9nKTtcblx0XHR9XG5cdFx0Ly8gaGFuZGxlIGVycm9yXG5cdFx0Y2F0Y2goZV9sb2dpbikge1xuXHRcdFx0aWYoZV9sb2dpbiBpbnN0YW5jZW9mIFVucmVnaXN0ZXJlZEVycm9yKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gJ05vIGFjY291bnRzIGRldGVjdGVkJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZV9sb2dpbiBpbnN0YW5jZW9mIEludmFsaWRQYXNzcGhyYXNlRXJyb3IpIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSAnSW52YWxpZCBwYXNzcGhyYXNlJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZV9sb2dpbiBpbnN0YW5jZW9mIFJlY292ZXJhYmxlVmF1bHRFcnJvcikge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9ICdWYXVsdCBpcyBwYXJ0aWFsbHkgY29ycnVwdGVkOyBhdHRlbXB0aW5nIHJlY292ZXJ5Li4uJztcblx0XHRcdFx0cmV0dXJuIGF3YWl0IGF0dGVtcHRfdW5sb2NrKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihiX3JlY292ZXIpIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSBgUmVjb3ZlcnkgZmFpbGVkLiBWYXVsdCBtYXkgYmUgaXJyZXBhcmFibHkgY29ycnVwdGVkLlxcbiR7ZV9sb2dpbi5tZXNzYWdlIX1gO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihlX2xvZ2luIGluc3RhbmNlb2YgQ29ycnVwdGVkVmF1bHRFcnJvcikge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9IGBWYXVsdCBhcHBlYXJzIHRvIGJlIGlycmVwYXJhYmx5IGNvcnJ1cHRlZC5cXG4ke2VfbG9naW4ubWVzc2FnZX1gO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gYFVua25vd24gZXJyb3Igb2NjdXJyZWQ6ICR7ZV9sb2dpbi5zdGFjayB8fCBlX2xvZ2luLm1lc3NhZ2V9YDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZXhpdFxuXHRcdFx0cmV0dXJuIGV4aXQoKTtcblx0XHR9XG5cblx0XHQvLyBzdWNjZXNzXG5cdFx0aWYoY29tcGxldGVkKSBjb21wbGV0ZWQodHJ1ZSk7XG5cblx0XHQvLyBleGl0XG5cdFx0cmV0dXJuIGV4aXQoKTtcblx0fVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0LndlbGNvbWUge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdFx0Z2FwOiAyMHB4O1xuXHRcdFx0cGFkZGluZy1sZWZ0OiAxNnB4O1xuXHRcdFx0cGFkZGluZy1yaWdodDogMTZweDtcblx0XHRcdGJhY2tncm91bmQtaW1hZ2U6IHVybCgnL21lZGlhL3ZlbmRvci9vcmItMS5zdmcnKTtcblx0XHRcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG5cdFx0XHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgdG9wO1xuXHRcdFx0YmFja2dyb3VuZC1zaXplOiBjb3Zlcjtcblx0XHRcdHBhZGRpbmctdG9wOiBjYWxjKDUwdmggLSAyMDBweCk7XG5cdFx0fVxuXG5cdFx0PmRpdiB7XG5cdFx0XHQmLmxvZ28sJi50aXRsZSB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1hcmdpbi1sZWZ0OiBhdXRvICFpbXBvcnRhbnQ7XG5cdFx0XHRcdFx0bWFyZ2luLXJpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC5sYXJnZSB7XG5cdFx0LmZvbnQoYmlnKTtcblx0fVxuXG5cdHAge1xuXHRcdC5mb250KHJlZ3VsYXIpO1xuXHRcdHBhZGRpbmc6IDhweCAwO1xuXHR9XG5cblx0LmxpbmUge1xuXHRcdHdpZHRoOiBjYWxjKDEwMCUgLSA0MHB4KTtcblx0XHRoZWlnaHQ6IDFweDtcblx0XHRiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoNTAlIDUwJSBhdCA1MCUgNTAlLCAjRkZDNzAwIDAlLCByZ2JhKDI1NSwgMTk5LCAwLCAwKSAxMDAlKTtcblx0fVxuXG5cdC5hY3Rpb25zLWxpbmUge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHR9XG5cblx0Lm9mZi1zY3JlZW4ge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IGNhbGModmFyKC0tYXBwLXdpbmRvdy13aWR0aCkgKiAxMDApO1xuXHR9XG48L3N0eWxlPlxuXG57I2lmIGZhbHNlfVxuXHQ8c3BhblxuXHRcdGNsYXNzOndlbGNvbWU9e3RydWV9XG5cdC8+XG57L2lmfVxuXG48U2NyZWVuIGRlYnVnPSdBdXRoZW50aWNhdGUnIGNsYXNzTmFtZXM9J3dlbGNvbWUnPlxuXHQ8ZGl2IGNsYXNzPVwibG9nb1wiPlxuXHRcdDxpbWcgd2lkdGg9XCI5NlwiIHNyYz1cIi9tZWRpYS92ZW5kb3IvbG9nby05NnB4LnBuZ1wiIHNyY3NldD1cIi9tZWRpYS92ZW5kb3IvbG9nby05NnB4LnBuZyAxeCwgL21lZGlhL3ZlbmRvci9sb2dvLTE5MnB4LnBuZyAyeFwiIGFsdD1cIlN0YXJTaGVsbFwiIC8+XG5cdDwvZGl2PlxuXG5cdDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxuXHRcdDxpbWcgc3JjPVwiL21lZGlhL3ZlbmRvci90aXRsZS5zdmdcIiBhbHQ9XCJcIiAvPlxuXHQ8L2Rpdj5cblxuXHQ8ZGl2IGNsYXNzPVwibGluZVwiPiZuYnNwOzwvZGl2PlxuXG5cdDxkaXYgY2xhc3M9XCJmb3JtIGZsZXgtcm93c1wiPlxuXHRcdDxGaWVsZCBrZXk9XCJwYXNzd29yZFwiIG5hbWU9XCJcIj5cblx0XHRcdDxpbnB1dFxuXHRcdFx0XHR0eXBlPVwicGFzc3dvcmRcIlxuXHRcdFx0XHRuYW1lPVwicGFzc3dvcmRcIlxuXHRcdFx0XHRwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCJcblx0XHRcdFx0YmluZDp2YWx1ZT17c2hfcGFzc3dvcmR9XG5cdFx0XHRcdGNsYXNzOmludmFsaWQ9e3NfZXJyX3Bhc3N3b3JkfVxuXHRcdFx0Lz5cblxuXHRcdFx0eyNpZiBzX2Vycl9wYXNzd29yZH1cblx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiIHRyYW5zaXRpb246c2xpZGU9e3tkdXJhdGlvbjozMDB9fT5cblx0XHRcdFx0XHR7c19lcnJfcGFzc3dvcmR9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9pZn1cblx0XHQ8L0ZpZWxkPlxuXHQ8L2Rpdj5cblxuXHQ8QWN0aW9uc0xpbmUgY29uZmlybT17WydVbmxvY2snLCBhdHRlbXB0X3VubG9ja119IC8+XG5cblx0PExvZyBiaW5kOml0ZW1zPXtrX2xvZ2dlci5pdGVtc30gaGlkZSAvPlxuXG48L1NjcmVlbj5cbiIsImltcG9ydCB7IGRkLCBxcyB9IGZyb20gJyMvdXRpbC9kb20nO1xuXG4vLyBzZWxlY3QgZG9tIGxvZyBlbGVtZW50c1xuZXhwb3J0IGNvbnN0IGRtX2xvZyA9IHFzKGRvY3VtZW50LCAnc2VjdGlvbiNkb20tbG9nJyk7XG5leHBvcnQgY29uc3QgZG1fbG9nX2xpc3QgPSBxcyhkb2N1bWVudCwgJyNkb20tbG9nLWxpc3QnKTtcblxuLyoqXG4gKiBMb2dzIGEgbWVzc2FnZSB0byB0aGUgY29uc29sZSBhbmQgdG8gRE9NIGFzIGEgZmFsbGJhY2sgZm9yIHVuaGFuZGxlZCBlcnJvcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvbWxvZyhzaV9tc2c6IHN0cmluZyk6IHZvaWQge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRjb25zb2xlLmxvZyhzaV9tc2cpO1xuXG5cdGRtX2xvZ19saXN0Py5hcHBlbmQoZGQoJ2xpJywge30sIFtcblx0XHRkZCgncHJlJywge30sIFtzaV9tc2ddKSxcblx0XSkpO1xufVxuIiwiPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5ob3Jpem9uIHtcblx0XHR3aWR0aDogY2FsYygxMDAlIC0gNDBweCk7XG5cdFx0aGVpZ2h0OiAxcHg7XG5cdFx0YmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KDUwJSA1MCUgYXQgNTAlIDUwJSwgI0ZGQzcwMCAwJSwgcmdiYSgyNTUsIDE5OSwgMCwgMCkgMTAwJSk7XG5cblx0XHRtYXJnaW4tbGVmdDogYXV0bztcblx0XHRtYXJnaW4tcmlnaHQ6IGF1dG87XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJuby1tYXJnaW4gaG9yaXpvblwiPntAaHRtbCAnJm5ic3A7J308L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IFNjcmVlbiB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcuLi91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuXHRpbXBvcnQgUmVnaXN0ZXIgZnJvbSAnLi9SZWdpc3Rlci5zdmVsdGUnO1xuXHRpbXBvcnQgU3RhclNoZWxsTG9nbyBmcm9tICcuLi91aS9TdGFyU2hlbGxMb2dvLnN2ZWx0ZSc7XG5cdGltcG9ydCBTdGFyU2hlbGxUaXRsZSBmcm9tICcuLi91aS9TdGFyU2hlbGxUaXRsZS5zdmVsdGUnO1xuXHRpbXBvcnQgSG9yaXpvbiBmcm9tICcuLi91aS9Ib3Jpem9uLnN2ZWx0ZSc7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0Omdsb2JhbCgucHJlcmVnaXN0ZXIpIHtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRnYXA6IDIwcHg7XG5cdFx0cGFkZGluZy1sZWZ0OiAxNnB4O1xuXHRcdHBhZGRpbmctcmlnaHQ6IDE2cHg7XG5cdFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKCcvbWVkaWEvdmVuZG9yL29yYi0xLnN2ZycpO1xuXHRcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG5cdFx0YmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIHRvcDtcblx0XHRiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xuXG5cdFx0cGFkZGluZy10b3A6IGNhbGMoNTB2aCAtIDE1MHB4KTtcblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbiByb290IGNsYXNzTmFtZXM9J3ByZXJlZ2lzdGVyJz5cblx0PFN0YXJTaGVsbExvZ28gZGltPXs5Nn0gLz5cblxuXHQ8U3RhclNoZWxsVGl0bGUgLz5cblxuXHQ8SG9yaXpvbiAvPlxuXG5cdDxkaXYgY2xhc3M9XCJsYXJnZVwiPlxuXHRcdDxkaXY+V2VsY29tZSB0byB0aGUgYmV0YSBwcm9ncmFtLjwvZGl2PlxuXHRcdDxkaXY+VGhhbmsgZm9yIHlvdSBiZWluZyBhIHRlc3RlciE8L2Rpdj5cblx0PC9kaXY+XG5cblx0PHA+XG5cdFx0XG5cdDwvcD5cblxuXHQ8QWN0aW9uc0xpbmUgY29uZmlybT17WydHZXQgU3RhcnRlZCddfSBjb250ZD17e2NyZWF0b3I6UmVnaXN0ZXJ9fSAvPlxuPC9TY3JlZW4+XG4iXSwibmFtZXMiOlsiY3JlYXRlX2lmX2Jsb2NrIiwiU1hfSUNPTl9BRERfU01BTEwiLCJjcmVhdGVfaWZfYmxvY2tfNSIsImNyZWF0ZV9pZl9ibG9ja18zIiwiY3JlYXRlX2lmX2Jsb2NrXzQiLCJjcmVhdGVfaWZfYmxvY2tfMiIsImNyZWF0ZV9pZl9ibG9ja18xIiwiUmVnaXN0ZXJXZWFrUGFzc3dvcmRTdmVsdGUiLCJyZWdpc3RlciIsIlNYX0lDT05fUEVSU09OQUwiLCJEZWFkRW5kIiwiU1hfSUNPTl9BREQiLCJhcHBlbmRfMSIsIkJsYW5rU3ZlbHRlIiwiUmVnaXN0ZXJTdmVsdGUiLCJIb2xkaW5nc0hvbWVTdmVsdGUiLCJDb250YWN0c0hvbWVTdmVsdGUiLCJOZXR3b3Jrc0hvbWVTdmVsdGUiLCJBY2NvdW50SG9tZVN2ZWx0ZSIsIlNpdGVzSG9tZVN2ZWx0ZSIsIlNYX0lDT05fQ09OVEFDVFMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxhQUFrQyxR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
