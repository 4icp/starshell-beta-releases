var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const p = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p();
function noop$1() {
}
const identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function is_promise(value) {
  return value && typeof value === "object" && typeof value.then === "function";
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop$1;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length2 = $$scope.ctx.length / 32;
    for (let i = 0; i < length2; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
const is_client = typeof window !== "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop$1;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function append(target, node) {
  target.appendChild(node);
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function set_custom_element_data(node, prop, value) {
  if (prop in node) {
    node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
  } else {
    attr(node, prop, value);
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
let crossorigin;
function is_crossorigin() {
  if (crossorigin === void 0) {
    crossorigin = false;
    try {
      if (typeof window !== "undefined" && window.parent) {
        void window.parent.document;
      }
    } catch (error) {
      crossorigin = true;
    }
  }
  return crossorigin;
}
function add_resize_listener(node, fn) {
  const computed_style = getComputedStyle(node);
  if (computed_style.position === "static") {
    node.style.position = "relative";
  }
  const iframe = element("iframe");
  iframe.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;");
  iframe.setAttribute("aria-hidden", "true");
  iframe.tabIndex = -1;
  const crossorigin2 = is_crossorigin();
  let unsubscribe;
  if (crossorigin2) {
    iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>";
    unsubscribe = listen(window, "message", (event) => {
      if (event.source === iframe.contentWindow)
        fn();
    });
  } else {
    iframe.src = "about:blank";
    iframe.onload = () => {
      unsubscribe = listen(iframe.contentWindow, "resize", fn);
    };
  }
  append(node, iframe);
  return () => {
    if (crossorigin2) {
      unsubscribe();
    } else if (unsubscribe && iframe.contentWindow) {
      unsubscribe();
    }
    detach(iframe);
  };
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
class HtmlTag {
  constructor(is_svg = false) {
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(target.nodeName);
      else
        this.e = element(target.nodeName);
      this.t = target;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.childNodes);
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t = a + (b - a) * ease(p2);
    keyframes += p2 * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { stylesheet } = info;
      let i = stylesheet.cssRules.length;
      while (i--)
        stylesheet.deleteRule(i);
      info.rules = {};
    });
    managed_styles.clear();
  });
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
function getAllContexts() {
  return get_current_component().$$.context;
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
const null_transition = { duration: 0 };
function create_out_transition(node, fn, params) {
  let config = fn(node, params);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  function go() {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop$1, css } = config || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, "start"));
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick2(0, 1);
          dispatch(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick2(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config)) {
    wait().then(() => {
      config = config();
      go();
    });
  } else {
    go();
  }
  return {
    end(reset2) {
      if (reset2 && config.tick) {
        config.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn, params, intro) {
  let config = fn(node, params);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop$1, css } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p2 = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p2 / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          config = config();
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function handle_promise(promise2, info) {
  const token = info.token = {};
  function update2(type, index, key, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i) => {
          if (i !== index && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i] === block2) {
                info.blocks[i] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise2)) {
    const current_component2 = get_current_component();
    promise2.then((value) => {
      set_current_component(current_component2);
      update2(info.then, 1, info.value, value);
      set_current_component(null);
    }, (error) => {
      set_current_component(current_component2);
      update2(info.catch, 2, info.error, error);
      set_current_component(null);
      if (!info.hasCatch) {
        throw error;
      }
    });
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise2);
      return true;
    }
    info.resolved = promise2;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop$1,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop$1;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
}
const F_NOOP = () => {
};
const proper = (s_input) => s_input.split(/\s+/g).map((s) => s[0].toUpperCase() + s.slice(1)).join(" ");
function objects_might_differ(h_a, h_b) {
  const a_keys_a = Object.keys(h_a);
  const a_keys_b = Object.keys(h_b);
  const nl_keys = a_keys_a.length;
  if (nl_keys !== a_keys_b.length)
    return true;
  for (const si_key in h_a) {
    if (h_b[si_key] !== h_a[si_key])
      return true;
  }
  return false;
}
function fold(a_in, f_fold) {
  const h_out = {};
  let i_each = 0;
  for (const z_each of a_in) {
    Object.assign(h_out, f_fold(z_each, i_each++));
  }
  return h_out;
}
function ode(h_object) {
  return Object.entries(h_object);
}
function ofe(a_entries) {
  return Object.fromEntries(a_entries);
}
function oderac(h_thing, f_concat, b_add_undefs = false) {
  return ode(h_thing).reduce((a_out, [si_key, w_value], i_entry) => [
    ...a_out,
    f_concat(si_key, w_value, i_entry)
  ], []);
}
function oderom(h_thing, f_merge) {
  return ode(h_thing).reduce((h_out, [si_key, w_value]) => ({
    ...h_out,
    ...f_merge(si_key, w_value)
  }), {});
}
function timeout(xt_wait) {
  return new Promise((fk_resolve) => {
    setTimeout(() => {
      fk_resolve();
    }, xt_wait);
  });
}
function forever(w_type) {
  return new Promise(F_NOOP);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var dist = {};
Object.defineProperty(dist, "__esModule", { value: true });
dist.bech32m = bech32 = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
const ALPHABET_MAP = {};
for (let z = 0; z < ALPHABET.length; z++) {
  const x = ALPHABET.charAt(z);
  ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
  const b = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
}
function prefixChk(prefix) {
  let chk = 1;
  for (let i = 0; i < prefix.length; ++i) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      return "Invalid prefix (" + prefix + ")";
    chk = polymodStep(chk) ^ c >> 5;
  }
  chk = polymodStep(chk);
  for (let i = 0; i < prefix.length; ++i) {
    const v = prefix.charCodeAt(i);
    chk = polymodStep(chk) ^ v & 31;
  }
  return chk;
}
function convert(data, inBits, outBits, pad) {
  let value = 0;
  let bits = 0;
  const maxV = (1 << outBits) - 1;
  const result = [];
  for (let i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }
  if (pad) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWords(bytes) {
  return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
  const res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words) {
  const res = convert(words, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
  let ENCODING_CONST;
  if (encoding === "bech32") {
    ENCODING_CONST = 1;
  } else {
    ENCODING_CONST = 734539939;
  }
  function encode(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT)
      throw new TypeError("Exceeds length limit");
    prefix = prefix.toLowerCase();
    let chk = prefixChk(prefix);
    if (typeof chk === "string")
      throw new Error(chk);
    let result = prefix + "1";
    for (let i = 0; i < words.length; ++i) {
      const x = words[i];
      if (x >> 5 !== 0)
        throw new Error("Non 5-bit word");
      chk = polymodStep(chk) ^ x;
      result += ALPHABET.charAt(x);
    }
    for (let i = 0; i < 6; ++i) {
      chk = polymodStep(chk);
    }
    chk ^= ENCODING_CONST;
    for (let i = 0; i < 6; ++i) {
      const v = chk >> (5 - i) * 5 & 31;
      result += ALPHABET.charAt(v);
    }
    return result;
  }
  function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8)
      return str + " too short";
    if (str.length > LIMIT)
      return "Exceeds length limit";
    const lowered = str.toLowerCase();
    const uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered)
      return "Mixed-case string " + str;
    str = lowered;
    const split = str.lastIndexOf("1");
    if (split === -1)
      return "No separator character for " + str;
    if (split === 0)
      return "Missing prefix for " + str;
    const prefix = str.slice(0, split);
    const wordChars = str.slice(split + 1);
    if (wordChars.length < 6)
      return "Data too short";
    let chk = prefixChk(prefix);
    if (typeof chk === "string")
      return chk;
    const words = [];
    for (let i = 0; i < wordChars.length; ++i) {
      const c = wordChars.charAt(i);
      const v = ALPHABET_MAP[c];
      if (v === void 0)
        return "Unknown character " + c;
      chk = polymodStep(chk) ^ v;
      if (i + 6 >= wordChars.length)
        continue;
      words.push(v);
    }
    if (chk !== ENCODING_CONST)
      return "Invalid checksum for " + str;
    return { prefix, words };
  }
  function decodeUnsafe(str, LIMIT) {
    const res = __decode(str, LIMIT);
    if (typeof res === "object")
      return res;
  }
  function decode(str, LIMIT) {
    const res = __decode(str, LIMIT);
    if (typeof res === "object")
      return res;
    throw new Error(res);
  }
  return {
    decodeUnsafe,
    decode,
    encode,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
var bech32 = dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
if ("undefined" !== typeof window && "localhost" === window?.location?.hostname) {
  const d_chrome = globalThis["chrome"];
  if (!d_chrome["storage"]) {
    let polyfill_chrome_storage = function(si_area) {
      return {
        async get(z_keys) {
          const a_keys = Array.isArray(z_keys) ? z_keys : [z_keys];
          return fold(a_keys, (si_key) => {
            const z_value = localStorage.getItem(`chrome.${si_area}:${si_key}`);
            return {
              [si_key]: "string" === typeof z_value ? JSON.parse(z_value) : void 0
            };
          });
        },
        async set(h_set) {
          for (const [si_key, w_value] of ode(h_set)) {
            localStorage.setItem(`chrome.${si_area}:${si_key}`, JSON.stringify(w_value));
          }
        },
        async clear() {
          const nl_items = localStorage.length;
          for (let i_item = nl_items; i_item >= 0; i_item--) {
            const si_key = localStorage.key(i_item);
            if (!si_key)
              continue;
            if (si_key.startsWith(`chrome.${si_area}:`)) {
              localStorage.removeItem(si_key);
            }
          }
        },
        async remove(z_keys) {
          const a_keys = Array.isArray(z_keys) ? z_keys : [z_keys];
          for (const si_key of a_keys) {
            localStorage.removeItem(`chrome.${si_area}:${si_key}`);
          }
        }
      };
    };
    d_chrome.storage = {
      local: polyfill_chrome_storage("local"),
      sync: polyfill_chrome_storage("sync"),
      session: polyfill_chrome_storage("session")
    };
  }
  if (!d_chrome["runtime"]) {
    d_chrome.runtime = {
      getURL(p_asset) {
        debugger;
      },
      getManifest() {
        debugger;
      },
      sendMessage(g_msg) {
        debugger;
      },
      onMessage: {
        addListener(f_listener) {
          debugger;
        },
        removeListener() {
          debugger;
        }
      },
      onInstalled: {
        addListener(f_listener) {
          debugger;
        },
        removeListener() {
          debugger;
        }
      }
    };
  }
  if (!d_chrome["tabs"]) {
    d_chrome.tabs = {
      create(gc_create) {
        window.open(gc_create.url, "_blank");
      },
      get(i_tab) {
        debugger;
      },
      reload(i_tab) {
        debugger;
      },
      onUpdated: {
        addEventListener() {
          debugger;
        },
        removeListener() {
          debugger;
        }
      }
    };
  }
  if (!d_chrome["windows"]) {
    d_chrome.windows = {
      create(gc_create) {
        window.open(gc_create.url, "_blank");
      },
      get(i_window) {
        debugger;
      },
      remove(i_window) {
        debugger;
      },
      onRemoved: {
        addEventListener() {
          debugger;
        },
        removeListener() {
          debugger;
        }
      }
    };
  }
  if (!d_chrome["extension"]) {
    d_chrome.extension = {
      getBackgroundPage() {
        debugger;
      }
    };
  }
  if (!d_chrome["scripting"]) {
    d_chrome.scripting = {
      executeScript() {
        debugger;
      }
    };
  }
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const base64ToBin = (validBase64) => {
  const lookup = new Uint8Array(123);
  for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }
  const bufferLengthEstimate = validBase64.length * 0.75;
  const stringLength = validBase64.length;
  const bufferLength = validBase64[validBase64.length - 1] === "=" ? validBase64[validBase64.length - 2] === "=" ? bufferLengthEstimate - 2 : bufferLengthEstimate - 1 : bufferLengthEstimate;
  const buffer = new ArrayBuffer(bufferLength);
  const bytes = new Uint8Array(buffer);
  let p2 = 0;
  for (let i = 0; i < stringLength; i += 4) {
    const encoded1 = lookup[validBase64.charCodeAt(i)];
    const encoded2 = lookup[validBase64.charCodeAt(i + 1)];
    const encoded3 = lookup[validBase64.charCodeAt(i + 2)];
    const encoded4 = lookup[validBase64.charCodeAt(i + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
};
const instantiateRustWasm = async (webassemblyBytes, expectedImportModuleName, hashExportName, initExportName, updateExportName, finalExportName) => {
  const wasm2 = (await WebAssembly.instantiate(webassemblyBytes, {
    [expectedImportModuleName]: {
      __wbindgen_throw: (ptr, len) => {
        throw new Error(
          Array.from(getUint8Memory().subarray(ptr, ptr + len)).map((num) => String.fromCharCode(num)).join("")
        );
      }
    }
  })).instance.exports;
  let cachedUint8Memory;
  let cachedUint32Memory;
  let cachedGlobalArgumentPtr;
  const globalArgumentPtr = () => {
    if (cachedGlobalArgumentPtr === void 0) {
      cachedGlobalArgumentPtr = wasm2.__wbindgen_global_argument_ptr();
    }
    return cachedGlobalArgumentPtr;
  };
  function getUint8Memory() {
    if (cachedUint8Memory === void 0 || cachedUint8Memory.buffer !== wasm2.memory.buffer) {
      cachedUint8Memory = new Uint8Array(wasm2.memory.buffer);
    }
    return cachedUint8Memory;
  }
  const getUint32Memory = () => {
    if (cachedUint32Memory === void 0 || cachedUint32Memory.buffer !== wasm2.memory.buffer) {
      cachedUint32Memory = new Uint32Array(wasm2.memory.buffer);
    }
    return cachedUint32Memory;
  };
  const passArray8ToWasm = (array) => {
    const ptr = wasm2.__wbindgen_malloc(array.length);
    getUint8Memory().set(array, ptr);
    return [ptr, array.length];
  };
  const getArrayU8FromWasm = (ptr, len) => getUint8Memory().subarray(ptr, ptr + len);
  const hash2 = (input) => {
    const [ptr0, len0] = passArray8ToWasm(input);
    const retPtr = globalArgumentPtr();
    try {
      wasm2[hashExportName](retPtr, ptr0, len0);
      const mem = getUint32Memory();
      const ptr = mem[retPtr / 4];
      const len = mem[retPtr / 4 + 1];
      const realRet = getArrayU8FromWasm(ptr, len).slice();
      wasm2.__wbindgen_free(ptr, len);
      return realRet;
    } finally {
      wasm2.__wbindgen_free(ptr0, len0);
    }
  };
  const init2 = () => {
    const retPtr = globalArgumentPtr();
    wasm2[initExportName](retPtr);
    const mem = getUint32Memory();
    const ptr = mem[retPtr / 4];
    const len = mem[retPtr / 4 + 1];
    const realRet = getArrayU8FromWasm(ptr, len).slice();
    wasm2.__wbindgen_free(ptr, len);
    return realRet;
  };
  const update2 = (rawState, input) => {
    const [ptr0, len0] = passArray8ToWasm(rawState);
    const [ptr1, len1] = passArray8ToWasm(input);
    const retPtr = globalArgumentPtr();
    try {
      wasm2[updateExportName](retPtr, ptr0, len0, ptr1, len1);
      const mem = getUint32Memory();
      const ptr = mem[retPtr / 4];
      const len = mem[retPtr / 4 + 1];
      const realRet = getArrayU8FromWasm(ptr, len).slice();
      wasm2.__wbindgen_free(ptr, len);
      return realRet;
    } finally {
      rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));
      wasm2.__wbindgen_free(ptr0, len0);
      wasm2.__wbindgen_free(ptr1, len1);
    }
  };
  const final = (rawState) => {
    const [ptr0, len0] = passArray8ToWasm(rawState);
    const retPtr = globalArgumentPtr();
    try {
      wasm2[finalExportName](retPtr, ptr0, len0);
      const mem = getUint32Memory();
      const ptr = mem[retPtr / 4];
      const len = mem[retPtr / 4 + 1];
      const realRet = getArrayU8FromWasm(ptr, len).slice();
      wasm2.__wbindgen_free(ptr, len);
      return realRet;
    } finally {
      rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));
      wasm2.__wbindgen_free(ptr0, len0);
    }
  };
  return {
    final,
    hash: hash2,
    init: init2,
    update: update2
  };
};
const ripemd160Base64Bytes = "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AgQMBQsgAEH8EigCACACaiICQQFyNgIEQYQTIAA2AgBB/BIgAjYCACAAIAJqIAI2AgAMBAsgAxAgDAELQewPQewPKAIAQX4gAUEDdndxNgIACyAEIAJqIQIgAyAEaiEDCyADIAMoAgRBfnE2AgQgACACQQFyNgIEIAAgAmogAjYCAAJ/AkAgAkH/AU0EQCACQQN2IgFBA3RB9A9qIQJB7A8oAgAiA0EBIAFBH3F0IgFxRQ0BIAJBCGohAyACKAIIDAILIAAgAhAhDAILQewPIAMgAXI2AgAgAkEIaiEDIAILIQEgAyAANgIAIAEgADYCDCAAIAI2AgwgACABNgIICyAFQQhqDwtBgBMgACACayIBNgIAQYgTQYgTKAIAIgAgAmoiAzYCACADIAFBAXI2AgQgACACQQNyNgIEIABBCGoLpQEBAn9BAiEFAkACQAJAAkACQCAAKAIEIgYgAWsgAk8NACABIAJqIgIgAUkhAQJAIAQEQEEAIQUgAQ0CIAZBAXQiASACIAIgAUkbIQIMAQtBACEFIAENAQsgAkEASA0AIAZFDQEgACgCACACEBMiAUUNAgwDCyAFDwsgAhAEIgENAQsgAw0BCyABBEAgACABNgIAIABBBGogAjYCAEECDwtBAQ8LAAsIAEGMFBAHAAtmAgF/A34jAEEwayIBJAAgACkCECECIAApAgghAyAAKQIAIQQgAUEUakEANgIAIAEgBDcDGCABQgE3AgQgAUH0DDYCECABIAFBGGo2AgAgASADNwMgIAEgAjcDKCABIAFBIGoQJQALuAEBAX8jAEHgAWsiAyQAIANBOGpBzAgoAgA2AgAgA0EwakHECCkCADcDACADQgA3AyAgA0G8CCkCADcDKCADQTxqQQBBxAAQKhogA0EgaiABIAIQCSADQYABaiADQSBqQeAAECgaIANBCGogA0GAAWoQCiADQSBqIANBCGpBFBADIANBiAFqIANBKGooAgA2AgAgAyADKQMgNwOAASADIANBgAFqEAsgACADKQMANwIAIANB4AFqJAALlwMBBH8jAEFAaiIDJAAgACAAKQMAIAKtfDcDACADIABBCGo2AiggAyADQShqNgIsAkACQAJAAkACQAJAIAAoAhwiBQRAQcAAIAVrIgQgAk0NASADQRhqIAUgBSACaiIEIABBIGoQFiADKAIcIAJHDQUgAygCGCABIAIQKBoMAwsgAiEEDAELIANBMGogASACIAQQFyADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQSBqIgYgACgCHBAYIAIgAygCJEcNBCADKAIgIAUgAhAoGiAAQRxqQQA2AgAgA0EsaiAGEBkLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAXIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAaIANBLGogAygCCBAZDAALAAsgA0EQaiAAQSBqIAQQGyADKAIUIARHDQEgAygCECABIAQQKBoLIABBHGogBDYCACADQUBrJAAPC0H0ExAHAAtB9BMQBwALQfQTEAcAC+MCAgR/AX4jAEFAaiICJAAgAiABQQhqIgU2AiQgASkDACEGIAEoAhwhAyACIAJBJGo2AigCQCADQT9NBEAgAUEgaiIEIANqQYABOgAAIAEgASgCHEEBaiIDNgIcIAJBGGogBCADEBggAigCGEEAIAIoAhwQKhpBwAAgASgCHGtBB00EQCACQShqIAQQGSACQRBqIAQgAUEcaigCABAbIAIoAhBBACACKAIUECoaCyACQQhqIARBOBAYIAIoAgxBCEcNASACKAIIIAZCA4Y3AAAgAkEoaiAEEBkgAUEcakEANgIAIAJBADYCKEEEIQECQANAIAFBGEYNASACQShqIAFqQQA6AAAgAiACKAIoQQFqNgIoIAFBAWohAQwACwALIAAgBSkAADcAACAAQRBqIAVBEGooAAA2AAAgAEEIaiAFQQhqKQAANwAAIAJBQGskAA8LQcwTIANBwAAQHQALQdwTEAcAC2MBAn8gASgCACECAkACQCABKAIEIgMgASgCCCIBRgRAIAMhAQwBCyADIAFJDQEgAQRAIAIgARATIgINAQALIAIgAxARQQEhAkEAIQELIAAgATYCBCAAIAI2AgAPC0G0ExAHAAuQAQEBfyMAQYABayIBJAAgAUEwakHECCkCADcDACABQThqQcwIKAIANgIAIAFCADcDICABQbwIKQIANwMoIAFBPGpBAEHEABAqGiABQRBqIAFBIGpB4AAQAyABQShqIAFBGGooAgA2AgAgASABKQMQNwMgIAFBCGogAUEgahALIAAgASkDCDcCACABQYABaiQAC4YB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";
const SECP256K1_FLAGS_TYPE_CONTEXT = 1 << 0;
const SECP256K1_FLAGS_TYPE_COMPRESSION = 1 << 1;
const SECP256K1_FLAGS_BIT_CONTEXT_VERIFY = 1 << 8;
const SECP256K1_FLAGS_BIT_CONTEXT_SIGN = 1 << 9;
const SECP256K1_FLAGS_BIT_COMPRESSION = 1 << 8;
const SECP256K1_CONTEXT_VERIFY = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY;
const SECP256K1_CONTEXT_SIGN = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN;
const SECP256K1_CONTEXT_NONE = SECP256K1_FLAGS_TYPE_CONTEXT;
const SECP256K1_EC_COMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION;
const SECP256K1_EC_UNCOMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION;
var ContextFlag;
(function(ContextFlag2) {
  ContextFlag2[ContextFlag2["NONE"] = SECP256K1_CONTEXT_NONE] = "NONE";
  ContextFlag2[ContextFlag2["VERIFY"] = SECP256K1_CONTEXT_VERIFY] = "VERIFY";
  ContextFlag2[ContextFlag2["SIGN"] = SECP256K1_CONTEXT_SIGN] = "SIGN";
  ContextFlag2[ContextFlag2["BOTH"] = SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY] = "BOTH";
})(ContextFlag || (ContextFlag = {}));
var CompressionFlag;
(function(CompressionFlag2) {
  CompressionFlag2[CompressionFlag2["COMPRESSED"] = SECP256K1_EC_COMPRESSED] = "COMPRESSED";
  CompressionFlag2[CompressionFlag2["UNCOMPRESSED"] = SECP256K1_EC_UNCOMPRESSED] = "UNCOMPRESSED";
})(CompressionFlag || (CompressionFlag = {}));
const secp256k1Base64Bytes = "AGFzbQEAAAABfBJgAn9/AGAGf39/f39/AX9gBH9/f38Bf2ADf39/AX9gAX8Bf2ABfwBgAAF/YAJ/fwF/YAAAYAV/f39/fwF/YAN/f38AYAh/f39/f39/fwF/YAR/f39/AGAFf39/f38AYAJ8fwF8YAN+f38Bf2ACfn8Bf2AGf3x/f39/AX8CoQIPA2VudgZtZW1vcnkCAYACgAIDZW52BXRhYmxlAXABEBADZW52CXRhYmxlQmFzZQN/AANlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudgVhYm9ydAAFA2Vudg1lbmxhcmdlTWVtb3J5AAYDZW52DmdldFRvdGFsTWVtb3J5AAYDZW52F2Fib3J0T25DYW5ub3RHcm93TWVtb3J5AAYDZW52C19fX3NldEVyck5vAAUDZW52DV9fX3N5c2NhbGwxNDAABwNlbnYNX19fc3lzY2FsbDE0NgAHA2VudgtfX19zeXNjYWxsNgAHA2VudgZfYWJvcnQACANlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwADA3FwAAQKAAMFCgoNAAoKDAUEAwoHAAcAAAQDAAoQCgANAwoJAAMABAcOBQQMCgcACgMACgwKAAwACwABAwoDAwMHAAMHAwYDBAQHBwoCAQECAgECAgECBwMDAwMDAwMHAQECAwMCAwICCQQCBAMREA8ABAYLAn8BIwELfwEjAgsH8wYcEV9fX2Vycm5vX2xvY2F0aW9uAE0FX2ZyZWUAMQdfbWFsbG9jADIZX3NlY3AyNTZrMV9jb250ZXh0X2NyZWF0ZQBQHF9zZWNwMjU2azFfY29udGV4dF9yYW5kb21pemUAXh9fc2VjcDI1NmsxX2VjX3ByaXZrZXlfdHdlYWtfYWRkAGMfX3NlY3AyNTZrMV9lY19wcml2a2V5X3R3ZWFrX211bABgG19zZWNwMjU2azFfZWNfcHVia2V5X2NyZWF0ZQBlGl9zZWNwMjU2azFfZWNfcHVia2V5X3BhcnNlAHIeX3NlY3AyNTZrMV9lY19wdWJrZXlfc2VyaWFsaXplAHAeX3NlY3AyNTZrMV9lY19wdWJrZXlfdHdlYWtfYWRkAGIeX3NlY3AyNTZrMV9lY19wdWJrZXlfdHdlYWtfbXVsAF8bX3NlY3AyNTZrMV9lY19zZWNrZXlfdmVyaWZ5AGYPX3NlY3AyNTZrMV9lY2RoAFwYX3NlY3AyNTZrMV9lY2RzYV9yZWNvdmVyAFg0X3NlY3AyNTZrMV9lY2RzYV9yZWNvdmVyYWJsZV9zaWduYXR1cmVfcGFyc2VfY29tcGFjdABbOF9zZWNwMjU2azFfZWNkc2FfcmVjb3ZlcmFibGVfc2lnbmF0dXJlX3NlcmlhbGl6ZV9jb21wYWN0AFoVX3NlY3AyNTZrMV9lY2RzYV9zaWduAGchX3NlY3AyNTZrMV9lY2RzYV9zaWduX3JlY292ZXJhYmxlAFkkX3NlY3AyNTZrMV9lY2RzYV9zaWduYXR1cmVfbm9ybWFsaXplAGooX3NlY3AyNTZrMV9lY2RzYV9zaWduYXR1cmVfcGFyc2VfY29tcGFjdABtJF9zZWNwMjU2azFfZWNkc2Ffc2lnbmF0dXJlX3BhcnNlX2RlcgBuLF9zZWNwMjU2azFfZWNkc2Ffc2lnbmF0dXJlX3NlcmlhbGl6ZV9jb21wYWN0AGsoX3NlY3AyNTZrMV9lY2RzYV9zaWduYXR1cmVfc2VyaWFsaXplX2RlcgBsF19zZWNwMjU2azFfZWNkc2FfdmVyaWZ5AGkaX3NlY3AyNTZrMV9zY2hub3Jyc2lnX3NpZ24AVRxfc2VjcDI1NmsxX3NjaG5vcnJzaWdfdmVyaWZ5AFQKc3RhY2tBbGxvYwB5CRYBACMACxBxT0NMTkNvXUJoVkJBSXhBCv7JCXDNBwIIfxV+IAEoAgQiAkEBdK0iEyABKAIgIgOtIgt+IAEoAgAiBEEBdK0iDyABKAIkrSIKfnwgASgCCCIFQQF0rSIWIAEoAhwiBq0iEX58IAEoAgwiB0EBdK0iGCABKAIYIgitIhR+fCABKAIQIglBAXStIhAgASgCFCIBrSIXfnwhGiAWIAt+IBMgCn58IBggEX58IBAgFH58IBcgF358IBpCGoh8IgxC////H4MiDUKQ+gB+IAStIg4gDn58IRsgDUIKhiACrSINIA9+fCAbQhqIfCAYIAt+IBYgCn58IBAgEX58IAFBAXStIg4gFH58IAxCGoh8IhlC////H4MiEkKQ+gB+fCEcIAWtIgwgD34gDSANfnwgEkIKhnwgFCAUfiAYIAp+fCAQIAt+fCAOIBF+fCAZQhqIfCIVQv///x+DIhJCkPoAfnwgHEIaiHwhGSAAIAetIg0gD34gDCATfnwgEkIKhnwgECAKfiAIQQF0rSISIBF+fCAOIAt+fCAVQhqIfCIVQv///x+DIh1CkPoAfnwgGUIaiHwiHqdB////H3E2AgwgACANIBN+IAwgDH58IAmtIhAgD358IB1CCoZ8IBIgC34gESARfnwgDiAKfnwgFUIaiHwiDkL///8fgyIMQpD6AH58IB5CGoh8IhWnQf///x9xNgIQIAAgECATfiANIBZ+fCAXIA9+fCAMQgqGfCASIAp+IAZBAXStIgwgC358IA5CGoh8Ig5C////H4MiEkKQ+gB+fCAVQhqIfCIVp0H///8fcTYCFCAAIBQgD34gDSANfnwgECAWfnwgFyATfnwgEkIKhnwgDCAKfiALIAt+fCAOQhqIfCINQv///x+DIg5CkPoAfnwgFUIaiHwiDKdB////H3E2AhggACAUIBN+IBEgD358IBAgGH58IBcgFn58IA5CCoZ8IA1CGoggA0EBdK0gCn58Ig1C////H4MiDkKQ+gB+fCAMQhqIfCIMp0H///8fcTYCHCAAIBEgE34gCyAPfnwgFCAWfnwgECAQfnwgFyAYfnwgDkIKhnwgDUIaiCAKIAp+fCIKQv///x+DIgtCkPoAfnwgDEIaiHwiD6dB////H3E2AiAgACAKQhqIIgpCkPoAfiAaQv///x+DfCALQgqGfCAPQhqIfCILp0H///8BcTYCJCAAIAtCFoggCkIOhnwiCkLRB34gG0L///8fg3wiC6dB////H3E2AgAgACAKQgaGIBxC////H4N8IAtCGoh8IgqnQf///x9xNgIEIAAgCkIaiCAZQv///x+DfD4CCAsrACAAQf8BcUEYdCAAQQh1Qf8BcUEQdHIgAEEQdUH/AXFBCHRyIABBGHZyC88JARt+IAIoAiCtIgMgASgCBK0iBH4gAigCJK0iBiABKAIArSIIfnwgAigCHK0iCSABKAIIrSIKfnwgAigCGK0iCyABKAIMrSIMfnwgAigCFK0iDSABKAIQrSIOfnwgAigCEK0iDyABKAIUrSIQfnwgAigCDK0iESABKAIYrSISfnwgAigCCK0iEyABKAIcrSIUfnwgAigCBK0iFSABKAIgrSIWfnwgAigCAK0iFyABKAIkrSIYfnwhHCAKIAN+IAQgBn58IAwgCX58IA4gC358IBAgDX58IBIgD358IBQgEX58IBYgE358IBggFX58IBxCGoh8IhtC////H4MiGkKQ+gB+IBcgCH58IR0gFyAEfiAVIAh+fCAaQgqGfCAdQhqIfCAMIAN+IAogBn58IA4gCX58IBAgC358IBIgDX58IBQgD358IBYgEX58IBggE358IBtCGoh8IhpC////H4MiBUKQ+gB+fCEbIBUgBH4gEyAIfnwgFyAKfnwgBUIKhnwgDiADfiAMIAZ+fCAQIAl+fCASIAt+fCAUIA1+fCAWIA9+fCAYIBF+fCAaQhqIfCIFQv///x+DIgdCkPoAfnwgG0IaiHwhGiAAIBMgBH4gESAIfnwgFSAKfnwgFyAMfnwgB0IKhnwgECADfiAOIAZ+fCASIAl+fCAUIAt+fCAWIA1+fCAYIA9+fCAFQhqIfCIFQv///x+DIgdCkPoAfnwgGkIaiHwiGadB////H3E2AgwgACARIAR+IA8gCH58IBMgCn58IBUgDH58IBcgDn58IAdCCoZ8IBIgA34gECAGfnwgFCAJfnwgFiALfnwgGCANfnwgBUIaiHwiBUL///8fgyIHQpD6AH58IBlCGoh8IhmnQf///x9xNgIQIAAgDyAEfiANIAh+fCARIAp+fCATIAx+fCAVIA5+fCAXIBB+fCAHQgqGfCAUIAN+IBIgBn58IBYgCX58IBggC358IAVCGoh8IgVC////H4MiB0KQ+gB+fCAZQhqIfCIZp0H///8fcTYCFCAAIA0gBH4gCyAIfnwgDyAKfnwgESAMfnwgEyAOfnwgFSAQfnwgFyASfnwgB0IKhnwgFiADfiAUIAZ+fCAYIAl+fCAFQhqIfCIFQv///x+DIgdCkPoAfnwgGUIaiHwiGadB////H3E2AhggACALIAR+IAkgCH58IA0gCn58IA8gDH58IBEgDn58IBMgEH58IBUgEn58IBcgFH58IAdCCoZ8IBggA34gFiAGfnwgBUIaiHwiBUL///8fgyIHQpD6AH58IBlCGoh8IhmnQf///x9xNgIcIAAgCSAEfiADIAh+fCALIAp+fCANIAx+fCAPIA5+fCARIBB+fCATIBJ+fCAVIBR+fCAXIBZ+fCAHQgqGfCAFQhqIIBggBn58IgNC////H4MiBEKQ+gB+fCAZQhqIfCIGp0H///8fcTYCICAAIANCGogiA0KQ+gB+IBxC////H4N8IARCCoZ8IAZCGoh8IgSnQf///wFxNgIkIAAgBEIWiCADQg6GfCIDQtEHfiAdQv///x+DfCIEp0H///8fcTYCACAAIANCBoYgG0L///8fg3wgBEIaiHwiA6dB////H3E2AgQgACADQhqIIBpC////H4N8PgIIC79WASR/IAAoAgAhHSAAQQRqIh4oAgAhCSAAQQhqIh8oAgAhBSAAQQxqIiAoAgAhDyAAQRxqIiEoAgBBmN+olARqIABBEGoiIigCACICQQZ2IAJBGnRyIAJBC3YgAkEVdHJzIAJBGXYgAkEHdHJzaiAAQRhqIiMoAgAiBiAAQRRqIiQoAgAiCnMgAnEgBnNqIAEoAgAQCyIXaiIHIA9qIQ8gBkGRid2JB2ogASgCBBALIhVqIA8gCiACc3EgCnNqIA9BBnYgD0EadHIgD0ELdiAPQRV0cnMgD0EZdiAPQQd0cnNqIhIgBWohBiAKQc/3g657aiABKAIIEAsiGGogBiAPIAJzcSACc2ogBkEGdiAGQRp0ciAGQQt2IAZBFXRycyAGQRl2IAZBB3Ryc2oiFCAJaiEKIAJBpbfXzX5qIAEoAgwQCyIWaiAKIAYgD3NxIA9zaiAKQQZ2IApBGnRyIApBC3YgCkEVdHJzIApBGXYgCkEHdHJzaiICIB1qIQMgHUECdiAdQR50ciAdQQ12IB1BE3RycyAdQRZ2IB1BCnRycyAFIAkgHXJxIAkgHXFyaiAHaiIFQQJ2IAVBHnRyIAVBDXYgBUETdHJzIAVBFnYgBUEKdHJzIAUgHXIgCXEgBSAdcXJqIBJqIglBAnYgCUEedHIgCUENdiAJQRN0cnMgCUEWdiAJQQp0cnMgCSAFciAdcSAJIAVxcmogFGoiB0ECdiAHQR50ciAHQQ12IAdBE3RycyAHQRZ2IAdBCnRycyAHIAlyIAVxIAcgCXFyaiACaiECIA9B24TbygNqIAEoAhAQCyIZaiADIAogBnNxIAZzaiADQQZ2IANBGnRyIANBC3YgA0EVdHJzIANBGXYgA0EHdHJzaiISIAVqIQ8gASgCFBALIhBB8aPEzwVqIAZqIA8gAyAKc3EgCnNqIA9BBnYgD0EadHIgD0ELdiAPQRV0cnMgD0EZdiAPQQd0cnNqIhQgCWohBiABKAIYEAsiCEGkhf6ReWogCmogBiAPIANzcSADc2ogBkEGdiAGQRp0ciAGQQt2IAZBFXRycyAGQRl2IAZBB3Ryc2oiEyAHaiEKIAEoAhwQCyILQdW98dh6aiADaiAKIAYgD3NxIA9zaiAKQQZ2IApBGnRyIApBC3YgCkEVdHJzIApBGXYgCkEHdHJzaiIEIAJqIQMgAkECdiACQR50ciACQQ12IAJBE3RycyACQRZ2IAJBCnRycyACIAdyIAlxIAIgB3FyaiASaiIFQQJ2IAVBHnRyIAVBDXYgBUETdHJzIAVBFnYgBUEKdHJzIAUgAnIgB3EgBSACcXJqIBRqIglBAnYgCUEedHIgCUENdiAJQRN0cnMgCUEWdiAJQQp0cnMgCSAFciACcSAJIAVxcmogE2oiB0ECdiAHQR50ciAHQQ12IAdBE3RycyAHQRZ2IAdBCnRycyAHIAlyIAVxIAcgCXFyaiAEaiECIAEoAiAQCyIOQZjVnsB9aiAPaiADIAogBnNxIAZzaiADQQZ2IANBGnRyIANBC3YgA0EVdHJzIANBGXYgA0EHdHJzaiISIAVqIQ8gASgCJBALIgxBgbaNlAFqIAZqIA8gAyAKc3EgCnNqIA9BBnYgD0EadHIgD0ELdiAPQRV0cnMgD0EZdiAPQQd0cnNqIhQgCWohBiABKAIoEAsiDUG+i8ahAmogCmogBiAPIANzcSADc2ogBkEGdiAGQRp0ciAGQQt2IAZBFXRycyAGQRl2IAZBB3Ryc2oiEyAHaiEKIAEoAiwQCyIRQcP7sagFaiADaiAKIAYgD3NxIA9zaiAKQQZ2IApBGnRyIApBC3YgCkEVdHJzIApBGXYgCkEHdHJzaiIEIAJqIQMgAkECdiACQR50ciACQQ12IAJBE3RycyACQRZ2IAJBCnRycyACIAdyIAlxIAIgB3FyaiASaiIFQQJ2IAVBHnRyIAVBDXYgBUETdHJzIAVBFnYgBUEKdHJzIAUgAnIgB3EgBSACcXJqIBRqIglBAnYgCUEedHIgCUENdiAJQRN0cnMgCUEWdiAJQQp0cnMgCSAFciACcSAJIAVxcmogE2oiB0ECdiAHQR50ciAHQQ12IAdBE3RycyAHQRZ2IAdBCnRycyAHIAlyIAVxIAcgCXFyaiAEaiECIAEoAjAQCyIaQfS6+ZUHaiAPaiADIAogBnNxIAZzaiADQQZ2IANBGnRyIANBC3YgA0EVdHJzIANBGXYgA0EHdHJzaiIEIAVqIQUgASgCNBALIhtB/uP6hnhqIAZqIAUgAyAKc3EgCnNqIAVBBnYgBUEadHIgBUELdiAFQRV0cnMgBUEZdiAFQQd0cnNqIgYgCWohEiABKAI4EAsiD0GnjfDeeWogCmogEiAFIANzcSADc2ogEkEGdiASQRp0ciASQQt2IBJBFXRycyASQRl2IBJBB3Ryc2oiCiAHaiEUIAEoAjwQCyIBQfTi74x8aiADaiAUIBIgBXNxIAVzaiAUQQZ2IBRBGnRyIBRBC3YgFEEVdHJzIBRBGXYgFEEHdHJzaiIcIAJqIRMgAkECdiACQR50ciACQQ12IAJBE3RycyACQRZ2IAJBCnRycyACIAdyIAlxIAIgB3FyaiAEaiIDQQJ2IANBHnRyIANBDXYgA0ETdHJzIANBFnYgA0EKdHJzIAMgAnIgB3EgAyACcXJqIAZqIglBAnYgCUEedHIgCUENdiAJQRN0cnMgCUEWdiAJQQp0cnMgCSADciACcSAJIANxcmogCmoiB0ECdiAHQR50ciAHQQ12IAdBE3RycyAHQRZ2IAdBCnRycyAHIAlyIANxIAcgCXFyaiAcaiECIBhBEnYgGEEOdHIgGEEDdnMgGEEHdiAYQRl0cnMgFWogDWogAUETdiABQQ10ciABQQp2cyABQRF2IAFBD3Ryc2oiBkGGj/n9fmogEmogFUESdiAVQQ50ciAVQQN2cyAVQQd2IBVBGXRycyAXaiAMaiAPQRN2IA9BDXRyIA9BCnZzIA9BEXYgD0EPdHJzaiIKQcHT7aR+aiAFaiATIBQgEnNxIBJzaiATQQZ2IBNBGnRyIBNBC3YgE0EVdHJzIBNBGXYgE0EHdHJzaiIVIANqIhcgEyAUc3EgFHNqIBdBBnYgF0EadHIgF0ELdiAXQRV0cnMgF0EZdiAXQQd0cnNqIgQgCWohEiAZQRJ2IBlBDnRyIBlBA3ZzIBlBB3YgGUEZdHJzIBZqIBpqIAZBE3YgBkENdHIgBkEKdnMgBkERdiAGQQ90cnNqIgNBzMOyoAJqIBNqIBZBEnYgFkEOdHIgFkEDdnMgFkEHdiAWQRl0cnMgGGogEWogCkETdiAKQQ10ciAKQQp2cyAKQRF2IApBD3Ryc2oiBUHGu4b+AGogFGogEiAXIBNzcSATc2ogEkEGdiASQRp0ciASQQt2IBJBFXRycyASQRl2IBJBB3Ryc2oiGCAHaiIWIBIgF3NxIBdzaiAWQQZ2IBZBGnRyIBZBC3YgFkEVdHJzIBZBGXYgFkEHdHJzaiIcIAJqIRMgAkECdiACQR50ciACQQ12IAJBE3RycyACQRZ2IAJBCnRycyACIAdyIAlxIAIgB3FyaiAVaiIUQQJ2IBRBHnRyIBRBDXYgFEETdHJzIBRBFnYgFEEKdHJzIBQgAnIgB3EgFCACcXJqIARqIhVBAnYgFUEedHIgFUENdiAVQRN0cnMgFUEWdiAVQQp0cnMgFSAUciACcSAVIBRxcmogGGoiGEECdiAYQR50ciAYQQ12IBhBE3RycyAYQRZ2IBhBCnRycyAYIBVyIBRxIBggFXFyaiAcaiECIAhBEnYgCEEOdHIgCEEDdnMgCEEHdiAIQRl0cnMgEGogD2ogA0ETdiADQQ10ciADQQp2cyADQRF2IANBD3Ryc2oiCUGqidLTBGogEmogEEESdiAQQQ50ciAQQQN2cyAQQQd2IBBBGXRycyAZaiAbaiAFQRN2IAVBDXRyIAVBCnZzIAVBEXYgBUEPdHJzaiIHQe/YpO8CaiAXaiATIBYgEnNxIBJzaiATQQZ2IBNBGnRyIBNBC3YgE0EVdHJzIBNBGXYgE0EHdHJzaiIZIBRqIgQgEyAWc3EgFnNqIARBBnYgBEEadHIgBEELdiAEQRV0cnMgBEEZdiAEQQd0cnNqIhAgFWohFyAOQRJ2IA5BDnRyIA5BA3ZzIA5BB3YgDkEZdHJzIAtqIApqIAlBE3YgCUENdHIgCUEKdnMgCUERdiAJQQ90cnNqIhJB2pHmtwdqIBNqIAtBEnYgC0EOdHIgC0EDdnMgC0EHdiALQRl0cnMgCGogAWogB0ETdiAHQQ10ciAHQQp2cyAHQRF2IAdBD3Ryc2oiFEHc08LlBWogFmogFyAEIBNzcSATc2ogF0EGdiAXQRp0ciAXQQt2IBdBFXRycyAXQRl2IBdBB3Ryc2oiEyAYaiILIBcgBHNxIARzaiALQQZ2IAtBGnRyIAtBC3YgC0EVdHJzIAtBGXYgC0EHdHJzaiIcIAJqIRYgAkECdiACQR50ciACQQ12IAJBE3RycyACQRZ2IAJBCnRycyACIBhyIBVxIAIgGHFyaiAZaiIZQQJ2IBlBHnRyIBlBDXYgGUETdHJzIBlBFnYgGUEKdHJzIBkgAnIgGHEgGSACcXJqIBBqIhBBAnYgEEEedHIgEEENdiAQQRN0cnMgEEEWdiAQQQp0cnMgECAZciACcSAQIBlxcmogE2oiCEECdiAIQR50ciAIQQ12IAhBE3RycyAIQRZ2IAhBCnRycyAIIBByIBlxIAggEHFyaiAcaiECIA1BEnYgDUEOdHIgDUEDdnMgDUEHdiANQRl0cnMgDGogBWogEkETdiASQQ10ciASQQp2cyASQRF2IBJBD3Ryc2oiE0HtjMfBemogF2ogDEESdiAMQQ50ciAMQQN2cyAMQQd2IAxBGXRycyAOaiAGaiAUQRN2IBRBDXRyIBRBCnZzIBRBEXYgFEEPdHJzaiIVQdKi+cF5aiAEaiAWIAsgF3NxIBdzaiAWQQZ2IBZBGnRyIBZBC3YgFkEVdHJzIBZBGXYgFkEHdHJzaiIMIBlqIg4gFiALc3EgC3NqIA5BBnYgDkEadHIgDkELdiAOQRV0cnMgDkEZdiAOQQd0cnNqIhkgEGohBCAaQRJ2IBpBDnRyIBpBA3ZzIBpBB3YgGkEZdHJzIBFqIAdqIBNBE3YgE0ENdHIgE0EKdnMgE0ERdiATQQ90cnNqIhhBx//l+ntqIBZqIBFBEnYgEUEOdHIgEUEDdnMgEUEHdiARQRl0cnMgDWogA2ogFUETdiAVQQ10ciAVQQp2cyAVQRF2IBVBD3Ryc2oiF0HIz4yAe2ogC2ogBCAOIBZzcSAWc2ogBEEGdiAEQRp0ciAEQQt2IARBFXRycyAEQRl2IARBB3Ryc2oiFiAIaiINIAQgDnNxIA5zaiANQQZ2IA1BGnRyIA1BC3YgDUEVdHJzIA1BGXYgDUEHdHJzaiIRIAJqIQsgAkECdiACQR50ciACQQ12IAJBE3RycyACQRZ2IAJBCnRycyACIAhyIBBxIAIgCHFyaiAMaiIQQQJ2IBBBHnRyIBBBDXYgEEETdHJzIBBBFnYgEEEKdHJzIBAgAnIgCHEgECACcXJqIBlqIghBAnYgCEEedHIgCEENdiAIQRN0cnMgCEEWdiAIQQp0cnMgCCAQciACcSAIIBBxcmogFmoiDEECdiAMQR50ciAMQQ12IAxBE3RycyAMQRZ2IAxBCnRycyAMIAhyIBBxIAwgCHFyaiARaiECIA9BEnYgD0EOdHIgD0EDdnMgD0EHdiAPQRl0cnMgG2ogFGogGEETdiAYQQ10ciAYQQp2cyAYQRF2IBhBD3Ryc2oiFkHHop6tfWogBGogG0ESdiAbQQ50ciAbQQN2cyAbQQd2IBtBGXRycyAaaiAJaiAXQRN2IBdBDXRyIBdBCnZzIBdBEXYgF0EPdHJzaiIZQfOXgLd8aiAOaiALIA0gBHNxIARzaiALQQZ2IAtBGnRyIAtBC3YgC0EVdHJzIAtBGXYgC0EHdHJzaiIOIBBqIhEgCyANc3EgDXNqIBFBBnYgEUEadHIgEUELdiARQRV0cnMgEUEZdiARQQd0cnNqIhogCGohBCAKQRJ2IApBDnRyIApBA3ZzIApBB3YgCkEZdHJzIAFqIBVqIBZBE3YgFkENdHIgFkEKdnMgFkERdiAWQQ90cnNqIhBB59KkoQFqIAtqIAFBEnYgAUEOdHIgAUEDdnMgAUEHdiABQRl0cnMgD2ogEmogGUETdiAZQQ10ciAZQQp2cyAZQRF2IBlBD3Ryc2oiAUHRxqk2aiANaiAEIBEgC3NxIAtzaiAEQQZ2IARBGnRyIARBC3YgBEEVdHJzIARBGXYgBEEHdHJzaiIPIAxqIg0gBCARc3EgEXNqIA1BBnYgDUEadHIgDUELdiANQRV0cnMgDUEZdiANQQd0cnNqIhsgAmohCyACQQJ2IAJBHnRyIAJBDXYgAkETdHJzIAJBFnYgAkEKdHJzIAIgDHIgCHEgAiAMcXJqIA5qIghBAnYgCEEedHIgCEENdiAIQRN0cnMgCEEWdiAIQQp0cnMgCCACciAMcSAIIAJxcmogGmoiDEECdiAMQR50ciAMQQ12IAxBE3RycyAMQRZ2IAxBCnRycyAMIAhyIAJxIAwgCHFyaiAPaiIOQQJ2IA5BHnRyIA5BDXYgDkETdHJzIA5BFnYgDkEKdHJzIA4gDHIgCHEgDiAMcXJqIBtqIQIgBUESdiAFQQ50ciAFQQN2cyAFQQd2IAVBGXRycyAGaiAXaiAQQRN2IBBBDXRyIBBBCnZzIBBBEXYgEEEPdHJzaiIPQbjC7PACaiAEaiAGQRJ2IAZBDnRyIAZBA3ZzIAZBB3YgBkEZdHJzIApqIBNqIAFBE3YgAUENdHIgAUEKdnMgAUERdiABQQ90cnNqIgZBhZXcvQJqIBFqIAsgDSAEc3EgBHNqIAtBBnYgC0EadHIgC0ELdiALQRV0cnMgC0EZdiALQQd0cnNqIhogCGoiESALIA1zcSANc2ogEUEGdiARQRp0ciARQQt2IBFBFXRycyARQRl2IBFBB3Ryc2oiGyAMaiEIIAdBEnYgB0EOdHIgB0EDdnMgB0EHdiAHQRl0cnMgA2ogGWogD0ETdiAPQQ10ciAPQQp2cyAPQRF2IA9BD3Ryc2oiCkGTmuCZBWogC2ogA0ESdiADQQ50ciADQQN2cyADQQd2IANBGXRycyAFaiAYaiAGQRN2IAZBDXRyIAZBCnZzIAZBEXYgBkEPdHJzaiIDQfzbsekEaiANaiAIIBEgC3NxIAtzaiAIQQZ2IAhBGnRyIAhBC3YgCEEVdHJzIAhBGXYgCEEHdHJzaiIFIA5qIg0gCCARc3EgEXNqIA1BBnYgDUEadHIgDUELdiANQRV0cnMgDUEZdiANQQd0cnNqIhwgAmohBCACQQJ2IAJBHnRyIAJBDXYgAkETdHJzIAJBFnYgAkEKdHJzIAIgDnIgDHEgAiAOcXJqIBpqIgtBAnYgC0EedHIgC0ENdiALQRN0cnMgC0EWdiALQQp0cnMgCyACciAOcSALIAJxcmogG2oiDEECdiAMQR50ciAMQQ12IAxBE3RycyAMQRZ2IAxBCnRycyAMIAtyIAJxIAwgC3FyaiAFaiIOQQJ2IA5BHnRyIA5BDXYgDkETdHJzIA5BFnYgDkEKdHJzIA4gDHIgC3EgDiAMcXJqIBxqIQIgFEESdiAUQQ50ciAUQQN2cyAUQQd2IBRBGXRycyAJaiABaiAKQRN2IApBDXRyIApBCnZzIApBEXYgCkEPdHJzaiIFQbuVqLMHaiAIaiAJQRJ2IAlBDnRyIAlBA3ZzIAlBB3YgCUEZdHJzIAdqIBZqIANBE3YgA0ENdHIgA0EKdnMgA0ERdiADQQ90cnNqIglB1OapqAZqIBFqIAQgDSAIc3EgCHNqIARBBnYgBEEadHIgBEELdiAEQRV0cnMgBEEZdiAEQQd0cnNqIhogC2oiESAEIA1zcSANc2ogEUEGdiARQRp0ciARQQt2IBFBFXRycyARQRl2IBFBB3Ryc2oiGyAMaiEIIBVBEnYgFUEOdHIgFUEDdnMgFUEHdiAVQRl0cnMgEmogBmogBUETdiAFQQ10ciAFQQp2cyAFQRF2IAVBD3Ryc2oiB0GF2ciTeWogBGogEkESdiASQQ50ciASQQN2cyASQQd2IBJBGXRycyAUaiAQaiAJQRN2IAlBDXRyIAlBCnZzIAlBEXYgCUEPdHJzaiISQa6Si454aiANaiAIIBEgBHNxIARzaiAIQQZ2IAhBGnRyIAhBC3YgCEEVdHJzIAhBGXYgCEEHdHJzaiIUIA5qIg0gCCARc3EgEXNqIA1BBnYgDUEadHIgDUELdiANQRV0cnMgDUEZdiANQQd0cnNqIhwgAmohBCACQQJ2IAJBHnRyIAJBDXYgAkETdHJzIAJBFnYgAkEKdHJzIAIgDnIgDHEgAiAOcXJqIBpqIgtBAnYgC0EedHIgC0ENdiALQRN0cnMgC0EWdiALQQp0cnMgCyACciAOcSALIAJxcmogG2oiDEECdiAMQR50ciAMQQ12IAxBE3RycyAMQRZ2IAxBCnRycyAMIAtyIAJxIAwgC3FyaiAUaiIOQQJ2IA5BHnRyIA5BDXYgDkETdHJzIA5BFnYgDkEKdHJzIA4gDHIgC3EgDiAMcXJqIBxqIQIgF0ESdiAXQQ50ciAXQQN2cyAXQQd2IBdBGXRycyATaiADaiAHQRN2IAdBDXRyIAdBCnZzIAdBEXYgB0EPdHJzaiIUQcvM6cB6aiAIaiATQRJ2IBNBDnRyIBNBA3ZzIBNBB3YgE0EZdHJzIBVqIA9qIBJBE3YgEkENdHIgEkEKdnMgEkERdiASQQ90cnNqIhNBodH/lXpqIBFqIAQgDSAIc3EgCHNqIARBBnYgBEEadHIgBEELdiAEQRV0cnMgBEEZdiAEQQd0cnNqIhogC2oiESAEIA1zcSANc2ogEUEGdiARQRp0ciARQQt2IBFBFXRycyARQRl2IBFBB3Ryc2oiGyAMaiEIIBlBEnYgGUEOdHIgGUEDdnMgGUEHdiAZQRl0cnMgGGogCWogFEETdiAUQQ10ciAUQQp2cyAUQRF2IBRBD3Ryc2oiFUGjo7G7fGogBGogGEESdiAYQQ50ciAYQQN2cyAYQQd2IBhBGXRycyAXaiAKaiATQRN2IBNBDXRyIBNBCnZzIBNBEXYgE0EPdHJzaiIYQfCWrpJ8aiANaiAIIBEgBHNxIARzaiAIQQZ2IAhBGnRyIAhBC3YgCEEVdHJzIAhBGXYgCEEHdHJzaiIXIA5qIg0gCCARc3EgEXNqIA1BBnYgDUEadHIgDUELdiANQRV0cnMgDUEZdiANQQd0cnNqIhwgAmohBCACQQJ2IAJBHnRyIAJBDXYgAkETdHJzIAJBFnYgAkEKdHJzIAIgDnIgDHEgAiAOcXJqIBpqIgtBAnYgC0EedHIgC0ENdiALQRN0cnMgC0EWdiALQQp0cnMgCyACciAOcSALIAJxcmogG2oiDEECdiAMQR50ciAMQQ12IAxBE3RycyAMQRZ2IAxBCnRycyAMIAtyIAJxIAwgC3FyaiAXaiIOQQJ2IA5BHnRyIA5BDXYgDkETdHJzIA5BFnYgDkEKdHJzIA4gDHIgC3EgDiAMcXJqIBxqIQIgAUESdiABQQ50ciABQQN2cyABQQd2IAFBGXRycyAWaiASaiAVQRN2IBVBDXRyIBVBCnZzIBVBEXYgFUEPdHJzaiIXQaSM5LR9aiAIaiAWQRJ2IBZBDnRyIBZBA3ZzIBZBB3YgFkEZdHJzIBlqIAVqIBhBE3YgGEENdHIgGEEKdnMgGEERdiAYQQ90cnNqIhZBmdDLjH1qIBFqIAQgDSAIc3EgCHNqIARBBnYgBEEadHIgBEELdiAEQRV0cnMgBEEZdiAEQQd0cnNqIhogC2oiESAEIA1zcSANc2ogEUEGdiARQRp0ciARQQt2IBFBFXRycyARQRl2IBFBB3Ryc2oiCyAMaiEIIAZBEnYgBkEOdHIgBkEDdnMgBkEHdiAGQRl0cnMgEGogE2ogF0ETdiAXQQ10ciAXQQp2cyAXQRF2IBdBD3Ryc2oiGUHwwKqDAWogBGogEEESdiAQQQ50ciAQQQN2cyAQQQd2IBBBGXRycyABaiAHaiAWQRN2IBZBDXRyIBZBCnZzIBZBEXYgFkEPdHJzaiIBQYXruKB/aiANaiAIIBEgBHNxIARzaiAIQQZ2IAhBGnRyIAhBC3YgCEEVdHJzIAhBGXYgCEEHdHJzaiIbIA5qIg0gCCARc3EgEXNqIA1BBnYgDUEadHIgDUELdiANQRV0cnMgDUEZdiANQQd0cnNqIhwgAmohECACQQJ2IAJBHnRyIAJBDXYgAkETdHJzIAJBFnYgAkEKdHJzIAIgDnIgDHEgAiAOcXJqIBpqIgRBAnYgBEEedHIgBEENdiAEQRN0cnMgBEEWdiAEQQp0cnMgBCACciAOcSAEIAJxcmogC2oiC0ECdiALQR50ciALQQ12IAtBE3RycyALQRZ2IAtBCnRycyALIARyIAJxIAsgBHFyaiAbaiIMQQJ2IAxBHnRyIAxBDXYgDEETdHJzIAxBFnYgDEEKdHJzIAwgC3IgBHEgDCALcXJqIBxqIQIgA0ESdiADQQ50ciADQQN2cyADQQd2IANBGXRycyAPaiAYaiAZQRN2IBlBDXRyIBlBCnZzIBlBEXYgGUEPdHJzaiIaQYjY3fEBaiAIaiAPQRJ2IA9BDnRyIA9BA3ZzIA9BB3YgD0EZdHJzIAZqIBRqIAFBE3YgAUENdHIgAUEKdnMgAUERdiABQQ90cnNqIg9BloKTzQFqIBFqIBAgDSAIc3EgCHNqIBBBBnYgEEEadHIgEEELdiAQQRV0cnMgEEEZdiAQQQd0cnNqIgggBGoiBCAQIA1zcSANc2ogBEEGdiAEQRp0ciAEQQt2IARBFXRycyAEQRl2IARBB3Ryc2oiHCALaiEGIAlBEnYgCUEOdHIgCUEDdnMgCUEHdiAJQRl0cnMgCmogFmogGkETdiAaQQ10ciAaQQp2cyAaQRF2IBpBD3Ryc2oiEUG1+cKlA2ogEGogCkESdiAKQQ50ciAKQQN2cyAKQQd2IApBGXRycyADaiAVaiAPQRN2IA9BDXRyIA9BCnZzIA9BEXYgD0EPdHJzaiIbQczuoboCaiANaiAGIAQgEHNxIBBzaiAGQQZ2IAZBGnRyIAZBC3YgBkEVdHJzIAZBGXYgBkEHdHJzaiINIAxqIg4gBiAEc3EgBHNqIA5BBnYgDkEadHIgDkELdiAOQRV0cnMgDkEZdiAOQQd0cnNqIiUgAmohCiACQQJ2IAJBHnRyIAJBDXYgAkETdHJzIAJBFnYgAkEKdHJzIAIgDHIgC3EgAiAMcXJqIAhqIgNBAnYgA0EedHIgA0ENdiADQRN0cnMgA0EWdiADQQp0cnMgAyACciAMcSADIAJxcmogHGoiEEECdiAQQR50ciAQQQ12IBBBE3RycyAQQRZ2IBBBCnRycyAQIANyIAJxIBAgA3FyaiANaiIIQQJ2IAhBHnRyIAhBDXYgCEETdHJzIAhBFnYgCEEKdHJzIAggEHIgA3EgCCAQcXJqICVqIQIgEkESdiASQQ50ciASQQN2cyASQQd2IBJBGXRycyAFaiABaiARQRN2IBFBDXRyIBFBCnZzIBFBEXYgEUEPdHJzaiILQcrU4vYEaiAGaiAFQRJ2IAVBDnRyIAVBA3ZzIAVBB3YgBUEZdHJzIAlqIBdqIBtBE3YgG0ENdHIgG0EKdnMgG0ERdiAbQQ90cnNqIgxBs5nwyANqIARqIAogDiAGc3EgBnNqIApBBnYgCkEadHIgCkELdiAKQRV0cnMgCkEZdiAKQQd0cnNqIgUgA2oiBCAKIA5zcSAOc2ogBEEGdiAEQRp0ciAEQQt2IARBFXRycyAEQRl2IARBB3Ryc2oiCSAQaiEGIBNBEnYgE0EOdHIgE0EDdnMgE0EHdiATQRl0cnMgB2ogD2ogC0ETdiALQQ10ciALQQp2cyALQRF2IAtBD3Ryc2oiDUHz37nBBmogCmogB0ESdiAHQQ50ciAHQQN2cyAHQQd2IAdBGXRycyASaiAZaiAMQRN2IAxBDXRyIAxBCnZzIAxBEXYgDEEPdHJzaiIcQc+U89wFaiAOaiAGIAQgCnNxIApzaiAGQQZ2IAZBGnRyIAZBC3YgBkEVdHJzIAZBGXYgBkEHdHJzaiISIAhqIgcgBiAEc3EgBHNqIAdBBnYgB0EadHIgB0ELdiAHQRV0cnMgB0EZdiAHQQd0cnNqIg4gAmohCiACQQJ2IAJBHnRyIAJBDXYgAkETdHJzIAJBFnYgAkEKdHJzIAIgCHIgEHEgAiAIcXJqIAVqIgNBAnYgA0EedHIgA0ENdiADQRN0cnMgA0EWdiADQQp0cnMgAyACciAIcSADIAJxcmogCWoiBUECdiAFQR50ciAFQQ12IAVBE3RycyAFQRZ2IAVBCnRycyAFIANyIAJxIAUgA3FyaiASaiIJQQJ2IAlBHnRyIAlBDXYgCUETdHJzIAlBFnYgCUEKdHJzIAkgBXIgA3EgCSAFcXJqIA5qIQIgGEESdiAYQQ50ciAYQQN2cyAYQQd2IBhBGXRycyAUaiAbaiANQRN2IA1BDXRyIA1BCnZzIA1BEXYgDUEPdHJzaiIQQe/GlcUHaiAGaiAUQRJ2IBRBDnRyIBRBA3ZzIBRBB3YgFEEZdHJzIBNqIBpqIBxBE3YgHEENdHIgHEEKdnMgHEERdiAcQQ90cnNqIhRB7oW+pAdqIARqIAogByAGc3EgBnNqIApBBnYgCkEadHIgCkELdiAKQRV0cnMgCkEZdiAKQQd0cnNqIgggA2oiEiAKIAdzcSAHc2ogEkEGdiASQRp0ciASQQt2IBJBFXRycyASQRl2IBJBB3Ryc2oiBCAFaiEGIBZBEnYgFkEOdHIgFkEDdnMgFkEHdiAWQRl0cnMgFWogDGogEEETdiAQQQ10ciAQQQp2cyAQQRF2IBBBD3Ryc2oiE0GIhJzmeGogCmogFUESdiAVQQ50ciAVQQN2cyAVQQd2IBVBGXRycyAYaiARaiAUQRN2IBRBDXRyIBRBCnZzIBRBEXYgFEEPdHJzaiIVQZTwoaZ4aiAHaiAGIBIgCnNxIApzaiAGQQZ2IAZBGnRyIAZBC3YgBkEVdHJzIAZBGXYgBkEHdHJzaiIYIAlqIgcgBiASc3EgEnNqIAdBBnYgB0EadHIgB0ELdiAHQRV0cnMgB0EZdiAHQQd0cnNqIhAgAmohCiACQQJ2IAJBHnRyIAJBDXYgAkETdHJzIAJBFnYgAkEKdHJzIAIgCXIgBXEgAiAJcXJqIAhqIgNBAnYgA0EedHIgA0ENdiADQRN0cnMgA0EWdiADQQp0cnMgAyACciAJcSADIAJxcmogBGoiBUECdiAFQR50ciAFQQ12IAVBE3RycyAFQRZ2IAVBCnRycyAFIANyIAJxIAUgA3FyaiAYaiIJQQJ2IAlBHnRyIAlBDXYgCUETdHJzIAlBFnYgCUEKdHJzIAkgBXIgA3EgCSAFcXJqIBBqIQIgAUESdiABQQ50ciABQQN2cyABQQd2IAFBGXRycyAXaiAcaiATQRN2IBNBDXRyIBNBCnZzIBNBEXYgE0EPdHJzaiITQevZwaJ6aiAGaiAXQRJ2IBdBDnRyIBdBA3ZzIBdBB3YgF0EZdHJzIBZqIAtqIBVBE3YgFUENdHIgFUEKdnMgFUERdiAVQQ90cnNqIhVB+v/7hXlqIBJqIAogByAGc3EgBnNqIApBBnYgCkEadHIgCkELdiAKQRV0cnMgCkEZdiAKQQd0cnNqIhIgA2oiBiAKIAdzcSAHc2ogBkEGdiAGQRp0ciAGQQt2IAZBFXRycyAGQRl2IAZBB3Ryc2oiGCAFaiEDIAFB98fm93tqIBlBEnYgGUEOdHIgGUEDdnMgGUEHdiAZQRl0cnNqIA1qIBVBE3YgFUENdHIgFUEKdnMgFUERdiAVQQ90cnNqIAdqIAMgBiAKc3EgCnNqIANBBnYgA0EadHIgA0ELdiADQRV0cnMgA0EZdiADQQd0cnNqIhUgCWohByAAIAJBAnYgAkEedHIgAkENdiACQRN0cnMgAkEWdiACQQp0cnMgAiAJciAFcSACIAlxcmogEmoiAEECdiAAQR50ciAAQQ12IABBE3RycyAAQRZ2IABBCnRycyAAIAJyIAlxIAAgAnFyaiAYaiIBQQJ2IAFBHnRyIAFBDXYgAUETdHJzIAFBFnYgAUEKdHJzIAEgAHIgAnEgASAAcXJqIBVqIgUgAXIgAHEgBSABcXIgHWogBUECdiAFQR50ciAFQQ12IAVBE3RycyAFQRZ2IAVBCnRyc2ogGUHy8cWzfGogD0ESdiAPQQ50ciAPQQN2cyAPQQd2IA9BGXRyc2ogFGogE0ETdiATQQ10ciATQQp2cyATQRF2IBNBD3Ryc2ogCmogByADIAZzcSAGc2ogB0EGdiAHQRp0ciAHQQt2IAdBFXRycyAHQRl2IAdBB3Ryc2oiHWo2AgAgHiAFIB4oAgBqNgIAIB8gASAfKAIAajYCACAgIAAgICgCAGo2AgAgIiACICIoAgBqIB1qNgIAICQgByAkKAIAajYCACAjIAMgIygCAGo2AgAgISAGICEoAgBqNgIAC8MDAQN/IAJBgMAATgRAIAAgASACEAkPCyAAIQQgACACaiEDIABBA3EgAUEDcUYEQANAIABBA3EEQCACRQRAIAQPCyAAIAEsAAA6AAAgAEEBaiEAIAFBAWohASACQQFrIQIMAQsLIANBfHEiAkFAaiEFA0AgACAFTARAIAAgASgCADYCACAAIAEoAgQ2AgQgACABKAIINgIIIAAgASgCDDYCDCAAIAEoAhA2AhAgACABKAIUNgIUIAAgASgCGDYCGCAAIAEoAhw2AhwgACABKAIgNgIgIAAgASgCJDYCJCAAIAEoAig2AiggACABKAIsNgIsIAAgASgCMDYCMCAAIAEoAjQ2AjQgACABKAI4NgI4IAAgASgCPDYCPCAAQUBrIQAgAUFAayEBDAELCwNAIAAgAkgEQCAAIAEoAgA2AgAgAEEEaiEAIAFBBGohAQwBCwsFIANBBGshAgNAIAAgAkgEQCAAIAEsAAA6AAAgACABLAABOgABIAAgASwAAjoAAiAAIAEsAAM6AAMgAEEEaiEAIAFBBGohAQwBCwsLA0AgACADSARAIAAgASwAADoAACAAQQFqIQAgAUEBaiEBDAELCyAEC44EARR/IABBJGoiDCgCACIFQRZ2IgFB0QdsIAAoAgBqIQJBACABQQZ0IABBBGoiDSgCAGogAkEadmoiA0EadiAAQQhqIg4oAgBqIgFBGnYgAEEMaiIPKAIAaiIGQRp2IABBEGoiECgCAGoiB0EadiAAQRRqIhEoAgBqIghBGnYgAEEYaiISKAIAaiIEQRp2IABBHGoiEygCAGoiCUEadiAAQSBqIhQoAgBqIgtBGnYgBUH///8BcWoiBUEWdiADQf///x9xIgNBQGsgAkH///8fcSICQdEHakEadmpB////H0sgBiABcSAHcSAIcSAEQf///x9xIgRxIAlxIAtxQf///x9GIAVB////AUZxcXIiCmtB0QdxIAJqIQIgCkEGdCADaiACQRp2aiIDQRp2IAFB////H3FqIgpBGnYgBkH///8fcWoiBkEadiAHQf///x9xaiIHQRp2IAhB////H3FqIghBGnYgBGoiBEEadiAJQf///x9xaiIJQRp2IAtB////H3FqIQEgACACQf///x9xNgIAIA0gA0H///8fcTYCACAOIApB////H3E2AgAgDyAGQf///x9xNgIAIBAgB0H///8fcTYCACARIAhB////H3E2AgAgEiAEQf///x9xNgIAIBMgCUH///8fcTYCACAUIAFB////H3E2AgAgDCABQRp2IAVqQf///wFxNgIAC8wFAgt/AX4gACABLQAeQQh0IAEtAB9yIAEtAB1BEHRyIAEtABxBGHRyNgIAIABBBGoiBiABLQAaQQh0IAEtABtyIAEtABlBEHRyIAEtABhBGHRyNgIAIABBCGoiByABLQAWQQh0IAEtABdyIAEtABVBEHRyIAEtABRBGHRyNgIAIABBDGoiCCABLQASQQh0IAEtABNyIAEtABFBEHRyIAEtABBBGHRyIgQ2AgAgAEEQaiIJIAEtAA5BCHQgAS0AD3IgAS0ADUEQdHIgAS0ADEEYdHIiAzYCACAAQRRqIgogAS0ACkEIdCABLQALciABLQAJQRB0ciABLQAIQRh0ciIFNgIAIABBGGoiCyABLQAGQQh0IAEtAAdyIAEtAAVBEHRyIAEtAARBGHRyIg02AgAgAEEcaiIMIAEtAAJBCHQgAS0AA3IgAS0AAUEQdHIgAS0AAEEYdHIiATYCACAAQQAgA0F+SSAFQX9HIAEgDXFBf0dyciIBQQFzIANBf0ZxIgNBAXMgBEHmubvVe0lxIAFyIgVBAXMgBEHmubvVe0txIANyIgRBAXMg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/P///wAgD2tqNgIAIAggGEH8////ACAQa2o2AgAgCSAZQfz///8AIBFrajYCACAKIBpB/P///wAgEmtqNgIAIAsgG0H8////ACATa2o2AgAgDCAcQfz///8AIBRrajYCACANIB1B/P///wAgFWtqNgIAIA4gHkH8//8HIAVrajYCACAAQShqIgEgBCACEAxB+vz/vwEgHygCAGshAkH6//+/ASAgKAIAayEEQfr//78BICEoAgBrIQVB+v//vwEgIigCAGshBkH6//+/ASAjKAIAayEHQfr//78BICQoAgBrIQhB+v//vwEgJSgCAGshCUH6//+/ASAmKAIAayEKQfr//wsgJygCAGshCyABIAEoAgBBmtL/vwEgAygCAGtqNgIAIABBLGoiASABKAIAIAJqNgIAIABBMGoiASABKAIAIARqNgIAIABBNGoiASABKAIAIAVqNgIAIABBOGoiASABKAIAIAZqNgIAIABBPGoiASABKAIAIAdqNgIAIABBQGsiASABKAIAIAhqNgIAIABBxABqIgEgASgCACAJajYCACAAQcgAaiIBIAEoAgAgCmo2AgAgAEHMAGoiACAAKAIAIAtqNgIAIAMkBAvZEgEffyMEIQMjBEHgA2okBCABQfgAaiIYKAIABEAgACACKQIANwIAIAAgAikCCDcCCCAAIAIpAhA3AhAgACACKQIYNwIYIAAgAikCIDcCICAAIAIpAig3AiggACACKQIwNwIwIAAgAikCODcCOCAAQUBrIAJBQGspAgA3AgAgACACKQJINwJIIAAgAikCUDcCUCAAIAIpAlg3AlggACACKQJgNwJgIAAgAikCaDcCaCAAIAIpAnA3AnAgACACKAJ4NgJ4IAMkBA8LIAIoAngEQCAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACABKQIgNwIgIAAgASkCKDcCKCAAIAEpAjA3AjAgACABKQI4NwI4IABBQGsgAUFAaykCADcCACAAIAEpAkg3AkggACABKQJQNwJQIAAgASkCWDcCWCAAIAEpAmA3AmAgACABKQJoNwJoIAAgASkCcDcCcCAAIAEoAng2AnggAyQEDwsgA0H4AGohDSADQdAAaiETIANBKGohByAAQfgAaiIVQQA2AgAgA0G4A2oiCiACQdAAaiIWEAogA0GQA2oiCyABQdAAaiIXEAogA0HoAmoiBiABIAoQDCADQcACaiIIIAIgCxAMIANBmAJqIgkgAUEoaiAKEAwgCSAJIBYQDCADQfABaiIFIAJBKGogCxAMIAUgBSAXEAxB/P3//wAgBigCBGshFEH8////ACAGKAIIayEOQfz///8AIAYoAgxrIQ9B/P///wAgBigCEGshEEH8////ACAGKAIUayERQfz///8AIAYoAhhrIRJB/P///wAgBigCHGshCkH8////ACAGKAIgayELQfz//wcgBigCJGshAiADQcgBaiIEQbzh//8AIAYoAgBrIAgoAgBqNgIAIAQgFCAIKAIEajYCBCAEIA4gCCgCCGo2AgggBCAPIAgoAgxqNgIMIAQgECAIKAIQajYCECAEIBEgCCgCFGo2AhQgBCASIAgoAhhqNgIYIAQgCiAIKAIcajYCHCAEIAsgCCgCIGo2AiAgBCACIAgoAiRqNgIkQfz9//8AIAkoAgRrIRRB/P///wAgCSgCCGshDkH8////ACAJKAIMayEPQfz///8AIAkoAhBrIRBB/P///wAgCSgCFGshEUH8////ACAJKAIYayESQfz///8AIAkoAhxrIQpB/P///wAgCSgCIGshC0H8//8HIAkoAiRrIQIgA0GgAWoiDEG84f//ACAJKAIAayAFKAIAajYCACAMIBQgBSgCBGo2AgQgDCAOIAUoAghqNgIIIAwgDyAFKAIMajYCDCAMIBAgBSgCEGo2AhAgDCARIAUoAhRqNgIUIAwgEiAFKAIYajYCGCAMIAogBSgCHGo2AhwgDCALIAUoAiBqNgIgIAwgAiAFKAIkajYCJCAEEBhFBEAgDSAMEAogEyAEEAogByAEIBMQDCAEIAQgFhAMIABB0ABqIBcgBBAMIAMgBiATEAwgACADKQIANwIAIAAgAykCCDcCCCAAIAMpAhA3AhAgACADKQIYNwIYIAAgAykCIDcCIEH4+///ASAAQQRqIgQoAgBBAXQgB0EEaiIZKAIAamshDkH4////ASAAQQhqIgUoAgBBAXQgB0EIaiIaKAIAamshD0H4////ASAAQQxqIgYoAgBBAXQgB0EMaiIbKAIAamshEEH4////ASAAQRBqIggoAgBBAXQgB0EQaiIcKAIAamshEUH4////ASAAQRRqIhMoAgBBAXQgB0EUaiIdKAIAamshEkH4////ASAAQRhqIhUoAgBBAXQgB0EYaiIeKAIAamshCkH4////ASAAQRxqIhYoAgBBAXQgB0EcaiIfKAIAamshC0H4////ASAAQSBqIhcoAgBBAXQgB0EgaiIgKAIAamshAkH4//8PIABBJGoiGCgCAEEBdCAHQSRqIiEoAgBqayEBIABB+ML//wEgACgCAEEBdCAHKAIAamsgDSgCAGoiFDYCACAEIA4gDSgCBGoiDjYCACAFIA8gDSgCCGoiDzYCACAGIBAgDSgCDGoiEDYCACAIIBEgDSgCEGoiETYCACATIBIgDSgCFGoiEjYCACAVIAogDSgCGGoiCjYCACAWIAsgDSgCHGoiCzYCACAXIAIgDSgCIGoiAjYCACAYIAEgDSgCJGoiATYCACAAQShqIgRBtKT//wIgFGsgAygCAGo2AgAgAEEsaiIFQfT5//8CIA5rIAMoAgRqNgIAIABBMGoiBkH0////AiAPayADKAIIajYCACAAQTRqIghB9P///wIgEGsgAygCDGo2AgAgAEE4aiITQfT///8CIBFrIAMoAhBqNgIAIABBPGoiFUH0////AiASayADKAIUajYCACAAQUBrIhZB9P///wIgCmsgAygCGGo2AgAgAEHEAGoiF0H0////AiALayADKAIcajYCACAAQcgAaiIYQfT///8CIAJrIAMoAiBqNgIAIABBzABqIhRB9P//FyABayADKAIkajYCACAEIAQgDBAMIAcgByAJEAwgB0G84f//ACAHKAIAayIONgIAIBlB/P3//wAgGSgCAGsiDzYCACAaQfz///8AIBooAgBrIhA2AgAgG0H8////ACAbKAIAayIRNgIAIBxB/P///wAgHCgCAGsiEjYCACAdQfz///8AIB0oAgBrIgo2AgAgHkH8////ACAeKAIAayILNgIAIB9B/P///wAgHygCAGsiAjYCACAgQfz///8AICAoAgBrIgE2AgAgIUH8//8HICEoAgBrIgA2AgAgBCAEKAIAIA5qNgIAIAUgBSgCACAPajYCACAGIAYoAgAgEGo2AgAgCCAIKAIAIBFqNgIAIBMgEygCACASajYCACAVIBUoAgAgCmo2AgAgFiAWKAIAIAtqNgIAIBcgFygCACACajYCACAYIBgoAgAgAWo2AgAgFCAUKAIAIABqNgIAIAMkBA8LIAwQ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DjYCACAAQQxqIgQgIkKZxsSqBH4gEK18ICVCIIh8IianIgo2AgAgAEEQaiICICIgDa18ICZCIIh8IienIgE2AgAgAEEUaiIJICdCIIggC618IiQ+AgAgAEEYaiIIICRCIIggBq18IiM+AgAgAEEcaiIGICNCIIggD618IiI+AgAgACAoQv////8PgyAiQiCIIAFBfkkgIyAkgyAig6dBf0dyIgBBAXMgAUF/RnEiAUEBcyAKQea5u9V7SXEgAHIiAEEBcyAKQea5u9V7S3EgAXIiAUEBcyAOQbvAovp6SXEgAHIiAEEBcyAOQbvAovp6S3EgAXIiAUEBcyARQYy9yf57SXEgAHJBf3MiACARQYy9yf57S3EgAXIgACAHQcCC2YF9S3FyrXwiI6ciAEG//ab+AmytfCIiPgIAIAUgKUL/////D4MgAEHzwraBBGytfCAiQiCIfCIiPgIAIAMgJUL/////D4MgAEHEv92FBWytfCAiQiCIfCIiPgIAIAQgJkL/////D4MgAEGZxsSqBGytfCAiQiCIfCIiPgIAIAIgI0L/////D4MgJ0L/////D4N8ICJCIIh8IiI+AgAgCSAiQiCIIAkoAgCtfCIiPgIAIAggIkIgiCAIKAIArXwiIj4CACAGICJCIIggBigCAK18PgIAIAwkBAviGwEpfyMEIQQjBEHAA2okBCACKAJQIQcgAUH4AGoiKygCAARAIAAgBzYCeCAAIAIpAgA3AgAgACACKQIINwIIIAAgAikCEDcCECAAIAIpAhg3AhggACACKQIgNwIgIABBKGoiAyACQShqIgEpAgA3AgAgAyABKQIINwIIIAMgASkCEDcCECADIAEpAhg3AhggAyABKQIgNwIgIABBATYCUCAAQdQAaiIAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAEEANgIgIAQkBA8LIAcEQCADBEAgA0EBNgIAIANBBGoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJBADYCIAsgACABKQIANwIAIAAgASkCCDcCCCAAIAEpAhA3AhAgACABKQIYNwIYIAAgASkCIDcCICAAIAEpAig3AiggACABKQIwNwIwIAAgASkCODcCOCAAQUBrIAFBQGspAgA3AgAgACABKQJINwJIIAAgASkCUDcCUCAAIAEpAlg3AlggACABKQJgNwJgIAAgASkCaDcCaCAAIAEpAnA3AnAgACABKAJ4NgJ4IAQkBA8LIARB+ABqIRUgBEHQAGohJSAEQShqIQogAEH4AGoiJkEANgIAIARBkANqIicgAUHQAGoiKBAKIARB6AJqIgggASkCADcCACAIIAEpAgg3AgggCCABKQIQNwIQIAggASkCGDcCGCAIIAEpAiA3AiAgCEEkaiIcKAIAIhJBFnYiB0HRB2wgCCgCAGohHiAHQQZ0IAhBBGoiFigCAGogHkEadmoiF0EadiAIQQhqIhgoAgBqIhlBGnYgCEEMaiIFKAIAaiIGQRp2IAhBEGoiDCgCAGoiE0EadiAIQRRqIhQoAgBqIg1BGnYgCEEYaiIOKAIAaiIPQRp2IAhBHGoiECgCAGoiEUEadiAIQSBqIgcoAgBqIRogCCAeQf///x9xIiw2AgAgFiAXQf///x9xIgs2AgAgGCAZQf///x9xIh82AgAgBSAGQf///x9xIiA2AgAgDCATQf///x9xIiE2AgAgFCANQf///x9xIiI2AgAgDiAPQf///x9xIiM2AgAgECARQf///x9xIiQ2AgAgByAaQf///x9xIh42AgAgHCAaQRp2IBJB////AXFqIho2AgAgBEHAAmoiGyACICcQDCAEQZgCaiIJIAFBKGoiHSkCADcCACAJIB0pAgg3AgggCSAdKQIQNwIQIAkgHSkCGDcCGCAJIB0pAiA3AiAgCUEkaiIpKAIAIhxBFnYiB0HRB2wgCSgCAGohDCAHQQZ0IAlBBGoiEigCAGogDEEadmoiE0EadiAJQQhqIhYoAgBqIhRBGnYgCUEMaiIXKAIAaiINQRp2IAlBEGoiGCgCAGoiDkEadiAJQRRqIhkoAgBqIg9BGnYgCUEYaiIFKAIAaiIQQRp2IAlBHGoiBigCAGoiEUEadiAJQSBqIgcoAgBqISogCSAMQf///x9xIgw2AgAgEiATQf///x9xIhM2AgAgFiAUQf///x9xIhQ2AgAgFyANQf///x9xIg02AgAgGCAOQf///x9xIg42AgAgGSAPQf///x9xIg82AgAgBSAQQf///x9xIhA2AgAgBiARQf///x9xIhE2AgAgByAqQf///x9xIgc2AgAgKSAqQRp2IBxB////AXFqNgIAIARB8AFqIgYgAkEoaiAnEAwgBiAGICgQDCAEQcgBaiIFQbzh//8AICxrIBsoAgBqNgIAIAVB/P3//wAgC2sgGygCBGo2AgQgBUH8////ACAfayAbKAIIajYCCCAFQfz///8AICBrIBsoAgxqNgIMIAVB/P///wAgIWsgGygCEGo2AhAgBUH8////ACAiayAbKAIUajYCFCAFQfz///8AICNrIBsoAhhqNgIYIAVB/P///wAgJGsgGygCHGo2AhwgBUH8////ACAeayAbKAIgajYCICAFQfz//wcgGmsgGygCJGo2AiRB/P//ByApKAIAayECIARBoAFqIgtBvOH//wAgDGsgBigCAGo2AgAgC0H8/f//ACATayAGKAIEajYCBCALQfz///8AIBRrIAYoAghqNgIIIAtB/P///wAgDWsgBigCDGo2AgwgC0H8////ACAOayAGKAIQajYCECALQfz///8AIA9rIAYoAhRqNgIUIAtB/P///wAgEGsgBigCGGo2AhggC0H8////ACARayAGKAIcajYCHCALQfz///8AIAdrIAYoAiBqNgIgIAsgAiAGKAIkajYCJCAFEBhFBEAgFSALEAogJSAFEAogCiAFICUQDCADBEAgAyAFKQIANwIAIAMgBSkCCDcCCCADIAUpAhA3AhAgAyAFKQIYNwIYIAMgBSkCIDcCIAsgAEHQAGogKCAFEAwgBCAIICUQDCAAIAQpAgA3AgAgACAEKQIINwIIIAAgBCkCEDcCECAAIAQpAhg3AhggACAEKQIgNwIgQfj7//8BIABBBGoiEigCAEEBdCAKQQRqIh8oAgBqayENQfj///8BIABBCGoiFigCAEEBdCAKQQhqIiAoAgBqayEOQfj///8BIABBDGoiFygCAEEBdCAKQQxqIiEoAgBqayEPQfj///8BIABBEGoiGCgCAEEBdCAKQRBqIiIoAgBqayEQQfj///8BIABBFGoiGSgCAEEBdCAKQRRqIiMoAgBqayERQfj///8BIABBGGoiBSgCAEEBdCAKQRhqIiQoAgBqayEHQfj///8BIABBHGoiBigCAEEBdCAKQRxqIh4oAgBqayEDQfj///8BIABBIGoiDCgCAEEBdCAKQSBqIhooAgBqayECQfj//w8gAEEkaiITKAIAQQF0IApBJGoiHCgCAGprIQEgAEH4wv//ASAAKAIAQQF0IAooAgBqayAVKAIAaiIUNgIAIBIgDSAVKAIEaiINNgIAIBYgDiAVKAIIaiIONgIAIBcgDyAVKAIMaiIPNgIAIBggECAVKAIQaiIQNgIAIBkgESAVKAIUaiIRNgIAIAUgByAVKAIYaiIHNgIAIAYgAyAVKAIcaiIDNgIAIAwgAiAVKAIgaiICNgIAIBMgASAVKAIkaiIBNgIAIABBKGoiEkG0pP//AiAUayAEKAIAajYCACAAQSxqIhZB9Pn//wIgDWsgBCgCBGo2AgAgAEEwaiIXQfT///8CIA5rIAQoAghqNgIAIABBNGoiGEH0////AiAPayAEKAIMajYCACAAQThqIhlB9P///wIgEGsgBCgCEGo2AgAgAEE8aiIFQfT///8CIBFrIAQoAhRqNgIAIABBQGsiBkH0////AiAHayAEKAIYajYCACAAQcQAaiIMQfT///8CIANrIAQoAhxqNgIAIABByABqIhNB9P///wIgAmsgBCgCIGo2AgAgAEHMAGoiFEH0//8XIAFrIAQoAiRqNgIAIBIgEiALEAwgCiAKIAkQDCAKQbzh//8AIAooAgBrIg02AgAgH0H8/f//ACAfKAIAayIONgIAICBB/P///wAgICgCAGsiDzYCACAhQfz///8AICEoAgBrIhA2AgAgIkH8////ACAiKAIAayIRNgIAICNB/P///wAgIygCAGsiBzYCACAkQfz///8AICQoAgBrIgM2AgAgHkH8////ACAeKAIAayICNgIAIBpB/P///wAgGigCAGsiATYCACAcQfz//wcgHCgCAGsiADYCACASIBIoAgAgDWo2AgAgFiAWKAIAIA5qNgIAIBcgFygCACAPajYCACAYIBgoAgAgEGo2AgAgGSAZKAIAIBFqNgIAIAUgBSgCACAHajYCACAGIAYoAgAgA2o2AgAgDCAMKAIAIAJqNgIAIBMgEygCACABajYCACAUIBQoAgAgAGo2AgAgBCQEDwsgCxAYRQRAIAMEQCADQgA3AgAgA0IANwIIIANCADcCECADQgA3AhggA0IANwIgCyAmQQE2AgAgAEIANwIAIABCADcCCCAAQgA3AhAgAEIANwIYIABCADcCICAAQgA3AiggAEIANwIwIABCADcCOCAAQUBrQgA3AgAgAEIANwJIIABCADcCUCAAQgA3AlggAEIANwJgIABCADcCaCAAQgA3AnAgBCQEDwsgKygCAARAICZBATYCACADRQRAIAQkBA8LIANBATYCACADQQRqIgBCADcCACAAQgA3AgggAEIANwIQIABCADcCGCAAQQA2AiAgBCQEBSADBEAgAyAdKQIANwIAIAMgHSkCCDcCCCADIB0pAhA3AhAgAyAdKQIYNwIYIAMgHSkCIDcCICADQSRqIhIoAgAiFkEWdiICQdEHbCADKAIAaiEaIAJBBnQgA0EEaiIXKAIAaiAaQRp2aiIYQRp2IANBCGoiGSgCAGoiBUEadiADQQxqIgYoAgBqIgxBGnYgA0EQaiITKAIAaiIUQRp2IANBFGoiDSgCAGoiDkEadiADQRhqIg8oAgBqIhBBGnYgA0EcaiIRKAIAaiIHQRp2IANBIGoiAigCAGohHCADIBpBAXRB/v//P3E2AgAgFyAYQQF0Qf7//z9xNgIAIBkgBUEBdEH+//8/cTYCACAGIAxBAXRB/v//P3E2AgAgEyAUQQF0Qf7//z9xNgIAIA0gDkEBdEH+//8/cTYCACAPIBBBAXRB/v//P3E2AgAgESAHQQF0Qf7//z9xNgIAIAIgHEEBdEH+//8/cTYCACASIBxBGnYgFkH///8BcWpBAXQ2AgALIAAgARATIAQkBAsL7gQBG38gAEEkaiILKAIAIgJBFnYiAUHRB2wgACgCAGohBCABQQZ0IABBBGoiDCgCAGogBEEadmoiBUEadiAAQQhqIg0oAgBqIgZB////H3EhByAGQRp2IABBDGoiDigCAGoiCEEadiAAQRBqIg8oAgBqIQEgCEH///8fcSEJIAFB////H3EhCiABQRp2IABBFGoiECgCAGoiEUEadiAAQRhqIhIoAgBqIRMgEUH///8fcSEUIBNBGnYgAEEcaiIVKAIAaiIWQRp2IABBIGoiFygCAGohAyAWQf///x9xIRggA0H///8fcSEZIANBGnYgAkH///8BcWoiAkEWdiAFQf///x9xIgVBQGsgBEH///8fcSIEQdEHaiIaQRp2IhtqQf///x9LIAggBnEgAXEgEXEgE0H///8fcSIBcSAWcSADcUH///8fRiACQf///wFGcXFyIgNFBEAgACAENgIAIAwgBTYCACANIAc2AgAgDiAJNgIAIA8gCjYCACAQIBQ2AgAgEiABNgIAIBUgGDYCACAXIBk2AgAgCyACNgIADwsgGyAFaiADQQZ0aiIDQRp2IAdqIgRBGnYgCWoiBkEadiAKaiIHQRp2IBRqIghBGnYgAWoiAUEadiAYaiIJQRp2IBlqIgpBGnYgAmpB////AXEhAiAAIBpB////H3E2AgAgDCADQf///x9xNgIAIA0gBEH///8fcTYCACAOIAZB////H3E2AgAgDyAHQf///x9xNgIAIBAgCEH///8fcTYCACASIAFB////H3E2AgAgFSAJQf///x9xNgIAIBcgCkH///8fcTYCACALIAI2AgALsAIBCn8gACgCJCIBQRZ2IgJB0QdsIAAoAgBqIgNB////H3EiBEHQB3MhBSAEQQBHIAVB////H0dxBEBBAA8LIANBGnYgAkEGdHIgACgCBGoiAkEadiAAKAIIaiIDQRp2IAAoAgxqIgZBGnYgACgCEGoiB0EadiAAKAIUaiIIQRp2IAAoAhhqIglBGnYgACgCHGoiCkEadiAAKAIgaiIAQRp2IAFB////AXFqIQEgAkHAAHMgBXEgA3EgBnEgB3EgCHEgCXEgCnEgAHEgAUGAgIAec3FB////H0YEf0EBBSACQf///x9xIARyIANB////H3FyIAZB////H3FyIAdB////H3FyIAhB////H3FyIAlB////H3FyIApB////H3FyIABB////H3FyIAFyRQtBAXELmAIBBH8gACACaiEEIAFB/wFxIQEgAkHDAE4EQANAIABBA3EEQCAAIAE6AAAgAEEBaiEADAELCyAEQXxxIgVBQGohBiABIAFBCHRyIAFBEHRyIAFBGHRyIQMDQCAAIAZMBEAgACADNgIAIAAgAzYCBCAAIAM2AgggACADNgIMIAAgAzYCECAAIAM2AhQgACADNgIYIAAgAzYCHCAAIAM2AiAgACADNgIkIAAgAzYCKCAAIAM2AiwgACADNgIwIAAgAzYCNCAAIAM2AjggACADNgI8IABBQGshAAwBCwsDQCAAIAVIBEAgACADNgIAIABBBGohAAwBCwsLA0AgACAESARAIAAgAToAACAAQQFqIQAMAQsLIAQgAmsL5gQCCn8DfiAAIAIoAgCtIAEoAgCtfCINPgIAIABBBGoiBSANQiCIIAEoAgStfCACKAIErXwiDT4CACAAQQhqIgYgAigCCK0gASgCCK18IA1CIIh8Ig2nIgM2AgAgAEEMaiIHIAIoAgytIAEoAgytfCANQiCIfCINpyIENgIA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AiAiG2o2AgAgAUEkaiIxIDEoAgAgBCgCJCIyajYCACAFKAIAICVB////H3EiPmohNSAFKAIEICxB////H3EiP2ohLCAFKAIIIC1B////H3EiQGohLSAFKAIMIC5B////H3EiQWohLiAFKAIQIC9B////H3EiQmohLyAFKAIUIDBB////H3EiQ2ohMCAFKAIYICZB////H3EiRGohJiAFKAIcICdB////H3EiRWohJyAFKAIgICBB////H3EiRmohMyAFKAIkICBBGnYgGkH///8BcWoiR2ohJSAHQdAAaiIEIAEQCiAHQShqIgVBvOH//wAgBms2AgAgBUEEaiIUQfz9//8AICFrNgIAIAVBCGoiIUH8////ACANazYCACAFQQxqIg1B/P///wAgIms2AgAgBUEQaiIiQfz///8AIBFrNgIAIAVBFGoiEUH8////ACAoazYCACAFQRhqIihB/P///wAgEms2AgAgBUEcaiISQfz///8AIClrNgIAIAVBIGoiKUH8////ACAbazYCACAFQSRqIhtB/P//ByAyazYCACAHQcgBaiIGIAMgBRAMIAQgBCgCACAGKAIAajYCACAEQQRqIjIoAgAgBigCBGohEyAyIBM2AgAgBEEIaiIrKAIAIAYoAghqITQgKyA0NgIAIARBDGoiPSgCACAGKAIMaiE2ID0gNjYCACAEQRBqIkkoAgAgBigCEGohNyBJIDc2AgAgBEEUaiJKKAIAIAYoAhRqITggSiA4NgIAIARBGGoiSygCACAGKAIYaiE5IEsgOTYCACAEQRxqIkwoAgAgBigCHGohOiBMIDo2AgAgBEEgaiJNKAIAIAYoAiBqITsgTSA7NgIAIARBJGoiTigCACAGKAIkaiEGIE4gBjYCACAlQRZ2IhpB0QdsIDVqISAgGkEGdCAsaiAgQRp2aiJPQRp2IC1qIlBBGnYgLmoiUUEadiAvaiJSQRp2IDBqIlNBGnYgJmoiVEEadiAnaiJVQRp2IDNqIlZBGnYgJUH///8BcWohVyAGQRZ2IkhB0QdsIAQoAgBqIRogSEEGdCATaiAaQRp2aiITQRp2IDRqIjRBGnYgNmoiNkEadiA3aiI3QRp2IDhqIjhBGnYgOWoiOUEadiA6aiI6QRp2IDtqIjtBGnYgBkH///8BcWohBiAHQQRqIUggB0EIaiFZIAdBDGoh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ECAFIAYpAhg3AhggBSAGKQIgNwIgIAUgBikCKDcCKCAFIAYpAjA3AjAgBSAGKQI4NwI4IAVBQGsgBkFAaykCADcCACAFIAYpAkg3AkggBSAGKAJQNgJQBSAFIBUgBkF/c0ECbUHUAGxqIgYpAgA3AgAgBSAGKQIINwIIIAUgBikCEDcCECAFIAYpAhg3AhggBSAGKQIgNwIgIAUgBikCKDcCKCAFIAYpAjA3AjAgBSAGKQI4NwI4IAVBQGsgBkFAaykCADcCACAFIAYpAkg3AkggBSAGKAJQNgJQIApBvOH//wAgCigCAGs2AgAgC0H8/f//ACALKAIAazYCACAPQfz///8AIA8oAgBrNgIAIBJB/P///wAgEigCAGs2AgAgE0H8////ACATKAIAazYCACAIQfz///8AIAgoAgBrNgIAIA1B/P///wAgDSgCAGs2AgAgDkH8////ACAOKAIAazYCACAUQfz///8AIBQoAgBrNgIAIBFB/P//ByARKAIAazYCAAsgASABIAVBABAWCwsgAiAdKAIATARAIAwgBEHUCGxqQcQEaiAQQQJ0aigCACIGBEAgCSAEQQN0QdQAbGohFSAGQQBKBEAgBSAVIAZBf2pBAm1B1ABsaiIGKQIANwIAIAUgBikCCDcCCCAFIAYpAhA3AhAgBSAGKQIYNwIYIAUgBikCIDcCICAFIAYpAig3AiggBSAGKQIwNwIwIAUgBikCODcCOCAFQUBrIAZBQGspAgA3AgAgBSAGKQJINwJIIAUgBigCUDYCUAUgBSAVIAZBf3NBAm1B1ABsaiIGKQIANwIAIAUgBikCCDcCCCAFIAYpAhA3AhAgBSAGKQIYNwIYIAUgBikCIDcCICAFIAYpAig3AiggBSAGKQIwNwIwIAUgBikCODcCOCAFQUBrIAZBQGspAgA3AgAgBSAGKQJINwJIIAUgBigCUDYCUCAKQbzh//8AIAooAgBrNgIAIAtB/P3//wAgCygCAGs2AgAgD0H8////ACAPKAIAazYCACASQfz///8AIBIoAgBrNgIAIBNB/P///wAgEygCAGs2AgAgCEH8////ACAIKAIAazYCACANQfz///8AIA0oAgBrNgIAIA5B/P///wAgDigCAGs2AgAgFEH8////ACAUKAIAazYCACARQfz//wcgESgCAGs2AgALIAEgASAFQQAQFgsLIARBAWoiBCAXRw0ACwsgAiADTARAICUgEEECdGooAgAiBARAIAAoAgAhBiAEQQBKBEAgBSAGIARBf2pBAm1BBnRqECIFIAUgBiAEQX9zQQJtQQZ0ahAiIApBvOH//wAgCigCAGs2AgAgC0H8/f//ACALKAIAazYCACAPQfz///8AIA8oAgBrNgIAIBJB/P///wAgEigCAGs2AgAgE0H8////ACATKAIAazYCACAIQfz///8AIAgoAgBrNgIAIA1B/P///wAgDSgCAGs2AgAgDkH8////ACAOKAIAazYCACAUQfz///8AIBQoAgBrNgIAIBFB/P//ByARKAIAazYCAAsgASABIAUgFhAzCwsgAiAZTARAICYgEEECdGooAgAiBARAIBsoAgAhBiAEQQBKBEAgBSAGIARBf2pBAm1BBnRqECIFIAUgBiAEQX9zQQJtQQZ0ahAiIApBvOH//wAgCigCAGs2AgAgC0H8/f//ACALKAIAazYCACAPQfz///8AIA8oAgBrNgIAIBJB/P///wAgEigCAGs2AgAgE0H8////ACATKAIAazYCACAIQfz///8AIAgoAgBrNgIAIA1B/P///wAgDSgCAGs2AgAgDkH8////ACAOKAIAazYCACAUQfz///8AIBQoAgBrNgIAIBFB/P//ByARKAIAazYCAAsgASABIAUgFhAzCwsgGigCAEUhBCACQQFKBEAgECECDAELCyAERQRAIAkkBA8LIAFB0ABqIgAgACAWEAwgCSQEC+UEAg5/An4jBCEDIwRBIGokBCAAQQBBhAQQGRogAyABKQIANwIAIAMgASkCCDcCCCADIAEpAhA3AhAgAyABKQIYNwIYIANBHGoiBigCACIBQX9KBH9BAQUgAyADKAIAIgRBf3OtQsKC2YENfCIRIAQgAXIgA0EEaiIEKAIAIgVyIANBCGoiCCgCACIHciADQQxqIgkoAgAiCnIgA0EQaiILKAIAIgxyIANBFGoiDSgCACIOciADQRhqIg8oAgAiEHJBAEdBH3RBH3WtIhKDPgIAIAQgEUIgiEKMvcn+C4QgBUF/c618IhEgEoM+AgAgCCAHQX9zrUK7wKL6CnwgEUIgiHwiESASgz4CACAJIApBf3OtQua5u9ULfCARQiCIfCIRIBKDPgIAIAsgDEF/c61C/v///w98IBFCIIh8IhEg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QcAATwRAA0AgByACKQAANwAAIAcgAikACDcACCAHIAIpABA3ABAgByACKQAYNwAYIAcgAikAIDcAICAHIAIpACg3ACggByACKQAwNwAwIAcgAikAODcAOCACQUBrIQIgDyAHEA0gA0FAaiIDQcAATw0ACwsgAwRAQQAhBAwCCwsMAQsgByAEaiACIAMQDhoLIA8oAgAQCyESIA9BADYCACAGQegAaiIXKAIAEAshCCAXQQA2AgAgBkHsAGoiGigCABALIQ0gGkEANgIAIAZB8ABqIhsoAgAQCyEOIBtBADYCACAGQfQAaiIcKAIAEAshBSAcQQA2AgAgBkH4AGoiFCgCABALIQQgFEEANgIAIAZB/ABqIhYoAgAQCyEDIBZBADYCACAGQYABaiIYKAIAEAshAiAYQQA2AgAgACASNgAgIAAgCDYAJCAAIA02ACggACAONgAsIAAgBTYAMCAAIAQ2ADQgACADNgA4IAAgAjYAPCAGIBkQHiAQKAIAIgJBP3EhBSAQIAJBIGo2AgAgBkEgaiEIAkACQEHAACAFayICQSBLBEAgACECIAUhBEEgIQMMAQUgCCAFaiAAIAIQDhogACACaiEEIAYgCBANQSAgAmsiA0HAAEkEfyAEBSAAQeQAaiAFQaB/aiINQUBxIg5BHHIgBWtqIQUgAyECIAQhAwNAIAggAykAADcAACAIIAMpAAg3AAggCCADKQAQNwAQIAggAykAGDcAGCAIIAMpACA3ACAgCCADKQAoNwAoIAggAykAMDcAMCAIIAMpADg3ADggA0FAayEDIAYgCBANIAJBQGoiAkHAAE8NAAsgDSAOayEDIAULIQIgAwRAQQAhBAwCCwsMAQsgCCAEaiACIAMQDhoLIAogECgCACICQR12QRh0NgIAIAogAkELdEGAgPwHcSACQRt0ciACQQV2QYD+A3FyIAJBFXZB/wFxcjYCBCAQIAJBNyACa0E/cUEBaiIDajYCACAGQSBqIQUCQAJAIANBwAAgAkE/cSICayIESQRAQakTIQQMAQUgBSACakGpEyAEEA4aIARBqRNqIQIgBiAFEA0gAyAEayIDQcAATwRAA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikA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ICUoAgAQCyEFICVBADYCACAmKAIAEAshBCAmQQA2AgAgJygCABALIQkgJ0EANgIAICgoAgAQCyECIChBADYCACApKAIAEAshCiApQQA2AgAgISgCABALIQAgDiANNgAAIBsgGTYAACAcIAU2AAAgFiAENgAAIBggCTYAACASIAI2AAAgCCAKNgAAIBogADYAACABIAMpAAA3AAAgASADKQAINwAIIAEgAykAEDcAECABIAMpABg3ABggMUEBNgIAIAYkBA8LCyAMIAJqIAAgChAOGiAVKAIAEAshDSAVQQA2AgAgJCgCABALIRkgJEEANgIAICUoAgAQCyEFICVBADYCACAmKAIAEAshBCAmQQA2AgAgJygCABALIQkgJ0EANgIAICgoAgAQCyECIChBADYCACApKAIAEAshCiApQQA2AgAgISgCABALIQAgDiANNgAAIBsgGTYAACAcIAU2AAAgFiAENgAAIBggCTYAACASIAI2AAAgCCAKNgAAIBogADYAACABIAMpAAA3AAAgASADKQAINwAIIAEgAykAEDcAECABIAMpABg3ABggMUEBNgIAIAYkBAubEwEPfyMEIQgjBEGwBGokBCAIQaABaiEEIAhB+ABqIQkgCEHQAGohBSAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACABKQIgNwIgIAhBKGoiAyABEAogCCABIAMQDCAAQQA2AlAgCCAIKAIAQQdqNgIAIAhBBGohDSAIQQxqIQ8gCEEUaiEQIAhBHGohESAIQSRqIQ4gCEGIBGoiDCAIEAogDCAMIAgQDCAIQeADaiILIAwQCiALIAsgCBAMIAhBuANqIgEgCykCADcCACABIAspAgg3AgggASALKQIQNwIQIAEgCykCGDcCGCABIAspAiA3AiAgASABEAogASABEAogASABEAogASABIAsQDCAIQZADaiIDIAEpAgA3AgAgAyABKQIINwIIIAMgASkCEDcCECADIAEpAhg3AhggAyABKQIgNwIgIAMgAxAKIAMgAxAKIAMgAxAKIAMgAyALEAwgCEHoAmoiASADKQIANwIAIAEgAykCCDcCCCABIAMpAhA3AhAgASADKQIYNwIYIAEgAykCIDcCICABIAEQCiABIAEQCiABIAEgDBAMIAhBwAJqIgcgASkCADcCACAHIAEpAgg3AgggByABKQIQNwIQIAcgASkCGDcCGCAHIAEpAiA3AiAgByAHEAogByAHEAogByAHEAogByAHEAogByAHEAogByAHEAogByAHEAogByAHEAogByAHEAogByAHEAogByAHEAogByAHIAEQDCAIQZgCaiIGIAcpAgA3AgAgBiAHKQIINwIIIAYgBykCEDcCECAGIAcpAhg3AhggBiAHKQIgNwIgIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBhAKIAYgBiAHEAwgCEHwAWoiAyAGKQIANwIAIAMgBikCCDcCCCADIAYpAhA3AhAgAyAGKQIYNwIYIAMgBikCIDcCICADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMQCiADIAMgBhAMIAhByAFqIgogAykCADcCACAKIAMpAgg3AgggCiADKQIQNwIQIAogAykCGDcCGCAKIAMpAiA3AiBBACEBA0AgCiAKEAogAUEBaiIBQdgARw0ACyAKIAogAxAMIAQgCikCADcCACAEIAopAgg3AgggBCAKKQIQNwIQIAQgCikCGDcCGCAEIAopAiA3AiAgBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAogBCAEEAog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IBYoAgBqNgIAIARB/P3//wAgH2sgFigCBGo2AgQgBEH8////ACAgayAWKAIIajYCCCAEQfz///8AICFrIBYoAgxqNgIMIARB/P///wAgImsgFigCEGo2AhAgBEH8////ACAjayAWKAIUajYCFCAEQfz///8AICRrIBYoAhhqNgIYIARB/P///wAgJWsgFigCHGo2AhwgBEH8////ACAcayAWKAIgajYCICAEQfz//wcgHWsgFigCJGo2AiRB/P//ByAqKAIAayECIAVB8AFqIgxBvOH//wAgDmsgBigCAGo2AgAgDEH8/f//ACAVayAGKAIEajYCBCAMQfz///8AIA9rIAYoAghqNgIIIAxB/P///wAgEGsgBigCDGo2AgwgDEH8////ACARayAGKAIQajYCECAMQfz///8AIBJrIAYoAhRqNgIUIAxB/P///wAgE2sgBigCGGo2AhggDEH8////ACAKayAGKAIcajYCHCAMQfz///8AIANrIAYoAiBqNgIgIAwgAiAGKAIkajYCJCAEEBhFBEAgDSAMEAogJiAEEAogCyAEICYQDCAAQdAAaiIBIB4pAgA3AgAgASAeKQIINwIIIAEgHikCEDcCECABIB4pAhg3AhggASAeKQIgNwIgIAEgASAEEAwgByAIICYQDCAAIAcpAgA3AgAgACAHKQIINwIIIAAgBykCEDcCECAAIAcpAhg3AhggACAHKQIgNwIgQfj7//8BIABBBGoiFCgCAEEBdCALQQRqIh8oAgBqayEPQfj///8BIABBCGoiFygCAEEBdCALQQhqIiAoAgBqayEQQfj///8BIABBDGoiGCgCAEEBdCALQQxqIiEoAgBqayERQfj///8BIABBEGoiGSgCAEEBdCALQRBqIiIoAgBqayESQfj///8BIABBFGoiGigCAEEBdCALQRRqIiMoAgBqayETQfj///8BIABBGGoiGygCAEEBdCALQRhqIiQoAgBqayEKQfj///8BIABBHGoiBCgCAEEBdCALQRxqIiUoAgBqayEDQfj///8BIABBIGoiBigCAEEBdCALQSBqIhwoAgBqayECQfj//w8gAEEkaiIOKAIAQQF0IAtBJGoiHSgCAGprIQEgAEH4wv//ASAAKAIAQQF0IAsoAgBqayANKAIAaiIVNgIAIBQgDyANKAIEaiIPNgIAIBcgECANKAIIaiIQNgIAIBggESANKAIMaiIRNgIAIBkgEiANKAIQaiISNgIAIBogEyANKAIUaiITNgIAIBsgCiANKAIYaiIKNgIAIAQgAyANKAIcaiIDNgIAIAYgAiANKAIgaiICNgIAIA4gASANKAIkaiIBNgIAIABBKGoiFEG0pP//AiAVayAHKAIAajYCACAAQSxqIhdB9Pn//wIgD2sgBygCBGo2AgAgAEEwaiIYQfT///8CIBBrIAcoAghqNgIAIABBNGoiGUH0////AiARayAHKAIMajYCACAAQThqIhpB9P///wIgEmsgBygCEGo2AgAgAEE8aiIbQfT///8CIBNrIAcoAhRqNgIAIABBQGsiBEH0////AiAKayAHKAIYajYCACAAQcQAaiIGQfT///8CIANrIAcoAhxqNgIAIABByABqIg5B9P///wIgAmsgBygCIGo2AgAgAEHMAGoiFUH0//8XIAFrIAcoAiRqNgIAIBQgFCAMEAwgCyALIAkQDCALQbzh//8AIAsoAgBrIg82AgAgH0H8/f//ACAfKAIAayIQNgIAICBB/P///wAgICgCAGsiETYCACAhQfz///8AICEoAgBrIhI2AgAgIkH8////ACAiKAIAayITNgIAICNB/P///wAgIygCAGsiCjYCACAkQfz///8AICQoAgBrIgM2AgAgJUH8////ACAlKAIAayICNgIAIBxB/P///wAgHCgCAGsiATYCACAdQfz//wcgHSgCAGsiADYCACAUIBQoAgAgD2o2AgAgFyAXKAIAIBBqNgIAIBggGCgCACARajYCACAZIBkoAgAgEmo2AgAgGiAaKAIAIBNqNgIAIBsgGygCACAKajYCACAEIAQoAgAgA2o2AgAgBiAGKAIAIAJqNgIAIA4gDigCACABajYCACAVIBUoAgAgAGo2AgAgBSQEDwsgDBAYRQRAICdBATYCACAAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAEIANwIgIABCADcCKCAAQgA3AjAgAEIANwI4IABBQGtCADcCACAAQgA3AkggAEIANwJQIABCADcCWCAAQgA3AmAgAEIANwJoIABCADcCcCAFJAQPCyAsKAIABEAgJ0EBNgIAIAUkBAUgACABEBMgBSQECwu3BAEEfyMEIQQjBEGwAmokBCAEQagBaiEFIAIoAngEQCAF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ACABIAxsNgKAAUEBIA90C8gIAiR/CH4jBCEDIwRB4ABqJAQgA0E0aiICQgA3AgAgAkIANwIIIAJCADcCECACQgA3AhggAkEANgIgIANBEGoiEUEEaiIEQgA3AgAgBEIANwIIIARCADcCECAEQgA3AhggEUEBNgIAIAMiB0EEaiEjIAdBCGohJCAHQQxqISVBfyEDIAAoAgAhBCABKAIAIQ0gACgCDCETIAEoAgwhFCAAKAIQIRUgASgCECEWIAAoAhQhFyABKAIUIRggACgCGCEZIAEoAhghGiAAKAIcIRsgASgCHCEcIAAoAiAhHSABKAIgIQ4gACgCBCEeIAEoAgQhHyAAKAIIISAgASgCCCEhA0BBACEiQQEhCEEAIQkgBCEFIA0hD0EAIQpBASELA0AgDyADQR91IgZzIAZrQQAgBUEBcWsiEHEgBWohBSAGIBBxIgwgA3MgDEF/c2ohAyAFIAxxIA9qIQ8gBUEBdiEFIAYgCHMgBmsgEHEgCmoiCiAMcSAIakEBdCEIIAsgCSAGcyAGayAQcWoiCyAMcSAJakEBdCEJICJBAWoiIkEeRw0ACyAHIAg2AgAgIyAJNgIAICQgCjYCACAlIAs2AgAgAiARIAcgARA7IAmsIiogHqwiK34gCKwiLCAfrCImfnwgKiAErCInfiAsIA2sIih+fEIeh3wiKadB/////wNxIQ0gC6wiLSArfiAKrCIrICZ+fCAtICd+ICsgKH58Qh6HfCImp0H/////A3EhBCAqICCsIid+ICwgIawiKH58IClCHod8IimnQf////8DcSEfIC0gJ34gKyAofnwgJkIeh3wiJqdB/////wNxIR4gKiATrCInfiAsIBSsIih+fCApQh6HfCIpp0H/////A3EhISAtICd+ICsgKH58ICZCHod8IianQf////8DcSEgICogFawiJ34gLCAWrCIofnwgKUIeh3wiKadB/////wNxIRQgLSAnfiArICh+fCAmQh6HfCImp0H/////A3EhEyAqIBesIid+ICwgGKwiKH58IClCHod8IimnQf////8DcSEWIC0gJ34gKyAofnwgJkIeh3wiJqdB/////wNxIRUgKiAZrCInfiAsIBqsIih+fCApQh6HfCIpp0H/////A3EhGCAtICd+ICsgKH58ICZCHod8IianQf////8DcSEXICogG6wiJ34gLCAcrCIofnwgKUIeh3wiKadB/////wNxIRogLSAnfiArICh+fCAmQh6HfCImp0H/////A3EhGSAqIB2sIip+ICwgDqwiLH58IClCHod8IienQf////8DcSEcIC0gKn4gKyAsfnwgJkIeh3wiKqdB/////wNxIRsgJ0IeiKchDiAqQh6IpyEdIBJBAWoiEkEZRw0ACyACIA4gARA6IAAgAikCADcCACAAIAIpAgg3AgggACACKQIQNwIQIAAgAikCGDcCGCAAIAIoAiA2AiAgByQEC6JLATN/IwQhCSMEQfABaiQEIABCgYKEiJCgwIABNwIAIABCgYKEiJCgwIABNwIIIABCgYKEiJCgwIABNwIQIABCgYKEiJCgwIABNwIYIABBIGoiGUIANwIAIBlCADcCCCAZQgA3AhAgGUIANwIYIAkiCiAZEB4gCkHgAGoiDSgCACIJQT9xIQQgDSAJQSBqNgIAIApBIGohCwJAAkBBwAAgBGsiCUEgSwRAIAAhCSAEIQNBICEIDAEFIAsgBGogACAJEA4aIAAgCWohAyAKIAsQDUEgIAlrIghBwABJBH8gAwUgAEHkAGogBEGgf2oiB0FAcSIGQRxyIARraiEEIAghCSADIQgDQCALIAgpAAA3AAAgCyAIKQAINwAIIAsgCCkAEDcAECALIAgpABg3ABggCyAIKQAgNwAgIAsgCCkAKDcAKCALIAgpADA3ADAgCyAIKQA4NwA4IAhBQGshCCAKIAsQDSAJQUBqIglBwABPDQALIAcgBmshCCAECyEJIAgEQEEAIQMMAgsLDAELIAsgA2ogCSAIEA4aCyANKAIAIghBP3EhCSANIAhBAWo2AgAgCkEgaiELAkACQEHAACAJayIIQQFLBEBBxC0hA0EBIQgMAQUgCyAJakEAIAgQGRogCEHELWohAyAKIAsQDUEBIAhrIghBwABJBH8gAwUgCUGBf2oiB0FAcSIGIAlrQcQuaiEEIAghCSADIQgDQCALIAgpAAA3AAAgCyAIKQAINwAIIAsgCCkAEDcAECALIAgpABg3ABggCyAIKQAgNwAgIAsgCCkAKDcAKCALIAgpADA3ADAgCyAIKQA4NwA4IAhBQGshCCAKIAsQDSAJQUBqIglBwABPDQALIAcgBmshCCAECyEJIAgEQCAJIQNBACEJDAILCwwBCyALIAlq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AUEIIQIMAQUgBCADaiAJIAIQDhogCSACaiEBIAogBBANQQggAmsiAkHAAE8EQANAIAQgASkAADcAACAEIAEpAAg3AAggBCABKQAQNwAQIAQgASkAGDcAGCAEIAEpACA3ACAgBCABKQAoNwAoIAQgASkAMDcAMCAEIAEpADg3ADggAUFAayEBIAogBBANIAJBQGoiAkHAAE8NAAsLIAIEQEEAIQMMAgsLDAELIAQgA2ogASACEA4aCyAKKAIAEAshDiAKQQA2AgAgGigCABALIQsgGkEANgIAIBsoAgAQCyEHIBtBADYCACAcKAIAEAshBiAcQQA2AgAgHSgCABALIQQgHUEANgIAIB4oAgAQCyEDIB5BADYCACAfKAIAEAshAiAfQQA2AgAgICgCABALIQEgIEEANgIAIAggDjYCACAiIAs2AgAgIyAHNgIAICQgBjYCACAlIAQ2AgAgJiADNgIAICcgAjYCACAoIAE2AgAgESgCACIBQT9xIQMgESABQSBqNgIAAkACQEHAACADayIEQSBLBEAgCCEBIAMhAkEgIQMMAQUgBSADaiAIIAQQDhogCCAEaiECIAwgBRANQSAgBGsiAUHAAEkEfyABIQMgAgUgA0Ggf2oiA0EGdkEBdCEGIARBQGohBANAIAUgAikAADcAACAFIAIpAAg3AAggBSACKQAQNwAQIAUgAikAGDcAGCAFIAIpACA3ACAgBSACKQAoNwAoIAUgAikAMDcAMCAFIAIpADg3ADggAkFAayECIAwgBRANIAFBQGoiAUHAAE8NAAsgA0E/cSEDIAggBkEEakEFdGogBGoLIQEgAwRAQQAhAgwCCwsMAQsgBSACaiABIAMQDhoLIAkgESgCACIBQR12QRh0NgIAIAkgAUELdEGAgPwHcSABQRt0ciABQQV2QYD+A3FyIAFBFXZB/wFxcjYCBCARIAFBNyABa0E/cUEBaiICajYCAAJAAkAgAkHAACABQT9xIgFrIgNJBEBBqRMhAwwBBSAFIAFqQakTIAMQDhogA0GpE2ohASAMIAUQDSACIANrIgJBwABPBEADQCAFIAEpAAA3AAAgBSABKQAINwAIIAUgASkAEDcAECAFIAEpABg3ABggBSABKQAgNwAgIAUgASkAKDcAKCAFIAEpADA3ADAgBSABKQA4NwA4IAFBQGshASAMIAUQDSACQUBqIgJBwABPDQALCyACBEAgASEDQQAhAQwCCwsMAQsgBSABaiADIAIQDhoLIBEoAgAiAUE/cSEDIBEgAUEIajYCAAJAAkBBwAAgA2siAkEISwRAIAkhAUEIIQIMAQUgBSADaiAJIAIQDhogCSACaiEBIAwgBRANQQggAmsiAkHAAE8EQANAIAUgASkAADcAACAFIAEpAAg3AAggBSABKQAQNwAQIAUgASkAGDcAGCAFIAEpACA3ACAgBSABKQAoNwAoIAUgASkAMDcAMCAFIAEpADg3ADggAUFAayEBIAwgBRANIAJBQGoiAkHAAE8NAAsLIAIEQEEAIQMMAgsLDAELIAUgA2ogASACEA4aCyAMKAIAEAshDiAMQQA2AgAgEygCABALIQsgE0EANgIAIBQoAgAQCyEHIBRBADYCACAVKAIAEAshBiAVQQA2AgAgFigCABALIQQgFkEANgIAIBcoAgAQCyEDIBdBADYCACAYKAIAEAshAiAYQQA2AgAgISgCABALIQEgIUEANgIAIC4gDjYAACAvIAs2AAAgMCAHNgAAIDEgBjYAACAyIAQ2AAAgMyADNgAAIDQgAjYAACA1IAE2AAAgCiAZEB4gDSgCACIBQT9xIQQgDSABQSBqNgIAIApBIGohCwJAAkBBwAAgBGsiAUEgSwRAIAAhASAEIQNBICECDAEFIAsgBGogACABEA4aIAAgAWohAyAKIAsQDUEgIAFrIgJBwABJBH8gAwUgAEHkAGogBEGgf2oiB0FAcSIGQRxyIARraiEEIAIhASADIQIDQCALIAIpAAA3AAAgCyACKQAINwAIIAsgAikAEDcAECALIAIpABg3ABggCyACKQAgNwAgIAsgAikAKDcAKCALIAIpADA3ADAgCyACKQA4NwA4IAJBQGshAiAKIAsQDSABQUBqIgFBwABPDQALIAcgBmshAiAECyEBIAIEQEEAIQMMAgsLDAELIAsgA2ogASACEA4aCyAJIA0oAgAiAUEddkEYdDYCACAJIAFBC3RBgID8B3EgAUEbdHIgAUEFdkGA/gNxciABQRV2Qf8BcXI2AgQgDSABQTcgAWtBP3FBAWoiAmo2AgAgCkEgaiEEAkACQCACQcAAIAFBP3EiAWsiA0kEQEGpEyEDDAEFIAQgAWpBqRMgAxAOGiADQakTaiEBIAogBBANIAIgA2siAkHAAE8EQANAIAQgASkAADcAACAEIAEpAAg3AAggBCABKQAQNwAQIAQgASkAGDcAGCAEIAEpACA3ACAgBCABKQAoNwAoIAQgASkAMDcAMCAEIAEpADg3ADggAUFAayEBIAogBBANIAJBQGoiAkHAAE8NAAsLIAIEQCABIQNBACEBDAILCwwBCyAEIAFqIAMgAhAOGgsgDSgCACIBQT9xIQMgDSABQQhqNgIAIApBIGohBAJAAkBBwAAgA2siAkEISwRAIAkhAUEIIQIMAQUgBCADaiAJIAIQDhogCSACaiEBIAogBBANQQggAmsiAkHAAE8EQANAIAQgASkAADcAACAEIAEpAAg3AAggBCABKQAQNwAQIAQgASkAGDcAGCAEIAEpACA3ACAgBCABKQAoNwAoIAQgASkAMDcAMCAEIAEpADg3ADggAUFAayEBIAogBBANIAJBQGoiAkHAAE8NAAsLIAIEQEEAIQMMAgsLDAELIAQgA2ogASACEA4aCyAKKAIAEAshDiAKQQA2AgAgGigCABALIQsgGkEANgIAIBsoAgAQCyEHIBtBADYCACAcKAIAEAshBiAcQQA2AgAgHSgCABALIQQgHUEANgIAIB4oAgAQCyEDIB5BADYCACAfKAIAEAshAiAfQQA2AgAgICgCABALIQEgIEEANgIAIAggDjYCACAiIAs2AgAgIyAHNgIAICQgBjYCACAlIAQ2AgAgJiADNgIAICcgAjYCACAoIAE2AgAgESgCACIBQT9xIQMgESABQSBqNgIAAkACQEHAACADayIEQSBLBEAgCCEBIAMhAkEgIQMMAQUgBSADaiAIIAQQDhogCCAEaiECIAwgBRANQSAgBGsiAUHAAEkEfyABIQMgAgUgA0Ggf2oiA0EGdkEBdCEGIARBQGohBANAIAUgAikAADcAACAFIAIpAAg3AAggBSACKQAQNwAQIAUgAikAGDcAGCAFIAIpACA3ACAgBSACKQAoNwAoIAUgAikAMDcAMCAFIAIpADg3ADggAkFAayECIAwgBRANIAFBQGoiAUHAAE8NAAsgA0E/cSEDIAggBkEEakEFdGogBGoLIQEgAwRAQQAhAgwCCwsMAQsgBSACaiABIAMQDhoLIAkgESgCACIBQR12QRh0NgIAIAkgAUELdEGAgPwHcSABQRt0ciABQQV2QYD+A3FyIAFBFXZB/wFxcjYCBCARIAFBNyABa0E/cUEBaiICajYCAAJAAkAgAkHAACABQT9xIgFrIghJBEBBqRMhCAwBBSAFIAFqQakTIAgQDhogCEGpE2ohASAMIAUQDSACIAhrIgJBwABPBEADQCAFIAEpAAA3AAAgBSABKQAINwAIIAUgASkAEDcAECAFIAEpABg3ABggBSABKQAgNwAgIAUgASkAKDcAKCAFIAEpADA3ADAgBSABKQA4NwA4IAFBQGshASAMIAUQDSACQUBqIgJBwABPDQALCyACBEAgASEIQQAhAQwCCwsMAQsgBSABaiAIIAIQDhoLIBEoAgAiAUE/cSECIBEgAUEIajYCAAJAQcAAIAJrIghBCEsEQCAJIQEgAiEJQQghAgUgBSACaiAJIAgQDhogCSAIaiEBIAwgBRANQQggCGsiAkHAAE8EQANAIAUgASkAADcAACAFIAEpAAg3AAggBSABKQAQNwAQIAUgASkAGDcAGCAFIAEpACA3ACAgBSABKQAoNwAoIAUgASkAMDcAMCAFIAEpADg3ADggAUFAayEBIAwgBRANIAJBQGoiAkHAAE8NAAsLIAIEQEEAIQkMAgsgDCgCABALIQcgDEEANgIAIBMoAgAQCyEGIBNBADYCACAUKAIAEAshBCAUQQA2AgAgFSgCABALIQMgFUEANgIAIBYoAgAQCyEIIBZBADYCACAXKAIAEAshCSAXQQA2AgAgGCgCABALIQIgGEEANgIAICEoAgAQCyEBIAAgBzYAACApIAY2AAAgKiAENgAAICsgAzYAACAsIAg2AAAgLSAJNgAAIBIgAjYAACAQIAE2AAAgAEFAa0EANgIAIAokBA8LCyAFIAlqIAEgAhAOGiAMKAIAEAshByAMQQA2AgAgEygCABALIQYgE0EANgIAIBQoAgAQCyEEIBRBADYCACAVKAIAEAshAyAVQQA2AgAgFigCABALIQggFkEANgIAIBcoAgAQCyEJIBdBADYCACAYKAIAEAshAiAYQQA2AgAgISgCABALIQEgACAHNgAAICkgBjYAACAqIAQ2AAAgKyADNgAAICwgCDYAACAtIAk2AAAgEiACNgAAIBAgATYAACAAQUBrQQA2AgAgCiQEC/AEAQd/IwQhAyMEQTBqJAQgA0EANgIAIANBCGoiB0IANwAAIAdCADcACCAHQgA3ABAg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cTYCACAMIARB/////wNxNgIAIA0gBUH/////A3E2AgAgDyAHQf////8DcTYCACASIAhB/////wNxNgIAIBUgCUH/////A3E2AgAgGCAKQf////8DcTYCACAbIANB/////wNxNgIAIAsgASAdcSAGaiADQR51ajYCAAuFCAIIfwx+IAFBIGoiBigCAEEfdSIEIAIoAgQiBXEgAEEgaiIHKAIAQR91IgggAigCACIJcWoiCiADKAIkIgsgASgCAKwiDiAFrCITfiAAKAIArCIUIAmsIhV+fCIMp2wgCmpB/////wNxa6whEiAEIAIoAgwiBHEgCCACKAIIIgJxaiIFIAsgDiAErCIWfiAUIAKsIhR+fCINp2wgBWpB/////wNxa6whDiAAIABBBGoiAigCAKwiDyAVfiASIAMoAgCsIhB+IAx8Qh6HfCABQQRqIgQoAgCsIgwgE358IAMoAgSsIhEgEn58IhenQf////8DcTYCACABIA8gFH4gDiAQfiANfEIeh3wgDCAWfnwgESAOfnwiDKdB/////wNxNgIAIAIgAEEIaiICKAIArCINIBV+IBdCHod8IAFBCGoiBSgCAKwiDyATfnwgAygCCKwiECASfnwiEadB/////wNxNgIAIAQgDSAUfiAMQh6HfCAPIBZ+fCAQIA5+fCIMp0H/////A3E2AgAgAiAAQQxqIgIoAgCsIg0gFX4gEUIeh3wgAUEMaiIEKAIArCIPIBN+fCADKAIMrCIQIBJ+fCIRp0H/////A3E2AgAgBSANIBR+IAxCHod8IA8gFn58IBAgDn58IgynQf////8DcTYCACACIABBEGoiAigCAKwiDSAVfiARQh6HfCABQRBqIgUoAgCsIg8gE358IAMoAhCsIhAgEn58IhGnQf////8DcTYCACAEIA0gFH4gDEIeh3wgDyAWfnwgECAOfnwiDKdB/////wNxNgIAIAIgAEEUaiICKAIArCINIBV+IBFCHod8IAFBFGoiBCgCAKwiDyATfnwgAygCFKwiECASfnwiEadB/////wNxNgIAIAUgDSAUfiAMQh6HfCAPIBZ+fCAQIA5+fCIMp0H/////A3E2AgAgAiAAQRhqIgIoAgCsIg0gFX4gEUIeh3wgAUEYaiIFKAIArCIPIBN+fCADKAIYrCIQIBJ+fCIRp0H/////A3E2AgAgBCANIBR+IAxCHod8IA8gFn58IBAgDn58IgynQf////8DcTYCACACIABBHGoiACgCAKwiDSAVfiARQh6HfCABQRxqIgEoAgCsIg8gE358IAMoAhysIhAgEn58IhGnQf////8DcTYCACAFIA0gFH4gDEIeh3wgDyAWfnwgECAOfnwiDKdB/////wNxNgIAIAAgBygCAKwiDSAVfiARQh6HfCAGKAIArCIVIBN+fCADKAIgrCITIBJ+fCISp0H/////A3E2AgAgASANIBR+IAxCHod8IBUgFn58IBMgDn58Ig6nQf////8DcTYCACAHIBJCHog+AgAgBiAOQh6IPgIAC+YBAQN/IABB4ABqIgMoAgAiBEE/cSEFIAMgBCACajYCAEHAACAFayIEIAJNBEAgAEEgaiIDIAVqIAEgBBAOGiABIARqIQEgACADEA0gAiAEayICQcAASQRAQQAhBQUDQCADIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABggAyABKQAgNwAgIAMgASkAKDcAKCADIAEpADA3ADAgAyABKQA4NwA4IAFBQGshASAAIAMQDSACQUBqIgJBwABPDQBBACEFCwsLIAJFBEAPCyAAQSBqIAVqIAEgAhAOGgvrBgEOfyMEIQcjBEGgAWokBCAAIAEoAngiAzYCUCADBEAgByQEDwsgB0H4AGoiAiABQdAAaiIFKQIANwIAIAIgBSkCCDcCCCACIAUpAhA3AhAgAiAFKQIYNwIYIAIgBSkCIDcCICACEBcgAigCCCEIIAIoAgwhCSACKAIQIQogAigCFCELIAIoAhghDyACKAIcIQ0gAigCICEGIAIoAiQhDCAHQdAAaiIEIAIoAgQiA0EadCACKAIAckH/////A3E2AgAgBEEEaiIOIAhBFnRBgICA/gNxIANBBHZyNgIAIARBCGoiAiAJQRJ0QYCA8P8DcSAIQQh2cjYCACAEQQxqIgggCkEOdEGAgP//A3EgCUEMdnI2AgAgBEEQaiIJIAtBCnRBgPj//wNxIApBEHZyNgIAIARBFGoiCiAPQQZ0QcD///8DcSALQRR2cjYCACAEQRhqIgsgDUECdCAPQRh2ciAGQRx0ckH/////A3E2AgAgBEEcaiINIAxBGHRBgICA+ANxIAZBAnZyNgIAIARBIGoiAyAMQQZ2NgIAIARBhAkQJiAOKAIAIQ4gAigCACECIAgoAgAhCCAJKAIAIQkgCigCACEKIAsoAgAhDCANKAIAIQsgAygCACENIAUgBCgCACIDQf///x9xNgIAIAFB1ABqIgYgDkEEdEHw//8fcSADQRp2cjYCACABIAJBCHRBgP7/H3EgDkEWdnI2AlggASAIQQx0QYDg/x9xIAJBEnZyNgJcIAEgCUEQdEGAgPwfcSAIQQ52cjYCYCABIApBFHRBgIDAH3EgCUEKdnI2AmQgASAMQRh0QYCAgBhxIApBBnZyNgJoIAEgDEECdkH///8fcTYCbCABIAtBAnRB/P//H3EgDEEcdnI2AnAgASANQQZ0IAtBGHZyNgJ0IAdBKGoiAyAFEAogByAFIAMQDCABIAEgAxAMIAFBKGoiAyADIAcQDCAFQQE2AgAgBkIANwIAIAZCADcCCCAGQgA3AhAgBkIANwIYIAZBADYCICAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACABKQIgNwIgIABBKGoiACADKQIANwIAIAAgAykCCDcCCCAAIAMpAhA3AhAgACADKQIYNwIYIAAgAykCIDcCICAHJAQLrwkBDX8jBCEFIwRBkAFqJAQgBUGIAWohCCAFQegAaiEGIAVBkfSy53k2AgAgBUEEaiILQYGnyZwCNgIAIAVBCGoiCkGSop6LATYCACAFQQxqIgxBj/yJi302AgAgBUEQaiINQdDqob55NgIAIAVBFGoiDkHljvMBNgIAIAVBGGoiD0HkotiHeTYCACAFQRxqIhBB6uymnwM2AgAgBUEgaiIEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBUHgAGoiB0GAATYCACAFQUBrIgEgAykAADcAACABIAMpAAg3AAggASADKQAQNwAQIAEgAykAGDcAGCAFIAQQDSAHKAIAIgFBP3EhAyAHIAFBIGo2AgACQAJAQcAAIANrIglBIEsEQCACIQFBICECDAEFIAQgA2ogAiAJEA4aIAIgCWohASAFIAQQDUEgIAlrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAFIAQQDSACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAEIANqIAEgAhAOGgsgCCAHKAIAIgFBHXZBGHQ2AgAgCCABQQt0QYCA/AdxIAFBG3RyIAFBBXZBgP4DcXIgAUEVdkH/AXFyNgIEIAcgAUE3IAFrQT9xQQFqIgJqNgIAAkACQCACQcAAIAFBP3EiAWsiA0kEQEGpEyEDDAEFIAQgAWpBqRMgAxAOGiADQakTaiEBIAUgBBANIAIgA2siAkHAAE8EQANAIAQgASkAADcAACAEIAEpAAg3AAggBCABKQAQNwAQIAQgASkAGDcAGCAEIAEpACA3ACAgBCABKQAoNwAoIAQgASkAMDcAMCAEIAEpADg3ADggAUFAayEBIAUgBBANIAJBQGoiAkHAAE8NAAsLIAIEQCABIQNBACEBDAILCwwBCyAEIAFqIAMgAhAOGgsgBygCACIBQT9xIQMgByABQQhqNgIAAkACQEHAACADayICQQhLBEAgCCEBQQghAgwBBSAEIANqIAggAhAOGiAIIAJqIQEgBSAEEA1BCCACayICQcAATwRAA0AgBCABKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIAQgASkAIDcAICAEIAEpACg3ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgBSAEEA0gAkFAaiICQcAATw0ACwsgAgRAQQAhAwwCCwsMAQsgBCADaiABIAIQDhoLIAUoAgAQCyEEIAVBADYCACALKAIAEAshByALQQA2AgAgCigCABALIQkgCkEANgIAIAwoAgAQCyEKIAxBADYCACANKAIAEAshCCANQQA2AgAgDigCABALIQMgDkEANgIAIA8oAgAQCyECIA9BADYCACAQKAIAEAshASAGIAQ2AgAgBiAHNgIEIAYgCTYCCCAGIAo2AgwgBiAINgIQIAYgAzYCFCAGIAI2AhggBiABNgIcIAAgBkEAEBAgBSQEC8kNAht/An4jBCEHIwRBoANqJAQgB0G4AmoiAkIANwAAIAJCADcACCACQgA3ABAgAkIANwAYIAJCADcAICACQgA3ACggAkIANwAwIAJCADcAOCABRQRAIABBADYCnAEgAEEkaiIDQbAIKQIANwIAIANBuAgpAgA3AgggA0HACCkCADcCECADQcgIKQIANwIYIANB0AgpAgA3AiAgAEEBNgJ0IABB+ABqIgNCADcCACADQgA3AgggA0IANwIQIANCADcCGCADQQA2AiAgAEGEuLznADYCTCAAQf61r/AANgJQIABBuMz59QA2AlQgAEHny/X2ADYCWCAAQcjQi/gANgJcIABB0vvu4wA2AmAgAEG8gMHtADYCZCAAQYbVuecANgJoIABB2bKj7AA2AmwgAEHG4rcHNgJwIABBATYCBCAAQQhqIgNCADcCACADQgA3AgggA0IANwIQIANBADYCGAsgB0H4AmoiBSAAQQRqIhIQHCACIAUpAAA3AAAgAiAFKQAINwAIIAIgBSkAEDcAECACIAUpABg3ABggAUEARyIGBEAgAkEgaiIDIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABgLIAdBkAJqIQggB0HwAWohAyAHQfAAaiEEIAdByABqIQEgByACIAYEf0HAAAVBIAsQNyACQgA3AAAgAkIANwAIIAJCADcAECACQgA3ABggAkIANwAgIAJCADcAKCACQgA3ADAgAkIANwA4IAcgBRArIAEgBRAbRSABQQRqIgYoAgAiCSABKAIAIgpyIAFBCGoiCygCACIMciABQQxqIg0oAgAiDnIgAUEQaiIPKAIAIhByIAFBFGoiESgCACITciABQRhqIhQoAgAiFXIgAUEcaiIWKAIAIhdyIAFBIGoiGCgCACIZciABQSRqIhooAgAiG3JFciICIRwgASACBH9BAAUgCgsgHHI2AgAgBiACBH9BAAUgCQs2AgAgCyACBH9BAAUgDAs2AgAgDSACBH9BAAUgDgs2AgAgDyACBH9BAAUgEAs2AgAgESACBH9BAAUgEws2AgAgFCACBH9BAAUgFQs2AgAgFiACBH9BAAUgFws2AgAgGCACBH9BAAUgGQs2AgAgGiACBH9BAAUgGws2AgAgCCABEAogAEEkaiICIAIgCBAMIABBzABqIgYgBiAIEAwgBiAGIAEQDCAAQfQAaiIIIAggARAMIAFCADcCACABQgA3AgggAUIANwIQIAFCADcCGCABQgA3AiAgByAFECsgAyAFQQAQECADQQRqIggoAgAiDiADKAIAIg9yIANBCGoiBigCACIQciADQQxqIgkoAgAiEXIgA0EQaiIKKAIAIhNyIANBFGoiCygC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ovoKfCAoQiCIfCIoICmDPgIAIAggCUF/c61C5rm71Qt8IChCIIh8IiggKYM+AgAgCiALQX9zrUL+////D3wgKEIgiHwiKCApgz4CACAMIA1Bf3OtQv////8PfCAoQiCIfCIoICmDPgIAIA8gEEF/c61C/////w98IChCIIh8IiggKYM+AgAgESASQX9zrUL/////D3wgKEIgiHwgKYM+AgAgBEGAAWoiAUEANgJ4IAEgGjYCACABIBs2AgQgASAcNgIIIAEgHTYCDCABIB42AhAgASAiNgIUIAEgHzYCGCABICA2AhwgASAhNgIgIAEgIzYCJCABIBNB////H3E2AiggASAUQQZ0QcD//x9xIBNBGnZyNgIsIAEgFUEMdEGA4P8fcSAUQRR2cjYCMCABIBZBEnRBgIDwH3EgFUEOdnI2AjQgASAOQRh0QYCAgBhxIBZBCHZyNgI4IAEgDkECdkH///8fcTYCPCABQUBrIBdBBHRB8P//H3EgDkEcdnI2AgAgASAYQQp0QYD4/x9xIBdBFnZyNgJEIAEgGUEQdEGAgPwfcSAYQRB2cjYCSCABIBlBCnY2AkwgAUEBNgJQIAFB1ABqIgJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCACQQA2AiAgACAEQfwBaiICIAEgBSAkECcgBEEEaiIAIAIQPSAAKAJQBEAgBCQEQQAPCyAAQShqIgEQFyABKAIAQQFxBEAgBCQEQQAPC0H8/f//ACAGKAIEayECQfz///8AIAYoAghrIQNB/P///wAgBigCDGshBUH8////ACAGKAIQayEHQfz///8AIAYoAhRrIQhB/P///wAgBigCGGshCUH8////ACAGKAIcayEKQfz///8AIAYoAiBrIQtB/P//ByAGKAIkayEMIARBuANqIgFBvOH//wAgBigCAGsgACgCAGo2AgAgASACIAAoAgRqNgIEIAEgAyAAKAIIajYCCCABIAUgACgCDGo2AgwgASAHIAAoAhBqNgIQIAEgCCAAKAIUajYCFCABIAkgACgCGGo2AhggASAKIAAoAhxqNgIcIAEgCyAAKAIgajYCICABIAwgACgCJGo2AiQgARAYQQBHIQAgBCQEIAALkRECFX8CfiMEIQojBEHwA2okBCAKQdADaiIOQgA3AAAgDkIANwAIIA5CADcAECAOQgA3ABgg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BGogAyAHEA4aIAMgB2ohAiAGIAgQDUEgIAdrIgNBwABPBEADQCAIIAIpAAA3AAAgCCACKQAINwAIIAggAikAEDcAECAIIAIpABg3ABggCCACKQAgNwAgIAggAikAKDcAKCAIIAIpADA3ADAgCCACKQA4NwA4IAJBQGshAiAGIAgQDSADQUBqIgNBwABPDQALCyADBEBBACEEDAILCwwBCyAIIARqIAIgAxAOGgsgBSgCACICQT9xIQMgBSACQSBqNgIAIAZBIGohBAJAAkBBwAAgA2siAkEgSwRAQSAhAgwBBSAEIANqIAEgAhAOGiABIAJqIQEgBiAEEA1BICACayICQcAATwRAA0AgBCABKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIAQgASkAIDcAICAEIAEpACg3ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgBiAEEA0gAkFAaiICQcAATw0ACwsgAgRAQQAhAwwCCwsMAQsgBCADaiABIAIQDhoLIA0gBSgCACIBQR12QRh0NgIAIA0gAUELdEGAgPwHcSABQRt0ciABQQV2QYD+A3FyIAFBFXZB/wFxcjYCBCAFIAFBNyABa0E/cUEBaiICajYCACAGQSBqIQQCQAJAIAJBwAAgAUE/cSIBayIDSQRAQakTIQMMAQUgBCABakGpEyADEA4aIANBqRNqIQEgBiAEEA0gAiADayICQcAATwRAA0AgBCABKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIAQgASkAIDcAICAEIAEpACg3ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgBiAEEA0gAkFAaiICQcAATw0ACwsgAgRAIAEhA0EAIQEMAgsLDAELIAQgAWogAyACEA4aCyAFKAIAIgFBP3EhAyAFIAFBCGo2AgAgBkEgaiEEAkACQEHAACADayICQQhLBEAgDSEBQQghAgwBBSAEIANqIA0gAhAOGiANIAJqIQEgBiAEEA1BCCACayICQcAATwRAA0AgBCABKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIAQgASkAIDcAICAEIAEpACg3ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgBiAEEA0gAkFAaiIC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aykCADcCACAMIAcpAkg3AkggDCAHKAJQNgJQIAwgDEH0ChAMIAxB1ABqIgIgB0HUAGoiACkCADcCACACIAApAgg3AgggAiAAKQIQNwIQIAIgACkCGDcCGCACIAApAiA3AiAgAiAAKQIoNwIoIAIgACkCMDcCMCACIAApAjg3AjggAkFAayAAQUBrKQIANwIAIAIgACkCSDcCSCACIAAoAlA2AlAgAiACQfQKEAwgDEGoAWoiAiAHQagBaiIAKQIANwIAIAIgACkCCDcCCCACIAApAhA3AhAgAiAAKQIYNwIYIAIgACkCIDcCICACIAApAig3AiggAiAAKQIwNwIwIAIgACkCODcCOCACQUBrIABBQGspAgA3AgAgAiAAKQJINwJIIAIgACgCUDYCUCACIAJB9AoQDCAMQfwBaiICIAdB/AFqIgApAgA3AgAgAiAAKQIINwIIIAIgACkCEDcCECACIAApAhg3AhggAiAAKQIgNwIgIAIgACkCKDcCKCACIAApAjA3AjAgAiAAKQI4NwI4IAJBQGsgAEFAaykCADcCACACIAApAkg3AkggAiAAKAJQNgJQIAIgAkH0ChAMIAxB0AJqIgIgB0HQAmoiACkCADcCACACIAApAgg3AgggAiAAKQIQNwIQIAIgACkCGDcCGCACIAApAiA3AiAgAiAAKQIoNwIoIAIgACkCMDcCMCACIAApAjg3AjggAkFAayAAQUBrKQIANwIAIAIgACkCSDcCSCACIAAoAlA2AlAgAiACQfQKEAwgDEGkA2oiAiAHQaQDaiIAKQIANwIAIAIgACkCCDcCCCACIAApAhA3AhAgAiAAKQIYNwIYIAIgACkCIDcCICACIAApAig3AiggAiAAKQIwNwIwIAIgACkCODcCOCACQUBrIABBQGspAgA3AgAgAiAAKQJINwJIIAIgACgCUDYCUCACIAJB9AoQDCAMQfgDaiICIAdB+ANqIgApAgA3AgAgAiAAKQIINwIIIAIgACkCEDcCECACIAApAhg3AhggAiAAKQIgNwIgIAIgACkCKDcCKCACIAApAjA3AjAgAiAAKQI4NwI4IAJBQGsgAEFAaykCADcCACACIAApAkg3AkggAiAAKAJQNgJQIAIgAkH0ChAMIAxBzARqIgAgCCkCADcCACAAIAgpAgg3AgggACAIKQIQNwIQIAAgCCkCGDcCGCAAIAgpAiA3AiAgACAIKQIoNwIoIAAgCCkCMDcCMCAAIAgpAjg3AjggAEFAayAIQUBrKQIANwIAIAAgCCkCSDcCSCAAIAgoAlA2AlAgACAAQfQKEAwgRCgCgAEiKkEfdSIAICpqIABzIi9BAXUhCSAQIAcpAgA3AgAgECAHKQIINwIIIBAgBykCEDcCECAQIAcpAhg3AhggECAHKQIgNwIgIBBBKGoiEyAtKQIANwIAIBMgLSkCCDcCCCATIC0pAhA3AhAgEyAtKQIYNwIYIBMgLSkCIDcCIEEBIQYgECgCACEeIBBBBGoiMSgCACEfIBBBCGoiMigCACEWIBBBDGoiMygCACEXIBBBEGoiNCgCACEYIBBBFGoiNSgCACEZIBBBGGoiNigCACEaIBBBHGoiNygCACEDIBBBIGoiOCgCACECIBBBJGoiOSgCACEAIBMoAgAhHSAQQSxqIjooAgAhKCAQQTBqIjsoAgAhISAQQTRqIjwoAgAhDiAQQThqIj0oAgAhDyAQQTxqIj4oAgAhIyAQQUBrIj8oAgAhJCAQQcQAaiJAKAIAISUgEEHIAGoiQSgCACEmIBBBzABqIkIoAgAhJwNAIAcgBkHUAGxqKAIAIQggBiAJRiIpBEAgCCEeCyAHIAZB1ABsaigCBCEIICkEQCAIIR8LIAcgBkHUAGxqKAIIIQggKQRAIAghFgsgByAGQdQAbGooAgwhCCApBEAgCCEXCyAHIAZB1ABsaigCECEIICkEQCAIIRgLIAcgBkHUAGxqKAIUIQggKQRAIAghGQsgByAGQdQAbGooAhghCCApBEAgCCEaCyAHIAZB1ABsaigCHCEIICkEQCAIIQMLIAcgBkHUAGxqKAIgIQggKQRAIAghAgsgByAGQdQAbGooAiQhCCApBEAgCCEACyAHIAZB1ABsaigCKCEIICkEQCAIIR0LIAcgBkHUAGxqKAIsIQggKQRAIAghKAsgByAGQdQAbGooAjAhCCApBEAgCCEhCyAHIAZB1ABsaigCNCEIICkEQCAIIQ4LIAcgBkHUAGxqKAI4IQggKQRAIAghDwsgByAGQdQAbGooAjwhCCApBEAgCCEjCyAHIAZB1ABsakFAaygCACEIICkEQCAIISQLIAcgBkHUAGxqKAJEIQggKQRAIAghJQsgByAGQdQAbGooAkghCCApBEAgCCEmCyAHIAZB1ABsaigCTCEIICkEQCAIIScLIAZBAWoiBkEIRw0ACyAQIB42AgAgMSAfNgIAIDIgFjYCACAzIBc2AgAgNCAYNgIAIDUgGTYCACA2IBo2AgAgNyADNgIAIDggAjYCACA5IAA2AgAgEEHQAGoiKUEANgIAQbzh//8AIB1rIR5B/P3//wAgKGshH0H8////ACAhayEWQfz///8AIA5rIRdB/P///wAgD2shGEH8////ACAjayEZQfz///8AICRrIRpB/P///wAgJWshA0H8////ACAmayECQfz//wcgJ2shACATICogL0ciBgR/IB4FIB0LNgIAIDogBgR/IB8FICgLNgIAIDsgBgR/IBYFICELNgIAIDwgBgR/IBcFIA4LNgIAID0gBgR/IBgFIA8LNgIAID4gBgR/IBkFICMLNgIAID8gBgR/IBoFICQLNgIAIEAgBgR/IAMFICULNgIAIEEgBgR/IAIFICYLNgIAIEIgBgR/IAAFICcLNgIAICJBADYCACAgIBApAgA3AgAgICAQKQIINwIIICAgECkCEDcCECAgIBApAhg3AhggICAQKQIgNwIgIC4gEykCADcCACAuIBMpAgg3AgggLiATKQIQNwIQIC4gEykCGDcCGCAuIBMpAiA3AiAgLEEBNgIAIBJCADcCACASQgA3AgggEkIANwIQIBJCADcCGCASQQA2AiAgRSgCgAEiLEEfdSIAICxqIABzIi9BAXUhCSAQIAwpAgA3AgAgECAMKQIINwIIIBAgDCkCEDcCECAQIAwpAhg3AhggECAMKQIgNwIgIBMgDEEoaiIqKQIANwIAIBMgKikCCDcCCCATICopAhA3AhAgEyAqKQIYNwIYIBMgKikCIDcCIEEBIQYgECgCACEeIDEoAgAhHyAyKAIAIRYgMygCACEXIDQoAgAhGCA1KAIAIRkgNigCACEaIDcoAgAhAyA4KAIAIQIgOSgCACEAIBMoAgAhHSA6KAIAISggOygCACEhIDwoAgAhDiA9KAIAIQ8gPigCACEjID8oAgAhJCBAKAIAISUgQSgCACEmIEIoAgAhJwNAIAwgBkHUAGxqKAIAIQggBiAJRiIiBEAgCCEeCyAMIAZB1ABsaigCBCEIICIEQCAIIR8LIAwgBkHUAGxqKAIIIQggIgRAIAghFgsgDCAGQdQAbGooAgwh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ACA5IAA2AgAgKUEANgIAQbzh//8AIB1rIR5B/P3//wAgKGshH0H8////ACAhayEWQfz///8AIA5rIRdB/P///wAgD2shGEH8////ACAjayEZQfz///8AICRrIRpB/P///wAgJWshA0H8////ACAmayECQfz//wcgJ2shACATICIgLEciBgR/IB4FIB0LNgIAIDogBgR/IB8FICgLNgIAIDsgBgR/IBYFICELNgIAIDwgBgR/IBcFIA4LNgIAID0gBgR/IBgFIA8LNgIAID4gBgR/IBkFICMLNgIAID8gBgR/IBoFICQLNgIAIEAgBgR/IAMFICULNgIAIEEgBgR/IAIFICYLNgIAIEIgBgR/IAAFICcLNgIAICAgICAQECMgCEF/aiEAIAhBAEoEQCAAIQgMAQsLICBB0ABqIgAgACAwEAwgCiARKQIANwIAIAogESkCCDcCCCAKIBEpAhA3AhAgCiARKQIYNwIYIAogESkCIDcCICAKIBEpAig3AiggCiARKQIwNwIwIAogESkCODcCOCAKQUBrIBFBQGspAgA3AgAgCiARKQJINwJIIAogESgCUDYCUCAVQfgAaiICIApB0ABqIkcoAgAiADYCACAVIBEpAgA3AgAgFSARKQIINwIIIBUgESkCEDcCECAVIBEpAhg3AhggFSARKQIgNwIgIBVBKGoiAyAKQShqIkMpAgA3AgAgAyBDKQIINwIIIAMgQykCEDcCECADIEMpAhg3AhggAyBDKQIgNwIgIBVBATYCUCAVQdQAaiIDQgA3AgAgA0IANwIIIANCADcCECADQgA3AhggA0EANgIgIAAEQCACQQE2AgAFIBUgFRATCyAUQYAcaiEbIBRB4BtqIRwgBAR/IAQFQQELISEgCiAVEB8gCyARKQIANwIAIAsgESkCCDcCCCALIBEpAhA3AhAgCyARKQIYNwIYIAsgESkCIDcCICALEA8gDSArKQIANwIAIA0gKykCCDcCCCANICspAhA3AhAgDSArKQIYNwIYIA0gKykCIDcCICANEA8gCygCACFcIAsoAgQiDkEGdiFdIAsoAggiXkEUdCEPIAsoAgwiX0EOdCEwIAsoAhAiAEEIdCEpIAsoAhRBAnQgAEEYdnIhYCALKAIYImFBHHQhRCALKAIcImJBFnQhRSALKAIgImNBEHQhKiALKAIkQQp0ISIg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FnYiAkHRB2wgCSgCAGohACACQQZ0IAlBBGoiDygCAGogAEEadmoiDEEadiAJQQhqIg0oAgBqIgpBGnYgCUEMaiIRKAIAaiILQRp2IAlBEGoiECgCAGoiDkEadiAJQRRqIhUoAgBqIhJBGnYgCUEYaiIWKAIAaiITQRp2IAlBHGoiFygCAGoiFEEadiAJQSBqIhgoAgBqIQJB/P3//wAgAygCBGshGUH8////ACADKAIIayEaQfz///8AIAMoAgxrIRtB/P///wAgAygCEGshHEH8////ACADKAIUayEdQfz///8AIAMoAhhrIR5B/P///wAgAygCHGshH0H8////ACADKAIgayEgIAMoAiQhISABQbzh//8AIAMoAgBrIABB////H3FqNgIAIAEgGSAMQf///x9xajYCBCABIBogCkH///8fcWo2AgggASAbIAtB////H3FqNgIMIAEgHCAOQf///x9xajYCECABIB0gEkH///8fcWo2AhQgASAeIBNB////H3FqNgIYIAEgHyAUQf///x9xajYCHCABICAgAkH///8fcWo2AiAgASAFQf///wFxQfz//wdqICFrIAJBGnZqNgIkIAEQGAR/QQEFIAdBJGoiBSgCAAR/QQAFIAdBIGoiDCgCAAR/QQAFIAdBHGoiCigCAAR/QQAFIAdBGGoiCygCAAR/QQAFIAdBFGoiDigCAAR/QQAFIAdBEGoiEigCACICQaOilQpLBH9BAAUgB0EMaiITKAIAIQACQCACQaOilQpGBEBBACAAQd2FlQNLDQwaIABB3YWVA0cNAUEAIAcoAggiAEGCiPEPSw0MGiAAQYKI8Q9HBEBB3YWVAyEADAILQQAgBygCBCIAQYu5oRtLDQwaIABBi7mhG0cEQEHdhZUDIQAMAgtBACAHKAIAQe31ph5LDQwaQd2FlQMhAAsLIAcgBygCAEHBgtkBajYCACAHQQRqIhQgFCgCAEG0xt4EajYCACAHQQhqIhQgFCgCAEH9944QajYCACATIABBovrqHGo2AgAgEiACQdzd6hVqNgIAIA5B////HzYCACALQf///x82AgAgCkH///8fNgIAIAxB////HzYCACAFQf///wE2AgAgAyAEEAogAyADIAcQDCAIKAIAIgRBFnYiAkHRB2wgCSgCAGohACACQQZ0IA8oAgBqIABBGnZqIgdBGnYgDSgCAGoiCUEadiARKAIAaiIIQRp2IBAoAgBqIgVBGnYgFSgCAGoiD0EadiAWKAIAaiIMQRp2IBcoAgBqIg1BGnYgGCgCAGohAkH8/f//ACADKAIEayEKQfz///8AIAMoAghrIRFB/P///wAgAygCDGshC0H8////ACADKAIQayEQQfz///8AIAMoAhRrIQ5B/P///wAgAygCGGshFUH8////ACADKAIcayESQfz///8AIAMoAiBrIRYgAygCJCETIAFBvOH//wAgAygCAGsgAEH///8fcWo2AgAgASAKIAdB////H3FqNgIEIAEgESAJQf///x9xajYCCCABIAsgCEH///8fcWo2AgwgASAQIAVB////H3FqNgIQIAEgDiAPQf///x9xajYCFCABIBUgDEH///8fcWo2AhggASASIA1B////H3FqNgIcIAEgFiACQf///x9xajYCICABIARB////AXFB/P//B2ogE2sgAkEadmo2AiQgARAYQQBHCwsLCwsLCwsFQQALBUEACwshACAGJAQgAAuXBQIJfwd+IwQhBCMEQSBqJAQgAkUEQEGoECAAKAKsASAAKAKoAUEDcUEMahEAACAEJARBAA8LIAQiACACKQAANwAAIAAgAikACDcACCAAIAIpABA3ABAgACACKQAYNwAYIAIoADgiCEF/RyACKAA8IgRBH3YiBUF/cyIDcSAEQf////8HSXIgAyACKAA0IglBf0dxciADIAIoADAiCkF/R3FyIAMgAigALCIDQfPc3eoFSXFyIgZBAXMgA0Hz3N3qBUtxIAVyIgdBAXMgAigAKCIFQZ2gkb0FSXEgBnIiC0EBcyAFQZ2gkb0FS3EgB3IiB0EBcyACKAAkIgZBxt6k/31JcSALckF/cyILIAZBxt6k/31LcSAHciALIAIoACAiAkGgwezABktxciEHIAFFBEAgACQEIAcPCyAHBEAgCEF/c61C/////w98IAlBf3OtQv////8PfCAKQX9zrUL+////D3wgA0F/c61C5rm71Qt8IAVBf3OtQrvAovoKfCAGQX9zrUKMvcn+C3wgAkF/c61CwoLZgQ18IgxCIIh8Ig5CIIh8Ig9CIIh8IhBCIIh8IhFCIIh8IhJCIIh8IQ0gDCAGIAJyIAVyIANyIApyIAlyIAhyIARyQQBHQR90QR91rSIMg6chAiAP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CCEPIAYoAgwhECAGKAIQIREgBigCFCESIAYoAhghEyAGKAIcIRRB/P///wAgBigCIGshFSAGKAIkIRYgBUG84f//ACAGKAIAayACQf///x9xajYCACAFQfz9//8AIA5rIAdB////H3FqNgIEIAVB/P///wAgD2sgCEH///8fcWo2AgggBUH8////ACAQayAJQf///x9xajYCDCAFQfz///8AIBFrIApB////H3FqNgIQIAVB/P///wAgEmsgC0H///8fcWo2AhQgBUH8////ACATayAMQf///x9xajYCGCAFQfz///8AIBRrIA1B////H3FqNgIcIAUgFSAAQf///x9xajYCICAFIANB////AXFB/P//B2ogFmsgAEEadmo2AiQgBRAYBUEACwVBAAsLIQAMAQsgBCQEQQAPCyAARQRAIAQkBEEADwsgBSAEKQIANwIAIAUgBCkCCDcCCCAFIAQpAhA3AhAgBSAEKQIYNwIYIAUgBCkCIDcCICAFEA8gBiAEQShqIgApAgA3AgAgBiAAKQIINwIIIAYgACkCEDcCECAGIAApAhg3AhggBiAAKQIgNwIgIAYQDyAFKAIIIQAgBSgCDCECIAUoAhRBAnQgBSgCECIKQRh2ciAFKAIYIgtBHHRyIQwgBSgCHCEDIAUoAiRBCnQgBSgCICINQRB2ciEOIAYoAgQiD0EadCAGKAIAciEQIAYoAgghByAGKAIMIQggBigCFEECdCAGKAIQIhFBGHZyIAYoAhgiEkEcdHIhEyAGKAIcIQkgBigCJEEKdCAGKAIgIgZBEHZyIRQgASAFKAIEIhVBGnQgBSgCAHI2AAAgASAAQRR0IBVBBnZyNgAEIAEgAkEOdCAAQQx2cjYACCABIApBCHQgAkESdnI2AAwgASAMNgAQIAEgA0EWdCALQQR2cjYAFCABIA1BEHQgA0EKdnI2ABggASAONgAcIAEgEDYAICABIAdBFHQgD0EGdnI2ACQgASAIQQ50IAdBDHZyNgAoIAEgEUEIdCAIQRJ2cjYALCABIBM2ADAgASAJQRZ0IBJBBHZyNgA0IAEgBkEQdCAJQQp2cjYAOCABIBQ2ADwgBEIANwIAIARCADcCCCAEQgA3AhAgBEIANwIYIARCADcCICAEQgA3AiggBEIANwIwIARCADcCOCAEQUBrQgA3AgAgBEIANwJIIARB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TABzY2FsYXIgIT0gTlVMTAByZWNpZCA+PSAwICYmIHJlY2lkIDw9IDMAcmVjaWQgIT0gTlVMTABrZXlwYWlyICE9IE5VTEwAc2lnNjQgIT0gTlVMTABtc2czMiAhPSBOVUxMAEJJUDAzNDAvbm9uY2UAAABGb3IgdGhpcyBzYW1wbGUsIHRoaXMgNjMtYnl0ZSBzdHJpbmcgd2lsbCBiZSB1c2VkIGFzIGlucHV0IGRhdGEAgABB6RMLqRFUaGUgc2NhbGFyIGZvciB0aGlzIHggaXMgdW5rbm93bgD/VTNJx107EQ/lw1nX7cshH3VTaed9WzEvBeN59w3rQT+Vc4kHnXtRTyUDmRctC2FftZOpJ72bcW9FI7k3TSuBf9WzyUfdu5GPZUPZV21LoZ/10+ln/duxr4Vj+XeNa8G/FfMJhx370c+lgxmXrYvh3zUTKac9G/HvxaM5t82rAU91dCBvZiBtZW1vcnkAW2xpYnNlY3AyNTZrMV0gaWxsZWdhbCBhcmd1bWVudDogJXMKAFtsaWJzZWNwMjU2azFdIGludGVybmFsIGNvbnNpc3RlbmN5IGNoZWNrIGZhaWxlZDogJXMKACFzZWNwMjU2azFfZmVfaXNfemVybygmZ2UtPngpAAFyZXQAVCEiGQ0BAgMRSxwMEAQLHRIeJ2hub3BxYiAFBg8TFBUaCBYHKCQXGAkKDhsfJSODgn0mKis8PT4/Q0dKTVhZWltcXV5fYGFjZGVmZ2lqa2xyc3R5ent8AElsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAAARAAoAERERAAAAAAUAAAAAAAAJAAAAAAsAQZolCyERAA8KERERAwoHAAETCQsLAAAJBgsAAAsABhEAAAAREREAQcslCwELAEHUJQsYEQAKChEREQAKAAACAAkLAAAACQALAAALAEGFJgsBDABBkSYLFQwAAAAADAAAAAAJDAAAAAAADAAADABBvyYLAQ4AQcsmCxUNAAAABA0AAAAACQ4AAAAAAA4AAA4AQfkmCwEQAEGFJwseDwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhISAEG8JwsOEgAAABISEgAAAAAAAAkAQe0nCwELAEH5JwsVCgAAAAAKAAAAAAkLAAAAAAALAAALAEGnKAsBDABBsygLXAwAAAAADAAAAAAJDAAAAAAADAAADAAALSsgICAwWDB4AChudWxsKQAtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBuYW4ATkFOADAxMjM0NTY3ODlBQkNERUYu";
const wrapSecp256k1Wasm$1 = (instance2, heapU8, heapU32) => ({
  contextCreate: (context) => instance2.exports._secp256k1_context_create(context),
  contextRandomize: (contextPtr, seedPtr) => instance2.exports._secp256k1_context_randomize(contextPtr, seedPtr),
  ecdh: (contextPtr, outputSharedSecretPtr, publicKeyPtr, secretKeyPtr) => instance2.exports._secp256k1_ecdh(contextPtr, outputSharedSecretPtr, publicKeyPtr, secretKeyPtr),
  free: (pointer) => instance2.exports._free(pointer),
  heapU32,
  heapU8,
  instance: instance2,
  malloc: (bytes) => instance2.exports._malloc(bytes),
  mallocSizeT: (num) => {
    const pointer = instance2.exports._malloc(4);
    const pointerView32 = pointer >> 2;
    heapU32.set([num], pointerView32);
    return pointer;
  },
  mallocUint8Array: (array) => {
    const pointer = instance2.exports._malloc(array.length);
    heapU8.set(array, pointer);
    return pointer;
  },
  privkeyTweakAdd: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance2.exports._secp256k1_ec_privkey_tweak_add(contextPtr, secretKeyPtr, tweakNum256Ptr),
  privkeyTweakMul: (contextPtr, secretKeyPtr, tweakNum256Ptr) => instance2.exports._secp256k1_ec_privkey_tweak_mul(contextPtr, secretKeyPtr, tweakNum256Ptr),
  pubkeyCreate: (contextPtr, publicKeyPtr, secretKeyPtr) => instance2.exports._secp256k1_ec_pubkey_create(contextPtr, publicKeyPtr, secretKeyPtr),
  pubkeyParse: (contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength) => instance2.exports._secp256k1_ec_pubkey_parse(contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength),
  pubkeySerialize: (contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression) => instance2.exports._secp256k1_ec_pubkey_serialize(contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression),
  pubkeyTweakAdd: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance2.exports._secp256k1_ec_pubkey_tweak_add(contextPtr, publicKeyPtr, tweakNum256Ptr),
  pubkeyTweakMul: (contextPtr, publicKeyPtr, tweakNum256Ptr) => instance2.exports._secp256k1_ec_pubkey_tweak_mul(contextPtr, publicKeyPtr, tweakNum256Ptr),
  readHeapU8: (pointer, bytes) => new Uint8Array(heapU8.buffer, pointer, bytes),
  readSizeT: (pointer) => {
    const pointerView32 = pointer >> 2;
    return heapU32[pointerView32];
  },
  recover: (contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr) => instance2.exports._secp256k1_ecdsa_recover(contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr),
  recoverableSignatureParse: (contextPtr, outputRSigPtr, inputSigPtr, rid) => instance2.exports._secp256k1_ecdsa_recoverable_signature_parse_compact(contextPtr, outputRSigPtr, inputSigPtr, rid),
  recoverableSignatureSerialize: (contextPtr, sigOutPtr, recIDOutPtr, rSigPtr) => instance2.exports._secp256k1_ecdsa_recoverable_signature_serialize_compact(contextPtr, sigOutPtr, recIDOutPtr, rSigPtr),
  schnorrSign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) => instance2.exports._secp256k1_schnorrsig_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr),
  schnorrVerify: (contextPtr, sigPtr, msg32Ptr, publicKeyPtr) => instance2.exports._secp256k1_schnorrsig_verify(contextPtr, sigPtr, msg32Ptr, publicKeyPtr),
  seckeyVerify: (contextPtr, secretKeyPtr) => instance2.exports._secp256k1_ec_seckey_verify(contextPtr, secretKeyPtr),
  sign: (contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr, extraEntropyPtr) => instance2.exports._secp256k1_ecdsa_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr, 0, extraEntropyPtr),
  signRecoverable: (contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr) => instance2.exports._secp256k1_ecdsa_sign_recoverable(contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr),
  signatureNormalize: (contextPtr, outputSigPtr, inputSigPtr) => instance2.exports._secp256k1_ecdsa_signature_normalize(contextPtr, outputSigPtr, inputSigPtr),
  signatureParseCompact: (contextPtr, sigOutPtr, compactSigInPtr) => instance2.exports._secp256k1_ecdsa_signature_parse_compact(contextPtr, sigOutPtr, compactSigInPtr),
  signatureParseDER: (contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength) => instance2.exports._secp256k1_ecdsa_signature_parse_der(contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength),
  signatureSerializeCompact: (contextPtr, outputCompactSigPtr, inputSigPtr) => instance2.exports._secp256k1_ecdsa_signature_serialize_compact(contextPtr, outputCompactSigPtr, inputSigPtr),
  signatureSerializeDER: (contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr) => instance2.exports._secp256k1_ecdsa_signature_serialize_der(contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr),
  verify: (contextPtr, sigPtr, msg32Ptr, pubkeyPtr) => instance2.exports._secp256k1_ecdsa_verify(contextPtr, sigPtr, msg32Ptr, pubkeyPtr)
});
const isLittleEndian = (buffer) => {
  const littleEndian = true;
  const notLittleEndian = false;
  const heap16 = new Int16Array(buffer);
  const heap32 = new Int32Array(buffer);
  const heapU8 = new Uint8Array(buffer);
  heap32[0] = 1668509029;
  heap16[1] = 25459;
  return heapU8[2] !== 115 || heapU8[3] !== 99 ? notLittleEndian : littleEndian;
};
const alignMemory = (factor, size) => Math.ceil(size / factor) * factor;
const instantiateSecp256k1WasmBytes = async (webassemblyBytes) => {
  const STACK_ALIGN = 16;
  const GLOBAL_BASE = 1024;
  const WASM_PAGE_SIZE = 65536;
  const TOTAL_STACK = 5242880;
  const TOTAL_MEMORY = 16777216;
  const wasmMemory = new WebAssembly.Memory({
    initial: TOTAL_MEMORY / WASM_PAGE_SIZE,
    maximum: TOTAL_MEMORY / WASM_PAGE_SIZE
  });
  if (!isLittleEndian(wasmMemory.buffer)) {
    throw new Error("Runtime error: expected the system to be little-endian.");
  }
  const STATIC_BASE = GLOBAL_BASE;
  const STATICTOP_INITIAL = STATIC_BASE + 67696 + 16;
  const DYNAMICTOP_PTR = STATICTOP_INITIAL;
  const DYNAMICTOP_PTR_SIZE = 4;
  const STATICTOP = STATICTOP_INITIAL + DYNAMICTOP_PTR_SIZE + 15 & -16;
  const STACKTOP = alignMemory(STACK_ALIGN, STATICTOP);
  const STACK_BASE = STACKTOP;
  const STACK_MAX = STACK_BASE + TOTAL_STACK;
  const DYNAMIC_BASE = alignMemory(STACK_ALIGN, STACK_MAX);
  const heapU8 = new Uint8Array(wasmMemory.buffer);
  const heap32 = new Int32Array(wasmMemory.buffer);
  const heapU32 = new Uint32Array(wasmMemory.buffer);
  heap32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  const TABLE_SIZE = 16;
  const MAX_TABLE_SIZE = 16;
  let getErrNoLocation;
  const env = {
    DYNAMICTOP_PTR,
    STACKTOP,
    ___setErrNo: (value) => {
      if (getErrNoLocation !== void 0) {
        heap32[getErrNoLocation() >> 2] = value;
      }
      return value;
    },
    ___syscall140: () => {
      throw new Error("___syscall140");
    },
    ___syscall146: () => {
      throw new Error("___syscall146");
    },
    ___syscall6: () => {
      throw new Error("___syscall6");
    },
    _abort: (err = "Secp256k1 Error") => {
      throw new Error(err);
    },
    _emscripten_memcpy_big: (dest, src, num) => {
      heapU8.set(heapU8.subarray(src, src + num), dest);
      return dest;
    },
    abort: (err = "Secp256k1 Error") => {
      throw new Error(err);
    },
    abortOnCannotGrowMemory: () => {
      throw new Error("Secp256k1 Error: abortOnCannotGrowMemory was called.");
    },
    enlargeMemory: () => {
      throw new Error("Secp256k1 Error: enlargeMemory was called.");
    },
    getTotalMemory: () => TOTAL_MEMORY
  };
  const info = {
    env: {
      ...env,
      memory: wasmMemory,
      memoryBase: STATIC_BASE,
      table: new WebAssembly.Table({
        element: "anyfunc",
        initial: TABLE_SIZE,
        maximum: MAX_TABLE_SIZE
      }),
      tableBase: 0
    },
    global: { Infinity: Infinity, NaN: NaN }
  };
  return WebAssembly.instantiate(webassemblyBytes, info).then((result) => {
    getErrNoLocation = result.instance.exports.___errno_location;
    return wrapSecp256k1Wasm$1(result.instance, heapU8, heapU32);
  });
};
const getEmbeddedSecp256k1Binary = () => base64ToBin(secp256k1Base64Bytes).buffer;
const instantiateSecp256k1Wasm = async () => instantiateSecp256k1WasmBytes(getEmbeddedSecp256k1Binary());
const sha256Base64Bytes = "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IAJHDQUgAygCGCABIAIQKxoMAwsgAiEEDAELIANBMGogASACIAQQFiADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQQxqIgYgACgCCBAXIAIgAygCJEcNBCADKAIgIAUgAhArGiAAQQhqQQA2AgAgA0EsaiAGEBgLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAWIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAZIANBLGogAygCCBAYDAALAAsgA0EQaiAAQQxqIAQQGiADKAIUIARHDQEgAygCECABIAQQKxoLIABBCGogBDYCACADQUBrJAAPC0GEFBAHAAtBhBQQBwALQYQUEAcAC98EAgN/AX4jAEHQAGsiAiQAIAIgAUHMAGo2AiQgASkDACEFIAEoAgghBCACIAJBJGo2AigCQCAEQT9NBEAgAUEMaiIDIARqQYABOgAAIAEgASgCCEEBaiIENgIIIAJBGGogAyAEEBcgAigCGEEAIAIoAhwQLRpBwAAgASgCCGtBB00EQCACQShqIAMQGCACQRBqIAMgAUEIaigCABAaIAIoAhBBACACKAIUEC0aCyACQQhqIANBOBAXIAIoAgxBCEcNASACKAIIIAVCOIYgBUIohkKAgICAgIDA/wCDhCAFQhiGQoCAgICA4D+DIAVCCIZCgICAgPAfg4SEIAVCCIhCgICA+A+DIAVCGIhCgID8B4OEIAVCKIhCgP4DgyAFQjiIhISENwAAIAJBKGogAxAYIAFBCGpBADYCACACQQA2AiggAkEoakEEciEEQQAhAwJAA0AgA0EgRg0BIAQgA2pBADoAACACIAIoAihBAWo2AiggA0EBaiEDDAALAAsgAkFAayABQeQAaikAADcDACACQThqIAFB3ABqKQAANwMAIAJBMGogAUHUAGopAAA3AwAgAiABKQBMNwMoQQAhAwJAA0AgA0EgRg0BIAJBKGogA2oiBCAEKAIAIgRBGHQgBEEIdEGAgPwHcXIgBEEIdkGA/gNxIARBGHZycjYCACADQQRqIQMMAAsACyAAIAIpAyg3AAAgAEEYaiACQUBrKQMANwAAIABBEGogAkE4aikDADcAACAAQQhqIAJBMGopAwA3AAAgAkHQAGokAA8LQdwTIARBwAAQ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KAJsIQggASAPNgJkIAEgDjYCYCABIBM2AmggASAYNgJsIAEgAjYCdCABIBc2AnAgASAQNgJ4IAEgDDYCfCABQdAAaiABQeAAaiABQfAAaiAHQevZwaJ6aiAIQfr/+4V5ahAeIAEoAlwhByABKAJYIQggASgCUCEKIAEoAlQhESABIAI2AmQgASAXNgJgIAEgEDYCaCABIAw2AmwgASARNgJ0IAEgCjYCcCABIAg2AnggASAHNgJ8IAFB0ABqIAFB4ABqIAFB8ABqIA1B8vHFs3xqIBlB98fm93tqEB4gASgCXCENIAEoAlghGCABKAJQIRMgACAeIAEoAlRqNgIEIAAgEyAdajYCACAAIAogIWo2AgggACARICJqNgIMIAAgGCAcajYCECAAIA0gG2o2AhQgACAIICBqNgIYIAAgByAfajYCHCABQYABaiQAC30BAX8jAEEwayICJAAgAiABNgIEIAIgADYCACACQSxqQQE2AgAgAkEUakECNgIAIAJBHGpBAjYCACACQQE2AiQgAkGMFTYCCCACQQI2AgwgAkHMDTYCECACIAI2AiAgAiACQQRqNgIoIAIgAkEgajYCGCACQQhqQZwVECgAC3wBAX8jAEEwayIDJAAgAyACNgIEIAMgATYCACADQSxqQQE2AgAgA0EUakECNgIAIANBHGpBAjYCACADQQE2AiQgA0HcFDYCCCADQQI2AgwgA0HMDTYCECADIANBBGo2AiAgAyADNgIoIAMgA0EgajYCGCADQQhqIAAQKAAL1gEBBn8gACABKAIAIgggAigCBCIHcyACKAIAIgVxIAggB3FzIAVBHncgBUETd3MgBUEKd3NqIAIoAggiBkEadyAGQRV3cyAGQQd3cyAEaiABKAIMaiABKAIIIgQgAigCDCIJcyAGcSAEc2oiCmoiAjYCBCAAIAogASgCBGoiATYCDCAAIAJBHncgAkETd3MgAkEKd3MgAiAHIAVzcSAHIAVxc2ogBCADaiAJIAEgCSAGc3FzaiABQRp3IAFBFXdzIAFBB3dzaiIFajYCACAAIAUgCGo2AggLeAAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgAiAmo2AgAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgQiAmo2AgQgACACQRl3IAJBA3ZzIAJBDndzIAEoAggiAmo2AgggACACQRl3IAJBA3ZzIAJBDndzIAEoAgxqNgIMC3YAIAAgAkENdyACQQp2cyACQQ93cyABKAIIaiICNgIIIAAgA0ENdyADQQp2cyADQQ93cyABKAIMaiIDNgIMIAAgAkENdyACQQp2cyACQQ93cyABKAIAajYCACAAIANBDXcgA0EKdnMgA0EPd3MgASgCBGo2AgQLUAACQAJAQegPKAIAQQFGBEBB7A9B7A8oAgBBAWoiADYCACAAQQNJDQEMAgtB6A9CgYCAgBA3AwALQfQPKAIAIgBBf0wNAEH0DyAANgIACwALPwECfyMAQRBrIgEkAAJ/IAAoAggiAiACDQAaQbQUEAcACxogASAAKQIMNwMAIAEgAEEUaikCADcDCCABECEAC7MCAQV/IAAoAhghAwJAAkACQCAAKAIMIgIgAEcEQCAAKAIIIgEgAjYCDCACIAE2AgggAw0BDAILIABBFGoiASAAQRBqIAEoAgAbIgQoAgAiAQRAAkADQCAEIQUgASICQRRqIgQoAgAiAQRAIAENAQwCCyACQRBqIQQgAigCECIBDQALCyAFQQA2AgAgAw0BDAILQQAhAiADRQ0BCwJAIAAoAhwiBEECdEGMEmoiASgCACAARwRAIANBEGogA0EUaiADKAIQIABGGyACNgIAIAINAQwCCyABIAI2AgAgAkUNAgsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIABBFGooAgAiAUUNACACQRRqIAE2AgAgASACNgIYCw8LQYAQQYAQKAIAQX4gBHdxNgIAC8UCAQR/IAACf0EAIAFBCHYiA0UNABpBHyICIAFB////B0sNABogAUEmIANnIgJrQR9xdkEBcUEfIAJrQQF0cgsiAjYCHCAAQgA3AhAgAkECdEGMEmohAwJAAkACQEGAECgCACIEQQEgAkEfcXQiBXEEQCADKAIAIgQoAgRBeHEgAUcNASAEIQIMAgsgAyAANgIAQYAQIAQgBXI2AgAgACADNgIYIAAgADYCCCAAIAA2AgwPCyABQQBBGSACQQF2a0EfcSACQR9GG3QhAwNAIAQgA0EddkEEcWpBEGoiBSgCACICRQ0CIANBAXQhAyACIQQgAigCBEF4cSABRw0ACwsgAigCCCIDIAA2AgwgAiAANgIIIAAgAjYCDCAAIAM2AgggAEEANgIYDwsgBSAANgIAIAAgBDYCGCAAIAA2AgwgACAANgIIC/UEAQR/IAAgAWohAgJAAkACQAJAAkACQAJAAkAgACgCBCIDQQFxDQAgA0EDcUUNASAAKAIAIgMgAWohAQJAAkBBlBMoAgAgACADayIARwRAIANB/wFLDQEgACgCDCIEIAAoAggiBUYNAiAFIAQ2AgwgBCAFNgIIDAMLIAIoAgQiA0EDcUEDRw0CQYwTIAE2AgAgAkEEaiADQX5xNgIAIAAgAUEBcjYCBCACIAE2AgAPCyAAECMMAQtB/A9B/A8oAgBBfiADQQN2d3E2AgALAkAgAigCBCIDQQJxRQRAQZgTKAIAIAJGDQFBlBMoAgAgAkYNAyADQXhxIgQgAWohASAEQf8BSw0EIAIoAgwiBCACKAIIIgJGDQYgAiAENgIMIAQgAjYCCAwHCyACQQRqIANBfnE2AgAgACABQQFyNgIEIAAgAWogATYCAAwHC0GYEyAANgIAQZATQZATKAIAIAFqIgE2AgAgACABQQFyNgIEIABBlBMoAgBGDQMLDwtBlBMgADYCAEGME0GMEygCACABaiIBNgIAIAAgAUEBcjYCBCAAIAFqIAE2AgAPCyACECMMAgtBjBNBADYCAEGUE0EANgIADwtB/A9B/A8oAgBBfiADQQN2d3E2AgALIAAgAUEBcjYCBCAAIAFqIAE2AgAgAEGUEygCAEcNAEGMEyABNgIADwsCfwJAIAFB/wFNBEAgAUEDdiICQQN0QYQQaiEBQfwPKAIAIgNBASACQR9xdCICcUUNASABKAIIDAILIAAgARAkDwtB/A8gAyACcjYCACABCyECIAFBCGogADYCACACIAA2AgwgACABNgIMIAAgAjYCCAvSAgEFfyMAQRBrIgMkAAJ/IAAoAgAoAgAiAkGAgMQARwRAIAFBHGooAgAhBCABKAIYIQUgA0EANgIMAn8gAkH/AE0EQCADIAI6AAxBAQwBCyACQf8PTQRAIAMgAkE/cUGAAXI6AA0gAyACQQZ2QR9xQcABcjoADEECDAELIAJB//8DTQRAIAMgAkE/cUGAAXI6AA4gAyACQQZ2QT9xQYABcjoADSADIAJBDHZBD3FB4AFyOgAMQQMMAQsgAyACQRJ2QfABcjoADCADIAJBP3FBgAFyOgAPIAMgAkEMdkE/cUGAAXI6AA0gAyACQQZ2QT9xQYABcjoADkEECyEGQQEiAiAFIANBDGogBiAEKAIMEQUADQEaCyAAKAIELQAABEAgASgCGCAAKAIIIgAoAgAgACgCBCABQRxqKAIAKAIMEQUADAELQQALIQIgA0EQaiQAIAILqggBCX8jAEHQAGsiAiQAQSchAwJAIAAoAgAiAEGQzgBPBEADQCACQQlqIANqIgVBfGogACAAQZDOAG4iBEHwsX9saiIHQeQAbiIGQQF0QboLai8AADsAACAFQX5qIAcgBkGcf2xqQQF0QboLai8AADsAACADQXxqIQMgAEH/wdcvSyEFIAQhACAFDQALDAELIAAhBAsCQCAEQeQATgRAIAJBCWogA0F+aiIDaiAEIARB5ABuIgBBnH9sakEBdEG6C2ovAAA7AAAMAQsgBCEACwJAIABBCUwEQCACQQlqIANBf2oiA2oiCCAAQTBqOgAADAELIAJBCWogA0F+aiIDaiIIIABBAXRBugtqLwAAOwAACyACQQA2AjQgAkGEDTYCMCACQYCAxAA2AjhBJyADayIGIQMgASgCACIAQQFxBEAgAkErNgI4IAZBAWohAwsgAiAAQQJ2QQFxOgA/IAEoAgghBCACIAJBP2o2AkQgAiACQThqNgJAIAIgAkEwajYCSAJ/AkACQAJ/AkACQAJAAkACQAJAAkAgBEEBRgRAIAFBDGooAgAiBCADTQ0BIABBCHENAiAEIANrIQVBASABLQAwIgAgAEEDRhtBA3EiAEUNAyAAQQJGDQQMBQsgAkFAayABECYNCCABKAIYIAggBiABQRxqKAIAKAIMEQUADAoLIAJBQGsgARAmDQcgASgCGCAIIAYgAUEcaigCACgCDBEFAAwJCyABQQE6ADAgAUEwNgIEIAJBQGsgARAmDQYgAkEwNgJMIAQgA2shAyABKAIYIQRBfyEAIAFBHGooAgAiB0EMaiEFA0AgAEEBaiIAIANPDQQgBCACQcwAakEBIAUoAgARBQBFDQALDAYLIAUhCUEAIQUMAQsgBUEBakEBdiEJIAVBAXYhBQsgAkEANgJMIAEoAgQiAEH/AE0EQCACIAA6AExBAQwDCyAAQf8PSw0BIAIgAEE/cUGAAXI6AE0gAiAAQQZ2QR9xQcABcjoATEECDAILIAQgCCAGIAdBDGooAgARBQANAgwDCyAAQf//A00EQCACIABBP3FBgAFyOgBOIAIgAEEGdkE/cUGAAXI6AE0gAiAAQQx2QQ9xQeABcjoATEEDDAELIAIgAEESdkHwAXI6AEwgAiAAQT9xQYABcjoATyACIABBDHZBP3FBgAFyOgBNIAIgAEEGdkE/cUGAAXI6AE5BBAshBCABKAIYIQNBfyEAIAFBHGooAgAiCkEMaiEHAkADQCAAQQFqIgAgBU8NASADIAJBzABqIAQgBygCABEFAEUNAAsMAQsgAkFAayABECYNACADIAggBiAKQQxqKAIAIgURBQANAEF/IQADQCAAQQFqIgAgCU8NAiADIAJBzABqIAQgBREFAEUNAAsLQQEMAQtBAAshACACQdAAaiQAIAALRgIBfwF+IwBBIGsiAiQAIAEpAgAhAyACQRRqIAEpAgg3AgAgAkHMFDYCBCACQYQNNgIAIAIgADYCCCACIAM3AgwgAhAiAAsDAAELDQBCiLKUk5iBlYz/AAszAQF/IAIEQCAAIQMDQCADIAEtAAA6AAAgAUEBaiEBIANBAWohAyACQX9qIgINAAsLIAALZwEBfwJAIAEgAEkEQCACRQ0BA0AgACACakF/aiABIAJqQX9qLQAAOgAAIAJBf2oiAg0ACwwBCyACRQ0AIAAhAwNAIAMgAS0AADoAACABQQFqIQEgA0EBaiEDIAJBf2oiAg0ACwsgAAspAQF/IAIEQCAAIQMDQCADIAE6AAAgA0EBaiEDIAJBf2oiAg0ACwsgAAsLoQkDAEGACAu0AWludmFsaWQgbWFsbG9jIHJlcXVlc3RUcmllZCB0byBzaHJpbmsgdG8gYSBsYXJnZXIgY2FwYWNpdHlhc3NlcnRpb24gZmFpbGVkOiA4ID09IGRzdC5sZW4oKS9yb290Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2J5dGUtdG9vbHMtMC4yLjAvc3JjL3dyaXRlX3NpbmdsZS5ycwBBwAkL2gUvcm9vdC8uY2FyZ28vcmVnaXN0cnkvc3JjL2dpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyMy9ibG9jay1idWZmZXItMC4zLjMvc3JjL2xpYi5yc2Rlc3RpbmF0aW9uIGFuZCBzb3VyY2Ugc2xpY2VzIGhhdmUgZGlmZmVyZW50IGxlbmd0aHMAZ+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4FsAAAAAAGNhcGFjaXR5IG92ZXJmbG93Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxpYmNvcmUvb3B0aW9uLnJzMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIGxpYmNvcmUvc2xpY2UvbW9kLnJzAAEAAAAAAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAEAAAABAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCBzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGVsaWJhbGxvYy9yYXdfdmVjLnJzAEHEEwv9ARYEAAAkAAAAhwcAABMAAABIAgAACQAAAMAEAABTAAAASwAAABEAAAA6BAAAIAAAAFoEAABaAAAAHwAAAAUAAAATBQAANAAAALcGAAAUAAAAbQYAAAkAAABtBQAAEQAAAIcHAAATAAAA8gIAAAUAAAB+BQAAKwAAAKkFAAARAAAAWQEAABUAAAACAAAAAAAAAAEAAAADAAAAhQYAACAAAAClBgAAEgAAABQHAAAGAAAAGgcAACIAAAC3BgAAFAAAAK0HAAAFAAAAPAcAABYAAABSBwAADQAAALcGAAAUAAAAswcAAAUAAABfBwAAKAAAAIcHAAATAAAA9QEAAB4ADAdsaW5raW5nAwLEDQ==";
const instantiateRipemd160Bytes = async (webassemblyBytes) => {
  const wasm2 = await instantiateRustWasm(webassemblyBytes, "./ripemd160", "ripemd160", "ripemd160_init", "ripemd160_update", "ripemd160_final");
  return {
    final: wasm2.final,
    hash: wasm2.hash,
    init: wasm2.init,
    update: wasm2.update
  };
};
const getEmbeddedRipemd160Binary = () => base64ToBin(ripemd160Base64Bytes).buffer;
const cachedRipemd160 = {};
const instantiateRipemd160 = async () => {
  if (cachedRipemd160.cache !== void 0) {
    return cachedRipemd160.cache;
  }
  const result = instantiateRipemd160Bytes(getEmbeddedRipemd160Binary());
  cachedRipemd160.cache = result;
  return result;
};
const wrapSecp256k1Wasm = (secp256k1Wasm, randomSeed) => {
  const contextPtr = secp256k1Wasm.contextCreate(ContextFlag.BOTH);
  const sigScratch = secp256k1Wasm.malloc(72);
  const publicKeyScratch = secp256k1Wasm.malloc(65);
  const messageHashScratch = secp256k1Wasm.malloc(32);
  const extraEntropyScratch = secp256k1Wasm.malloc(32);
  const internalPublicKeyPtr = secp256k1Wasm.malloc(64);
  const ecdhSharedSecretPtr = secp256k1Wasm.malloc(32);
  const internalSigPtr = secp256k1Wasm.malloc(64);
  const schnorrSigPtr = secp256k1Wasm.malloc(64);
  const privateKeyPtr = secp256k1Wasm.malloc(32);
  const internalRSigPtr = secp256k1Wasm.malloc(65);
  const recoveryNumPtr = secp256k1Wasm.malloc(4);
  const recoveryNumPtrView32 = recoveryNumPtr >> 2;
  const getRecoveryNumPtr = () => secp256k1Wasm.heapU32[recoveryNumPtrView32];
  const lengthPtr = secp256k1Wasm.malloc(4);
  const lengthPtrView32 = lengthPtr >> 2;
  const cloneAndPad = (value, expectedLength) => {
    const zeroPaddedValue = new Uint8Array(expectedLength);
    zeroPaddedValue.set(value);
    return zeroPaddedValue;
  };
  const parsePublicKey = (publicKey) => {
    const paddedPublicKey = cloneAndPad(publicKey, 65);
    secp256k1Wasm.heapU8.set(paddedPublicKey, publicKeyScratch);
    return secp256k1Wasm.pubkeyParse(
      contextPtr,
      internalPublicKeyPtr,
      publicKeyScratch,
      publicKey.length
    ) === 1;
  };
  const setLengthPtr = (value) => {
    secp256k1Wasm.heapU32.set([value], lengthPtrView32);
  };
  const getLengthPtr = () => secp256k1Wasm.heapU32[lengthPtrView32];
  const serializePublicKey = (length2, flag) => {
    setLengthPtr(length2);
    secp256k1Wasm.pubkeySerialize(contextPtr, publicKeyScratch, lengthPtr, internalPublicKeyPtr, flag);
    return secp256k1Wasm.readHeapU8(publicKeyScratch, getLengthPtr()).slice();
  };
  const getSerializedPublicKey = (compressed) => compressed ? serializePublicKey(33, CompressionFlag.COMPRESSED) : serializePublicKey(65, CompressionFlag.UNCOMPRESSED);
  const convertPublicKey = (compressed) => (publicKey) => {
    if (!parsePublicKey(publicKey)) {
      throw new Error("Failed to parse public key.");
    }
    return getSerializedPublicKey(compressed);
  };
  const parseSignature = (signature, isDer) => {
    const paddedSignature = cloneAndPad(signature, 72);
    secp256k1Wasm.heapU8.set(paddedSignature, sigScratch);
    return isDer ? secp256k1Wasm.signatureParseDER(contextPtr, internalSigPtr, sigScratch, signature.length) === 1 : secp256k1Wasm.signatureParseCompact(contextPtr, internalSigPtr, sigScratch) === 1;
  };
  const parseOrThrow = (signature, isDer) => {
    if (!parseSignature(signature, isDer)) {
      throw new Error("Failed to parse signature.");
    }
  };
  const getCompactSig = () => {
    secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
    return secp256k1Wasm.readHeapU8(sigScratch, 64).slice();
  };
  const getDERSig = () => {
    setLengthPtr(72);
    secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
    return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
  };
  const convertSignature = (wasDER) => (signature) => {
    parseOrThrow(signature, wasDER);
    return wasDER ? getCompactSig() : getDERSig();
  };
  const fillPrivateKeyPtr = (privateKey) => {
    const paddedPrivateKey = cloneAndPad(privateKey, 32);
    secp256k1Wasm.heapU8.set(paddedPrivateKey, privateKeyPtr);
  };
  const zeroOutPtr = (pointer, bytes) => {
    secp256k1Wasm.heapU8.fill(0, pointer, pointer + bytes);
  };
  const zeroOutPrivateKeyPtr = () => {
    zeroOutPtr(privateKeyPtr, 32);
  };
  const withPrivateKey = (privateKey, instructions) => {
    fillPrivateKeyPtr(privateKey);
    const ret = instructions();
    zeroOutPrivateKeyPtr();
    return ret;
  };
  const derivePublicKey = (compressed) => (privateKey) => {
    const invalid = withPrivateKey(privateKey, () => secp256k1Wasm.pubkeyCreate(contextPtr, internalPublicKeyPtr, privateKeyPtr) !== 1);
    if (invalid) {
      throw new Error("Cannot derive public key from invalid private key.");
    }
    return getSerializedPublicKey(compressed);
  };
  const fillMessageHashScratch = (messageHash) => {
    const paddedMessageHash = cloneAndPad(messageHash, 32);
    secp256k1Wasm.heapU8.set(paddedMessageHash, messageHashScratch);
  };
  const fillExtraEntropyScratch = (extraEntropy) => {
    const paddedExtraEntropy = cloneAndPad(extraEntropy, 32);
    secp256k1Wasm.heapU8.set(paddedExtraEntropy, extraEntropyScratch);
  };
  const normalizeSignature2 = () => {
    secp256k1Wasm.signatureNormalize(contextPtr, internalSigPtr, internalSigPtr);
  };
  const modifySignature = (isDer, normalize) => (signature) => {
    parseOrThrow(signature, isDer);
    if (normalize) {
      normalizeSignature2();
    }
    return isDer ? getDERSig() : getCompactSig();
  };
  const parseAndNormalizeSignature = (signature, isDer, normalize) => {
    const ret = parseSignature(signature, isDer);
    if (normalize) {
      normalizeSignature2();
    }
    return ret;
  };
  const signMessageHash = (isDer) => (privateKey, messageHash, extraEntropy) => {
    fillMessageHashScratch(messageHash);
    if (extraEntropy)
      fillExtraEntropyScratch(extraEntropy);
    return withPrivateKey(privateKey, () => {
      const failed = secp256k1Wasm.sign(contextPtr, internalSigPtr, messageHashScratch, privateKeyPtr, extraEntropy ? extraEntropyScratch : 0) !== 1;
      if (failed) {
        throw new Error("Failed to sign message hash. The private key is not valid.");
      }
      if (isDer) {
        setLengthPtr(72);
        secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
        return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
      }
      secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
      return secp256k1Wasm.readHeapU8(sigScratch, 64).slice();
    });
  };
  const signMessageHashSchnorr = () => (privateKey, messageHash) => {
    fillMessageHashScratch(messageHash);
    return withPrivateKey(privateKey, () => {
      const failed = secp256k1Wasm.schnorrSign(contextPtr, schnorrSigPtr, messageHashScratch, privateKeyPtr) !== 1;
      if (failed) {
        throw new Error("Failed to sign message hash. The private key is not valid.");
      }
      return secp256k1Wasm.readHeapU8(schnorrSigPtr, 64).slice();
    });
  };
  const ecdh = () => (privateKey, publicKey) => {
    if (!parsePublicKey(publicKey)) {
      throw new Error("ECDH Key Exchange failed. Failed to parse public key.");
    }
    return withPrivateKey(privateKey, () => {
      const failed = secp256k1Wasm.ecdh(contextPtr, ecdhSharedSecretPtr, internalPublicKeyPtr, privateKeyPtr) !== 1;
      if (failed) {
        throw new Error("ECDH Key Exchange failed. The private key is not valid.");
      }
      return secp256k1Wasm.readHeapU8(ecdhSharedSecretPtr, 32).slice();
    });
  };
  const verifyMessage = (messageHash) => {
    fillMessageHashScratch(messageHash);
    return secp256k1Wasm.verify(contextPtr, internalSigPtr, messageHashScratch, internalPublicKeyPtr) === 1;
  };
  const verifySignature = (isDer, normalize) => (signature, publicKey, messageHash) => parsePublicKey(publicKey) && parseAndNormalizeSignature(signature, isDer, normalize) && verifyMessage(messageHash);
  const verifyMessageSchnorr = (messageHash, signature) => {
    fillMessageHashScratch(messageHash);
    const paddedSignature = cloneAndPad(signature, 64);
    secp256k1Wasm.heapU8.set(paddedSignature, schnorrSigPtr);
    return secp256k1Wasm.schnorrVerify(contextPtr, schnorrSigPtr, messageHashScratch, internalPublicKeyPtr) === 1;
  };
  const verifySignatureSchnorr = () => (signature, publicKey, messageHash) => parsePublicKey(publicKey) ? verifyMessageSchnorr(messageHash, signature) : false;
  const signMessageHashRecoverable = (privateKey, messageHash) => {
    fillMessageHashScratch(messageHash);
    return withPrivateKey(privateKey, () => {
      if (secp256k1Wasm.signRecoverable(contextPtr, internalRSigPtr, messageHashScratch, privateKeyPtr) !== 1) {
        throw new Error("Failed to sign message hash. The private key is not valid.");
      }
      secp256k1Wasm.recoverableSignatureSerialize(contextPtr, sigScratch, recoveryNumPtr, internalRSigPtr);
      return {
        recoveryId: getRecoveryNumPtr(),
        signature: secp256k1Wasm.readHeapU8(sigScratch, 64).slice()
      };
    });
  };
  const recoverPublicKey = (compressed) => (signature, recoveryId, messageHash) => {
    fillMessageHashScratch(messageHash);
    const paddedSignature = cloneAndPad(signature, 72);
    secp256k1Wasm.heapU8.set(paddedSignature, sigScratch);
    if (secp256k1Wasm.recoverableSignatureParse(contextPtr, internalRSigPtr, sigScratch, recoveryId) !== 1) {
      throw new Error("Failed to recover public key. Could not parse signature.");
    }
    if (secp256k1Wasm.recover(contextPtr, internalPublicKeyPtr, internalRSigPtr, messageHashScratch) !== 1) {
      throw new Error("Failed to recover public key. The compact signature, recovery, or message hash is invalid.");
    }
    return getSerializedPublicKey(compressed);
  };
  const addTweakPrivateKey = (privateKey, tweakValue) => {
    fillMessageHashScratch(tweakValue);
    return withPrivateKey(privateKey, () => {
      if (secp256k1Wasm.privkeyTweakAdd(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
        throw new Error("Private key is invalid or adding failed.");
      }
      return secp256k1Wasm.readHeapU8(privateKeyPtr, 32).slice();
    });
  };
  const mulTweakPrivateKey = (privateKey, tweakValue) => {
    fillMessageHashScratch(tweakValue);
    return withPrivateKey(privateKey, () => {
      if (secp256k1Wasm.privkeyTweakMul(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
        throw new Error("Private key is invalid or multiplying failed.");
      }
      return secp256k1Wasm.readHeapU8(privateKeyPtr, 32).slice();
    });
  };
  const addTweakPublicKey = (compressed) => (publicKey, tweakValue) => {
    if (!parsePublicKey(publicKey)) {
      throw new Error("Failed to parse public key.");
    }
    fillMessageHashScratch(tweakValue);
    if (secp256k1Wasm.pubkeyTweakAdd(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
      throw new Error("Adding failed");
    }
    return getSerializedPublicKey(compressed);
  };
  const mulTweakPublicKey = (compressed) => (publicKey, tweakValue) => {
    if (!parsePublicKey(publicKey)) {
      throw new Error("Failed to parse public key.");
    }
    fillMessageHashScratch(tweakValue);
    if (secp256k1Wasm.pubkeyTweakMul(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
      throw new Error("Multiplying failed");
    }
    return getSerializedPublicKey(compressed);
  };
  if (randomSeed !== void 0) {
    const randomSeedPtr = messageHashScratch;
    const paddedRandomSeed = cloneAndPad(randomSeed, 32);
    secp256k1Wasm.heapU8.set(paddedRandomSeed, randomSeedPtr);
    secp256k1Wasm.contextRandomize(contextPtr, randomSeedPtr);
    zeroOutPtr(randomSeedPtr, 32);
  }
  return {
    addTweakPrivateKey,
    addTweakPublicKeyCompressed: addTweakPublicKey(true),
    addTweakPublicKeyUncompressed: addTweakPublicKey(false),
    compressPublicKey: convertPublicKey(true),
    derivePublicKeyCompressed: derivePublicKey(true),
    derivePublicKeyUncompressed: derivePublicKey(false),
    ecdh: ecdh(),
    malleateSignatureCompact: modifySignature(false, false),
    malleateSignatureDER: modifySignature(true, false),
    mulTweakPrivateKey,
    mulTweakPublicKeyCompressed: mulTweakPublicKey(true),
    mulTweakPublicKeyUncompressed: mulTweakPublicKey(false),
    normalizeSignatureCompact: modifySignature(false, true),
    normalizeSignatureDER: modifySignature(true, true),
    recoverPublicKeyCompressed: recoverPublicKey(true),
    recoverPublicKeyUncompressed: recoverPublicKey(false),
    signMessageHashCompact: signMessageHash(false),
    signMessageHashDER: signMessageHash(true),
    signMessageHashRecoverableCompact: signMessageHashRecoverable,
    signMessageHashSchnorr: signMessageHashSchnorr(),
    signatureCompactToDER: convertSignature(false),
    signatureDERToCompact: convertSignature(true),
    uncompressPublicKey: convertPublicKey(false),
    validatePrivateKey: (privateKey) => withPrivateKey(privateKey, () => secp256k1Wasm.seckeyVerify(contextPtr, privateKeyPtr) === 1),
    validatePublicKey: parsePublicKey,
    verifySignatureCompact: verifySignature(false, true),
    verifySignatureCompactLowS: verifySignature(false, false),
    verifySignatureDER: verifySignature(true, true),
    verifySignatureDERLowS: verifySignature(true, false),
    verifySignatureSchnorr: verifySignatureSchnorr()
  };
};
const cachedSecp256k1 = {};
const instantiateSecp256k1 = async (randomSeed) => {
  if (cachedSecp256k1.cache !== void 0) {
    return cachedSecp256k1.cache;
  }
  const result = Promise.resolve(wrapSecp256k1Wasm(await instantiateSecp256k1Wasm(), randomSeed));
  cachedSecp256k1.cache = result;
  return result;
};
const instantiateSha256Bytes = async (webassemblyBytes) => {
  const wasm2 = await instantiateRustWasm(webassemblyBytes, "./sha256", "sha256", "sha256_init", "sha256_update", "sha256_final");
  return {
    final: wasm2.final,
    hash: wasm2.hash,
    init: wasm2.init,
    update: wasm2.update
  };
};
const getEmbeddedSha256Binary = () => base64ToBin(sha256Base64Bytes).buffer;
const cachedSha256 = {};
const instantiateSha256 = async () => {
  if (cachedSha256.cache !== void 0) {
    return cachedSha256.cache;
  }
  const result = instantiateSha256Bytes(getEmbeddedSha256Binary());
  cachedSha256.cache = result;
  return result;
};
var sha256Uint8array = {};
Object.defineProperty(sha256Uint8array, "__esModule", { value: true });
sha256Uint8array.Hash = createHash_1 = sha256Uint8array.createHash = void 0;
const K = [
  1116352408 | 0,
  1899447441 | 0,
  3049323471 | 0,
  3921009573 | 0,
  961987163 | 0,
  1508970993 | 0,
  2453635748 | 0,
  2870763221 | 0,
  3624381080 | 0,
  310598401 | 0,
  607225278 | 0,
  1426881987 | 0,
  1925078388 | 0,
  2162078206 | 0,
  2614888103 | 0,
  3248222580 | 0,
  3835390401 | 0,
  4022224774 | 0,
  264347078 | 0,
  604807628 | 0,
  770255983 | 0,
  1249150122 | 0,
  1555081692 | 0,
  1996064986 | 0,
  2554220882 | 0,
  2821834349 | 0,
  2952996808 | 0,
  3210313671 | 0,
  3336571891 | 0,
  3584528711 | 0,
  113926993 | 0,
  338241895 | 0,
  666307205 | 0,
  773529912 | 0,
  1294757372 | 0,
  1396182291 | 0,
  1695183700 | 0,
  1986661051 | 0,
  2177026350 | 0,
  2456956037 | 0,
  2730485921 | 0,
  2820302411 | 0,
  3259730800 | 0,
  3345764771 | 0,
  3516065817 | 0,
  3600352804 | 0,
  4094571909 | 0,
  275423344 | 0,
  430227734 | 0,
  506948616 | 0,
  659060556 | 0,
  883997877 | 0,
  958139571 | 0,
  1322822218 | 0,
  1537002063 | 0,
  1747873779 | 0,
  1955562222 | 0,
  2024104815 | 0,
  2227730452 | 0,
  2361852424 | 0,
  2428436474 | 0,
  2756734187 | 0,
  3204031479 | 0,
  3329325298 | 0
];
const algorithms = {
  sha256: 1
};
function createHash(algorithm) {
  if (algorithm && !algorithms[algorithm] && !algorithms[algorithm.toLowerCase()]) {
    throw new Error("Digest method not supported");
  }
  return new Hash();
}
var createHash_1 = sha256Uint8array.createHash = createHash;
class Hash {
  constructor() {
    this.A = 1779033703 | 0;
    this.B = 3144134277 | 0;
    this.C = 1013904242 | 0;
    this.D = 2773480762 | 0;
    this.E = 1359893119 | 0;
    this.F = 2600822924 | 0;
    this.G = 528734635 | 0;
    this.H = 1541459225 | 0;
    this._size = 0;
    this._sp = 0;
    if (!sharedBuffer || sharedOffset >= 8e3) {
      sharedBuffer = new ArrayBuffer(8e3);
      sharedOffset = 0;
    }
    this._byte = new Uint8Array(sharedBuffer, sharedOffset, 80);
    this._word = new Int32Array(sharedBuffer, sharedOffset, 20);
    sharedOffset += 80;
  }
  update(data) {
    if ("string" === typeof data) {
      return this._utf8(data);
    }
    if (data == null) {
      throw new TypeError("Invalid type: " + typeof data);
    }
    const byteOffset = data.byteOffset;
    const length2 = data.byteLength;
    let blocks = length2 / 64 | 0;
    let offset = 0;
    if (blocks && !(byteOffset & 3) && !(this._size % 64)) {
      const block = new Int32Array(data.buffer, byteOffset, blocks * 16);
      while (blocks--) {
        this._int32(block, offset >> 2);
        offset += 64;
      }
      this._size += offset;
    }
    const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;
    if (BYTES_PER_ELEMENT !== 1 && data.buffer) {
      const rest = new Uint8Array(data.buffer, byteOffset + offset, length2 - offset);
      return this._uint8(rest);
    }
    if (offset === length2)
      return this;
    return this._uint8(data, offset);
  }
  _uint8(data, offset) {
    const { _byte, _word } = this;
    const length2 = data.length;
    offset = offset | 0;
    while (offset < length2) {
      const start = this._size % 64;
      let index = start;
      while (offset < length2 && index < 64) {
        _byte[index++] = data[offset++];
      }
      if (index >= 64) {
        this._int32(_word);
      }
      this._size += index - start;
    }
    return this;
  }
  _utf8(text2) {
    const { _byte, _word } = this;
    const length2 = text2.length;
    let surrogate = this._sp;
    for (let offset = 0; offset < length2; ) {
      const start = this._size % 64;
      let index = start;
      while (offset < length2 && index < 64) {
        let code = text2.charCodeAt(offset++) | 0;
        if (code < 128) {
          _byte[index++] = code;
        } else if (code < 2048) {
          _byte[index++] = 192 | code >>> 6;
          _byte[index++] = 128 | code & 63;
        } else if (code < 55296 || code > 57343) {
          _byte[index++] = 224 | code >>> 12;
          _byte[index++] = 128 | code >>> 6 & 63;
          _byte[index++] = 128 | code & 63;
        } else if (surrogate) {
          code = ((surrogate & 1023) << 10) + (code & 1023) + 65536;
          _byte[index++] = 240 | code >>> 18;
          _byte[index++] = 128 | code >>> 12 & 63;
          _byte[index++] = 128 | code >>> 6 & 63;
          _byte[index++] = 128 | code & 63;
          surrogate = 0;
        } else {
          surrogate = code;
        }
      }
      if (index >= 64) {
        this._int32(_word);
        _word[0] = _word[16];
      }
      this._size += index - start;
    }
    this._sp = surrogate;
    return this;
  }
  _int32(data, offset) {
    let { A, B, C, D, E, F, G, H } = this;
    let i = 0;
    offset = offset | 0;
    while (i < 16) {
      W[i++] = swap32(data[offset++]);
    }
    for (i = 16; i < 64; i++) {
      W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
    }
    for (i = 0; i < 64; i++) {
      const T1 = H + sigma1(E) + ch(E, F, G) + K[i] + W[i] | 0;
      const T2 = sigma0(A) + maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    this.A = A + this.A | 0;
    this.B = B + this.B | 0;
    this.C = C + this.C | 0;
    this.D = D + this.D | 0;
    this.E = E + this.E | 0;
    this.F = F + this.F | 0;
    this.G = G + this.G | 0;
    this.H = H + this.H | 0;
  }
  digest(encoding) {
    const { _byte, _word } = this;
    let i = this._size % 64 | 0;
    _byte[i++] = 128;
    while (i & 3) {
      _byte[i++] = 0;
    }
    i >>= 2;
    if (i > 14) {
      while (i < 16) {
        _word[i++] = 0;
      }
      i = 0;
      this._int32(_word);
    }
    while (i < 16) {
      _word[i++] = 0;
    }
    const bits64 = this._size * 8;
    const low32 = (bits64 & 4294967295) >>> 0;
    const high32 = (bits64 - low32) / 4294967296;
    if (high32)
      _word[14] = swap32(high32);
    if (low32)
      _word[15] = swap32(low32);
    this._int32(_word);
    return encoding === "hex" ? this._hex() : this._bin();
  }
  _hex() {
    const { A, B, C, D, E, F, G, H } = this;
    return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E) + hex32(F) + hex32(G) + hex32(H);
  }
  _bin() {
    const { A, B, C, D, E, F, G, H, _byte, _word } = this;
    _word[0] = swap32(A);
    _word[1] = swap32(B);
    _word[2] = swap32(C);
    _word[3] = swap32(D);
    _word[4] = swap32(E);
    _word[5] = swap32(F);
    _word[6] = swap32(G);
    _word[7] = swap32(H);
    return _byte.slice(0, 32);
  }
}
sha256Uint8array.Hash = Hash;
const W = new Int32Array(64);
let sharedBuffer;
let sharedOffset = 0;
const hex32 = (num) => (num + 4294967296).toString(16).substr(-8);
const swapLE = (c) => c << 24 & 4278190080 | c << 8 & 16711680 | c >> 8 & 65280 | c >> 24 & 255;
const swapBE = (c) => c;
const swap32 = isBE() ? swapBE : swapLE;
const ch = (x, y, z) => z ^ x & (y ^ z);
const maj = (x, y, z) => x & y | z & (x | y);
const sigma0 = (x) => (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
const sigma1 = (x) => (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
const gamma0 = (x) => (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
const gamma1 = (x) => (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
function isBE() {
  const buf = new Uint8Array(new Uint16Array([65279]).buffer);
  return buf[0] === 254;
}
async function sha256$1(atu8_data) {
  return new Uint8Array(await crypto.subtle.digest("SHA-256", atu8_data));
}
const sha256_sync_insecure = (atu8_data) => createHash_1().update(atu8_data).digest();
let y_sha256;
void instantiateSha256().then((y) => y_sha256 = y);
const sha256_sync$1 = (atu8_data) => y_sha256.final(y_sha256.update(y_sha256.init(), atu8_data));
let y_ripemd;
void instantiateRipemd160().then((y) => y_ripemd = y);
const ripemd160_sync = (atu8_data) => y_ripemd.final(y_ripemd.update(y_ripemd.init(), atu8_data));
function zero_out(atu8_data) {
  atu8_data.fill(0);
  if (0 !== atu8_data.reduce((c, x) => c + x, 0))
    throw new Error("Failed to zero out sensitive memory region");
}
function text_to_buffer(s_text) {
  return new TextEncoder().encode(s_text);
}
function buffer_to_text(atu8_text) {
  return new TextDecoder().decode(atu8_text);
}
const sfcc = String.fromCharCode;
function buffer_to_hex(atu8_buffer) {
  let sx_hex = "";
  for (const xb_byte of atu8_buffer) {
    sx_hex += xb_byte.toString(16).padStart(2, "0");
  }
  return sx_hex;
}
function hex_to_buffer(sx_hex) {
  const nl_hex = sx_hex.length;
  if (0 !== nl_hex % 2)
    throw new Error(`Invalid hex string length is not a multiple of 2`);
  const nb_buffer = nl_hex / 2;
  const atu8_buffer = new Uint8Array(nb_buffer);
  for (let i_byte = 0; i_byte < nb_buffer; i_byte++) {
    atu8_buffer[i_byte] = parseInt(sx_hex.slice(i_byte + i_byte, i_byte + i_byte + 2), 16);
  }
  return atu8_buffer;
}
function buffer_to_base64(atu8_buffer) {
  return globalThis.btoa(buffer_to_string8(atu8_buffer));
}
function base64_to_buffer(sx_buffer) {
  return string8_to_buffer(globalThis.atob(sx_buffer));
}
function buffer_to_string8(atu8_buffer) {
  let sx_buffer = "";
  for (const xb_byte of atu8_buffer) {
    sx_buffer += sfcc(xb_byte);
  }
  return sx_buffer;
}
function string8_to_buffer(sx_buffer) {
  const nl_pairs = sx_buffer.length;
  const atu8_buffer = new Uint8Array(nl_pairs);
  for (let i_read = 0; i_read < nl_pairs; i_read++) {
    atu8_buffer[i_read] = sx_buffer.charCodeAt(i_read);
  }
  return atu8_buffer;
}
var sha256 = { exports: {} };
var core = { exports: {} };
(function(module, exports) {
  (function(root, factory2) {
    {
      module.exports = factory2();
    }
  })(commonjsGlobal, function() {
    var CryptoJS = CryptoJS || function(Math2, undefined$1) {
      var crypto2;
      if (typeof window !== "undefined" && window.crypto) {
        crypto2 = window.crypto;
      }
      if (typeof self !== "undefined" && self.crypto) {
        crypto2 = self.crypto;
      }
      if (typeof globalThis !== "undefined" && globalThis.crypto) {
        crypto2 = globalThis.crypto;
      }
      if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
        crypto2 = window.msCrypto;
      }
      if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
        crypto2 = commonjsGlobal.crypto;
      }
      if (!crypto2 && typeof commonjsRequire === "function") {
        try {
          crypto2 = require("crypto");
        } catch (err) {
        }
      }
      var cryptoSecureRandomInt = function() {
        if (crypto2) {
          if (typeof crypto2.getRandomValues === "function") {
            try {
              return crypto2.getRandomValues(new Uint32Array(1))[0];
            } catch (err) {
            }
          }
          if (typeof crypto2.randomBytes === "function") {
            try {
              return crypto2.randomBytes(4).readInt32LE();
            } catch (err) {
            }
          }
        }
        throw new Error("Native crypto module could not be used to get secure random number.");
      };
      var create4 = Object.create || function() {
        function F() {
        }
        return function(obj) {
          var subtype;
          F.prototype = obj;
          subtype = new F();
          F.prototype = null;
          return subtype;
        };
      }();
      var C = {};
      var C_lib = C.lib = {};
      var Base = C_lib.Base = function() {
        return {
          extend: function(overrides) {
            var subtype = create4(this);
            if (overrides) {
              subtype.mixIn(overrides);
            }
            if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
              subtype.init = function() {
                subtype.$super.init.apply(this, arguments);
              };
            }
            subtype.init.prototype = subtype;
            subtype.$super = this;
            return subtype;
          },
          create: function() {
            var instance2 = this.extend();
            instance2.init.apply(instance2, arguments);
            return instance2;
          },
          init: function() {
          },
          mixIn: function(properties) {
            for (var propertyName in properties) {
              if (properties.hasOwnProperty(propertyName)) {
                this[propertyName] = properties[propertyName];
              }
            }
            if (properties.hasOwnProperty("toString")) {
              this.toString = properties.toString;
            }
          },
          clone: function() {
            return this.init.prototype.extend(this);
          }
        };
      }();
      var WordArray = C_lib.WordArray = Base.extend({
        init: function(words, sigBytes) {
          words = this.words = words || [];
          if (sigBytes != undefined$1) {
            this.sigBytes = sigBytes;
          } else {
            this.sigBytes = words.length * 4;
          }
        },
        toString: function(encoder) {
          return (encoder || Hex).stringify(this);
        },
        concat: function(wordArray) {
          var thisWords = this.words;
          var thatWords = wordArray.words;
          var thisSigBytes = this.sigBytes;
          var thatSigBytes = wordArray.sigBytes;
          this.clamp();
          if (thisSigBytes % 4) {
            for (var i = 0; i < thatSigBytes; i++) {
              var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
            }
          } else {
            for (var j = 0; j < thatSigBytes; j += 4) {
              thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
            }
          }
          this.sigBytes += thatSigBytes;
          return this;
        },
        clamp: function() {
          var words = this.words;
          var sigBytes = this.sigBytes;
          words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
          words.length = Math2.ceil(sigBytes / 4);
        },
        clone: function() {
          var clone2 = Base.clone.call(this);
          clone2.words = this.words.slice(0);
          return clone2;
        },
        random: function(nBytes) {
          var words = [];
          for (var i = 0; i < nBytes; i += 4) {
            words.push(cryptoSecureRandomInt());
          }
          return new WordArray.init(words, nBytes);
        }
      });
      var C_enc = C.enc = {};
      var Hex = C_enc.Hex = {
        stringify: function(wordArray) {
          var words = wordArray.words;
          var sigBytes = wordArray.sigBytes;
          var hexChars = [];
          for (var i = 0; i < sigBytes; i++) {
            var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
            hexChars.push((bite >>> 4).toString(16));
            hexChars.push((bite & 15).toString(16));
          }
          return hexChars.join("");
        },
        parse: function(hexStr) {
          var hexStrLength = hexStr.length;
          var words = [];
          for (var i = 0; i < hexStrLength; i += 2) {
            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
          }
          return new WordArray.init(words, hexStrLength / 2);
        }
      };
      var Latin1 = C_enc.Latin1 = {
        stringify: function(wordArray) {
          var words = wordArray.words;
          var sigBytes = wordArray.sigBytes;
          var latin1Chars = [];
          for (var i = 0; i < sigBytes; i++) {
            var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
            latin1Chars.push(String.fromCharCode(bite));
          }
          return latin1Chars.join("");
        },
        parse: function(latin1Str) {
          var latin1StrLength = latin1Str.length;
          var words = [];
          for (var i = 0; i < latin1StrLength; i++) {
            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
          }
          return new WordArray.init(words, latin1StrLength);
        }
      };
      var Utf8 = C_enc.Utf8 = {
        stringify: function(wordArray) {
          try {
            return decodeURIComponent(escape(Latin1.stringify(wordArray)));
          } catch (e) {
            throw new Error("Malformed UTF-8 data");
          }
        },
        parse: function(utf8Str) {
          return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
      };
      var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
        reset: function() {
          this._data = new WordArray.init();
          this._nDataBytes = 0;
        },
        _append: function(data) {
          if (typeof data == "string") {
            data = Utf8.parse(data);
          }
          this._data.concat(data);
          this._nDataBytes += data.sigBytes;
        },
        _process: function(doFlush) {
          var processedWords;
          var data = this._data;
          var dataWords = data.words;
          var dataSigBytes = data.sigBytes;
          var blockSize = this.blockSize;
          var blockSizeBytes = blockSize * 4;
          var nBlocksReady = dataSigBytes / blockSizeBytes;
          if (doFlush) {
            nBlocksReady = Math2.ceil(nBlocksReady);
          } else {
            nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
          }
          var nWordsReady = nBlocksReady * blockSize;
          var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
          if (nWordsReady) {
            for (var offset = 0; offset < nWordsReady; offset += blockSize) {
              this._doProcessBlock(dataWords, offset);
            }
            processedWords = dataWords.splice(0, nWordsReady);
            data.sigBytes -= nBytesReady;
          }
          return new WordArray.init(processedWords, nBytesReady);
        },
        clone: function() {
          var clone2 = Base.clone.call(this);
          clone2._data = this._data.clone();
          return clone2;
        },
        _minBufferSize: 0
      });
      C_lib.Hasher = BufferedBlockAlgorithm.extend({
        cfg: Base.extend(),
        init: function(cfg) {
          this.cfg = this.cfg.extend(cfg);
          this.reset();
        },
        reset: function() {
          BufferedBlockAlgorithm.reset.call(this);
          this._doReset();
        },
        update: function(messageUpdate) {
          this._append(messageUpdate);
          this._process();
          return this;
        },
        finalize: function(messageUpdate) {
          if (messageUpdate) {
            this._append(messageUpdate);
          }
          var hash2 = this._doFinalize();
          return hash2;
        },
        blockSize: 512 / 32,
        _createHelper: function(hasher) {
          return function(message, cfg) {
            return new hasher.init(cfg).finalize(message);
          };
        },
        _createHmacHelper: function(hasher) {
          return function(message, key) {
            return new C_algo.HMAC.init(hasher, key).finalize(message);
          };
        }
      });
      var C_algo = C.algo = {};
      return C;
    }(Math);
    return CryptoJS;
  });
})(core);
(function(module, exports) {
  (function(root, factory2) {
    {
      module.exports = factory2(core.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function(Math2) {
      var C = CryptoJS;
      var C_lib = C.lib;
      var WordArray = C_lib.WordArray;
      var Hasher = C_lib.Hasher;
      var C_algo = C.algo;
      var H = [];
      var K2 = [];
      (function() {
        function isPrime(n2) {
          var sqrtN = Math2.sqrt(n2);
          for (var factor = 2; factor <= sqrtN; factor++) {
            if (!(n2 % factor)) {
              return false;
            }
          }
          return true;
        }
        function getFractionalBits(n2) {
          return (n2 - (n2 | 0)) * 4294967296 | 0;
        }
        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
          if (isPrime(n)) {
            if (nPrime < 8) {
              H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
            }
            K2[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
            nPrime++;
          }
          n++;
        }
      })();
      var W2 = [];
      var SHA256 = C_algo.SHA256 = Hasher.extend({
        _doReset: function() {
          this._hash = new WordArray.init(H.slice(0));
        },
        _doProcessBlock: function(M, offset) {
          var H2 = this._hash.words;
          var a = H2[0];
          var b = H2[1];
          var c = H2[2];
          var d = H2[3];
          var e = H2[4];
          var f = H2[5];
          var g = H2[6];
          var h = H2[7];
          for (var i = 0; i < 64; i++) {
            if (i < 16) {
              W2[i] = M[offset + i] | 0;
            } else {
              var gamma0x = W2[i - 15];
              var gamma02 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
              var gamma1x = W2[i - 2];
              var gamma12 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
              W2[i] = gamma02 + W2[i - 7] + gamma12 + W2[i - 16];
            }
            var ch2 = e & f ^ ~e & g;
            var maj2 = a & b ^ a & c ^ b & c;
            var sigma02 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
            var sigma12 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
            var t1 = h + sigma12 + ch2 + K2[i] + W2[i];
            var t2 = sigma02 + maj2;
            h = g;
            g = f;
            f = e;
            e = d + t1 | 0;
            d = c;
            c = b;
            b = a;
            a = t1 + t2 | 0;
          }
          H2[0] = H2[0] + a | 0;
          H2[1] = H2[1] + b | 0;
          H2[2] = H2[2] + c | 0;
          H2[3] = H2[3] + d | 0;
          H2[4] = H2[4] + e | 0;
          H2[5] = H2[5] + f | 0;
          H2[6] = H2[6] + g | 0;
          H2[7] = H2[7] + h | 0;
        },
        _doFinalize: function() {
          var data = this._data;
          var dataWords = data.words;
          var nBitsTotal = this._nDataBytes * 8;
          var nBitsLeft = data.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
          dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
          data.sigBytes = dataWords.length * 4;
          this._process();
          return this._hash;
        },
        clone: function() {
          var clone2 = Hasher.clone.call(this);
          clone2._hash = this._hash.clone();
          return clone2;
        }
      });
      C.SHA256 = Hasher._createHelper(SHA256);
      C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
    })(Math);
    return CryptoJS.SHA256;
  });
})(sha256);
var sha256_sync = sha256.exports;
var sha512 = { exports: {} };
var x64Core = { exports: {} };
(function(module, exports) {
  (function(root, factory2) {
    {
      module.exports = factory2(core.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function(undefined$1) {
      var C = CryptoJS;
      var C_lib = C.lib;
      var Base = C_lib.Base;
      var X32WordArray = C_lib.WordArray;
      var C_x64 = C.x64 = {};
      C_x64.Word = Base.extend({
        init: function(high, low) {
          this.high = high;
          this.low = low;
        }
      });
      C_x64.WordArray = Base.extend({
        init: function(words, sigBytes) {
          words = this.words = words || [];
          if (sigBytes != undefined$1) {
            this.sigBytes = sigBytes;
          } else {
            this.sigBytes = words.length * 8;
          }
        },
        toX32: function() {
          var x64Words = this.words;
          var x64WordsLength = x64Words.length;
          var x32Words = [];
          for (var i = 0; i < x64WordsLength; i++) {
            var x64Word = x64Words[i];
            x32Words.push(x64Word.high);
            x32Words.push(x64Word.low);
          }
          return X32WordArray.create(x32Words, this.sigBytes);
        },
        clone: function() {
          var clone2 = Base.clone.call(this);
          var words = clone2.words = this.words.slice(0);
          var wordsLength = words.length;
          for (var i = 0; i < wordsLength; i++) {
            words[i] = words[i].clone();
          }
          return clone2;
        }
      });
    })();
    return CryptoJS;
  });
})(x64Core);
(function(module, exports) {
  (function(root, factory2, undef) {
    {
      module.exports = factory2(core.exports, x64Core.exports);
    }
  })(commonjsGlobal, function(CryptoJS) {
    (function() {
      var C = CryptoJS;
      var C_lib = C.lib;
      var Hasher = C_lib.Hasher;
      var C_x64 = C.x64;
      var X64Word = C_x64.Word;
      var X64WordArray = C_x64.WordArray;
      var C_algo = C.algo;
      function X64Word_create() {
        return X64Word.create.apply(X64Word, arguments);
      }
      var K2 = [
        X64Word_create(1116352408, 3609767458),
        X64Word_create(1899447441, 602891725),
        X64Word_create(3049323471, 3964484399),
        X64Word_create(3921009573, 2173295548),
        X64Word_create(961987163, 4081628472),
        X64Word_create(1508970993, 3053834265),
        X64Word_create(2453635748, 2937671579),
        X64Word_create(2870763221, 3664609560),
        X64Word_create(3624381080, 2734883394),
        X64Word_create(310598401, 1164996542),
        X64Word_create(607225278, 1323610764),
        X64Word_create(1426881987, 3590304994),
        X64Word_create(1925078388, 4068182383),
        X64Word_create(2162078206, 991336113),
        X64Word_create(2614888103, 633803317),
        X64Word_create(3248222580, 3479774868),
        X64Word_create(3835390401, 2666613458),
        X64Word_create(4022224774, 944711139),
        X64Word_create(264347078, 2341262773),
        X64Word_create(604807628, 2007800933),
        X64Word_create(770255983, 1495990901),
        X64Word_create(1249150122, 1856431235),
        X64Word_create(1555081692, 3175218132),
        X64Word_create(1996064986, 2198950837),
        X64Word_create(2554220882, 3999719339),
        X64Word_create(2821834349, 766784016),
        X64Word_create(2952996808, 2566594879),
        X64Word_create(3210313671, 3203337956),
        X64Word_create(3336571891, 1034457026),
        X64Word_create(3584528711, 2466948901),
        X64Word_create(113926993, 3758326383),
        X64Word_create(338241895, 168717936),
        X64Word_create(666307205, 1188179964),
        X64Word_create(773529912, 1546045734),
        X64Word_create(1294757372, 1522805485),
        X64Word_create(1396182291, 2643833823),
        X64Word_create(1695183700, 2343527390),
        X64Word_create(1986661051, 1014477480),
        X64Word_create(2177026350, 1206759142),
        X64Word_create(2456956037, 344077627),
        X64Word_create(2730485921, 1290863460),
        X64Word_create(2820302411, 3158454273),
        X64Word_create(3259730800, 3505952657),
        X64Word_create(3345764771, 106217008),
        X64Word_create(3516065817, 3606008344),
        X64Word_create(3600352804, 1432725776),
        X64Word_create(4094571909, 1467031594),
        X64Word_create(275423344, 851169720),
        X64Word_create(430227734, 3100823752),
        X64Word_create(506948616, 1363258195),
        X64Word_create(659060556, 3750685593),
        X64Word_create(883997877, 3785050280),
        X64Word_create(958139571, 3318307427),
        X64Word_create(1322822218, 3812723403),
        X64Word_create(1537002063, 2003034995),
        X64Word_create(1747873779, 3602036899),
        X64Word_create(1955562222, 1575990012),
        X64Word_create(2024104815, 1125592928),
        X64Word_create(2227730452, 2716904306),
        X64Word_create(2361852424, 442776044),
        X64Word_create(2428436474, 593698344),
        X64Word_create(2756734187, 3733110249),
        X64Word_create(3204031479, 2999351573),
        X64Word_create(3329325298, 3815920427),
        X64Word_create(3391569614, 3928383900),
        X64Word_create(3515267271, 566280711),
        X64Word_create(3940187606, 3454069534),
        X64Word_create(4118630271, 4000239992),
        X64Word_create(116418474, 1914138554),
        X64Word_create(174292421, 2731055270),
        X64Word_create(289380356, 3203993006),
        X64Word_create(460393269, 320620315),
        X64Word_create(685471733, 587496836),
        X64Word_create(852142971, 1086792851),
        X64Word_create(1017036298, 365543100),
        X64Word_create(1126000580, 2618297676),
        X64Word_create(1288033470, 3409855158),
        X64Word_create(1501505948, 4234509866),
        X64Word_create(1607167915, 987167468),
        X64Word_create(1816402316, 1246189591)
      ];
      var W2 = [];
      (function() {
        for (var i = 0; i < 80; i++) {
          W2[i] = X64Word_create();
        }
      })();
      var SHA512 = C_algo.SHA512 = Hasher.extend({
        _doReset: function() {
          this._hash = new X64WordArray.init([
            new X64Word.init(1779033703, 4089235720),
            new X64Word.init(3144134277, 2227873595),
            new X64Word.init(1013904242, 4271175723),
            new X64Word.init(2773480762, 1595750129),
            new X64Word.init(1359893119, 2917565137),
            new X64Word.init(2600822924, 725511199),
            new X64Word.init(528734635, 4215389547),
            new X64Word.init(1541459225, 327033209)
          ]);
        },
        _doProcessBlock: function(M, offset) {
          var H = this._hash.words;
          var H0 = H[0];
          var H1 = H[1];
          var H2 = H[2];
          var H3 = H[3];
          var H4 = H[4];
          var H5 = H[5];
          var H6 = H[6];
          var H7 = H[7];
          var H0h = H0.high;
          var H0l = H0.low;
          var H1h = H1.high;
          var H1l = H1.low;
          var H2h = H2.high;
          var H2l = H2.low;
          var H3h = H3.high;
          var H3l = H3.low;
          var H4h = H4.high;
          var H4l = H4.low;
          var H5h = H5.high;
          var H5l = H5.low;
          var H6h = H6.high;
          var H6l = H6.low;
          var H7h = H7.high;
          var H7l = H7.low;
          var ah = H0h;
          var al = H0l;
          var bh = H1h;
          var bl = H1l;
          var ch2 = H2h;
          var cl = H2l;
          var dh = H3h;
          var dl = H3l;
          var eh = H4h;
          var el = H4l;
          var fh = H5h;
          var fl = H5l;
          var gh = H6h;
          var gl = H6l;
          var hh = H7h;
          var hl = H7l;
          for (var i = 0; i < 80; i++) {
            var Wil;
            var Wih;
            var Wi = W2[i];
            if (i < 16) {
              Wih = Wi.high = M[offset + i * 2] | 0;
              Wil = Wi.low = M[offset + i * 2 + 1] | 0;
            } else {
              var gamma0x = W2[i - 15];
              var gamma0xh = gamma0x.high;
              var gamma0xl = gamma0x.low;
              var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
              var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
              var gamma1x = W2[i - 2];
              var gamma1xh = gamma1x.high;
              var gamma1xl = gamma1x.low;
              var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
              var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
              var Wi7 = W2[i - 7];
              var Wi7h = Wi7.high;
              var Wi7l = Wi7.low;
              var Wi16 = W2[i - 16];
              var Wi16h = Wi16.high;
              var Wi16l = Wi16.low;
              Wil = gamma0l + Wi7l;
              Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
              Wil = Wil + gamma1l;
              Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
              Wil = Wil + Wi16l;
              Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
              Wi.high = Wih;
              Wi.low = Wil;
            }
            var chh = eh & fh ^ ~eh & gh;
            var chl = el & fl ^ ~el & gl;
            var majh = ah & bh ^ ah & ch2 ^ bh & ch2;
            var majl = al & bl ^ al & cl ^ bl & cl;
            var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
            var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
            var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
            var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
            var Ki = K2[i];
            var Kih = Ki.high;
            var Kil = Ki.low;
            var t1l = hl + sigma1l;
            var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
            var t1l = t1l + chl;
            var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
            var t1l = t1l + Kil;
            var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
            var t1l = t1l + Wil;
            var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
            var t2l = sigma0l + majl;
            var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
            hh = gh;
            hl = gl;
            gh = fh;
            gl = fl;
            fh = eh;
            fl = el;
            el = dl + t1l | 0;
            eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
            dh = ch2;
            dl = cl;
            ch2 = bh;
            cl = bl;
            bh = ah;
            bl = al;
            al = t1l + t2l | 0;
            ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
          }
          H0l = H0.low = H0l + al;
          H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
          H1l = H1.low = H1l + bl;
          H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
          H2l = H2.low = H2l + cl;
          H2.high = H2h + ch2 + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
          H3l = H3.low = H3l + dl;
          H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
          H4l = H4.low = H4l + el;
          H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
          H5l = H5.low = H5l + fl;
          H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
          H6l = H6.low = H6l + gl;
          H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
          H7l = H7.low = H7l + hl;
          H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
        },
        _doFinalize: function() {
          var data = this._data;
          var dataWords = data.words;
          var nBitsTotal = this._nDataBytes * 8;
          var nBitsLeft = data.sigBytes * 8;
          dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
          dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
          dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
          data.sigBytes = dataWords.length * 4;
          this._process();
          var hash2 = this._hash.toX32();
          return hash2;
        },
        clone: function() {
          var clone2 = Hasher.clone.call(this);
          clone2._hash = this._hash.clone();
          return clone2;
        },
        blockSize: 1024 / 32
      });
      C.SHA512 = Hasher._createHelper(SHA512);
      C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
    })();
    return CryptoJS.SHA512;
  });
})(sha512);
var sha512_sync = sha512.exports;
function destroyed() {
  throw new Error("Method called on destroyed SensitiveBytes instance");
}
class SensitiveBytesContext {
  constructor() {
    __publicField(this, "_a_biguints", []);
  }
  random(nb_size) {
    const kn_random = SensitiveBytes.random(nb_size);
    this._a_biguints.push(kn_random);
    return kn_random;
  }
  empty(nb_size) {
    const kn_empty = SensitiveBytes.random(nb_size);
    this._a_biguints.push(kn_empty);
    return kn_empty;
  }
  new(atu8_data) {
    const kn_new = new SensitiveBytes(atu8_data, this);
    this._a_biguints.push(kn_new);
    return kn_new;
  }
  wipe() {
    for (const kn_each of this._a_biguints) {
      kn_each.wipe();
    }
  }
}
class SensitiveBytes {
  constructor(_atu8_data, _kc_context = null) {
    this._atu8_data = _atu8_data;
    this._kc_context = _kc_context;
  }
  static context() {
    return new SensitiveBytesContext();
  }
  static random(nb_size) {
    return new SensitiveBytes(crypto.getRandomValues(new Uint8Array(nb_size)));
  }
  static empty(nb_size = 0) {
    return new SensitiveBytes(new Uint8Array(nb_size));
  }
  get data() {
    return this._atu8_data;
  }
  clone() {
    return new SensitiveBytes(Uint8Array.from(this._atu8_data), this._kc_context);
  }
  wipe() {
    this._atu8_data.fill(0);
    this.clone = this.wipe = this.diff = this.compare = this.mod = destroyed;
    Object.defineProperties(this, {
      data: {
        get: destroyed
      },
      digits: {
        get: destroyed
      }
    });
  }
  leftShift(ni_shift) {
    if (Number.isInteger(ni_shift) || ni_shift < 0) {
      this.wipe();
      throw new Error("Refusing to left shift by argument that is not a non-negative integer");
    }
    if (0 === ni_shift)
      return this.clone();
    const nb_digits_this = this._atu8_data.byteLength;
    const atu8_output = new Uint8Array(nb_digits_this);
    const nb_shift = ni_shift >>> 3;
    const atu8_sub = this._atu8_data.subarray(nb_shift);
    const ni_remainder = ni_shift % 8;
    if (0 === ni_remainder) {
      atu8_output.set(atu8_sub);
      return new SensitiveBytes(atu8_output);
    }
    const xm_truncate = 255 >>> ni_remainder;
    const ni_carry = 8 - ni_remainder;
    let ib_each = 0;
    for (; ib_each < nb_digits_this - 1 - nb_shift; ib_each++) {
      atu8_output[ib_each] = (atu8_sub[ib_each] & xm_truncate) << ni_remainder | atu8_sub[ib_each + 1] >>> ni_carry;
    }
    if (0 === nb_shift) {
      atu8_output[ib_each] <<= ni_shift;
    }
    return new SensitiveBytes(atu8_output);
  }
  rightShift(ni_shift) {
    if (Number.isInteger(ni_shift) || ni_shift < 0) {
      this.wipe();
      throw new Error("Refusing to left shift by argument that is not a non-negative integer");
    }
    if (0 === ni_shift)
      return this.clone();
    const atu8_data = this._atu8_data;
    const nb_digits_this = atu8_data.byteLength;
    const atu8_output = new Uint8Array(nb_digits_this);
    const ni_remainder = ni_shift % 8;
    const nb_shift = ni_shift >>> 3;
    if (0 === ni_remainder) {
      atu8_output.set(atu8_data, nb_shift);
      return new SensitiveBytes(atu8_output);
    }
    const atu8_sub = atu8_data.subarray(0, nb_digits_this - (ni_shift >>> 3));
    const ni_carry = 8 - ni_remainder;
    if (0 === nb_shift) {
      atu8_output[0] >>= ni_shift;
    }
    let ib_each = 1;
    for (; ib_each < nb_digits_this - 1; ib_each++) {
      atu8_output[ib_each] = atu8_sub[ib_each - 1] << ni_carry & 255 | atu8_sub[ib_each] >>> ni_remainder;
    }
    return new SensitiveBytes(atu8_output);
  }
  xor(kn_other) {
    const atu8_data_this = this._atu8_data;
    const atu8_data_other = kn_other._atu8_data;
    const nb_digits_this = atu8_data_this.byteLength;
    if (nb_digits_this !== atu8_data_other.byteLength) {
      this.wipe();
      kn_other.wipe();
      throw new Error("Refusing to XOR buffers of different byte length");
    }
    const atu8_output = new Uint8Array(nb_digits_this);
    for (let ib_each = 0; ib_each < nb_digits_this; ib_each++) {
      atu8_output[ib_each] = atu8_data_this[ib_each] ^ atu8_data_other[ib_each];
    }
    return new SensitiveBytes(atu8_output);
  }
  split(xb_value) {
    const atu8_data = this.data;
    const nb_this = atu8_data.byteLength;
    const a_words = [];
    let ib_start = 0;
    for (let ib_each = 0; ib_each < nb_this; ib_each++) {
      if (xb_value === atu8_data[ib_each]) {
        a_words.push(atu8_data.subarray(ib_start, ib_each));
        ib_start = ib_each + 1;
      }
    }
    return a_words;
  }
}
const d_broadcast_global = new BroadcastChannel("global");
function global_broadcast(g_msg) {
  d_broadcast_global.postMessage(g_msg);
  d_broadcast_global.dispatchEvent(new MessageEvent("message", {
    data: g_msg
  }));
}
function global_receive(h_handlers) {
  const f_listener = (d_event) => {
    const g_msg = d_event.data;
    if (!g_msg || !g_msg.type) {
      throw new Error("Ignored invalid message received on global broadcast channel");
    }
    const {
      type: si_type,
      value: w_value = null
    } = g_msg;
    const f_handler = h_handlers[si_type];
    if (!f_handler)
      return;
    void f_handler(w_value);
  };
  d_broadcast_global.addEventListener("message", f_listener);
  return () => {
    d_broadcast_global.removeEventListener("message", f_listener);
  };
}
async function global_wait(si_key, fk_test, xt_timeout = 0) {
  const s_stack = new Error().stack || "";
  return new Promise((fk_resolve, fe_reject) => {
    let i_timeout = 0;
    const f_unregister = global_receive({
      [si_key]: (w_value) => {
        if (fk_test(w_value)) {
          f_unregister();
          clearTimeout(i_timeout);
          fk_resolve();
        }
      }
    });
    if (Number.isInteger(xt_timeout) && xt_timeout > 0) {
      i_timeout = globalThis.setTimeout(() => {
        f_unregister();
        fe_reject(new Error(`A timeout was reached waiting for the '${si_key}' event
${s_stack}`));
      }, xt_timeout);
    }
  });
}
class NotAuthenticatedError extends Error {
}
class AlreadyRegisteredError extends Error {
}
class InvalidPassphraseError extends Error {
}
class UnregisteredError extends Error {
}
class RecoverableVaultError extends Error {
}
class CorruptedVaultError extends Error {
}
const ATU8_DUMMY_PHRASE = text_to_buffer("32-character-long-dummy-password");
const ATU8_DUMMY_VECTOR = new Uint8Array(crypto.getRandomValues(new Uint8Array(16)));
const NL_PASSPHRASE_MINIMUM = 5;
const NL_PASSPHRASE_MAXIMUM = 1024;
function acceptable(sh_phrase) {
  return "string" === typeof sh_phrase && sh_phrase.length >= NL_PASSPHRASE_MINIMUM && sh_phrase.length <= NL_PASSPHRASE_MAXIMUM;
}
async function register(sh_phrase, f_update = F_NOOP) {
  f_update("Reading from storage");
  const g_root = await Vault.getBase();
  if (Vault.isValidBase(g_root)) {
    throw new AlreadyRegisteredError();
  }
  if (!sh_phrase || !acceptable(sh_phrase)) {
    throw new InvalidPassphraseError();
  }
  const atu8_phrase = text_to_buffer(sh_phrase);
  f_update("Deriving root keys");
  const atu8_entropy = crypto.getRandomValues(new Uint8Array(8));
  const dv_random = new DataView(crypto.getRandomValues(new Uint32Array(2)).buffer);
  const xg_nonce_init = dv_random.getBigUint64(0, false);
  const {
    new: {
      key: dk_root_new,
      nonce: xg_nonce_new
    }
  } = await Vault.deriveRootKeys(atu8_phrase, atu8_entropy, xg_nonce_init);
  f_update("Generating signature");
  const atu8_signature = await Vault.generateRootKeySignature(dk_root_new);
  f_update("Saving to storage");
  await Vault.setParsedBase({
    entropy: atu8_entropy,
    nonce: xg_nonce_new,
    signature: atu8_signature
  });
}
async function login(sh_phrase, b_recover = false, f_update = F_NOOP) {
  f_update("Reading from storage");
  const g_root = await Vault.getBase();
  if (!g_root) {
    throw new UnregisteredError();
  }
  if (!Vault.isValidBase(g_root)) {
    throw new CorruptedVaultError(`Storage is corrupt; root object is missing or partially damaged`);
  }
  const {
    entropy: atu8_entropy,
    nonce: xg_nonce_old,
    signature: atu8_signature_old,
    version: n_version
  } = Vault.parseBase(g_root);
  if (n_version < 1) {
    throw new CorruptedVaultError(`Vault reports to be encrypted with an unknown version identifier`);
  } else if (n_version > 1) {
    throw new CorruptedVaultError(`Vault reports to be encrypted with a newer version identifier`);
  }
  if (!sh_phrase)
    throw new InvalidPassphraseError();
  const atu8_phrase = text_to_buffer(sh_phrase);
  f_update("Deriving root keys");
  const {
    old: {
      key: dk_root_old,
      vector: atu8_vector_old
    },
    new: {
      key: dk_root_new,
      vector: atu8_vector_new,
      nonce: xg_nonce_new
    },
    export: kn_root_new
  } = await Vault.deriveRootKeys(atu8_phrase, atu8_entropy, xg_nonce_old, true);
  try {
    if (!await Vault.verifyRootKey(dk_root_old, atu8_signature_old)) {
      if (!await Vault.verifyRootKey(dk_root_new, atu8_signature_old)) {
        throw new InvalidPassphraseError();
      } else if (!b_recover) {
        throw new RecoverableVaultError();
      }
    }
    f_update("Rotating keys");
    await Vault.recryptAll(dk_root_old, atu8_vector_old, dk_root_new, atu8_vector_new);
    f_update("Generating signature");
    const atu8_signature_new = await Vault.generateRootKeySignature(dk_root_new);
    f_update("Saving to storage");
    await Vault.setParsedBase({
      entropy: atu8_entropy,
      nonce: xg_nonce_new,
      signature: atu8_signature_new
    });
    if (session_storage_is_native) {
      await session_storage_set_native({
        root: dk_root_new,
        vector: atu8_vector_new
      });
    } else {
      await session_storage_set_wrapped({
        root: Array.from(kn_root_new.data),
        vector: Array.from(atu8_vector_new)
      });
    }
    kn_root_new?.wipe();
    global_broadcast({
      type: "login"
    });
    f_update("Done");
  } catch (e_thrown) {
    kn_root_new?.wipe();
    throw e_thrown;
  }
}
async function logout() {
  await Vault.clearRootKey();
}
function syserr(g_error) {
  console.error(g_error);
  return g_error.error || new Error(g_error.text);
}
function syswarn(g_warn) {
  console.warn(g_warn);
}
var ContactAgentType = /* @__PURE__ */ ((ContactAgentType2) => {
  ContactAgentType2["PERSON"] = "person";
  ContactAgentType2["CONTRACT"] = "contract";
  return ContactAgentType2;
})(ContactAgentType || {});
const SI_VERSION = "0.0.3";
const XT_SECONDS = 1e3;
const XT_MINUTES = 60 * XT_SECONDS;
const R_DOMAIN_LOCALHOST = /^(localhost|127.0.0.1)(:\d+)?$/;
const R_DOMAIN_IP = /^\d+(?:.\d+){3}(:\d+)?$/;
const R_BECH32 = /^(\w+)([13])([a-zA-HJ-NP-Z0-9]{25,39})$/;
const P_PUBLIC_SUFFIX_LIST = "https://raw.githubusercontent.com/publicsuffix/list/master/public_suffix_list.dat";
const P_STARSHELL_DECREES = "https://raw.githubusercontent.com/SolarRepublic/wallet-decrees/main/global.json";
const R_TRANSFER_AMOUNT = /^(\d+)(.+)/;
const SI_STORE_SECRETS = "secrets";
const SI_STORE_APPS = "apps";
const SI_STORE_APP_POLICIES = "app_policies";
const SI_STORE_AGENTS = "agents";
const SI_STORE_SETTINGS = "settings";
const SI_STORE_ACCOUNTS = "accounts";
const SI_STORE_QUERY_CACHE = "query_cache";
const SI_STORE_TAGS = "tags";
const SI_STORE_MEDIA = "media";
const SI_STORE_PFPS = "pfps";
const SI_STORE_CHAINS = "chains";
const SI_STORE_NETWORKS = "networks";
const SI_STORE_ENTITIES = "entities";
const SI_STORE_EVENTS = "events";
const SI_STORE_WEB_RESOURCES = "web_resources";
const SI_STORE_WEB_APIS = "web_apis";
const type_check = (h_input) => h_input;
const H_MEDIA = { "/media.image/sha256.8df5056ed6b806c2e36cd5b4e59f7ada3d832d339a4528417e12d44de9f02156": { "hash": "8df5056ed6b806c2e36cd5b4e59f7ada3d832d339a4528417e12d44de9f02156", "data": "/media/chain/akash.svg" }, "/media.image/sha256.4010e79c2131a2cceee1027940138e866c0c95fa961059ce6958cf5a3ea460c4": { "hash": "4010e79c2131a2cceee1027940138e866c0c95fa961059ce6958cf5a3ea460c4", "data": "/media/chain/cosmos-hub.svg" }, "/media.image/sha256.da6c5b6b3348288b3ea67d4dd9eaf3fc57f7f0bda1ddaf11bd64624f358eec49": { "hash": "da6c5b6b3348288b3ea67d4dd9eaf3fc57f7f0bda1ddaf11bd64624f358eec49", "data": "/media/chain/dvpn.png" }, "/media.image/sha256.8f7927283c16106a4d7e0adf84d087b195d9c2f011d10ddd5d219c8502d6f2af": { "hash": "8f7927283c16106a4d7e0adf84d087b195d9c2f011d10ddd5d219c8502d6f2af", "data": "/media/chain/iris.svg" }, "/media.image/sha256.e6012eddd6d5ff8339fdbc8db0671e70921e6407d51ff14126620a06e5898eeb": { "hash": "e6012eddd6d5ff8339fdbc8db0671e70921e6407d51ff14126620a06e5898eeb", "data": "/media/chain/juno.svg" }, "/media.image/sha256.0439126779b99998d706fd6515935595644b31118814d7cb4749144ea3e9f625": { "hash": "0439126779b99998d706fd6515935595644b31118814d7cb4749144ea3e9f625", "data": "/media/chain/luna.svg" }, "/media.image/sha256.668c28e1a5e0ce6839c6b3a8a35c5dfba3e284a442f7ae4049398472f72ace27": { "hash": "668c28e1a5e0ce6839c6b3a8a35c5dfba3e284a442f7ae4049398472f72ace27", "data": "/media/chain/monero.svg" }, "/media.image/sha256.63b08c298e1dd7f81d61e20bf7fcc8d2e9f9b6a424769b34c7c5a9439c1a1655": { "hash": "63b08c298e1dd7f81d61e20bf7fcc8d2e9f9b6a424769b34c7c5a9439c1a1655", "data": "/media/chain/osmosis.svg" }, "/media.image/sha256.9dedfbec129c61f372221053f27deaf4205e827e487db702a0fc0b83b717e056": { "hash": "9dedfbec129c61f372221053f27deaf4205e827e487db702a0fc0b83b717e056", "data": "/media/chain/regen.png" }, "/media.image/sha256.b04e9464a3d26cea0815da3fd5bf454af9d3317be96732ecda9ea830bdeaeec5": { "hash": "b04e9464a3d26cea0815da3fd5bf454af9d3317be96732ecda9ea830bdeaeec5", "data": "/media/chain/secret-network.svg" }, "/media.image/sha256.4436f974426723faa4948135da5c96842c7c9ced4dfe6ae1556281428fcada3f": { "hash": "4436f974426723faa4948135da5c96842c7c9ced4dfe6ae1556281428fcada3f", "data": "/media/token/secret-secret.svg" }, "/media.image/sha256.af836bf7edee07cefd268465180256b79115a796c2b8e33a440ef987bee95dcc": { "hash": "af836bf7edee07cefd268465180256b79115a796c2b8e33a440ef987bee95dcc", "data": "/media/vendor/logo-128px.png" }, "/media.image/sha256.a5d0053596c7044eb2ffdc43b035e1ffc095dbe667fbdc3d6667e56b7e4b019b": { "hash": "a5d0053596c7044eb2ffdc43b035e1ffc095dbe667fbdc3d6667e56b7e4b019b", "data": "/media/vendor/logo-192px.png" }, "/media.image/sha256.adf28c4af60418bcbff19498d7fcbc938def15322951677cf3838c162ac26c0e": { "hash": "adf28c4af60418bcbff19498d7fcbc938def15322951677cf3838c162ac26c0e", "data": "/media/vendor/logo-256px.png" }, "/media.image/sha256.345ede2f04cdf5c837e9a363dbb27a40c1383d86b371e1445ab4145727ee64c1": { "hash": "345ede2f04cdf5c837e9a363dbb27a40c1383d86b371e1445ab4145727ee64c1", "data": "/media/vendor/logo-32px.png" }, "/media.image/sha256.9457704318786e08034fdcd7ba1917249f91a1e49a3ee0aa5d73339021f4dc13": { "hash": "9457704318786e08034fdcd7ba1917249f91a1e49a3ee0aa5d73339021f4dc13", "data": "/media/vendor/logo-48px.png" }, "/media.image/sha256.4873801c4ffd5294ca110258d39c26f9dd4af896b7c34cda591d5a6a317c8ff7": { "hash": "4873801c4ffd5294ca110258d39c26f9dd4af896b7c34cda591d5a6a317c8ff7", "data": "/media/vendor/logo-64px.png" }, "/media.image/sha256.ab8cba62b0a72801f542bd88580af91fa60a31ff724ef6e732559b706b706196": { "hash": "ab8cba62b0a72801f542bd88580af91fa60a31ff724ef6e732559b706b706196", "data": "/media/vendor/logo-96px.png" }, "/media.image/sha256.602124abca18b5e30da54addb50ca5fb0ca044cd8590c5fd4edc75a98b0f3412": { "hash": "602124abca18b5e30da54addb50ca5fb0ca044cd8590c5fd4edc75a98b0f3412", "data": "/media/vendor/logo.svg" }, "/media.image/sha256.861e55f23f97723dd9e5ff9b4ab708c6b6aef4986d59f66a56ba2e329f7efd15": { "hash": "861e55f23f97723dd9e5ff9b4ab708c6b6aef4986d59f66a56ba2e329f7efd15", "data": "/media/vendor/orb-1.png" }, "/media.image/sha256.88286cacda5af5ae34fb924513e0d5f0158ad535eaf1e452a8013b20acdf8e9e": { "hash": "88286cacda5af5ae34fb924513e0d5f0158ad535eaf1e452a8013b20acdf8e9e", "data": "/media/vendor/orb-1.svg" }, "/media.image/sha256.cf644a4e8f825a6df083b5399e51749dd97af568abdf4146b27374476bf7977b": { "hash": "cf644a4e8f825a6df083b5399e51749dd97af568abdf4146b27374476bf7977b", "data": "/media/vendor/title.svg" }, "/media.image/sha256.6fee1420b6bf2f7c0cad4c59a457abcef727be430705233e141a90cea5bb5622": { "hash": "6fee1420b6bf2f7c0cad4c59a457abcef727be430705233e141a90cea5bb5622", "data": "/media/other/secret-saturn.png" }, "/media.image/sha256.3f62d381cd0f496c946093344fdb27180f12e28241a60ee99a34efc185ae08ff": { "hash": "3f62d381cd0f496c946093344fdb27180f12e28241a60ee99a34efc185ae08ff", "data": "/media/other/supdoggie.png" } };
const H_MEDIA_LOOKUP = { "/media/chain/akash.svg": "/media.image/sha256.8df5056ed6b806c2e36cd5b4e59f7ada3d832d339a4528417e12d44de9f02156", "/media/chain/cosmos-hub.svg": "/media.image/sha256.4010e79c2131a2cceee1027940138e866c0c95fa961059ce6958cf5a3ea460c4", "/media/chain/dvpn.png": "/media.image/sha256.da6c5b6b3348288b3ea67d4dd9eaf3fc57f7f0bda1ddaf11bd64624f358eec49", "/media/chain/iris.svg": "/media.image/sha256.8f7927283c16106a4d7e0adf84d087b195d9c2f011d10ddd5d219c8502d6f2af", "/media/chain/juno.svg": "/media.image/sha256.e6012eddd6d5ff8339fdbc8db0671e70921e6407d51ff14126620a06e5898eeb", "/media/chain/luna.svg": "/media.image/sha256.0439126779b99998d706fd6515935595644b31118814d7cb4749144ea3e9f625", "/media/chain/monero.svg": "/media.image/sha256.668c28e1a5e0ce6839c6b3a8a35c5dfba3e284a442f7ae4049398472f72ace27", "/media/chain/osmosis.svg": "/media.image/sha256.63b08c298e1dd7f81d61e20bf7fcc8d2e9f9b6a424769b34c7c5a9439c1a1655", "/media/chain/regen.png": "/media.image/sha256.9dedfbec129c61f372221053f27deaf4205e827e487db702a0fc0b83b717e056", "/media/chain/secret-network.svg": "/media.image/sha256.b04e9464a3d26cea0815da3fd5bf454af9d3317be96732ecda9ea830bdeaeec5", "/media/token/secret-secret.svg": "/media.image/sha256.4436f974426723faa4948135da5c96842c7c9ced4dfe6ae1556281428fcada3f", "/media/vendor/logo-128px.png": "/media.image/sha256.af836bf7edee07cefd268465180256b79115a796c2b8e33a440ef987bee95dcc", "/media/vendor/logo-192px.png": "/media.image/sha256.a5d0053596c7044eb2ffdc43b035e1ffc095dbe667fbdc3d6667e56b7e4b019b", "/media/vendor/logo-256px.png": "/media.image/sha256.adf28c4af60418bcbff19498d7fcbc938def15322951677cf3838c162ac26c0e", "/media/vendor/logo-32px.png": "/media.image/sha256.345ede2f04cdf5c837e9a363dbb27a40c1383d86b371e1445ab4145727ee64c1", "/media/vendor/logo-48px.png": "/media.image/sha256.9457704318786e08034fdcd7ba1917249f91a1e49a3ee0aa5d73339021f4dc13", "/media/vendor/logo-64px.png": "/media.image/sha256.4873801c4ffd5294ca110258d39c26f9dd4af896b7c34cda591d5a6a317c8ff7", "/media/vendor/logo-96px.png": "/media.image/sha256.ab8cba62b0a72801f542bd88580af91fa60a31ff724ef6e732559b706b706196", "/media/vendor/logo.svg": "/media.image/sha256.602124abca18b5e30da54addb50ca5fb0ca044cd8590c5fd4edc75a98b0f3412", "/media/vendor/orb-1.png": "/media.image/sha256.861e55f23f97723dd9e5ff9b4ab708c6b6aef4986d59f66a56ba2e329f7efd15", "/media/vendor/orb-1.svg": "/media.image/sha256.88286cacda5af5ae34fb924513e0d5f0158ad535eaf1e452a8013b20acdf8e9e", "/media/vendor/title.svg": "/media.image/sha256.cf644a4e8f825a6df083b5399e51749dd97af568abdf4146b27374476bf7977b", "/media/other/secret-saturn.png": "/media.image/sha256.6fee1420b6bf2f7c0cad4c59a457abcef727be430705233e141a90cea5bb5622", "/media/other/supdoggie.png": "/media.image/sha256.3f62d381cd0f496c946093344fdb27180f12e28241a60ee99a34efc185ae08ff" };
const H_STORE_INIT_MEDIA = type_check(H_MEDIA);
const cosmos_bech32s = (s_prefix) => ({
  acc: {
    hrp: s_prefix,
    separator: "1"
  },
  accpub: {
    hrp: `${s_prefix}pub`,
    separator: "1"
  },
  valoper: {
    hrp: `${s_prefix}valoper`,
    separator: "1"
  },
  valoperpub: {
    hrp: `${s_prefix}valoperpub`,
    separator: "1"
  },
  valcons: {
    hrp: `${s_prefix}valcons`,
    separator: "1"
  },
  valconspub: {
    hrp: `${s_prefix}valconspub`,
    separator: "1"
  }
});
const H_STORE_INIT_PFPS = type_check(fold([
  {
    type: "plain",
    image: {
      default: H_MEDIA_LOOKUP["/media/vendor/logo.svg"]
    }
  },
  {
    type: "plain",
    image: {
      default: H_MEDIA_LOOKUP["/media/chain/cosmos-hub.svg"]
    }
  },
  {
    type: "plain",
    image: {
      default: H_MEDIA_LOOKUP["/media/chain/secret-network.svg"]
    }
  },
  {
    type: "plain",
    image: {
      default: H_MEDIA_LOOKUP["/media/token/secret-secret.svg"]
    }
  },
  {
    type: "plain",
    image: {
      default: H_MEDIA_LOOKUP["/media/other/secret-saturn.png"]
    }
  },
  {
    type: "plain",
    image: {
      default: H_MEDIA_LOOKUP["/media/other/supdoggie.png"]
    }
  }
], (g_pfp, i_pfp) => ({
  [`/template.pfp/id.${i_pfp}`]: g_pfp
})));
const H_LOOKUP_PFP = {};
for (const [p_pfp, g_pfp] of ode(H_STORE_INIT_PFPS)) {
  if ("plain" === g_pfp.type) {
    const g_media = H_MEDIA[g_pfp.image.default];
    H_LOOKUP_PFP[g_media.data] = p_pfp;
  }
}
const H_STORE_INIT_CHAINS = type_check({
  "/family.cosmos/chain.pulsar-2": {
    name: "Secret Pulsar",
    pfp: H_LOOKUP_PFP["/media/chain/secret-network.svg"],
    family: "cosmos",
    id: "pulsar-2",
    bech32s: cosmos_bech32s("secret"),
    bip44: {
      coinType: 529
    },
    coins: {
      SCRT: {
        decimals: 6,
        denom: "uscrt",
        name: "Secret",
        pfp: H_LOOKUP_PFP["/media/chain/secret-network.svg"],
        extra: {
          coingecko_id: "secret"
        }
      }
    },
    tokenInterfaces: ["snip-20", "snip-21", "snip-721", "snip-722"],
    testnet: true
  },
  "/family.cosmos/chain.theta-testnet-001": {
    name: "Cosmos Hub Theta",
    pfp: H_LOOKUP_PFP["/media/chain/cosmos-hub.svg"],
    family: "cosmos",
    id: "theta-testnet-001",
    bech32s: cosmos_bech32s("cosmos"),
    bip44: {
      coinType: 118
    },
    coins: {
      ATOM: {
        decimals: 6,
        denom: "uatom",
        name: "Cosmos",
        pfp: H_LOOKUP_PFP["/media/chain/cosmos-hub.svg"],
        extra: {
          coingecko_id: "cosmos-hub"
        }
      }
    },
    tokenInterfaces: ["cw-20"],
    testnet: true
  }
});
const H_STORE_INIT_NETWORKS = type_check(fold([
  {
    name: "\u{1D54A}ecret \u{1D54A}aturn",
    pfp: H_LOOKUP_PFP["/media/other/secret-saturn.png"],
    chain: "/family.cosmos/chain.pulsar-2",
    grpcWebUrl: "https://grpc.testnet.secretsaturn.net",
    rpcHost: "rpc.testnet.secretsaturn.net"
  },
  {
    name: "StarShell",
    pfp: H_LOOKUP_PFP["/media/vendor/logo.svg"],
    chain: "/family.cosmos/chain.theta-testnet-001",
    grpcWebUrl: "https://grpc-web.cosmos-theta.starshell.net",
    rpcHost: "rpc.cosmos-theta.starshell.net"
  }
], (g_each) => ({
  [`/network.${buffer_to_base64(sha256_sync_insecure(text_to_buffer(g_each.grpcWebUrl)))}`]: g_each
})));
const H_STORE_INIT_APPS = type_check(fold([
  {
    scheme: "https",
    host: "app.starshell.net",
    connections: {},
    pfp: H_LOOKUP_PFP["/media/vendor/logo.svg"]
  },
  {
    scheme: "https",
    host: "faucet.secrettestnet.io",
    connections: {},
    pfp: ""
  }
], (g_each) => ({
  [`/scheme.${g_each.scheme}/host.${g_each.host.replace(/:/g, "+")}`]: g_each
})));
const H_STORE_INIT_AGENTS = type_check(fold([
  {
    name: "supdoggie",
    notes: "",
    agentType: ContactAgentType.PERSON,
    space: "acc",
    family: "cosmos",
    chains: {},
    pfp: H_LOOKUP_PFP["/media/other/supdoggie.png"],
    address: "0mtm48ul5mcgjj4hm0a4j3td4l5pt590erl3k9",
    origin: "built-in"
  },
  {
    name: "faucet.secrettestnet.io",
    notes: "",
    agentType: ContactAgentType.PERSON,
    space: "acc",
    family: "cosmos",
    chains: {},
    pfp: "",
    address: "3fqtu0lxsvn8gtlf3mz5kt75spxv93ssa6vecf",
    origin: "built-in"
  }
], (g_contact) => ({
  [`/family.${g_contact.family}/agent.${g_contact.address}/as.contact`]: g_contact
})));
const H_STORE_INITS = {
  [SI_STORE_APPS]: H_STORE_INIT_APPS,
  [SI_STORE_APP_POLICIES]: {
    hq: [],
    user: []
  },
  [SI_STORE_ACCOUNTS]: {},
  [SI_STORE_AGENTS]: H_STORE_INIT_AGENTS,
  [SI_STORE_CHAINS]: H_STORE_INIT_CHAINS,
  [SI_STORE_NETWORKS]: H_STORE_INIT_NETWORKS,
  [SI_STORE_SETTINGS]: {},
  [SI_STORE_MEDIA]: H_STORE_INIT_MEDIA,
  [SI_STORE_PFPS]: H_STORE_INIT_PFPS,
  [SI_STORE_ENTITIES]: {},
  [SI_STORE_EVENTS]: [],
  [SI_STORE_SECRETS]: {},
  [SI_STORE_TAGS]: {
    registry: oderac({
      pink: "#D500F9",
      hot: "#C51162",
      orange: "#FF4D21",
      gold: "#FF8622",
      yellow: "#EEB521",
      autum: "#7E9E24",
      grass: "#3A6F16",
      teal: "#009688",
      sky: "#1976D2",
      violet: "#6200EA",
      gray: "#607D8B",
      brown: "#795548",
      bright: "#ffffff"
    }, (si_key, s_value, i_entry) => ({
      index: i_entry,
      color: s_value,
      name: si_key,
      info: ""
    })),
    map: {}
  },
  [SI_STORE_QUERY_CACHE]: {},
  [SI_STORE_WEB_RESOURCES]: {},
  [SI_STORE_WEB_APIS]: {}
};
const ATU8_SHA256_STARSHELL = hex_to_buffer(sha256_sync("starshell").toString());
hex_to_buffer(sha512_sync("starshell").toString());
const N_ITERATIONS = 20;
const NB_SALT = 256 >> 3;
const SI_PRF = "SHA-512";
const NI_DERIVED_AES_KEY = 256;
const NB_RECRYPTION_THRESHOLD = 32 * 1024;
const GC_DERIVE_ROOT_SIGNING = {
  name: "HMAC",
  hash: "SHA-256"
};
const GC_DERIVE_ROOT_CIPHER = {
  name: "AES-GCM",
  length: NI_DERIVED_AES_KEY
};
const GC_HKDF_COMMON = {
  name: "HKDF",
  hash: "SHA-256",
  salt: ATU8_SHA256_STARSHELL,
  info: Uint8Array.from([])
};
const A_STORE_KEYS = ["keys", ...Object.keys(H_STORE_INITS)];
const SI_FRAME_LOCAL = crypto.randomUUID().slice(24);
const hm_privates$3 = /* @__PURE__ */ new WeakMap();
async function restore_as_key(z_data, w_kdf, b_extractable, a_usages) {
  if (Array.isArray(z_data)) {
    return await crypto.subtle.importKey("raw", Uint8Array.from(z_data), w_kdf, false, a_usages);
  }
  return z_data;
}
function restore_as_buffer(z_data) {
  if (Array.isArray(z_data)) {
    return Uint8Array.from(z_data);
  }
  return z_data;
}
const {
  session_storage_get,
  session_storage_set_native,
  session_storage_set_wrapped,
  session_storage_remove,
  session_storage_clear,
  session_storage_is_native
} = (() => {
  if (chrome.storage["session"]) {
    const d_session = chrome.storage.session;
    return {
      async session_storage_get(si_key) {
        return (await d_session.get([si_key]))[si_key];
      },
      session_storage_set_native(h_set_native) {
        throw new Error("Implementation bug; cannot use native session storage");
      },
      async session_storage_set_wrapped(h_set_wrapped) {
        return await d_session.set(h_set_wrapped);
      },
      async session_storage_remove(si_key) {
        return await d_session.remove(si_key);
      },
      async session_storage_clear() {
        return await d_session.clear();
      },
      session_storage_is_native: false
    };
  } else {
    const dw_background = chrome.extension.getBackgroundPage();
    if (!dw_background) {
      throw new Error("Browser does not support any type of session storage");
    }
    let g_session = dw_background["_g_session"] = {};
    return {
      async session_storage_get(si_key) {
        return g_session[si_key] ?? null;
      },
      async session_storage_set_native(h_set_native) {
        for (const [si_key, w_value] of ode(h_set_native)) {
          session_storage_remove(si_key);
          g_session[si_key] = w_value;
        }
      },
      async session_storage_set_wrapped(h_set_wrapped) {
        throw new Error("Implementation bug; cannot use wrapped session storage");
      },
      async session_storage_remove(si_key) {
        const z_value = g_session[si_key];
        if (z_value && "object" === typeof z_value) {
          if (Array.isArray(z_value) || ArrayBuffer.isView(z_value)) {
            zero_out(z_value);
          }
        }
        delete g_session[si_key];
      },
      async session_storage_clear() {
        for (const [si_key, w_value] of ode(g_session)) {
          session_storage_remove(si_key);
        }
        dw_background["_g_session"] = g_session = {};
      },
      session_storage_is_native: true
    };
  }
})();
async function session_storage_set_isomorphic(h_set) {
  if (session_storage_is_native) {
    await session_storage_set_native(h_set);
  } else {
    await session_storage_set_wrapped(h_set);
  }
}
async function hkdf_params() {
  const g_base = await Vault.getBase();
  let atu8_salt;
  if (Vault.isValidBase(g_base)) {
    atu8_salt = await Vault.getSalt();
    if (!atu8_salt || NB_SALT !== atu8_salt.byteLength) {
      throw new Error("Vault is irreparably corrupted. No salt was found.");
    }
  } else {
    atu8_salt = crypto.getRandomValues(new Uint8Array(NB_SALT));
    await Vault.setSalt(atu8_salt);
  }
  return {
    ...GC_HKDF_COMMON,
    salt: atu8_salt
  };
}
function pbkdf2_derive2(ab_nonce, x_iteration_multiplier = 0) {
  return async function(dk_base) {
    return new SensitiveBytes(new Uint8Array(await crypto.subtle.deriveBits({
      name: "PBKDF2",
      salt: ab_nonce,
      iterations: x_iteration_multiplier ? Math.ceil(N_ITERATIONS * x_iteration_multiplier) : N_ITERATIONS,
      hash: SI_PRF
    }, dk_base, 256)));
  };
}
class DecryptionError extends Error {
  constructor(original) {
    super("Failed to decrypt data: " + original);
    this.original = original;
  }
}
async function decrypt(atu8_data, dk_key, atu8_nonce, atu8_verify = ATU8_SHA256_STARSHELL) {
  try {
    return new Uint8Array(await crypto.subtle.decrypt({
      name: "AES-GCM",
      iv: atu8_nonce,
      additionalData: atu8_verify
    }, dk_key, atu8_data));
  } catch (e_decrypt) {
    console.warn(`
			const atu8_key = Uint8Array.from([${Array.from(new Uint8Array(await crypto.subtle.exportKey("raw", dk_key))).join(",")}]);
			const dk_key = await crypto.subtle.importKey('raw', atu8_key, 'AES-GCM', true, ['encrypt', 'decrypt']);
			const atu8_nonce = Uint8Array.from([${Array.from(atu8_nonce).join(",")}]);
			const atu8_verify = Uint8Array.from([${Array.from(atu8_verify).join(",")}]);
			const atu8_data = Uint8Array.from([${Array.from(atu8_data).join(",")}]);
			const atu8_ans = await crypto.subtle.decrypt({
				name: 'AES-GCM',
				iv: atu8_nonce,
				additionalData: atu8_verify,
			}, dk_key, atu8_data);
		`);
    debugger;
    throw new DecryptionError(e_decrypt);
  }
}
class EncryptionError extends Error {
  constructor(original) {
    super("Failed to encrypt data: " + original);
    this.original = original;
  }
}
async function encrypt(atu8_data, dk_key, atu8_nonce, atu8_verify = ATU8_SHA256_STARSHELL) {
  try {
    return new Uint8Array(await crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: atu8_nonce,
      additionalData: atu8_verify
    }, dk_key, atu8_data));
  } catch (e_encrypt) {
    throw new EncryptionError(e_encrypt);
  }
}
const h_release_waiters_local = {};
const Vault = {
  async getBase() {
    return (await chrome.storage.local.get(["base"]))["base"];
  },
  isValidBase(z_test) {
    return !!z_test && "object" === typeof z_test && "number" === typeof z_test["version"] && "string" === typeof z_test["entropy"] && "string" === typeof z_test["nonce"] && "string" === typeof z_test["signature"];
  },
  parseBase(g_base) {
    return {
      version: g_base.version,
      entropy: hex_to_buffer(g_base.entropy),
      nonce: BigInt(g_base.nonce),
      signature: hex_to_buffer(g_base.signature)
    };
  },
  async setParsedBase(g_base) {
    return await chrome.storage.local.set({
      base: {
        version: 1,
        entropy: buffer_to_hex(g_base.entropy),
        nonce: g_base.nonce + "",
        signature: buffer_to_hex(g_base.signature)
      }
    });
  },
  async eraseBase() {
    return await chrome.storage.local.remove(["base"]);
  },
  async getSalt() {
    const sx_salt = (await chrome.storage.local.get(["salt"]))["salt"];
    return sx_salt ? hex_to_buffer(sx_salt) : void 0;
  },
  async setSalt(atu8_salt) {
    return await chrome.storage.local.set({
      salt: buffer_to_hex(atu8_salt)
    });
  },
  async getRootKey() {
    const w_root = await session_storage_get("root");
    if (!w_root)
      return null;
    return await restore_as_key(w_root, "HKDF", false, ["deriveKey"]);
  },
  async clearRootKey() {
    let dw_background;
    if (chrome.extension.getBackgroundPage && (dw_background = chrome.extension.getBackgroundPage())) {
      delete dw_background["_dk_root"];
    }
    global_broadcast({
      type: "logout"
    });
    await Promise.all([
      session_storage_clear()
    ]);
  },
  deriveRootBits(atu8_phrase, ab_nonce, x_iteration_multiplier = 0) {
    return crypto.subtle.importKey("raw", atu8_phrase, "PBKDF2", false, ["deriveBits"]).then(pbkdf2_derive2(ab_nonce, x_iteration_multiplier));
  },
  async deriveRootKeys(atu8_phrase, atu8_entropy, xg_nonce_old, b_export_new = false) {
    const xg_nonce_new = (xg_nonce_old + 1n) % 2n ** 64n;
    const atu8_vector_old = new Uint8Array(16);
    const atu8_vector_new = new Uint8Array(16);
    atu8_vector_old.set(atu8_entropy, 0);
    atu8_vector_new.set(atu8_entropy, 0);
    new DataView(atu8_vector_old.buffer).setBigUint64(8, xg_nonce_old, false);
    new DataView(atu8_vector_new.buffer).setBigUint64(8, xg_nonce_new, false);
    const [
      kn_root_old,
      kn_root_new
    ] = await Promise.all([
      Vault.deriveRootBits(atu8_phrase, atu8_vector_old),
      Vault.deriveRootBits(atu8_phrase, atu8_vector_new)
    ]);
    zero_out(atu8_phrase);
    const [
      dk_root_old,
      dk_root_new
    ] = await Promise.all([
      crypto.subtle.importKey("raw", kn_root_old.data, "HKDF", false, ["deriveKey"]),
      crypto.subtle.importKey("raw", kn_root_new.data, "HKDF", false, ["deriveKey"])
    ]);
    kn_root_old.wipe();
    if (!b_export_new)
      kn_root_new.wipe();
    return {
      old: {
        key: dk_root_old,
        vector: atu8_vector_old,
        nonce: xg_nonce_old
      },
      new: {
        key: dk_root_new,
        vector: atu8_vector_new,
        nonce: xg_nonce_new
      },
      export: b_export_new ? kn_root_new : null
    };
  },
  async cipherKey(dk_root, b_encrypt = false) {
    return crypto.subtle.deriveKey(await hkdf_params(), dk_root, GC_DERIVE_ROOT_CIPHER, true, b_encrypt ? ["encrypt", "decrypt"] : ["decrypt"]);
  },
  async signatureKey(dk_root, b_signer = false) {
    return crypto.subtle.deriveKey(await hkdf_params(), dk_root, GC_DERIVE_ROOT_SIGNING, false, b_signer ? ["sign"] : ["verify"]);
  },
  async generateRootKeySignature(dk_root) {
    const dk_verify = await Vault.signatureKey(dk_root, true);
    return new Uint8Array(await crypto.subtle.sign("HMAC", dk_verify, ATU8_SHA256_STARSHELL));
  },
  async verifyRootKey(dk_root, atu8_test) {
    const dk_verify = await Vault.signatureKey(dk_root, false);
    return await crypto.subtle.verify("HMAC", dk_verify, atu8_test, ATU8_SHA256_STARSHELL);
  },
  async recryptAll(dk_root_old, atu8_nonce_old, dk_root_new, atu8_nonce_new) {
    const a_promises = [];
    let cb_pending = 0;
    const [
      dk_aes_old,
      dk_aes_new
    ] = await Promise.all([
      Vault.cipherKey(dk_root_old, false),
      Vault.cipherKey(dk_root_new, true)
    ]);
    for (const si_key of A_STORE_KEYS) {
      const sx_entry = (await chrome.storage.local.get([si_key]))[si_key];
      if (!sx_entry)
        continue;
      const atu8_entry = string8_to_buffer(sx_entry);
      cb_pending += atu8_entry.byteLength;
      a_promises.push((async () => {
        let atu8_data;
        try {
          atu8_data = await decrypt(atu8_entry, dk_aes_old, atu8_nonce_old);
        } catch (e_decrypt) {
          atu8_data = await decrypt(atu8_entry, dk_aes_new, atu8_nonce_old);
        }
        const atu8_replace = await encrypt(atu8_data, dk_aes_new, atu8_nonce_new);
        await chrome.storage.local.set({
          [si_key]: buffer_to_string8(atu8_replace)
        });
        cb_pending -= atu8_entry.byteLength;
      })());
      if (cb_pending > NB_RECRYPTION_THRESHOLD) {
        await Promise.all(a_promises);
        a_promises.length = 0;
      }
    }
    await Promise.all(a_promises);
  },
  async peekJson(si_key, dk_cipher) {
    const kp_store = await Vault.acquire(si_key);
    const w_read = kp_store.readJson(dk_cipher);
    await kp_store.release();
    return w_read;
  },
  async readonly(si_key) {
    const sx_entry = (await chrome.storage.local.get(si_key))[si_key];
    return new VaultEntry(si_key, sx_entry ?? "");
  },
  async acquire(si_key, c_attempts = 0) {
    const si_lock = `lock_${si_key}`;
    const sx_owner = await session_storage_get(si_lock);
    if (sx_owner) {
      const [si_frame, si_moment] = sx_owner.split(":");
      if (SI_FRAME_LOCAL === si_frame) {
        await new Promise((fk_resolve) => {
          let i_timeout = 0;
          (h_release_waiters_local[si_key] = h_release_waiters_local[si_key] || []).push(() => {
            clearTimeout(i_timeout);
            fk_resolve(void 0);
          });
          i_timeout = globalThis.setTimeout(() => {
            syserr({
              text: `Local lock on '${si_key}' lasted more than 5 seconds; possible bug in implementation.`
            });
          }, 5e3);
        });
      } else {
        console.warn(`'${si_key}' store is currently locked on a remote frame: ${sx_owner}; waiting for release`);
        try {
          await global_wait("releaseStore", (g_release) => si_key === g_release.key, 5e3);
        } catch (e_timeout) {
          syswarn({
            text: "Recovered from previous interrupted shutdown."
          });
          await session_storage_remove(`lock_${si_key}`);
        }
      }
    }
    const si_self = SI_FRAME_LOCAL + ":" + crypto.randomUUID().slice(24);
    await session_storage_set_isomorphic({ [si_lock]: si_self });
    if (si_self !== await session_storage_get(si_lock)) {
      if (c_attempts > 10) {
        throw new Error(`Exceeded maximum retry count while trying to checkout "${si_key}" from the vault`);
      }
      return await Vault.acquire(si_key, c_attempts + 1);
    }
    global_broadcast({
      type: "acquireStore",
      value: {
        key: si_key
      }
    });
    const sx_entry = (await chrome.storage.local.get(si_key))[si_key];
    return new WritableVaultEntry(si_key, sx_entry ?? "");
  }
};
function VaultEntry$_fields(kv_this) {
  const g_privates = hm_privates$3.get(kv_this);
  if (!g_privates) {
    throw new Error(`Attempted to use '${kv_this._si_key}' store after it was released or it was never opened for writing.`);
  }
  return g_privates;
}
class VaultEntry {
  constructor(_si_key, sx_store) {
    this._si_key = _si_key;
    hm_privates$3.set(this, {
      atu8_ciphertext: string8_to_buffer(sx_store)
    });
  }
  async read(dk_cipher) {
    const atu8_vector = restore_as_buffer(await session_storage_get("vector"));
    if (!atu8_vector) {
      throw new NotAuthenticatedError();
    }
    const g_privates = VaultEntry$_fields(this);
    if (!g_privates.atu8_ciphertext.byteLength) {
      return new Uint8Array(0);
    }
    return await decrypt(g_privates.atu8_ciphertext, dk_cipher, atu8_vector);
  }
  async readJson(dk_cipher) {
    let h_store = {};
    try {
      const atu8_store = await this.read(dk_cipher);
      if (!atu8_store.byteLength)
        return null;
      h_store = JSON.parse(buffer_to_text(atu8_store));
      zero_out(atu8_store);
    } catch (e_read) {
      try {
        if (this instanceof WritableVaultEntry) {
          void this.release();
        }
      } catch (e_ignore) {
      }
      throw e_read;
    }
    return h_store;
  }
}
class WritableVaultEntry extends VaultEntry {
  async release() {
    VaultEntry$_fields(this);
    hm_privates$3.delete(this);
    await session_storage_remove(`lock_${this._si_key}`);
    if (this._si_key in h_release_waiters_local) {
      for (const f_notify of h_release_waiters_local[this._si_key]) {
        f_notify();
      }
    }
    global_broadcast({
      type: "releaseStore",
      value: {
        key: this._si_key
      }
    });
  }
  async write(atu8_data, dk_cipher, b_init = false) {
    const g_privates = VaultEntry$_fields(this);
    const atu8_vector = restore_as_buffer(await session_storage_get("vector"));
    if (!atu8_vector) {
      throw new NotAuthenticatedError();
    }
    const atu8_ciphertext = await encrypt(atu8_data, dk_cipher, atu8_vector);
    await chrome.storage.local.set({
      [this._si_key]: buffer_to_string8(atu8_ciphertext)
    });
    zero_out(g_privates.atu8_ciphertext);
    g_privates.atu8_ciphertext = atu8_ciphertext;
    queueMicrotask(() => {
      global_broadcast({
        type: "updateStore",
        value: {
          key: this._si_key,
          init: b_init
        }
      });
    });
  }
  async writeJson(w_value, dk_cipher, b_init = false) {
    const atu8_data = text_to_buffer(JSON.stringify(w_value));
    return await this.write(atu8_data, dk_cipher, b_init);
  }
}
const hm_privates$2 = /* @__PURE__ */ new WeakMap();
class WritableStore {
  constructor(_kv_store, _w_cache, dk_cipher) {
    this._kv_store = _kv_store;
    this._w_cache = _w_cache;
    hm_privates$2.set(this, {
      dk_cipher
    });
  }
  get raw() {
    return this._w_cache;
  }
  release() {
    return this._kv_store.release();
  }
  save(b_init = false) {
    return this._kv_store.writeJson(this._w_cache, hm_privates$2.get(this).dk_cipher, b_init);
  }
}
class WritableStoreArray extends WritableStore {
  get size() {
    return this._w_cache.length;
  }
  at(i_key) {
    return this._w_cache[i_key] ?? null;
  }
  map(f_map) {
    return this._w_cache.map(f_map);
  }
  async prepend(w_value) {
    this._w_cache.unshift(w_value);
    await this.save();
  }
  async append(w_value) {
    this._w_cache.unshift(w_value);
    await this.save();
  }
}
class WritableStoreMap extends WritableStore {
  *[Symbol.iterator]() {
    for (const a_pair of ode(this._w_cache)) {
      yield a_pair;
    }
  }
  at(p_res) {
    return this._w_cache[p_res] ?? null;
  }
  reduce(f_map) {
    return oderac(this._w_cache, f_map);
  }
  entries() {
    return ode(this._w_cache);
  }
}
class WritableStoreDict extends WritableStore {
  get(si_key) {
    return this._w_cache[si_key] ?? null;
  }
  async set(si_key, w_value) {
    this._w_cache[si_key] = w_value;
    await this.save();
  }
}
async function fetch_cipher() {
  const dk_root = await Vault.getRootKey();
  if (!dk_root)
    throw new NotAuthenticatedError();
  return await Vault.cipherKey(dk_root, true);
}
function create_store_class({
  store: si_store,
  class: dc_store,
  extension: s_extension
}) {
  return Object.assign(dc_store, {
    async open(fk_use) {
      const dk_cipher = await fetch_cipher();
      const kv_store = await Vault.acquire(si_store);
      let w_store = await kv_store.readJson(dk_cipher);
      let b_save = false;
      if (!w_store) {
        w_store = H_STORE_INITS[si_store];
        b_save = true;
      }
      const ks_store = new dc_store(kv_store, w_store, dk_cipher);
      if (b_save)
        await ks_store.save(true);
      const w_return = await fk_use(ks_store);
      await ks_store.release();
      return w_return;
    },
    read() {
      return dc_store["open"]((ks_store) => ks_store);
    },
    ..."array" === s_extension && {
      async prepend(w_value) {
        return await dc_store["open"]((ks_self) => ks_self.prepend(w_value));
      },
      async append(w_value) {
        return await dc_store["open"]((ks_self) => ks_self.append(w_value));
      }
    },
    ..."map" === s_extension && {
      async at(si_key) {
        return await dc_store["open"]((ks_self) => ks_self.at(si_key));
      }
    },
    ..."dict" === s_extension && {
      async get(si_key) {
        return await dc_store["open"]((ks_self) => ks_self.get(si_key));
      },
      async set(si_key, w_value) {
        return await dc_store["open"]((ks_self) => ks_self.put(si_key, w_value));
      }
    }
  });
}
function subscribe_store(si_key, f_callback) {
  return global_receive({
    updateStore({ key: si_store, init: b_init }) {
      if (si_store === si_key) {
        f_callback(b_init);
      }
    }
  });
}
(async () => {
  await instantiateRipemd160();
})();
const Chains = create_store_class({
  store: SI_STORE_CHAINS,
  class: class ChainsI extends WritableStoreMap {
    static pathFor(si_family, si_chain) {
      return `/family.${si_family}/chain.${si_chain}`;
    }
    static pathFrom(g_chain) {
      return ChainsI.pathFor(g_chain.family, g_chain.id);
    }
    static addressFor(s_pubkey, g_chain = yw_chain.get(), g_bech32 = g_chain.bech32s.acc) {
      const atu8_sha256 = sha256_sync$1(base64_to_buffer(s_pubkey));
      const atu8_ripemd160 = ripemd160_sync(atu8_sha256);
      return bech32.encode(g_bech32.hrp, bech32.toWords(atu8_ripemd160));
    }
    static bech32(s_addr, g_chain = yw_chain.get(), g_bech32 = g_chain.bech32s.acc) {
      return `${g_bech32.hrp}${g_bech32.separator}${s_addr}`;
    }
    static get(si_family, si_chain) {
      return Chains.read().then((ks) => ks.get(si_family, si_chain));
    }
    static at(p_chain) {
      return Chains.read().then((ks) => ks.at(p_chain));
    }
    static isValidAddressFor(g_chain, s_address, si_purpose = "acc") {
      if (g_chain.bech32s) {
        const m_bech32 = R_BECH32.exec(s_address);
        return m_bech32 && m_bech32[1] === g_chain.bech32s[si_purpose].hrp && m_bech32[2] === g_chain.bech32s[si_purpose].separator;
      } else {
        return false;
      }
    }
    *inFamily(si_family) {
      const p_prefix = ChainsI.pathFor(si_family, "");
      for (const [p_chain, g_chain] of ode(this._w_cache)) {
        if (p_chain.startsWith(p_prefix)) {
          yield [p_chain, g_chain];
        }
      }
    }
    get(si_family, si_chain) {
      const p_res = ChainsI.pathFor(si_family, si_chain);
      return this._w_cache[p_res] ?? null;
    }
    async put(g_res) {
      const p_res = ChainsI.pathFrom(g_res);
      this._w_cache[p_res] = g_res;
      await this.save();
      return p_res;
    }
  }
});
const TokenRegistry = {
  "cw-20": {
    attributes: {
      fungible: false
    }
  },
  "snip-20": {
    attributes: {
      fungible: true
    }
  },
  "snip-21": {
    extends: "snip-20",
    attributes: {
      fungible: true
    }
  },
  "snip-721": {
    attributes: {
      fungible: false
    }
  },
  "snip-722": {
    extends: "snip-721",
    attributes: {
      fungible: false
    }
  }
};
const Entities = create_store_class({
  store: SI_STORE_ENTITIES,
  class: class EntitiesI extends WritableStoreDict {
    static pathFrom(g_entity, g_chain = yw_chain.get()) {
      return `${Chains.pathFrom(g_chain)}/bech32.${g_entity.bech32}`;
    }
    static parseEntityPath(p_entity) {
      const a_paths = p_entity.slice(1).split("/");
      if (a_paths.length < 3)
        return null;
      if (!a_paths[0].startsWith("family.") || !a_paths[1].startsWith("chain.") || !a_paths[2].startsWith("bech32.")) {
        return null;
      }
      let si_type;
      let si_coin = "";
      if ("as.contract" === a_paths[3]) {
        si_type = "contract";
      } else if ("as.token" === a_paths[3]) {
        si_type = "token";
      } else if (a_paths[3].startsWith("holding.")) {
        si_type = "holding";
        si_coin = a_paths[3].slice(a_paths[3].indexOf(".") + 1);
      } else {
        return null;
      }
      const p_chain = "/" + a_paths.slice(0, 2).join("/");
      return {
        chainRef: p_chain,
        entityRef: `${p_chain}/${a_paths[3]}`,
        bech32: a_paths[2].slice(a_paths[2].indexOf(".") + 1),
        type: si_type,
        ...si_coin && {
          coin: si_coin
        }
      };
    }
    static holdingPathFor(sa_owner, si_coin, p_chain = yw_chain_ref.get()) {
      return `${p_chain}/bech32.${sa_owner}/holding.${si_coin}`;
    }
    static async readTokens(g_chain, h_interfaces = null) {
      const ks_res = await Entities.read();
      return ks_res.tokens(Chains.pathFrom(g_chain), h_interfaces);
    }
    static async readFungibleTokens(g_chain) {
      const ks_res = await Entities.read();
      const h_interfaces = fold(
        g_chain.tokenInterfaces,
        (si_key) => TokenRegistry[si_key].attributes.fungible ? { [si_key]: {} } : {}
      );
      return ks_res.tokens(Chains.pathFrom(g_chain), h_interfaces);
    }
    static fungibleInterfacesFor(g_chain) {
      return fold(
        g_chain.tokenInterfaces,
        (si_key) => TokenRegistry[si_key].attributes.fungible ? { [si_key]: {} } : {}
      );
    }
    static async infoForToken(g_token) {
    }
    filteredMap(f_map) {
      const h_cache = this._w_cache;
      const h_out = {};
      for (const p_res in h_cache) {
        const w_out = f_map(p_res, h_cache[p_res]);
        if (w_out) {
          h_out[p_res] = w_out;
        }
      }
      return h_out;
    }
    every(f_every) {
      const h_cache = this._w_cache;
      for (const p_res in h_cache) {
        if (!f_every(p_res, h_cache[p_res])) {
          return false;
        }
      }
      return true;
    }
    tokens(p_prefix, h_interfaces = null) {
      const h_outs = {};
      this.every((p_res, g_entity) => {
        let g_contract;
        if (p_res.startsWith(p_prefix) && (g_contract = g_entity["as.contract"])) {
          for (const si_interface in g_contract) {
            if (!si_interface.startsWith("token."))
              continue;
            const si_interface_token = si_interface.slice("token.".length);
            if (!h_interfaces || si_interface_token in h_interfaces) {
              h_outs[si_interface_token][p_res] = g_contract[si_interface];
            }
          }
        }
        return true;
      });
      return h_outs;
    }
  }
});
const QueryCache = create_store_class({
  store: SI_STORE_QUERY_CACHE,
  extension: "map",
  class: class QueryCacheI extends WritableStoreMap {
    async set(p_query, g_result) {
      this._w_cache[p_query] = g_result;
      await this.save();
    }
  }
});
var grpcWebClient_umd$1 = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return e = { 418: function(e2, t2) {
      !function(e3, t3) {
        for (var r in t3)
          e3[r] = t3[r];
      }(t2, function(e3) {
        var t3 = {};
        function r(n) {
          if (t3[n])
            return t3[n].exports;
          var o = t3[n] = { i: n, l: false, exports: {} };
          return e3[n].call(o.exports, o, o.exports, r), o.l = true, o.exports;
        }
        return r.m = e3, r.c = t3, r.i = function(e4) {
          return e4;
        }, r.d = function(e4, t4, n) {
          r.o(e4, t4) || Object.defineProperty(e4, t4, { configurable: false, enumerable: true, get: n });
        }, r.n = function(e4) {
          var t4 = e4 && e4.__esModule ? function() {
            return e4.default;
          } : function() {
            return e4;
          };
          return r.d(t4, "a", t4), t4;
        }, r.o = function(e4, t4) {
          return Object.prototype.hasOwnProperty.call(e4, t4);
        }, r.p = "", r(r.s = 1);
      }([function(e3, t3, r) {
        Object.defineProperty(t3, "__esModule", { value: true });
        var n = r(3), o = function() {
          function e4(e5, t4) {
            void 0 === e5 && (e5 = {}), void 0 === t4 && (t4 = { splitValues: false });
            var r2, o2 = this;
            this.headersMap = {}, e5 && ("undefined" != typeof Headers && e5 instanceof Headers ? n.getHeaderKeys(e5).forEach(function(r3) {
              n.getHeaderValues(e5, r3).forEach(function(e6) {
                t4.splitValues ? o2.append(r3, n.splitHeaderValue(e6)) : o2.append(r3, e6);
              });
            }) : "object" == typeof (r2 = e5) && "object" == typeof r2.headersMap && "function" == typeof r2.forEach ? e5.forEach(function(e6, t5) {
              o2.append(e6, t5);
            }) : "undefined" != typeof Map && e5 instanceof Map ? e5.forEach(function(e6, t5) {
              o2.append(t5, e6);
            }) : "string" == typeof e5 ? this.appendFromString(e5) : "object" == typeof e5 && Object.getOwnPropertyNames(e5).forEach(function(t5) {
              var r3 = e5[t5];
              Array.isArray(r3) ? r3.forEach(function(e6) {
                o2.append(t5, e6);
              }) : o2.append(t5, r3);
            }));
          }
          return e4.prototype.appendFromString = function(e5) {
            for (var t4 = e5.split("\r\n"), r2 = 0; r2 < t4.length; r2++) {
              var n2 = t4[r2], o2 = n2.indexOf(":");
              if (o2 > 0) {
                var s = n2.substring(0, o2).trim(), i = n2.substring(o2 + 1).trim();
                this.append(s, i);
              }
            }
          }, e4.prototype.delete = function(e5, t4) {
            var r2 = n.normalizeName(e5);
            if (void 0 === t4)
              delete this.headersMap[r2];
            else {
              var o2 = this.headersMap[r2];
              if (o2) {
                var s = o2.indexOf(t4);
                s >= 0 && o2.splice(s, 1), 0 === o2.length && delete this.headersMap[r2];
              }
            }
          }, e4.prototype.append = function(e5, t4) {
            var r2 = this, o2 = n.normalizeName(e5);
            Array.isArray(this.headersMap[o2]) || (this.headersMap[o2] = []), Array.isArray(t4) ? t4.forEach(function(e6) {
              r2.headersMap[o2].push(n.normalizeValue(e6));
            }) : this.headersMap[o2].push(n.normalizeValue(t4));
          }, e4.prototype.set = function(e5, t4) {
            var r2 = n.normalizeName(e5);
            if (Array.isArray(t4)) {
              var o2 = [];
              t4.forEach(function(e6) {
                o2.push(n.normalizeValue(e6));
              }), this.headersMap[r2] = o2;
            } else
              this.headersMap[r2] = [n.normalizeValue(t4)];
          }, e4.prototype.has = function(e5, t4) {
            var r2 = this.headersMap[n.normalizeName(e5)];
            if (!Array.isArray(r2))
              return false;
            if (void 0 !== t4) {
              var o2 = n.normalizeValue(t4);
              return r2.indexOf(o2) >= 0;
            }
            return true;
          }, e4.prototype.get = function(e5) {
            var t4 = this.headersMap[n.normalizeName(e5)];
            return void 0 !== t4 ? t4.concat() : [];
          }, e4.prototype.forEach = function(e5) {
            var t4 = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(r2) {
              e5(r2, t4.headersMap[r2]);
            }, this);
          }, e4.prototype.toHeaders = function() {
            if ("undefined" != typeof Headers) {
              var e5 = new Headers();
              return this.forEach(function(t4, r2) {
                r2.forEach(function(r3) {
                  e5.append(t4, r3);
                });
              }), e5;
            }
            throw new Error("Headers class is not defined");
          }, e4;
        }();
        t3.BrowserHeaders = o;
      }, function(e3, t3, r) {
        Object.defineProperty(t3, "__esModule", { value: true });
        var n = r(0);
        t3.BrowserHeaders = n.BrowserHeaders;
      }, function(e3, t3, r) {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.iterateHeaders = function(e4, t4) {
          for (var r2 = e4[Symbol.iterator](), n = r2.next(); !n.done; )
            t4(n.value[0]), n = r2.next();
        }, t3.iterateHeadersKeys = function(e4, t4) {
          for (var r2 = e4.keys(), n = r2.next(); !n.done; )
            t4(n.value), n = r2.next();
        };
      }, function(e3, t3, r) {
        Object.defineProperty(t3, "__esModule", { value: true });
        var n = r(2);
        t3.normalizeName = function(e4) {
          if ("string" != typeof e4 && (e4 = String(e4)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e4))
            throw new TypeError("Invalid character in header field name");
          return e4.toLowerCase();
        }, t3.normalizeValue = function(e4) {
          return "string" != typeof e4 && (e4 = String(e4)), e4;
        }, t3.getHeaderValues = function(e4, t4) {
          var r2 = e4;
          if (r2 instanceof Headers && r2.getAll)
            return r2.getAll(t4);
          var n2 = r2.get(t4);
          return n2 && "string" == typeof n2 ? [n2] : n2;
        }, t3.getHeaderKeys = function(e4) {
          var t4 = e4, r2 = {}, o = [];
          return t4.keys ? n.iterateHeadersKeys(t4, function(e5) {
            r2[e5] || (r2[e5] = true, o.push(e5));
          }) : t4.forEach ? t4.forEach(function(e5, t5) {
            r2[t5] || (r2[t5] = true, o.push(t5));
          }) : n.iterateHeaders(t4, function(e5) {
            var t5 = e5[0];
            r2[t5] || (r2[t5] = true, o.push(t5));
          }), o;
        }, t3.splitHeaderValue = function(e4) {
          var t4 = [];
          return e4.split(", ").forEach(function(e5) {
            e5.split(",").forEach(function(e6) {
              t4.push(e6);
            });
          }), t4;
        };
      }]));
    }, 617: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ChunkParser = t2.ChunkType = t2.encodeASCII = t2.decodeASCII = void 0;
      var n, o = r(65);
      function s(e3) {
        return 9 === (t3 = e3) || 10 === t3 || 13 === t3 || e3 >= 32 && e3 <= 126;
        var t3;
      }
      function i(e3) {
        for (var t3 = 0; t3 !== e3.length; ++t3)
          if (!s(e3[t3]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(e3));
      }
      function a(e3) {
        return 128 == (128 & e3.getUint8(0));
      }
      function u(e3) {
        return e3.getUint32(1, false);
      }
      function d(e3, t3, r2) {
        return e3.byteLength - t3 >= r2;
      }
      function c(e3, t3, r2) {
        if (e3.slice)
          return e3.slice(t3, r2);
        var n2 = e3.length;
        void 0 !== r2 && (n2 = r2);
        for (var o2 = new Uint8Array(n2 - t3), s2 = 0, i2 = t3; i2 < n2; i2++)
          o2[s2++] = e3[i2];
        return o2;
      }
      t2.decodeASCII = i, t2.encodeASCII = function(e3) {
        for (var t3 = new Uint8Array(e3.length), r2 = 0; r2 !== e3.length; ++r2) {
          var n2 = e3.charCodeAt(r2);
          if (!s(n2))
            throw new Error("Metadata contains invalid ASCII");
          t3[r2] = n2;
        }
        return t3;
      }, function(e3) {
        e3[e3.MESSAGE = 1] = "MESSAGE", e3[e3.TRAILERS = 2] = "TRAILERS";
      }(n = t2.ChunkType || (t2.ChunkType = {}));
      var p2 = function() {
        function e3() {
          this.buffer = null, this.position = 0;
        }
        return e3.prototype.parse = function(e4, t3) {
          if (0 === e4.length && t3)
            return [];
          var r2, s2 = [];
          if (null == this.buffer)
            this.buffer = e4, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = e4, this.position = 0;
          else {
            var p3 = this.buffer.byteLength - this.position, h = new Uint8Array(p3 + e4.byteLength), f = c(this.buffer, this.position);
            h.set(f, 0);
            var l = new Uint8Array(e4);
            h.set(l, p3), this.buffer = h, this.position = 0;
          }
          for (; ; ) {
            if (!d(this.buffer, this.position, 5))
              return s2;
            var g = c(this.buffer, this.position, this.position + 5), b = new DataView(g.buffer, g.byteOffset, g.byteLength), y = u(b);
            if (!d(this.buffer, this.position, 5 + y))
              return s2;
            var v = c(this.buffer, this.position + 5, this.position + 5 + y);
            if (this.position += 5 + y, a(b))
              return s2.push({ chunkType: n.TRAILERS, trailers: (r2 = v, new o.Metadata(i(r2))) }), s2;
            s2.push({ chunkType: n.MESSAGE, data: v });
          }
        }, e3;
      }();
      t2.ChunkParser = p2;
    }, 8: function(e2, t2) {
      var r;
      Object.defineProperty(t2, "__esModule", { value: true }), t2.httpStatusToCode = t2.Code = void 0, function(e3) {
        e3[e3.OK = 0] = "OK", e3[e3.Canceled = 1] = "Canceled", e3[e3.Unknown = 2] = "Unknown", e3[e3.InvalidArgument = 3] = "InvalidArgument", e3[e3.DeadlineExceeded = 4] = "DeadlineExceeded", e3[e3.NotFound = 5] = "NotFound", e3[e3.AlreadyExists = 6] = "AlreadyExists", e3[e3.PermissionDenied = 7] = "PermissionDenied", e3[e3.ResourceExhausted = 8] = "ResourceExhausted", e3[e3.FailedPrecondition = 9] = "FailedPrecondition", e3[e3.Aborted = 10] = "Aborted", e3[e3.OutOfRange = 11] = "OutOfRange", e3[e3.Unimplemented = 12] = "Unimplemented", e3[e3.Internal = 13] = "Internal", e3[e3.Unavailable = 14] = "Unavailable", e3[e3.DataLoss = 15] = "DataLoss", e3[e3.Unauthenticated = 16] = "Unauthenticated";
      }(r = t2.Code || (t2.Code = {})), t2.httpStatusToCode = function(e3) {
        switch (e3) {
          case 0:
            return r.Internal;
          case 200:
            return r.OK;
          case 400:
            return r.InvalidArgument;
          case 401:
            return r.Unauthenticated;
          case 403:
            return r.PermissionDenied;
          case 404:
            return r.NotFound;
          case 409:
            return r.Aborted;
          case 412:
            return r.FailedPrecondition;
          case 429:
            return r.ResourceExhausted;
          case 499:
            return r.Canceled;
          case 500:
            return r.Unknown;
          case 501:
            return r.Unimplemented;
          case 503:
            return r.Unavailable;
          case 504:
            return r.DeadlineExceeded;
          default:
            return r.Unknown;
        }
      };
    }, 934: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.client = void 0;
      var n = r(65), o = r(617), s = r(8), i = r(346), a = r(57), u = r(882);
      t2.client = function(e3, t3) {
        return new d(e3, t3);
      };
      var d = function() {
        function e3(e4, t3) {
          this.started = false, this.sentFirstMessage = false, this.completed = false, this.closed = false, this.finishedSending = false, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new o.ChunkParser(), this.methodDefinition = e4, this.props = t3, this.createTransport();
        }
        return e3.prototype.createTransport = function() {
          var e4 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, t3 = { methodDefinition: this.methodDefinition, debug: this.props.debug || false, url: e4, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(t3) : this.transport = a.makeDefaultTransport(t3);
        }, e3.prototype.onTransportHeaders = function(e4, t3) {
          if (this.props.debug && i.debug("onHeaders", e4, t3), this.closed)
            this.props.debug && i.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (0 === t3)
            ;
          else {
            this.responseHeaders = e4, this.props.debug && i.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var r2 = c(e4);
            this.props.debug && i.debug("onHeaders.gRPCStatus", r2);
            var n2 = r2 && r2 >= 0 ? r2 : s.httpStatusToCode(t3);
            this.props.debug && i.debug("onHeaders.code", n2);
            var o2 = e4.get("grpc-message") || [];
            if (this.props.debug && i.debug("onHeaders.gRPCMessage", o2), this.rawOnHeaders(e4), n2 !== s.Code.OK) {
              var a2 = this.decodeGRPCStatus(o2[0]);
              this.rawOnError(n2, a2, e4);
            }
          }
        }, e3.prototype.onTransportChunk = function(e4) {
          var t3 = this;
          if (this.closed)
            this.props.debug && i.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var r2 = [];
            try {
              r2 = this.parser.parse(e4);
            } catch (e5) {
              return this.props.debug && i.debug("onChunk.parsing error", e5, e5.message), void this.rawOnError(s.Code.Internal, "parsing error: " + e5.message);
            }
            r2.forEach(function(e5) {
              if (e5.chunkType === o.ChunkType.MESSAGE) {
                var r3 = t3.methodDefinition.responseType.deserializeBinary(e5.data);
                t3.rawOnMessage(r3);
              } else
                e5.chunkType === o.ChunkType.TRAILERS && (t3.responseHeaders ? (t3.responseTrailers = new n.Metadata(e5.trailers), t3.props.debug && i.debug("onChunk.trailers", t3.responseTrailers)) : (t3.responseHeaders = new n.Metadata(e5.trailers), t3.rawOnHeaders(t3.responseHeaders)));
            });
          }
        }, e3.prototype.onTransportEnd = function() {
          if (this.props.debug && i.debug("grpc.onEnd"), this.closed)
            this.props.debug && i.debug("grpc.onEnd received after request was closed - ignoring");
          else if (void 0 !== this.responseTrailers) {
            var e4 = c(this.responseTrailers);
            if (null !== e4) {
              var t3 = this.responseTrailers.get("grpc-message"), r2 = this.decodeGRPCStatus(t3[0]);
              this.rawOnEnd(e4, r2, this.responseTrailers);
            } else
              this.rawOnError(s.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (void 0 === this.responseHeaders)
              return void this.rawOnError(s.Code.Unknown, "Response closed without headers");
            var n2 = c(this.responseHeaders), o2 = this.responseHeaders.get("grpc-message");
            if (this.props.debug && i.debug("grpc.headers only response ", n2, o2), null === n2)
              return void this.rawOnEnd(s.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var a2 = this.decodeGRPCStatus(o2[0]);
            this.rawOnEnd(n2, a2, this.responseHeaders);
          }
        }, e3.prototype.decodeGRPCStatus = function(e4) {
          if (!e4)
            return "";
          try {
            return decodeURIComponent(e4);
          } catch (t3) {
            return e4;
          }
        }, e3.prototype.rawOnEnd = function(e4, t3, r2) {
          var n2 = this;
          this.props.debug && i.debug("rawOnEnd", e4, t3, r2), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(o2) {
            if (!n2.closed)
              try {
                o2(e4, t3, r2);
              } catch (e5) {
                setTimeout(function() {
                  throw e5;
                }, 0);
              }
          }));
        }, e3.prototype.rawOnHeaders = function(e4) {
          this.props.debug && i.debug("rawOnHeaders", e4), this.completed || this.onHeadersCallbacks.forEach(function(t3) {
            try {
              t3(e4);
            } catch (e5) {
              setTimeout(function() {
                throw e5;
              }, 0);
            }
          });
        }, e3.prototype.rawOnError = function(e4, t3, r2) {
          var o2 = this;
          void 0 === r2 && (r2 = new n.Metadata()), this.props.debug && i.debug("rawOnError", e4, t3), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(n2) {
            if (!o2.closed)
              try {
                n2(e4, t3, r2);
              } catch (e5) {
                setTimeout(function() {
                  throw e5;
                }, 0);
              }
          }));
        }, e3.prototype.rawOnMessage = function(e4) {
          var t3 = this;
          this.props.debug && i.debug("rawOnMessage", e4.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(r2) {
            if (!t3.closed)
              try {
                r2(e4);
              } catch (e5) {
                setTimeout(function() {
                  throw e5;
                }, 0);
              }
          });
        }, e3.prototype.onHeaders = function(e4) {
          this.onHeadersCallbacks.push(e4);
        }, e3.prototype.onMessage = function(e4) {
          this.onMessageCallbacks.push(e4);
        }, e3.prototype.onEnd = function(e4) {
          this.onEndCallbacks.push(e4);
        }, e3.prototype.start = function(e4) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = true;
          var t3 = new n.Metadata(e4 || {});
          t3.set("content-type", "application/grpc-web+proto"), t3.set("x-grpc-web", "1"), this.transport.start(t3);
        }, e3.prototype.send = function(e4) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = true;
          var t3 = u.frameRequest(e4);
          this.transport.sendMessage(t3);
        }, e3.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = true, this.transport.finishSend();
        }, e3.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = true, this.props.debug && i.debug("request.abort aborting request"), this.transport.cancel();
        }, e3;
      }();
      function c(e3) {
        var t3 = e3.get("grpc-status") || [];
        if (t3.length > 0)
          try {
            var r2 = t3[0];
            return parseInt(r2, 10);
          } catch (e4) {
            return null;
          }
        return null;
      }
    }, 346: function(e2, t2) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.debug = void 0, t2.debug = function() {
        for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
          e3[t3] = arguments[t3];
        console.debug ? console.debug.apply(null, e3) : console.log.apply(null, e3);
      };
    }, 607: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.grpc = void 0;
      var n, o = r(418), s = r(57), i = r(229), a = r(540), u = r(210), d = r(859), c = r(8), p2 = r(938), h = r(35), f = r(934);
      (n = t2.grpc || (t2.grpc = {})).setDefaultTransport = s.setDefaultTransportFactory, n.CrossBrowserHttpTransport = d.CrossBrowserHttpTransport, n.FetchReadableStreamTransport = i.FetchReadableStreamTransport, n.XhrTransport = u.XhrTransport, n.WebsocketTransport = a.WebsocketTransport, n.Code = c.Code, n.Metadata = o.BrowserHeaders, n.client = function(e3, t3) {
        return f.client(e3, t3);
      }, n.invoke = p2.invoke, n.unary = h.unary;
    }, 938: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.invoke = void 0;
      var n = r(934);
      t2.invoke = function(e3, t3) {
        if (e3.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var r2 = n.client(e3, { host: t3.host, transport: t3.transport, debug: t3.debug });
        return t3.onHeaders && r2.onHeaders(t3.onHeaders), t3.onMessage && r2.onMessage(t3.onMessage), t3.onEnd && r2.onEnd(t3.onEnd), r2.start(t3.metadata), r2.send(t3.request), r2.finishSend(), { close: function() {
          r2.close();
        } };
      };
    }, 65: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Metadata = void 0;
      var n = r(418);
      Object.defineProperty(t2, "Metadata", { enumerable: true, get: function() {
        return n.BrowserHeaders;
      } });
    }, 57: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.makeDefaultTransport = t2.setDefaultTransportFactory = void 0;
      var n = r(859), o = function(e3) {
        return n.CrossBrowserHttpTransport({ withCredentials: false })(e3);
      };
      t2.setDefaultTransportFactory = function(e3) {
        o = e3;
      }, t2.makeDefaultTransport = function(e3) {
        return o(e3);
      };
    }, 229: function(e2, t2, r) {
      var n = this && this.__assign || function() {
        return (n = Object.assign || function(e3) {
          for (var t3, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
            for (var o2 in t3 = arguments[r2])
              Object.prototype.hasOwnProperty.call(t3, o2) && (e3[o2] = t3[o2]);
          return e3;
        }).apply(this, arguments);
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.detectFetchSupport = t2.FetchReadableStreamTransport = void 0;
      var o = r(65), s = r(346);
      t2.FetchReadableStreamTransport = function(e3) {
        return function(t3) {
          return function(e4, t4) {
            return e4.debug && s.debug("fetchRequest", e4), new i(e4, t4);
          }(t3, e3);
        };
      };
      var i = function() {
        function e3(e4, t3) {
          this.cancelled = false, this.controller = self.AbortController && new AbortController(), this.options = e4, this.init = t3;
        }
        return e3.prototype.pump = function(e4, t3) {
          var r2 = this;
          if (this.reader = e4, this.cancelled)
            return this.options.debug && s.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(e5) {
              r2.options.debug && s.debug("Fetch.pump.reader.cancel exception", e5);
            });
          this.reader.read().then(function(e5) {
            if (e5.done)
              return r2.options.onEnd(), t3;
            r2.options.onChunk(e5.value), r2.pump(r2.reader, t3);
          }).catch(function(e5) {
            r2.cancelled ? r2.options.debug && s.debug("Fetch.catch - request cancelled") : (r2.cancelled = true, r2.options.debug && s.debug("Fetch.catch", e5.message), r2.options.onEnd(e5));
          });
        }, e3.prototype.send = function(e4) {
          var t3 = this;
          fetch(this.options.url, n(n({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: e4, signal: this.controller && this.controller.signal })).then(function(e5) {
            if (t3.options.debug && s.debug("Fetch.response", e5), t3.options.onHeaders(new o.Metadata(e5.headers), e5.status), !e5.body)
              return e5;
            t3.pump(e5.body.getReader(), e5);
          }).catch(function(e5) {
            t3.cancelled ? t3.options.debug && s.debug("Fetch.catch - request cancelled") : (t3.cancelled = true, t3.options.debug && s.debug("Fetch.catch", e5.message), t3.options.onEnd(e5));
          });
        }, e3.prototype.sendMessage = function(e4) {
          this.send(e4);
        }, e3.prototype.finishSend = function() {
        }, e3.prototype.start = function(e4) {
          this.metadata = e4;
        }, e3.prototype.cancel = function() {
          var e4 = this;
          this.cancelled ? this.options.debug && s.debug("Fetch.cancel already cancelled") : (this.cancelled = true, this.controller ? (this.options.debug && s.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && s.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && s.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(t3) {
            e4.options.debug && s.debug("Fetch.cancel.reader.cancel exception", t3);
          })) : this.options.debug && s.debug("Fetch.cancel before reader"));
        }, e3;
      }();
      t2.detectFetchSupport = function() {
        return "undefined" != typeof Response && Response.prototype.hasOwnProperty("body") && "function" == typeof Headers;
      };
    }, 859: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CrossBrowserHttpTransport = void 0;
      var n = r(229), o = r(210);
      t2.CrossBrowserHttpTransport = function(e3) {
        if (n.detectFetchSupport()) {
          var t3 = { credentials: e3.withCredentials ? "include" : "same-origin" };
          return n.FetchReadableStreamTransport(t3);
        }
        return o.XhrTransport({ withCredentials: e3.withCredentials });
      };
    }, 210: function(e2, t2, r) {
      var n, o = this && this.__extends || (n = function(e3, t3) {
        return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
          e4.__proto__ = t4;
        } || function(e4, t4) {
          for (var r2 in t4)
            Object.prototype.hasOwnProperty.call(t4, r2) && (e4[r2] = t4[r2]);
        })(e3, t3);
      }, function(e3, t3) {
        function r2() {
          this.constructor = e3;
        }
        n(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (r2.prototype = t3.prototype, new r2());
      });
      Object.defineProperty(t2, "__esModule", { value: true }), t2.stringToArrayBuffer = t2.MozChunkedArrayBufferXHR = t2.XHR = t2.XhrTransport = void 0;
      var s = r(65), i = r(346), a = r(849);
      t2.XhrTransport = function(e3) {
        return function(t3) {
          if (a.detectMozXHRSupport())
            return new d(t3, e3);
          if (a.detectXHROverrideMimeTypeSupport())
            return new u(t3, e3);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var u = function() {
        function e3(e4, t3) {
          this.options = e4, this.init = t3;
        }
        return e3.prototype.onProgressEvent = function() {
          this.options.debug && i.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var e4 = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var t3 = p2(e4);
          this.options.onChunk(t3);
        }, e3.prototype.onLoadEvent = function() {
          this.options.debug && i.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, e3.prototype.onStateChange = function() {
          this.options.debug && i.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new s.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, e3.prototype.sendMessage = function(e4) {
          this.xhr.send(e4);
        }, e3.prototype.finishSend = function() {
        }, e3.prototype.start = function(e4) {
          var t3 = this;
          this.metadata = e4;
          var r2 = new XMLHttpRequest();
          this.xhr = r2, r2.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(e5, t4) {
            r2.setRequestHeader(e5, t4.join(", "));
          }), r2.withCredentials = Boolean(this.init.withCredentials), r2.addEventListener("readystatechange", this.onStateChange.bind(this)), r2.addEventListener("progress", this.onProgressEvent.bind(this)), r2.addEventListener("loadend", this.onLoadEvent.bind(this)), r2.addEventListener("error", function(e5) {
            t3.options.debug && i.debug("XHR.error", e5), t3.options.onEnd(e5.error);
          });
        }, e3.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, e3.prototype.cancel = function() {
          this.options.debug && i.debug("XHR.abort"), this.xhr.abort();
        }, e3;
      }();
      t2.XHR = u;
      var d = function(e3) {
        function t3() {
          return null !== e3 && e3.apply(this, arguments) || this;
        }
        return o(t3, e3), t3.prototype.configureXhr = function() {
          this.options.debug && i.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, t3.prototype.onProgressEvent = function() {
          var e4 = this.xhr.response;
          this.options.debug && i.debug("MozXHR.onProgressEvent: ", new Uint8Array(e4)), this.options.onChunk(new Uint8Array(e4));
        }, t3;
      }(u);
      function c(e3, t3) {
        var r2 = e3.charCodeAt(t3);
        if (r2 >= 55296 && r2 <= 56319) {
          var n2 = e3.charCodeAt(t3 + 1);
          n2 >= 56320 && n2 <= 57343 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320));
        }
        return r2;
      }
      function p2(e3) {
        for (var t3 = new Uint8Array(e3.length), r2 = 0, n2 = 0; n2 < e3.length; n2++) {
          var o2 = String.prototype.codePointAt ? e3.codePointAt(n2) : c(e3, n2);
          t3[r2++] = 255 & o2;
        }
        return t3;
      }
      t2.MozChunkedArrayBufferXHR = d, t2.stringToArrayBuffer = p2;
    }, 849: function(e2, t2) {
      var r;
      function n() {
        if (void 0 !== r)
          return r;
        if (XMLHttpRequest) {
          r = new XMLHttpRequest();
          try {
            r.open("GET", "https://localhost");
          } catch (e3) {
          }
        }
        return r;
      }
      function o(e3) {
        var t3 = n();
        if (!t3)
          return false;
        try {
          return t3.responseType = e3, t3.responseType === e3;
        } catch (e4) {
        }
        return false;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.detectXHROverrideMimeTypeSupport = t2.detectMozXHRSupport = t2.xhrSupportsResponseType = void 0, t2.xhrSupportsResponseType = o, t2.detectMozXHRSupport = function() {
        return "undefined" != typeof XMLHttpRequest && o("moz-chunked-arraybuffer");
      }, t2.detectXHROverrideMimeTypeSupport = function() {
        return "undefined" != typeof XMLHttpRequest && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.WebsocketTransport = void 0;
      var n, o = r(346), s = r(617);
      !function(e3) {
        e3[e3.FINISH_SEND = 1] = "FINISH_SEND";
      }(n || (n = {}));
      var i = new Uint8Array([1]);
      t2.WebsocketTransport = function() {
        return function(e3) {
          return function(e4) {
            e4.debug && o.debug("websocketRequest", e4);
            var t3, r2 = function(e5) {
              if ("https://" === e5.substr(0, 8))
                return "wss://" + e5.substr(8);
              if ("http://" === e5.substr(0, 7))
                return "ws://" + e5.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(e4.url), a = [];
            function u(e5) {
              if (e5 === n.FINISH_SEND)
                t3.send(i);
              else {
                var r3 = e5, o2 = new Int8Array(r3.byteLength + 1);
                o2.set(new Uint8Array([0])), o2.set(r3, 1), t3.send(o2);
              }
            }
            return { sendMessage: function(e5) {
              t3 && t3.readyState !== t3.CONNECTING ? u(e5) : a.push(e5);
            }, finishSend: function() {
              t3 && t3.readyState !== t3.CONNECTING ? u(n.FINISH_SEND) : a.push(n.FINISH_SEND);
            }, start: function(n2) {
              (t3 = new WebSocket(r2, ["grpc-websockets"])).binaryType = "arraybuffer", t3.onopen = function() {
                var r3;
                e4.debug && o.debug("websocketRequest.onopen"), t3.send((r3 = "", n2.forEach(function(e5, t4) {
                  r3 += e5 + ": " + t4.join(", ") + "\r\n";
                }), s.encodeASCII(r3))), a.forEach(function(e5) {
                  u(e5);
                });
              }, t3.onclose = function(t4) {
                e4.debug && o.debug("websocketRequest.onclose", t4), e4.onEnd();
              }, t3.onerror = function(t4) {
                e4.debug && o.debug("websocketRequest.onerror", t4);
              }, t3.onmessage = function(t4) {
                e4.onChunk(new Uint8Array(t4.data));
              };
            }, cancel: function() {
              e4.debug && o.debug("websocket.abort"), t3.close();
            } };
          }(e3);
        };
      };
    }, 35: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.unary = void 0;
      var n = r(65), o = r(934);
      t2.unary = function(e3, t3) {
        if (e3.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if (e3.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var r2 = null, s = null, i = o.client(e3, { host: t3.host, transport: t3.transport, debug: t3.debug });
        return i.onHeaders(function(e4) {
          r2 = e4;
        }), i.onMessage(function(e4) {
          s = e4;
        }), i.onEnd(function(e4, o2, i2) {
          t3.onEnd({ status: e4, statusMessage: o2, headers: r2 || new n.Metadata(), message: s, trailers: i2 });
        }), i.start(t3.metadata), i.send(t3.request), i.finishSend(), { close: function() {
          i.close();
        } };
      };
    }, 882: function(e2, t2) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.frameRequest = void 0, t2.frameRequest = function(e3) {
        var t3 = e3.serializeBinary(), r = new ArrayBuffer(t3.byteLength + 5);
        return new DataView(r, 1, 4).setUint32(0, t3.length, false), new Uint8Array(r, 5).set(t3), new Uint8Array(r);
      };
    } }, t = {}, function r(n) {
      if (t[n])
        return t[n].exports;
      var o = t[n] = { exports: {} };
      return e[n].call(o.exports, o, o.exports, r), o.exports;
    }(607);
    var e, t;
  });
})(grpcWebClient_umd$1);
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _3n = BigInt(3);
const _8n = BigInt(8);
const POW_2_256 = _2n ** BigInt(256);
const CURVE = {
  a: _0n,
  b: BigInt(7),
  P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),
  n: POW_2_256 - BigInt("432420386565659656852420866394968145599"),
  h: _1n,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
};
function weistrass(x) {
  const { a, b } = CURVE;
  const x2 = mod(x * x);
  const x3 = mod(x2 * x);
  return mod(x3 + a * x + b);
}
const USE_ENDOMORPHISM = CURVE.a === _0n;
class JacobianPoint {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  static fromAffine(p2) {
    if (!(p2 instanceof Point)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    return new JacobianPoint(p2.x, p2.y, _1n);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p2) => p2.z));
    return points.map((p2, i) => p2.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
  }
  equals(other) {
    if (!(other instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod(Z1 ** _2n);
    const Z2Z2 = mod(Z2 ** _2n);
    const U1 = mod(X1 * Z2Z2);
    const U2 = mod(X2 * Z1Z1);
    const S1 = mod(mod(Y1 * Z2) * Z2Z2);
    const S2 = mod(mod(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new JacobianPoint(this.x, mod(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod(X1 ** _2n);
    const B = mod(Y1 ** _2n);
    const C = mod(B ** _2n);
    const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));
    const E = mod(_3n * A);
    const F = mod(E ** _2n);
    const X3 = mod(F - _2n * D);
    const Y3 = mod(E * (D - X3) - _8n * C);
    const Z3 = mod(_2n * Y1 * Z1);
    return new JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    if (!(other instanceof JacobianPoint))
      throw new TypeError("JacobianPoint expected");
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n || Y2 === _0n)
      return this;
    if (X1 === _0n || Y1 === _0n)
      return other;
    const Z1Z1 = mod(Z1 ** _2n);
    const Z2Z2 = mod(Z2 ** _2n);
    const U1 = mod(X1 * Z2Z2);
    const U2 = mod(X2 * Z1Z1);
    const S1 = mod(mod(Y1 * Z2) * Z2Z2);
    const S2 = mod(mod(Y2 * Z1) * Z1Z1);
    const H = mod(U2 - U1);
    const r = mod(S2 - S1);
    if (H === _0n) {
      if (r === _0n) {
        return this.double();
      } else {
        return JacobianPoint.ZERO;
      }
    }
    const HH = mod(H ** _2n);
    const HHH = mod(H * HH);
    const V = mod(U1 * HH);
    const X3 = mod(r ** _2n - HHH - _2n * V);
    const Y3 = mod(r * (V - X3) - S1 * HHH);
    const Z3 = mod(Z1 * Z2 * H);
    return new JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n)
      return P0;
    let n = normalizeScalar(scalar);
    if (n === _1n)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p2 = P0;
      let d2 = this;
      while (n > _0n) {
        if (n & _1n)
          p2 = p2.add(d2);
        d2 = d2.double();
        n >>= _1n;
      }
      return p2;
    }
    let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
    let k1p = P0;
    let k2p = P0;
    let d = this;
    while (k1 > _0n || k2 > _0n) {
      if (k1 & _1n)
        k1p = k1p.add(d);
      if (k2 & _1n)
        k2p = k2p.add(d);
      d = d.double();
      k1 >>= _1n;
      k2 >>= _1n;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W2) {
    const windows = USE_ENDOMORPHISM ? 128 / W2 + 1 : 256 / W2 + 1;
    const points = [];
    let p2 = this;
    let base = p2;
    for (let window2 = 0; window2 < windows; window2++) {
      base = p2;
      points.push(base);
      for (let i = 1; i < 2 ** (W2 - 1); i++) {
        base = base.add(p2);
        points.push(base);
      }
      p2 = base.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(JacobianPoint.BASE))
      affinePoint = Point.BASE;
    const W2 = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W2) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W2);
      if (affinePoint && W2 !== 1) {
        precomputes = JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p2 = JacobianPoint.ZERO;
    let f = JacobianPoint.ZERO;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W2 : 256 / W2);
    const windowSize = 2 ** (W2 - 1);
    const mask = BigInt(2 ** W2 - 1);
    const maxNumber = 2 ** W2;
    const shiftBy = BigInt(W2);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n;
      }
      if (wbits === 0) {
        let pr = precomputes[offset];
        if (window2 % 2)
          pr = pr.negate();
        f = f.add(pr);
      } else {
        let cached = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          cached = cached.negate();
        p2 = p2.add(cached);
      }
    }
    return { p: p2, f };
  }
  multiply(scalar, affinePoint) {
    let n = normalizeScalar(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p: p2, f } = this.wNAF(n, affinePoint);
      point = p2;
      fake = f;
    }
    return JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ = invert(this.z)) {
    const { x, y, z } = this;
    const iz1 = invZ;
    const iz2 = mod(iz1 * iz1);
    const iz3 = mod(iz2 * iz1);
    const ax = mod(x * iz2);
    const ay = mod(y * iz3);
    const zz = mod(z * iz1);
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
const pointPrecomputes = /* @__PURE__ */ new WeakMap();
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  static fromCompressedHex(bytes) {
    const isShort = bytes.length === 32;
    const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weistrass(x);
    let y = sqrtMod(y2);
    const isYOdd = (y & _1n) === _1n;
    if (isShort) {
      if (isYOdd)
        y = mod(-y);
    } else {
      const isFirstByteOdd = (bytes[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y = mod(-y);
    }
    const point = new Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes) {
    const x = bytesToNumber(bytes.subarray(1, 33));
    const y = bytesToNumber(bytes.subarray(33, 65));
    const point = new Point(x, y);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes = ensureBytes(hex);
    const len = bytes.length;
    const header = bytes[0];
    if (len === 32 || len === 33 && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes);
    }
    if (len === 65 && header === 4)
      return this.fromUncompressedHex(bytes);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return Point.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    msgHash = ensureBytes(msgHash);
    const h = truncateHash(msgHash);
    const { r, s } = normalizeSignature(signature);
    if (recovery !== 0 && recovery !== 1) {
      throw new Error("Cannot recover signature: invalid recovery bit");
    }
    const prefix = recovery & 1 ? "03" : "02";
    const R = Point.fromHex(prefix + numTo32bStr(r));
    const { n } = CURVE;
    const rinv = invert(r, n);
    const u1 = mod(-h * rinv, n);
    const u2 = mod(s * rinv, n);
    const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.y & _1n ? "03" : "02";
      return `${prefix}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y))
      throw new Error(msg);
    const left = mod(y * y);
    const right = weistrass(x);
    if (mod(left - right) !== _0n)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point(this.x, mod(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a, b) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
}
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
  return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
  }
  return { r, s };
}
class Signature {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = isUint8a(hex);
    const name = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name}: Expected 64-byte hex`);
    return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = isUint8a(hex);
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
    return new Signature(r, s);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r, s } = this;
    if (!isWithinCurveOrder(r))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE.n >> _1n;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
  }
  toDERRawBytes(isCompressed = false) {
    return hexToBytes(this.toDERHex(isCompressed));
  }
  toDERHex(isCompressed = false) {
    const sHex = sliceDER(numberToHexUnpadded(this.s));
    if (isCompressed)
      return sHex;
    const rHex = sliceDER(numberToHexUnpadded(this.r));
    const rLen = numberToHexUnpadded(rHex.length / 2);
    const sLen = numberToHexUnpadded(sHex.length / 2);
    const length2 = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
    return `30${length2}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
}
function isUint8a(bytes) {
  return bytes instanceof Uint8Array;
}
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes[uint8a[i]];
  }
  return hex;
}
function numTo32bStr(num) {
  if (num > POW_2_256)
    throw new Error("Expected number < 2^256");
  return num.toString(16).padStart(64, "0");
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumber(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod(a, b = CURVE.P) {
  const result = a % b;
  return result >= _0n ? result : b + result;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  const { P } = CURVE;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow2(b3, _3n) * b3 % P;
  const b9 = pow2(b6, _3n) * b3 % P;
  const b11 = pow2(b9, _2n) * b2 % P;
  const b22 = pow2(b11, _11n) * b11 % P;
  const b44 = pow2(b22, _22n) * b22 % P;
  const b88 = pow2(b44, _44n) * b44 % P;
  const b176 = pow2(b88, _88n) * b88 % P;
  const b220 = pow2(b176, _44n) * b44 % P;
  const b223 = pow2(b220, _3n) * b3 % P;
  const t1 = pow2(b223, _23n) * b22 % P;
  const t2 = pow2(t1, _6n) * b2 % P;
  return pow2(t2, _2n);
}
function invert(number, modulo2 = CURVE.P) {
  if (number === _0n || modulo2 <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo2}`);
  }
  let a = mod(number, modulo2);
  let b = modulo2;
  let x = _0n, u = _1n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    b = a, a = r, x = u, u = m;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod(x, modulo2);
}
function invertBatch(nums, p2 = CURVE.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n)
      return acc;
    scratch[i] = acc;
    return mod(acc * num, p2);
  }, _1n);
  const inverted = invert(lastMultiplied, p2);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n)
      return acc;
    scratch[i] = mod(acc * scratch[i], p2);
    return mod(acc * num, p2);
  }, inverted);
  return scratch;
}
const divNearest = (a, b) => (a + b / _2n) / b;
const POW_2_128 = _2n ** BigInt(128);
function splitScalarEndo(k) {
  const { n } = CURVE;
  const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
  const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
  const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
  const b2 = a1;
  const c1 = divNearest(b2 * k, n);
  const c2 = divNearest(-b1 * k, n);
  let k1 = mod(k - c1 * a1 - c2 * a2, n);
  let k2 = mod(-c1 * b1 - c2 * b2, n);
  const k1neg = k1 > POW_2_128;
  const k2neg = k2 > POW_2_128;
  if (k1neg)
    k1 = n - k1;
  if (k2neg)
    k2 = n - k2;
  if (k1 > POW_2_128 || k2 > POW_2_128) {
    throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
  }
  return { k1neg, k1, k2neg, k2 };
}
function truncateHash(hash2) {
  const { n } = CURVE;
  const byteLength = hash2.length;
  const delta = byteLength * 8 - 256;
  let h = bytesToNumber(hash2);
  if (delta > 0)
    h = h >> BigInt(delta);
  if (h >= n)
    h -= n;
  return h;
}
function isWithinCurveOrder(num) {
  return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
  return _0n < num && num < CURVE.P;
}
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 64)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber(key);
  } else if (isUint8a(key)) {
    if (key.length !== 32)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
function normalizeSignature(signature) {
  if (signature instanceof Signature) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature.fromDER(signature);
  } catch (error) {
    return Signature.fromCompact(signature);
  }
}
Point.BASE._setWindowSize(8);
var grpcWebClient_umd = { exports: {} };
(function(module, exports) {
  !function(e, t) {
    module.exports = t();
  }(commonjsGlobal, function() {
    return e = { 418: function(e2, t2) {
      !function(e3, t3) {
        for (var r in t3)
          e3[r] = t3[r];
      }(t2, function(e3) {
        var t3 = {};
        function r(n) {
          if (t3[n])
            return t3[n].exports;
          var o = t3[n] = { i: n, l: false, exports: {} };
          return e3[n].call(o.exports, o, o.exports, r), o.l = true, o.exports;
        }
        return r.m = e3, r.c = t3, r.i = function(e4) {
          return e4;
        }, r.d = function(e4, t4, n) {
          r.o(e4, t4) || Object.defineProperty(e4, t4, { configurable: false, enumerable: true, get: n });
        }, r.n = function(e4) {
          var t4 = e4 && e4.__esModule ? function() {
            return e4.default;
          } : function() {
            return e4;
          };
          return r.d(t4, "a", t4), t4;
        }, r.o = function(e4, t4) {
          return Object.prototype.hasOwnProperty.call(e4, t4);
        }, r.p = "", r(r.s = 1);
      }([function(e3, t3, r) {
        Object.defineProperty(t3, "__esModule", { value: true });
        var n = r(3), o = function() {
          function e4(e5, t4) {
            void 0 === e5 && (e5 = {}), void 0 === t4 && (t4 = { splitValues: false });
            var r2, o2 = this;
            this.headersMap = {}, e5 && ("undefined" != typeof Headers && e5 instanceof Headers ? n.getHeaderKeys(e5).forEach(function(r3) {
              n.getHeaderValues(e5, r3).forEach(function(e6) {
                t4.splitValues ? o2.append(r3, n.splitHeaderValue(e6)) : o2.append(r3, e6);
              });
            }) : "object" == typeof (r2 = e5) && "object" == typeof r2.headersMap && "function" == typeof r2.forEach ? e5.forEach(function(e6, t5) {
              o2.append(e6, t5);
            }) : "undefined" != typeof Map && e5 instanceof Map ? e5.forEach(function(e6, t5) {
              o2.append(t5, e6);
            }) : "string" == typeof e5 ? this.appendFromString(e5) : "object" == typeof e5 && Object.getOwnPropertyNames(e5).forEach(function(t5) {
              var r3 = e5[t5];
              Array.isArray(r3) ? r3.forEach(function(e6) {
                o2.append(t5, e6);
              }) : o2.append(t5, r3);
            }));
          }
          return e4.prototype.appendFromString = function(e5) {
            for (var t4 = e5.split("\r\n"), r2 = 0; r2 < t4.length; r2++) {
              var n2 = t4[r2], o2 = n2.indexOf(":");
              if (o2 > 0) {
                var s = n2.substring(0, o2).trim(), i = n2.substring(o2 + 1).trim();
                this.append(s, i);
              }
            }
          }, e4.prototype.delete = function(e5, t4) {
            var r2 = n.normalizeName(e5);
            if (void 0 === t4)
              delete this.headersMap[r2];
            else {
              var o2 = this.headersMap[r2];
              if (o2) {
                var s = o2.indexOf(t4);
                s >= 0 && o2.splice(s, 1), 0 === o2.length && delete this.headersMap[r2];
              }
            }
          }, e4.prototype.append = function(e5, t4) {
            var r2 = this, o2 = n.normalizeName(e5);
            Array.isArray(this.headersMap[o2]) || (this.headersMap[o2] = []), Array.isArray(t4) ? t4.forEach(function(e6) {
              r2.headersMap[o2].push(n.normalizeValue(e6));
            }) : this.headersMap[o2].push(n.normalizeValue(t4));
          }, e4.prototype.set = function(e5, t4) {
            var r2 = n.normalizeName(e5);
            if (Array.isArray(t4)) {
              var o2 = [];
              t4.forEach(function(e6) {
                o2.push(n.normalizeValue(e6));
              }), this.headersMap[r2] = o2;
            } else
              this.headersMap[r2] = [n.normalizeValue(t4)];
          }, e4.prototype.has = function(e5, t4) {
            var r2 = this.headersMap[n.normalizeName(e5)];
            if (!Array.isArray(r2))
              return false;
            if (void 0 !== t4) {
              var o2 = n.normalizeValue(t4);
              return r2.indexOf(o2) >= 0;
            }
            return true;
          }, e4.prototype.get = function(e5) {
            var t4 = this.headersMap[n.normalizeName(e5)];
            return void 0 !== t4 ? t4.concat() : [];
          }, e4.prototype.forEach = function(e5) {
            var t4 = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(r2) {
              e5(r2, t4.headersMap[r2]);
            }, this);
          }, e4.prototype.toHeaders = function() {
            if ("undefined" != typeof Headers) {
              var e5 = new Headers();
              return this.forEach(function(t4, r2) {
                r2.forEach(function(r3) {
                  e5.append(t4, r3);
                });
              }), e5;
            }
            throw new Error("Headers class is not defined");
          }, e4;
        }();
        t3.BrowserHeaders = o;
      }, function(e3, t3, r) {
        Object.defineProperty(t3, "__esModule", { value: true });
        var n = r(0);
        t3.BrowserHeaders = n.BrowserHeaders;
      }, function(e3, t3, r) {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.iterateHeaders = function(e4, t4) {
          for (var r2 = e4[Symbol.iterator](), n = r2.next(); !n.done; )
            t4(n.value[0]), n = r2.next();
        }, t3.iterateHeadersKeys = function(e4, t4) {
          for (var r2 = e4.keys(), n = r2.next(); !n.done; )
            t4(n.value), n = r2.next();
        };
      }, function(e3, t3, r) {
        Object.defineProperty(t3, "__esModule", { value: true });
        var n = r(2);
        t3.normalizeName = function(e4) {
          if ("string" != typeof e4 && (e4 = String(e4)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e4))
            throw new TypeError("Invalid character in header field name");
          return e4.toLowerCase();
        }, t3.normalizeValue = function(e4) {
          return "string" != typeof e4 && (e4 = String(e4)), e4;
        }, t3.getHeaderValues = function(e4, t4) {
          var r2 = e4;
          if (r2 instanceof Headers && r2.getAll)
            return r2.getAll(t4);
          var n2 = r2.get(t4);
          return n2 && "string" == typeof n2 ? [n2] : n2;
        }, t3.getHeaderKeys = function(e4) {
          var t4 = e4, r2 = {}, o = [];
          return t4.keys ? n.iterateHeadersKeys(t4, function(e5) {
            r2[e5] || (r2[e5] = true, o.push(e5));
          }) : t4.forEach ? t4.forEach(function(e5, t5) {
            r2[t5] || (r2[t5] = true, o.push(t5));
          }) : n.iterateHeaders(t4, function(e5) {
            var t5 = e5[0];
            r2[t5] || (r2[t5] = true, o.push(t5));
          }), o;
        }, t3.splitHeaderValue = function(e4) {
          var t4 = [];
          return e4.split(", ").forEach(function(e5) {
            e5.split(",").forEach(function(e6) {
              t4.push(e6);
            });
          }), t4;
        };
      }]));
    }, 617: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.ChunkParser = t2.ChunkType = t2.encodeASCII = t2.decodeASCII = void 0;
      var n, o = r(65);
      function s(e3) {
        return 9 === (t3 = e3) || 10 === t3 || 13 === t3 || e3 >= 32 && e3 <= 126;
        var t3;
      }
      function i(e3) {
        for (var t3 = 0; t3 !== e3.length; ++t3)
          if (!s(e3[t3]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(e3));
      }
      function a(e3) {
        return 128 == (128 & e3.getUint8(0));
      }
      function u(e3) {
        return e3.getUint32(1, false);
      }
      function d(e3, t3, r2) {
        return e3.byteLength - t3 >= r2;
      }
      function c(e3, t3, r2) {
        if (e3.slice)
          return e3.slice(t3, r2);
        var n2 = e3.length;
        void 0 !== r2 && (n2 = r2);
        for (var o2 = new Uint8Array(n2 - t3), s2 = 0, i2 = t3; i2 < n2; i2++)
          o2[s2++] = e3[i2];
        return o2;
      }
      t2.decodeASCII = i, t2.encodeASCII = function(e3) {
        for (var t3 = new Uint8Array(e3.length), r2 = 0; r2 !== e3.length; ++r2) {
          var n2 = e3.charCodeAt(r2);
          if (!s(n2))
            throw new Error("Metadata contains invalid ASCII");
          t3[r2] = n2;
        }
        return t3;
      }, function(e3) {
        e3[e3.MESSAGE = 1] = "MESSAGE", e3[e3.TRAILERS = 2] = "TRAILERS";
      }(n = t2.ChunkType || (t2.ChunkType = {}));
      var p2 = function() {
        function e3() {
          this.buffer = null, this.position = 0;
        }
        return e3.prototype.parse = function(e4, t3) {
          if (0 === e4.length && t3)
            return [];
          var r2, s2 = [];
          if (null == this.buffer)
            this.buffer = e4, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = e4, this.position = 0;
          else {
            var p3 = this.buffer.byteLength - this.position, h = new Uint8Array(p3 + e4.byteLength), f = c(this.buffer, this.position);
            h.set(f, 0);
            var l = new Uint8Array(e4);
            h.set(l, p3), this.buffer = h, this.position = 0;
          }
          for (; ; ) {
            if (!d(this.buffer, this.position, 5))
              return s2;
            var g = c(this.buffer, this.position, this.position + 5), b = new DataView(g.buffer, g.byteOffset, g.byteLength), y = u(b);
            if (!d(this.buffer, this.position, 5 + y))
              return s2;
            var v = c(this.buffer, this.position + 5, this.position + 5 + y);
            if (this.position += 5 + y, a(b))
              return s2.push({ chunkType: n.TRAILERS, trailers: (r2 = v, new o.Metadata(i(r2))) }), s2;
            s2.push({ chunkType: n.MESSAGE, data: v });
          }
        }, e3;
      }();
      t2.ChunkParser = p2;
    }, 8: function(e2, t2) {
      var r;
      Object.defineProperty(t2, "__esModule", { value: true }), t2.httpStatusToCode = t2.Code = void 0, function(e3) {
        e3[e3.OK = 0] = "OK", e3[e3.Canceled = 1] = "Canceled", e3[e3.Unknown = 2] = "Unknown", e3[e3.InvalidArgument = 3] = "InvalidArgument", e3[e3.DeadlineExceeded = 4] = "DeadlineExceeded", e3[e3.NotFound = 5] = "NotFound", e3[e3.AlreadyExists = 6] = "AlreadyExists", e3[e3.PermissionDenied = 7] = "PermissionDenied", e3[e3.ResourceExhausted = 8] = "ResourceExhausted", e3[e3.FailedPrecondition = 9] = "FailedPrecondition", e3[e3.Aborted = 10] = "Aborted", e3[e3.OutOfRange = 11] = "OutOfRange", e3[e3.Unimplemented = 12] = "Unimplemented", e3[e3.Internal = 13] = "Internal", e3[e3.Unavailable = 14] = "Unavailable", e3[e3.DataLoss = 15] = "DataLoss", e3[e3.Unauthenticated = 16] = "Unauthenticated";
      }(r = t2.Code || (t2.Code = {})), t2.httpStatusToCode = function(e3) {
        switch (e3) {
          case 0:
            return r.Internal;
          case 200:
            return r.OK;
          case 400:
            return r.InvalidArgument;
          case 401:
            return r.Unauthenticated;
          case 403:
            return r.PermissionDenied;
          case 404:
            return r.NotFound;
          case 409:
            return r.Aborted;
          case 412:
            return r.FailedPrecondition;
          case 429:
            return r.ResourceExhausted;
          case 499:
            return r.Canceled;
          case 500:
            return r.Unknown;
          case 501:
            return r.Unimplemented;
          case 503:
            return r.Unavailable;
          case 504:
            return r.DeadlineExceeded;
          default:
            return r.Unknown;
        }
      };
    }, 934: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.client = void 0;
      var n = r(65), o = r(617), s = r(8), i = r(346), a = r(57), u = r(882);
      t2.client = function(e3, t3) {
        return new d(e3, t3);
      };
      var d = function() {
        function e3(e4, t3) {
          this.started = false, this.sentFirstMessage = false, this.completed = false, this.closed = false, this.finishedSending = false, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new o.ChunkParser(), this.methodDefinition = e4, this.props = t3, this.createTransport();
        }
        return e3.prototype.createTransport = function() {
          var e4 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, t3 = { methodDefinition: this.methodDefinition, debug: this.props.debug || false, url: e4, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(t3) : this.transport = a.makeDefaultTransport(t3);
        }, e3.prototype.onTransportHeaders = function(e4, t3) {
          if (this.props.debug && i.debug("onHeaders", e4, t3), this.closed)
            this.props.debug && i.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (0 === t3)
            ;
          else {
            this.responseHeaders = e4, this.props.debug && i.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var r2 = c(e4);
            this.props.debug && i.debug("onHeaders.gRPCStatus", r2);
            var n2 = r2 && r2 >= 0 ? r2 : s.httpStatusToCode(t3);
            this.props.debug && i.debug("onHeaders.code", n2);
            var o2 = e4.get("grpc-message") || [];
            if (this.props.debug && i.debug("onHeaders.gRPCMessage", o2), this.rawOnHeaders(e4), n2 !== s.Code.OK) {
              var a2 = this.decodeGRPCStatus(o2[0]);
              this.rawOnError(n2, a2, e4);
            }
          }
        }, e3.prototype.onTransportChunk = function(e4) {
          var t3 = this;
          if (this.closed)
            this.props.debug && i.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var r2 = [];
            try {
              r2 = this.parser.parse(e4);
            } catch (e5) {
              return this.props.debug && i.debug("onChunk.parsing error", e5, e5.message), void this.rawOnError(s.Code.Internal, "parsing error: " + e5.message);
            }
            r2.forEach(function(e5) {
              if (e5.chunkType === o.ChunkType.MESSAGE) {
                var r3 = t3.methodDefinition.responseType.deserializeBinary(e5.data);
                t3.rawOnMessage(r3);
              } else
                e5.chunkType === o.ChunkType.TRAILERS && (t3.responseHeaders ? (t3.responseTrailers = new n.Metadata(e5.trailers), t3.props.debug && i.debug("onChunk.trailers", t3.responseTrailers)) : (t3.responseHeaders = new n.Metadata(e5.trailers), t3.rawOnHeaders(t3.responseHeaders)));
            });
          }
        }, e3.prototype.onTransportEnd = function() {
          if (this.props.debug && i.debug("grpc.onEnd"), this.closed)
            this.props.debug && i.debug("grpc.onEnd received after request was closed - ignoring");
          else if (void 0 !== this.responseTrailers) {
            var e4 = c(this.responseTrailers);
            if (null !== e4) {
              var t3 = this.responseTrailers.get("grpc-message"), r2 = this.decodeGRPCStatus(t3[0]);
              this.rawOnEnd(e4, r2, this.responseTrailers);
            } else
              this.rawOnError(s.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (void 0 === this.responseHeaders)
              return void this.rawOnError(s.Code.Unknown, "Response closed without headers");
            var n2 = c(this.responseHeaders), o2 = this.responseHeaders.get("grpc-message");
            if (this.props.debug && i.debug("grpc.headers only response ", n2, o2), null === n2)
              return void this.rawOnEnd(s.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var a2 = this.decodeGRPCStatus(o2[0]);
            this.rawOnEnd(n2, a2, this.responseHeaders);
          }
        }, e3.prototype.decodeGRPCStatus = function(e4) {
          if (!e4)
            return "";
          try {
            return decodeURIComponent(e4);
          } catch (t3) {
            return e4;
          }
        }, e3.prototype.rawOnEnd = function(e4, t3, r2) {
          var n2 = this;
          this.props.debug && i.debug("rawOnEnd", e4, t3, r2), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(o2) {
            if (!n2.closed)
              try {
                o2(e4, t3, r2);
              } catch (e5) {
                setTimeout(function() {
                  throw e5;
                }, 0);
              }
          }));
        }, e3.prototype.rawOnHeaders = function(e4) {
          this.props.debug && i.debug("rawOnHeaders", e4), this.completed || this.onHeadersCallbacks.forEach(function(t3) {
            try {
              t3(e4);
            } catch (e5) {
              setTimeout(function() {
                throw e5;
              }, 0);
            }
          });
        }, e3.prototype.rawOnError = function(e4, t3, r2) {
          var o2 = this;
          void 0 === r2 && (r2 = new n.Metadata()), this.props.debug && i.debug("rawOnError", e4, t3), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(n2) {
            if (!o2.closed)
              try {
                n2(e4, t3, r2);
              } catch (e5) {
                setTimeout(function() {
                  throw e5;
                }, 0);
              }
          }));
        }, e3.prototype.rawOnMessage = function(e4) {
          var t3 = this;
          this.props.debug && i.debug("rawOnMessage", e4.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(r2) {
            if (!t3.closed)
              try {
                r2(e4);
              } catch (e5) {
                setTimeout(function() {
                  throw e5;
                }, 0);
              }
          });
        }, e3.prototype.onHeaders = function(e4) {
          this.onHeadersCallbacks.push(e4);
        }, e3.prototype.onMessage = function(e4) {
          this.onMessageCallbacks.push(e4);
        }, e3.prototype.onEnd = function(e4) {
          this.onEndCallbacks.push(e4);
        }, e3.prototype.start = function(e4) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = true;
          var t3 = new n.Metadata(e4 || {});
          t3.set("content-type", "application/grpc-web+proto"), t3.set("x-grpc-web", "1"), this.transport.start(t3);
        }, e3.prototype.send = function(e4) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = true;
          var t3 = u.frameRequest(e4);
          this.transport.sendMessage(t3);
        }, e3.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = true, this.transport.finishSend();
        }, e3.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = true, this.props.debug && i.debug("request.abort aborting request"), this.transport.cancel();
        }, e3;
      }();
      function c(e3) {
        var t3 = e3.get("grpc-status") || [];
        if (t3.length > 0)
          try {
            var r2 = t3[0];
            return parseInt(r2, 10);
          } catch (e4) {
            return null;
          }
        return null;
      }
    }, 346: function(e2, t2) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.debug = void 0, t2.debug = function() {
        for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
          e3[t3] = arguments[t3];
        console.debug ? console.debug.apply(null, e3) : console.log.apply(null, e3);
      };
    }, 607: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.grpc = void 0;
      var n, o = r(418), s = r(57), i = r(229), a = r(540), u = r(210), d = r(859), c = r(8), p2 = r(938), h = r(35), f = r(934);
      (n = t2.grpc || (t2.grpc = {})).setDefaultTransport = s.setDefaultTransportFactory, n.CrossBrowserHttpTransport = d.CrossBrowserHttpTransport, n.FetchReadableStreamTransport = i.FetchReadableStreamTransport, n.XhrTransport = u.XhrTransport, n.WebsocketTransport = a.WebsocketTransport, n.Code = c.Code, n.Metadata = o.BrowserHeaders, n.client = function(e3, t3) {
        return f.client(e3, t3);
      }, n.invoke = p2.invoke, n.unary = h.unary;
    }, 938: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.invoke = void 0;
      var n = r(934);
      t2.invoke = function(e3, t3) {
        if (e3.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var r2 = n.client(e3, { host: t3.host, transport: t3.transport, debug: t3.debug });
        return t3.onHeaders && r2.onHeaders(t3.onHeaders), t3.onMessage && r2.onMessage(t3.onMessage), t3.onEnd && r2.onEnd(t3.onEnd), r2.start(t3.metadata), r2.send(t3.request), r2.finishSend(), { close: function() {
          r2.close();
        } };
      };
    }, 65: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.Metadata = void 0;
      var n = r(418);
      Object.defineProperty(t2, "Metadata", { enumerable: true, get: function() {
        return n.BrowserHeaders;
      } });
    }, 57: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.makeDefaultTransport = t2.setDefaultTransportFactory = void 0;
      var n = r(859), o = function(e3) {
        return n.CrossBrowserHttpTransport({ withCredentials: false })(e3);
      };
      t2.setDefaultTransportFactory = function(e3) {
        o = e3;
      }, t2.makeDefaultTransport = function(e3) {
        return o(e3);
      };
    }, 229: function(e2, t2, r) {
      var n = this && this.__assign || function() {
        return (n = Object.assign || function(e3) {
          for (var t3, r2 = 1, n2 = arguments.length; r2 < n2; r2++)
            for (var o2 in t3 = arguments[r2])
              Object.prototype.hasOwnProperty.call(t3, o2) && (e3[o2] = t3[o2]);
          return e3;
        }).apply(this, arguments);
      };
      Object.defineProperty(t2, "__esModule", { value: true }), t2.detectFetchSupport = t2.FetchReadableStreamTransport = void 0;
      var o = r(65), s = r(346);
      t2.FetchReadableStreamTransport = function(e3) {
        return function(t3) {
          return function(e4, t4) {
            return e4.debug && s.debug("fetchRequest", e4), new i(e4, t4);
          }(t3, e3);
        };
      };
      var i = function() {
        function e3(e4, t3) {
          this.cancelled = false, this.controller = self.AbortController && new AbortController(), this.options = e4, this.init = t3;
        }
        return e3.prototype.pump = function(e4, t3) {
          var r2 = this;
          if (this.reader = e4, this.cancelled)
            return this.options.debug && s.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(e5) {
              r2.options.debug && s.debug("Fetch.pump.reader.cancel exception", e5);
            });
          this.reader.read().then(function(e5) {
            if (e5.done)
              return r2.options.onEnd(), t3;
            r2.options.onChunk(e5.value), r2.pump(r2.reader, t3);
          }).catch(function(e5) {
            r2.cancelled ? r2.options.debug && s.debug("Fetch.catch - request cancelled") : (r2.cancelled = true, r2.options.debug && s.debug("Fetch.catch", e5.message), r2.options.onEnd(e5));
          });
        }, e3.prototype.send = function(e4) {
          var t3 = this;
          fetch(this.options.url, n(n({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: e4, signal: this.controller && this.controller.signal })).then(function(e5) {
            if (t3.options.debug && s.debug("Fetch.response", e5), t3.options.onHeaders(new o.Metadata(e5.headers), e5.status), !e5.body)
              return e5;
            t3.pump(e5.body.getReader(), e5);
          }).catch(function(e5) {
            t3.cancelled ? t3.options.debug && s.debug("Fetch.catch - request cancelled") : (t3.cancelled = true, t3.options.debug && s.debug("Fetch.catch", e5.message), t3.options.onEnd(e5));
          });
        }, e3.prototype.sendMessage = function(e4) {
          this.send(e4);
        }, e3.prototype.finishSend = function() {
        }, e3.prototype.start = function(e4) {
          this.metadata = e4;
        }, e3.prototype.cancel = function() {
          var e4 = this;
          this.cancelled ? this.options.debug && s.debug("Fetch.cancel already cancelled") : (this.cancelled = true, this.controller ? (this.options.debug && s.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && s.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && s.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(t3) {
            e4.options.debug && s.debug("Fetch.cancel.reader.cancel exception", t3);
          })) : this.options.debug && s.debug("Fetch.cancel before reader"));
        }, e3;
      }();
      t2.detectFetchSupport = function() {
        return "undefined" != typeof Response && Response.prototype.hasOwnProperty("body") && "function" == typeof Headers;
      };
    }, 859: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.CrossBrowserHttpTransport = void 0;
      var n = r(229), o = r(210);
      t2.CrossBrowserHttpTransport = function(e3) {
        if (n.detectFetchSupport()) {
          var t3 = { credentials: e3.withCredentials ? "include" : "same-origin" };
          return n.FetchReadableStreamTransport(t3);
        }
        return o.XhrTransport({ withCredentials: e3.withCredentials });
      };
    }, 210: function(e2, t2, r) {
      var n, o = this && this.__extends || (n = function(e3, t3) {
        return (n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
          e4.__proto__ = t4;
        } || function(e4, t4) {
          for (var r2 in t4)
            Object.prototype.hasOwnProperty.call(t4, r2) && (e4[r2] = t4[r2]);
        })(e3, t3);
      }, function(e3, t3) {
        function r2() {
          this.constructor = e3;
        }
        n(e3, t3), e3.prototype = null === t3 ? Object.create(t3) : (r2.prototype = t3.prototype, new r2());
      });
      Object.defineProperty(t2, "__esModule", { value: true }), t2.stringToArrayBuffer = t2.MozChunkedArrayBufferXHR = t2.XHR = t2.XhrTransport = void 0;
      var s = r(65), i = r(346), a = r(849);
      t2.XhrTransport = function(e3) {
        return function(t3) {
          if (a.detectMozXHRSupport())
            return new d(t3, e3);
          if (a.detectXHROverrideMimeTypeSupport())
            return new u(t3, e3);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var u = function() {
        function e3(e4, t3) {
          this.options = e4, this.init = t3;
        }
        return e3.prototype.onProgressEvent = function() {
          this.options.debug && i.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var e4 = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var t3 = p2(e4);
          this.options.onChunk(t3);
        }, e3.prototype.onLoadEvent = function() {
          this.options.debug && i.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, e3.prototype.onStateChange = function() {
          this.options.debug && i.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new s.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, e3.prototype.sendMessage = function(e4) {
          this.xhr.send(e4);
        }, e3.prototype.finishSend = function() {
        }, e3.prototype.start = function(e4) {
          var t3 = this;
          this.metadata = e4;
          var r2 = new XMLHttpRequest();
          this.xhr = r2, r2.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(e5, t4) {
            r2.setRequestHeader(e5, t4.join(", "));
          }), r2.withCredentials = Boolean(this.init.withCredentials), r2.addEventListener("readystatechange", this.onStateChange.bind(this)), r2.addEventListener("progress", this.onProgressEvent.bind(this)), r2.addEventListener("loadend", this.onLoadEvent.bind(this)), r2.addEventListener("error", function(e5) {
            t3.options.debug && i.debug("XHR.error", e5), t3.options.onEnd(e5.error);
          });
        }, e3.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, e3.prototype.cancel = function() {
          this.options.debug && i.debug("XHR.abort"), this.xhr.abort();
        }, e3;
      }();
      t2.XHR = u;
      var d = function(e3) {
        function t3() {
          return null !== e3 && e3.apply(this, arguments) || this;
        }
        return o(t3, e3), t3.prototype.configureXhr = function() {
          this.options.debug && i.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, t3.prototype.onProgressEvent = function() {
          var e4 = this.xhr.response;
          this.options.debug && i.debug("MozXHR.onProgressEvent: ", new Uint8Array(e4)), this.options.onChunk(new Uint8Array(e4));
        }, t3;
      }(u);
      function c(e3, t3) {
        var r2 = e3.charCodeAt(t3);
        if (r2 >= 55296 && r2 <= 56319) {
          var n2 = e3.charCodeAt(t3 + 1);
          n2 >= 56320 && n2 <= 57343 && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320));
        }
        return r2;
      }
      function p2(e3) {
        for (var t3 = new Uint8Array(e3.length), r2 = 0, n2 = 0; n2 < e3.length; n2++) {
          var o2 = String.prototype.codePointAt ? e3.codePointAt(n2) : c(e3, n2);
          t3[r2++] = 255 & o2;
        }
        return t3;
      }
      t2.MozChunkedArrayBufferXHR = d, t2.stringToArrayBuffer = p2;
    }, 849: function(e2, t2) {
      var r;
      function n() {
        if (void 0 !== r)
          return r;
        if (XMLHttpRequest) {
          r = new XMLHttpRequest();
          try {
            r.open("GET", "https://localhost");
          } catch (e3) {
          }
        }
        return r;
      }
      function o(e3) {
        var t3 = n();
        if (!t3)
          return false;
        try {
          return t3.responseType = e3, t3.responseType === e3;
        } catch (e4) {
        }
        return false;
      }
      Object.defineProperty(t2, "__esModule", { value: true }), t2.detectXHROverrideMimeTypeSupport = t2.detectMozXHRSupport = t2.xhrSupportsResponseType = void 0, t2.xhrSupportsResponseType = o, t2.detectMozXHRSupport = function() {
        return "undefined" != typeof XMLHttpRequest && o("moz-chunked-arraybuffer");
      }, t2.detectXHROverrideMimeTypeSupport = function() {
        return "undefined" != typeof XMLHttpRequest && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.WebsocketTransport = void 0;
      var n, o = r(346), s = r(617);
      !function(e3) {
        e3[e3.FINISH_SEND = 1] = "FINISH_SEND";
      }(n || (n = {}));
      var i = new Uint8Array([1]);
      t2.WebsocketTransport = function() {
        return function(e3) {
          return function(e4) {
            e4.debug && o.debug("websocketRequest", e4);
            var t3, r2 = function(e5) {
              if ("https://" === e5.substr(0, 8))
                return "wss://" + e5.substr(8);
              if ("http://" === e5.substr(0, 7))
                return "ws://" + e5.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(e4.url), a = [];
            function u(e5) {
              if (e5 === n.FINISH_SEND)
                t3.send(i);
              else {
                var r3 = e5, o2 = new Int8Array(r3.byteLength + 1);
                o2.set(new Uint8Array([0])), o2.set(r3, 1), t3.send(o2);
              }
            }
            return { sendMessage: function(e5) {
              t3 && t3.readyState !== t3.CONNECTING ? u(e5) : a.push(e5);
            }, finishSend: function() {
              t3 && t3.readyState !== t3.CONNECTING ? u(n.FINISH_SEND) : a.push(n.FINISH_SEND);
            }, start: function(n2) {
              (t3 = new WebSocket(r2, ["grpc-websockets"])).binaryType = "arraybuffer", t3.onopen = function() {
                var r3;
                e4.debug && o.debug("websocketRequest.onopen"), t3.send((r3 = "", n2.forEach(function(e5, t4) {
                  r3 += e5 + ": " + t4.join(", ") + "\r\n";
                }), s.encodeASCII(r3))), a.forEach(function(e5) {
                  u(e5);
                });
              }, t3.onclose = function(t4) {
                e4.debug && o.debug("websocketRequest.onclose", t4), e4.onEnd();
              }, t3.onerror = function(t4) {
                e4.debug && o.debug("websocketRequest.onerror", t4);
              }, t3.onmessage = function(t4) {
                e4.onChunk(new Uint8Array(t4.data));
              };
            }, cancel: function() {
              e4.debug && o.debug("websocket.abort"), t3.close();
            } };
          }(e3);
        };
      };
    }, 35: function(e2, t2, r) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.unary = void 0;
      var n = r(65), o = r(934);
      t2.unary = function(e3, t3) {
        if (e3.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if (e3.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var r2 = null, s = null, i = o.client(e3, { host: t3.host, transport: t3.transport, debug: t3.debug });
        return i.onHeaders(function(e4) {
          r2 = e4;
        }), i.onMessage(function(e4) {
          s = e4;
        }), i.onEnd(function(e4, o2, i2) {
          t3.onEnd({ status: e4, statusMessage: o2, headers: r2 || new n.Metadata(), message: s, trailers: i2 });
        }), i.start(t3.metadata), i.send(t3.request), i.finishSend(), { close: function() {
          i.close();
        } };
      };
    }, 882: function(e2, t2) {
      Object.defineProperty(t2, "__esModule", { value: true }), t2.frameRequest = void 0, t2.frameRequest = function(e3) {
        var t3 = e3.serializeBinary(), r = new ArrayBuffer(t3.byteLength + 5);
        return new DataView(r, 1, 4).setUint32(0, t3.length, false), new Uint8Array(r, 5).set(t3), new Uint8Array(r);
      };
    } }, t = {}, function r(n) {
      if (t[n])
        return t[n].exports;
      var o = t[n] = { exports: {} };
      return e[n].call(o.exports, o, o.exports, r), o.exports;
    }(607);
    var e, t;
  });
})(grpcWebClient_umd);
var indexMinimal = {};
var minimal$1 = {};
var aspromise = asPromise;
function asPromise(fn, ctx) {
  var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
  while (index < arguments.length)
    params[offset++] = arguments[index++];
  return new Promise(function executor(resolve, reject) {
    params[offset] = function callback(err) {
      if (pending) {
        pending = false;
        if (err)
          reject(err);
        else {
          var params2 = new Array(arguments.length - 1), offset2 = 0;
          while (offset2 < params2.length)
            params2[offset2++] = arguments[offset2];
          resolve.apply(null, params2);
        }
      }
    };
    try {
      fn.apply(ctx || null, params);
    } catch (err) {
      if (pending) {
        pending = false;
        reject(err);
      }
    }
  });
}
var base64$1 = {};
(function(exports) {
  var base642 = exports;
  base642.length = function length2(string) {
    var p2 = string.length;
    if (!p2)
      return 0;
    var n = 0;
    while (--p2 % 4 > 1 && string.charAt(p2) === "=")
      ++n;
    return Math.ceil(string.length * 3) / 4 - n;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i = 0; i < 64; )
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
  base642.encode = function encode(buffer, start, end2) {
    var parts = null, chunk = [];
    var i2 = 0, j = 0, t;
    while (start < end2) {
      var b = buffer[start++];
      switch (j) {
        case 0:
          chunk[i2++] = b64[b >> 2];
          t = (b & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i2++] = b64[t | b >> 4];
          t = (b & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i2++] = b64[t | b >> 6];
          chunk[i2++] = b64[b & 63];
          j = 0;
          break;
      }
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (j) {
      chunk[i2++] = b64[t];
      chunk[i2++] = 61;
      if (j === 1)
        chunk[i2++] = 61;
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  var invalidEncoding = "invalid encoding";
  base642.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t;
    for (var i2 = 0; i2 < string.length; ) {
      var c = string.charCodeAt(i2++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === void 0)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c;
          j = 1;
          break;
        case 1:
          buffer[offset++] = t << 2 | (c & 48) >> 4;
          t = c;
          j = 2;
          break;
        case 2:
          buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
          t = c;
          j = 3;
          break;
        case 3:
          buffer[offset++] = (t & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base642.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
})(base64$1);
var eventemitter = EventEmitter;
function EventEmitter() {
  this._listeners = {};
}
EventEmitter.prototype.on = function on(evt, fn, ctx) {
  (this._listeners[evt] || (this._listeners[evt] = [])).push({
    fn,
    ctx: ctx || this
  });
  return this;
};
EventEmitter.prototype.off = function off(evt, fn) {
  if (evt === void 0)
    this._listeners = {};
  else {
    if (fn === void 0)
      this._listeners[evt] = [];
    else {
      var listeners = this._listeners[evt];
      for (var i = 0; i < listeners.length; )
        if (listeners[i].fn === fn)
          listeners.splice(i, 1);
        else
          ++i;
    }
  }
  return this;
};
EventEmitter.prototype.emit = function emit(evt) {
  var listeners = this._listeners[evt];
  if (listeners) {
    var args = [], i = 1;
    for (; i < arguments.length; )
      args.push(arguments[i++]);
    for (i = 0; i < listeners.length; )
      listeners[i].fn.apply(listeners[i++].ctx, args);
  }
  return this;
};
var float = factory(factory);
function factory(exports) {
  if (typeof Float32Array !== "undefined")
    (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf, pos) {
        f32[0] = val;
        buf[pos] = f8b[3];
        buf[pos + 1] = f8b[2];
        buf[pos + 2] = f8b[1];
        buf[pos + 3] = f8b[0];
      }
      exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf, pos) {
        f8b[3] = buf[pos];
        f8b[2] = buf[pos + 1];
        f8b[1] = buf[pos + 2];
        f8b[0] = buf[pos + 3];
        return f32[0];
      }
      exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
      exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
  else
    (function() {
      function writeFloat_ieee754(writeUint, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
        }
      }
      exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf, pos) {
        var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
  if (typeof Float64Array !== "undefined")
    (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[0];
        buf[pos + 1] = f8b[1];
        buf[pos + 2] = f8b[2];
        buf[pos + 3] = f8b[3];
        buf[pos + 4] = f8b[4];
        buf[pos + 5] = f8b[5];
        buf[pos + 6] = f8b[6];
        buf[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf, pos) {
        f64[0] = val;
        buf[pos] = f8b[7];
        buf[pos + 1] = f8b[6];
        buf[pos + 2] = f8b[5];
        buf[pos + 3] = f8b[4];
        buf[pos + 4] = f8b[3];
        buf[pos + 5] = f8b[2];
        buf[pos + 6] = f8b[1];
        buf[pos + 7] = f8b[0];
      }
      exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf, pos) {
        f8b[0] = buf[pos];
        f8b[1] = buf[pos + 1];
        f8b[2] = buf[pos + 2];
        f8b[3] = buf[pos + 3];
        f8b[4] = buf[pos + 4];
        f8b[5] = buf[pos + 5];
        f8b[6] = buf[pos + 6];
        f8b[7] = buf[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf, pos) {
        f8b[7] = buf[pos];
        f8b[6] = buf[pos + 1];
        f8b[5] = buf[pos + 2];
        f8b[4] = buf[pos + 3];
        f8b[3] = buf[pos + 4];
        f8b[2] = buf[pos + 5];
        f8b[1] = buf[pos + 6];
        f8b[0] = buf[pos + 7];
        return f64[0];
      }
      exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
      exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
  else
    (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0) {
          writeUint(0, buf, pos + off0);
          writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf, pos + off0);
          writeUint(2146959360, buf, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf, pos + off0);
          writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf, pos + off0);
            writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
            writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
          }
        }
      }
      exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf, pos) {
        var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
        var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
  return exports;
}
function writeUintLE(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf, pos) {
  buf[pos] = val >>> 24;
  buf[pos + 1] = val >>> 16 & 255;
  buf[pos + 2] = val >>> 8 & 255;
  buf[pos + 3] = val & 255;
}
function readUintLE(buf, pos) {
  return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}
function readUintBE(buf, pos) {
  return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e) {
  }
  return null;
}
var utf8$2 = {};
(function(exports) {
  var utf82 = exports;
  utf82.length = function utf8_length(string) {
    var len = 0, c = 0;
    for (var i = 0; i < string.length; ++i) {
      c = string.charCodeAt(i);
      if (c < 128)
        len += 1;
      else if (c < 2048)
        len += 2;
      else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
        ++i;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };
  utf82.read = function utf8_read(buffer, start, end2) {
    var len = end2 - start;
    if (len < 1)
      return "";
    var parts = null, chunk = [], i = 0, t;
    while (start < end2) {
      t = buffer[start++];
      if (t < 128)
        chunk[i++] = t;
      else if (t > 191 && t < 224)
        chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
        chunk[i++] = 55296 + (t >> 10);
        chunk[i++] = 56320 + (t & 1023);
      } else
        chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
      if (i > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i = 0;
      }
    }
    if (parts) {
      if (i)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
  };
  utf82.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2;
    for (var i = 0; i < string.length; ++i) {
      c1 = string.charCodeAt(i);
      if (c1 < 128) {
        buffer[offset++] = c1;
      } else if (c1 < 2048) {
        buffer[offset++] = c1 >> 6 | 192;
        buffer[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i;
        buffer[offset++] = c1 >> 18 | 240;
        buffer[offset++] = c1 >> 12 & 63 | 128;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      } else {
        buffer[offset++] = c1 >> 12 | 224;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
})(utf8$2);
var pool_1 = pool;
function pool(alloc2, slice, size) {
  var SIZE = size || 8192;
  var MAX2 = SIZE >>> 1;
  var slab = null;
  var offset = SIZE;
  return function pool_alloc(size2) {
    if (size2 < 1 || size2 > MAX2)
      return alloc2(size2);
    if (offset + size2 > SIZE) {
      slab = alloc2(SIZE);
      offset = 0;
    }
    var buf = slice.call(slab, offset, offset += size2);
    if (offset & 7)
      offset = (offset | 7) + 1;
    return buf;
  };
}
var longbits = LongBits$2;
var util$5 = minimal$1;
function LongBits$2(lo, hi) {
  this.lo = lo >>> 0;
  this.hi = hi >>> 0;
}
var zero = LongBits$2.zero = new LongBits$2(0, 0);
zero.toNumber = function() {
  return 0;
};
zero.zzEncode = zero.zzDecode = function() {
  return this;
};
zero.length = function() {
  return 1;
};
var zeroHash = LongBits$2.zeroHash = "\0\0\0\0\0\0\0\0";
LongBits$2.fromNumber = function fromNumber2(value) {
  if (value === 0)
    return zero;
  var sign = value < 0;
  if (sign)
    value = -value;
  var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
  if (sign) {
    hi = ~hi >>> 0;
    lo = ~lo >>> 0;
    if (++lo > 4294967295) {
      lo = 0;
      if (++hi > 4294967295)
        hi = 0;
    }
  }
  return new LongBits$2(lo, hi);
};
LongBits$2.from = function from(value) {
  if (typeof value === "number")
    return LongBits$2.fromNumber(value);
  if (util$5.isString(value)) {
    if (util$5.Long)
      value = util$5.Long.fromString(value);
    else
      return LongBits$2.fromNumber(parseInt(value, 10));
  }
  return value.low || value.high ? new LongBits$2(value.low >>> 0, value.high >>> 0) : zero;
};
LongBits$2.prototype.toNumber = function toNumber(unsigned) {
  if (!unsigned && this.hi >>> 31) {
    var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
    if (!lo)
      hi = hi + 1 >>> 0;
    return -(lo + hi * 4294967296);
  }
  return this.lo + this.hi * 4294967296;
};
LongBits$2.prototype.toLong = function toLong(unsigned) {
  return util$5.Long ? new util$5.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};
var charCodeAt = String.prototype.charCodeAt;
LongBits$2.fromHash = function fromHash(hash2) {
  if (hash2 === zeroHash)
    return zero;
  return new LongBits$2(
    (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
    (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
  );
};
LongBits$2.prototype.toHash = function toHash() {
  return String.fromCharCode(
    this.lo & 255,
    this.lo >>> 8 & 255,
    this.lo >>> 16 & 255,
    this.lo >>> 24,
    this.hi & 255,
    this.hi >>> 8 & 255,
    this.hi >>> 16 & 255,
    this.hi >>> 24
  );
};
LongBits$2.prototype.zzEncode = function zzEncode() {
  var mask = this.hi >> 31;
  this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
  this.lo = (this.lo << 1 ^ mask) >>> 0;
  return this;
};
LongBits$2.prototype.zzDecode = function zzDecode() {
  var mask = -(this.lo & 1);
  this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
  this.hi = (this.hi >>> 1 ^ mask) >>> 0;
  return this;
};
LongBits$2.prototype.length = function length() {
  var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
  return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
};
(function(exports) {
  var util2 = exports;
  util2.asPromise = aspromise;
  util2.base64 = base64$1;
  util2.EventEmitter = eventemitter;
  util2.float = float;
  util2.inquire = inquire_1;
  util2.utf8 = utf8$2;
  util2.pool = pool_1;
  util2.LongBits = longbits;
  util2.isNode = Boolean(typeof commonjsGlobal !== "undefined" && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node);
  util2.global = util2.isNode && commonjsGlobal || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
  util2.emptyArray = Object.freeze ? Object.freeze([]) : [];
  util2.emptyObject = Object.freeze ? Object.freeze({}) : {};
  util2.isInteger = Number.isInteger || function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  util2.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
  };
  util2.isObject = function isObject2(value) {
    return value && typeof value === "object";
  };
  util2.isset = util2.isSet = function isSet2(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop))
      return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
  };
  util2.Buffer = function() {
    try {
      var Buffer2 = util2.inquire("buffer").Buffer;
      return Buffer2.prototype.utf8Write ? Buffer2 : null;
    } catch (e) {
      return null;
    }
  }();
  util2._Buffer_from = null;
  util2._Buffer_allocUnsafe = null;
  util2.newBuffer = function newBuffer(sizeOrArray) {
    return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
  };
  util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  util2.Long = util2.global.dcodeIO && util2.global.dcodeIO.Long || util2.global.Long || util2.inquire("long");
  util2.key2Re = /^true|false|0|1$/;
  util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
  util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
  util2.longToHash = function longToHash(value) {
    return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
  };
  util2.longFromHash = function longFromHash(hash2, unsigned) {
    var bits = util2.LongBits.fromHash(hash2);
    if (util2.Long)
      return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
  };
  function merge(dst, src, ifNotSet) {
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
      if (dst[keys[i]] === void 0 || !ifNotSet)
        dst[keys[i]] = src[keys[i]];
    return dst;
  }
  util2.merge = merge;
  util2.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  };
  function newError(name) {
    function CustomError(message, properties) {
      if (!(this instanceof CustomError))
        return new CustomError(message, properties);
      Object.defineProperty(this, "message", { get: function() {
        return message;
      } });
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CustomError);
      else
        Object.defineProperty(this, "stack", { value: new Error().stack || "" });
      if (properties)
        merge(this, properties);
    }
    CustomError.prototype = Object.create(Error.prototype, {
      constructor: {
        value: CustomError,
        writable: true,
        enumerable: false,
        configurable: true
      },
      name: {
        get() {
          return name;
        },
        set: void 0,
        enumerable: false,
        configurable: true
      },
      toString: {
        value() {
          return this.name + ": " + this.message;
        },
        writable: true,
        enumerable: false,
        configurable: true
      }
    });
    return CustomError;
  }
  util2.newError = newError;
  util2.ProtocolError = newError("ProtocolError");
  util2.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
      fieldMap[fieldNames[i]] = 1;
    return function() {
      for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
        if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
          return keys[i2];
    };
  };
  util2.oneOfSetter = function setOneOf(fieldNames) {
    return function(name) {
      for (var i = 0; i < fieldNames.length; ++i)
        if (fieldNames[i] !== name)
          delete this[fieldNames[i]];
    };
  };
  util2.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
  };
  util2._configure = function() {
    var Buffer2 = util2.Buffer;
    if (!Buffer2) {
      util2._Buffer_from = util2._Buffer_allocUnsafe = null;
      return;
    }
    util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
      return new Buffer2(value, encoding);
    };
    util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
      return new Buffer2(size);
    };
  };
})(minimal$1);
var writer = Writer$1;
var util$4 = minimal$1;
var BufferWriter$1;
var LongBits$1 = util$4.LongBits, base64 = util$4.base64, utf8$1 = util$4.utf8;
function Op(fn, len, val) {
  this.fn = fn;
  this.len = len;
  this.next = void 0;
  this.val = val;
}
function noop() {
}
function State(writer2) {
  this.head = writer2.head;
  this.tail = writer2.tail;
  this.len = writer2.len;
  this.next = writer2.states;
}
function Writer$1() {
  this.len = 0;
  this.head = new Op(noop, 0, 0);
  this.tail = this.head;
  this.states = null;
}
var create$1 = function create2() {
  return util$4.Buffer ? function create_buffer_setup() {
    return (Writer$1.create = function create_buffer() {
      return new BufferWriter$1();
    })();
  } : function create_array3() {
    return new Writer$1();
  };
};
Writer$1.create = create$1();
Writer$1.alloc = function alloc(size) {
  return new util$4.Array(size);
};
if (util$4.Array !== Array)
  Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray);
Writer$1.prototype._push = function push(fn, len, val) {
  this.tail = this.tail.next = new Op(fn, len, val);
  this.len += len;
  return this;
};
function writeByte(val, buf, pos) {
  buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
  while (val > 127) {
    buf[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf[pos] = val;
}
function VarintOp(len, val) {
  this.len = len;
  this.next = void 0;
  this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function write_uint32(value) {
  this.len += (this.tail = this.tail.next = new VarintOp(
    (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
    value
  )).len;
  return this;
};
Writer$1.prototype.int32 = function write_int32(value) {
  return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);
};
Writer$1.prototype.sint32 = function write_sint32(value) {
  return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
  while (val.hi) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf[pos++] = val.lo;
}
Writer$1.prototype.uint64 = function write_uint64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function write_sint64(value) {
  var bits = LongBits$1.from(value).zzEncode();
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.bool = function write_bool(value) {
  return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
  buf[pos] = val & 255;
  buf[pos + 1] = val >>> 8 & 255;
  buf[pos + 2] = val >>> 16 & 255;
  buf[pos + 3] = val >>> 24;
}
Writer$1.prototype.fixed32 = function write_fixed32(value) {
  return this._push(writeFixed32, 4, value >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function write_fixed64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function write_float(value) {
  return this._push(util$4.float.writeFloatLE, 4, value);
};
Writer$1.prototype.double = function write_double(value) {
  return this._push(util$4.float.writeDoubleLE, 8, value);
};
var writeBytes = util$4.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
  buf.set(val, pos);
} : function writeBytes_for(val, buf, pos) {
  for (var i = 0; i < val.length; ++i)
    buf[pos + i] = val[i];
};
Writer$1.prototype.bytes = function write_bytes(value) {
  var len = value.length >>> 0;
  if (!len)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(value)) {
    var buf = Writer$1.alloc(len = base64.length(value));
    base64.decode(value, buf, 0);
    value = buf;
  }
  return this.uint32(len)._push(writeBytes, len, value);
};
Writer$1.prototype.string = function write_string(value) {
  var len = utf8$1.length(value);
  return len ? this.uint32(len)._push(utf8$1.write, len, value) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function fork() {
  this.states = new State(this);
  this.head = this.tail = new Op(noop, 0, 0);
  this.len = 0;
  return this;
};
Writer$1.prototype.reset = function reset() {
  if (this.states) {
    this.head = this.states.head;
    this.tail = this.states.tail;
    this.len = this.states.len;
    this.states = this.states.next;
  } else {
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
  }
  return this;
};
Writer$1.prototype.ldelim = function ldelim() {
  var head = this.head, tail = this.tail, len = this.len;
  this.reset().uint32(len);
  if (len) {
    this.tail.next = head.next;
    this.tail = tail;
    this.len += len;
  }
  return this;
};
Writer$1.prototype.finish = function finish() {
  var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
  while (head) {
    head.fn(head.val, buf, pos);
    pos += head.len;
    head = head.next;
  }
  return buf;
};
Writer$1._configure = function(BufferWriter_) {
  BufferWriter$1 = BufferWriter_;
  Writer$1.create = create$1();
  BufferWriter$1._configure();
};
var writer_buffer = BufferWriter;
var Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = minimal$1;
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe;
  BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf, pos) {
    if (val.copy)
      val.copy(buf, pos, 0, val.length);
    else
      for (var i = 0; i < val.length; )
        buf[pos++] = val[i++];
  };
};
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
  if (util$3.isString(value))
    value = util$3._Buffer_from(value, "base64");
  var len = value.length >>> 0;
  this.uint32(len);
  if (len)
    this._push(BufferWriter.writeBytesBuffer, len, value);
  return this;
};
function writeStringBuffer(val, buf, pos) {
  if (val.length < 40)
    util$3.utf8.write(val, buf, pos);
  else if (buf.utf8Write)
    buf.utf8Write(val, pos);
  else
    buf.write(val, pos);
}
BufferWriter.prototype.string = function write_string_buffer(value) {
  var len = util$3.Buffer.byteLength(value);
  this.uint32(len);
  if (len)
    this._push(writeStringBuffer, len, value);
  return this;
};
BufferWriter._configure();
var reader = Reader$1;
var util$2 = minimal$1;
var BufferReader$1;
var LongBits = util$2.LongBits, utf8 = util$2.utf8;
function indexOutOfRange(reader2, writeLength) {
  return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
}
function Reader$1(buffer) {
  this.buf = buffer;
  this.pos = 0;
  this.len = buffer.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
  if (buffer instanceof Uint8Array || Array.isArray(buffer))
    return new Reader$1(buffer);
  throw Error("illegal buffer");
} : function create_array2(buffer) {
  if (Array.isArray(buffer))
    return new Reader$1(buffer);
  throw Error("illegal buffer");
};
var create = function create3() {
  return util$2.Buffer ? function create_buffer_setup(buffer) {
    return (Reader$1.create = function create_buffer(buffer2) {
      return util$2.Buffer.isBuffer(buffer2) ? new BufferReader$1(buffer2) : create_array(buffer2);
    })(buffer);
  } : create_array;
};
Reader$1.create = create();
Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice;
Reader$1.prototype.uint32 = function read_uint32_setup() {
  var value = 4294967295;
  return function read_uint32() {
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  };
}();
Reader$1.prototype.int32 = function read_int32() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function read_sint32() {
  var value = this.uint32();
  return value >>> 1 ^ -(value & 1) | 0;
};
function readLongVarint() {
  var bits = new LongBits(0, 0);
  var i = 0;
  if (this.len - this.pos > 4) {
    for (; i < 4; ++i) {
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
    if (this.buf[this.pos++] < 128)
      return bits;
    i = 0;
  } else {
    for (; i < 3; ++i) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
    return bits;
  }
  if (this.len - this.pos > 4) {
    for (; i < 5; ++i) {
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  } else {
    for (; i < 5; ++i) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function read_bool() {
  return this.uint32() !== 0;
};
function readFixed32_end(buf, end2) {
  return (buf[end2 - 4] | buf[end2 - 3] << 8 | buf[end2 - 2] << 16 | buf[end2 - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function read_fixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function read_sfixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function read_float() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readFloatLE(this.buf, this.pos);
  this.pos += 4;
  return value;
};
Reader$1.prototype.double = function read_double() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readDoubleLE(this.buf, this.pos);
  this.pos += 8;
  return value;
};
Reader$1.prototype.bytes = function read_bytes() {
  var length2 = this.uint32(), start = this.pos, end2 = this.pos + length2;
  if (end2 > this.len)
    throw indexOutOfRange(this, length2);
  this.pos += length2;
  if (Array.isArray(this.buf))
    return this.buf.slice(start, end2);
  return start === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end2);
};
Reader$1.prototype.string = function read_string() {
  var bytes = this.bytes();
  return utf8.read(bytes, 0, bytes.length);
};
Reader$1.prototype.skip = function skip(length2) {
  if (typeof length2 === "number") {
    if (this.pos + length2 > this.len)
      throw indexOutOfRange(this, length2);
    this.pos += length2;
  } else {
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    } while (this.buf[this.pos++] & 128);
  }
  return this;
};
Reader$1.prototype.skipType = function(wireType) {
  switch (wireType) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      while ((wireType = this.uint32() & 7) !== 4) {
        this.skipType(wireType);
      }
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(BufferReader_) {
  BufferReader$1 = BufferReader_;
  Reader$1.create = create();
  BufferReader$1._configure();
  var fn = util$2.Long ? "toLong" : "toNumber";
  util$2.merge(Reader$1.prototype, {
    int64: function read_int64() {
      return readLongVarint.call(this)[fn](false);
    },
    uint64: function read_uint64() {
      return readLongVarint.call(this)[fn](true);
    },
    sint64: function read_sint64() {
      return readLongVarint.call(this).zzDecode()[fn](false);
    },
    fixed64: function read_fixed64() {
      return readFixed64.call(this)[fn](true);
    },
    sfixed64: function read_sfixed64() {
      return readFixed64.call(this)[fn](false);
    }
  });
};
var reader_buffer = BufferReader;
var Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = minimal$1;
function BufferReader(buffer) {
  Reader.call(this, buffer);
}
BufferReader._configure = function() {
  if (util$1.Buffer)
    BufferReader.prototype._slice = util$1.Buffer.prototype.slice;
};
BufferReader.prototype.string = function read_string_buffer() {
  var len = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
BufferReader._configure();
var rpc = {};
var service = Service;
var util = minimal$1;
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
function Service(rpcImpl, requestDelimited, responseDelimited) {
  if (typeof rpcImpl !== "function")
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this);
  this.rpcImpl = rpcImpl;
  this.requestDelimited = Boolean(requestDelimited);
  this.responseDelimited = Boolean(responseDelimited);
}
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
  if (!request)
    throw TypeError("request must be specified");
  var self2 = this;
  if (!callback)
    return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
  if (!self2.rpcImpl) {
    setTimeout(function() {
      callback(Error("already ended"));
    }, 0);
    return void 0;
  }
  try {
    return self2.rpcImpl(
      method,
      requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
      function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(true);
          return void 0;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      }
    );
  } catch (err) {
    self2.emit("error", err, method);
    setTimeout(function() {
      callback(err);
    }, 0);
    return void 0;
  }
};
Service.prototype.end = function end(endedByRPC) {
  if (this.rpcImpl) {
    if (!endedByRPC)
      this.rpcImpl(null, null, null);
    this.rpcImpl = null;
    this.emit("end").off();
  }
  return this;
};
(function(exports) {
  var rpc2 = exports;
  rpc2.Service = service;
})(rpc);
var roots = {};
(function(exports) {
  var protobuf = exports;
  protobuf.build = "minimal";
  protobuf.Writer = writer;
  protobuf.BufferWriter = writer_buffer;
  protobuf.Reader = reader;
  protobuf.BufferReader = reader_buffer;
  protobuf.util = minimal$1;
  protobuf.rpc = rpc;
  protobuf.roots = roots;
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
})(indexMinimal);
var minimal = indexMinimal;
function createBaseCoin() {
  return { denom: "", amount: "" };
}
const Coin = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.denom !== "") {
      writer2.uint32(10).string(message.denom);
    }
    if (message.amount !== "") {
      writer2.uint32(18).string(message.amount);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCoin();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader2.string();
          break;
        case 2:
          message.amount = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      denom: isSet$d(object.denom) ? String(object.denom) : "",
      amount: isSet$d(object.amount) ? String(object.amount) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.denom !== void 0 && (obj.denom = message.denom);
    message.amount !== void 0 && (obj.amount = message.amount);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCoin();
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    return message;
  }
};
function isSet$d(value) {
  return value !== null && value !== void 0;
}
var long = Long;
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch (e) {
}
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
    if (cache)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache)
      INT_CACHE[value] = obj;
    return obj;
  }
}
Long.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
Long.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error("empty string");
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return ZERO;
  if (typeof unsigned === "number") {
    radix = unsigned, unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  var p2;
  if ((p2 = str.indexOf("-")) > 0)
    throw Error("interior hyphen");
  else if (p2 === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number")
    return fromNumber(val, unsigned);
  if (typeof val === "string")
    return fromString(val, unsigned);
  return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber2() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else
      return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero())
      return digits + result;
    else {
      while (digits.length < 6)
        digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val & 1 << bit) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative2() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd2() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(other);
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(other) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(other) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(other) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(other) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare2(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.eq(other))
    return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg)
    return -1;
  if (!thisNeg && otherNeg)
    return 1;
  if (!this.unsigned)
    return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE))
    return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend))
    addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend))
    subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero())
    return ZERO;
  if (!isLong(multiplier))
    multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm.mul(
      this.low,
      this.high,
      multiplier.low,
      multiplier.high
    );
    return fromBits(low, wasm.get_high(), this.unsigned);
  }
  if (multiplier.isZero())
    return ZERO;
  if (this.eq(MIN_VALUE))
    return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative())
      return this.neg().mul(multiplier.neg());
    else
      return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (divisor.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm.get_high(), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE))
        return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative())
        return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative())
      return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned)
      divisor = divisor.toUnsigned();
    if (divisor.gt(this))
      return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero())
      approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm.get_high(), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.and = function and(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
  else
    return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  numBits &= 63;
  if (numBits === 0)
    return this;
  else {
    var high = this.high;
    if (numBits < 32) {
      var low = this.low;
      return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
    } else if (numBits === 32)
      return fromBits(high, 0, this.unsigned);
    else
      return fromBits(high >>> numBits - 32, 0, this.unsigned);
  }
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long(
    bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
    bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
    unsigned
  );
};
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long(
    bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
    bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
    unsigned
  );
};
function createBasePageRequest() {
  return {
    key: new Uint8Array(),
    offset: "0",
    limit: "0",
    countTotal: false,
    reverse: false
  };
}
const PageRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.key.length !== 0) {
      writer2.uint32(10).bytes(message.key);
    }
    if (message.offset !== "0") {
      writer2.uint32(16).uint64(message.offset);
    }
    if (message.limit !== "0") {
      writer2.uint32(24).uint64(message.limit);
    }
    if (message.countTotal === true) {
      writer2.uint32(32).bool(message.countTotal);
    }
    if (message.reverse === true) {
      writer2.uint32(40).bool(message.reverse);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePageRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader2.bytes();
          break;
        case 2:
          message.offset = longToString$3(reader2.uint64());
          break;
        case 3:
          message.limit = longToString$3(reader2.uint64());
          break;
        case 4:
          message.countTotal = reader2.bool();
          break;
        case 5:
          message.reverse = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet$c(object.key) ? bytesFromBase64$7(object.key) : new Uint8Array(),
      offset: isSet$c(object.offset) ? String(object.offset) : "0",
      limit: isSet$c(object.limit) ? String(object.limit) : "0",
      countTotal: isSet$c(object.countTotal) ? Boolean(object.countTotal) : false,
      reverse: isSet$c(object.reverse) ? Boolean(object.reverse) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes$7(message.key !== void 0 ? message.key : new Uint8Array()));
    message.offset !== void 0 && (obj.offset = message.offset);
    message.limit !== void 0 && (obj.limit = message.limit);
    message.countTotal !== void 0 && (obj.countTotal = message.countTotal);
    message.reverse !== void 0 && (obj.reverse = message.reverse);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePageRequest();
    message.key = object.key ?? new Uint8Array();
    message.offset = object.offset ?? "0";
    message.limit = object.limit ?? "0";
    message.countTotal = object.countTotal ?? false;
    message.reverse = object.reverse ?? false;
    return message;
  }
};
function createBasePageResponse() {
  return { nextKey: new Uint8Array(), total: "0" };
}
const PageResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.nextKey.length !== 0) {
      writer2.uint32(10).bytes(message.nextKey);
    }
    if (message.total !== "0") {
      writer2.uint32(16).uint64(message.total);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePageResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.nextKey = reader2.bytes();
          break;
        case 2:
          message.total = longToString$3(reader2.uint64());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      nextKey: isSet$c(object.nextKey) ? bytesFromBase64$7(object.nextKey) : new Uint8Array(),
      total: isSet$c(object.total) ? String(object.total) : "0"
    };
  },
  toJSON(message) {
    const obj = {};
    message.nextKey !== void 0 && (obj.nextKey = base64FromBytes$7(message.nextKey !== void 0 ? message.nextKey : new Uint8Array()));
    message.total !== void 0 && (obj.total = message.total);
    return obj;
  },
  fromPartial(object) {
    const message = createBasePageResponse();
    message.nextKey = object.nextKey ?? new Uint8Array();
    message.total = object.total ?? "0";
    return message;
  }
};
var globalThis$d = (() => {
  if (typeof globalThis$d !== "undefined")
    return globalThis$d;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
const atob$7 = globalThis$d.atob || ((b64) => globalThis$d.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64$7(b64) {
  const bin = atob$7(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}
const btoa$7 = globalThis$d.btoa || ((bin) => globalThis$d.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes$7(arr) {
  const bin = [];
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte));
  });
  return btoa$7(bin.join(""));
}
function longToString$3(long2) {
  return long2.toString();
}
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
function isSet$c(value) {
  return value !== null && value !== void 0;
}
function createBaseParams$1() {
  return { sendEnabled: [], defaultSendEnabled: false };
}
const Params$1 = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.sendEnabled) {
      SendEnabled.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    if (message.defaultSendEnabled === true) {
      writer2.uint32(16).bool(message.defaultSendEnabled);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseParams$1();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.sendEnabled.push(SendEnabled.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.defaultSendEnabled = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      sendEnabled: Array.isArray(object?.sendEnabled) ? object.sendEnabled.map((e) => SendEnabled.fromJSON(e)) : [],
      defaultSendEnabled: isSet$b(object.defaultSendEnabled) ? Boolean(object.defaultSendEnabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.sendEnabled) {
      obj.sendEnabled = message.sendEnabled.map((e) => e ? SendEnabled.toJSON(e) : void 0);
    } else {
      obj.sendEnabled = [];
    }
    message.defaultSendEnabled !== void 0 && (obj.defaultSendEnabled = message.defaultSendEnabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseParams$1();
    message.sendEnabled = object.sendEnabled?.map((e) => SendEnabled.fromPartial(e)) || [];
    message.defaultSendEnabled = object.defaultSendEnabled ?? false;
    return message;
  }
};
function createBaseSendEnabled() {
  return { denom: "", enabled: false };
}
const SendEnabled = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.denom !== "") {
      writer2.uint32(10).string(message.denom);
    }
    if (message.enabled === true) {
      writer2.uint32(16).bool(message.enabled);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSendEnabled();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader2.string();
          break;
        case 2:
          message.enabled = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      denom: isSet$b(object.denom) ? String(object.denom) : "",
      enabled: isSet$b(object.enabled) ? Boolean(object.enabled) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.denom !== void 0 && (obj.denom = message.denom);
    message.enabled !== void 0 && (obj.enabled = message.enabled);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSendEnabled();
    message.denom = object.denom ?? "";
    message.enabled = object.enabled ?? false;
    return message;
  }
};
function createBaseDenomUnit() {
  return { denom: "", exponent: 0, aliases: [] };
}
const DenomUnit = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.denom !== "") {
      writer2.uint32(10).string(message.denom);
    }
    if (message.exponent !== 0) {
      writer2.uint32(16).uint32(message.exponent);
    }
    for (const v of message.aliases) {
      writer2.uint32(26).string(v);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseDenomUnit();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader2.string();
          break;
        case 2:
          message.exponent = reader2.uint32();
          break;
        case 3:
          message.aliases.push(reader2.string());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      denom: isSet$b(object.denom) ? String(object.denom) : "",
      exponent: isSet$b(object.exponent) ? Number(object.exponent) : 0,
      aliases: Array.isArray(object?.aliases) ? object.aliases.map((e) => String(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.denom !== void 0 && (obj.denom = message.denom);
    message.exponent !== void 0 && (obj.exponent = Math.round(message.exponent));
    if (message.aliases) {
      obj.aliases = message.aliases.map((e) => e);
    } else {
      obj.aliases = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseDenomUnit();
    message.denom = object.denom ?? "";
    message.exponent = object.exponent ?? 0;
    message.aliases = object.aliases?.map((e) => e) || [];
    return message;
  }
};
function createBaseMetadata() {
  return {
    description: "",
    denomUnits: [],
    base: "",
    display: "",
    name: "",
    symbol: ""
  };
}
const Metadata = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.description !== "") {
      writer2.uint32(10).string(message.description);
    }
    for (const v of message.denomUnits) {
      DenomUnit.encode(v, writer2.uint32(18).fork()).ldelim();
    }
    if (message.base !== "") {
      writer2.uint32(26).string(message.base);
    }
    if (message.display !== "") {
      writer2.uint32(34).string(message.display);
    }
    if (message.name !== "") {
      writer2.uint32(42).string(message.name);
    }
    if (message.symbol !== "") {
      writer2.uint32(50).string(message.symbol);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseMetadata();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.description = reader2.string();
          break;
        case 2:
          message.denomUnits.push(DenomUnit.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.base = reader2.string();
          break;
        case 4:
          message.display = reader2.string();
          break;
        case 5:
          message.name = reader2.string();
          break;
        case 6:
          message.symbol = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      description: isSet$b(object.description) ? String(object.description) : "",
      denomUnits: Array.isArray(object?.denomUnits) ? object.denomUnits.map((e) => DenomUnit.fromJSON(e)) : [],
      base: isSet$b(object.base) ? String(object.base) : "",
      display: isSet$b(object.display) ? String(object.display) : "",
      name: isSet$b(object.name) ? String(object.name) : "",
      symbol: isSet$b(object.symbol) ? String(object.symbol) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.description !== void 0 && (obj.description = message.description);
    if (message.denomUnits) {
      obj.denomUnits = message.denomUnits.map((e) => e ? DenomUnit.toJSON(e) : void 0);
    } else {
      obj.denomUnits = [];
    }
    message.base !== void 0 && (obj.base = message.base);
    message.display !== void 0 && (obj.display = message.display);
    message.name !== void 0 && (obj.name = message.name);
    message.symbol !== void 0 && (obj.symbol = message.symbol);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMetadata();
    message.description = object.description ?? "";
    message.denomUnits = object.denomUnits?.map((e) => DenomUnit.fromPartial(e)) || [];
    message.base = object.base ?? "";
    message.display = object.display ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    return message;
  }
};
function isSet$b(value) {
  return value !== null && value !== void 0;
}
var browserHeaders_umd = { exports: {} };
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory2) {
    module.exports = factory2();
  })(commonjsGlobal, function() {
    return function(modules) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules;
      __webpack_require__.c = installedModules;
      __webpack_require__.i = function(value) {
        return value;
      };
      __webpack_require__.d = function(exports2, name, getter) {
        if (!__webpack_require__.o(exports2, name)) {
          Object.defineProperty(exports2, name, {
            configurable: false,
            enumerable: true,
            get: getter
          });
        }
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "";
      return __webpack_require__(__webpack_require__.s = 1);
    }([
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var util_1 = __webpack_require__(3);
        function isBrowserHeaders(arg) {
          return typeof arg === "object" && typeof arg.headersMap === "object" && typeof arg.forEach === "function";
        }
        var BrowserHeaders = function() {
          function BrowserHeaders2(init2, options) {
            if (init2 === void 0) {
              init2 = {};
            }
            if (options === void 0) {
              options = { splitValues: false };
            }
            var _this = this;
            this.headersMap = {};
            if (init2) {
              if (typeof Headers !== "undefined" && init2 instanceof Headers) {
                var keys = util_1.getHeaderKeys(init2);
                keys.forEach(function(key) {
                  var values = util_1.getHeaderValues(init2, key);
                  values.forEach(function(value) {
                    if (options.splitValues) {
                      _this.append(key, util_1.splitHeaderValue(value));
                    } else {
                      _this.append(key, value);
                    }
                  });
                });
              } else if (isBrowserHeaders(init2)) {
                init2.forEach(function(key, values) {
                  _this.append(key, values);
                });
              } else if (typeof Map !== "undefined" && init2 instanceof Map) {
                var asMap = init2;
                asMap.forEach(function(value, key) {
                  _this.append(key, value);
                });
              } else if (typeof init2 === "string") {
                this.appendFromString(init2);
              } else if (typeof init2 === "object") {
                Object.getOwnPropertyNames(init2).forEach(function(key) {
                  var asObject = init2;
                  var values = asObject[key];
                  if (Array.isArray(values)) {
                    values.forEach(function(value) {
                      _this.append(key, value);
                    });
                  } else {
                    _this.append(key, values);
                  }
                });
              }
            }
          }
          BrowserHeaders2.prototype.appendFromString = function(str) {
            var pairs = str.split("\r\n");
            for (var i = 0; i < pairs.length; i++) {
              var p2 = pairs[i];
              var index = p2.indexOf(":");
              if (index > 0) {
                var key = p2.substring(0, index).trim();
                var value = p2.substring(index + 1).trim();
                this.append(key, value);
              }
            }
          };
          BrowserHeaders2.prototype.delete = function(key, value) {
            var normalizedKey = util_1.normalizeName(key);
            if (value === void 0) {
              delete this.headersMap[normalizedKey];
            } else {
              var existing = this.headersMap[normalizedKey];
              if (existing) {
                var index = existing.indexOf(value);
                if (index >= 0) {
                  existing.splice(index, 1);
                }
                if (existing.length === 0) {
                  delete this.headersMap[normalizedKey];
                }
              }
            }
          };
          BrowserHeaders2.prototype.append = function(key, value) {
            var _this = this;
            var normalizedKey = util_1.normalizeName(key);
            if (!Array.isArray(this.headersMap[normalizedKey])) {
              this.headersMap[normalizedKey] = [];
            }
            if (Array.isArray(value)) {
              value.forEach(function(arrayValue) {
                _this.headersMap[normalizedKey].push(util_1.normalizeValue(arrayValue));
              });
            } else {
              this.headersMap[normalizedKey].push(util_1.normalizeValue(value));
            }
          };
          BrowserHeaders2.prototype.set = function(key, value) {
            var normalizedKey = util_1.normalizeName(key);
            if (Array.isArray(value)) {
              var normalized_1 = [];
              value.forEach(function(arrayValue) {
                normalized_1.push(util_1.normalizeValue(arrayValue));
              });
              this.headersMap[normalizedKey] = normalized_1;
            } else {
              this.headersMap[normalizedKey] = [util_1.normalizeValue(value)];
            }
          };
          BrowserHeaders2.prototype.has = function(key, value) {
            var keyArray = this.headersMap[util_1.normalizeName(key)];
            var keyExists = Array.isArray(keyArray);
            if (!keyExists) {
              return false;
            }
            if (value !== void 0) {
              var normalizedValue = util_1.normalizeValue(value);
              return keyArray.indexOf(normalizedValue) >= 0;
            } else {
              return true;
            }
          };
          BrowserHeaders2.prototype.get = function(key) {
            var values = this.headersMap[util_1.normalizeName(key)];
            if (values !== void 0) {
              return values.concat();
            }
            return [];
          };
          BrowserHeaders2.prototype.forEach = function(callback) {
            var _this = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(key) {
              callback(key, _this.headersMap[key]);
            }, this);
          };
          BrowserHeaders2.prototype.toHeaders = function() {
            if (typeof Headers !== "undefined") {
              var headers_1 = new Headers();
              this.forEach(function(key, values) {
                values.forEach(function(value) {
                  headers_1.append(key, value);
                });
              });
              return headers_1;
            } else {
              throw new Error("Headers class is not defined");
            }
          };
          return BrowserHeaders2;
        }();
        exports2.BrowserHeaders = BrowserHeaders;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var BrowserHeaders_1 = __webpack_require__(0);
        exports2.BrowserHeaders = BrowserHeaders_1.BrowserHeaders;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        function iterateHeaders(headers, callback) {
          var iterator = headers[Symbol.iterator]();
          var entry = iterator.next();
          while (!entry.done) {
            callback(entry.value[0]);
            entry = iterator.next();
          }
        }
        exports2.iterateHeaders = iterateHeaders;
        function iterateHeadersKeys(headers, callback) {
          var iterator = headers.keys();
          var entry = iterator.next();
          while (!entry.done) {
            callback(entry.value);
            entry = iterator.next();
          }
        }
        exports2.iterateHeadersKeys = iterateHeadersKeys;
      },
      function(module2, exports2, __webpack_require__) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        var iterateHeaders_1 = __webpack_require__(2);
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        exports2.normalizeName = normalizeName;
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        exports2.normalizeValue = normalizeValue;
        function getHeaderValues(headersAsNative, key) {
          var headers = toWindowHeaders(headersAsNative);
          if (headers instanceof Headers && headers.getAll) {
            return headers.getAll(key);
          }
          var getValue = headers.get(key);
          if (getValue && typeof getValue === "string") {
            return [getValue];
          }
          return getValue;
        }
        exports2.getHeaderValues = getHeaderValues;
        function toWindowHeaders(headersAsNative) {
          return headersAsNative;
        }
        function getHeaderKeys(headersAsNative) {
          var headers = toWindowHeaders(headersAsNative);
          var asMap = {};
          var keys = [];
          if (headers.keys) {
            iterateHeaders_1.iterateHeadersKeys(headers, function(key) {
              if (!asMap[key]) {
                asMap[key] = true;
                keys.push(key);
              }
            });
          } else if (headers.forEach) {
            headers.forEach(function(_, key) {
              if (!asMap[key]) {
                asMap[key] = true;
                keys.push(key);
              }
            });
          } else {
            iterateHeaders_1.iterateHeaders(headers, function(entry) {
              var key = entry[0];
              if (!asMap[key]) {
                asMap[key] = true;
                keys.push(key);
              }
            });
          }
          return keys;
        }
        exports2.getHeaderKeys = getHeaderKeys;
        function splitHeaderValue(str) {
          var values = [];
          var commaSpaceValues = str.split(", ");
          commaSpaceValues.forEach(function(commaSpaceValue) {
            commaSpaceValue.split(",").forEach(function(commaValue) {
              values.push(commaValue);
            });
          });
          return values;
        }
        exports2.splitHeaderValue = splitHeaderValue;
      }
    ]);
  });
})(browserHeaders_umd);
function createBaseQueryBalanceRequest() {
  return { address: "", denom: "" };
}
const QueryBalanceRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.address !== "") {
      writer2.uint32(10).string(message.address);
    }
    if (message.denom !== "") {
      writer2.uint32(18).string(message.denom);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryBalanceRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader2.string();
          break;
        case 2:
          message.denom = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet$a(object.address) ? String(object.address) : "",
      denom: isSet$a(object.denom) ? String(object.denom) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    message.denom !== void 0 && (obj.denom = message.denom);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryBalanceRequest();
    message.address = object.address ?? "";
    message.denom = object.denom ?? "";
    return message;
  }
};
function createBaseQueryBalanceResponse() {
  return { balance: void 0 };
}
const QueryBalanceResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.balance !== void 0) {
      Coin.encode(message.balance, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryBalanceResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.balance = Coin.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      balance: isSet$a(object.balance) ? Coin.fromJSON(object.balance) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.balance !== void 0 && (obj.balance = message.balance ? Coin.toJSON(message.balance) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryBalanceResponse();
    message.balance = object.balance !== void 0 && object.balance !== null ? Coin.fromPartial(object.balance) : void 0;
    return message;
  }
};
function createBaseQueryAllBalancesRequest() {
  return { address: "", pagination: void 0 };
}
const QueryAllBalancesRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.address !== "") {
      writer2.uint32(10).string(message.address);
    }
    if (message.pagination !== void 0) {
      PageRequest.encode(message.pagination, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryAllBalancesRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader2.string();
          break;
        case 2:
          message.pagination = PageRequest.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet$a(object.address) ? String(object.address) : "",
      pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageRequest.toJSON(message.pagination) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryAllBalancesRequest();
    message.address = object.address ?? "";
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseQueryAllBalancesResponse() {
  return { balances: [], pagination: void 0 };
}
const QueryAllBalancesResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.balances) {
      Coin.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== void 0) {
      PageResponse.encode(message.pagination, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryAllBalancesResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.balances.push(Coin.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.pagination = PageResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      balances: Array.isArray(object?.balances) ? object.balances.map((e) => Coin.fromJSON(e)) : [],
      pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.balances) {
      obj.balances = message.balances.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.balances = [];
    }
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageResponse.toJSON(message.pagination) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryAllBalancesResponse();
    message.balances = object.balances?.map((e) => Coin.fromPartial(e)) || [];
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseQueryTotalSupplyRequest() {
  return { pagination: void 0 };
}
const QueryTotalSupplyRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.pagination !== void 0) {
      PageRequest.encode(message.pagination, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryTotalSupplyRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pagination = PageRequest.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageRequest.toJSON(message.pagination) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryTotalSupplyRequest();
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseQueryTotalSupplyResponse() {
  return { supply: [], pagination: void 0 };
}
const QueryTotalSupplyResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.supply) {
      Coin.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== void 0) {
      PageResponse.encode(message.pagination, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryTotalSupplyResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.supply.push(Coin.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.pagination = PageResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      supply: Array.isArray(object?.supply) ? object.supply.map((e) => Coin.fromJSON(e)) : [],
      pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.supply) {
      obj.supply = message.supply.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.supply = [];
    }
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageResponse.toJSON(message.pagination) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryTotalSupplyResponse();
    message.supply = object.supply?.map((e) => Coin.fromPartial(e)) || [];
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseQuerySupplyOfRequest() {
  return { denom: "" };
}
const QuerySupplyOfRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.denom !== "") {
      writer2.uint32(10).string(message.denom);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQuerySupplyOfRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      denom: isSet$a(object.denom) ? String(object.denom) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.denom !== void 0 && (obj.denom = message.denom);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQuerySupplyOfRequest();
    message.denom = object.denom ?? "";
    return message;
  }
};
function createBaseQuerySupplyOfResponse() {
  return { amount: void 0 };
}
const QuerySupplyOfResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.amount !== void 0) {
      Coin.encode(message.amount, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQuerySupplyOfResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.amount = Coin.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      amount: isSet$a(object.amount) ? Coin.fromJSON(object.amount) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.amount !== void 0 && (obj.amount = message.amount ? Coin.toJSON(message.amount) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQuerySupplyOfResponse();
    message.amount = object.amount !== void 0 && object.amount !== null ? Coin.fromPartial(object.amount) : void 0;
    return message;
  }
};
function createBaseQueryParamsRequest$1() {
  return {};
}
const QueryParamsRequest$1 = {
  encode(_, writer2 = minimal.Writer.create()) {
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryParamsRequest$1();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseQueryParamsRequest$1();
    return message;
  }
};
function createBaseQueryParamsResponse$1() {
  return { params: void 0 };
}
const QueryParamsResponse$1 = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.params !== void 0) {
      Params$1.encode(message.params, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryParamsResponse$1();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params$1.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet$a(object.params) ? Params$1.fromJSON(object.params) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params$1.toJSON(message.params) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryParamsResponse$1();
    message.params = object.params !== void 0 && object.params !== null ? Params$1.fromPartial(object.params) : void 0;
    return message;
  }
};
function createBaseQueryDenomsMetadataRequest() {
  return { pagination: void 0 };
}
const QueryDenomsMetadataRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.pagination !== void 0) {
      PageRequest.encode(message.pagination, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryDenomsMetadataRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pagination = PageRequest.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageRequest.toJSON(message.pagination) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryDenomsMetadataRequest();
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseQueryDenomsMetadataResponse() {
  return { metadatas: [], pagination: void 0 };
}
const QueryDenomsMetadataResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.metadatas) {
      Metadata.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== void 0) {
      PageResponse.encode(message.pagination, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryDenomsMetadataResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metadatas.push(Metadata.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.pagination = PageResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      metadatas: Array.isArray(object?.metadatas) ? object.metadatas.map((e) => Metadata.fromJSON(e)) : [],
      pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.metadatas) {
      obj.metadatas = message.metadatas.map((e) => e ? Metadata.toJSON(e) : void 0);
    } else {
      obj.metadatas = [];
    }
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageResponse.toJSON(message.pagination) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryDenomsMetadataResponse();
    message.metadatas = object.metadatas?.map((e) => Metadata.fromPartial(e)) || [];
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseQueryDenomMetadataRequest() {
  return { denom: "" };
}
const QueryDenomMetadataRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.denom !== "") {
      writer2.uint32(10).string(message.denom);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryDenomMetadataRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.denom = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      denom: isSet$a(object.denom) ? String(object.denom) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.denom !== void 0 && (obj.denom = message.denom);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryDenomMetadataRequest();
    message.denom = object.denom ?? "";
    return message;
  }
};
function createBaseQueryDenomMetadataResponse() {
  return { metadata: void 0 };
}
const QueryDenomMetadataResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.metadata !== void 0) {
      Metadata.encode(message.metadata, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryDenomMetadataResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.metadata = Metadata.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      metadata: isSet$a(object.metadata) ? Metadata.fromJSON(object.metadata) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.metadata !== void 0 && (obj.metadata = message.metadata ? Metadata.toJSON(message.metadata) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryDenomMetadataResponse();
    message.metadata = object.metadata !== void 0 && object.metadata !== null ? Metadata.fromPartial(object.metadata) : void 0;
    return message;
  }
};
class QueryClientImpl$1 {
  constructor(rpc2) {
    __publicField(this, "rpc");
    this.rpc = rpc2;
    this.balance = this.balance.bind(this);
    this.allBalances = this.allBalances.bind(this);
    this.totalSupply = this.totalSupply.bind(this);
    this.supplyOf = this.supplyOf.bind(this);
    this.params = this.params.bind(this);
    this.denomMetadata = this.denomMetadata.bind(this);
    this.denomsMetadata = this.denomsMetadata.bind(this);
  }
  balance(request, metadata) {
    return this.rpc.unary(QueryBalanceDesc, QueryBalanceRequest.fromPartial(request), metadata);
  }
  allBalances(request, metadata) {
    return this.rpc.unary(QueryAllBalancesDesc, QueryAllBalancesRequest.fromPartial(request), metadata);
  }
  totalSupply(request, metadata) {
    return this.rpc.unary(QueryTotalSupplyDesc, QueryTotalSupplyRequest.fromPartial(request), metadata);
  }
  supplyOf(request, metadata) {
    return this.rpc.unary(QuerySupplyOfDesc, QuerySupplyOfRequest.fromPartial(request), metadata);
  }
  params(request, metadata) {
    return this.rpc.unary(QueryParamsDesc$1, QueryParamsRequest$1.fromPartial(request), metadata);
  }
  denomMetadata(request, metadata) {
    return this.rpc.unary(QueryDenomMetadataDesc, QueryDenomMetadataRequest.fromPartial(request), metadata);
  }
  denomsMetadata(request, metadata) {
    return this.rpc.unary(QueryDenomsMetadataDesc, QueryDenomsMetadataRequest.fromPartial(request), metadata);
  }
}
const QueryDesc$1 = {
  serviceName: "cosmos.bank.v1beta1.Query"
};
const QueryBalanceDesc = {
  methodName: "Balance",
  service: QueryDesc$1,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryBalanceRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QueryBalanceResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const QueryAllBalancesDesc = {
  methodName: "AllBalances",
  service: QueryDesc$1,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryAllBalancesRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QueryAllBalancesResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const QueryTotalSupplyDesc = {
  methodName: "TotalSupply",
  service: QueryDesc$1,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryTotalSupplyRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QueryTotalSupplyResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const QuerySupplyOfDesc = {
  methodName: "SupplyOf",
  service: QueryDesc$1,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QuerySupplyOfRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QuerySupplyOfResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const QueryParamsDesc$1 = {
  methodName: "Params",
  service: QueryDesc$1,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryParamsRequest$1.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QueryParamsResponse$1.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const QueryDenomMetadataDesc = {
  methodName: "DenomMetadata",
  service: QueryDesc$1,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDenomMetadataRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QueryDenomMetadataResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const QueryDenomsMetadataDesc = {
  methodName: "DenomsMetadata",
  service: QueryDesc$1,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryDenomsMetadataRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QueryDenomsMetadataResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
class GrpcWebImpl {
  constructor(host, options) {
    __publicField(this, "host");
    __publicField(this, "options");
    this.host = host;
    this.options = options;
  }
  unary(methodDesc, _request, metadata) {
    const request = { ..._request, ...methodDesc.requestType };
    const maybeCombinedMetadata = metadata && this.options.metadata ? new browserHeaders_umd.exports.BrowserHeaders({
      ...this.options?.metadata.headersMap,
      ...metadata?.headersMap
    }) : metadata || this.options.metadata;
    return new Promise((resolve, reject) => {
      grpcWebClient_umd.exports.grpc.unary(methodDesc, {
        request,
        host: this.host,
        metadata: maybeCombinedMetadata,
        transport: this.options.transport,
        debug: this.options.debug,
        onEnd: function(response) {
          if (response.status === grpcWebClient_umd.exports.grpc.Code.OK) {
            resolve(response.message);
          } else {
            const err = new Error(response.statusMessage);
            err.code = response.status;
            err.metadata = response.trailers;
            reject(err);
          }
        }
      });
    });
  }
}
function isSet$a(value) {
  return value !== null && value !== void 0;
}
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array() };
}
const Any = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.typeUrl !== "") {
      writer2.uint32(10).string(message.typeUrl);
    }
    if (message.value.length !== 0) {
      writer2.uint32(18).bytes(message.value);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseAny();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.typeUrl = reader2.string();
          break;
        case 2:
          message.value = reader2.bytes();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      typeUrl: isSet$9(object.typeUrl) ? String(object.typeUrl) : "",
      value: isSet$9(object.value) ? bytesFromBase64$6(object.value) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
    message.value !== void 0 && (obj.value = base64FromBytes$6(message.value !== void 0 ? message.value : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAny();
    message.typeUrl = object.typeUrl ?? "";
    message.value = object.value ?? new Uint8Array();
    return message;
  }
};
var globalThis$c = (() => {
  if (typeof globalThis$c !== "undefined")
    return globalThis$c;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
const atob$6 = globalThis$c.atob || ((b64) => globalThis$c.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64$6(b64) {
  const bin = atob$6(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}
const btoa$6 = globalThis$c.btoa || ((bin) => globalThis$c.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes$6(arr) {
  const bin = [];
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte));
  });
  return btoa$6(bin.join(""));
}
function isSet$9(value) {
  return value !== null && value !== void 0;
}
function createBaseBaseAccount() {
  return { address: "", pubKey: void 0, accountNumber: "0", sequence: "0" };
}
const BaseAccount = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.address !== "") {
      writer2.uint32(10).string(message.address);
    }
    if (message.pubKey !== void 0) {
      Any.encode(message.pubKey, writer2.uint32(18).fork()).ldelim();
    }
    if (message.accountNumber !== "0") {
      writer2.uint32(24).uint64(message.accountNumber);
    }
    if (message.sequence !== "0") {
      writer2.uint32(32).uint64(message.sequence);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseBaseAccount();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader2.string();
          break;
        case 2:
          message.pubKey = Any.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.accountNumber = longToString$2(reader2.uint64());
          break;
        case 4:
          message.sequence = longToString$2(reader2.uint64());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet$8(object.address) ? String(object.address) : "",
      pubKey: isSet$8(object.pubKey) ? Any.fromJSON(object.pubKey) : void 0,
      accountNumber: isSet$8(object.accountNumber) ? String(object.accountNumber) : "0",
      sequence: isSet$8(object.sequence) ? String(object.sequence) : "0"
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? Any.toJSON(message.pubKey) : void 0);
    message.accountNumber !== void 0 && (obj.accountNumber = message.accountNumber);
    message.sequence !== void 0 && (obj.sequence = message.sequence);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBaseAccount();
    message.address = object.address ?? "";
    message.pubKey = object.pubKey !== void 0 && object.pubKey !== null ? Any.fromPartial(object.pubKey) : void 0;
    message.accountNumber = object.accountNumber ?? "0";
    message.sequence = object.sequence ?? "0";
    return message;
  }
};
function createBaseParams() {
  return {
    maxMemoCharacters: "0",
    txSigLimit: "0",
    txSizeCostPerByte: "0",
    sigVerifyCostEd25519: "0",
    sigVerifyCostSecp256k1: "0"
  };
}
const Params = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.maxMemoCharacters !== "0") {
      writer2.uint32(8).uint64(message.maxMemoCharacters);
    }
    if (message.txSigLimit !== "0") {
      writer2.uint32(16).uint64(message.txSigLimit);
    }
    if (message.txSizeCostPerByte !== "0") {
      writer2.uint32(24).uint64(message.txSizeCostPerByte);
    }
    if (message.sigVerifyCostEd25519 !== "0") {
      writer2.uint32(32).uint64(message.sigVerifyCostEd25519);
    }
    if (message.sigVerifyCostSecp256k1 !== "0") {
      writer2.uint32(40).uint64(message.sigVerifyCostSecp256k1);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseParams();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxMemoCharacters = longToString$2(reader2.uint64());
          break;
        case 2:
          message.txSigLimit = longToString$2(reader2.uint64());
          break;
        case 3:
          message.txSizeCostPerByte = longToString$2(reader2.uint64());
          break;
        case 4:
          message.sigVerifyCostEd25519 = longToString$2(reader2.uint64());
          break;
        case 5:
          message.sigVerifyCostSecp256k1 = longToString$2(reader2.uint64());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      maxMemoCharacters: isSet$8(object.maxMemoCharacters) ? String(object.maxMemoCharacters) : "0",
      txSigLimit: isSet$8(object.txSigLimit) ? String(object.txSigLimit) : "0",
      txSizeCostPerByte: isSet$8(object.txSizeCostPerByte) ? String(object.txSizeCostPerByte) : "0",
      sigVerifyCostEd25519: isSet$8(object.sigVerifyCostEd25519) ? String(object.sigVerifyCostEd25519) : "0",
      sigVerifyCostSecp256k1: isSet$8(object.sigVerifyCostSecp256k1) ? String(object.sigVerifyCostSecp256k1) : "0"
    };
  },
  toJSON(message) {
    const obj = {};
    message.maxMemoCharacters !== void 0 && (obj.maxMemoCharacters = message.maxMemoCharacters);
    message.txSigLimit !== void 0 && (obj.txSigLimit = message.txSigLimit);
    message.txSizeCostPerByte !== void 0 && (obj.txSizeCostPerByte = message.txSizeCostPerByte);
    message.sigVerifyCostEd25519 !== void 0 && (obj.sigVerifyCostEd25519 = message.sigVerifyCostEd25519);
    message.sigVerifyCostSecp256k1 !== void 0 && (obj.sigVerifyCostSecp256k1 = message.sigVerifyCostSecp256k1);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseParams();
    message.maxMemoCharacters = object.maxMemoCharacters ?? "0";
    message.txSigLimit = object.txSigLimit ?? "0";
    message.txSizeCostPerByte = object.txSizeCostPerByte ?? "0";
    message.sigVerifyCostEd25519 = object.sigVerifyCostEd25519 ?? "0";
    message.sigVerifyCostSecp256k1 = object.sigVerifyCostSecp256k1 ?? "0";
    return message;
  }
};
function longToString$2(long2) {
  return long2.toString();
}
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
function isSet$8(value) {
  return value !== null && value !== void 0;
}
function createBaseQueryAccountsRequest() {
  return { pagination: void 0 };
}
const QueryAccountsRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.pagination !== void 0) {
      PageRequest.encode(message.pagination, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryAccountsRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pagination = PageRequest.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      pagination: isSet$7(object.pagination) ? PageRequest.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageRequest.toJSON(message.pagination) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryAccountsRequest();
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseQueryAccountsResponse() {
  return { accounts: [], pagination: void 0 };
}
const QueryAccountsResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.accounts) {
      Any.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    if (message.pagination !== void 0) {
      PageResponse.encode(message.pagination, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryAccountsResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.accounts.push(Any.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.pagination = PageResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      accounts: Array.isArray(object?.accounts) ? object.accounts.map((e) => Any.fromJSON(e)) : [],
      pagination: isSet$7(object.pagination) ? PageResponse.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.accounts) {
      obj.accounts = message.accounts.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.accounts = [];
    }
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageResponse.toJSON(message.pagination) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryAccountsResponse();
    message.accounts = object.accounts?.map((e) => Any.fromPartial(e)) || [];
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseQueryAccountRequest() {
  return { address: "" };
}
const QueryAccountRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.address !== "") {
      writer2.uint32(10).string(message.address);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryAccountRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      address: isSet$7(object.address) ? String(object.address) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.address !== void 0 && (obj.address = message.address);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryAccountRequest();
    message.address = object.address ?? "";
    return message;
  }
};
function createBaseQueryAccountResponse() {
  return { account: void 0 };
}
const QueryAccountResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.account !== void 0) {
      Any.encode(message.account, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryAccountResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = Any.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      account: isSet$7(object.account) ? Any.fromJSON(object.account) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.account !== void 0 && (obj.account = message.account ? Any.toJSON(message.account) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryAccountResponse();
    message.account = object.account !== void 0 && object.account !== null ? Any.fromPartial(object.account) : void 0;
    return message;
  }
};
function createBaseQueryParamsRequest() {
  return {};
}
const QueryParamsRequest = {
  encode(_, writer2 = minimal.Writer.create()) {
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryParamsRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(_) {
    return {};
  },
  toJSON(_) {
    const obj = {};
    return obj;
  },
  fromPartial(_) {
    const message = createBaseQueryParamsRequest();
    return message;
  }
};
function createBaseQueryParamsResponse() {
  return { params: void 0 };
}
const QueryParamsResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.params !== void 0) {
      Params.encode(message.params, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseQueryParamsResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.params = Params.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      params: isSet$7(object.params) ? Params.fromJSON(object.params) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.params !== void 0 && (obj.params = message.params ? Params.toJSON(message.params) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseQueryParamsResponse();
    message.params = object.params !== void 0 && object.params !== null ? Params.fromPartial(object.params) : void 0;
    return message;
  }
};
class QueryClientImpl {
  constructor(rpc2) {
    __publicField(this, "rpc");
    this.rpc = rpc2;
    this.accounts = this.accounts.bind(this);
    this.account = this.account.bind(this);
    this.params = this.params.bind(this);
  }
  accounts(request, metadata) {
    return this.rpc.unary(QueryAccountsDesc, QueryAccountsRequest.fromPartial(request), metadata);
  }
  account(request, metadata) {
    return this.rpc.unary(QueryAccountDesc, QueryAccountRequest.fromPartial(request), metadata);
  }
  params(request, metadata) {
    return this.rpc.unary(QueryParamsDesc, QueryParamsRequest.fromPartial(request), metadata);
  }
}
const QueryDesc = {
  serviceName: "cosmos.auth.v1beta1.Query"
};
const QueryAccountsDesc = {
  methodName: "Accounts",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryAccountsRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QueryAccountsResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const QueryAccountDesc = {
  methodName: "Account",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryAccountRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QueryAccountResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const QueryParamsDesc = {
  methodName: "Params",
  service: QueryDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return QueryParamsRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...QueryParamsResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
function isSet$7(value) {
  return value !== null && value !== void 0;
}
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
var globalThis$b = (() => {
  if (typeof globalThis$b !== "undefined")
    return globalThis$b;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
globalThis$b.atob || ((b64) => globalThis$b.Buffer.from(b64, "base64").toString("binary"));
globalThis$b.btoa || ((bin) => globalThis$b.Buffer.from(bin, "binary").toString("base64"));
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
var globalThis$a = (() => {
  if (typeof globalThis$a !== "undefined")
    return globalThis$a;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
globalThis$a.atob || ((b64) => globalThis$a.Buffer.from(b64, "base64").toString("binary"));
globalThis$a.btoa || ((bin) => globalThis$a.Buffer.from(bin, "binary").toString("base64"));
var globalThis$9 = (() => {
  if (typeof globalThis$9 !== "undefined")
    return globalThis$9;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
globalThis$9.atob || ((b64) => globalThis$9.Buffer.from(b64, "base64").toString("binary"));
globalThis$9.btoa || ((bin) => globalThis$9.Buffer.from(bin, "binary").toString("base64"));
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
var BlockIDFlag;
(function(BlockIDFlag2) {
  BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
  BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
  BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
  BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
  BlockIDFlag2[BlockIDFlag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockIDFlag || (BlockIDFlag = {}));
var SignedMsgType;
(function(SignedMsgType2) {
  SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
  SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
  SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
  SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
  SignedMsgType2[SignedMsgType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SignedMsgType || (SignedMsgType = {}));
var globalThis$8 = (() => {
  if (typeof globalThis$8 !== "undefined")
    return globalThis$8;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
globalThis$8.atob || ((b64) => globalThis$8.Buffer.from(b64, "base64").toString("binary"));
globalThis$8.btoa || ((bin) => globalThis$8.Buffer.from(bin, "binary").toString("base64"));
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
var CheckTxType;
(function(CheckTxType2) {
  CheckTxType2[CheckTxType2["NEW"] = 0] = "NEW";
  CheckTxType2[CheckTxType2["RECHECK"] = 1] = "RECHECK";
  CheckTxType2[CheckTxType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CheckTxType || (CheckTxType = {}));
var EvidenceType;
(function(EvidenceType2) {
  EvidenceType2[EvidenceType2["UNKNOWN"] = 0] = "UNKNOWN";
  EvidenceType2[EvidenceType2["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
  EvidenceType2[EvidenceType2["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
  EvidenceType2[EvidenceType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EvidenceType || (EvidenceType = {}));
var ResponseOfferSnapshot_Result;
(function(ResponseOfferSnapshot_Result2) {
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNKNOWN"] = 0] = "UNKNOWN";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ACCEPT"] = 1] = "ACCEPT";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ABORT"] = 2] = "ABORT";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT"] = 3] = "REJECT";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_SENDER"] = 5] = "REJECT_SENDER";
  ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseOfferSnapshot_Result || (ResponseOfferSnapshot_Result = {}));
var ResponseApplySnapshotChunk_Result;
(function(ResponseApplySnapshotChunk_Result2) {
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNKNOWN"] = 0] = "UNKNOWN";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ACCEPT"] = 1] = "ACCEPT";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ABORT"] = 2] = "ABORT";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY"] = 3] = "RETRY";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
  ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseApplySnapshotChunk_Result || (ResponseApplySnapshotChunk_Result = {}));
function createBaseEvent() {
  return { type: "", attributes: [] };
}
const Event$1 = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.type !== "") {
      writer2.uint32(10).string(message.type);
    }
    for (const v of message.attributes) {
      EventAttribute.encode(v, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader2.string();
          break;
        case 2:
          message.attributes.push(EventAttribute.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet$6(object.type) ? String(object.type) : "",
      attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => EventAttribute.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    if (message.attributes) {
      obj.attributes = message.attributes.map((e) => e ? EventAttribute.toJSON(e) : void 0);
    } else {
      obj.attributes = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEvent();
    message.type = object.type ?? "";
    message.attributes = object.attributes?.map((e) => EventAttribute.fromPartial(e)) || [];
    return message;
  }
};
function createBaseEventAttribute() {
  return { key: new Uint8Array(), value: new Uint8Array(), index: false };
}
const EventAttribute = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.key.length !== 0) {
      writer2.uint32(10).bytes(message.key);
    }
    if (message.value.length !== 0) {
      writer2.uint32(18).bytes(message.value);
    }
    if (message.index === true) {
      writer2.uint32(24).bool(message.index);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseEventAttribute();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader2.bytes();
          break;
        case 2:
          message.value = reader2.bytes();
          break;
        case 3:
          message.index = reader2.bool();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet$6(object.key) ? bytesFromBase64$5(object.key) : new Uint8Array(),
      value: isSet$6(object.value) ? bytesFromBase64$5(object.value) : new Uint8Array(),
      index: isSet$6(object.index) ? Boolean(object.index) : false
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes$5(message.key !== void 0 ? message.key : new Uint8Array()));
    message.value !== void 0 && (obj.value = base64FromBytes$5(message.value !== void 0 ? message.value : new Uint8Array()));
    message.index !== void 0 && (obj.index = message.index);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseEventAttribute();
    message.key = object.key ?? new Uint8Array();
    message.value = object.value ?? new Uint8Array();
    message.index = object.index ?? false;
    return message;
  }
};
var globalThis$7 = (() => {
  if (typeof globalThis$7 !== "undefined")
    return globalThis$7;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
const atob$5 = globalThis$7.atob || ((b64) => globalThis$7.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64$5(b64) {
  const bin = atob$5(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}
const btoa$5 = globalThis$7.btoa || ((bin) => globalThis$7.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes$5(arr) {
  const bin = [];
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte));
  });
  return btoa$5(bin.join(""));
}
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
function isSet$6(value) {
  return value !== null && value !== void 0;
}
function createBaseTxResponse() {
  return {
    height: "0",
    txhash: "",
    codespace: "",
    code: 0,
    data: "",
    rawLog: "",
    logs: [],
    info: "",
    gasWanted: "0",
    gasUsed: "0",
    tx: void 0,
    timestamp: "",
    events: []
  };
}
const TxResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.height !== "0") {
      writer2.uint32(8).int64(message.height);
    }
    if (message.txhash !== "") {
      writer2.uint32(18).string(message.txhash);
    }
    if (message.codespace !== "") {
      writer2.uint32(26).string(message.codespace);
    }
    if (message.code !== 0) {
      writer2.uint32(32).uint32(message.code);
    }
    if (message.data !== "") {
      writer2.uint32(42).string(message.data);
    }
    if (message.rawLog !== "") {
      writer2.uint32(50).string(message.rawLog);
    }
    for (const v of message.logs) {
      ABCIMessageLog.encode(v, writer2.uint32(58).fork()).ldelim();
    }
    if (message.info !== "") {
      writer2.uint32(66).string(message.info);
    }
    if (message.gasWanted !== "0") {
      writer2.uint32(72).int64(message.gasWanted);
    }
    if (message.gasUsed !== "0") {
      writer2.uint32(80).int64(message.gasUsed);
    }
    if (message.tx !== void 0) {
      Any.encode(message.tx, writer2.uint32(90).fork()).ldelim();
    }
    if (message.timestamp !== "") {
      writer2.uint32(98).string(message.timestamp);
    }
    for (const v of message.events) {
      Event$1.encode(v, writer2.uint32(106).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTxResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = longToString$1(reader2.int64());
          break;
        case 2:
          message.txhash = reader2.string();
          break;
        case 3:
          message.codespace = reader2.string();
          break;
        case 4:
          message.code = reader2.uint32();
          break;
        case 5:
          message.data = reader2.string();
          break;
        case 6:
          message.rawLog = reader2.string();
          break;
        case 7:
          message.logs.push(ABCIMessageLog.decode(reader2, reader2.uint32()));
          break;
        case 8:
          message.info = reader2.string();
          break;
        case 9:
          message.gasWanted = longToString$1(reader2.int64());
          break;
        case 10:
          message.gasUsed = longToString$1(reader2.int64());
          break;
        case 11:
          message.tx = Any.decode(reader2, reader2.uint32());
          break;
        case 12:
          message.timestamp = reader2.string();
          break;
        case 13:
          message.events.push(Event$1.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      height: isSet$5(object.height) ? String(object.height) : "0",
      txhash: isSet$5(object.txhash) ? String(object.txhash) : "",
      codespace: isSet$5(object.codespace) ? String(object.codespace) : "",
      code: isSet$5(object.code) ? Number(object.code) : 0,
      data: isSet$5(object.data) ? String(object.data) : "",
      rawLog: isSet$5(object.rawLog) ? String(object.rawLog) : "",
      logs: Array.isArray(object?.logs) ? object.logs.map((e) => ABCIMessageLog.fromJSON(e)) : [],
      info: isSet$5(object.info) ? String(object.info) : "",
      gasWanted: isSet$5(object.gasWanted) ? String(object.gasWanted) : "0",
      gasUsed: isSet$5(object.gasUsed) ? String(object.gasUsed) : "0",
      tx: isSet$5(object.tx) ? Any.fromJSON(object.tx) : void 0,
      timestamp: isSet$5(object.timestamp) ? String(object.timestamp) : "",
      events: Array.isArray(object?.events) ? object.events.map((e) => Event$1.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.height !== void 0 && (obj.height = message.height);
    message.txhash !== void 0 && (obj.txhash = message.txhash);
    message.codespace !== void 0 && (obj.codespace = message.codespace);
    message.code !== void 0 && (obj.code = Math.round(message.code));
    message.data !== void 0 && (obj.data = message.data);
    message.rawLog !== void 0 && (obj.rawLog = message.rawLog);
    if (message.logs) {
      obj.logs = message.logs.map((e) => e ? ABCIMessageLog.toJSON(e) : void 0);
    } else {
      obj.logs = [];
    }
    message.info !== void 0 && (obj.info = message.info);
    message.gasWanted !== void 0 && (obj.gasWanted = message.gasWanted);
    message.gasUsed !== void 0 && (obj.gasUsed = message.gasUsed);
    message.tx !== void 0 && (obj.tx = message.tx ? Any.toJSON(message.tx) : void 0);
    message.timestamp !== void 0 && (obj.timestamp = message.timestamp);
    if (message.events) {
      obj.events = message.events.map((e) => e ? Event$1.toJSON(e) : void 0);
    } else {
      obj.events = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTxResponse();
    message.height = object.height ?? "0";
    message.txhash = object.txhash ?? "";
    message.codespace = object.codespace ?? "";
    message.code = object.code ?? 0;
    message.data = object.data ?? "";
    message.rawLog = object.rawLog ?? "";
    message.logs = object.logs?.map((e) => ABCIMessageLog.fromPartial(e)) || [];
    message.info = object.info ?? "";
    message.gasWanted = object.gasWanted ?? "0";
    message.gasUsed = object.gasUsed ?? "0";
    message.tx = object.tx !== void 0 && object.tx !== null ? Any.fromPartial(object.tx) : void 0;
    message.timestamp = object.timestamp ?? "";
    message.events = object.events?.map((e) => Event$1.fromPartial(e)) || [];
    return message;
  }
};
function createBaseABCIMessageLog() {
  return { msgIndex: 0, log: "", events: [] };
}
const ABCIMessageLog = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.msgIndex !== 0) {
      writer2.uint32(8).uint32(message.msgIndex);
    }
    if (message.log !== "") {
      writer2.uint32(18).string(message.log);
    }
    for (const v of message.events) {
      StringEvent.encode(v, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseABCIMessageLog();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msgIndex = reader2.uint32();
          break;
        case 2:
          message.log = reader2.string();
          break;
        case 3:
          message.events.push(StringEvent.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      msgIndex: isSet$5(object.msgIndex) ? Number(object.msgIndex) : 0,
      log: isSet$5(object.log) ? String(object.log) : "",
      events: Array.isArray(object?.events) ? object.events.map((e) => StringEvent.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.msgIndex !== void 0 && (obj.msgIndex = Math.round(message.msgIndex));
    message.log !== void 0 && (obj.log = message.log);
    if (message.events) {
      obj.events = message.events.map((e) => e ? StringEvent.toJSON(e) : void 0);
    } else {
      obj.events = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseABCIMessageLog();
    message.msgIndex = object.msgIndex ?? 0;
    message.log = object.log ?? "";
    message.events = object.events?.map((e) => StringEvent.fromPartial(e)) || [];
    return message;
  }
};
function createBaseStringEvent() {
  return { type: "", attributes: [] };
}
const StringEvent = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.type !== "") {
      writer2.uint32(10).string(message.type);
    }
    for (const v of message.attributes) {
      Attribute.encode(v, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseStringEvent();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader2.string();
          break;
        case 2:
          message.attributes.push(Attribute.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      type: isSet$5(object.type) ? String(object.type) : "",
      attributes: Array.isArray(object?.attributes) ? object.attributes.map((e) => Attribute.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.type !== void 0 && (obj.type = message.type);
    if (message.attributes) {
      obj.attributes = message.attributes.map((e) => e ? Attribute.toJSON(e) : void 0);
    } else {
      obj.attributes = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseStringEvent();
    message.type = object.type ?? "";
    message.attributes = object.attributes?.map((e) => Attribute.fromPartial(e)) || [];
    return message;
  }
};
function createBaseAttribute() {
  return { key: "", value: "" };
}
const Attribute = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.key !== "") {
      writer2.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer2.uint32(18).string(message.value);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseAttribute();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader2.string();
          break;
        case 2:
          message.value = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet$5(object.key) ? String(object.key) : "",
      value: isSet$5(object.value) ? String(object.value) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = message.key);
    message.value !== void 0 && (obj.value = message.value);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAttribute();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  }
};
function createBaseGasInfo() {
  return { gasWanted: "0", gasUsed: "0" };
}
const GasInfo = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.gasWanted !== "0") {
      writer2.uint32(8).uint64(message.gasWanted);
    }
    if (message.gasUsed !== "0") {
      writer2.uint32(16).uint64(message.gasUsed);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGasInfo();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gasWanted = longToString$1(reader2.uint64());
          break;
        case 2:
          message.gasUsed = longToString$1(reader2.uint64());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      gasWanted: isSet$5(object.gasWanted) ? String(object.gasWanted) : "0",
      gasUsed: isSet$5(object.gasUsed) ? String(object.gasUsed) : "0"
    };
  },
  toJSON(message) {
    const obj = {};
    message.gasWanted !== void 0 && (obj.gasWanted = message.gasWanted);
    message.gasUsed !== void 0 && (obj.gasUsed = message.gasUsed);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGasInfo();
    message.gasWanted = object.gasWanted ?? "0";
    message.gasUsed = object.gasUsed ?? "0";
    return message;
  }
};
function createBaseResult() {
  return { data: new Uint8Array(), log: "", events: [] };
}
const Result = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.data.length !== 0) {
      writer2.uint32(10).bytes(message.data);
    }
    if (message.log !== "") {
      writer2.uint32(18).string(message.log);
    }
    for (const v of message.events) {
      Event$1.encode(v, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseResult();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.data = reader2.bytes();
          break;
        case 2:
          message.log = reader2.string();
          break;
        case 3:
          message.events.push(Event$1.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      data: isSet$5(object.data) ? bytesFromBase64$4(object.data) : new Uint8Array(),
      log: isSet$5(object.log) ? String(object.log) : "",
      events: Array.isArray(object?.events) ? object.events.map((e) => Event$1.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.data !== void 0 && (obj.data = base64FromBytes$4(message.data !== void 0 ? message.data : new Uint8Array()));
    message.log !== void 0 && (obj.log = message.log);
    if (message.events) {
      obj.events = message.events.map((e) => e ? Event$1.toJSON(e) : void 0);
    } else {
      obj.events = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseResult();
    message.data = object.data ?? new Uint8Array();
    message.log = object.log ?? "";
    message.events = object.events?.map((e) => Event$1.fromPartial(e)) || [];
    return message;
  }
};
var globalThis$6 = (() => {
  if (typeof globalThis$6 !== "undefined")
    return globalThis$6;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
const atob$4 = globalThis$6.atob || ((b64) => globalThis$6.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64$4(b64) {
  const bin = atob$4(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}
const btoa$4 = globalThis$6.btoa || ((bin) => globalThis$6.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes$4(arr) {
  const bin = [];
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte));
  });
  return btoa$4(bin.join(""));
}
function longToString$1(long2) {
  return long2.toString();
}
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
function isSet$5(value) {
  return value !== null && value !== void 0;
}
function createBaseCompactBitArray() {
  return { extraBitsStored: 0, elems: new Uint8Array() };
}
const CompactBitArray = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.extraBitsStored !== 0) {
      writer2.uint32(8).uint32(message.extraBitsStored);
    }
    if (message.elems.length !== 0) {
      writer2.uint32(18).bytes(message.elems);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseCompactBitArray();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.extraBitsStored = reader2.uint32();
          break;
        case 2:
          message.elems = reader2.bytes();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      extraBitsStored: isSet$4(object.extraBitsStored) ? Number(object.extraBitsStored) : 0,
      elems: isSet$4(object.elems) ? bytesFromBase64$3(object.elems) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.extraBitsStored !== void 0 && (obj.extraBitsStored = Math.round(message.extraBitsStored));
    message.elems !== void 0 && (obj.elems = base64FromBytes$3(message.elems !== void 0 ? message.elems : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseCompactBitArray();
    message.extraBitsStored = object.extraBitsStored ?? 0;
    message.elems = object.elems ?? new Uint8Array();
    return message;
  }
};
var globalThis$5 = (() => {
  if (typeof globalThis$5 !== "undefined")
    return globalThis$5;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
const atob$3 = globalThis$5.atob || ((b64) => globalThis$5.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64$3(b64) {
  const bin = atob$3(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}
const btoa$3 = globalThis$5.btoa || ((bin) => globalThis$5.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes$3(arr) {
  const bin = [];
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte));
  });
  return btoa$3(bin.join(""));
}
function isSet$4(value) {
  return value !== null && value !== void 0;
}
var SignMode;
(function(SignMode2) {
  SignMode2[SignMode2["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
  SignMode2[SignMode2["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
  SignMode2[SignMode2["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
  SignMode2[SignMode2["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
  SignMode2[SignMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SignMode || (SignMode = {}));
function signModeFromJSON(object) {
  switch (object) {
    case 0:
    case "SIGN_MODE_UNSPECIFIED":
      return SignMode.SIGN_MODE_UNSPECIFIED;
    case 1:
    case "SIGN_MODE_DIRECT":
      return SignMode.SIGN_MODE_DIRECT;
    case 2:
    case "SIGN_MODE_TEXTUAL":
      return SignMode.SIGN_MODE_TEXTUAL;
    case 127:
    case "SIGN_MODE_LEGACY_AMINO_JSON":
      return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SignMode.UNRECOGNIZED;
  }
}
function signModeToJSON(object) {
  switch (object) {
    case SignMode.SIGN_MODE_UNSPECIFIED:
      return "SIGN_MODE_UNSPECIFIED";
    case SignMode.SIGN_MODE_DIRECT:
      return "SIGN_MODE_DIRECT";
    case SignMode.SIGN_MODE_TEXTUAL:
      return "SIGN_MODE_TEXTUAL";
    case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
      return "SIGN_MODE_LEGACY_AMINO_JSON";
    case SignMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var globalThis$4 = (() => {
  if (typeof globalThis$4 !== "undefined")
    return globalThis$4;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
globalThis$4.atob || ((b64) => globalThis$4.Buffer.from(b64, "base64").toString("binary"));
globalThis$4.btoa || ((bin) => globalThis$4.Buffer.from(bin, "binary").toString("base64"));
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
function createBaseTx() {
  return { body: void 0, authInfo: void 0, signatures: [] };
}
const Tx = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.body !== void 0) {
      TxBody.encode(message.body, writer2.uint32(10).fork()).ldelim();
    }
    if (message.authInfo !== void 0) {
      AuthInfo.encode(message.authInfo, writer2.uint32(18).fork()).ldelim();
    }
    for (const v of message.signatures) {
      writer2.uint32(26).bytes(v);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTx();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.body = TxBody.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.authInfo = AuthInfo.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.signatures.push(reader2.bytes());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      body: isSet$3(object.body) ? TxBody.fromJSON(object.body) : void 0,
      authInfo: isSet$3(object.authInfo) ? AuthInfo.fromJSON(object.authInfo) : void 0,
      signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => bytesFromBase64$2(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.body !== void 0 && (obj.body = message.body ? TxBody.toJSON(message.body) : void 0);
    message.authInfo !== void 0 && (obj.authInfo = message.authInfo ? AuthInfo.toJSON(message.authInfo) : void 0);
    if (message.signatures) {
      obj.signatures = message.signatures.map((e) => base64FromBytes$2(e !== void 0 ? e : new Uint8Array()));
    } else {
      obj.signatures = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTx();
    message.body = object.body !== void 0 && object.body !== null ? TxBody.fromPartial(object.body) : void 0;
    message.authInfo = object.authInfo !== void 0 && object.authInfo !== null ? AuthInfo.fromPartial(object.authInfo) : void 0;
    message.signatures = object.signatures?.map((e) => e) || [];
    return message;
  }
};
function createBaseTxRaw() {
  return {
    bodyBytes: new Uint8Array(),
    authInfoBytes: new Uint8Array(),
    signatures: []
  };
}
const TxRaw = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.bodyBytes.length !== 0) {
      writer2.uint32(10).bytes(message.bodyBytes);
    }
    if (message.authInfoBytes.length !== 0) {
      writer2.uint32(18).bytes(message.authInfoBytes);
    }
    for (const v of message.signatures) {
      writer2.uint32(26).bytes(v);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTxRaw();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bodyBytes = reader2.bytes();
          break;
        case 2:
          message.authInfoBytes = reader2.bytes();
          break;
        case 3:
          message.signatures.push(reader2.bytes());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bodyBytes: isSet$3(object.bodyBytes) ? bytesFromBase64$2(object.bodyBytes) : new Uint8Array(),
      authInfoBytes: isSet$3(object.authInfoBytes) ? bytesFromBase64$2(object.authInfoBytes) : new Uint8Array(),
      signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => bytesFromBase64$2(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.bodyBytes !== void 0 && (obj.bodyBytes = base64FromBytes$2(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
    message.authInfoBytes !== void 0 && (obj.authInfoBytes = base64FromBytes$2(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
    if (message.signatures) {
      obj.signatures = message.signatures.map((e) => base64FromBytes$2(e !== void 0 ? e : new Uint8Array()));
    } else {
      obj.signatures = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTxRaw();
    message.bodyBytes = object.bodyBytes ?? new Uint8Array();
    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
    message.signatures = object.signatures?.map((e) => e) || [];
    return message;
  }
};
function createBaseSignDoc() {
  return {
    bodyBytes: new Uint8Array(),
    authInfoBytes: new Uint8Array(),
    chainId: "",
    accountNumber: "0"
  };
}
const SignDoc = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.bodyBytes.length !== 0) {
      writer2.uint32(10).bytes(message.bodyBytes);
    }
    if (message.authInfoBytes.length !== 0) {
      writer2.uint32(18).bytes(message.authInfoBytes);
    }
    if (message.chainId !== "") {
      writer2.uint32(26).string(message.chainId);
    }
    if (message.accountNumber !== "0") {
      writer2.uint32(32).uint64(message.accountNumber);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSignDoc();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bodyBytes = reader2.bytes();
          break;
        case 2:
          message.authInfoBytes = reader2.bytes();
          break;
        case 3:
          message.chainId = reader2.string();
          break;
        case 4:
          message.accountNumber = longToString(reader2.uint64());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bodyBytes: isSet$3(object.bodyBytes) ? bytesFromBase64$2(object.bodyBytes) : new Uint8Array(),
      authInfoBytes: isSet$3(object.authInfoBytes) ? bytesFromBase64$2(object.authInfoBytes) : new Uint8Array(),
      chainId: isSet$3(object.chainId) ? String(object.chainId) : "",
      accountNumber: isSet$3(object.accountNumber) ? String(object.accountNumber) : "0"
    };
  },
  toJSON(message) {
    const obj = {};
    message.bodyBytes !== void 0 && (obj.bodyBytes = base64FromBytes$2(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
    message.authInfoBytes !== void 0 && (obj.authInfoBytes = base64FromBytes$2(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
    message.chainId !== void 0 && (obj.chainId = message.chainId);
    message.accountNumber !== void 0 && (obj.accountNumber = message.accountNumber);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSignDoc();
    message.bodyBytes = object.bodyBytes ?? new Uint8Array();
    message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
    message.chainId = object.chainId ?? "";
    message.accountNumber = object.accountNumber ?? "0";
    return message;
  }
};
function createBaseTxBody() {
  return {
    messages: [],
    memo: "",
    timeoutHeight: "0",
    extensionOptions: [],
    nonCriticalExtensionOptions: []
  };
}
const TxBody = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.messages) {
      Any.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    if (message.memo !== "") {
      writer2.uint32(18).string(message.memo);
    }
    if (message.timeoutHeight !== "0") {
      writer2.uint32(24).uint64(message.timeoutHeight);
    }
    for (const v of message.extensionOptions) {
      Any.encode(v, writer2.uint32(8186).fork()).ldelim();
    }
    for (const v of message.nonCriticalExtensionOptions) {
      Any.encode(v, writer2.uint32(16378).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseTxBody();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.messages.push(Any.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.memo = reader2.string();
          break;
        case 3:
          message.timeoutHeight = longToString(reader2.uint64());
          break;
        case 1023:
          message.extensionOptions.push(Any.decode(reader2, reader2.uint32()));
          break;
        case 2047:
          message.nonCriticalExtensionOptions.push(Any.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      messages: Array.isArray(object?.messages) ? object.messages.map((e) => Any.fromJSON(e)) : [],
      memo: isSet$3(object.memo) ? String(object.memo) : "",
      timeoutHeight: isSet$3(object.timeoutHeight) ? String(object.timeoutHeight) : "0",
      extensionOptions: Array.isArray(object?.extensionOptions) ? object.extensionOptions.map((e) => Any.fromJSON(e)) : [],
      nonCriticalExtensionOptions: Array.isArray(object?.nonCriticalExtensionOptions) ? object.nonCriticalExtensionOptions.map((e) => Any.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.messages) {
      obj.messages = message.messages.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.messages = [];
    }
    message.memo !== void 0 && (obj.memo = message.memo);
    message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight);
    if (message.extensionOptions) {
      obj.extensionOptions = message.extensionOptions.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.extensionOptions = [];
    }
    if (message.nonCriticalExtensionOptions) {
      obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => e ? Any.toJSON(e) : void 0);
    } else {
      obj.nonCriticalExtensionOptions = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseTxBody();
    message.messages = object.messages?.map((e) => Any.fromPartial(e)) || [];
    message.memo = object.memo ?? "";
    message.timeoutHeight = object.timeoutHeight ?? "0";
    message.extensionOptions = object.extensionOptions?.map((e) => Any.fromPartial(e)) || [];
    message.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions?.map((e) => Any.fromPartial(e)) || [];
    return message;
  }
};
function createBaseAuthInfo() {
  return { signerInfos: [], fee: void 0 };
}
const AuthInfo = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.signerInfos) {
      SignerInfo.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    if (message.fee !== void 0) {
      Fee.encode(message.fee, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseAuthInfo();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signerInfos.push(SignerInfo.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.fee = Fee.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      signerInfos: Array.isArray(object?.signerInfos) ? object.signerInfos.map((e) => SignerInfo.fromJSON(e)) : [],
      fee: isSet$3(object.fee) ? Fee.fromJSON(object.fee) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.signerInfos) {
      obj.signerInfos = message.signerInfos.map((e) => e ? SignerInfo.toJSON(e) : void 0);
    } else {
      obj.signerInfos = [];
    }
    message.fee !== void 0 && (obj.fee = message.fee ? Fee.toJSON(message.fee) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseAuthInfo();
    message.signerInfos = object.signerInfos?.map((e) => SignerInfo.fromPartial(e)) || [];
    message.fee = object.fee !== void 0 && object.fee !== null ? Fee.fromPartial(object.fee) : void 0;
    return message;
  }
};
function createBaseSignerInfo() {
  return { publicKey: void 0, modeInfo: void 0, sequence: "0" };
}
const SignerInfo = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.publicKey !== void 0) {
      Any.encode(message.publicKey, writer2.uint32(10).fork()).ldelim();
    }
    if (message.modeInfo !== void 0) {
      ModeInfo.encode(message.modeInfo, writer2.uint32(18).fork()).ldelim();
    }
    if (message.sequence !== "0") {
      writer2.uint32(24).uint64(message.sequence);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSignerInfo();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.publicKey = Any.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.modeInfo = ModeInfo.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.sequence = longToString(reader2.uint64());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      publicKey: isSet$3(object.publicKey) ? Any.fromJSON(object.publicKey) : void 0,
      modeInfo: isSet$3(object.modeInfo) ? ModeInfo.fromJSON(object.modeInfo) : void 0,
      sequence: isSet$3(object.sequence) ? String(object.sequence) : "0"
    };
  },
  toJSON(message) {
    const obj = {};
    message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? Any.toJSON(message.publicKey) : void 0);
    message.modeInfo !== void 0 && (obj.modeInfo = message.modeInfo ? ModeInfo.toJSON(message.modeInfo) : void 0);
    message.sequence !== void 0 && (obj.sequence = message.sequence);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSignerInfo();
    message.publicKey = object.publicKey !== void 0 && object.publicKey !== null ? Any.fromPartial(object.publicKey) : void 0;
    message.modeInfo = object.modeInfo !== void 0 && object.modeInfo !== null ? ModeInfo.fromPartial(object.modeInfo) : void 0;
    message.sequence = object.sequence ?? "0";
    return message;
  }
};
function createBaseModeInfo() {
  return { single: void 0, multi: void 0 };
}
const ModeInfo = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.single !== void 0) {
      ModeInfo_Single.encode(message.single, writer2.uint32(10).fork()).ldelim();
    }
    if (message.multi !== void 0) {
      ModeInfo_Multi.encode(message.multi, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseModeInfo();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.single = ModeInfo_Single.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.multi = ModeInfo_Multi.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      single: isSet$3(object.single) ? ModeInfo_Single.fromJSON(object.single) : void 0,
      multi: isSet$3(object.multi) ? ModeInfo_Multi.fromJSON(object.multi) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.single !== void 0 && (obj.single = message.single ? ModeInfo_Single.toJSON(message.single) : void 0);
    message.multi !== void 0 && (obj.multi = message.multi ? ModeInfo_Multi.toJSON(message.multi) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModeInfo();
    message.single = object.single !== void 0 && object.single !== null ? ModeInfo_Single.fromPartial(object.single) : void 0;
    message.multi = object.multi !== void 0 && object.multi !== null ? ModeInfo_Multi.fromPartial(object.multi) : void 0;
    return message;
  }
};
function createBaseModeInfo_Single() {
  return { mode: 0 };
}
const ModeInfo_Single = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.mode !== 0) {
      writer2.uint32(8).int32(message.mode);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseModeInfo_Single();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.mode = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      mode: isSet$3(object.mode) ? signModeFromJSON(object.mode) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.mode !== void 0 && (obj.mode = signModeToJSON(message.mode));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModeInfo_Single();
    message.mode = object.mode ?? 0;
    return message;
  }
};
function createBaseModeInfo_Multi() {
  return { bitarray: void 0, modeInfos: [] };
}
const ModeInfo_Multi = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.bitarray !== void 0) {
      CompactBitArray.encode(message.bitarray, writer2.uint32(10).fork()).ldelim();
    }
    for (const v of message.modeInfos) {
      ModeInfo.encode(v, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseModeInfo_Multi();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bitarray = CompactBitArray.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.modeInfos.push(ModeInfo.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      bitarray: isSet$3(object.bitarray) ? CompactBitArray.fromJSON(object.bitarray) : void 0,
      modeInfos: Array.isArray(object?.modeInfos) ? object.modeInfos.map((e) => ModeInfo.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? CompactBitArray.toJSON(message.bitarray) : void 0);
    if (message.modeInfos) {
      obj.modeInfos = message.modeInfos.map((e) => e ? ModeInfo.toJSON(e) : void 0);
    } else {
      obj.modeInfos = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseModeInfo_Multi();
    message.bitarray = object.bitarray !== void 0 && object.bitarray !== null ? CompactBitArray.fromPartial(object.bitarray) : void 0;
    message.modeInfos = object.modeInfos?.map((e) => ModeInfo.fromPartial(e)) || [];
    return message;
  }
};
function createBaseFee() {
  return { amount: [], gasLimit: "0", payer: "", granter: "" };
}
const Fee = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.amount) {
      Coin.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    if (message.gasLimit !== "0") {
      writer2.uint32(16).uint64(message.gasLimit);
    }
    if (message.payer !== "") {
      writer2.uint32(26).string(message.payer);
    }
    if (message.granter !== "") {
      writer2.uint32(34).string(message.granter);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseFee();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.amount.push(Coin.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.gasLimit = longToString(reader2.uint64());
          break;
        case 3:
          message.payer = reader2.string();
          break;
        case 4:
          message.granter = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      amount: Array.isArray(object?.amount) ? object.amount.map((e) => Coin.fromJSON(e)) : [],
      gasLimit: isSet$3(object.gasLimit) ? String(object.gasLimit) : "0",
      payer: isSet$3(object.payer) ? String(object.payer) : "",
      granter: isSet$3(object.granter) ? String(object.granter) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.amount) {
      obj.amount = message.amount.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.amount = [];
    }
    message.gasLimit !== void 0 && (obj.gasLimit = message.gasLimit);
    message.payer !== void 0 && (obj.payer = message.payer);
    message.granter !== void 0 && (obj.granter = message.granter);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseFee();
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    message.gasLimit = object.gasLimit ?? "0";
    message.payer = object.payer ?? "";
    message.granter = object.granter ?? "";
    return message;
  }
};
var globalThis$3 = (() => {
  if (typeof globalThis$3 !== "undefined")
    return globalThis$3;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
const atob$2 = globalThis$3.atob || ((b64) => globalThis$3.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64$2(b64) {
  const bin = atob$2(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}
const btoa$2 = globalThis$3.btoa || ((bin) => globalThis$3.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes$2(arr) {
  const bin = [];
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte));
  });
  return btoa$2(bin.join(""));
}
function longToString(long2) {
  return long2.toString();
}
if (minimal.util.Long !== long) {
  minimal.util.Long = long;
  minimal.configure();
}
function isSet$3(value) {
  return value !== null && value !== void 0;
}
var OrderBy;
(function(OrderBy2) {
  OrderBy2[OrderBy2["ORDER_BY_UNSPECIFIED"] = 0] = "ORDER_BY_UNSPECIFIED";
  OrderBy2[OrderBy2["ORDER_BY_ASC"] = 1] = "ORDER_BY_ASC";
  OrderBy2[OrderBy2["ORDER_BY_DESC"] = 2] = "ORDER_BY_DESC";
  OrderBy2[OrderBy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OrderBy || (OrderBy = {}));
function orderByFromJSON(object) {
  switch (object) {
    case 0:
    case "ORDER_BY_UNSPECIFIED":
      return OrderBy.ORDER_BY_UNSPECIFIED;
    case 1:
    case "ORDER_BY_ASC":
      return OrderBy.ORDER_BY_ASC;
    case 2:
    case "ORDER_BY_DESC":
      return OrderBy.ORDER_BY_DESC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderBy.UNRECOGNIZED;
  }
}
function orderByToJSON(object) {
  switch (object) {
    case OrderBy.ORDER_BY_UNSPECIFIED:
      return "ORDER_BY_UNSPECIFIED";
    case OrderBy.ORDER_BY_ASC:
      return "ORDER_BY_ASC";
    case OrderBy.ORDER_BY_DESC:
      return "ORDER_BY_DESC";
    case OrderBy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
var BroadcastMode;
(function(BroadcastMode2) {
  BroadcastMode2[BroadcastMode2["BROADCAST_MODE_UNSPECIFIED"] = 0] = "BROADCAST_MODE_UNSPECIFIED";
  BroadcastMode2[BroadcastMode2["BROADCAST_MODE_BLOCK"] = 1] = "BROADCAST_MODE_BLOCK";
  BroadcastMode2[BroadcastMode2["BROADCAST_MODE_SYNC"] = 2] = "BROADCAST_MODE_SYNC";
  BroadcastMode2[BroadcastMode2["BROADCAST_MODE_ASYNC"] = 3] = "BROADCAST_MODE_ASYNC";
  BroadcastMode2[BroadcastMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BroadcastMode || (BroadcastMode = {}));
function broadcastModeFromJSON(object) {
  switch (object) {
    case 0:
    case "BROADCAST_MODE_UNSPECIFIED":
      return BroadcastMode.BROADCAST_MODE_UNSPECIFIED;
    case 1:
    case "BROADCAST_MODE_BLOCK":
      return BroadcastMode.BROADCAST_MODE_BLOCK;
    case 2:
    case "BROADCAST_MODE_SYNC":
      return BroadcastMode.BROADCAST_MODE_SYNC;
    case 3:
    case "BROADCAST_MODE_ASYNC":
      return BroadcastMode.BROADCAST_MODE_ASYNC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BroadcastMode.UNRECOGNIZED;
  }
}
function broadcastModeToJSON(object) {
  switch (object) {
    case BroadcastMode.BROADCAST_MODE_UNSPECIFIED:
      return "BROADCAST_MODE_UNSPECIFIED";
    case BroadcastMode.BROADCAST_MODE_BLOCK:
      return "BROADCAST_MODE_BLOCK";
    case BroadcastMode.BROADCAST_MODE_SYNC:
      return "BROADCAST_MODE_SYNC";
    case BroadcastMode.BROADCAST_MODE_ASYNC:
      return "BROADCAST_MODE_ASYNC";
    case BroadcastMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}
function createBaseGetTxsEventRequest() {
  return { events: [], pagination: void 0, orderBy: 0 };
}
const GetTxsEventRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.events) {
      writer2.uint32(10).string(v);
    }
    if (message.pagination !== void 0) {
      PageRequest.encode(message.pagination, writer2.uint32(18).fork()).ldelim();
    }
    if (message.orderBy !== 0) {
      writer2.uint32(24).int32(message.orderBy);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetTxsEventRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.events.push(reader2.string());
          break;
        case 2:
          message.pagination = PageRequest.decode(reader2, reader2.uint32());
          break;
        case 3:
          message.orderBy = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      events: Array.isArray(object?.events) ? object.events.map((e) => String(e)) : [],
      pagination: isSet$2(object.pagination) ? PageRequest.fromJSON(object.pagination) : void 0,
      orderBy: isSet$2(object.orderBy) ? orderByFromJSON(object.orderBy) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.events) {
      obj.events = message.events.map((e) => e);
    } else {
      obj.events = [];
    }
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageRequest.toJSON(message.pagination) : void 0);
    message.orderBy !== void 0 && (obj.orderBy = orderByToJSON(message.orderBy));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetTxsEventRequest();
    message.events = object.events?.map((e) => e) || [];
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageRequest.fromPartial(object.pagination) : void 0;
    message.orderBy = object.orderBy ?? 0;
    return message;
  }
};
function createBaseGetTxsEventResponse() {
  return { txs: [], txResponses: [], pagination: void 0 };
}
const GetTxsEventResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    for (const v of message.txs) {
      Tx.encode(v, writer2.uint32(10).fork()).ldelim();
    }
    for (const v of message.txResponses) {
      TxResponse.encode(v, writer2.uint32(18).fork()).ldelim();
    }
    if (message.pagination !== void 0) {
      PageResponse.encode(message.pagination, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetTxsEventResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.txs.push(Tx.decode(reader2, reader2.uint32()));
          break;
        case 2:
          message.txResponses.push(TxResponse.decode(reader2, reader2.uint32()));
          break;
        case 3:
          message.pagination = PageResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      txs: Array.isArray(object?.txs) ? object.txs.map((e) => Tx.fromJSON(e)) : [],
      txResponses: Array.isArray(object?.txResponses) ? object.txResponses.map((e) => TxResponse.fromJSON(e)) : [],
      pagination: isSet$2(object.pagination) ? PageResponse.fromJSON(object.pagination) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.txs) {
      obj.txs = message.txs.map((e) => e ? Tx.toJSON(e) : void 0);
    } else {
      obj.txs = [];
    }
    if (message.txResponses) {
      obj.txResponses = message.txResponses.map((e) => e ? TxResponse.toJSON(e) : void 0);
    } else {
      obj.txResponses = [];
    }
    message.pagination !== void 0 && (obj.pagination = message.pagination ? PageResponse.toJSON(message.pagination) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetTxsEventResponse();
    message.txs = object.txs?.map((e) => Tx.fromPartial(e)) || [];
    message.txResponses = object.txResponses?.map((e) => TxResponse.fromPartial(e)) || [];
    message.pagination = object.pagination !== void 0 && object.pagination !== null ? PageResponse.fromPartial(object.pagination) : void 0;
    return message;
  }
};
function createBaseBroadcastTxRequest() {
  return { txBytes: new Uint8Array(), mode: 0 };
}
const BroadcastTxRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.txBytes.length !== 0) {
      writer2.uint32(10).bytes(message.txBytes);
    }
    if (message.mode !== 0) {
      writer2.uint32(16).int32(message.mode);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseBroadcastTxRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.txBytes = reader2.bytes();
          break;
        case 2:
          message.mode = reader2.int32();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      txBytes: isSet$2(object.txBytes) ? bytesFromBase64$1(object.txBytes) : new Uint8Array(),
      mode: isSet$2(object.mode) ? broadcastModeFromJSON(object.mode) : 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.txBytes !== void 0 && (obj.txBytes = base64FromBytes$1(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
    message.mode !== void 0 && (obj.mode = broadcastModeToJSON(message.mode));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBroadcastTxRequest();
    message.txBytes = object.txBytes ?? new Uint8Array();
    message.mode = object.mode ?? 0;
    return message;
  }
};
function createBaseBroadcastTxResponse() {
  return { txResponse: void 0 };
}
const BroadcastTxResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.txResponse !== void 0) {
      TxResponse.encode(message.txResponse, writer2.uint32(10).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseBroadcastTxResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.txResponse = TxResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      txResponse: isSet$2(object.txResponse) ? TxResponse.fromJSON(object.txResponse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? TxResponse.toJSON(message.txResponse) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseBroadcastTxResponse();
    message.txResponse = object.txResponse !== void 0 && object.txResponse !== null ? TxResponse.fromPartial(object.txResponse) : void 0;
    return message;
  }
};
function createBaseSimulateRequest() {
  return { tx: void 0, txBytes: new Uint8Array() };
}
const SimulateRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.tx !== void 0) {
      Tx.encode(message.tx, writer2.uint32(10).fork()).ldelim();
    }
    if (message.txBytes.length !== 0) {
      writer2.uint32(18).bytes(message.txBytes);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSimulateRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tx = Tx.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.txBytes = reader2.bytes();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      tx: isSet$2(object.tx) ? Tx.fromJSON(object.tx) : void 0,
      txBytes: isSet$2(object.txBytes) ? bytesFromBase64$1(object.txBytes) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.tx !== void 0 && (obj.tx = message.tx ? Tx.toJSON(message.tx) : void 0);
    message.txBytes !== void 0 && (obj.txBytes = base64FromBytes$1(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSimulateRequest();
    message.tx = object.tx !== void 0 && object.tx !== null ? Tx.fromPartial(object.tx) : void 0;
    message.txBytes = object.txBytes ?? new Uint8Array();
    return message;
  }
};
function createBaseSimulateResponse() {
  return { gasInfo: void 0, result: void 0 };
}
const SimulateResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.gasInfo !== void 0) {
      GasInfo.encode(message.gasInfo, writer2.uint32(10).fork()).ldelim();
    }
    if (message.result !== void 0) {
      Result.encode(message.result, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseSimulateResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gasInfo = GasInfo.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.result = Result.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      gasInfo: isSet$2(object.gasInfo) ? GasInfo.fromJSON(object.gasInfo) : void 0,
      result: isSet$2(object.result) ? Result.fromJSON(object.result) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? GasInfo.toJSON(message.gasInfo) : void 0);
    message.result !== void 0 && (obj.result = message.result ? Result.toJSON(message.result) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseSimulateResponse();
    message.gasInfo = object.gasInfo !== void 0 && object.gasInfo !== null ? GasInfo.fromPartial(object.gasInfo) : void 0;
    message.result = object.result !== void 0 && object.result !== null ? Result.fromPartial(object.result) : void 0;
    return message;
  }
};
function createBaseGetTxRequest() {
  return { hash: "" };
}
const GetTxRequest = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.hash !== "") {
      writer2.uint32(10).string(message.hash);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetTxRequest();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader2.string();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      hash: isSet$2(object.hash) ? String(object.hash) : ""
    };
  },
  toJSON(message) {
    const obj = {};
    message.hash !== void 0 && (obj.hash = message.hash);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetTxRequest();
    message.hash = object.hash ?? "";
    return message;
  }
};
function createBaseGetTxResponse() {
  return { tx: void 0, txResponse: void 0 };
}
const GetTxResponse = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.tx !== void 0) {
      Tx.encode(message.tx, writer2.uint32(10).fork()).ldelim();
    }
    if (message.txResponse !== void 0) {
      TxResponse.encode(message.txResponse, writer2.uint32(18).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseGetTxResponse();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tx = Tx.decode(reader2, reader2.uint32());
          break;
        case 2:
          message.txResponse = TxResponse.decode(reader2, reader2.uint32());
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      tx: isSet$2(object.tx) ? Tx.fromJSON(object.tx) : void 0,
      txResponse: isSet$2(object.txResponse) ? TxResponse.fromJSON(object.txResponse) : void 0
    };
  },
  toJSON(message) {
    const obj = {};
    message.tx !== void 0 && (obj.tx = message.tx ? Tx.toJSON(message.tx) : void 0);
    message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? TxResponse.toJSON(message.txResponse) : void 0);
    return obj;
  },
  fromPartial(object) {
    const message = createBaseGetTxResponse();
    message.tx = object.tx !== void 0 && object.tx !== null ? Tx.fromPartial(object.tx) : void 0;
    message.txResponse = object.txResponse !== void 0 && object.txResponse !== null ? TxResponse.fromPartial(object.txResponse) : void 0;
    return message;
  }
};
class ServiceClientImpl {
  constructor(rpc2) {
    __publicField(this, "rpc");
    this.rpc = rpc2;
    this.simulate = this.simulate.bind(this);
    this.getTx = this.getTx.bind(this);
    this.broadcastTx = this.broadcastTx.bind(this);
    this.getTxsEvent = this.getTxsEvent.bind(this);
  }
  simulate(request, metadata) {
    return this.rpc.unary(ServiceSimulateDesc, SimulateRequest.fromPartial(request), metadata);
  }
  getTx(request, metadata) {
    return this.rpc.unary(ServiceGetTxDesc, GetTxRequest.fromPartial(request), metadata);
  }
  broadcastTx(request, metadata) {
    return this.rpc.unary(ServiceBroadcastTxDesc, BroadcastTxRequest.fromPartial(request), metadata);
  }
  getTxsEvent(request, metadata) {
    return this.rpc.unary(ServiceGetTxsEventDesc, GetTxsEventRequest.fromPartial(request), metadata);
  }
}
const ServiceDesc = {
  serviceName: "cosmos.tx.v1beta1.Service"
};
const ServiceSimulateDesc = {
  methodName: "Simulate",
  service: ServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return SimulateRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...SimulateResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const ServiceGetTxDesc = {
  methodName: "GetTx",
  service: ServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetTxRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...GetTxResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const ServiceBroadcastTxDesc = {
  methodName: "BroadcastTx",
  service: ServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return BroadcastTxRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...BroadcastTxResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
const ServiceGetTxsEventDesc = {
  methodName: "GetTxsEvent",
  service: ServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetTxsEventRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      return {
        ...GetTxsEventResponse.decode(data),
        toObject() {
          return this;
        }
      };
    }
  }
};
var globalThis$2 = (() => {
  if (typeof globalThis$2 !== "undefined")
    return globalThis$2;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
const atob$1 = globalThis$2.atob || ((b64) => globalThis$2.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64$1(b64) {
  const bin = atob$1(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}
const btoa$1 = globalThis$2.btoa || ((bin) => globalThis$2.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes$1(arr) {
  const bin = [];
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte));
  });
  return btoa$1(bin.join(""));
}
function isSet$2(value) {
  return value !== null && value !== void 0;
}
function createBaseMsgSend() {
  return { fromAddress: "", toAddress: "", amount: [] };
}
const MsgSend = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.fromAddress !== "") {
      writer2.uint32(10).string(message.fromAddress);
    }
    if (message.toAddress !== "") {
      writer2.uint32(18).string(message.toAddress);
    }
    for (const v of message.amount) {
      Coin.encode(v, writer2.uint32(26).fork()).ldelim();
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBaseMsgSend();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fromAddress = reader2.string();
          break;
        case 2:
          message.toAddress = reader2.string();
          break;
        case 3:
          message.amount.push(Coin.decode(reader2, reader2.uint32()));
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      fromAddress: isSet$1(object.fromAddress) ? String(object.fromAddress) : "",
      toAddress: isSet$1(object.toAddress) ? String(object.toAddress) : "",
      amount: Array.isArray(object?.amount) ? object.amount.map((e) => Coin.fromJSON(e)) : []
    };
  },
  toJSON(message) {
    const obj = {};
    message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
    message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
    if (message.amount) {
      obj.amount = message.amount.map((e) => e ? Coin.toJSON(e) : void 0);
    } else {
      obj.amount = [];
    }
    return obj;
  },
  fromPartial(object) {
    const message = createBaseMsgSend();
    message.fromAddress = object.fromAddress ?? "";
    message.toAddress = object.toAddress ?? "";
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  }
};
function isSet$1(value) {
  return value !== null && value !== void 0;
}
function createBasePubKey() {
  return { key: new Uint8Array() };
}
const PubKey = {
  encode(message, writer2 = minimal.Writer.create()) {
    if (message.key.length !== 0) {
      writer2.uint32(10).bytes(message.key);
    }
    return writer2;
  },
  decode(input, length2) {
    const reader2 = input instanceof minimal.Reader ? input : new minimal.Reader(input);
    let end2 = length2 === void 0 ? reader2.len : reader2.pos + length2;
    const message = createBasePubKey();
    while (reader2.pos < end2) {
      const tag = reader2.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader2.bytes();
          break;
        default:
          reader2.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object) {
    return {
      key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array()
    };
  },
  toJSON(message) {
    const obj = {};
    message.key !== void 0 && (obj.key = base64FromBytes(message.key !== void 0 ? message.key : new Uint8Array()));
    return obj;
  },
  fromPartial(object) {
    const message = createBasePubKey();
    message.key = object.key ?? new Uint8Array();
    return message;
  }
};
var globalThis$1 = (() => {
  if (typeof globalThis$1 !== "undefined")
    return globalThis$1;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  throw "Unable to locate global object";
})();
const atob = globalThis$1.atob || ((b64) => globalThis$1.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
  const bin = atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}
const btoa = globalThis$1.btoa || ((bin) => globalThis$1.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
  const bin = [];
  arr.forEach((byte) => {
    bin.push(String.fromCharCode(byte));
  });
  return btoa(bin.join(""));
}
function isSet(value) {
  return value !== null && value !== void 0;
}
async function fetch_derived(dk_base, atu8_salt, ni_bits = 256, atu8_info = new Uint8Array(0)) {
  return new Uint8Array(await crypto.subtle.deriveBits({
    name: "HKDF",
    hash: "SHA-256",
    salt: atu8_salt,
    info: atu8_info
  }, dk_base, ni_bits));
}
async function generate_pair(fk_sk, atu8_salt, ni_bits = 256) {
  const atu8_otp = crypto.getRandomValues(new Uint8Array(ni_bits >> 3));
  const dk_base = await crypto.subtle.importKey("raw", atu8_otp, {
    name: "HKDF",
    hash: "SHA-256"
  }, false, ["deriveBits"]);
  zero_out(atu8_otp);
  const kn_derived = new SensitiveBytes(await fetch_derived(dk_base, atu8_salt, ni_bits));
  const kn_sk = new SensitiveBytes(await fk_sk());
  const kn_xor = kn_sk.xor(kn_derived);
  kn_sk.wipe();
  kn_derived.wipe();
  return [dk_base, kn_xor];
}
const hm_privates$1 = /* @__PURE__ */ new Map();
class RuntimeKey {
  static async create(fk_sk, ni_bits = 256) {
    const k_key = new RuntimeKey();
    const g_private = hm_privates$1.get(k_key);
    const [dk_base, kn_xor] = await generate_pair(fk_sk, g_private.atu8_salt, ni_bits);
    Object.assign(g_private, {
      dk_base,
      kn_xor
    });
    return k_key;
  }
  static async createRaw(atu8_sk, ni_bits = 256) {
    return RuntimeKey.create(() => atu8_sk, ni_bits);
  }
  constructor() {
    const atu8_salt = crypto.getRandomValues(new Uint8Array(32));
    hm_privates$1.set(this, {
      atu8_salt,
      kn_xor: null,
      dk_base: null
    });
  }
  async access(fk_use) {
    const g_privates = hm_privates$1.get(this);
    const {
      dk_base,
      atu8_salt,
      kn_xor
    } = g_privates;
    let w_return;
    let e_thrown;
    const [dk_base_new, kn_xor_new] = await generate_pair(() => new Promise(async (fk_resolve) => {
      const kn_derived = new SensitiveBytes(await fetch_derived(dk_base, atu8_salt, 256));
      const kn_sk = kn_xor.xor(kn_derived);
      kn_derived.wipe();
      try {
        w_return = fk_use(kn_sk.data);
      } catch (_e_thrown) {
        e_thrown = _e_thrown;
      }
      fk_resolve(kn_sk.data);
      queueMicrotask(() => {
        kn_sk.wipe();
      });
    }), atu8_salt);
    g_privates.dk_base = dk_base_new;
    g_privates.kn_xor = kn_xor_new;
    if (e_thrown) {
      throw e_thrown;
    } else {
      return w_return;
    }
  }
  destroy() {
    const {
      atu8_salt,
      kn_xor
    } = hm_privates$1.get(this);
    kn_xor?.wipe();
    zero_out(atu8_salt);
    hm_privates$1.delete(this);
  }
}
class SensitiveBigUint extends SensitiveBytes {
  static random(nb_size) {
    return new SensitiveBigUint(crypto.getRandomValues(new Uint8Array(nb_size)));
  }
  static empty(nb_size = 0) {
    return new SensitiveBigUint(new Uint8Array(nb_size));
  }
  static max(kn_a, kn_b) {
    if (kn_a.gte(kn_b)) {
      return kn_a.clone();
    } else {
      return kn_b.clone();
    }
  }
  static min(kn_a, kn_b) {
    if (kn_a.lte(kn_b)) {
      return kn_a.clone();
    } else {
      return kn_b.clone();
    }
  }
  clone() {
    return new SensitiveBigUint(Uint8Array.from(this.data));
  }
  compare(kn_other) {
    const atu8_data_this = this.data;
    const nb_digits_this = atu8_data_this.byteLength;
    const atu8_data_other = kn_other.data;
    const nb_digits_other = atu8_data_other.byteLength;
    if (nb_digits_other !== nb_digits_this) {
      this.wipe();
      kn_other.wipe();
      throw new Error("Refusing to compare buffers of different byte length");
    }
    for (let ib_each = 0; ib_each < nb_digits_this; ib_each++) {
      const xb_a = atu8_data_this[ib_each];
      const xb_b = atu8_data_other[ib_each];
      if (xb_a !== xb_b) {
        if (xb_a > xb_b) {
          return 1;
        } else {
          return -1;
        }
      }
    }
    return 0;
  }
  eq(kn_other) {
    return this.compare(kn_other) === 0;
  }
  gt(kn_other) {
    return this.compare(kn_other) > 0;
  }
  gte(kn_other) {
    return this.compare(kn_other) >= 0;
  }
  lt(kn_other) {
    return this.compare(kn_other) < 0;
  }
  lte(kn_other) {
    return this.compare(kn_other) <= 0;
  }
  diff(kn_other) {
    const atu8_data_this = this.data;
    const nb_digits = atu8_data_this.byteLength;
    const xc_compare = this.compare(kn_other);
    if (xc_compare < 0) {
      return kn_other.diff(this);
    } else if (0 === xc_compare) {
      return SensitiveBigUint.empty(nb_digits);
    }
    const atu8_data_other = kn_other.data;
    const atu8_out = new Uint8Array(nb_digits);
    let xb_borrow = 0;
    for (let ib_each = nb_digits - 1; ib_each >= 0; ib_each--) {
      let xb_diff = atu8_data_this[ib_each] - atu8_data_other[ib_each] - xb_borrow;
      if (xb_diff < 0) {
        xb_diff += 256;
        xb_borrow = 1;
      } else {
        xb_borrow = 0;
      }
      atu8_out[ib_each] = xb_diff;
    }
    return new SensitiveBigUint(atu8_out);
  }
  mod(kn_base) {
    const atu8_data_this = this.data;
    const nb_digits_this = atu8_data_this.byteLength;
    let xc_compare = this.compare(kn_base);
    if (xc_compare < 0) {
      return this.clone();
    } else if (0 === xc_compare) {
      return SensitiveBigUint.empty(nb_digits_this);
    }
    const atu8_data_other = kn_base.data;
    atu8_data_other.byteLength;
    let kn_prev = this.clone();
    for (; ; ) {
      const kn_diff = kn_prev.diff(kn_base);
      kn_prev.wipe();
      xc_compare = kn_diff.compare(kn_base);
      if (xc_compare <= 0) {
        return kn_diff;
      }
      kn_prev = kn_diff;
    }
  }
  modulus(kn_divisor) {
    const atu8_data_this = this.data;
    const nb_digits_this = atu8_data_this.byteLength;
    let xc_compare = this.compare(kn_divisor);
    if (xc_compare < 0) {
      return this.clone();
    } else if (0 === xc_compare) {
      return SensitiveBigUint.empty(nb_digits_this);
    }
    const atu8_data_other = kn_divisor.data;
    atu8_data_other.byteLength;
  }
}
const KN_ZERO_32 = SensitiveBigUint.empty(32);
const KN_CURVE_N_SECP256K1 = new SensitiveBigUint(hex_to_buffer("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"));
const NI_MINIMUM_BORDER = 64;
const KN_DANGER_LO = new SensitiveBigUint(
  hex_to_buffer(
    ((1 << NI_MINIMUM_BORDER % 8).toString(16) + "00".repeat(NI_MINIMUM_BORDER >>> 3)).padStart(64, "0")
  )
);
KN_CURVE_N_SECP256K1.diff(KN_DANGER_LO);
let y_secp256k1;
let a_wait_secp256k1 = null;
async function init_secp256k1() {
  if (y_secp256k1)
    return y_secp256k1;
  if (a_wait_secp256k1) {
    return new Promise((fk_resolve) => {
      a_wait_secp256k1.push(fk_resolve);
    });
  }
  a_wait_secp256k1 = [];
  y_secp256k1 = await instantiateSecp256k1(crypto.getRandomValues(new Uint8Array(32)));
  const a_execs = a_wait_secp256k1.slice();
  a_wait_secp256k1 = null;
  for (const fk_callback of a_execs) {
    fk_callback(y_secp256k1);
  }
  return y_secp256k1;
}
const hm_privates = /* @__PURE__ */ new Map();
class Secp256k1Key {
  constructor(_y_secp256k1) {
    __publicField(this, "_b_init", false);
    this._y_secp256k1 = _y_secp256k1;
  }
  static withinCurve(kg_sk) {
    return KN_ZERO_32.lt(kg_sk) && KN_CURVE_N_SECP256K1.gt(kg_sk);
  }
  static async verify(atu8_signature, atu8_message, atu8_pk) {
    if (!y_secp256k1)
      await init_secp256k1();
    const atu8_digest = await sha256$1(atu8_message);
    return y_secp256k1.verifySignatureCompactLowS(atu8_signature, atu8_pk, atu8_digest);
  }
  static async generatePrivateKey(b_exportable = false) {
    if (!y_secp256k1)
      await init_secp256k1();
    const kk_sk = await RuntimeKey.create(() => {
      let atu8_sk;
      while (!y_secp256k1.validatePrivateKey(atu8_sk = crypto.getRandomValues(new Uint8Array(32))))
        ;
      return atu8_sk;
    });
    return [kk_sk, await Secp256k1Key.import(kk_sk, b_exportable)];
  }
  static async import(kk_sk, b_exportable = false) {
    if (!y_secp256k1)
      await init_secp256k1();
    return await new Secp256k1Key(y_secp256k1).import(kk_sk, b_exportable);
  }
  async import(kk_sk, b_exportable = false) {
    const _y_secp256k1 = this._y_secp256k1;
    await kk_sk.access((atu8_sk) => {
      if (!this._y_secp256k1.validatePrivateKey(atu8_sk)) {
        throw new Error(`Failed to validate secp256k1 private key`);
      }
      hm_privates.set(this, {
        kk_sk,
        atu8_pk33: _y_secp256k1.derivePublicKeyCompressed(atu8_sk),
        atu8_pk65: _y_secp256k1.derivePublicKeyUncompressed(atu8_sk),
        b_exportable
      });
    });
    const {
      atu8_pk33,
      atu8_pk65
    } = hm_privates.get(this);
    if (!_y_secp256k1.validatePublicKey(atu8_pk33)) {
      throw new Error(`Failed to validate secp256k1 compressed public key`);
    }
    if (!_y_secp256k1.validatePublicKey(atu8_pk65)) {
      throw new Error(`Failed to validate secp256k1 uncompressed public key`);
    }
    this._b_init = true;
    return this;
  }
  exportPublicKey(b_uncompressed = false) {
    const {
      atu8_pk33,
      atu8_pk65,
      b_exportable
    } = hm_privates.get(this);
    if (true === b_exportable) {
      if (b_uncompressed) {
        return atu8_pk65;
      } else {
        return atu8_pk33;
      }
    } else {
      throw new Error("Public key is not exportable");
    }
  }
  async sign(atu8_message, b_extra_entropy = false) {
    const atu8_digest = await sha256$1(atu8_message);
    const {
      kk_sk
    } = hm_privates.get(this);
    return await kk_sk.access((atu8_sk) => {
      if (b_extra_entropy) {
        return this._y_secp256k1.signMessageHashCompact(atu8_sk, atu8_digest, crypto.getRandomValues(new Uint8Array(32)));
      } else {
        return this._y_secp256k1.signMessageHashCompact(atu8_sk, atu8_digest);
      }
    });
  }
  async verify(atu8_signature, atu8_message) {
    const atu8_digest = await sha256$1(atu8_message);
    const {
      atu8_pk65
    } = hm_privates.get(this);
    return this._y_secp256k1.verifySignatureCompactLowS(atu8_signature, atu8_pk65, atu8_digest);
  }
  async ecdh(atu8_pk) {
    const {
      kk_sk
    } = hm_privates.get(this);
    return await kk_sk.access((atu8_sk) => this._y_secp256k1.ecdh(atu8_sk, atu8_pk));
  }
  add(atu8_tweak) {
    const {
      kk_sk
    } = hm_privates.get(this);
    return kk_sk.access((atu8_sk) => this._y_secp256k1.addTweakPrivateKey(atu8_sk, atu8_tweak));
  }
}
const Secrets = create_store_class({
  store: SI_STORE_SECRETS,
  extension: "dict",
  class: class SecretsI extends WritableStoreDict {
    static pathFrom(g_secret) {
      return `/secret.${g_secret.type}/uuid.${g_secret.uuid}`;
    }
    async put(g_secret) {
      const p_res = SecretsI.pathFrom(g_secret);
      this._w_cache[p_res] = g_secret;
      await this.save();
      return p_res;
    }
  }
});
const Accounts = create_store_class({
  store: SI_STORE_ACCOUNTS,
  extension: "map",
  class: class AccountsI extends WritableStoreMap {
    static pathFor(si_family, s_pubkey) {
      return `/family.${si_family}/account.${s_pubkey.replace(/:/g, "+")}`;
    }
    static pathFrom(g_account) {
      return AccountsI.pathFor(g_account.family, g_account.pubkey);
    }
    static get(si_family, s_pubkey) {
      return Accounts.open((ks) => ks.get(si_family, s_pubkey));
    }
    get(si_family, s_pubkey) {
      const p_res = AccountsI.pathFor(si_family, s_pubkey);
      return this._w_cache[p_res] ?? null;
    }
    async put(g_account) {
      const p_res = AccountsI.pathFrom(g_account);
      this._w_cache[p_res] = g_account;
      await this.save();
      return p_res;
    }
  }
});
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE2 = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    suffix: ""
  }, ALPHABET2 = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2))
      return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v)))
          return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET2.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round2(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0)
          return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET2.slice(0, b);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0")
          ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p2, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
          v = obj[p2];
          intCheck(v, 0, MAX, p2);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
          v = obj[p2];
          intCheck(v, 0, 8, p2);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
          v = obj[p2];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p2);
            intCheck(v[1], 0, MAX, p2);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p2);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p2 = "RANGE")) {
          v = obj[p2];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p2);
            intCheck(v[1], 1, MAX, p2);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p2);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p2 + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p2 = "CRYPTO")) {
          v = obj[p2];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p2 + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
          v = obj[p2];
          intCheck(v, 0, 9, p2);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
          v = obj[p2];
          intCheck(v, 0, MAX, p2);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p2 = "FORMAT")) {
          v = obj[p2];
          if (typeof v == "object")
            FORMAT = v;
          else
            throw Error(bignumberError + p2 + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p2 = "ALPHABET")) {
          v = obj[p2];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET2 = v;
          } else {
            throw Error(bignumberError + p2 + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET: ALPHABET2
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n, c = v.c, e = v.e, s = v.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c[0] === 0) {
            if (e === 0 && c.length === 1)
              return true;
            break out;
          }
          i = (e + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n))
                break out;
            }
            if (n !== 0)
              return true;
          }
        }
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, P.lt);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, P.gt);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE2);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15)
            c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--)
        ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
          ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
          ;
        if (i < LOG_BASE)
          e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i < args.length; )
      sum = sum.plus(args[i++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x = y.pow(str.length - i);
        POW_PRECISION = k;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET2, decimal) : (alphabet = decimal, ALPHABET2));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign;
        x = div(x, y, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d = e + dp + 1;
      i = xc[d];
      k = baseOut / 2;
      r = r || d < 0 || xc[d + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d;
        if (r) {
          for (--baseOut; ++xc[--d] > baseOut; ) {
            xc[d] = 0;
            if (!d) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; )
          ;
        for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
          ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply2(x, k, base) {
      var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry)
        x = [carry].concat(x);
      return x;
    }
    function compare3(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract2(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x, y, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0
        );
      }
      q = new BigNumber2(s);
      qc = q.c = [];
      e = x.e - y.e;
      s = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s = s / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++)
        ;
      if (yc[i] > (xc[i] || 0))
        e--;
      if (s < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply2(yc, n, base);
          xc = multiply2(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n = 0;
          cmp = compare3(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base)
                n = base - 1;
              prod = multiply2(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare3(prod, rem, prodL, remL) == 1) {
                n--;
                subtract2(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract2(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare3(yc, rem, yL, remL) < 1) {
                n++;
                subtract2(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
          ;
        round2(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format3(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n.c)
      return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round2(new BigNumber2(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++)
          ;
        str = toExponential(str, e);
      } else {
        i -= ne;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0)
            for (str += "."; i--; str += "0")
              ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len)
              str += ".";
            for (; i--; str += "0")
              ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, method) {
    var n, i = 1, m = new BigNumber2(args[0]);
    for (; i < args.length; i++) {
      n = new BigNumber2(args[i]);
      if (!n.s) {
        m = n;
        break;
      } else if (method.call(m, n)) {
        m = n;
      }
    }
    return m;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop())
      ;
    for (j = c[0]; j >= 10; j /= 10, i++)
      ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s)) {
        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s = s.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m;
          });
          if (b) {
            base = b;
            s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s)
            return new BigNumber2(s, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round2(x, sd, rm, r) {
    var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
          ;
        i = sd - d;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = n / pows10[d - j - 1] % 10 | 0;
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n = rd = 0;
              d = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d = 1; k >= 10; k /= 10, d++)
              ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d;
            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
          }
        }
        r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++)
                ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop())
          ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str, e = n.e;
    if (e === null)
      return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0)
      x.s = 1;
    return x;
  };
  P.comparedTo = function(y, b) {
    return compare(this, new BigNumber2(y, b));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round2(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c))
      return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v])
      for (; v % 10 == 0; v /= 10, n--)
        ;
    if (n < 0)
      n = 0;
    return n;
  };
  P.dividedBy = P.div = function(y, b) {
    return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b) {
    return div(this, new BigNumber2(y, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n, m) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m != null)
      m = new BigNumber2(m);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m.isInteger();
      if (isModExp)
        x = x.mod(m);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1)
        k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y = new BigNumber2(ONE2);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x);
        if (!y.c)
          break;
        if (k) {
          if (y.c.length > k)
            y.c.length = k;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round2(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k)
          x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m);
      }
    }
    if (isModExp)
      return y;
    if (nIsNeg)
      y = ONE2.div(y);
    return m ? y.mod(m) : k ? round2(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round2(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b) {
    return compare(this, new BigNumber2(y, b)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b) {
    return compare(this, new BigNumber2(y, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b) {
    return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0))
        ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy)
      t = xc, xc = yc, yc = t, y.s = -y.s;
    b = (j = yc.length) - (i = xc.length);
    if (b > 0)
      for (; b--; xc[i++] = 0)
        ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b)
          ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc, ye);
  };
  P.modulo = P.mod = function(y, b) {
    var q, s, x = this;
    y = new BigNumber2(y, b);
    if (!x.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s = y.s;
      y.s = 1;
      q = div(x, y, 0, 3);
      y.s = s;
      q.s *= s;
    } else {
      q = div(x, y, 0, MODULO_MODE);
    }
    y = x.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1)
      y.s = x.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b) {
    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x.s;
        if (!xc || !yc) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL)
      zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
    for (i = xcL + ycL, zc = []; i--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y, b) {
    var t, x = this, a = x.s;
    y = new BigNumber2(y, b);
    b = y.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y.s = -b;
      return x.minus(y);
    }
    var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0))
        ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0)
      t = yc, yc = xc, xc = t, b = a;
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round2(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c))
      return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--)
        ;
      for (v = c[0]; v >= 10; v /= 10, n++)
        ;
    }
    if (sd && x.e + 1 > n)
      n = x.e + 1;
    return n;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s !== 1 || !c || !c[0]) {
      return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s = Math.sqrt(+valueOf(x));
    if (s == 0 || s == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s + "");
    }
    if (r.c[0]) {
      e = r.e;
      s = e + dp;
      if (s < 3)
        s = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
          if (r.e < e)
            --s;
          n = n.slice(s - 3, s + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round2(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round2(r, r.e + DECIMAL_PLACES + 2, 1);
              m = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round2(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format3(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format3(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format4) {
    var str, x = this;
    if (format4 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format4 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format4 = dp;
        dp = rm = null;
      } else {
        format4 = FORMAT;
      }
    } else if (typeof format4 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format4);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format4.groupSize, g2 = +format4.secondaryGroupSize, groupSeparator = format4.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2)
        i = g1, g1 = g2, g2 = i, len -= i;
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format4.decimalSeparator || "") + ((g2 = +format4.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format4.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format4.prefix || "") + str + (format4.suffix || "");
  };
  P.toFraction = function(md) {
    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE2)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc)
      return new BigNumber2(x);
    d = new BigNumber2(ONE2);
    n1 = d0 = new BigNumber2(ONE2);
    d1 = n0 = new BigNumber2(ONE2);
    s = coeffToString(xc);
    e = d.e = s.length - x.e - 1;
    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d, 0, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d2;
      n1 = n0.plus(q.times(d2 = n1));
      n0 = d2;
      d = n.minus(q.times(d2 = d));
      n = d2;
    }
    d2 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format3(this, sd, rm, 2);
  };
  P.toString = function(b) {
    var str, n = this, s = n.s, e = n.e;
    if (e === null) {
      if (s) {
        str = "Infinity";
        if (s < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round2(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET2.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
      }
      if (s < 0 && n.c[0])
        str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s, z, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s = a[i++] + "";
    z = LOG_BASE - s.length;
    for (; z--; s = "0" + s)
      ;
    r += s;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; )
    ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y) {
  var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!i || !j)
    return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b)
    return a ? b ? 0 : -j : i;
  if (i != j)
    return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc)
    return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b)
    return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++)
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z) {
  var len, zs;
  if (e < 0) {
    for (zs = z + "."; ++e; zs += z)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z, e -= len; --e; zs += z)
        ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone();
const fold_attrs = (g_event) => fold(g_event.attributes, (g_attr) => ({
  [g_attr.key]: g_attr.value
}));
async function sign_doc(xg_account_number, atu8_auth, atu8_body, si_chain) {
  const g_doc = SignDoc.fromPartial({
    accountNumber: xg_account_number + "",
    authInfoBytes: atu8_auth,
    bodyBytes: atu8_body,
    chainId: si_chain
  });
  const atu8_doc = SignDoc.encode(g_doc).finish();
  const p_secret = yw_account.get().secret;
  const g_secret = await Secrets.get(p_secret);
  if ("none" !== g_secret?.security.type) {
    throw new Error(`Keyring not yet implemented`);
  }
  const k_key = await Secp256k1Key.import(await RuntimeKey.createRaw(string8_to_buffer(g_secret.data)));
  return await k_key.sign(atu8_doc, true);
}
class CosmosNetwork {
  constructor(_g_network, _g_chain) {
    __publicField(this, "_p_chain");
    __publicField(this, "_y_grpc");
    __publicField(this, "_ks_cache");
    this._g_network = _g_network;
    this._g_chain = _g_chain;
    this._p_chain = Chains.pathFrom(_g_chain);
    this._y_grpc = new GrpcWebImpl(_g_network.grpcWebUrl, {
      transport: grpcWebClient_umd$1.exports.grpc.CrossBrowserHttpTransport({ withCredentials: false })
    });
    void this.reloadCached();
  }
  async _signer_data(sa_sender) {
    const g_response = await new QueryClientImpl(this._y_grpc).account({
      address: sa_sender
    });
    const {
      typeUrl: si_type,
      value: atu8_data
    } = g_response?.account || {};
    if (!si_type) {
      throw new Error(`Account for ${sa_sender} was not found on chain. Likely has zero balance.`);
    } else if (si_type !== "/cosmos.auth.v1beta1.BaseAccount") {
      throw new Error(`Cannot sign with account of type "${si_type}", can only sign with BaseAccount.`);
    }
    const g_account = BaseAccount.decode(atu8_data);
    return {
      chainId: this._g_chain.id,
      accountNumber: BigInt(g_account.accountNumber),
      sequence: BigInt(g_account.sequence)
    };
  }
  async _update_balance(sa_owner, si_coin, g_balance, xt_when) {
    const p_holding = Entities.holdingPathFor(sa_owner, si_coin, this._p_chain);
    const g_cached = this._ks_cache.at(p_holding);
    await QueryCache.open(async (ks) => {
      await ks.set(p_holding, {
        timestamp: xt_when,
        data: JSON.parse(JSON.stringify(g_balance))
      });
      this._ks_cache = ks;
    });
    return [p_holding, g_cached];
  }
  async reloadCached() {
    this._ks_cache = await QueryCache.read();
  }
  cachedBalance(sa_owner, si_coin) {
    const p_holding = Entities.holdingPathFor(sa_owner, si_coin, this._p_chain);
    return this._ks_cache.at(p_holding);
  }
  async bankBalance(sa_owner, si_coin, xt_since = 0) {
    const xt_req = Date.now();
    si_coin = si_coin || Object.keys(this._g_chain.coins)[0];
    const g_response = await new QueryClientImpl$1(this._y_grpc).balance({
      address: sa_owner,
      denom: this._g_chain.coins[si_coin].denom
    });
    const {
      balance: g_balance
    } = g_response;
    if (!g_balance) {
      throw new Error(`Failed to fetch balance`);
    }
    const [p_holding, g_cached] = await this._update_balance(sa_owner, si_coin, g_balance, xt_req);
    return {
      balance: g_balance,
      cached: g_cached,
      holding: p_holding
    };
  }
  async bankBalances(sa_owner) {
    const xt_req = Date.now();
    const g_response = await new QueryClientImpl$1(this._y_grpc).allBalances({
      address: sa_owner
    });
    const {
      balances: a_balances
    } = g_response;
    const h_coins = this._g_chain.coins;
    const h_denoms = oderom(h_coins, (si_coin, g_coin) => ({
      [g_coin.denom]: si_coin
    }));
    const h_outs = {};
    for (const g_balance of a_balances) {
      const si_coin = h_denoms[g_balance.denom];
      h_coins[si_coin];
      const [p_holding, g_cached] = await this._update_balance(sa_owner, si_coin, g_balance, xt_req);
      h_outs[si_coin] = {
        balance: g_balance,
        cached: g_cached,
        holding: p_holding
      };
    }
    return h_outs;
  }
  get hasRpc() {
    return !!this._g_network.rpcHost;
  }
  listen(a_events, fke_receive) {
    const p_host = this._g_network.rpcHost;
    if (!p_host)
      throw new Error("Cannot subscribe to events; no RPC host configured on network");
    const d_ws = new WebSocket(`wss://${p_host}/websocket`);
    d_ws.onopen = (d_event) => {
      d_ws.send(JSON.stringify({
        jsonrpc: "2.0",
        method: "subscribe",
        id: "0",
        params: {
          query: a_events.join(" AND ")
        }
      }));
    };
    d_ws.onmessage = (d_event) => {
      const g_msg = JSON.parse(d_event.data || "{}");
      const g_value = g_msg?.result?.data?.value;
      if (g_value) {
        void fke_receive(null, g_value);
      }
    };
    let b_user_closed = false;
    d_ws.onclose = (d_event) => {
      if (!b_user_closed) {
        void fke_receive(d_event);
      }
    };
    d_ws.onerror = (d_event) => {
      void fke_receive(d_event);
    };
    return () => {
      b_user_closed = true;
      d_ws.close();
    };
  }
  onReceive(sa_owner, fke_receive) {
    return this.listen([
      `tm.event='Tx'`,
      `transfer.recipient='${sa_owner}'`
    ], (d_kill, g_value) => {
      void fke_receive(d_kill, g_value?.TxResult || void 0);
    });
  }
  onSend(sa_owner, fke_send) {
    return this.listen([
      `tm.event='Tx'`,
      `transfer.sender='${sa_owner}'`
    ], (d_kill, g_value) => {
      void fke_send(d_kill, g_value?.TxResult || void 0);
    });
  }
  async isContract(sa_account) {
    const g_response = await new ServiceClientImpl(this._y_grpc).getTxsEvent({
      events: [
        `message.contract_address='${sa_account}'`
      ],
      orderBy: OrderBy.ORDER_BY_ASC,
      pagination: {
        limit: "1"
      }
    });
    return g_response.txResponses.length > 0;
  }
  async received(sa_owner, n_min_block = 0) {
    const g_response = await new ServiceClientImpl(this._y_grpc).getTxsEvent({
      events: [
        `transfer.recipient='${sa_owner}'`,
        `tx.height>=${n_min_block}`
      ],
      pagination: {
        limit: "100"
      }
    });
    const y_client = grpcWebClient_umd$1.exports.grpc.client(ServiceGetTxsEventDesc, {
      host: "wss://rpc.testnet.secretsaturn.net/websocket",
      transport: grpcWebClient_umd$1.exports.grpc.WebsocketTransport(),
      debug: true
    });
    y_client.onHeaders((g_headers) => {
      console.log(g_headers);
      debugger;
    });
    y_client.onMessage((g_msg) => {
      console.log(g_msg);
      debugger;
    });
    y_client.onEnd((w_status, s_msg, g_trailers) => {
      console.log({
        w_status,
        s_msg,
        g_trailers
      });
      debugger;
      console.log("#end");
    });
    y_client.start();
    const g_tx = GetTxsEventRequest.fromPartial({
      events: [
        `tm.event='Tx'`
      ]
    });
    debugger;
    y_client.send({
      ...g_tx,
      ...ServiceGetTxsEventDesc.requestType
    });
    y_client.finishSend();
    if (!g_response) {
      throw new Error("Failed to fetch transaction");
    }
    const n_pages = +(g_response.pagination?.total || 1);
    if (n_pages > 1) {
      throw new Error("Not yet implemented");
    }
    const a_outs = [];
    for (const g_txn of g_response.txResponses) {
      const a_events = JSON.parse(g_txn.rawLog)[0].events;
      for (const g_event of a_events) {
        if ("transfer" === g_event.type) {
          const h_attrs = fold_attrs(g_event);
          a_outs.push({
            ...h_attrs,
            height: g_txn.height,
            timestamp: g_txn.timestamp,
            txhash: g_txn.txhash
          });
        }
      }
    }
    console.log(a_outs);
    return a_outs;
  }
  async bankSend(sa_sender, sa_recipient, si_coin, xg_amount, s_memo = "", g_chain = yw_chain.get()) {
    const g_coin = g_chain.coins[si_coin];
    const g_msg_send = MsgSend.fromPartial({
      amount: [{
        denom: g_coin.denom,
        amount: xg_amount.toString()
      }],
      fromAddress: sa_sender,
      toAddress: sa_recipient
    });
    const g_encoded = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSend",
      value: MsgSend.encode(g_msg_send).finish()
    };
    const [si_txn, atu8_txn] = await this.broadcast({
      msgs: [g_encoded],
      memo: s_memo,
      gasLimit: 20000n,
      gasFee: {
        price: 0.25
      }
    });
    return {
      chain: yw_chain_ref.get(),
      owner: sa_sender,
      hash: si_txn,
      coin: si_coin,
      msg: g_msg_send,
      raw: buffer_to_string8(atu8_txn)
    };
  }
  async broadcast(gc_broadcast) {
    const {
      msgs: a_msgs,
      memo: s_memo,
      gasLimit: xg_gas_limit,
      gasFee: gc_fee,
      account: g_account = yw_account.get()
    } = gc_broadcast;
    let {
      amount: s_gas_fee_amount,
      denom: s_denom
    } = gc_fee;
    if (gc_fee["price"]) {
      s_gas_fee_amount = new BigNumber(gc_fee["price"]).times(xg_gas_limit.toString()).toString();
      s_denom = Object.values(yw_chain.get().coins)[0].denom;
    }
    const sa_owner = Chains.addressFor(g_account.pubkey, this._g_chain);
    const p_secret = yw_account.get().secret;
    const g_secret = await Secrets.get(p_secret);
    if ("none" !== g_secret?.security.type) {
      throw new Error(`Keyring not yet implemented`);
    }
    const k_secp = await Secp256k1Key.import(await RuntimeKey.create(() => string8_to_buffer(g_secret.data)), true);
    const atu8_pk = k_secp.exportPublicKey();
    const g_tx_body = TxBody.fromPartial({
      messages: a_msgs,
      memo: s_memo
    });
    const atu8_body = TxBody.encode(g_tx_body).finish();
    const g_signer = await this._signer_data(sa_owner);
    const g_auth_body = AuthInfo.fromPartial({
      signerInfos: [
        {
          publicKey: {
            typeUrl: "/cosmos.crypto.secp256k1.PubKey",
            value: PubKey.encode(PubKey.fromPartial({
              key: atu8_pk
            })).finish()
          },
          modeInfo: {
            single: {
              mode: SignMode.SIGN_MODE_DIRECT
            }
          },
          sequence: g_signer.sequence + ""
        }
      ],
      fee: {
        amount: [{
          amount: s_gas_fee_amount,
          denom: s_denom
        }],
        gasLimit: xg_gas_limit + ""
      }
    });
    const atu8_auth = AuthInfo.encode(g_auth_body).finish();
    const atu8_signature = await sign_doc(g_signer.accountNumber, atu8_auth, atu8_body, yw_chain.get().id);
    const atu8_txn = TxRaw.encode(TxRaw.fromPartial({
      bodyBytes: atu8_body,
      authInfoBytes: atu8_auth,
      signatures: [atu8_signature]
    })).finish();
    const g_response = await new ServiceClientImpl(this._y_grpc).broadcastTx({
      txBytes: atu8_txn,
      mode: BroadcastMode.BROADCAST_MODE_ASYNC
    });
    const si_txn = g_response.txResponse?.txhash;
    if (!si_txn) {
      throw syserr({
        text: "Txn failed to broadcast"
      });
    }
    return [si_txn, atu8_txn];
  }
}
const Medias = create_store_class({
  store: SI_STORE_MEDIA,
  extension: "map",
  class: class MediaI extends WritableStoreMap {
  }
});
const Networks = create_store_class({
  store: SI_STORE_NETWORKS,
  extension: "map",
  class: class NetworksI extends WritableStoreMap {
    static pathFor(p_base) {
      return `/network.${buffer_to_base64(sha256_sync$1(text_to_buffer(p_base)))}`;
    }
    static pathFrom(g_network) {
      return NetworksI.pathFor(g_network.grpcWebUrl);
    }
    static activate(g_network, g_chain = yw_chain.get()) {
      return new CosmosNetwork(g_network, g_chain);
    }
  }
});
const Tags = create_store_class({
  store: SI_STORE_TAGS,
  class: class TagsI extends WritableStore {
    static tagPathFor(g_tag) {
      return `/tag.${g_tag.index}`;
    }
    getTag(i_tag) {
      return this._w_cache.registry[i_tag] ?? null;
    }
    getIdsFor(p_resource) {
      return this._w_cache.map[p_resource] ?? [];
    }
    getTagsFor(p_resource) {
      return this.getIdsFor(p_resource).map((i_tag) => this.getTag(i_tag)).filter((g) => !!g);
    }
    setIdsFor(p_ressource, a_ids) {
      this._w_cache.map[p_ressource] = a_ids;
      return this.save();
    }
    setTagsFor(p_resource, a_tags2) {
      return this.setIdsFor(p_resource, a_tags2.map((g) => g.index));
    }
  }
});
const subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop$1) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop$1;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = noop$1;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop$1;
      }
    };
    const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    inited = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
    };
  });
}
var Screen_svelte_svelte_type_style_lang = "";
var StarShellLogo_svelte_svelte_type_style_lang = "";
var SX_ICON_ADD$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="8" height="8">\n	<g style="fill: var(--svg-color-fg, currentColor);">\n		<rect x="3" width="2" height="8" />\n		<rect y="5" width="2" height="8" transform="rotate(-90 0 5)" />\n	</g>\n</svg>';
var OverlaySelect_svelte_svelte_type_style_lang = "";
function create_if_block$e(ctx) {
  let html_tag;
  let raw_value = ctx[0].outerHTML + "";
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && raw_value !== (raw_value = ctx2[0].outerHTML + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_fragment$m(ctx) {
  let if_block_anchor;
  let if_block = ctx[0]?.outerHTML && create_if_block$e(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]?.outerHTML) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$e(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let { element: element2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(0, element2 = $$props2.element);
  };
  return [element2];
}
class Put extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$m, safe_not_equal, { element: 0 });
  }
}
const qs = (dm_node, sq_selector) => dm_node.querySelector(sq_selector);
function dd(s_tag, h_attrs = {}, a_children = []) {
  const dm_node = document.createElement(s_tag);
  for (const si_attr in h_attrs) {
    dm_node.setAttribute(si_attr, h_attrs[si_attr] + "");
  }
  for (const w_child of a_children) {
    dm_node.append(w_child);
  }
  return dm_node;
}
function open_external_link(p_url) {
  chrome.tabs.create({
    url: p_url
  });
}
function picture(h_image, gc_render, h_attrs = {}) {
  const {
    default: p_default,
    16: p_16,
    32: p_32,
    48: p_48,
    64: p_64,
    96: p_96,
    128: p_128,
    256: p_256
  } = h_image;
  const ks_medias = gc_render.medias;
  const sx_16 = p_16 ? ks_medias.at(p_16)?.data : null;
  const sx_32 = p_32 ? ks_medias.at(p_32)?.data : null;
  const sx_48 = p_48 ? ks_medias.at(p_48)?.data : null;
  const sx_64 = p_64 ? ks_medias.at(p_64)?.data : null;
  const sx_96 = p_96 ? ks_medias.at(p_96)?.data : null;
  const sx_128 = p_128 ? ks_medias.at(p_128)?.data : null;
  const sx_256 = p_256 ? ks_medias.at(p_256)?.data : null;
  const sx_default = ks_medias.at(p_default).data;
  const sx_any_x = sx_16 || sx_32 || sx_48 || sx_64 || sx_96 || sx_128 || sx_256;
  const x_dim_1x = gc_render.dim;
  const x_dim_2x = x_dim_1x * 2;
  let sx_1x = null;
  let sx_2x = null;
  if (sx_any_x) {
    if (x_dim_1x <= 64) {
      if (x_dim_1x <= 32) {
        if (x_dim_1x <= 16) {
          sx_1x = sx_any_x;
        } else {
          sx_1x = sx_32 || sx_48 || sx_64 || sx_96 || sx_128 || sx_256;
        }
      } else if (x_dim_1x <= 48) {
        sx_1x = sx_48 || sx_64 || sx_96 || sx_128 || sx_256;
      } else {
        sx_1x = sx_64 || sx_96 || sx_128 || sx_256;
      }
    } else if (x_dim_1x <= 128) {
      if (x_dim_1x <= 96) {
        sx_1x = sx_96 || sx_128 || sx_256;
      } else {
        sx_1x = sx_128 || sx_256;
      }
    } else if (x_dim_1x <= 256) {
      sx_1x = sx_256;
    }
    if (x_dim_2x <= 64) {
      if (x_dim_2x <= 32) {
        if (x_dim_2x <= 16) {
          sx_2x = sx_any_x;
        } else {
          sx_2x = sx_32 || sx_48 || sx_64 || sx_96 || sx_128 || sx_256;
        }
      } else if (x_dim_2x <= 48) {
        sx_2x = sx_48 || sx_64 || sx_96 || sx_128 || sx_256;
      } else {
        sx_2x = sx_64 || sx_96 || sx_128 || sx_256;
      }
    } else if (x_dim_2x <= 128) {
      if (x_dim_2x <= 96) {
        sx_2x = sx_96 || sx_128 || sx_256;
      } else {
        sx_2x = sx_128 || sx_256;
      }
    } else if (x_dim_2x <= 256) {
      sx_2x = sx_256;
    }
  }
  return dd("picture", {
    ...h_attrs
  }, [
    ...sx_2x ? [dd("source", {
      srcset: sx_2x,
      media: "(min-resolution: 2dppx)"
    })] : [],
    dd("img", {
      src: sx_1x || sx_default,
      alt: gc_render.alt || ""
    })
  ]);
}
const Pfps = create_store_class({
  store: SI_STORE_PFPS,
  extension: "map",
  class: class PfpI extends WritableStoreMap {
    static async load(p_pfp, gc_render) {
      const g_pfp = await Pfps.at(p_pfp);
      if (!g_pfp)
        return null;
      return Pfps.render(g_pfp, gc_render);
    }
    static render(g_pfp, gc_render) {
      const sx_style_picture = `width:${gc_render.dim}px; height:${gc_render.dim}px;`;
      switch (g_pfp.type) {
        case "plain": {
          return picture(g_pfp.image, gc_render, {
            class: "global_pfp",
            style: sx_style_picture
          });
        }
      }
    }
  }
});
var PfpDisplay_svelte_svelte_type_style_lang = "";
function create_else_block_1$1(ctx) {
  let span;
  let t0_value = (ctx[1][0] || "") + "";
  let t0;
  let t1;
  let await_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_2,
    then: create_then_block_2,
    catch: create_catch_block_2,
    value: 21
  };
  handle_promise(ctx[7](), info);
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      await_block_anchor = empty();
      info.block.c();
      attr(span, "class", "icon-dom svelte-mmgef2");
      attr(span, "style", ctx[4]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      insert(target, t1, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block$d(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block_1$2,
    value: 20,
    blocks: [, , ,]
  };
  handle_promise(ctx[6](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block_2(ctx) {
  return { c: noop$1, m: noop$1, d: noop$1 };
}
function create_then_block_2(ctx) {
  let t;
  return {
    c() {
      t = text("_");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block_2(ctx) {
  return { c: noop$1, m: noop$1, d: noop$1 };
}
function create_catch_block_1$2(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$4(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let await_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$8, create_else_block$4];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[20])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1$2,
    then: create_then_block_1$2,
    catch: create_catch_block$4,
    value: 21
  };
  handle_promise(ctx[7](), info);
  return {
    c() {
      if_block.c();
      t = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if_block.p(ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_else_block$4(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Error";
      attr(span, "class", "error");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$8(ctx) {
  let put2;
  let current;
  put2 = new Put({ props: { element: ctx[20] } });
  return {
    c() {
      create_component(put2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(put2, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(put2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(put2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(put2, detaching);
    }
  };
}
function create_catch_block$4(ctx) {
  return { c: noop$1, m: noop$1, d: noop$1 };
}
function create_then_block_1$2(ctx) {
  let t;
  return {
    c() {
      t = text("_");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block_1$2(ctx) {
  return { c: noop$1, m: noop$1, d: noop$1 };
}
function create_pending_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading pfp...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$l(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$d, create_else_block_1$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      span = element("span");
      if_block.c();
      attr(span, "class", "global_pfp tile " + ctx[2] + " svelte-mmgef2");
      attr(span, "style", ctx[5]);
      attr(span, "data-path", ctx[0]);
      toggle_class(span, "satin", "satin" === ctx[3]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
      if (!current || dirty & 1) {
        attr(span, "data-path", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let $yw_store_medias;
  component_subscribe($$self, yw_store_medias, ($$value) => $$invalidate(16, $yw_store_medias = $$value));
  const dispatch2 = createEventDispatcher();
  let { resource = null } = $$props;
  const g_resource = resource;
  let { ref = g_resource?.pfp || "" } = $$props;
  let { name = g_resource?.name || "" } = $$props;
  const s_name = name;
  let { dim } = $$props;
  const x_dim = dim;
  let { circular = false } = $$props;
  const s_classes = circular ? "" : "square";
  let { bg = void 0 } = $$props;
  const si_style_bg = bg;
  let { genStyle = "" } = $$props;
  const sx_style_gen = `width:${x_dim}px; height:${x_dim}px; ` + (genStyle || "") + (ref ? `font-size:${x_dim}px;` : "") + (circular ? `border-radius:${x_dim}px;` : "");
  let { rootStyle = "" } = $$props;
  const sx_style_root = rootStyle;
  let { settle = void 0 } = $$props;
  async function load_pfp() {
    const ks_medias = $yw_store_medias || await Medias.read();
    const dm_pfp = await Pfps.load(ref, {
      alt: s_name,
      dim: x_dim,
      medias: ks_medias
    });
    queueMicrotask(() => {
      dispatch2("loaded");
    });
    return dm_pfp;
  }
  function settle_inner() {
    if (settle)
      queueMicrotask(() => settle());
    return new Promise(F_NOOP);
  }
  $$self.$$set = ($$props2) => {
    if ("resource" in $$props2)
      $$invalidate(8, resource = $$props2.resource);
    if ("ref" in $$props2)
      $$invalidate(0, ref = $$props2.ref);
    if ("name" in $$props2)
      $$invalidate(9, name = $$props2.name);
    if ("dim" in $$props2)
      $$invalidate(10, dim = $$props2.dim);
    if ("circular" in $$props2)
      $$invalidate(11, circular = $$props2.circular);
    if ("bg" in $$props2)
      $$invalidate(12, bg = $$props2.bg);
    if ("genStyle" in $$props2)
      $$invalidate(13, genStyle = $$props2.genStyle);
    if ("rootStyle" in $$props2)
      $$invalidate(14, rootStyle = $$props2.rootStyle);
    if ("settle" in $$props2)
      $$invalidate(15, settle = $$props2.settle);
  };
  return [
    ref,
    s_name,
    s_classes,
    si_style_bg,
    sx_style_gen,
    sx_style_root,
    load_pfp,
    settle_inner,
    resource,
    name,
    dim,
    circular,
    bg,
    genStyle,
    rootStyle,
    settle
  ];
}
class PfpDisplay extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$l, safe_not_equal, {
      resource: 8,
      ref: 0,
      name: 9,
      dim: 10,
      circular: 11,
      bg: 12,
      genStyle: 13,
      rootStyle: 14,
      settle: 15
    });
  }
}
var SX_ICON_CLOSE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-close-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-close-fg" d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>\n</svg>\n';
var Close_svelte_svelte_type_style_lang = "";
function create_fragment$k(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "close icon svelte-1to5vmp");
      toggle_class(div, "absolute", ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = SX_ICON_CLOSE;
      if (!mounted) {
        dispose = listen(div, "click", ctx[2]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        toggle_class(div, "absolute", ctx2[0]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let { absolute = false } = $$props;
  let { heightless = false } = $$props;
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("absolute" in $$props2)
      $$invalidate(0, absolute = $$props2.absolute);
    if ("heightless" in $$props2)
      $$invalidate(1, heightless = $$props2.heightless);
  };
  return [absolute, heightless, click_handler2];
}
class Close extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$k, safe_not_equal, { absolute: 0, heightless: 1 });
  }
}
var Row_svelte_svelte_type_style_lang = "";
const get_below_slot_changes = (dirty) => ({});
const get_below_slot_context = (ctx) => ({});
const get_tags_slot_changes = (dirty) => ({});
const get_tags_slot_context = (ctx) => ({});
const get_right_slot_changes = (dirty) => ({});
const get_right_slot_context = (ctx) => ({});
const get_status_slot_changes = (dirty) => ({});
const get_status_slot_context = (ctx) => ({});
const get_detail_slot_changes = (dirty) => ({});
const get_detail_slot_context = (ctx) => ({});
const get_icon_slot_changes_1 = (dirty) => ({});
const get_icon_slot_context_1 = (ctx) => ({});
const get_icon_slot_changes = (dirty) => ({});
const get_icon_slot_context = (ctx) => ({});
function fallback_block_3(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      ref: ctx[12],
      name: ctx[10],
      dim: ctx[13]
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function fallback_block_2(ctx) {
  let current;
  const icon_slot_template = ctx[26].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[25], get_icon_slot_context_1);
  const icon_slot_or_fallback = icon_slot || fallback_block_3(ctx);
  return {
    c() {
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(icon_slot_template, ctx2[25], dirty, get_icon_slot_changes_1),
            get_icon_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block_9$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `(${ctx[11]})`;
      attr(span, "class", "postname svelte-o4urkb");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_8$1(ctx) {
  return { c: noop$1, m: noop$1, d: noop$1 };
}
function create_if_block_5$1(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_6$1, create_if_block_7$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5] || ctx2[2] || ctx2[17].detail)
      return 0;
    if (ctx2[4])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "class", "subtitle svelte-o4urkb");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_if_block_7$1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_if_block_6$1(ctx) {
  let span;
  let current;
  const detail_slot_template = ctx[26].detail;
  const detail_slot = create_slot(detail_slot_template, ctx, ctx[25], get_detail_slot_context);
  const detail_slot_or_fallback = detail_slot || fallback_block_1$1(ctx);
  return {
    c() {
      span = element("span");
      if (detail_slot_or_fallback)
        detail_slot_or_fallback.c();
      attr(span, "class", "detail svelte-o4urkb");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (detail_slot_or_fallback) {
        detail_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (detail_slot) {
        if (detail_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            detail_slot,
            detail_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(detail_slot_template, ctx2[25], dirty, get_detail_slot_changes),
            get_detail_slot_context
          );
        }
      } else {
        if (detail_slot_or_fallback && detail_slot_or_fallback.p && (!current || dirty[0] & 100)) {
          detail_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(detail_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(detail_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detail_slot_or_fallback)
        detail_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_1$1(ctx) {
  let t0;
  let t1_value = (ctx[5] || ctx[2]) + "";
  let t1;
  return {
    c() {
      t0 = text(ctx[6]);
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64)
        set_data(t0, ctx2[6]);
      if (dirty[0] & 36 && t1_value !== (t1_value = (ctx2[5] || ctx2[2]) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_if_block_3$3(ctx) {
  let div;
  let span;
  let promise2;
  let t;
  let if_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1$1,
    then: create_then_block_1$1,
    catch: create_catch_block_1$1,
    value: 33
  };
  handle_promise(promise2 = ctx[16](ctx[0]), info);
  let if_block = ctx[1] && create_if_block_4$3(ctx);
  return {
    c() {
      div = element("div");
      span = element("span");
      info.block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "number svelte-o4urkb");
      attr(div, "class", "amount svelte-o4urkb");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      info.block.m(span, info.anchor = null);
      info.mount = () => span;
      info.anchor = null;
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty[0] & 1 && promise2 !== (promise2 = ctx[16](ctx[0])) && handle_promise(promise2, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
      if (ctx[1]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_4$3(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_2$6(ctx) {
  let current;
  const status_slot_template = ctx[26].status;
  const status_slot = create_slot(status_slot_template, ctx, ctx[25], get_status_slot_context);
  return {
    c() {
      if (status_slot)
        status_slot.c();
    },
    m(target, anchor) {
      if (status_slot) {
        status_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (status_slot) {
        if (status_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            status_slot,
            status_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(status_slot_template, ctx2[25], dirty, get_status_slot_changes),
            get_status_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(status_slot, local);
      current = true;
    },
    o(local) {
      transition_out(status_slot, local);
      current = false;
    },
    d(detaching) {
      if (status_slot)
        status_slot.d(detaching);
    }
  };
}
function create_catch_block_1$1(ctx) {
  return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
}
function create_then_block_1$1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[0]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_pending_block_1$1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[9]);
      attr(span, "class", "font-family_mono svelte-o4urkb");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data(t, ctx2[9]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_4$3(ctx) {
  let div;
  let span;
  let promise2;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    value: 32
  };
  handle_promise(promise2 = ctx[1], info);
  return {
    c() {
      div = element("div");
      span = element("span");
      info.block.c();
      attr(span, "class", "fiat svelte-o4urkb");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      info.block.m(span, info.anchor = null);
      info.mount = () => span;
      info.anchor = null;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty[0] & 2 && promise2 !== (promise2 = ctx[1]) && handle_promise(promise2, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block$3(ctx) {
  return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
}
function create_then_block$3(ctx) {
  let t_value = ctx[32] + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t_value !== (t_value = ctx2[32] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block$3(ctx) {
  let t;
  return {
    c() {
      t = text("$...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$7(ctx) {
  let current;
  const right_slot_template = ctx[26].right;
  const right_slot = create_slot(right_slot_template, ctx, ctx[25], get_right_slot_context);
  return {
    c() {
      if (right_slot)
        right_slot.c();
    },
    m(target, anchor) {
      if (right_slot) {
        right_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (right_slot) {
        if (right_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            right_slot,
            right_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(right_slot_template, ctx2[25], dirty, get_right_slot_changes),
            get_right_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(right_slot, local);
      current = true;
    },
    o(local) {
      transition_out(right_slot, local);
      current = false;
    },
    d(detaching) {
      if (right_slot)
        right_slot.d(detaching);
    }
  };
}
function create_if_block$c(ctx) {
  let current;
  const tags_slot_template = ctx[26].tags;
  const tags_slot = create_slot(tags_slot_template, ctx, ctx[25], get_tags_slot_context);
  return {
    c() {
      if (tags_slot)
        tags_slot.c();
    },
    m(target, anchor) {
      if (tags_slot) {
        tags_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (tags_slot) {
        if (tags_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            tags_slot,
            tags_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(tags_slot_template, ctx2[25], dirty, get_tags_slot_changes),
            get_tags_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tags_slot, local);
      current = true;
    },
    o(local) {
      transition_out(tags_slot, local);
      current = false;
    },
    d(detaching) {
      if (tags_slot)
        tags_slot.d(detaching);
    }
  };
}
function create_fragment$j(ctx) {
  let div3;
  let div1;
  let span0;
  let span0_class_value;
  let t0;
  let span5;
  let span3;
  let div0;
  let span2;
  let span1;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let span4;
  let current_block_type_index;
  let if_block3;
  let t6;
  let t7;
  let div2;
  let t8;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = ctx[26].icon;
  const icon_slot = create_slot(icon_slot_template, ctx, ctx[25], get_icon_slot_context);
  const icon_slot_or_fallback = icon_slot || fallback_block_2(ctx);
  let if_block0 = ctx[11] && create_if_block_9$1(ctx);
  let if_block1 = ctx[3] && create_if_block_8$1();
  let if_block2 = (ctx[4] || ctx[2] || ctx[5] || ctx[15].length || ctx[17].detail) && create_if_block_5$1(ctx);
  const if_block_creators = [create_if_block_2$6, create_if_block_3$3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[17].status)
      return 0;
    if (ctx2[0])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block4 = ctx[17].right && create_if_block_1$7(ctx);
  let if_block5 = (ctx[15].length || ctx[17].tags) && create_if_block$c(ctx);
  const below_slot_template = ctx[26].below;
  const below_slot = create_slot(below_slot_template, ctx, ctx[25], get_below_slot_context);
  return {
    c() {
      div3 = element("div");
      div1 = element("div");
      span0 = element("span");
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.c();
      t0 = space();
      span5 = element("span");
      span3 = element("span");
      div0 = element("div");
      span2 = element("span");
      span1 = element("span");
      t1 = text(ctx[10]);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      span4 = element("span");
      if (if_block3)
        if_block3.c();
      t6 = space();
      if (if_block4)
        if_block4.c();
      t7 = space();
      div2 = element("div");
      if (if_block5)
        if_block5.c();
      t8 = space();
      if (below_slot)
        below_slot.c();
      attr(span0, "class", span0_class_value = "icon " + ctx[8] + " svelte-o4urkb");
      attr(span1, "class", "text svelte-o4urkb");
      attr(span2, "class", "name svelte-o4urkb");
      attr(div0, "class", "title svelte-o4urkb");
      attr(span3, "class", "main part svelte-o4urkb");
      attr(span4, "class", "status part svelte-o4urkb");
      attr(span5, "class", "content svelte-o4urkb");
      attr(div1, "class", "banner svelte-o4urkb");
      attr(div2, "class", "rest svelte-o4urkb");
      attr(div3, "class", "row " + ctx[14] + " svelte-o4urkb");
      attr(div3, "style", ctx[7]);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div1);
      append(div1, span0);
      if (icon_slot_or_fallback) {
        icon_slot_or_fallback.m(span0, null);
      }
      append(div1, t0);
      append(div1, span5);
      append(span5, span3);
      append(span3, div0);
      append(div0, span2);
      append(span2, span1);
      append(span1, t1);
      append(span1, t2);
      if (if_block0)
        if_block0.m(span1, null);
      append(div0, t3);
      if (if_block1)
        if_block1.m(div0, null);
      append(span3, t4);
      if (if_block2)
        if_block2.m(span3, null);
      append(span5, t5);
      append(span5, span4);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span4, null);
      }
      append(div1, t6);
      if (if_block4)
        if_block4.m(div1, null);
      append(div3, t7);
      append(div3, div2);
      if (if_block5)
        if_block5.m(div2, null);
      append(div2, t8);
      if (below_slot) {
        below_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div3, "click", ctx[27]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(icon_slot_template, ctx2[25], dirty, get_icon_slot_changes),
            get_icon_slot_context
          );
        }
      } else {
        if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty[0] & 33554432)) {
          icon_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & 256 && span0_class_value !== (span0_class_value = "icon " + ctx2[8] + " svelte-o4urkb")) {
        attr(span0, "class", span0_class_value);
      }
      if (ctx2[11])
        if_block0.p(ctx2, dirty);
      if (ctx2[3]) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_8$1();
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[4] || ctx2[2] || ctx2[5] || ctx2[15].length || ctx2[17].detail) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 131124) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_5$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(span3, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block3) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block3 = if_blocks[current_block_type_index];
          if (!if_block3) {
            if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block3.c();
          } else {
            if_block3.p(ctx2, dirty);
          }
          transition_in(if_block3, 1);
          if_block3.m(span4, null);
        } else {
          if_block3 = null;
        }
      }
      if (ctx2[17].right) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & 131072) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1$7(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div1, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (ctx2[15].length || ctx2[17].tags) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & 131072) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block$c(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, t8);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (below_slot) {
        if (below_slot.p && (!current || dirty[0] & 33554432)) {
          update_slot_base(
            below_slot,
            below_slot_template,
            ctx2,
            ctx2[25],
            !current ? get_all_dirty_from_scope(ctx2[25]) : get_slot_changes(below_slot_template, ctx2[25], dirty, get_below_slot_changes),
            get_below_slot_context
          );
        }
      }
      if (!current || dirty[0] & 128) {
        attr(div3, "style", ctx2[7]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot_or_fallback, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(below_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot_or_fallback, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(below_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (icon_slot_or_fallback)
        icon_slot_or_fallback.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (below_slot)
        below_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let $yw_store_tags;
  component_subscribe($$self, yw_store_tags, ($$value) => $$invalidate(28, $yw_store_tags = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { resourcePath = "" } = $$props;
  const p_resource = resourcePath;
  let { resource = null } = $$props;
  const g_resource = resource;
  let { name = g_resource?.name } = $$props;
  const s_name = name;
  let { postname = "" } = $$props;
  const s_postname = postname;
  let { pfp = g_resource?.pfp } = $$props;
  const p_pfp = pfp;
  let { pfpDim = 48 } = $$props;
  const x_dim_pfp = pfpDim;
  let { amount = "" } = $$props;
  let { fiat = "" } = $$props;
  let { symbol = "" } = $$props;
  let { lockIcon = false } = $$props;
  let { address = "" } = $$props;
  let { detail = "" } = $$props;
  let { prefix = "" } = $$props;
  let { rootStyle = "" } = $$props;
  let { rootClasses = "" } = $$props;
  const s_classes = rootClasses;
  let { iconClass = "" } = $$props;
  const a_tags2 = $yw_store_tags?.getTagsFor(p_resource) || [];
  const as_intervals = /* @__PURE__ */ new Set();
  onDestroy(() => {
    for (const i_interval of as_intervals) {
      clearInterval(i_interval);
    }
  });
  let s_spin = "";
  async function start_spinner(dp_thing) {
    const A_SPIN = ["\u25DC \u25DD", " \u02C9\u25DE", " \u02CD\u25DD", "\u25DF \u25DE", "\u25DC\u02CD ", "\u25DF\u02C9 "];
    let i_spin = 0;
    $$invalidate(9, s_spin = A_SPIN[0]);
    if (dp_thing instanceof Promise) {
      const i_interval = window.setInterval(
        () => {
          i_spin = (i_spin + 1) % A_SPIN.length;
          $$invalidate(9, s_spin = A_SPIN[i_spin]);
        },
        125
      );
      as_intervals.add(i_interval);
      const w_value = await dp_thing;
      clearInterval(i_interval);
      return w_value;
    }
    return dp_thing;
  }
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("resourcePath" in $$props2)
      $$invalidate(18, resourcePath = $$props2.resourcePath);
    if ("resource" in $$props2)
      $$invalidate(19, resource = $$props2.resource);
    if ("name" in $$props2)
      $$invalidate(20, name = $$props2.name);
    if ("postname" in $$props2)
      $$invalidate(21, postname = $$props2.postname);
    if ("pfp" in $$props2)
      $$invalidate(22, pfp = $$props2.pfp);
    if ("pfpDim" in $$props2)
      $$invalidate(23, pfpDim = $$props2.pfpDim);
    if ("amount" in $$props2)
      $$invalidate(0, amount = $$props2.amount);
    if ("fiat" in $$props2)
      $$invalidate(1, fiat = $$props2.fiat);
    if ("symbol" in $$props2)
      $$invalidate(2, symbol = $$props2.symbol);
    if ("lockIcon" in $$props2)
      $$invalidate(3, lockIcon = $$props2.lockIcon);
    if ("address" in $$props2)
      $$invalidate(4, address = $$props2.address);
    if ("detail" in $$props2)
      $$invalidate(5, detail = $$props2.detail);
    if ("prefix" in $$props2)
      $$invalidate(6, prefix = $$props2.prefix);
    if ("rootStyle" in $$props2)
      $$invalidate(7, rootStyle = $$props2.rootStyle);
    if ("rootClasses" in $$props2)
      $$invalidate(24, rootClasses = $$props2.rootClasses);
    if ("iconClass" in $$props2)
      $$invalidate(8, iconClass = $$props2.iconClass);
    if ("$$scope" in $$props2)
      $$invalidate(25, $$scope = $$props2.$$scope);
  };
  return [
    amount,
    fiat,
    symbol,
    lockIcon,
    address,
    detail,
    prefix,
    rootStyle,
    iconClass,
    s_spin,
    s_name,
    s_postname,
    p_pfp,
    x_dim_pfp,
    s_classes,
    a_tags2,
    start_spinner,
    $$slots,
    resourcePath,
    resource,
    name,
    postname,
    pfp,
    pfpDim,
    rootClasses,
    $$scope,
    slots,
    click_handler2
  ];
}
class Row extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$i,
      create_fragment$j,
      safe_not_equal,
      {
        resourcePath: 18,
        resource: 19,
        name: 20,
        postname: 21,
        pfp: 22,
        pfpDim: 23,
        amount: 0,
        fiat: 1,
        symbol: 2,
        lockIcon: 3,
        address: 4,
        detail: 5,
        prefix: 6,
        rootStyle: 7,
        rootClasses: 24,
        iconClass: 8
      },
      null,
      [-1, -1]
    );
  }
}
var Header_svelte_svelte_type_style_lang = "";
var SubHeader_svelte_svelte_type_style_lang = "";
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block$8(ctx) {
  let button;
  let span;
  let t_value = ctx[10] + "";
  let t;
  let mounted;
  let dispose;
  function click_handler2() {
    return ctx[7](ctx[10]);
  }
  return {
    c() {
      button = element("button");
      span = element("span");
      t = text(t_value);
      attr(span, "class", "text");
      attr(button, "class", "pill");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      append(span, t);
      if (!mounted) {
        dispose = listen(button, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2 && t_value !== (t_value = ctx[10] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$6(ctx) {
  let button;
  let span0;
  let t0;
  let span1;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      span1.textContent = "Add New";
      attr(span0, "class", "icon svelte-44hl34");
      attr(span1, "class", "text");
      attr(button, "class", "pill svelte-44hl34");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span0);
      span0.innerHTML = SX_ICON_ADD$1;
      append(button, t0);
      append(button, span1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[8]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$b(ctx) {
  let close;
  let current;
  close = new Close({});
  close.$on("click", ctx[9]);
  return {
    c() {
      create_component(close.$$.fragment);
    },
    m(target, anchor) {
      mount_component(close, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(close, detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let div;
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  let t3;
  let current;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  }
  let if_block0 = !ctx[2] && create_if_block_1$6(ctx);
  let if_block1 = ctx[4] && create_if_block$b(ctx);
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = text(ctx[0]);
      t1 = space();
      span1 = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      attr(span0, "class", "text");
      attr(span1, "class", "right svelte-44hl34");
      attr(div, "class", "title svelte-44hl34");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, t0);
      append(div, t1);
      append(div, span1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span1, null);
      }
      append(span1, t2);
      if (if_block0)
        if_block0.m(span1, null);
      append(span1, t3);
      if (if_block1)
        if_block1.m(span1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1)
        set_data(t0, ctx2[0]);
      if (dirty & 34) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span1, t2);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$6(ctx2);
          if_block0.c();
          if_block0.m(span1, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[4])
        if_block1.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let $yw_popup;
  component_subscribe($$self, yw_popup, ($$value) => $$invalidate(3, $yw_popup = $$value));
  let { title } = $$props;
  let { buttons = [] } = $$props;
  let { bare = false } = $$props;
  let { closes = false } = $$props;
  const b_closes = closes;
  const dispatch2 = createEventDispatcher();
  const click_handler2 = (s_button) => dispatch2(s_button.toLowerCase().replace(/\s/g, "_"));
  const click_handler_1 = () => dispatch2("add_new");
  const click_handler_2 = () => set_store_value(yw_popup, $yw_popup = null, $yw_popup);
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("buttons" in $$props2)
      $$invalidate(1, buttons = $$props2.buttons);
    if ("bare" in $$props2)
      $$invalidate(2, bare = $$props2.bare);
    if ("closes" in $$props2)
      $$invalidate(6, closes = $$props2.closes);
  };
  return [
    title,
    buttons,
    bare,
    $yw_popup,
    b_closes,
    dispatch2,
    closes,
    click_handler2,
    click_handler_1,
    click_handler_2
  ];
}
class SubHeader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$i, safe_not_equal, { title: 0, buttons: 1, bare: 2, closes: 6 });
  }
}
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
function quintOut(t) {
  return --t * t * t * t * t + 1;
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const height = parseFloat(style.height);
  const padding_top = parseFloat(style.paddingTop);
  const padding_bottom = parseFloat(style.paddingBottom);
  const margin_top = parseFloat(style.marginTop);
  const margin_bottom = parseFloat(style.marginBottom);
  const border_top_width = parseFloat(style.borderTopWidth);
  const border_bottom_width = parseFloat(style.borderBottomWidth);
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};height: ${t * height}px;padding-top: ${t * padding_top}px;padding-bottom: ${t * padding_bottom}px;margin-top: ${t * margin_top}px;margin-bottom: ${t * margin_bottom}px;border-top-width: ${t * border_top_width}px;border-bottom-width: ${t * border_bottom_width}px;`
  };
}
var Field_svelte_svelte_type_style_lang = "";
const get_post_slot_changes = (dirty) => ({});
const get_post_slot_context = (ctx) => ({});
function create_fragment$h(ctx) {
  let div2;
  let div0;
  let label;
  let t0;
  let div0_transition;
  let t1;
  let div1;
  let div1_transition;
  let t2;
  let div2_id_value;
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  const post_slot_template = ctx[6].post;
  const post_slot = create_slot(post_slot_template, ctx, ctx[5], get_post_slot_context);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      label = element("label");
      t0 = text(ctx[0]);
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (post_slot)
        post_slot.c();
      attr(label, "for", ctx[1]);
      attr(div0, "class", "field-name svelte-yry0w8");
      attr(div1, "class", "field-value svelte-yry0w8");
      attr(div2, "class", "field svelte-yry0w8");
      attr(div2, "id", div2_id_value = "field-" + ctx[1]);
      toggle_class(div2, "short", ctx[2]);
      toggle_class(div2, "double", ctx[4]);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, label);
      append(label, t0);
      append(div2, t1);
      append(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append(div2, t2);
      if (post_slot) {
        post_slot.m(div2, null);
      }
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & 1)
        set_data(t0, ctx[0]);
      if (!current || dirty & 2) {
        attr(label, "for", ctx[1]);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[5],
            !current ? get_all_dirty_from_scope(ctx[5]) : get_slot_changes(default_slot_template, ctx[5], dirty, null),
            null
          );
        }
      }
      if (post_slot) {
        if (post_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            post_slot,
            post_slot_template,
            ctx,
            ctx[5],
            !current ? get_all_dirty_from_scope(ctx[5]) : get_slot_changes(post_slot_template, ctx[5], dirty, get_post_slot_changes),
            get_post_slot_context
          );
        }
      }
      if (!current || dirty & 2 && div2_id_value !== (div2_id_value = "field-" + ctx[1])) {
        attr(div2, "id", div2_id_value);
      }
      if (dirty & 4) {
        toggle_class(div2, "short", ctx[2]);
      }
      if (dirty & 16) {
        toggle_class(div2, "double", ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div0_transition)
          div0_transition = create_bidirectional_transition(div0, slide, { duration: ctx[3] ? 350 : 0 }, true);
        div0_transition.run(1);
      });
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, slide, { duration: ctx[3] ? 350 : 0 }, true);
        div1_transition.run(1);
      });
      transition_in(post_slot, local);
      current = true;
    },
    o(local) {
      if (!div0_transition)
        div0_transition = create_bidirectional_transition(div0, slide, { duration: ctx[3] ? 350 : 0 }, false);
      div0_transition.run(0);
      transition_out(default_slot, local);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, slide, { duration: ctx[3] ? 350 : 0 }, false);
      div1_transition.run(0);
      transition_out(post_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if (detaching && div0_transition)
        div0_transition.end();
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div1_transition)
        div1_transition.end();
      if (post_slot)
        post_slot.d(detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = "" } = $$props;
  let { key } = $$props;
  let { short = false } = $$props;
  let { slides = false } = $$props;
  let { double = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("key" in $$props2)
      $$invalidate(1, key = $$props2.key);
    if ("short" in $$props2)
      $$invalidate(2, short = $$props2.short);
    if ("slides" in $$props2)
      $$invalidate(3, slides = $$props2.slides);
    if ("double" in $$props2)
      $$invalidate(4, double = $$props2.double);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [name, key, short, slides, double, $$scope, slots];
}
class Field extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$h, safe_not_equal, {
      name: 0,
      key: 1,
      short: 2,
      slides: 3,
      double: 4
    });
  }
}
var Log_svelte_svelte_type_style_lang = "";
var ActionsLine_svelte_svelte_type_style_lang = "";
function create_if_block$a(ctx) {
  let button;
  let t_value = ctx[5] ? "Cancel" : "Back";
  let t;
  let button_disabled_value;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t = text(t_value);
      button.disabled = button_disabled_value = ctx[0] || ctx[2];
      attr(button, "class", "svelte-11kqquk");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", ctx[15]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 5 && button_disabled_value !== (button_disabled_value = ctx2[0] || ctx2[2])) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$g(ctx) {
  let div;
  let t0;
  let button;
  let t1;
  let button_disabled_value;
  let mounted;
  let dispose;
  let if_block = (ctx[5] || ctx[6]) && create_if_block$a(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      button = element("button");
      t1 = text(ctx[4]);
      button.disabled = button_disabled_value = ctx[3] || ctx[0] || ctx[1] || ctx[2];
      attr(button, "class", "primary svelte-11kqquk");
      attr(div, "class", "actions-line svelte-11kqquk");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      append(div, t0);
      append(div, button);
      append(button, t1);
      if (!mounted) {
        dispose = listen(button, "click", ctx[16]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[5] || ctx2[6])
        if_block.p(ctx2, dirty);
      if (dirty & 16)
        set_data(t1, ctx2[4]);
      if (dirty & 15 && button_disabled_value !== (button_disabled_value = ctx2[3] || ctx2[0] || ctx2[1] || ctx2[2])) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let s_confirm_final;
  let b_disabled;
  let { cancel = false } = $$props;
  const b_cancel = !!cancel;
  const f_cancel = "function" === typeof cancel ? cancel : F_NOOP;
  let { back = false } = $$props;
  const b_back = back;
  let { confirm = ["Done", F_NOOP, false] } = $$props;
  const [s_confirm, f_confirm] = confirm;
  let s_confirm_append = "";
  let { wait: wait2 = 0 } = $$props;
  const xt_wait = true === wait2 ? 5e3 : wait2 || 0;
  let b_waiting = xt_wait > 0;
  if (b_waiting) {
    let n_seconds = Math.round(xt_wait / 1e3);
    s_confirm_append = ` (${n_seconds}s)`;
    const i_interval = setInterval(
      () => {
        n_seconds -= 1;
        $$invalidate(14, s_confirm_append = ` (${n_seconds}s)`);
      },
      1e3
    );
    setTimeout(
      () => {
        $$invalidate(1, b_waiting = false);
        $$invalidate(14, s_confirm_append = "");
        clearInterval(i_interval);
      },
      xt_wait
    );
  }
  let b_busy = false;
  let { disabled = false } = $$props;
  let { contd = null } = $$props;
  const f_continue = contd ? () => k_page.push(contd) : null;
  const k_page = getContext("page");
  function cancel_action() {
    if (b_cancel && f_cancel) {
      f_cancel();
    }
    if (b_back || "pop" === cancel) {
      k_page.pop();
    }
  }
  async function confirm_action() {
    let b_continue = true;
    $$invalidate(2, b_busy = true);
    try {
      await (f_confirm || F_NOOP)();
    } catch (e_confirm) {
      b_continue = false;
    }
    $$invalidate(2, b_busy = false);
    if (f_continue && b_continue) {
      f_continue();
    }
  }
  const click_handler2 = () => cancel_action();
  const click_handler_1 = () => confirm_action();
  $$self.$$set = ($$props2) => {
    if ("cancel" in $$props2)
      $$invalidate(9, cancel = $$props2.cancel);
    if ("back" in $$props2)
      $$invalidate(10, back = $$props2.back);
    if ("confirm" in $$props2)
      $$invalidate(11, confirm = $$props2.confirm);
    if ("wait" in $$props2)
      $$invalidate(12, wait2 = $$props2.wait);
    if ("disabled" in $$props2)
      $$invalidate(0, disabled = $$props2.disabled);
    if ("contd" in $$props2)
      $$invalidate(13, contd = $$props2.contd);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16384) {
      $$invalidate(4, s_confirm_final = s_confirm + s_confirm_append);
    }
    if ($$self.$$.dirty & 2048) {
      $$invalidate(3, b_disabled = confirm[2] || false);
    }
  };
  return [
    disabled,
    b_waiting,
    b_busy,
    b_disabled,
    s_confirm_final,
    b_cancel,
    b_back,
    cancel_action,
    confirm_action,
    cancel,
    back,
    confirm,
    wait2,
    contd,
    s_confirm_append,
    click_handler2,
    click_handler_1
  ];
}
class ActionsLine extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$g, safe_not_equal, {
      cancel: 9,
      back: 10,
      confirm: 11,
      wait: 12,
      disabled: 0,
      contd: 13
    });
  }
}
var StarShellTitle_svelte_svelte_type_style_lang = "";
var Register_svelte_svelte_type_style_lang = "";
var SX_SEND = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none">\n	<g style="fill: var(--svg-color-fg, currentColor);">\n		<rect x="12" y="4" width="2" height="9" />\n		<rect x="5" y="6" width="2" height="9" transform="rotate(-90 5 6)" />\n		<path d="M14 5.5V4H12.5L3 13.5L4.5 15L14 5.5Z" />\n	</g>\n</svg>\n';
var SX_RECV = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none">\n	<style>\n		.s2r-action-recv-fg-stroke {\n			stroke: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path style="fill:var(--svg-color-fg, currentColor)" d="M3 14h12v2H3z"/>\n	<path class="s2r-action-recv-fg-stroke" d="M9 12V1M4.5 7.5 9 12l4.5-4.5" stroke-width="2"/>\n</svg>';
var SX_ICON_ADD = '<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22">\n	<g style="fill: var(--svg-color-fg, currentColor);">\n		<rect x="10" y="4" width="2" height="14" rx="1" />\n		<rect x="4" y="10" width="14" height="2" ry="1" />\n	</g>\n</svg>';
var SX_ICON_INFO = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>';
var SX_ICON_EDIT$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>\n</svg>';
var SX_ICON_DELETE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M16 9v10H8V9h8m-1.5-6h-5l-1 1H5v2h14V4h-3.5l-1-1zM18 7H6v12c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7z"/>\n</svg>';
var SX_ICON_WRAP = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">\n	<style>\n		.star-action-wrap-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="star-action-wrap-fg" d="M11,3.6L7.8,6.7L4.6,3.6c-0.3-0.3-0.8-0.3-1.1,0s-0.3,0.8,0,1.1l3.7,3.7c0.3,0.3,0.8,0.3,1.1,0L12,4.7 c0.3-0.3,0.3-0.8,0-1.1C11.8,3.3,11.3,3.3,11,3.6z M12.6,12.3c0,0.4-0.3,0.8-0.7,0.8H3.7c-0.4,0-0.8-0.4-0.8-0.8l0,0l0,0v-1.6 c0-0.4,0.4-0.8,0.8-0.8s0.8,0.4,0.8,0.8v0.8H11v-0.8c0-0.4,0.4-0.8,0.8-0.8s0.8,0.4,0.8,0.8V12.3C12.7,12.3,12.7,12.3,12.6,12.3 L12.6,12.3z" />\n</svg>\n';
var SX_ICON_UNWRAP = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none">\n	<style>\n		.star-action-unwrap-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="star-action-unwrap-fg" d="M12,7.8c0.3-0.3,0.3-0.8,0-1.1L8.3,3C8,2.7,7.5,2.7,7.2,3L3.5,6.8C3.2,7,3.2,7.5,3.5,7.8c0.3,0.3,0.8,0.3,1.1,0\n	l3.2-3.1L11,7.8C11.3,8.1,11.8,8.1,12,7.8z M12.6,12.4c0,0.4-0.3,0.8-0.7,0.8H3.7c-0.4,0-0.8-0.4-0.8-0.8l0,0l0,0v-1.6\n	c0-0.4,0.4-0.8,0.8-0.8s0.8,0.4,0.8,0.8v0.8H11v-0.8c0-0.4,0.4-0.8,0.8-0.8s0.8,0.4,0.8,0.8V12.4L12.6,12.4L12.6,12.4z" />\n</svg>\n';
var SX_ICON_EDIT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24">\n	<circle cx="11" cy="11" r="10" fill="none" style="stroke:var(--svg-color-bg, currentColor)"/>\n	<path style="fill:var(--svg-color-fg, currentColor)" d="m8.364 11.631 5.656-5.657L16 7.954l-5.657 5.657zM7.6 12.4 7 13v2h2l.6-.6z"/>\n</svg>';
var SX_ICON_CHECKED = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18">\n	<style type="text/css">\n		.s2r-checked-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-checked-fg" d="M16 0H2C0.9 0 0 0.9 0 2V16C0 17.1 0.9 18 2 18H16C17.1 18 18 17.1 18 16V2C18 0.9 17.1 0 16 0ZM7.71 13.29C7.32 13.68 6.69 13.68 6.3 13.29L2.71 9.7C2.32 9.31 2.32 8.68 2.71 8.29C3.1 7.9 3.73 7.9 4.12 8.29L7 11.17L13.88 4.29C14.27 3.9 14.9 3.9 15.29 4.29C15.68 4.68 15.68 5.31 15.29 5.7L7.71 13.29Z" />\n</svg>\n';
var SX_ICON_UNCHECKED = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18">\n	<style type="text/css">\n		.s2r-unchecked-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-unchecked-fg" d="M15 16H3C2.45 16 2 15.55 2 15V3C2 2.45 2.45 2 3 2H15C15.55 2 16 2.45 16 3V15C16 15.55 15.55 16 15 16ZM16 0H2C0.9 0 0 0.9 0 2V16C0 17.1 0.9 18 2 18H16C17.1 18 18 17.1 18 16V2C18 0.9 17.1 0 16 0Z" />\n</svg>\n';
var CheckboxField_svelte_svelte_type_style_lang = "";
function create_if_block$9(ctx) {
  let label;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      attr(label, "for", ctx[3]);
    },
    m(target, anchor) {
      insert(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(label, "click", click_handler);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(label);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$f(ctx) {
  let fieldset;
  let span1;
  let input;
  let t0;
  let span0;
  let raw_value = (ctx[0] ? SX_ICON_CHECKED : SX_ICON_UNCHECKED) + "";
  let t1;
  let fieldset_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[4].default && create_if_block$9(ctx);
  return {
    c() {
      fieldset = element("fieldset");
      span1 = element("span");
      input = element("input");
      t0 = space();
      span0 = element("span");
      t1 = space();
      if (if_block)
        if_block.c();
      attr(input, "id", ctx[3]);
      attr(input, "type", "checkbox");
      input.hidden = true;
      attr(span0, "class", "icon svelte-1fxz7ga");
      attr(span1, "class", "checkbox");
      attr(fieldset, "class", fieldset_class_value = null_to_empty(ctx[1]) + " svelte-1fxz7ga");
    },
    m(target, anchor) {
      insert(target, fieldset, anchor);
      append(fieldset, span1);
      append(span1, input);
      input.checked = ctx[0];
      append(span1, t0);
      append(span1, span0);
      span0.innerHTML = raw_value;
      append(fieldset, t1);
      if (if_block)
        if_block.m(fieldset, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[8]),
          listen(fieldset, "click", function() {
            if (is_function(ctx[2] ? F_NOOP : ctx[9]))
              (ctx[2] ? F_NOOP : ctx[9]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & 1) {
        input.checked = ctx[0];
      }
      if ((!current || dirty & 1) && raw_value !== (raw_value = (ctx[0] ? SX_ICON_CHECKED : SX_ICON_UNCHECKED) + ""))
        span0.innerHTML = raw_value;
      if (ctx[4].default) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$9(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(fieldset, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 2 && fieldset_class_value !== (fieldset_class_value = null_to_empty(ctx[1]) + " svelte-1fxz7ga")) {
        attr(fieldset, "class", fieldset_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(fieldset);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const click_handler = (d_event) => d_event.stopImmediatePropagation();
function instance$e($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { id } = $$props;
  const s_id = id;
  let { containerClass = "" } = $$props;
  let { checked = false } = $$props;
  let { disableHandler = false } = $$props;
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  const click_handler_1 = () => $$invalidate(0, checked = !checked);
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(5, id = $$props2.id);
    if ("containerClass" in $$props2)
      $$invalidate(1, containerClass = $$props2.containerClass);
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("disableHandler" in $$props2)
      $$invalidate(2, disableHandler = $$props2.disableHandler);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    checked,
    containerClass,
    disableHandler,
    s_id,
    $$slots,
    id,
    $$scope,
    slots,
    input_change_handler,
    click_handler_1
  ];
}
class CheckboxField extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$f, safe_not_equal, {
      id: 5,
      containerClass: 1,
      checked: 0,
      disableHandler: 2
    });
  }
}
var PopupTagsSelect_svelte_svelte_type_style_lang = "";
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i].tag;
  child_ctx[12] = list[i].selected;
  child_ctx[13] = list;
  child_ctx[14] = i;
  return child_ctx;
}
function create_right_slot$1(ctx) {
  let checkboxfield;
  let updating_checked;
  let t;
  let current;
  function checkboxfield_checked_binding(value) {
    ctx[3](value, ctx[12], ctx[13], ctx[14]);
  }
  let checkboxfield_props = {
    id: "tag-$" + ctx[11].index,
    disableHandler: true
  };
  if (ctx[12] !== void 0) {
    checkboxfield_props.checked = ctx[12];
  }
  checkboxfield = new CheckboxField({ props: checkboxfield_props });
  binding_callbacks.push(() => bind(checkboxfield, "checked", checkboxfield_checked_binding));
  return {
    c() {
      create_component(checkboxfield.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(checkboxfield, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const checkboxfield_changes = {};
      if (dirty & 1)
        checkboxfield_changes.id = "tag-$" + ctx[11].index;
      if (!updating_checked && dirty & 1) {
        updating_checked = true;
        checkboxfield_changes.checked = ctx[12];
        add_flush_callback(() => updating_checked = false);
      }
      checkboxfield.$set(checkboxfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkboxfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(checkboxfield, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$7(ctx) {
  let row;
  let current;
  function click_handler2() {
    return ctx[4](ctx[11]);
  }
  row = new Row({
    props: {
      rootStyle: "--app-icon-diameter:12px;",
      iconClass: "align-self_center",
      name: ctx[11].name,
      $$slots: { right: [create_right_slot$1] },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1)
        row_changes.name = ctx[11].name;
      if (dirty & 32769) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_fragment$e(ctx) {
  let section;
  let subheader;
  let t0;
  let div0;
  let t1;
  let div1;
  let actionsline;
  let current;
  subheader = new SubHeader({
    props: {
      title: "Select Tag(s)",
      bare: true,
      closes: true
    }
  });
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  actionsline = new ActionsLine({
    props: {
      confirm: ["Apply", ctx[2]]
    }
  });
  return {
    c() {
      section = element("section");
      create_component(subheader.$$.fragment);
      t0 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div1 = element("div");
      create_component(actionsline.$$.fragment);
      attr(div0, "class", "rows svelte-vooes4");
      attr(div1, "class", "float svelte-vooes4");
      attr(section, "class", "screen");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      mount_component(subheader, section, null);
      append(section, t0);
      append(section, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      append(section, t1);
      append(section, div1);
      mount_component(actionsline, div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$7(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(subheader.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(subheader.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(section);
      destroy_component(subheader);
      destroy_each(each_blocks, detaching);
      destroy_component(actionsline);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let $yw_popup;
  let $yw_store_tags;
  let $yw_context_popup;
  component_subscribe($$self, yw_popup, ($$value) => $$invalidate(5, $yw_popup = $$value));
  component_subscribe($$self, yw_store_tags, ($$value) => $$invalidate(6, $yw_store_tags = $$value));
  component_subscribe($$self, yw_context_popup, ($$value) => $$invalidate(7, $yw_context_popup = $$value));
  const p_resource = $yw_context_popup["resource"];
  const f_sort_tags = (g_a, g_b) => g_a.index - g_b.index;
  const as_preapplied = new Set($yw_store_tags.getIdsFor(p_resource));
  let a_tag_options = $yw_store_tags.raw.registry.sort(f_sort_tags).map((g_tag) => ({
    tag: g_tag,
    selected: as_preapplied.has(g_tag.index)
  }));
  function toggle_tag(i_tag) {
    const g_option = a_tag_options.find((g) => i_tag === g.tag.index);
    g_option.selected = !g_option.selected;
    $$invalidate(0, a_tag_options);
  }
  async function apply_tags() {
    await $yw_store_tags.setTagsFor(p_resource, a_tags);
    set_store_value(yw_popup, $yw_popup = null, $yw_popup);
  }
  function checkboxfield_checked_binding(value, b_selected, each_value, each_index) {
    each_value[each_index].selected = value;
    $$invalidate(0, a_tag_options);
  }
  const click_handler2 = (g_tag) => toggle_tag(g_tag.index);
  return [
    a_tag_options,
    toggle_tag,
    apply_tags,
    checkboxfield_checked_binding,
    click_handler2
  ];
}
class PopupTagsSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$e, safe_not_equal, {});
  }
}
var InlineTags_svelte_svelte_type_style_lang = "";
const get_suffix_slot_changes = (dirty) => ({});
const get_suffix_slot_context = (ctx) => ({});
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  child_ctx[28] = i;
  return child_ctx;
}
const get_prefix_slot_changes = (dirty) => ({});
const get_prefix_slot_context = (ctx) => ({});
function create_if_block_4$2(ctx) {
  let span;
  let span_class_value;
  let current;
  const prefix_slot_template = ctx[17].prefix;
  const prefix_slot = create_slot(prefix_slot_template, ctx, ctx[16], get_prefix_slot_context);
  return {
    c() {
      span = element("span");
      if (prefix_slot)
        prefix_slot.c();
      attr(span, "class", span_class_value = "prefix " + ctx[0] + " svelte-r4i5a9");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (prefix_slot) {
        prefix_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (prefix_slot) {
        if (prefix_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            prefix_slot,
            prefix_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(prefix_slot_template, ctx2[16], dirty, get_prefix_slot_changes),
            get_prefix_slot_context
          );
        }
      }
      if (!current || dirty & 1 && span_class_value !== (span_class_value = "prefix " + ctx2[0] + " svelte-r4i5a9")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(prefix_slot, local);
      current = true;
    },
    o(local) {
      transition_out(prefix_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (prefix_slot)
        prefix_slot.d(detaching);
    }
  };
}
function create_if_block_3$2(ctx) {
  let span;
  let t_value = ctx[26].name + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "label svelte-r4i5a9");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32 && t_value !== (t_value = ctx2[26].name + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$5(ctx) {
  let span;
  let mounted;
  let dispose;
  function click_handler2() {
    return ctx[18](ctx[26]);
  }
  return {
    c() {
      span = element("span");
      attr(span, "class", "delete icon svelte-r4i5a9");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_ADD;
      if (!mounted) {
        dispose = listen(span, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$6(ctx) {
  let span;
  let t0;
  let t1;
  let span_outro;
  let current;
  let if_block0 = !ctx[7] && create_if_block_3$2(ctx);
  let if_block1 = ctx[6] && create_if_block_2$5(ctx);
  return {
    c() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      attr(span, "class", "tag svelte-r4i5a9");
      set_style(span, "background-color", ctx[26].color);
      toggle_class(span, "collapsed", ctx[7]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append(span, t0);
      if (if_block1)
        if_block1.m(span, null);
      append(span, t1);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!ctx[7])
        if_block0.p(ctx, dirty);
      if (ctx[6])
        if_block1.p(ctx, dirty);
      if (!current || dirty & 32) {
        set_style(span, "background-color", ctx[26].color);
      }
    },
    i(local) {
      if (current)
        return;
      if (span_outro)
        span_outro.end(1);
      current = true;
    },
    o(local) {
      span_outro = create_out_transition(span, ctx[10], {
        duration: ctx[6] ? 300 : 0
      });
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching && span_outro)
        span_outro.end();
    }
  };
}
function create_key_block(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[5];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 736) {
        each_value = ctx2[5];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_1$5(ctx) {
  let span1;
  let span0;
  let mounted;
  let dispose;
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      attr(span0, "class", "icon svelte-r4i5a9");
      attr(span1, "class", "edit svelte-r4i5a9");
    },
    m(target, anchor) {
      insert(target, span1, anchor);
      append(span1, span0);
      span0.innerHTML = SX_ICON_EDIT;
      if (!mounted) {
        dispose = listen(span1, "click", ctx[19]);
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span1);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$8(ctx) {
  let span;
  let span_class_value;
  let current;
  const suffix_slot_template = ctx[17].suffix;
  const suffix_slot = create_slot(suffix_slot_template, ctx, ctx[16], get_suffix_slot_context);
  return {
    c() {
      span = element("span");
      if (suffix_slot)
        suffix_slot.c();
      attr(span, "class", span_class_value = "suffix " + ctx[1] + " svelte-r4i5a9");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (suffix_slot) {
        suffix_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (suffix_slot) {
        if (suffix_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            suffix_slot,
            suffix_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(suffix_slot_template, ctx2[16], dirty, get_suffix_slot_changes),
            get_suffix_slot_context
          );
        }
      }
      if (!current || dirty & 2 && span_class_value !== (span_class_value = "suffix " + ctx2[1] + " svelte-r4i5a9")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(suffix_slot, local);
      current = true;
    },
    o(local) {
      transition_out(suffix_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (suffix_slot)
        suffix_slot.d(detaching);
    }
  };
}
function create_fragment$d(ctx) {
  let span;
  let t0;
  let previous_key = ctx[3];
  let t1;
  let t2;
  let current;
  let if_block0 = ctx[11].prefix && create_if_block_4$2(ctx);
  let key_block = create_key_block(ctx);
  let if_block1 = ctx[6] && create_if_block_1$5(ctx);
  let if_block2 = ctx[11].suffix && create_if_block$8(ctx);
  return {
    c() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      key_block.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      attr(span, "class", "cluster svelte-r4i5a9");
      attr(span, "style", ctx[2]);
      toggle_class(span, "editable", ctx[6]);
      toggle_class(span, "collapsed", ctx[7]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append(span, t0);
      key_block.m(span, null);
      append(span, t1);
      if (if_block1)
        if_block1.m(span, null);
      append(span, t2);
      if (if_block2)
        if_block2.m(span, null);
      ctx[20](span);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[11].prefix) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & 8 && safe_not_equal(previous_key, previous_key = ctx2[3])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(span, t1);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[6])
        if_block1.p(ctx2, dirty);
      if (ctx2[11].suffix) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 2048) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$8(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(span, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & 4) {
        attr(span, "style", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(key_block);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(key_block);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block0)
        if_block0.d();
      key_block.d(detaching);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      ctx[20](null);
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  let a_tags2;
  let $yw_popup;
  let $yw_context_popup;
  let $yw_store_tags;
  component_subscribe($$self, yw_popup, ($$value) => $$invalidate(21, $yw_popup = $$value));
  component_subscribe($$self, yw_context_popup, ($$value) => $$invalidate(22, $yw_context_popup = $$value));
  component_subscribe($$self, yw_store_tags, ($$value) => $$invalidate(15, $yw_store_tags = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { resourcePath } = $$props;
  const p_resource = resourcePath;
  let { editable = false } = $$props;
  const b_editable = editable;
  let { collapsed = false } = $$props;
  const b_collapsed = collapsed;
  let { prefixClass = "" } = $$props;
  let { suffixClass = "" } = $$props;
  let { rootStyle = "" } = $$props;
  let c_reload_tags = 0;
  const f_unsubscribe = yw_store_tags.subscribe(() => $$invalidate(3, c_reload_tags++, c_reload_tags));
  onDestroy(() => {
    f_unsubscribe();
  });
  let ks_tags;
  if (b_editable) {
    yw_context_popup.subscribe((g_ctx) => {
      if (g_ctx?.tags) {
        $$invalidate(5, a_tags2 = g_ctx.tags);
      }
    });
    onDestroy(() => {
      set_store_value(yw_context_popup, $yw_context_popup = null, $yw_context_popup);
    });
  }
  function show_tag_selector() {
    set_store_value(yw_context_popup, $yw_context_popup = { resource: p_resource }, $yw_context_popup);
    set_store_value(yw_popup, $yw_popup = PopupTagsSelect, $yw_popup);
  }
  let dm_cluster;
  async function remove_tag(g_tag) {
    const i_tag = a_tags2.findIndex((g) => g.index === g_tag.index);
    a_tags2.splice(i_tag, 1);
    await ks_tags.save();
  }
  function sslide(dm_node, { delay: xt_delay = 0, duration: xt_duration = 400, easing: f_easing = cubicOut } = {}) {
    const d_style = getComputedStyle(dm_node);
    const x_opacity = +d_style.opacity;
    const x_width = parseFloat(d_style.width);
    const x_padding_left = parseFloat(d_style.paddingLeft);
    const x_padding_right = parseFloat(d_style.paddingRight);
    const x_margin_left = parseFloat(d_style.marginLeft);
    const x_margin_right = parseFloat(d_style.marginRight);
    const x_border_left_width = parseFloat(d_style.borderLeftWidth);
    const x_border_right_width = parseFloat(d_style.borderRightWidth);
    return {
      delay: xt_delay,
      duration: xt_duration,
      easing: f_easing,
      css: (xt) => `--delete-display: none;overflow: hidden;opacity: ${Math.min(xt * 20, 1) * x_opacity};width: ${xt * x_width}px;padding-left: ${xt * x_padding_left}px;padding-right: ${xt * x_padding_right}px;margin-left: ${xt * x_margin_left}px;margin-right: ${xt * x_margin_right}px;border-left-width: ${xt * x_border_left_width}px;border-right-width: ${xt * x_border_right_width}px;`
    };
  }
  const click_handler2 = (g_tag) => remove_tag(g_tag);
  const click_handler_1 = () => show_tag_selector();
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_cluster = $$value;
      $$invalidate(4, dm_cluster);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("resourcePath" in $$props2)
      $$invalidate(12, resourcePath = $$props2.resourcePath);
    if ("editable" in $$props2)
      $$invalidate(13, editable = $$props2.editable);
    if ("collapsed" in $$props2)
      $$invalidate(14, collapsed = $$props2.collapsed);
    if ("prefixClass" in $$props2)
      $$invalidate(0, prefixClass = $$props2.prefixClass);
    if ("suffixClass" in $$props2)
      $$invalidate(1, suffixClass = $$props2.suffixClass);
    if ("rootStyle" in $$props2)
      $$invalidate(2, rootStyle = $$props2.rootStyle);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 32768) {
      $$invalidate(5, a_tags2 = $yw_store_tags.getTagsFor(p_resource));
    }
  };
  return [
    prefixClass,
    suffixClass,
    rootStyle,
    c_reload_tags,
    dm_cluster,
    a_tags2,
    b_editable,
    b_collapsed,
    show_tag_selector,
    remove_tag,
    sslide,
    $$slots,
    resourcePath,
    editable,
    collapsed,
    $yw_store_tags,
    $$scope,
    slots,
    click_handler2,
    click_handler_1,
    span_binding
  ];
}
class InlineTags extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$d, safe_not_equal, {
      resourcePath: 12,
      editable: 13,
      collapsed: 14,
      prefixClass: 0,
      suffixClass: 1,
      rootStyle: 2
    });
  }
}
var Portrait_svelte_svelte_type_style_lang = "";
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i][0];
  child_ctx[23] = list[i][1];
  return child_ctx;
}
const get_subtitle_slot_changes = (dirty) => ({});
const get_subtitle_slot_context = (ctx) => ({});
const get_pfp_slot_changes = (dirty) => ({});
const get_pfp_slot_context = (ctx) => ({});
function create_if_block_3$1(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_4$1, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[11].pfp)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "pfp svelte-1ilena7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_else_block$3(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      ref: ctx[1],
      resource: ctx[0],
      dim: 64,
      circular: ctx[6]
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = {};
      if (dirty & 2)
        pfpdisplay_changes.ref = ctx2[1];
      if (dirty & 1)
        pfpdisplay_changes.resource = ctx2[0];
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_4$1(ctx) {
  let span;
  let current;
  const pfp_slot_template = ctx[19].pfp;
  const pfp_slot = create_slot(pfp_slot_template, ctx, ctx[18], get_pfp_slot_context);
  const pfp_slot_or_fallback = pfp_slot || fallback_block_1();
  return {
    c() {
      span = element("span");
      if (pfp_slot_or_fallback)
        pfp_slot_or_fallback.c();
      attr(span, "class", "icon svelte-1ilena7");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (pfp_slot_or_fallback) {
        pfp_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (pfp_slot) {
        if (pfp_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            pfp_slot,
            pfp_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(pfp_slot_template, ctx2[18], dirty, get_pfp_slot_changes),
            get_pfp_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(pfp_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(pfp_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (pfp_slot_or_fallback)
        pfp_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_1(ctx) {
  let t;
  return {
    c() {
      t = text("Empty pfp slot");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_catch_block$2(ctx) {
  return { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };
}
function create_then_block$2(ctx) {
  let t_value = ctx[26] + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 4 && t_value !== (t_value = ctx2[26] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block$2(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$4(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "info svelte-1ilena7");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_INFO;
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$4(ctx) {
  let div;
  let span;
  let current;
  const subtitle_slot_template = ctx[19].subtitle;
  const subtitle_slot = create_slot(subtitle_slot_template, ctx, ctx[18], get_subtitle_slot_context);
  const subtitle_slot_or_fallback = subtitle_slot || fallback_block$1(ctx);
  return {
    c() {
      div = element("div");
      span = element("span");
      if (subtitle_slot_or_fallback)
        subtitle_slot_or_fallback.c();
      attr(span, "class", "text");
      attr(div, "class", "subtitle svelte-1ilena7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      if (subtitle_slot_or_fallback) {
        subtitle_slot_or_fallback.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (subtitle_slot) {
        if (subtitle_slot.p && (!current || dirty & 262144)) {
          update_slot_base(
            subtitle_slot,
            subtitle_slot_template,
            ctx2,
            ctx2[18],
            !current ? get_all_dirty_from_scope(ctx2[18]) : get_slot_changes(subtitle_slot_template, ctx2[18], dirty, get_subtitle_slot_changes),
            get_subtitle_slot_context
          );
        }
      } else {
        if (subtitle_slot_or_fallback && subtitle_slot_or_fallback.p && (!current || dirty & 8)) {
          subtitle_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(subtitle_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(subtitle_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (subtitle_slot_or_fallback)
        subtitle_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block$1(ctx) {
  let t;
  return {
    c() {
      t = text(ctx[3]);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$7(ctx) {
  let div;
  let each_value = ode(ctx[10]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "actions svelte-1ilena7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1056) {
        each_value = ode(ctx2[10]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$5(ctx) {
  let span2;
  let span0;
  let raw_value = ctx[5][ctx[22]] + "";
  let t0;
  let span1;
  let t1_value = ctx[23].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler2() {
    return ctx[20](ctx[23]);
  }
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon svelte-1ilena7");
      attr(span1, "class", "label");
      attr(span2, "class", "action action-" + ctx[22] + " svelte-1ilena7");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      span0.innerHTML = raw_value;
      append(span2, t0);
      append(span2, span1);
      append(span1, t1);
      append(span2, t2);
      if (!mounted) {
        dispose = listen(span2, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$c(ctx) {
  let div1;
  let t0;
  let div0;
  let span;
  let promise2;
  let t1;
  let t2;
  let t3;
  let inlinetags;
  let t4;
  let current;
  let if_block0 = !ctx[7] && create_if_block_3$1(ctx);
  let info_1 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2,
    value: 26
  };
  handle_promise(promise2 = ctx[2], info_1);
  let if_block1 = ctx[4] && create_if_block_2$4();
  let if_block2 = (ctx[3] || ctx[11].subtitle) && create_if_block_1$4(ctx);
  inlinetags = new InlineTags({
    props: {
      resourcePath: ctx[8],
      rootStyle: "margin: var(--ui-padding) 0 0 0;"
    }
  });
  let if_block3 = ctx[10] && create_if_block$7(ctx);
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      span = element("span");
      info_1.block.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      create_component(inlinetags.$$.fragment);
      t4 = space();
      if (if_block3)
        if_block3.c();
      attr(span, "class", "text");
      attr(div0, "class", "title svelte-1ilena7");
      attr(div1, "class", "portrait " + ctx[9] + " svelte-1ilena7");
      attr(div1, "data-path", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, span);
      info_1.block.m(span, info_1.anchor = null);
      info_1.mount = () => span;
      info_1.anchor = null;
      append(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      append(div1, t3);
      mount_component(inlinetags, div1, null);
      append(div1, t4);
      if (if_block3)
        if_block3.m(div1, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!ctx[7])
        if_block0.p(ctx, dirty);
      info_1.ctx = ctx;
      if (dirty & 4 && promise2 !== (promise2 = ctx[2]) && handle_promise(promise2, info_1))
        ;
      else {
        update_await_block_branch(info_1, ctx, dirty);
      }
      if (ctx[4]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2$4();
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx[3] || ctx[11].subtitle) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty & 2056) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$4(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (ctx[10])
        if_block3.p(ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block0)
        if_block0.d();
      info_1.block.d();
      info_1.token = null;
      info_1 = null;
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(inlinetags);
      if (if_block3)
        if_block3.d();
    }
  };
}
var ActionId;
(function(ActionId2) {
  ActionId2["SEND"] = "send";
  ActionId2["RECV"] = "recv";
  ActionId2["ADD"] = "add";
  ActionId2["EDIT"] = "edit";
  ActionId2["WRAP"] = "wrap";
  ActionId2["UNWRAP"] = "unwrap";
})(ActionId || (ActionId = {}));
function instance$b($$self, $$props, $$invalidate) {
  let $yw_store_tags;
  component_subscribe($$self, yw_store_tags, ($$value) => $$invalidate(17, $yw_store_tags = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  const H_ACTION_ICONS = {
    send: SX_SEND,
    recv: SX_RECV,
    add: SX_ICON_ADD,
    edit: SX_ICON_EDIT$1,
    wrap: SX_ICON_WRAP,
    unwrap: SX_ICON_UNWRAP,
    delete: SX_ICON_DELETE
  };
  let { resource = null } = $$props;
  let { pfp = resource?.pfp || "" } = $$props;
  let { circular = false } = $$props;
  const b_circular = circular;
  let { noPfp = false } = $$props;
  const b_no_pfp = noPfp;
  let { resourcePath } = $$props;
  const p_resource = resourcePath;
  let { rootClasses = "" } = $$props;
  const s_classes = rootClasses;
  let { title = resource?.name || "" } = $$props;
  let { subtitle = "" } = $$props;
  let { actions = null } = $$props;
  const h_actions = actions;
  let { info = false } = $$props;
  const click_handler2 = (gc_action) => gc_action.trigger();
  $$self.$$set = ($$props2) => {
    if ("resource" in $$props2)
      $$invalidate(0, resource = $$props2.resource);
    if ("pfp" in $$props2)
      $$invalidate(1, pfp = $$props2.pfp);
    if ("circular" in $$props2)
      $$invalidate(12, circular = $$props2.circular);
    if ("noPfp" in $$props2)
      $$invalidate(13, noPfp = $$props2.noPfp);
    if ("resourcePath" in $$props2)
      $$invalidate(14, resourcePath = $$props2.resourcePath);
    if ("rootClasses" in $$props2)
      $$invalidate(15, rootClasses = $$props2.rootClasses);
    if ("title" in $$props2)
      $$invalidate(2, title = $$props2.title);
    if ("subtitle" in $$props2)
      $$invalidate(3, subtitle = $$props2.subtitle);
    if ("actions" in $$props2)
      $$invalidate(16, actions = $$props2.actions);
    if ("info" in $$props2)
      $$invalidate(4, info = $$props2.info);
    if ("$$scope" in $$props2)
      $$invalidate(18, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 131072) {
      $yw_store_tags.getTagsFor(p_resource);
    }
  };
  return [
    resource,
    pfp,
    title,
    subtitle,
    info,
    H_ACTION_ICONS,
    b_circular,
    b_no_pfp,
    p_resource,
    s_classes,
    h_actions,
    $$slots,
    circular,
    noPfp,
    resourcePath,
    rootClasses,
    actions,
    $yw_store_tags,
    $$scope,
    slots,
    click_handler2
  ];
}
class Portrait extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$c, safe_not_equal, {
      resource: 0,
      pfp: 1,
      circular: 12,
      noPfp: 13,
      resourcePath: 14,
      rootClasses: 15,
      title: 2,
      subtitle: 3,
      actions: 16,
      info: 4
    });
  }
}
var SX_ICON_DROPDOWN = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-drop-down-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-drop-down-fg" d="M8.70956 11.71L11.2996 14.3C11.6896 14.69 12.3196 14.69 12.7096 14.3L15.2996 11.71C15.9296 11.08 15.4796 10 14.5896 10H9.40956C8.51956 10 8.07956 11.08 8.70956 11.71Z" />\n</svg>\n';
function isOutOfViewport(parent, container) {
  const parentBounding = parent.getBoundingClientRect();
  const boundingContainer = container.getBoundingClientRect();
  const out = {};
  out.top = parentBounding.top < 0;
  out.left = parentBounding.left < 0;
  out.bottom = parentBounding.bottom + boundingContainer.height > (window.innerHeight || document.documentElement.clientHeight);
  out.right = parentBounding.right > (window.innerWidth || document.documentElement.clientWidth);
  out.any = out.top || out.left || out.bottom || out.right;
  return out;
}
var Item_svelte_svelte_type_style_lang = "";
function create_fragment$b(ctx) {
  let div;
  let raw_value = ctx[0](ctx[1], ctx[2]) + "";
  let div_class_value;
  return {
    c() {
      div = element("div");
      attr(div, "class", div_class_value = "item " + ctx[3] + " svelte-3e0qet");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p(ctx2, [dirty]) {
      if (dirty & 7 && raw_value !== (raw_value = ctx2[0](ctx2[1], ctx2[2]) + ""))
        div.innerHTML = raw_value;
      if (dirty & 8 && div_class_value !== (div_class_value = "item " + ctx2[3] + " svelte-3e0qet")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let { isActive = false } = $$props;
  let { isFirst = false } = $$props;
  let { isHover = false } = $$props;
  let { isSelectable = false } = $$props;
  let { getOptionLabel = void 0 } = $$props;
  let { item = void 0 } = $$props;
  let { filterText = "" } = $$props;
  let itemClasses = "";
  $$self.$$set = ($$props2) => {
    if ("isActive" in $$props2)
      $$invalidate(4, isActive = $$props2.isActive);
    if ("isFirst" in $$props2)
      $$invalidate(5, isFirst = $$props2.isFirst);
    if ("isHover" in $$props2)
      $$invalidate(6, isHover = $$props2.isHover);
    if ("isSelectable" in $$props2)
      $$invalidate(7, isSelectable = $$props2.isSelectable);
    if ("getOptionLabel" in $$props2)
      $$invalidate(0, getOptionLabel = $$props2.getOptionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("filterText" in $$props2)
      $$invalidate(2, filterText = $$props2.filterText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 242) {
      {
        const classes = [];
        if (isActive) {
          classes.push("active");
        }
        if (isFirst) {
          classes.push("first");
        }
        if (isHover) {
          classes.push("hover");
        }
        if (item.isGroupHeader) {
          classes.push("groupHeader");
        }
        if (item.isGroupItem) {
          classes.push("groupItem");
        }
        if (!isSelectable) {
          classes.push("notSelectable");
        }
        $$invalidate(3, itemClasses = classes.join(" "));
      }
    }
  };
  return [
    getOptionLabel,
    item,
    filterText,
    itemClasses,
    isActive,
    isFirst,
    isHover,
    isSelectable
  ];
}
class Item extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$b, safe_not_equal, {
      isActive: 4,
      isFirst: 5,
      isHover: 6,
      isSelectable: 7,
      getOptionLabel: 0,
      item: 1,
      filterText: 2
    });
  }
}
var List_svelte_svelte_type_style_lang = "";
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[41] = list[i];
  child_ctx[42] = i;
  return child_ctx;
}
function create_else_block$2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let each_1_else = null;
  if (!each_value.length) {
    each_1_else = create_else_block_2(ctx);
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      if (each_1_else) {
        each_1_else.c();
      }
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      if (each_1_else) {
        each_1_else.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 114390) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
        if (!each_value.length && each_1_else) {
          each_1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each_1_else = create_else_block_2(ctx2);
          each_1_else.c();
          each_1_else.m(each_1_anchor.parentNode, each_1_anchor);
        } else if (each_1_else) {
          each_1_else.d(1);
          each_1_else = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
      if (each_1_else)
        each_1_else.d(detaching);
    }
  };
}
function create_if_block$6(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[3];
  function switch_props(ctx2) {
    return {
      props: {
        items: ctx2[1],
        itemHeight: ctx2[8],
        $$slots: {
          default: [
            create_default_slot$1,
            ({ item, i }) => ({ 41: item, 42: i }),
            ({ item, i }) => [0, (item ? 1024 : 0) | (i ? 2048 : 0)]
          ]
        },
        $$scope: { ctx: ctx2 }
      }
    };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 2)
        switch_instance_changes.items = ctx2[1];
      if (dirty[0] & 256)
        switch_instance_changes.itemHeight = ctx2[8];
      if (dirty[0] & 9814 | dirty[1] & 11264) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[3])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_else_block_2(ctx) {
  let if_block_anchor;
  let if_block = !ctx[11] && create_if_block_2$3(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (!ctx2[11]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$3(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_2$3(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(ctx[12]);
      attr(div, "class", "empty svelte-1uyqfml");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4096)
        set_data(t, ctx2[12]);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_else_block_1(ctx) {
  let div;
  let switch_instance;
  let t;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[4];
  function switch_props(ctx2) {
    return {
      props: {
        item: ctx2[41],
        filterText: ctx2[13],
        getOptionLabel: ctx2[6],
        isFirst: isItemFirst(ctx2[42]),
        isActive: isItemActive(ctx2[41], ctx2[9], ctx2[10]),
        isHover: isItemHover(ctx2[2], ctx2[41], ctx2[42], ctx2[1]),
        isSelectable: isItemSelectable(ctx2[41])
      }
    };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
  }
  function mouseover_handler_1() {
    return ctx[29](ctx[42]);
  }
  function focus_handler_1() {
    return ctx[30](ctx[42]);
  }
  function click_handler_1(...args) {
    return ctx[31](ctx[41], ctx[42], ...args);
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      attr(div, "class", "listItem");
      attr(div, "tabindex", "-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance) {
        mount_component(switch_instance, div, null);
      }
      append(div, t);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "mouseover", mouseover_handler_1),
          listen(div, "focus", focus_handler_1),
          listen(div, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[0] & 2)
        switch_instance_changes.item = ctx[41];
      if (dirty[0] & 8192)
        switch_instance_changes.filterText = ctx[13];
      if (dirty[0] & 64)
        switch_instance_changes.getOptionLabel = ctx[6];
      if (dirty[0] & 1538)
        switch_instance_changes.isActive = isItemActive(ctx[41], ctx[9], ctx[10]);
      if (dirty[0] & 6)
        switch_instance_changes.isHover = isItemHover(ctx[2], ctx[41], ctx[42], ctx[1]);
      if (dirty[0] & 2)
        switch_instance_changes.isSelectable = isItemSelectable(ctx[41]);
      if (switch_value !== (switch_value = ctx[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$3(ctx) {
  let div;
  let t_value = ctx[7](ctx[41]) + "";
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "listGroupTitle svelte-1uyqfml");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 130 && t_value !== (t_value = ctx2[7](ctx2[41]) + ""))
        set_data(t, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block$4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$3, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[41].isGroupHeader && !ctx2[41].isSelectable)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot$1(ctx) {
  let div;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[4];
  function switch_props(ctx2) {
    return {
      props: {
        item: ctx2[41],
        filterText: ctx2[13],
        getOptionLabel: ctx2[6],
        isFirst: isItemFirst(ctx2[42]),
        isActive: isItemActive(ctx2[41], ctx2[9], ctx2[10]),
        isHover: isItemHover(ctx2[2], ctx2[41], ctx2[42], ctx2[1]),
        isSelectable: isItemSelectable(ctx2[41])
      }
    };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
  }
  function mouseover_handler() {
    return ctx[26](ctx[42]);
  }
  function focus_handler() {
    return ctx[27](ctx[42]);
  }
  function click_handler2(...args) {
    return ctx[28](ctx[41], ctx[42], ...args);
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "listItem");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance) {
        mount_component(switch_instance, div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "mouseover", mouseover_handler),
          listen(div, "focus", focus_handler),
          listen(div, "click", click_handler2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const switch_instance_changes = {};
      if (dirty[1] & 1024)
        switch_instance_changes.item = ctx[41];
      if (dirty[0] & 8192)
        switch_instance_changes.filterText = ctx[13];
      if (dirty[0] & 64)
        switch_instance_changes.getOptionLabel = ctx[6];
      if (dirty[1] & 2048)
        switch_instance_changes.isFirst = isItemFirst(ctx[42]);
      if (dirty[0] & 1536 | dirty[1] & 1024)
        switch_instance_changes.isActive = isItemActive(ctx[41], ctx[9], ctx[10]);
      if (dirty[0] & 6 | dirty[1] & 3072)
        switch_instance_changes.isHover = isItemHover(ctx[2], ctx[41], ctx[42], ctx[1]);
      if (dirty[1] & 1024)
        switch_instance_changes.isSelectable = isItemSelectable(ctx[41]);
      if (switch_value !== (switch_value = ctx[4])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$a(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$6, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[5])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "listContainer svelte-1uyqfml");
      attr(div, "style", ctx[14]);
      toggle_class(div, "virtualList", ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[32](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window, "keydown", ctx[17]),
          listen(window, "resize", ctx[18])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[0] & 16384) {
        attr(div, "style", ctx2[14]);
      }
      if (dirty[0] & 32) {
        toggle_class(div, "virtualList", ctx2[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function isItemActive(item, value, optionIdentifier) {
  return value && value[optionIdentifier] === item[optionIdentifier];
}
function isItemFirst(itemIndex) {
  return itemIndex === 0;
}
function isItemHover(hoverItemIndex, item, itemIndex, items) {
  return isItemSelectable(item) && (hoverItemIndex === itemIndex || items.length === 1);
}
function isItemSelectable(item) {
  return item.isGroupHeader && item.isSelectable || item.selectable || !item.hasOwnProperty("selectable");
}
function instance$9($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { container = void 0 } = $$props;
  let { VirtualList: VirtualList2 = null } = $$props;
  let { Item: Item$1 = Item } = $$props;
  let { isVirtualList = false } = $$props;
  let { items = [] } = $$props;
  let { labelIdentifier = "label" } = $$props;
  let { getOptionLabel = (option, filterText2) => {
    if (option)
      return option.isCreator ? `Create "${filterText2}"` : option[labelIdentifier];
  } } = $$props;
  let { getGroupHeaderLabel = null } = $$props;
  let { itemHeight = 40 } = $$props;
  let { hoverItemIndex = 0 } = $$props;
  let { value = void 0 } = $$props;
  let { optionIdentifier = "value" } = $$props;
  let { hideEmptyState = false } = $$props;
  let { noOptionsMessage = "No options" } = $$props;
  let { isMulti = false } = $$props;
  let { activeItemIndex = 0 } = $$props;
  let { filterText = "" } = $$props;
  let { parent = null } = $$props;
  let { listPlacement = null } = $$props;
  let { listAutoWidth = null } = $$props;
  let { listOffset = 5 } = $$props;
  let isScrollingTimer = 0;
  let isScrolling = false;
  let prev_items;
  onMount(() => {
    if (items.length > 0 && !isMulti && value) {
      const _hoverItemIndex = items.findIndex((item) => item[optionIdentifier] === value[optionIdentifier]);
      if (_hoverItemIndex) {
        $$invalidate(2, hoverItemIndex = _hoverItemIndex);
      }
    }
    scrollToActiveItem("active");
    container.addEventListener(
      "scroll",
      () => {
        clearTimeout(isScrollingTimer);
        isScrollingTimer = setTimeout(
          () => {
            isScrolling = false;
          },
          100
        );
      },
      false
    );
  });
  beforeUpdate(() => {
    if (!items)
      $$invalidate(1, items = []);
    if (items !== prev_items && items.length > 0) {
      $$invalidate(2, hoverItemIndex = 0);
    }
    prev_items = items;
  });
  function handleSelect(item) {
    if (item.isCreator)
      return;
    dispatch2("itemSelected", item);
  }
  function handleHover(i) {
    if (isScrolling)
      return;
    $$invalidate(2, hoverItemIndex = i);
  }
  function handleClick(args) {
    const { item, i, event } = args;
    event.stopPropagation();
    if (value && !isMulti && value[optionIdentifier] === item[optionIdentifier])
      return closeList();
    if (item.isCreator) {
      dispatch2("itemCreated", filterText);
    } else if (isItemSelectable(item)) {
      $$invalidate(19, activeItemIndex = i);
      $$invalidate(2, hoverItemIndex = i);
      handleSelect(item);
    }
  }
  function closeList() {
    dispatch2("closeList");
  }
  async function updateHoverItem(increment) {
    if (isVirtualList)
      return;
    let isNonSelectableItem = true;
    while (isNonSelectableItem) {
      if (increment > 0 && hoverItemIndex === items.length - 1) {
        $$invalidate(2, hoverItemIndex = 0);
      } else if (increment < 0 && hoverItemIndex === 0) {
        $$invalidate(2, hoverItemIndex = items.length - 1);
      } else {
        $$invalidate(2, hoverItemIndex = hoverItemIndex + increment);
      }
      isNonSelectableItem = !isItemSelectable(items[hoverItemIndex]);
    }
    await tick();
    scrollToActiveItem("hover");
  }
  function handleKeyDown(e) {
    switch (e.key) {
      case "Escape":
        e.preventDefault();
        closeList();
        break;
      case "ArrowDown":
        e.preventDefault();
        items.length && updateHoverItem(1);
        break;
      case "ArrowUp":
        e.preventDefault();
        items.length && updateHoverItem(-1);
        break;
      case "Enter":
        e.preventDefault();
        if (items.length === 0)
          break;
        const hoverItem = items[hoverItemIndex];
        if (value && !isMulti && value[optionIdentifier] === hoverItem[optionIdentifier]) {
          closeList();
          break;
        }
        if (hoverItem.isCreator) {
          dispatch2("itemCreated", filterText);
        } else {
          $$invalidate(19, activeItemIndex = hoverItemIndex);
          handleSelect(items[hoverItemIndex]);
        }
        break;
      case "Tab":
        e.preventDefault();
        if (items.length === 0) {
          return closeList();
        }
        if (value && value[optionIdentifier] === items[hoverItemIndex][optionIdentifier])
          return closeList();
        $$invalidate(19, activeItemIndex = hoverItemIndex);
        handleSelect(items[hoverItemIndex]);
        break;
    }
  }
  function scrollToActiveItem(className) {
    if (isVirtualList || !container)
      return;
    let offsetBounding;
    const focusedElemBounding = container.querySelector(`.listItem .${className}`);
    if (focusedElemBounding) {
      offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
    }
    $$invalidate(0, container.scrollTop -= offsetBounding, container);
  }
  let listStyle;
  function computePlacement() {
    const { height, width } = parent.getBoundingClientRect();
    $$invalidate(14, listStyle = "");
    $$invalidate(14, listStyle += `min-width:${width}px;width:${listAutoWidth ? "auto" : "100%"};`);
    if (listPlacement === "top" || listPlacement === "auto" && isOutOfViewport(parent, container).bottom) {
      $$invalidate(14, listStyle += `bottom:${height + listOffset}px;`);
    } else {
      $$invalidate(14, listStyle += `top:${height + listOffset}px;`);
    }
  }
  const mouseover_handler = (i) => handleHover(i);
  const focus_handler = (i) => handleHover(i);
  const click_handler2 = (item, i, event) => handleClick({ item, i, event });
  const mouseover_handler_1 = (i) => handleHover(i);
  const focus_handler_1 = (i) => handleHover(i);
  const click_handler_1 = (item, i, event) => handleClick({ item, i, event });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("VirtualList" in $$props2)
      $$invalidate(3, VirtualList2 = $$props2.VirtualList);
    if ("Item" in $$props2)
      $$invalidate(4, Item$1 = $$props2.Item);
    if ("isVirtualList" in $$props2)
      $$invalidate(5, isVirtualList = $$props2.isVirtualList);
    if ("items" in $$props2)
      $$invalidate(1, items = $$props2.items);
    if ("labelIdentifier" in $$props2)
      $$invalidate(20, labelIdentifier = $$props2.labelIdentifier);
    if ("getOptionLabel" in $$props2)
      $$invalidate(6, getOptionLabel = $$props2.getOptionLabel);
    if ("getGroupHeaderLabel" in $$props2)
      $$invalidate(7, getGroupHeaderLabel = $$props2.getGroupHeaderLabel);
    if ("itemHeight" in $$props2)
      $$invalidate(8, itemHeight = $$props2.itemHeight);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(2, hoverItemIndex = $$props2.hoverItemIndex);
    if ("value" in $$props2)
      $$invalidate(9, value = $$props2.value);
    if ("optionIdentifier" in $$props2)
      $$invalidate(10, optionIdentifier = $$props2.optionIdentifier);
    if ("hideEmptyState" in $$props2)
      $$invalidate(11, hideEmptyState = $$props2.hideEmptyState);
    if ("noOptionsMessage" in $$props2)
      $$invalidate(12, noOptionsMessage = $$props2.noOptionsMessage);
    if ("isMulti" in $$props2)
      $$invalidate(21, isMulti = $$props2.isMulti);
    if ("activeItemIndex" in $$props2)
      $$invalidate(19, activeItemIndex = $$props2.activeItemIndex);
    if ("filterText" in $$props2)
      $$invalidate(13, filterText = $$props2.filterText);
    if ("parent" in $$props2)
      $$invalidate(22, parent = $$props2.parent);
    if ("listPlacement" in $$props2)
      $$invalidate(23, listPlacement = $$props2.listPlacement);
    if ("listAutoWidth" in $$props2)
      $$invalidate(24, listAutoWidth = $$props2.listAutoWidth);
    if ("listOffset" in $$props2)
      $$invalidate(25, listOffset = $$props2.listOffset);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4194305) {
      {
        if (parent && container)
          computePlacement();
      }
    }
  };
  return [
    container,
    items,
    hoverItemIndex,
    VirtualList2,
    Item$1,
    isVirtualList,
    getOptionLabel,
    getGroupHeaderLabel,
    itemHeight,
    value,
    optionIdentifier,
    hideEmptyState,
    noOptionsMessage,
    filterText,
    listStyle,
    handleHover,
    handleClick,
    handleKeyDown,
    computePlacement,
    activeItemIndex,
    labelIdentifier,
    isMulti,
    parent,
    listPlacement,
    listAutoWidth,
    listOffset,
    mouseover_handler,
    focus_handler,
    click_handler2,
    mouseover_handler_1,
    focus_handler_1,
    click_handler_1,
    div_binding
  ];
}
class List extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$9,
      create_fragment$a,
      safe_not_equal,
      {
        container: 0,
        VirtualList: 3,
        Item: 4,
        isVirtualList: 5,
        items: 1,
        labelIdentifier: 20,
        getOptionLabel: 6,
        getGroupHeaderLabel: 7,
        itemHeight: 8,
        hoverItemIndex: 2,
        value: 9,
        optionIdentifier: 10,
        hideEmptyState: 11,
        noOptionsMessage: 12,
        isMulti: 21,
        activeItemIndex: 19,
        filterText: 13,
        parent: 22,
        listPlacement: 23,
        listAutoWidth: 24,
        listOffset: 25
      },
      null,
      [-1, -1]
    );
  }
}
var Selection_svelte_svelte_type_style_lang = "";
function create_fragment$9(ctx) {
  let div;
  let raw_value = ctx[0](ctx[1]) + "";
  return {
    c() {
      div = element("div");
      attr(div, "class", "selection svelte-pu1q1n");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3 && raw_value !== (raw_value = ctx2[0](ctx2[1]) + ""))
        div.innerHTML = raw_value;
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let { getSelectionLabel = void 0 } = $$props;
  let { item = void 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("getSelectionLabel" in $$props2)
      $$invalidate(0, getSelectionLabel = $$props2.getSelectionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  return [getSelectionLabel, item];
}
class Selection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$9, safe_not_equal, { getSelectionLabel: 0, item: 1 });
  }
}
var MultiSelection_svelte_svelte_type_style_lang = "";
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  child_ctx[11] = i;
  return child_ctx;
}
function create_if_block$5(ctx) {
  let div;
  let mounted;
  let dispose;
  function click_handler2(...args) {
    return ctx[6](ctx[11], ...args);
  }
  return {
    c() {
      div = element("div");
      div.innerHTML = `<svg width="100%" height="100%" viewBox="-2 -2 50 50" focusable="false" aria-hidden="true" role="presentation" class="svelte-liu9pa"><path d="M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z"></path></svg>`;
      attr(div, "class", "multiSelectItem_clear svelte-liu9pa");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(div, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$3(ctx) {
  let div1;
  let div0;
  let raw_value = ctx[4](ctx[9]) + "";
  let t0;
  let t1;
  let div1_class_value;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && !ctx[3] && create_if_block$5(ctx);
  function click_handler_1(...args) {
    return ctx[7](ctx[11], ...args);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      attr(div0, "class", "multiSelectItem_label svelte-liu9pa");
      attr(div1, "class", div1_class_value = "multiSelectItem " + (ctx[1] === ctx[11] ? "active" : "") + " " + (ctx[2] ? "disabled" : "") + " svelte-liu9pa");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      div0.innerHTML = raw_value;
      append(div1, t0);
      if (if_block)
        if_block.m(div1, null);
      append(div1, t1);
      if (!mounted) {
        dispose = listen(div1, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 17 && raw_value !== (raw_value = ctx[4](ctx[9]) + ""))
        div0.innerHTML = raw_value;
      if (!ctx[2] && !ctx[3]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$5(ctx);
          if_block.c();
          if_block.m(div1, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (ctx[1] === ctx[11] ? "active" : "") + " " + (ctx[2] ? "disabled" : "") + " svelte-liu9pa")) {
        attr(div1, "class", div1_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$8(ctx) {
  let each_1_anchor;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & 63) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  const dispatch2 = createEventDispatcher();
  let { value = [] } = $$props;
  let { activeValue = void 0 } = $$props;
  let { isDisabled = false } = $$props;
  let { multiFullItemClearable = false } = $$props;
  let { getSelectionLabel = void 0 } = $$props;
  function handleClear(i, event) {
    event.stopPropagation();
    dispatch2("multiItemClear", { i });
  }
  const click_handler2 = (i, event) => handleClear(i, event);
  const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("activeValue" in $$props2)
      $$invalidate(1, activeValue = $$props2.activeValue);
    if ("isDisabled" in $$props2)
      $$invalidate(2, isDisabled = $$props2.isDisabled);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(3, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("getSelectionLabel" in $$props2)
      $$invalidate(4, getSelectionLabel = $$props2.getSelectionLabel);
  };
  return [
    value,
    activeValue,
    isDisabled,
    multiFullItemClearable,
    getSelectionLabel,
    handleClear,
    click_handler2,
    click_handler_1
  ];
}
class MultiSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$8, safe_not_equal, {
      value: 0,
      activeValue: 1,
      isDisabled: 2,
      multiFullItemClearable: 3,
      getSelectionLabel: 4
    });
  }
}
var VirtualList_svelte_svelte_type_style_lang = "";
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
const get_default_slot_changes = (dirty) => ({
  item: dirty & 32,
  i: dirty & 32,
  hoverItemIndex: dirty & 2
});
const get_default_slot_context = (ctx) => ({
  item: ctx[23].data,
  i: ctx[23].index,
  hoverItemIndex: ctx[1]
});
function fallback_block(ctx) {
  let t;
  return {
    c() {
      t = text("Missing template");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$2(key_1, ctx) {
  let svelte_virtual_list_row;
  let t;
  let current;
  const default_slot_template = ctx[15].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], get_default_slot_context);
  const default_slot_or_fallback = default_slot || fallback_block();
  return {
    key: key_1,
    first: null,
    c() {
      svelte_virtual_list_row = element("svelte-virtual-list-row");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      set_custom_element_data(svelte_virtual_list_row, "class", "svelte-g2cagw");
      this.first = svelte_virtual_list_row;
    },
    m(target, anchor) {
      insert(target, svelte_virtual_list_row, anchor);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(svelte_virtual_list_row, null);
      }
      append(svelte_virtual_list_row, t);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16418)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[14],
            !current ? get_all_dirty_from_scope(ctx[14]) : get_slot_changes(default_slot_template, ctx[14], dirty, get_default_slot_changes),
            get_default_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svelte_virtual_list_row);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function create_fragment$7(ctx) {
  let svelte_virtual_list_viewport;
  let svelte_virtual_list_contents;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let svelte_virtual_list_viewport_resize_listener;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[5];
  const get_key = (ctx2) => ctx2[23].index;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context$2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
  }
  return {
    c() {
      svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
      svelte_virtual_list_contents = element("svelte-virtual-list-contents");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(svelte_virtual_list_contents, "padding-top", ctx[6] + "px");
      set_style(svelte_virtual_list_contents, "padding-bottom", ctx[7] + "px");
      set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-g2cagw");
      set_style(svelte_virtual_list_viewport, "height", ctx[0]);
      set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-g2cagw");
      add_render_callback(() => ctx[18].call(svelte_virtual_list_viewport));
    },
    m(target, anchor) {
      insert(target, svelte_virtual_list_viewport, anchor);
      append(svelte_virtual_list_viewport, svelte_virtual_list_contents);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(svelte_virtual_list_contents, null);
      }
      ctx[16](svelte_virtual_list_contents);
      ctx[17](svelte_virtual_list_viewport);
      svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, ctx[18].bind(svelte_virtual_list_viewport));
      current = true;
      if (!mounted) {
        dispose = listen(svelte_virtual_list_viewport, "scroll", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 16418) {
        each_value = ctx2[5];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
        check_outros();
      }
      if (!current || dirty & 64) {
        set_style(svelte_virtual_list_contents, "padding-top", ctx2[6] + "px");
      }
      if (!current || dirty & 128) {
        set_style(svelte_virtual_list_contents, "padding-bottom", ctx2[7] + "px");
      }
      if (!current || dirty & 1) {
        set_style(svelte_virtual_list_viewport, "height", ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svelte_virtual_list_viewport);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[16](null);
      ctx[17](null);
      svelte_virtual_list_viewport_resize_listener();
      mounted = false;
      dispose();
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { items = void 0 } = $$props;
  let { height = "100%" } = $$props;
  let { itemHeight = 40 } = $$props;
  let { hoverItemIndex = 0 } = $$props;
  let { start = 0 } = $$props;
  let { end: end2 = 0 } = $$props;
  let height_map = [];
  let rows;
  let viewport;
  let contents;
  let viewport_height = 0;
  let visible;
  let mounted;
  let top = 0;
  let bottom = 0;
  let average_height;
  async function refresh(items2, viewport_height2, itemHeight2) {
    const { scrollTop } = viewport;
    await tick();
    let content_height = top - scrollTop;
    let i = start;
    while (content_height < viewport_height2 && i < items2.length) {
      let row = rows[i - start];
      if (!row) {
        $$invalidate(10, end2 = i + 1);
        await tick();
        row = rows[i - start];
      }
      const row_height = height_map[i] = itemHeight2 || row.offsetHeight;
      content_height += row_height;
      i += 1;
    }
    $$invalidate(10, end2 = i);
    const remaining = items2.length - end2;
    average_height = (top + content_height) / end2;
    $$invalidate(7, bottom = remaining * average_height);
    height_map.length = items2.length;
    if (viewport)
      $$invalidate(3, viewport.scrollTop = 0, viewport);
  }
  async function handle_scroll() {
    const { scrollTop } = viewport;
    const old_start = start;
    for (let v = 0; v < rows.length; v += 1) {
      height_map[start + v] = itemHeight || rows[v].offsetHeight;
    }
    let i = 0;
    let y = 0;
    while (i < items.length) {
      const row_height = height_map[i] || average_height;
      if (y + row_height > scrollTop) {
        $$invalidate(9, start = i);
        $$invalidate(6, top = y);
        break;
      }
      y += row_height;
      i += 1;
    }
    while (i < items.length) {
      y += height_map[i] || average_height;
      i += 1;
      if (y > scrollTop + viewport_height)
        break;
    }
    $$invalidate(10, end2 = i);
    const remaining = items.length - end2;
    average_height = y / end2;
    while (i < items.length)
      height_map[i++] = average_height;
    $$invalidate(7, bottom = remaining * average_height);
    if (start < old_start) {
      await tick();
      let expected_height = 0;
      let actual_height = 0;
      for (let i2 = start; i2 < old_start; i2 += 1) {
        if (rows[i2 - start]) {
          expected_height += height_map[i2];
          actual_height += itemHeight || rows[i2 - start].offsetHeight;
        }
      }
      const d = actual_height - expected_height;
      viewport.scrollTo(0, scrollTop + d);
    }
  }
  onMount(() => {
    rows = contents.getElementsByTagName("svelte-virtual-list-row");
    $$invalidate(13, mounted = true);
  });
  function svelte_virtual_list_contents_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contents = $$value;
      $$invalidate(4, contents);
    });
  }
  function svelte_virtual_list_viewport_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      viewport = $$value;
      $$invalidate(3, viewport);
    });
  }
  function svelte_virtual_list_viewport_elementresize_handler() {
    viewport_height = this.offsetHeight;
    $$invalidate(2, viewport_height);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(11, items = $$props2.items);
    if ("height" in $$props2)
      $$invalidate(0, height = $$props2.height);
    if ("itemHeight" in $$props2)
      $$invalidate(12, itemHeight = $$props2.itemHeight);
    if ("hoverItemIndex" in $$props2)
      $$invalidate(1, hoverItemIndex = $$props2.hoverItemIndex);
    if ("start" in $$props2)
      $$invalidate(9, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(10, end2 = $$props2.end);
    if ("$$scope" in $$props2)
      $$invalidate(14, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3584) {
      $$invalidate(5, visible = items.slice(start, end2).map((data, i) => {
        return { index: i + start, data };
      }));
    }
    if ($$self.$$.dirty & 14340) {
      if (mounted)
        refresh(items, viewport_height, itemHeight);
    }
  };
  return [
    height,
    hoverItemIndex,
    viewport_height,
    viewport,
    contents,
    visible,
    top,
    bottom,
    handle_scroll,
    start,
    end2,
    items,
    itemHeight,
    mounted,
    $$scope,
    slots,
    svelte_virtual_list_contents_binding,
    svelte_virtual_list_viewport_binding,
    svelte_virtual_list_viewport_elementresize_handler
  ];
}
class VirtualList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$7, safe_not_equal, {
      items: 11,
      height: 0,
      itemHeight: 12,
      hoverItemIndex: 1,
      start: 9,
      end: 10
    });
  }
}
function create_fragment$6(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "currentColor");
      attr(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
      attr(svg, "width", "100%");
      attr(svg, "height", "100%");
      attr(svg, "viewBox", "-2 -2 50 50");
      attr(svg, "focusable", "false");
      attr(svg, "aria-hidden", "true");
      attr(svg, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
class ClearIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$6, safe_not_equal, {});
  }
}
function debounce(func, wait2, immediate) {
  let timeout2;
  return function executedFunction() {
    let context = this;
    let args = arguments;
    let later = function() {
      timeout2 = null;
      if (!immediate)
        func.apply(context, args);
    };
    let callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait2);
    if (callNow)
      func.apply(context, args);
  };
}
var Select_svelte_svelte_type_style_lang = "";
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[103] = list[i];
  return child_ctx;
}
function create_if_block_10(ctx) {
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  return {
    c() {
      span0 = element("span");
      t0 = text(ctx[33]);
      t1 = space();
      span1 = element("span");
      t2 = text(ctx[32]);
      attr(span0, "id", "aria-selection");
      attr(span1, "id", "aria-context");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      append(span0, t0);
      insert(target, t1, anchor);
      insert(target, span1, anchor);
      append(span1, t2);
    },
    p(ctx2, dirty) {
      if (dirty[1] & 4)
        set_data(t0, ctx2[33]);
      if (dirty[1] & 2)
        set_data(t2, ctx2[32]);
    },
    d(detaching) {
      if (detaching)
        detach(span0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span1);
    }
  };
}
function create_if_block_9(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[18]];
  var switch_value = ctx[17];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[0] & 262144 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[18])]) : {};
      if (switch_value !== (switch_value = ctx2[17])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_8(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = ctx[26];
  function switch_props(ctx2) {
    return {
      props: {
        value: ctx2[2],
        getSelectionLabel: ctx2[12],
        activeValue: ctx2[30],
        isDisabled: ctx2[9],
        multiFullItemClearable: ctx2[8]
      }
    };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    switch_instance.$on("multiItemClear", ctx[38]);
    switch_instance.$on("focus", ctx[40]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 4)
        switch_instance_changes.value = ctx2[2];
      if (dirty[0] & 4096)
        switch_instance_changes.getSelectionLabel = ctx2[12];
      if (dirty[0] & 1073741824)
        switch_instance_changes.activeValue = ctx2[30];
      if (dirty[0] & 512)
        switch_instance_changes.isDisabled = ctx2[9];
      if (dirty[0] & 256)
        switch_instance_changes.multiFullItemClearable = ctx2[8];
      if (switch_value !== (switch_value = ctx2[26])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          switch_instance.$on("multiItemClear", ctx2[38]);
          switch_instance.$on("focus", ctx2[40]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let div;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[25];
  function switch_props(ctx2) {
    return {
      props: {
        item: ctx2[2],
        getSelectionLabel: ctx2[12]
      }
    };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "selectedItem svelte-17l1npl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance) {
        mount_component(switch_instance, div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "focus", ctx[40]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & 4)
        switch_instance_changes.item = ctx2[2];
      if (dirty[0] & 4096)
        switch_instance_changes.getSelectionLabel = ctx2[12];
      if (switch_value !== (switch_value = ctx2[25])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_6(ctx) {
  let div;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[23];
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
  }
  return {
    c() {
      div = element("div");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(div, "class", "clearSelect svelte-17l1npl");
      attr(div, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (switch_instance) {
        mount_component(switch_instance, div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", prevent_default(ctx[27]));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (switch_value !== (switch_value = ctx2[23])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (ctx2[22])
      return create_if_block_5;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "indicator svelte-17l1npl");
      attr(div, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_block.m(div, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
    }
  };
}
function create_else_block$1(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
      attr(svg, "width", "100%");
      attr(svg, "height", "100%");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "focusable", "false");
      attr(svg, "aria-hidden", "true");
      attr(svg, "class", "svelte-17l1npl");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block_5(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(ctx[22], target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 4194304)
        html_tag.p(ctx2[22]);
    },
    d(detaching) {
      if (detaching)
        detach(html_anchor);
      if (detaching)
        html_tag.d();
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<svg class="spinner_icon svelte-17l1npl" viewBox="25 25 50 50"><circle class="spinner_path svelte-17l1npl" cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="5" stroke-miterlimit="10"></circle></svg>`;
      attr(div, "class", "spinner svelte-17l1npl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_2$2(ctx) {
  let switch_instance;
  let updating_hoverItemIndex;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [ctx[34]];
  function switch_instance_hoverItemIndex_binding(value) {
    ctx[84](value);
  }
  var switch_value = ctx[24];
  function switch_props(ctx2) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    if (ctx2[28] !== void 0) {
      switch_instance_props.hoverItemIndex = ctx2[28];
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
    binding_callbacks.push(() => bind(switch_instance, "hoverItemIndex", switch_instance_hoverItemIndex_binding));
    switch_instance.$on("itemSelected", ctx[43]);
    switch_instance.$on("itemCreated", ctx[44]);
    switch_instance.$on("closeList", ctx[45]);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance) {
        mount_component(switch_instance, target, anchor);
      }
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = dirty[1] & 8 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(ctx2[34])]) : {};
      if (!updating_hoverItemIndex && dirty[0] & 268435456) {
        updating_hoverItemIndex = true;
        switch_instance_changes.hoverItemIndex = ctx2[28];
        add_flush_callback(() => updating_hoverItemIndex = false);
      }
      if (switch_value !== (switch_value = ctx2[24])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx2));
          binding_callbacks.push(() => bind(switch_instance, "hoverItemIndex", switch_instance_hoverItemIndex_binding));
          switch_instance.$on("itemSelected", ctx2[43]);
          switch_instance.$on("itemCreated", ctx2[44]);
          switch_instance.$on("closeList", ctx2[45]);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_1$2(ctx) {
  let input_1;
  let input_1_name_value;
  let input_1_value_value;
  return {
    c() {
      input_1 = element("input");
      attr(input_1, "name", input_1_name_value = ctx[16].name);
      attr(input_1, "type", "hidden");
      input_1.value = input_1_value_value = ctx[2] ? ctx[12](ctx[2]) : null;
      attr(input_1, "class", "svelte-17l1npl");
    },
    m(target, anchor) {
      insert(target, input_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 65536 && input_1_name_value !== (input_1_name_value = ctx2[16].name)) {
        attr(input_1, "name", input_1_name_value);
      }
      if (dirty[0] & 4100 && input_1_value_value !== (input_1_value_value = ctx2[2] ? ctx2[12](ctx2[2]) : null)) {
        input_1.value = input_1_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input_1);
    }
  };
}
function create_if_block$4(ctx) {
  let each_1_anchor;
  let each_value = ctx[2];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 69636) {
        each_value = ctx2[2];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$1(ctx) {
  let input_1;
  let input_1_name_value;
  let input_1_value_value;
  return {
    c() {
      input_1 = element("input");
      attr(input_1, "name", input_1_name_value = ctx[16].name);
      attr(input_1, "type", "hidden");
      input_1.value = input_1_value_value = ctx[103] ? ctx[12](ctx[103]) : null;
      attr(input_1, "class", "svelte-17l1npl");
    },
    m(target, anchor) {
      insert(target, input_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 65536 && input_1_name_value !== (input_1_name_value = ctx2[16].name)) {
        attr(input_1, "name", input_1_name_value);
      }
      if (dirty[0] & 4100 && input_1_value_value !== (input_1_value_value = ctx2[103] ? ctx2[12](ctx2[103]) : null)) {
        input_1.value = input_1_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input_1);
    }
  };
}
function create_fragment$5(ctx) {
  let div;
  let span;
  let t0;
  let t1;
  let t2;
  let input_1;
  let input_1_readonly_value;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = ctx[1] && create_if_block_10(ctx);
  let if_block1 = ctx[17] && create_if_block_9(ctx);
  let if_block2 = ctx[35] && create_if_block_8(ctx);
  let input_1_levels = [
    {
      readOnly: input_1_readonly_value = !ctx[13]
    },
    ctx[31],
    { placeholder: ctx[36] },
    { style: ctx[14] },
    { disabled: ctx[9] }
  ];
  let input_1_data = {};
  for (let i = 0; i < input_1_levels.length; i += 1) {
    input_1_data = assign(input_1_data, input_1_levels[i]);
  }
  let if_block3 = !ctx[7] && ctx[29] && create_if_block_7(ctx);
  let if_block4 = ctx[37] && create_if_block_6(ctx);
  let if_block5 = !ctx[37] && (ctx[20] || ctx[19] && !ctx[2] || !ctx[13] && !ctx[9] && !ctx[4] && (ctx[29] && !ctx[15] || !ctx[29])) && create_if_block_4(ctx);
  let if_block6 = ctx[4] && create_if_block_3();
  let if_block7 = ctx[5] && create_if_block_2$2(ctx);
  let if_block8 = (!ctx[7] || ctx[7] && !ctx[35]) && create_if_block_1$2(ctx);
  let if_block9 = ctx[7] && ctx[35] && create_if_block$4(ctx);
  return {
    c() {
      div = element("div");
      span = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      input_1 = element("input");
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      if (if_block7)
        if_block7.c();
      t8 = space();
      if (if_block8)
        if_block8.c();
      t9 = space();
      if (if_block9)
        if_block9.c();
      attr(span, "aria-live", "polite");
      attr(span, "aria-atomic", "false");
      attr(span, "aria-relevant", "additions text");
      attr(span, "class", "a11yText svelte-17l1npl");
      set_attributes(input_1, input_1_data);
      toggle_class(input_1, "svelte-17l1npl", true);
      attr(div, "class", div_class_value = "selectContainer " + ctx[21] + " svelte-17l1npl");
      attr(div, "style", ctx[11]);
      toggle_class(div, "hasError", ctx[10]);
      toggle_class(div, "multiSelect", ctx[7]);
      toggle_class(div, "disabled", ctx[9]);
      toggle_class(div, "focused", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      if (if_block0)
        if_block0.m(span, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t2);
      append(div, input_1);
      if (input_1.autofocus)
        input_1.focus();
      ctx[82](input_1);
      set_input_value(input_1, ctx[3]);
      append(div, t3);
      if (if_block3)
        if_block3.m(div, null);
      append(div, t4);
      if (if_block4)
        if_block4.m(div, null);
      append(div, t5);
      if (if_block5)
        if_block5.m(div, null);
      append(div, t6);
      if (if_block6)
        if_block6.m(div, null);
      append(div, t7);
      if (if_block7)
        if_block7.m(div, null);
      append(div, t8);
      if (if_block8)
        if_block8.m(div, null);
      append(div, t9);
      if (if_block9)
        if_block9.m(div, null);
      ctx[85](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(window, "click", ctx[41]),
          listen(window, "focusin", ctx[41]),
          listen(window, "keydown", ctx[39]),
          listen(input_1, "focus", ctx[40]),
          listen(input_1, "input", ctx[83]),
          listen(div, "click", ctx[42])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          if_block0.m(span, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[17]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 131072) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[35]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & 16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_8(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
        (!current || dirty[0] & 8192 && input_1_readonly_value !== (input_1_readonly_value = !ctx2[13])) && { readOnly: input_1_readonly_value },
        dirty[1] & 1 && ctx2[31],
        (!current || dirty[1] & 32) && { placeholder: ctx2[36] },
        (!current || dirty[0] & 16384) && { style: ctx2[14] },
        (!current || dirty[0] & 512) && { disabled: ctx2[9] }
      ]));
      if (dirty[0] & 8 && input_1.value !== ctx2[3]) {
        set_input_value(input_1, ctx2[3]);
      }
      toggle_class(input_1, "svelte-17l1npl", true);
      if (!ctx2[7] && ctx2[29]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 536871040) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_7(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (ctx2[37]) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & 64) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_6(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (!ctx2[37] && (ctx2[20] || ctx2[19] && !ctx2[2] || !ctx2[13] && !ctx2[9] && !ctx2[4] && (ctx2[29] && !ctx2[15] || !ctx2[29]))) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_4(ctx2);
          if_block5.c();
          if_block5.m(div, t6);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (ctx2[4]) {
        if (if_block6)
          ;
        else {
          if_block6 = create_if_block_3();
          if_block6.c();
          if_block6.m(div, t7);
        }
      } else if (if_block6) {
        if_block6.d(1);
        if_block6 = null;
      }
      if (ctx2[5]) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_2$2(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(div, t8);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (!ctx2[7] || ctx2[7] && !ctx2[35]) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
        } else {
          if_block8 = create_if_block_1$2(ctx2);
          if_block8.c();
          if_block8.m(div, t9);
        }
      } else if (if_block8) {
        if_block8.d(1);
        if_block8 = null;
      }
      if (ctx2[7] && ctx2[35]) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
        } else {
          if_block9 = create_if_block$4(ctx2);
          if_block9.c();
          if_block9.m(div, null);
        }
      } else if (if_block9) {
        if_block9.d(1);
        if_block9 = null;
      }
      if (!current || dirty[0] & 2097152 && div_class_value !== (div_class_value = "selectContainer " + ctx2[21] + " svelte-17l1npl")) {
        attr(div, "class", div_class_value);
      }
      if (!current || dirty[0] & 2048) {
        attr(div, "style", ctx2[11]);
      }
      if (dirty[0] & 2098176) {
        toggle_class(div, "hasError", ctx2[10]);
      }
      if (dirty[0] & 2097280) {
        toggle_class(div, "multiSelect", ctx2[7]);
      }
      if (dirty[0] & 2097664) {
        toggle_class(div, "disabled", ctx2[9]);
      }
      if (dirty[0] & 2097154) {
        toggle_class(div, "focused", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block7);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block7);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      ctx[82](null);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
      if (if_block8)
        if_block8.d();
      if (if_block9)
        if_block9.d();
      ctx[85](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function convertStringItemsToObjects(_items) {
  return _items.map((item, index) => {
    return { index, value: item, label: `${item}` };
  });
}
function instance$5($$self, $$props, $$invalidate) {
  let filteredItems;
  let showSelectedItem;
  let showClearIcon;
  let placeholderText;
  let showMultiSelect;
  let listProps;
  let ariaSelection;
  let ariaContext;
  const dispatch2 = createEventDispatcher();
  let { id = null } = $$props;
  let { container = void 0 } = $$props;
  let { input = void 0 } = $$props;
  let { isMulti = false } = $$props;
  let { multiFullItemClearable = false } = $$props;
  let { isDisabled = false } = $$props;
  let { isCreatable = false } = $$props;
  let { isFocused = false } = $$props;
  let { value = null } = $$props;
  let { filterText = "" } = $$props;
  let { placeholder = "Select..." } = $$props;
  let { placeholderAlwaysShow = false } = $$props;
  let { items = null } = $$props;
  let { itemFilter = (label, filterText2, option) => `${label}`.toLowerCase().includes(filterText2.toLowerCase()) } = $$props;
  let { groupBy = void 0 } = $$props;
  let { groupFilter = (groups) => groups } = $$props;
  let { isGroupHeaderSelectable = false } = $$props;
  let { getGroupHeaderLabel = (option) => {
    return option[labelIdentifier] || option.id;
  } } = $$props;
  let { labelIdentifier = "label" } = $$props;
  let { getOptionLabel = (option, filterText2) => {
    return option.isCreator ? `Create "${filterText2}"` : option[labelIdentifier];
  } } = $$props;
  let { optionIdentifier = "value" } = $$props;
  let { loadOptions = void 0 } = $$props;
  let { hasError = false } = $$props;
  let { containerStyles = "" } = $$props;
  let { getSelectionLabel = (option) => {
    if (option)
      return option[labelIdentifier];
    else
      return null;
  } } = $$props;
  let { createGroupHeaderItem = (groupValue) => {
    return { value: groupValue, label: groupValue };
  } } = $$props;
  let { createItem = (filterText2) => {
    return { value: filterText2, label: filterText2 };
  } } = $$props;
  const getFilteredItems = () => {
    return filteredItems;
  };
  let { isSearchable = true } = $$props;
  let { inputStyles = "" } = $$props;
  let { isClearable = true } = $$props;
  let { isWaiting = false } = $$props;
  let { listPlacement = "auto" } = $$props;
  let { listOpen = false } = $$props;
  let { isVirtualList = false } = $$props;
  let { loadOptionsInterval = 300 } = $$props;
  let { noOptionsMessage = "No options" } = $$props;
  let { hideEmptyState = false } = $$props;
  let { inputAttributes = {} } = $$props;
  let { listAutoWidth = true } = $$props;
  let { itemHeight = 40 } = $$props;
  let { Icon = void 0 } = $$props;
  let { iconProps = {} } = $$props;
  let { showChevron = false } = $$props;
  let { showIndicator = false } = $$props;
  let { containerClasses = "" } = $$props;
  let { indicatorSvg = void 0 } = $$props;
  let { listOffset = 5 } = $$props;
  let { ClearIcon: ClearIcon$1 = ClearIcon } = $$props;
  let { Item: Item$1 = Item } = $$props;
  let { List: List$1 = List } = $$props;
  let { Selection: Selection$1 = Selection } = $$props;
  let { MultiSelection: MultiSelection$1 = MultiSelection } = $$props;
  let { VirtualList: VirtualList$1 = VirtualList } = $$props;
  function filterMethod(args) {
    if (args.loadOptions && args.filterText.length > 0)
      return;
    if (!args.items)
      return [];
    if (args.items && args.items.length > 0 && typeof args.items[0] !== "object") {
      args.items = convertStringItemsToObjects(args.items);
    }
    let filterResults = args.items.filter((item) => {
      let matchesFilter = itemFilter(getOptionLabel(item, args.filterText), args.filterText, item);
      if (matchesFilter && args.isMulti && args.value && Array.isArray(args.value)) {
        matchesFilter = !args.value.some((x) => {
          return x[args.optionIdentifier] === item[args.optionIdentifier];
        });
      }
      return matchesFilter;
    });
    if (args.groupBy) {
      filterResults = filterGroupedItems(filterResults);
    }
    if (args.isCreatable) {
      filterResults = addCreatableItem(filterResults, args.filterText);
    }
    return filterResults;
  }
  function addCreatableItem(_items, _filterText) {
    if (_filterText.length === 0)
      return _items;
    const itemToCreate = createItem(_filterText);
    if (_items[0] && _filterText === _items[0][labelIdentifier])
      return _items;
    itemToCreate.isCreator = true;
    return [..._items, itemToCreate];
  }
  let { selectedValue = null } = $$props;
  let activeValue;
  let prev_value;
  let prev_filterText;
  let prev_isFocused;
  let prev_isMulti;
  let hoverItemIndex;
  const getItems = debounce(
    async () => {
      $$invalidate(4, isWaiting = true);
      let res = await loadOptions(filterText).catch((err) => {
        console.warn("svelte-select loadOptions error :>> ", err);
        dispatch2("error", { type: "loadOptions", details: err });
      });
      if (res && !res.cancelled) {
        if (res) {
          if (res && res.length > 0 && typeof res[0] !== "object") {
            res = convertStringItemsToObjects(res);
          }
          $$invalidate(81, filteredItems = [...res]);
          dispatch2("loaded", { items: filteredItems });
        } else {
          $$invalidate(81, filteredItems = []);
        }
        if (isCreatable) {
          $$invalidate(81, filteredItems = addCreatableItem(filteredItems, filterText));
        }
        $$invalidate(4, isWaiting = false);
        $$invalidate(1, isFocused = true);
        $$invalidate(5, listOpen = true);
      }
    },
    loadOptionsInterval
  );
  function setValue() {
    if (typeof value === "string") {
      $$invalidate(2, value = { [optionIdentifier]: value, label: value });
    } else if (isMulti && Array.isArray(value) && value.length > 0) {
      $$invalidate(2, value = value.map((item) => typeof item === "string" ? { value: item, label: item } : item));
    }
  }
  let _inputAttributes;
  function assignInputAttributes() {
    $$invalidate(31, _inputAttributes = Object.assign(
      {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        tabindex: 0,
        type: "text",
        "aria-autocomplete": "list"
      },
      inputAttributes
    ));
    if (id) {
      $$invalidate(31, _inputAttributes.id = id, _inputAttributes);
    }
    if (!isSearchable) {
      $$invalidate(31, _inputAttributes.readonly = true, _inputAttributes);
    }
  }
  function filterGroupedItems(_items) {
    const groupValues = [];
    const groups = {};
    _items.forEach((item) => {
      const groupValue = groupBy(item);
      if (!groupValues.includes(groupValue)) {
        groupValues.push(groupValue);
        groups[groupValue] = [];
        if (groupValue) {
          groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
            id: groupValue,
            isGroupHeader: true,
            isSelectable: isGroupHeaderSelectable
          }));
        }
      }
      groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
    });
    const sortedGroupedItems = [];
    groupFilter(groupValues).forEach((groupValue) => {
      sortedGroupedItems.push(...groups[groupValue]);
    });
    return sortedGroupedItems;
  }
  function dispatchSelectedItem() {
    if (isMulti) {
      if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
        if (checkValueForDuplicates()) {
          dispatch2("select", value);
        }
      }
      return;
    }
    if (!prev_value || JSON.stringify(value[optionIdentifier]) !== JSON.stringify(prev_value[optionIdentifier])) {
      dispatch2("select", value);
    }
  }
  function setupFocus() {
    if (isFocused || listOpen) {
      handleFocus();
    } else {
      if (input)
        input.blur();
    }
  }
  function setupMulti() {
    if (value) {
      if (Array.isArray(value)) {
        $$invalidate(2, value = [...value]);
      } else {
        $$invalidate(2, value = [value]);
      }
    }
  }
  function setupSingle() {
    if (value)
      $$invalidate(2, value = null);
  }
  function setupFilterText() {
    if (filterText.length === 0)
      return;
    $$invalidate(1, isFocused = true);
    $$invalidate(5, listOpen = true);
    if (loadOptions) {
      getItems();
    } else {
      $$invalidate(5, listOpen = true);
      if (isMulti) {
        $$invalidate(30, activeValue = void 0);
      }
    }
  }
  beforeUpdate(async () => {
    $$invalidate(77, prev_value = value);
    $$invalidate(78, prev_filterText = filterText);
    $$invalidate(79, prev_isFocused = isFocused);
    $$invalidate(80, prev_isMulti = isMulti);
  });
  function checkValueForDuplicates() {
    let noDuplicates = true;
    if (value) {
      const ids = [];
      const uniqueValues = [];
      value.forEach((val) => {
        if (!ids.includes(val[optionIdentifier])) {
          ids.push(val[optionIdentifier]);
          uniqueValues.push(val);
        } else {
          noDuplicates = false;
        }
      });
      if (!noDuplicates)
        $$invalidate(2, value = uniqueValues);
    }
    return noDuplicates;
  }
  function findItem(selection) {
    let matchTo = selection ? selection[optionIdentifier] : value[optionIdentifier];
    return items.find((item) => item[optionIdentifier] === matchTo);
  }
  function updateValueDisplay(items2) {
    if (!items2 || items2.length === 0 || items2.some((item) => typeof item !== "object"))
      return;
    if (!value || (isMulti ? value.some((selection) => !selection || !selection[optionIdentifier]) : !value[optionIdentifier]))
      return;
    if (Array.isArray(value)) {
      $$invalidate(2, value = value.map((selection) => findItem(selection) || selection));
    } else {
      $$invalidate(2, value = findItem() || value);
    }
  }
  function handleMultiItemClear(event) {
    const { detail } = event;
    const itemToRemove = value[detail ? detail.i : value.length - 1];
    if (value.length === 1) {
      $$invalidate(2, value = void 0);
    } else {
      $$invalidate(2, value = value.filter((item) => {
        return item !== itemToRemove;
      }));
    }
    dispatch2("clear", itemToRemove);
  }
  function handleKeyDown(e) {
    if (!isFocused)
      return;
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        $$invalidate(5, listOpen = true);
        $$invalidate(30, activeValue = void 0);
        break;
      case "ArrowUp":
        e.preventDefault();
        $$invalidate(5, listOpen = true);
        $$invalidate(30, activeValue = void 0);
        break;
      case "Tab":
        if (!listOpen)
          $$invalidate(1, isFocused = false);
        break;
      case "Backspace":
        if (!isMulti || filterText.length > 0)
          return;
        if (isMulti && value && value.length > 0) {
          handleMultiItemClear(activeValue !== void 0 ? activeValue : value.length - 1);
          if (activeValue === 0 || activeValue === void 0)
            break;
          $$invalidate(30, activeValue = value.length > activeValue ? activeValue - 1 : void 0);
        }
        break;
      case "ArrowLeft":
        if (!isMulti || filterText.length > 0)
          return;
        if (activeValue === void 0) {
          $$invalidate(30, activeValue = value.length - 1);
        } else if (value.length > activeValue && activeValue !== 0) {
          $$invalidate(30, activeValue -= 1);
        }
        break;
      case "ArrowRight":
        if (!isMulti || filterText.length > 0 || activeValue === void 0)
          return;
        if (activeValue === value.length - 1) {
          $$invalidate(30, activeValue = void 0);
        } else if (activeValue < value.length - 1) {
          $$invalidate(30, activeValue += 1);
        }
        break;
    }
  }
  function handleFocus() {
    $$invalidate(1, isFocused = true);
    if (input)
      input.focus();
  }
  function handleWindowEvent(event) {
    if (!container)
      return;
    const eventTarget = event.path && event.path.length > 0 ? event.path[0] : event.target;
    if (container.contains(eventTarget) || container.contains(event.relatedTarget)) {
      return;
    }
    $$invalidate(1, isFocused = false);
    $$invalidate(5, listOpen = false);
    $$invalidate(30, activeValue = void 0);
    if (input)
      input.blur();
  }
  function handleClick() {
    if (isDisabled)
      return;
    $$invalidate(1, isFocused = true);
    $$invalidate(5, listOpen = !listOpen);
  }
  function handleClear() {
    $$invalidate(2, value = void 0);
    $$invalidate(5, listOpen = false);
    dispatch2("clear", value);
    handleFocus();
  }
  onMount(() => {
    if (isFocused && input)
      input.focus();
  });
  function itemSelected(event) {
    const { detail } = event;
    if (detail) {
      $$invalidate(3, filterText = "");
      const item = Object.assign({}, detail);
      if (!item.isGroupHeader || item.isSelectable) {
        if (isMulti) {
          $$invalidate(2, value = value ? value.concat([item]) : [item]);
        } else {
          $$invalidate(2, value = item);
        }
        $$invalidate(2, value);
        setTimeout(() => {
          $$invalidate(5, listOpen = false);
          $$invalidate(30, activeValue = void 0);
        });
      }
    }
  }
  function itemCreated(event) {
    const { detail } = event;
    if (isMulti) {
      $$invalidate(2, value = value || []);
      $$invalidate(2, value = [...value, createItem(detail)]);
    } else {
      $$invalidate(2, value = createItem(detail));
    }
    dispatch2("itemCreated", detail);
    $$invalidate(3, filterText = "");
    $$invalidate(5, listOpen = false);
    $$invalidate(30, activeValue = void 0);
  }
  function closeList() {
    $$invalidate(3, filterText = "");
    $$invalidate(5, listOpen = false);
  }
  let { ariaValues = (values) => {
    return `Option ${values}, selected.`;
  } } = $$props;
  let { ariaListOpen = (label, count) => {
    return `You are currently focused on option ${label}. There are ${count} results available.`;
  } } = $$props;
  let { ariaFocused = () => {
    return `Select is focused, type to refine list, press down to open the menu.`;
  } } = $$props;
  function handleAriaSelection() {
    let selected = void 0;
    if (isMulti && value.length > 0) {
      selected = value.map((v) => getSelectionLabel(v)).join(", ");
    } else {
      selected = getSelectionLabel(value);
    }
    return ariaValues(selected);
  }
  function handleAriaContent() {
    if (!isFocused || !filteredItems || filteredItems.length === 0)
      return "";
    let _item = filteredItems[hoverItemIndex];
    if (listOpen && _item) {
      let label = getSelectionLabel(_item);
      let count = filteredItems ? filteredItems.length : 0;
      return ariaListOpen(label, count);
    } else {
      return ariaFocused();
    }
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(6, input);
    });
  }
  function input_1_input_handler() {
    filterText = this.value;
    $$invalidate(3, filterText);
  }
  function switch_instance_hoverItemIndex_binding(value2) {
    hoverItemIndex = value2;
    $$invalidate(28, hoverItemIndex);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(46, id = $$props2.id);
    if ("container" in $$props2)
      $$invalidate(0, container = $$props2.container);
    if ("input" in $$props2)
      $$invalidate(6, input = $$props2.input);
    if ("isMulti" in $$props2)
      $$invalidate(7, isMulti = $$props2.isMulti);
    if ("multiFullItemClearable" in $$props2)
      $$invalidate(8, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("isDisabled" in $$props2)
      $$invalidate(9, isDisabled = $$props2.isDisabled);
    if ("isCreatable" in $$props2)
      $$invalidate(47, isCreatable = $$props2.isCreatable);
    if ("isFocused" in $$props2)
      $$invalidate(1, isFocused = $$props2.isFocused);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
    if ("filterText" in $$props2)
      $$invalidate(3, filterText = $$props2.filterText);
    if ("placeholder" in $$props2)
      $$invalidate(48, placeholder = $$props2.placeholder);
    if ("placeholderAlwaysShow" in $$props2)
      $$invalidate(49, placeholderAlwaysShow = $$props2.placeholderAlwaysShow);
    if ("items" in $$props2)
      $$invalidate(50, items = $$props2.items);
    if ("itemFilter" in $$props2)
      $$invalidate(51, itemFilter = $$props2.itemFilter);
    if ("groupBy" in $$props2)
      $$invalidate(52, groupBy = $$props2.groupBy);
    if ("groupFilter" in $$props2)
      $$invalidate(53, groupFilter = $$props2.groupFilter);
    if ("isGroupHeaderSelectable" in $$props2)
      $$invalidate(54, isGroupHeaderSelectable = $$props2.isGroupHeaderSelectable);
    if ("getGroupHeaderLabel" in $$props2)
      $$invalidate(55, getGroupHeaderLabel = $$props2.getGroupHeaderLabel);
    if ("labelIdentifier" in $$props2)
      $$invalidate(56, labelIdentifier = $$props2.labelIdentifier);
    if ("getOptionLabel" in $$props2)
      $$invalidate(57, getOptionLabel = $$props2.getOptionLabel);
    if ("optionIdentifier" in $$props2)
      $$invalidate(58, optionIdentifier = $$props2.optionIdentifier);
    if ("loadOptions" in $$props2)
      $$invalidate(59, loadOptions = $$props2.loadOptions);
    if ("hasError" in $$props2)
      $$invalidate(10, hasError = $$props2.hasError);
    if ("containerStyles" in $$props2)
      $$invalidate(11, containerStyles = $$props2.containerStyles);
    if ("getSelectionLabel" in $$props2)
      $$invalidate(12, getSelectionLabel = $$props2.getSelectionLabel);
    if ("createGroupHeaderItem" in $$props2)
      $$invalidate(60, createGroupHeaderItem = $$props2.createGroupHeaderItem);
    if ("createItem" in $$props2)
      $$invalidate(61, createItem = $$props2.createItem);
    if ("isSearchable" in $$props2)
      $$invalidate(13, isSearchable = $$props2.isSearchable);
    if ("inputStyles" in $$props2)
      $$invalidate(14, inputStyles = $$props2.inputStyles);
    if ("isClearable" in $$props2)
      $$invalidate(15, isClearable = $$props2.isClearable);
    if ("isWaiting" in $$props2)
      $$invalidate(4, isWaiting = $$props2.isWaiting);
    if ("listPlacement" in $$props2)
      $$invalidate(63, listPlacement = $$props2.listPlacement);
    if ("listOpen" in $$props2)
      $$invalidate(5, listOpen = $$props2.listOpen);
    if ("isVirtualList" in $$props2)
      $$invalidate(64, isVirtualList = $$props2.isVirtualList);
    if ("loadOptionsInterval" in $$props2)
      $$invalidate(65, loadOptionsInterval = $$props2.loadOptionsInterval);
    if ("noOptionsMessage" in $$props2)
      $$invalidate(66, noOptionsMessage = $$props2.noOptionsMessage);
    if ("hideEmptyState" in $$props2)
      $$invalidate(67, hideEmptyState = $$props2.hideEmptyState);
    if ("inputAttributes" in $$props2)
      $$invalidate(16, inputAttributes = $$props2.inputAttributes);
    if ("listAutoWidth" in $$props2)
      $$invalidate(68, listAutoWidth = $$props2.listAutoWidth);
    if ("itemHeight" in $$props2)
      $$invalidate(69, itemHeight = $$props2.itemHeight);
    if ("Icon" in $$props2)
      $$invalidate(17, Icon = $$props2.Icon);
    if ("iconProps" in $$props2)
      $$invalidate(18, iconProps = $$props2.iconProps);
    if ("showChevron" in $$props2)
      $$invalidate(19, showChevron = $$props2.showChevron);
    if ("showIndicator" in $$props2)
      $$invalidate(20, showIndicator = $$props2.showIndicator);
    if ("containerClasses" in $$props2)
      $$invalidate(21, containerClasses = $$props2.containerClasses);
    if ("indicatorSvg" in $$props2)
      $$invalidate(22, indicatorSvg = $$props2.indicatorSvg);
    if ("listOffset" in $$props2)
      $$invalidate(70, listOffset = $$props2.listOffset);
    if ("ClearIcon" in $$props2)
      $$invalidate(23, ClearIcon$1 = $$props2.ClearIcon);
    if ("Item" in $$props2)
      $$invalidate(71, Item$1 = $$props2.Item);
    if ("List" in $$props2)
      $$invalidate(24, List$1 = $$props2.List);
    if ("Selection" in $$props2)
      $$invalidate(25, Selection$1 = $$props2.Selection);
    if ("MultiSelection" in $$props2)
      $$invalidate(26, MultiSelection$1 = $$props2.MultiSelection);
    if ("VirtualList" in $$props2)
      $$invalidate(72, VirtualList$1 = $$props2.VirtualList);
    if ("selectedValue" in $$props2)
      $$invalidate(73, selectedValue = $$props2.selectedValue);
    if ("ariaValues" in $$props2)
      $$invalidate(74, ariaValues = $$props2.ariaValues);
    if ("ariaListOpen" in $$props2)
      $$invalidate(75, ariaListOpen = $$props2.ariaListOpen);
    if ("ariaFocused" in $$props2)
      $$invalidate(76, ariaFocused = $$props2.ariaFocused);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 140 | $$self.$$.dirty[1] & 405340160) {
      $$invalidate(81, filteredItems = filterMethod({
        loadOptions,
        filterText,
        items,
        value,
        isMulti,
        optionIdentifier,
        groupBy,
        isCreatable
      }));
    }
    if ($$self.$$.dirty[2] & 2048) {
      {
        if (selectedValue)
          console.warn("selectedValue is no longer used. Please use value instead.");
      }
    }
    if ($$self.$$.dirty[1] & 524288) {
      updateValueDisplay(items);
    }
    if ($$self.$$.dirty[0] & 4) {
      {
        if (value)
          setValue();
      }
    }
    if ($$self.$$.dirty[0] & 73728) {
      {
        if (inputAttributes || !isSearchable)
          assignInputAttributes();
      }
    }
    if ($$self.$$.dirty[0] & 128 | $$self.$$.dirty[2] & 262144) {
      {
        if (isMulti) {
          setupMulti();
        }
        if (prev_isMulti && !isMulti) {
          setupSingle();
        }
      }
    }
    if ($$self.$$.dirty[0] & 132) {
      {
        if (isMulti && value && value.length > 1) {
          checkValueForDuplicates();
        }
      }
    }
    if ($$self.$$.dirty[0] & 4) {
      {
        if (value)
          dispatchSelectedItem();
      }
    }
    if ($$self.$$.dirty[0] & 132 | $$self.$$.dirty[2] & 32768) {
      {
        if (!value && isMulti && prev_value) {
          dispatch2("select", value);
        }
      }
    }
    if ($$self.$$.dirty[0] & 2 | $$self.$$.dirty[2] & 131072) {
      {
        if (isFocused !== prev_isFocused) {
          setupFocus();
        }
      }
    }
    if ($$self.$$.dirty[0] & 8 | $$self.$$.dirty[2] & 65536) {
      {
        if (filterText !== prev_filterText) {
          setupFilterText();
        }
      }
    }
    if ($$self.$$.dirty[0] & 12) {
      $$invalidate(29, showSelectedItem = value && filterText.length === 0);
    }
    if ($$self.$$.dirty[0] & 536904208) {
      $$invalidate(37, showClearIcon = showSelectedItem && isClearable && !isDisabled && !isWaiting);
    }
    if ($$self.$$.dirty[0] & 132 | $$self.$$.dirty[1] & 393216) {
      $$invalidate(36, placeholderText = placeholderAlwaysShow && isMulti ? placeholder : value ? "" : placeholder);
    }
    if ($$self.$$.dirty[0] & 132) {
      $$invalidate(35, showMultiSelect = isMulti && value && value.length > 0);
    }
    if ($$self.$$.dirty[0] & 141 | $$self.$$.dirty[1] & 218103808 | $$self.$$.dirty[2] & 526326) {
      $$invalidate(34, listProps = {
        Item: Item$1,
        filterText,
        optionIdentifier,
        noOptionsMessage,
        hideEmptyState,
        isVirtualList,
        VirtualList: VirtualList$1,
        value,
        isMulti,
        getGroupHeaderLabel,
        items: filteredItems,
        itemHeight,
        getOptionLabel,
        listPlacement,
        parent: container,
        listAutoWidth,
        listOffset
      });
    }
    if ($$self.$$.dirty[0] & 132) {
      $$invalidate(33, ariaSelection = value ? handleAriaSelection() : "");
    }
    if ($$self.$$.dirty[0] & 268435490 | $$self.$$.dirty[2] & 524288) {
      $$invalidate(32, ariaContext = handleAriaContent());
    }
  };
  return [
    container,
    isFocused,
    value,
    filterText,
    isWaiting,
    listOpen,
    input,
    isMulti,
    multiFullItemClearable,
    isDisabled,
    hasError,
    containerStyles,
    getSelectionLabel,
    isSearchable,
    inputStyles,
    isClearable,
    inputAttributes,
    Icon,
    iconProps,
    showChevron,
    showIndicator,
    containerClasses,
    indicatorSvg,
    ClearIcon$1,
    List$1,
    Selection$1,
    MultiSelection$1,
    handleClear,
    hoverItemIndex,
    showSelectedItem,
    activeValue,
    _inputAttributes,
    ariaContext,
    ariaSelection,
    listProps,
    showMultiSelect,
    placeholderText,
    showClearIcon,
    handleMultiItemClear,
    handleKeyDown,
    handleFocus,
    handleWindowEvent,
    handleClick,
    itemSelected,
    itemCreated,
    closeList,
    id,
    isCreatable,
    placeholder,
    placeholderAlwaysShow,
    items,
    itemFilter,
    groupBy,
    groupFilter,
    isGroupHeaderSelectable,
    getGroupHeaderLabel,
    labelIdentifier,
    getOptionLabel,
    optionIdentifier,
    loadOptions,
    createGroupHeaderItem,
    createItem,
    getFilteredItems,
    listPlacement,
    isVirtualList,
    loadOptionsInterval,
    noOptionsMessage,
    hideEmptyState,
    listAutoWidth,
    itemHeight,
    listOffset,
    Item$1,
    VirtualList$1,
    selectedValue,
    ariaValues,
    ariaListOpen,
    ariaFocused,
    prev_value,
    prev_filterText,
    prev_isFocused,
    prev_isMulti,
    filteredItems,
    input_1_binding,
    input_1_input_handler,
    switch_instance_hoverItemIndex_binding,
    div_binding
  ];
}
class Select extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$5,
      create_fragment$5,
      safe_not_equal,
      {
        id: 46,
        container: 0,
        input: 6,
        isMulti: 7,
        multiFullItemClearable: 8,
        isDisabled: 9,
        isCreatable: 47,
        isFocused: 1,
        value: 2,
        filterText: 3,
        placeholder: 48,
        placeholderAlwaysShow: 49,
        items: 50,
        itemFilter: 51,
        groupBy: 52,
        groupFilter: 53,
        isGroupHeaderSelectable: 54,
        getGroupHeaderLabel: 55,
        labelIdentifier: 56,
        getOptionLabel: 57,
        optionIdentifier: 58,
        loadOptions: 59,
        hasError: 10,
        containerStyles: 11,
        getSelectionLabel: 12,
        createGroupHeaderItem: 60,
        createItem: 61,
        getFilteredItems: 62,
        isSearchable: 13,
        inputStyles: 14,
        isClearable: 15,
        isWaiting: 4,
        listPlacement: 63,
        listOpen: 5,
        isVirtualList: 64,
        loadOptionsInterval: 65,
        noOptionsMessage: 66,
        hideEmptyState: 67,
        inputAttributes: 16,
        listAutoWidth: 68,
        itemHeight: 69,
        Icon: 17,
        iconProps: 18,
        showChevron: 19,
        showIndicator: 20,
        containerClasses: 21,
        indicatorSvg: 22,
        listOffset: 70,
        ClearIcon: 23,
        Item: 71,
        List: 24,
        Selection: 25,
        MultiSelection: 26,
        VirtualList: 72,
        selectedValue: 73,
        handleClear: 27,
        ariaValues: 74,
        ariaListOpen: 75,
        ariaFocused: 76
      },
      null,
      [-1, -1, -1, -1]
    );
  }
  get getFilteredItems() {
    return this.$$.ctx[62];
  }
  get handleClear() {
    return this.$$.ctx[27];
  }
}
var StarSelect_svelte_svelte_type_style_lang = "";
function create_fragment$4(ctx) {
  let div;
  let select;
  let div_1;
  let updating_value;
  let div_class_value;
  let current;
  function select_value_binding(value) {
    ctx[14](value);
  }
  let select_props = {
    id: "sender-select",
    placeholder: ctx[1],
    listOffset: ctx[2],
    isClearable: ctx[3],
    showIndicator: ctx[4],
    indicatorSvg: SX_ICON_DROPDOWN,
    listPlacement: "bottom",
    items: ctx[5],
    getOptionLabel: ctx[9],
    getSelectionLabel: ctx[9]
  };
  if (ctx[0] !== void 0) {
    select_props.value = ctx[0];
  }
  select = new Select({ props: select_props });
  binding_callbacks.push(() => bind(select, "value", select_value_binding));
  return {
    c() {
      div = element("div");
      div_1 = element("div");
      create_component(select.$$.fragment);
      set_style(div_1, "display", "contents");
      set_style(div_1, "--listMaxHeight", ctx[8]);
      attr(div, "class", div_class_value = "star-select " + ctx[6] + " svelte-dvjau7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, div_1);
      mount_component(select, div_1, null);
      ctx[15](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 256) {
        set_style(div_1, "--listMaxHeight", ctx2[8]);
      }
      const select_changes = {};
      if (dirty & 2)
        select_changes.placeholder = ctx2[1];
      if (dirty & 4)
        select_changes.listOffset = ctx2[2];
      if (dirty & 8)
        select_changes.isClearable = ctx2[3];
      if (dirty & 16)
        select_changes.showIndicator = ctx2[4];
      if (dirty & 32)
        select_changes.items = ctx2[5];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        select_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
      if (!current || dirty & 64 && div_class_value !== (div_class_value = "star-select " + ctx2[6] + " svelte-dvjau7")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(select);
      ctx[15](null);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let { id = "" } = $$props;
  let { placeholder = "" } = $$props;
  let { listOffset = 1 } = $$props;
  let { isClearable = false } = $$props;
  let { showIndicator = true } = $$props;
  let { items } = $$props;
  let { value = void 0 } = $$props;
  let { pfpMap = null } = $$props;
  const h_pfps = pfpMap;
  let { primaryClass = "" } = $$props;
  let { secondaryClass = "" } = $$props;
  let { containerClasses = "" } = $$props;
  function create_label(g_item) {
    if (g_item.primary) {
      return dd("span", { class: "global_select-item" }, [
        h_pfps ? h_pfps[g_item.object.pfp] || "" : "",
        dd("span", { class: "name " + primaryClass }, [g_item.primary]),
        dd("span", { class: "secondary " + secondaryClass }, [g_item.secondary || ""])
      ]).outerHTML;
    }
    return g_item.value;
  }
  let dm_star_select;
  let sx_max_height = "500px";
  onMount(() => {
    setTimeout(
      () => {
        try {
          const x_bottom = dm_star_select.getBoundingClientRect().bottom;
          $$invalidate(8, sx_max_height = Math.min(window.innerHeight - x_bottom - 20, 500) + "px");
        } catch (e_bounds) {
        }
      },
      1e3
    );
  });
  function select_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_star_select = $$value;
      $$invalidate(7, dm_star_select);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(10, id = $$props2.id);
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
    if ("listOffset" in $$props2)
      $$invalidate(2, listOffset = $$props2.listOffset);
    if ("isClearable" in $$props2)
      $$invalidate(3, isClearable = $$props2.isClearable);
    if ("showIndicator" in $$props2)
      $$invalidate(4, showIndicator = $$props2.showIndicator);
    if ("items" in $$props2)
      $$invalidate(5, items = $$props2.items);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("pfpMap" in $$props2)
      $$invalidate(11, pfpMap = $$props2.pfpMap);
    if ("primaryClass" in $$props2)
      $$invalidate(12, primaryClass = $$props2.primaryClass);
    if ("secondaryClass" in $$props2)
      $$invalidate(13, secondaryClass = $$props2.secondaryClass);
    if ("containerClasses" in $$props2)
      $$invalidate(6, containerClasses = $$props2.containerClasses);
  };
  return [
    value,
    placeholder,
    listOffset,
    isClearable,
    showIndicator,
    items,
    containerClasses,
    dm_star_select,
    sx_max_height,
    create_label,
    id,
    pfpMap,
    primaryClass,
    secondaryClass,
    select_value_binding,
    div_binding
  ];
}
class StarSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, {
      id: 10,
      placeholder: 1,
      listOffset: 2,
      isClearable: 3,
      showIndicator: 4,
      items: 5,
      value: 0,
      pfpMap: 11,
      primaryClass: 12,
      secondaryClass: 13,
      containerClasses: 6
    });
  }
}
function once_store_updates(yw_store, b_truthy = false) {
  return new Promise((fk_resolve) => {
    let b_initialized = false;
    const f_unsubscribe = yw_store.subscribe((w_value) => {
      if (!b_initialized) {
        b_initialized = true;
        return;
      }
      if (!b_truthy || w_value) {
        f_unsubscribe();
        fk_resolve(w_value);
      }
    });
  });
}
async function load_pfps(h_resources, h_props) {
  return ofe(
    await Promise.all(
      ode(h_resources).map(([_, g_resource]) => new Promise(
        (fk_resolve) => {
          const dm_dummy = dd("span");
          const yc_pfp = new PfpDisplay({
            target: dm_dummy,
            props: {
              ...h_props,
              resource: g_resource,
              settle() {
                const dm_pfp = dm_dummy.firstChild?.cloneNode(true);
                yc_pfp.$destroy();
                fk_resolve([g_resource.pfp, dm_pfp]);
              }
            }
          });
        }
      ))
    )
  );
}
const D_INTL_USD = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  currencyDisplay: "symbol"
});
const D_INTL_USD_LT1 = new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: "USD",
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 5
});
const A_NUMERIC_GT1 = [
  {
    order: 1e21,
    suffix: "sept",
    metric: "yotta",
    m: "Y"
  },
  {
    order: 1e21,
    suffix: "sext",
    metric: "zetta",
    m: "Z"
  },
  {
    order: 1e18,
    suffix: "quint",
    metric: "exa",
    m: "E"
  },
  {
    order: 1e15,
    suffix: "quad",
    metric: "peta",
    m: "P"
  },
  {
    order: 1e12,
    suffix: "tril",
    metric: "terra",
    m: "T"
  },
  {
    order: 1e9,
    suffix: "bil",
    metric: "giga",
    m: "G"
  },
  {
    order: 1e6,
    suffix: "mil",
    metric: "mega",
    m: "M"
  }
];
const A_NUMERIC_LT1 = [
  {
    order: 1e-24,
    suffix: "septh",
    metric: "yocto",
    m: "y"
  },
  {
    order: 1e-21,
    suffix: "sexth",
    metric: "zepto",
    m: "z"
  },
  {
    order: 1e-18,
    suffix: "quinth",
    metric: "atto",
    m: "a"
  },
  {
    order: 1e-15,
    suffix: "quadth",
    metric: "femto",
    m: "f"
  },
  {
    order: 1e-12,
    suffix: "trilth",
    metric: "pico",
    m: "p"
  },
  {
    order: 1e-9,
    suffix: "bilth",
    metric: "nano",
    m: "n"
  },
  {
    order: 1e-6,
    suffix: "milth",
    metric: "mirco",
    m: "\u03BC"
  },
  {
    order: 1e-3,
    suffix: "thsth",
    metric: "milli",
    m: "m"
  }
];
const D_INTL_AMOUNT_LT1 = new Intl.NumberFormat("en-US", {
  notation: "standard",
  maximumSignificantDigits: 6
});
const D_INTL_AMOUNT_GT1 = new Intl.NumberFormat("en-US", {
  notation: "standard",
  maximumFractionDigits: 3
});
const D_INTL_AMOUNT_GT1E3 = new Intl.NumberFormat("en-US", {
  notation: "standard",
  maximumSignificantDigits: 6
});
const D_INTL_AMOUNT_I1E3 = new Intl.NumberFormat("en-US", {
  notation: "standard",
  maximumSignificantDigits: 4
});
function format_amount(x_amount, b_shorter = false) {
  if (0 === x_amount)
    return "0";
  if (x_amount >= 1e6) {
    for (const gc_abbr of A_NUMERIC_GT1) {
      if (x_amount >= gc_abbr.order) {
        return (x_amount / gc_abbr.order).toPrecision(3) + " " + gc_abbr.suffix;
      }
    }
  } else if (x_amount < 1) {
    for (const gc_abbr of A_NUMERIC_LT1) {
      if (x_amount <= gc_abbr.order) {
        return (x_amount * gc_abbr.order).toPrecision(3) + " " + gc_abbr.metric;
      }
    }
    return D_INTL_AMOUNT_LT1.format(x_amount);
  }
  if (x_amount >= 1e3) {
    if (b_shorter) {
      return D_INTL_AMOUNT_I1E3.format(x_amount / 1e3) + " k";
    }
    return D_INTL_AMOUNT_GT1E3.format(x_amount);
  }
  return D_INTL_AMOUNT_GT1.format(x_amount);
}
function format_fiat(x_amount, si_fiat = "usd", b_omit_sign = false, n_decimals = 2) {
  const s_formatted = x_amount < 1 ? D_INTL_USD_LT1.format(x_amount) : D_INTL_USD.format(x_amount);
  return b_omit_sign ? s_formatted.replace(/^[$]/, "") : s_formatted;
}
function abbreviate_addr(sa_addr) {
  return sa_addr.replace(/^(\w+1...).+(.{7})/, "$1[...]$2");
}
const coingecko_url = (a_coins, si_versus) => "https://api.coingecko.com/api/v3/simple/price?" + new URLSearchParams(ode({
  ids: a_coins.join(","),
  vs_currencies: si_versus,
  include_last_updated_at: "true"
}));
const CoinGecko = {
  async coinsVersus(a_coins, si_versus = "usd", xt_max_age = 5 * XT_MINUTES) {
    const a_apis = a_coins.map((si2) => WebApis.pathFor("GET", coingecko_url([si2], si_versus)));
    return await WebApis.open(async (ks_apis) => {
      const h_out = {};
      if (xt_max_age > 0) {
        const xt_cutoff = Date.now() - xt_max_age;
        let b_cache_valid = true;
        for (let i_coin = 0; i_coin < a_coins.length; i_coin++) {
          const g_api = ks_apis.at(a_apis[i_coin]);
          if (g_api && g_api.time > xt_cutoff) {
            const si_coin = a_coins[i_coin];
            h_out[si_coin] = g_api.response.cache[si_coin][si_versus];
          } else {
            b_cache_valid = false;
            break;
          }
        }
        if (b_cache_valid) {
          return h_out;
        }
      }
      const d_res = await fetch(coingecko_url(a_coins, si_versus));
      const h_response = await d_res.json();
      const h_cache = ks_apis.raw;
      const xt_now = Date.now();
      for (const [si_coin, g_coin] of ode(h_response)) {
        const g_cache = h_cache[si_coin] = h_cache[si_coin] || {};
        g_cache.response = g_coin;
        g_cache.time = xt_now;
        h_out[si_coin] = g_coin[si_versus];
      }
      return h_out;
    });
  }
};
const WebApis = create_store_class({
  store: SI_STORE_WEB_APIS,
  extension: "map",
  class: class WebApisI extends WritableStoreMap {
    static pathFor(si_method, p_api) {
      const s_hash = buffer_to_base64(sha256_sync$1(text_to_buffer(si_method + " " + p_api)));
      return `/cache.web-api/sha256.${s_hash}`;
    }
    static pathFrom(g_api) {
      return WebApisI.pathFor(g_api.method, g_api.path);
    }
  }
});
var AmountInput_svelte_svelte_type_style_lang = "";
const Agents = create_store_class({
  store: SI_STORE_AGENTS,
  extension: "map",
  class: class AgentsI extends WritableStoreMap {
    static pathForAgent(sa_addr, si_family = yw_family.get()) {
      return `/family.${si_family}/agent.${sa_addr.replace(/^\w+1/, "")}`;
    }
    static pathForContact(sa_addr, si_family = yw_family.get()) {
      return `${AgentsI.pathForAgent(sa_addr, si_family)}/as.contact`;
    }
    static pathFromContact(g_contact) {
      return AgentsI.pathForContact(g_contact.address, g_contact.family);
    }
    static async getContact(p_contact) {
      const ks_agents = await Agents.read();
      return ks_agents.at(p_contact);
    }
    *contacts(si_family = yw_family.get()) {
      const h_cache = this._w_cache;
      const s_agent_prefix = `/family.${si_family}/agent.`;
      for (const p_agent in h_cache) {
        if (!p_agent.startsWith(s_agent_prefix))
          continue;
        if (!p_agent.endsWith("/as.contact"))
          continue;
        yield [p_agent, h_cache[p_agent]];
      }
    }
    async putContact(g_res) {
      const p_res = AgentsI.pathFromContact(g_res);
      this._w_cache[p_res] = g_res;
      await this.save();
      return p_res;
    }
  }
});
var SX_ICON_COPY = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M3 13H5V11H3V13ZM3 17H5V15H3V17ZM5 21V19H3C3 20.1 3.89 21 5 21ZM3 9H5V7H3V9ZM15 21H17V19H15V21ZM19 3H9C7.89 3 7 3.9 7 5V15C7 16.1 7.89 17 9 17H19C20.1 17 21 16.1 21 15V5C21 3.9 20.1 3 19 3ZM19 15H9V5H19V15ZM11 21H13V19H11V21ZM7 21H9V19H7V21Z" />\n</svg>\n';
var Address_svelte_svelte_type_style_lang = "";
function create_if_block_2$1(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[0]);
      attr(span, "class", "prefix svelte-1f41ddv");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block$3(ctx) {
  let t0;
  let span;
  function select_block_type(ctx2, dirty) {
    if ("icon" === ctx2[7])
      return create_if_block_1$1;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      t0 = space();
      span = element("span");
      span.textContent = "Copied!";
      attr(span, "class", "copied svelte-1f41ddv");
      toggle_class(span, "confirm", ctx[3]);
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      ctx[11](span);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
      if (dirty & 8) {
        toggle_class(span, "confirm", ctx2[3]);
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(span);
      ctx[11](null);
    }
  };
}
function create_else_block(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Copy";
      attr(span, "class", "copy svelte-1f41ddv");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_1$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "copy icon svelte-1f41ddv");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_COPY;
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$3(ctx) {
  let span2;
  let t0;
  let span0;
  let t1;
  let t2;
  let span1;
  let t3;
  let t4;
  let mounted;
  let dispose;
  let if_block0 = ctx[0] && create_if_block_2$1(ctx);
  let if_block1 = ctx[6] && create_if_block$3(ctx);
  return {
    c() {
      span2 = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span0 = element("span");
      t1 = text(ctx[1]);
      t2 = space();
      span1 = element("span");
      t3 = text(ctx[1]);
      t4 = space();
      if (if_block1)
        if_block1.c();
      attr(span0, "class", "head svelte-1f41ddv");
      attr(span1, "class", "tail svelte-1f41ddv");
      toggle_class(span1, "display_none", !ctx[5]);
      attr(span2, "class", "address svelte-1f41ddv");
      toggle_class(span2, "copyable", ctx[6]);
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      if (if_block0)
        if_block0.m(span2, null);
      append(span2, t0);
      append(span2, span0);
      append(span0, t1);
      ctx[10](span0);
      append(span2, t2);
      append(span2, span1);
      append(span1, t3);
      append(span2, t4);
      if (if_block1)
        if_block1.m(span2, null);
      if (!mounted) {
        dispose = listen(span2, "click", ctx[6] ? ctx[12] : void 0);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[0]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$1(ctx2);
          if_block0.c();
          if_block0.m(span2, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & 2)
        set_data(t1, ctx2[1]);
      if (dirty & 2)
        set_data(t3, ctx2[1]);
      if (dirty & 32) {
        toggle_class(span1, "display_none", !ctx2[5]);
      }
      if (ctx2[6])
        if_block1.p(ctx2, dirty);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(span2);
      if (if_block0)
        if_block0.d();
      ctx[10](null);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let { prefix = "" } = $$props;
  let { address } = $$props;
  let { copyable = false } = $$props;
  const b_copyable = !!copyable;
  const s_copy_style = true === copyable ? "icon" : copyable || "";
  let dm_copied;
  let b_copy_confirm = false;
  async function copy() {
    try {
      await navigator.clipboard.writeText(address);
    } catch (e_write) {
      syserr({
        text: "Failed to write to the navigator clipboard",
        error: e_write
      });
      return;
    }
    $$invalidate(3, b_copy_confirm = true);
    setTimeout(
      () => {
        $$invalidate(3, b_copy_confirm = false);
      },
      800
    );
  }
  let dm_head;
  let b_head_overflows = false;
  onMount(() => {
    $$invalidate(5, b_head_overflows = dm_head.scrollWidth > dm_head.offsetWidth);
  });
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_head = $$value;
      $$invalidate(4, dm_head);
    });
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_copied = $$value;
      $$invalidate(2, dm_copied);
    });
  }
  const click_handler2 = () => copy();
  $$self.$$set = ($$props2) => {
    if ("prefix" in $$props2)
      $$invalidate(0, prefix = $$props2.prefix);
    if ("address" in $$props2)
      $$invalidate(1, address = $$props2.address);
    if ("copyable" in $$props2)
      $$invalidate(9, copyable = $$props2.copyable);
  };
  return [
    prefix,
    address,
    dm_copied,
    b_copy_confirm,
    dm_head,
    b_head_overflows,
    b_copyable,
    s_copy_style,
    copy,
    copyable,
    span0_binding,
    span_binding,
    click_handler2
  ];
}
class Address extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$3, safe_not_equal, { prefix: 0, address: 1, copyable: 9 });
  }
}
var InlineContactSelection_svelte_svelte_type_style_lang = "";
var RecipientSelectItem_svelte_svelte_type_style_lang = "";
var RecipientSelectSelection_svelte_svelte_type_style_lang = "";
var RecipientSelect_svelte_svelte_type_style_lang = "";
const Events = create_store_class({
  store: SI_STORE_EVENTS,
  extension: "array",
  class: class EventsI extends WritableStoreArray {
    static async filter(gc_filter) {
      const ks_events = await Events.read();
      return ks_events.filter(gc_filter);
    }
    static async insert(g_event) {
      return await Events.open((ks) => ks.insert(g_event));
    }
    *filter(gc_filter = {}) {
      for (const g_event of this._w_cache) {
        if (gc_filter.type && gc_filter.type !== g_event.type)
          continue;
        if (gc_filter.account && gc_filter.account !== g_event.data["account"])
          continue;
        if (gc_filter.owner && gc_filter.owner !== g_event.data["owner"])
          continue;
        yield g_event;
      }
    }
    async delete(g_delete) {
      const a_events = this._w_cache;
      const xt_delete = g_delete.time;
      const si_delete = JSON.stringify(g_delete);
      DELETION: {
        for (let i_event = 0, nl_events = a_events.length; i_event < nl_events; i_event++) {
          const g_test = a_events[i_event];
          if (xt_delete === g_test.time) {
            if (si_delete === JSON.stringify(g_test)) {
              a_events.splice(i_event, 1);
              break DELETION;
            }
          }
        }
        return a_events.length;
      }
      await this.save();
      return a_events.length;
    }
    async insert(g_event) {
      const xt_event = g_event.time;
      const a_events = this._w_cache;
      const si_event = JSON.stringify(g_event);
      INSERTION: {
        for (let i_event = 0, nl_events = a_events.length; i_event < nl_events; i_event++) {
          const g_test = a_events[i_event];
          if (xt_event > g_test.time) {
            a_events.splice(i_event, 0, g_event);
            break INSERTION;
          } else if (xt_event === g_test.time) {
            if (si_event === JSON.stringify(g_test)) {
              return a_events.length;
            }
          }
        }
        a_events.push(g_event);
      }
      await this.save();
      return a_events.length;
    }
  }
});
var SendNative_svelte_svelte_type_style_lang = "";
var Send_svelte_svelte_type_style_lang = "";
var qrcode = { exports: {} };
(function(module) {
  function QR8bitByte(data) {
    this.mode = QRMode.MODE_8BIT_BYTE;
    this.data = data;
    this.parsedData = [];
    for (var i2 = 0, l = this.data.length; i2 < l; i2++) {
      var byteArray = [];
      var code = this.data.charCodeAt(i2);
      if (code > 65536) {
        byteArray[0] = 240 | (code & 1835008) >>> 18;
        byteArray[1] = 128 | (code & 258048) >>> 12;
        byteArray[2] = 128 | (code & 4032) >>> 6;
        byteArray[3] = 128 | code & 63;
      } else if (code > 2048) {
        byteArray[0] = 224 | (code & 61440) >>> 12;
        byteArray[1] = 128 | (code & 4032) >>> 6;
        byteArray[2] = 128 | code & 63;
      } else if (code > 128) {
        byteArray[0] = 192 | (code & 1984) >>> 6;
        byteArray[1] = 128 | code & 63;
      } else {
        byteArray[0] = code;
      }
      this.parsedData.push(byteArray);
    }
    this.parsedData = Array.prototype.concat.apply([], this.parsedData);
    if (this.parsedData.length != this.data.length) {
      this.parsedData.unshift(191);
      this.parsedData.unshift(187);
      this.parsedData.unshift(239);
    }
  }
  QR8bitByte.prototype = {
    getLength: function(buffer) {
      return this.parsedData.length;
    },
    write: function(buffer) {
      for (var i2 = 0, l = this.parsedData.length; i2 < l; i2++) {
        buffer.put(this.parsedData[i2], 8);
      }
    }
  };
  function QRCodeModel(typeNumber, errorCorrectLevel) {
    this.typeNumber = typeNumber;
    this.errorCorrectLevel = errorCorrectLevel;
    this.modules = null;
    this.moduleCount = 0;
    this.dataCache = null;
    this.dataList = [];
  }
  QRCodeModel.prototype = { addData: function(data) {
    var newData = new QR8bitByte(data);
    this.dataList.push(newData);
    this.dataCache = null;
  }, isDark: function(row, col) {
    if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
      throw new Error(row + "," + col);
    }
    return this.modules[row][col];
  }, getModuleCount: function() {
    return this.moduleCount;
  }, make: function() {
    this.makeImpl(false, this.getBestMaskPattern());
  }, makeImpl: function(test, maskPattern) {
    this.moduleCount = this.typeNumber * 4 + 17;
    this.modules = new Array(this.moduleCount);
    for (var row = 0; row < this.moduleCount; row++) {
      this.modules[row] = new Array(this.moduleCount);
      for (var col = 0; col < this.moduleCount; col++) {
        this.modules[row][col] = null;
      }
    }
    this.setupPositionProbePattern(0, 0);
    this.setupPositionProbePattern(this.moduleCount - 7, 0);
    this.setupPositionProbePattern(0, this.moduleCount - 7);
    this.setupPositionAdjustPattern();
    this.setupTimingPattern();
    this.setupTypeInfo(test, maskPattern);
    if (this.typeNumber >= 7) {
      this.setupTypeNumber(test);
    }
    if (this.dataCache == null) {
      this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
    }
    this.mapData(this.dataCache, maskPattern);
  }, setupPositionProbePattern: function(row, col) {
    for (var r = -1; r <= 7; r++) {
      if (row + r <= -1 || this.moduleCount <= row + r)
        continue;
      for (var c = -1; c <= 7; c++) {
        if (col + c <= -1 || this.moduleCount <= col + c)
          continue;
        if (0 <= r && r <= 6 && (c == 0 || c == 6) || 0 <= c && c <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {
          this.modules[row + r][col + c] = true;
        } else {
          this.modules[row + r][col + c] = false;
        }
      }
    }
  }, getBestMaskPattern: function() {
    var minLostPoint = 0;
    var pattern = 0;
    for (var i2 = 0; i2 < 8; i2++) {
      this.makeImpl(true, i2);
      var lostPoint = QRUtil.getLostPoint(this);
      if (i2 == 0 || minLostPoint > lostPoint) {
        minLostPoint = lostPoint;
        pattern = i2;
      }
    }
    return pattern;
  }, createMovieClip: function(target_mc, instance_name, depth) {
    var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
    var cs2 = 1;
    this.make();
    for (var row = 0; row < this.modules.length; row++) {
      var y = row * cs2;
      for (var col = 0; col < this.modules[row].length; col++) {
        var x = col * cs2;
        var dark = this.modules[row][col];
        if (dark) {
          qr_mc.beginFill(0, 100);
          qr_mc.moveTo(x, y);
          qr_mc.lineTo(x + cs2, y);
          qr_mc.lineTo(x + cs2, y + cs2);
          qr_mc.lineTo(x, y + cs2);
          qr_mc.endFill();
        }
      }
    }
    return qr_mc;
  }, setupTimingPattern: function() {
    for (var r = 8; r < this.moduleCount - 8; r++) {
      if (this.modules[r][6] != null) {
        continue;
      }
      this.modules[r][6] = r % 2 == 0;
    }
    for (var c = 8; c < this.moduleCount - 8; c++) {
      if (this.modules[6][c] != null) {
        continue;
      }
      this.modules[6][c] = c % 2 == 0;
    }
  }, setupPositionAdjustPattern: function() {
    var pos = QRUtil.getPatternPosition(this.typeNumber);
    for (var i2 = 0; i2 < pos.length; i2++) {
      for (var j = 0; j < pos.length; j++) {
        var row = pos[i2];
        var col = pos[j];
        if (this.modules[row][col] != null) {
          continue;
        }
        for (var r = -2; r <= 2; r++) {
          for (var c = -2; c <= 2; c++) {
            if (r == -2 || r == 2 || c == -2 || c == 2 || r == 0 && c == 0) {
              this.modules[row + r][col + c] = true;
            } else {
              this.modules[row + r][col + c] = false;
            }
          }
        }
      }
    }
  }, setupTypeNumber: function(test) {
    var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
    for (var i2 = 0; i2 < 18; i2++) {
      var mod2 = !test && (bits >> i2 & 1) == 1;
      this.modules[Math.floor(i2 / 3)][i2 % 3 + this.moduleCount - 8 - 3] = mod2;
    }
    for (var i2 = 0; i2 < 18; i2++) {
      var mod2 = !test && (bits >> i2 & 1) == 1;
      this.modules[i2 % 3 + this.moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod2;
    }
  }, setupTypeInfo: function(test, maskPattern) {
    var data = this.errorCorrectLevel << 3 | maskPattern;
    var bits = QRUtil.getBCHTypeInfo(data);
    for (var i2 = 0; i2 < 15; i2++) {
      var mod2 = !test && (bits >> i2 & 1) == 1;
      if (i2 < 6) {
        this.modules[i2][8] = mod2;
      } else if (i2 < 8) {
        this.modules[i2 + 1][8] = mod2;
      } else {
        this.modules[this.moduleCount - 15 + i2][8] = mod2;
      }
    }
    for (var i2 = 0; i2 < 15; i2++) {
      var mod2 = !test && (bits >> i2 & 1) == 1;
      if (i2 < 8) {
        this.modules[8][this.moduleCount - i2 - 1] = mod2;
      } else if (i2 < 9) {
        this.modules[8][15 - i2 - 1 + 1] = mod2;
      } else {
        this.modules[8][15 - i2 - 1] = mod2;
      }
    }
    this.modules[this.moduleCount - 8][8] = !test;
  }, mapData: function(data, maskPattern) {
    var inc = -1;
    var row = this.moduleCount - 1;
    var bitIndex = 7;
    var byteIndex = 0;
    for (var col = this.moduleCount - 1; col > 0; col -= 2) {
      if (col == 6)
        col--;
      while (true) {
        for (var c = 0; c < 2; c++) {
          if (this.modules[row][col - c] == null) {
            var dark = false;
            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) == 1;
            }
            var mask = QRUtil.getMask(maskPattern, row, col - c);
            if (mask) {
              dark = !dark;
            }
            this.modules[row][col - c] = dark;
            bitIndex--;
            if (bitIndex == -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc;
        if (row < 0 || this.moduleCount <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  } };
  QRCodeModel.PAD0 = 236;
  QRCodeModel.PAD1 = 17;
  QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
    var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
    var buffer = new QRBitBuffer();
    for (var i2 = 0; i2 < dataList.length; i2++) {
      var data = dataList[i2];
      buffer.put(data.mode, 4);
      buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
      data.write(buffer);
    }
    var totalDataCount = 0;
    for (var i2 = 0; i2 < rsBlocks.length; i2++) {
      totalDataCount += rsBlocks[i2].dataCount;
    }
    if (buffer.getLengthInBits() > totalDataCount * 8) {
      throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
    }
    if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
      buffer.put(0, 4);
    }
    while (buffer.getLengthInBits() % 8 != 0) {
      buffer.putBit(false);
    }
    while (true) {
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCodeModel.PAD0, 8);
      if (buffer.getLengthInBits() >= totalDataCount * 8) {
        break;
      }
      buffer.put(QRCodeModel.PAD1, 8);
    }
    return QRCodeModel.createBytes(buffer, rsBlocks);
  };
  QRCodeModel.createBytes = function(buffer, rsBlocks) {
    var offset = 0;
    var maxDcCount = 0;
    var maxEcCount = 0;
    var dcdata = new Array(rsBlocks.length);
    var ecdata = new Array(rsBlocks.length);
    for (var r = 0; r < rsBlocks.length; r++) {
      var dcCount = rsBlocks[r].dataCount;
      var ecCount = rsBlocks[r].totalCount - dcCount;
      maxDcCount = Math.max(maxDcCount, dcCount);
      maxEcCount = Math.max(maxEcCount, ecCount);
      dcdata[r] = new Array(dcCount);
      for (var i2 = 0; i2 < dcdata[r].length; i2++) {
        dcdata[r][i2] = 255 & buffer.buffer[i2 + offset];
      }
      offset += dcCount;
      var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
      var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
      var modPoly = rawPoly.mod(rsPoly);
      ecdata[r] = new Array(rsPoly.getLength() - 1);
      for (var i2 = 0; i2 < ecdata[r].length; i2++) {
        var modIndex = i2 + modPoly.getLength() - ecdata[r].length;
        ecdata[r][i2] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
      }
    }
    var totalCodeCount = 0;
    for (var i2 = 0; i2 < rsBlocks.length; i2++) {
      totalCodeCount += rsBlocks[i2].totalCount;
    }
    var data = new Array(totalCodeCount);
    var index = 0;
    for (var i2 = 0; i2 < maxDcCount; i2++) {
      for (var r = 0; r < rsBlocks.length; r++) {
        if (i2 < dcdata[r].length) {
          data[index++] = dcdata[r][i2];
        }
      }
    }
    for (var i2 = 0; i2 < maxEcCount; i2++) {
      for (var r = 0; r < rsBlocks.length; r++) {
        if (i2 < ecdata[r].length) {
          data[index++] = ecdata[r][i2];
        }
      }
    }
    return data;
  };
  var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
  var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
  var QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
  var QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, getBCHTypeInfo: function(data) {
    var d = data << 10;
    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
      d ^= QRUtil.G15 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15);
    }
    return (data << 10 | d) ^ QRUtil.G15_MASK;
  }, getBCHTypeNumber: function(data) {
    var d = data << 12;
    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
      d ^= QRUtil.G18 << QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18);
    }
    return data << 12 | d;
  }, getBCHDigit: function(data) {
    var digit = 0;
    while (data != 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  }, getPatternPosition: function(typeNumber) {
    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
  }, getMask: function(maskPattern, i2, j) {
    switch (maskPattern) {
      case QRMaskPattern.PATTERN000:
        return (i2 + j) % 2 == 0;
      case QRMaskPattern.PATTERN001:
        return i2 % 2 == 0;
      case QRMaskPattern.PATTERN010:
        return j % 3 == 0;
      case QRMaskPattern.PATTERN011:
        return (i2 + j) % 3 == 0;
      case QRMaskPattern.PATTERN100:
        return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 == 0;
      case QRMaskPattern.PATTERN101:
        return i2 * j % 2 + i2 * j % 3 == 0;
      case QRMaskPattern.PATTERN110:
        return (i2 * j % 2 + i2 * j % 3) % 2 == 0;
      case QRMaskPattern.PATTERN111:
        return (i2 * j % 3 + (i2 + j) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern);
    }
  }, getErrorCorrectPolynomial: function(errorCorrectLength) {
    var a = new QRPolynomial([1], 0);
    for (var i2 = 0; i2 < errorCorrectLength; i2++) {
      a = a.multiply(new QRPolynomial([1, QRMath.gexp(i2)], 0));
    }
    return a;
  }, getLengthInBits: function(mode, type) {
    if (1 <= type && type < 10) {
      switch (mode) {
        case QRMode.MODE_NUMBER:
          return 10;
        case QRMode.MODE_ALPHA_NUM:
          return 9;
        case QRMode.MODE_8BIT_BYTE:
          return 8;
        case QRMode.MODE_KANJI:
          return 8;
        default:
          throw new Error("mode:" + mode);
      }
    } else if (type < 27) {
      switch (mode) {
        case QRMode.MODE_NUMBER:
          return 12;
        case QRMode.MODE_ALPHA_NUM:
          return 11;
        case QRMode.MODE_8BIT_BYTE:
          return 16;
        case QRMode.MODE_KANJI:
          return 10;
        default:
          throw new Error("mode:" + mode);
      }
    } else if (type < 41) {
      switch (mode) {
        case QRMode.MODE_NUMBER:
          return 14;
        case QRMode.MODE_ALPHA_NUM:
          return 13;
        case QRMode.MODE_8BIT_BYTE:
          return 16;
        case QRMode.MODE_KANJI:
          return 12;
        default:
          throw new Error("mode:" + mode);
      }
    } else {
      throw new Error("type:" + type);
    }
  }, getLostPoint: function(qrCode) {
    var moduleCount = qrCode.getModuleCount();
    var lostPoint = 0;
    for (var row = 0; row < moduleCount; row++) {
      for (var col = 0; col < moduleCount; col++) {
        var sameCount = 0;
        var dark = qrCode.isDark(row, col);
        for (var r = -1; r <= 1; r++) {
          if (row + r < 0 || moduleCount <= row + r) {
            continue;
          }
          for (var c = -1; c <= 1; c++) {
            if (col + c < 0 || moduleCount <= col + c) {
              continue;
            }
            if (r == 0 && c == 0) {
              continue;
            }
            if (dark == qrCode.isDark(row + r, col + c)) {
              sameCount++;
            }
          }
        }
        if (sameCount > 5) {
          lostPoint += 3 + sameCount - 5;
        }
      }
    }
    for (var row = 0; row < moduleCount - 1; row++) {
      for (var col = 0; col < moduleCount - 1; col++) {
        var count = 0;
        if (qrCode.isDark(row, col))
          count++;
        if (qrCode.isDark(row + 1, col))
          count++;
        if (qrCode.isDark(row, col + 1))
          count++;
        if (qrCode.isDark(row + 1, col + 1))
          count++;
        if (count == 0 || count == 4) {
          lostPoint += 3;
        }
      }
    }
    for (var row = 0; row < moduleCount; row++) {
      for (var col = 0; col < moduleCount - 6; col++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
          lostPoint += 40;
        }
      }
    }
    for (var col = 0; col < moduleCount; col++) {
      for (var row = 0; row < moduleCount - 6; row++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
          lostPoint += 40;
        }
      }
    }
    var darkCount = 0;
    for (var col = 0; col < moduleCount; col++) {
      for (var row = 0; row < moduleCount; row++) {
        if (qrCode.isDark(row, col)) {
          darkCount++;
        }
      }
    }
    var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
    lostPoint += ratio * 10;
    return lostPoint;
  } };
  var QRMath = { glog: function(n) {
    if (n < 1) {
      throw new Error("glog(" + n + ")");
    }
    return QRMath.LOG_TABLE[n];
  }, gexp: function(n) {
    while (n < 0) {
      n += 255;
    }
    while (n >= 256) {
      n -= 255;
    }
    return QRMath.EXP_TABLE[n];
  }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
  for (var i = 0; i < 8; i++) {
    QRMath.EXP_TABLE[i] = 1 << i;
  }
  for (var i = 8; i < 256; i++) {
    QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
  }
  for (var i = 0; i < 255; i++) {
    QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
  }
  function QRPolynomial(num, shift) {
    if (num.length == void 0) {
      throw new Error(num.length + "/" + shift);
    }
    var offset = 0;
    while (offset < num.length && num[offset] == 0) {
      offset++;
    }
    this.num = new Array(num.length - offset + shift);
    for (var i2 = 0; i2 < num.length - offset; i2++) {
      this.num[i2] = num[i2 + offset];
    }
  }
  QRPolynomial.prototype = { get: function(index) {
    return this.num[index];
  }, getLength: function() {
    return this.num.length;
  }, multiply: function(e) {
    var num = new Array(this.getLength() + e.getLength() - 1);
    for (var i2 = 0; i2 < this.getLength(); i2++) {
      for (var j = 0; j < e.getLength(); j++) {
        num[i2 + j] ^= QRMath.gexp(QRMath.glog(this.get(i2)) + QRMath.glog(e.get(j)));
      }
    }
    return new QRPolynomial(num, 0);
  }, mod: function(e) {
    if (this.getLength() - e.getLength() < 0) {
      return this;
    }
    var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
    var num = new Array(this.getLength());
    for (var i2 = 0; i2 < this.getLength(); i2++) {
      num[i2] = this.get(i2);
    }
    for (var i2 = 0; i2 < e.getLength(); i2++) {
      num[i2] ^= QRMath.gexp(QRMath.glog(e.get(i2)) + ratio);
    }
    return new QRPolynomial(num, 0).mod(e);
  } };
  function QRRSBlock(totalCount, dataCount) {
    this.totalCount = totalCount;
    this.dataCount = dataCount;
  }
  QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
  QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
    var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
    if (rsBlock == void 0) {
      throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
    }
    var length2 = rsBlock.length / 3;
    var list = [];
    for (var i2 = 0; i2 < length2; i2++) {
      var count = rsBlock[i2 * 3 + 0];
      var totalCount = rsBlock[i2 * 3 + 1];
      var dataCount = rsBlock[i2 * 3 + 2];
      for (var j = 0; j < count; j++) {
        list.push(new QRRSBlock(totalCount, dataCount));
      }
    }
    return list;
  };
  QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
    switch (errorCorrectLevel) {
      case QRErrorCorrectLevel.L:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectLevel.M:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectLevel.Q:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectLevel.H:
        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  function QRBitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  QRBitBuffer.prototype = { get: function(index) {
    var bufIndex = Math.floor(index / 8);
    return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
  }, put: function(num, length2) {
    for (var i2 = 0; i2 < length2; i2++) {
      this.putBit((num >>> length2 - i2 - 1 & 1) == 1);
    }
  }, getLengthInBits: function() {
    return this.length;
  }, putBit: function(bit) {
    var bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  } };
  var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
  function QRCode2(options) {
    this.options = {
      padding: 4,
      width: 256,
      height: 256,
      typeNumber: 4,
      color: "#000000",
      background: "#ffffff",
      ecl: "M"
    };
    if (typeof options === "string") {
      options = {
        content: options
      };
    }
    if (options) {
      for (var i2 in options) {
        this.options[i2] = options[i2];
      }
    }
    if (typeof this.options.content !== "string") {
      throw new Error("Expected 'content' as string!");
    }
    if (this.options.content.length === 0) {
      throw new Error("Expected 'content' to be non-empty!");
    }
    if (!(this.options.padding >= 0)) {
      throw new Error("Expected 'padding' value to be non-negative!");
    }
    if (!(this.options.width > 0) || !(this.options.height > 0)) {
      throw new Error("Expected 'width' or 'height' value to be higher than zero!");
    }
    function _getErrorCorrectLevel(ecl2) {
      switch (ecl2) {
        case "L":
          return QRErrorCorrectLevel.L;
        case "M":
          return QRErrorCorrectLevel.M;
        case "Q":
          return QRErrorCorrectLevel.Q;
        case "H":
          return QRErrorCorrectLevel.H;
        default:
          throw new Error("Unknwon error correction level: " + ecl2);
      }
    }
    function _getTypeNumber(content2, ecl2) {
      var length2 = _getUTF8Length(content2);
      var type2 = 1;
      var limit = 0;
      for (var i3 = 0, len = QRCodeLimitLength.length; i3 <= len; i3++) {
        var table = QRCodeLimitLength[i3];
        if (!table) {
          throw new Error("Content too long: expected " + limit + " but got " + length2);
        }
        switch (ecl2) {
          case "L":
            limit = table[0];
            break;
          case "M":
            limit = table[1];
            break;
          case "Q":
            limit = table[2];
            break;
          case "H":
            limit = table[3];
            break;
          default:
            throw new Error("Unknwon error correction level: " + ecl2);
        }
        if (length2 <= limit) {
          break;
        }
        type2++;
      }
      if (type2 > QRCodeLimitLength.length) {
        throw new Error("Content too long");
      }
      return type2;
    }
    function _getUTF8Length(content2) {
      var result = encodeURI(content2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
      return result.length + (result.length != content2 ? 3 : 0);
    }
    var content = this.options.content;
    var type = _getTypeNumber(content, this.options.ecl);
    var ecl = _getErrorCorrectLevel(this.options.ecl);
    this.qrcode = new QRCodeModel(type, ecl);
    this.qrcode.addData(content);
    this.qrcode.make();
  }
  QRCode2.prototype.svg = function(opt) {
    var options = this.options || {};
    var modules = this.qrcode.modules;
    if (typeof opt == "undefined") {
      opt = { container: options.container || "svg" };
    }
    var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
    var indent = pretty ? "  " : "";
    var EOL = pretty ? "\r\n" : "";
    var width = options.width;
    var height = options.height;
    var length2 = modules.length;
    var xsize = width / (length2 + 2 * options.padding);
    var ysize = height / (length2 + 2 * options.padding);
    var join = typeof options.join != "undefined" ? !!options.join : false;
    var swap = typeof options.swap != "undefined" ? !!options.swap : false;
    var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
    var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
    var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : "";
    var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;
    var modrect = "";
    var pathdata = "";
    for (var y = 0; y < length2; y++) {
      for (var x = 0; x < length2; x++) {
        var module2 = modules[x][y];
        if (module2) {
          var px = x * xsize + options.padding * xsize;
          var py = y * ysize + options.padding * ysize;
          if (swap) {
            var t = px;
            px = py;
            py = t;
          }
          if (join) {
            var w = xsize + px;
            var h = ysize + py;
            px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
            py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
            w = Number.isInteger(w) ? Number(w) : w.toFixed(2);
            h = Number.isInteger(h) ? Number(h) : h.toFixed(2);
            pathdata += "M" + px + "," + py + " V" + h + " H" + w + " V" + py + " H" + px + " Z ";
          } else if (predefined) {
            modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
          } else {
            modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
          }
        }
      }
    }
    if (join) {
      modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
    }
    var svg = "";
    switch (opt.container) {
      case "svg":
        if (xmlDeclaration) {
          svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
        }
        svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
        svg += defs + bgrect + modrect;
        svg += "</svg>";
        break;
      case "svg-viewbox":
        if (xmlDeclaration) {
          svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
        }
        svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL;
        svg += defs + bgrect + modrect;
        svg += "</svg>";
        break;
      case "g":
        svg += '<g width="' + width + '" height="' + height + '">' + EOL;
        svg += defs + bgrect + modrect;
        svg += "</g>";
        break;
      default:
        svg += (defs + bgrect + modrect).replace(/^\s+/, "");
        break;
    }
    return svg;
  };
  QRCode2.prototype.save = function(file, callback) {
    var data = this.svg();
    if (typeof callback != "function") {
      callback = function(error, result) {
      };
    }
    try {
      var fs = require("fs");
      fs.writeFile(file, data, callback);
    } catch (e) {
      callback(e);
    }
  };
  {
    module.exports = QRCode2;
  }
})(qrcode);
var QRCode = qrcode.exports;
var Info_svelte_svelte_type_style_lang = "";
function create_if_block$2(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "icon svelte-1ytw09y");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_COPY;
    },
    p: noop$1,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$2(ctx) {
  let div;
  let span;
  let t;
  let current;
  const default_slot_template = ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  let if_block = ctx[2] && create_if_block$2();
  return {
    c() {
      div = element("div");
      span = element("span");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(span, "id", ctx[0]);
      attr(span, "class", "info-value svelte-1ytw09y");
      attr(div, "class", "info svelte-1ytw09y");
      toggle_class(div, "copyable", ctx[2]);
      toggle_class(div, "center", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
      if (ctx2[2])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { key } = $$props;
  const si_key = key;
  let { address = false } = $$props;
  const b_address = address;
  let { center = b_address } = $$props;
  const b_center = center;
  let { copyable = false } = $$props;
  const b_copyable = copyable;
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(3, key = $$props2.key);
    if ("address" in $$props2)
      $$invalidate(4, address = $$props2.address);
    if ("center" in $$props2)
      $$invalidate(5, center = $$props2.center);
    if ("copyable" in $$props2)
      $$invalidate(6, copyable = $$props2.copyable);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  return [si_key, b_center, b_copyable, key, address, center, copyable, $$scope, slots];
}
class Info extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$2, safe_not_equal, {
      key: 3,
      address: 4,
      center: 5,
      copyable: 6
    });
  }
}
var PopupReceive_svelte_svelte_type_style_lang = "";
function create_catch_block_1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block_1(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding(value) {
    ctx[13](value);
  }
  let starselect_props = {
    id: "chain-select",
    pfpMap: ctx[6],
    placeholder: "Select chain",
    items: ctx[23]
  };
  if (ctx[2] !== void 0) {
    starselect_props.value = ctx[2];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (dirty & 64)
        starselect_changes.pfpMap = ctx2[6];
      if (!updating_value && dirty & 4) {
        updating_value = true;
        starselect_changes.value = ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block_1(ctx) {
  let t;
  return {
    c() {
      t = text("Loading chains...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 23,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block$1(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block$1(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding_1(value) {
    ctx[14](value);
  }
  let starselect_props = {
    id: "account-select",
    pfpMap: ctx[5],
    placeholder: "Select account",
    secondaryClass: "balance",
    items: ctx[22]
  };
  if (ctx[0] !== void 0) {
    starselect_props.value = ctx[0];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding_1));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (dirty & 32)
        starselect_changes.pfpMap = ctx2[5];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        starselect_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block$1(ctx) {
  let t;
  return {
    c() {
      t = text("Loading Accounts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    value: 22,
    blocks: [, , ,]
  };
  handle_promise(ctx[8](), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block$1(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: Chains.addressFor(ctx[1]?.pubkey, ctx[3]) || ""
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 10)
        address_changes.address = Chains.addressFor(ctx2[1]?.pubkey, ctx2[3]) || "";
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[1] && ctx[3] && create_if_block$1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1] && ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 10) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$1(ctx) {
  let h3;
  let t1;
  let close;
  let div;
  let t2;
  let field0;
  let t3;
  let field1;
  let t4;
  let info;
  let t5;
  let div0;
  let t6;
  let div1;
  let current;
  close = new Close({ props: { absolute: true } });
  close.$on("click", ctx[12]);
  field0 = new Field({
    props: {
      short: true,
      key: "chain-select",
      name: "Chain",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      short: true,
      key: "account-select",
      name: "Account",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  info = new Info({
    props: {
      address: true,
      key: "receive-address",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Receive";
      t1 = space();
      div = element("div");
      create_component(close.$$.fragment);
      t2 = space();
      create_component(field0.$$.fragment);
      t3 = space();
      create_component(field1.$$.fragment);
      t4 = space();
      create_component(info.$$.fragment);
      t5 = space();
      div0 = element("div");
      t6 = space();
      div1 = element("div");
      div1.textContent = "Scan QR code to receive to this address";
      set_style(div, "display", "contents");
      set_style(div, "--margin", "5px");
      attr(div0, "class", "qr-code svelte-rmdw72");
      attr(div1, "class", "info svelte-rmdw72");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      mount_component(close, div, null);
      insert(target, t2, anchor);
      mount_component(field0, target, anchor);
      insert(target, t3, anchor);
      mount_component(field1, target, anchor);
      insert(target, t4, anchor);
      mount_component(info, target, anchor);
      insert(target, t5, anchor);
      insert(target, div0, anchor);
      ctx[15](div0);
      insert(target, t6, anchor);
      insert(target, div1, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const field0_changes = {};
      if (dirty & 16777284) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 16777249) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const info_changes = {};
      if (dirty & 16777226) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(close.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      destroy_component(close, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t3);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t4);
      destroy_component(info, detaching);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div0);
      ctx[15](null);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(div1);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let p_account_selected;
  let p_chain_selected;
  let $yw_account_ref;
  let $yw_context_popup;
  let $yw_chain_ref;
  let $yw_popup;
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(16, $yw_account_ref = $$value));
  component_subscribe($$self, yw_context_popup, ($$value) => $$invalidate(17, $yw_context_popup = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(18, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_popup, ($$value) => $$invalidate(7, $yw_popup = $$value));
  let g_option_selected_account = { value: $yw_account_ref };
  let g_account_selected;
  const account_to_option = (p_account, g_account) => ({
    object: g_account,
    value: p_account,
    primary: g_account.name,
    secondary: g_account.extra?.total_fiat_cache || "(?)"
  });
  let h_pfps_account = {};
  async function load_account_options() {
    const ks_accounts = await Accounts.read();
    $$invalidate(5, h_pfps_account = ofe(await Promise.all(ode(ks_accounts.raw).map(([_, g_account]) => new Promise((fk_resolve) => {
      const dm_dummy = dd("span");
      const yc_pfp = new PfpDisplay({
        target: dm_dummy,
        props: {
          dim: 28,
          genStyle: "font-size: 18px;",
          resource: g_account,
          settle() {
            const dm_pfp = dm_dummy.firstChild?.cloneNode(true);
            yc_pfp.$destroy();
            fk_resolve([g_account.pfp, dm_pfp]);
          }
        }
      });
    })))));
    return oderac(ks_accounts.raw, account_to_option);
  }
  let g_option_selected_chain = { value: $yw_chain_ref };
  let g_chain_selected;
  const chain_to_option = (p_chain, g_chain) => ({
    object: g_chain,
    value: p_chain,
    primary: g_chain.name,
    secondary: g_chain.id,
    pfp: g_chain.pfp
  });
  let h_pfps_chain = {};
  async function load_chain_options() {
    const ks_chains = await Chains.read();
    $$invalidate(6, h_pfps_chain = await load_pfps2(ks_chains.raw));
    return oderac(ks_chains.raw, chain_to_option);
  }
  if (!$yw_context_popup?.account) {
    set_store_value(yw_context_popup, $yw_context_popup = { account: $yw_account_ref }, $yw_context_popup);
  }
  let dm_qr;
  async function load_pfps2(h_resources) {
    return ofe(await Promise.all(ode(h_resources).map(([_, g_resource]) => new Promise((fk_resolve) => {
      const dm_dummy = dd("span");
      const yc_pfp = new PfpDisplay({
        target: dm_dummy,
        props: {
          dim: 28,
          genStyle: "font-size: 18px;",
          resource: g_resource,
          settle() {
            const dm_pfp = dm_dummy.firstChild?.cloneNode(true);
            yc_pfp.$destroy();
            fk_resolve([g_resource.pfp, dm_pfp]);
          }
        }
      });
    }))));
  }
  const click_handler2 = () => set_store_value(yw_popup, $yw_popup = null, $yw_popup);
  function starselect_value_binding(value) {
    g_option_selected_chain = value;
    $$invalidate(2, g_option_selected_chain);
  }
  function starselect_value_binding_1(value) {
    g_option_selected_account = value;
    $$invalidate(0, g_option_selected_account);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_qr = $$value;
      $$invalidate(4, dm_qr), $$invalidate(1, g_account_selected), $$invalidate(3, g_chain_selected), $$invalidate(11, p_account_selected), $$invalidate(10, p_chain_selected), $$invalidate(0, g_option_selected_account), $$invalidate(2, g_option_selected_chain);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(11, p_account_selected = g_option_selected_account.value);
    }
    if ($$self.$$.dirty & 2048) {
      {
        if (p_account_selected) {
          void Accounts.read().then((ks_accounts) => {
            $$invalidate(1, g_account_selected = ks_accounts.at(p_account_selected));
          });
        }
      }
    }
    if ($$self.$$.dirty & 4) {
      $$invalidate(10, p_chain_selected = g_option_selected_chain.value);
    }
    if ($$self.$$.dirty & 1024) {
      {
        if (p_chain_selected) {
          void Chains.read().then((ks_chains) => {
            $$invalidate(3, g_chain_selected = ks_chains.at(p_chain_selected));
          });
        }
      }
    }
    if ($$self.$$.dirty & 26) {
      {
        if (dm_qr && g_account_selected && g_chain_selected) {
          const y_qrcode = new QRCode({
            content: `starshell:${Chains.addressFor(g_account_selected.pubkey, g_chain_selected) || ""}`,
            width: 240,
            height: 240,
            padding: 3,
            ecl: "H",
            join: true
          }).svg();
          $$invalidate(4, dm_qr.innerHTML = y_qrcode, dm_qr);
        }
      }
    }
  };
  return [
    g_option_selected_account,
    g_account_selected,
    g_option_selected_chain,
    g_chain_selected,
    dm_qr,
    h_pfps_account,
    h_pfps_chain,
    $yw_popup,
    load_account_options,
    load_chain_options,
    p_chain_selected,
    p_account_selected,
    click_handler2,
    starselect_value_binding,
    starselect_value_binding_1,
    div0_binding
  ];
}
class PopupReceive extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {});
  }
}
var Gap_svelte_svelte_type_style_lang = "";
var InlinePills_svelte_svelte_type_style_lang = "";
var TokensAdd_svelte_svelte_type_style_lang = "";
var HoldingView_svelte_svelte_type_style_lang = "";
var HoldingsHome_svelte_svelte_type_style_lang = "";
var AccountCreate_svelte_svelte_type_style_lang = "";
var AccountsHome_svelte_svelte_type_style_lang = "";
var Tab_svelte_svelte_type_style_lang = "";
var TabList_svelte_svelte_type_style_lang = "";
var TabPanel_svelte_svelte_type_style_lang = "";
var DeadEnd_svelte_svelte_type_style_lang = "";
var IconEditor_svelte_svelte_type_style_lang = "";
var ContactEdit_svelte_svelte_type_style_lang = "";
var ContactList_svelte_svelte_type_style_lang = "";
var ContactsHome_svelte_svelte_type_style_lang = "";
const Apps = create_store_class({
  store: SI_STORE_APPS,
  class: class AppsI extends WritableStoreMap {
    static pathFor(s_host, s_scheme) {
      return `/scheme.${s_scheme}/host.${s_host.replace(/:/g, "+")}`;
    }
    static pathFrom(g_app) {
      return AppsI.pathFor(g_app.host, g_app.scheme);
    }
    static get(s_host, s_scheme) {
      return Apps.open((ks_apps) => ks_apps.get(s_host, s_scheme));
    }
    get(s_host, s_scheme) {
      const p_app = AppsI.pathFor(s_host, s_scheme);
      return this._w_cache[p_app] ?? null;
    }
    async put(g_app) {
      const p_app = AppsI.pathFor(g_app.host, g_app.scheme);
      this._w_cache[p_app] = g_app;
      await this.save();
    }
  }
});
var NetworkView_svelte_svelte_type_style_lang = "";
var defaultLocale$1 = "en";
var localesData$1 = {};
var lowercaseLocaleLookup = {};
function getDefaultLocale() {
  return defaultLocale$1;
}
function setDefaultLocale(locale) {
  defaultLocale$1 = locale;
}
function getLocaleData$1(locale) {
  return localesData$1[locale];
}
function addLocaleData$1(localeData) {
  if (!localeData) {
    throw new Error("No locale data passed");
  }
  localesData$1[localeData.locale] = localeData;
  lowercaseLocaleLookup[localeData.locale.toLowerCase()] = localeData.locale;
}
function resolveLocale$1(locale) {
  if (localesData$1[locale]) {
    return locale;
  }
  if (lowercaseLocaleLookup[locale.toLowerCase()]) {
    return lowercaseLocaleLookup[locale.toLowerCase()];
  }
}
function resolveLocale(locale) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var localeMatcher = options.localeMatcher || "lookup";
  switch (localeMatcher) {
    case "lookup":
      return resolveLocaleLookup(locale);
    case "best fit":
      return resolveLocaleLookup(locale);
    default:
      throw new RangeError('Invalid "localeMatcher" option: '.concat(localeMatcher));
  }
}
function resolveLocaleLookup(locale) {
  var resolvedLocale = resolveLocale$1(locale);
  if (resolvedLocale) {
    return resolvedLocale;
  }
  var parts = locale.split("-");
  while (locale.length > 1) {
    parts.pop();
    locale = parts.join("-");
    var _resolvedLocale = resolveLocale$1(locale);
    if (_resolvedLocale) {
      return _resolvedLocale;
    }
  }
}
var $ = {
  af: function af(n) {
    return n == 1 ? "one" : "other";
  },
  am: function am(n) {
    return n >= 0 && n <= 1 ? "one" : "other";
  },
  ar: function ar(n) {
    var s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
    return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 99 ? "many" : "other";
  },
  ast: function ast(n) {
    var s = String(n).split("."), v0 = !s[1];
    return n == 1 && v0 ? "one" : "other";
  },
  be: function be(n) {
    var s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
    return n10 == 1 && n100 != 11 ? "one" : n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) ? "few" : t0 && n10 == 0 || n10 >= 5 && n10 <= 9 || n100 >= 11 && n100 <= 14 ? "many" : "other";
  },
  br: function br(n) {
    var s = String(n).split("."), t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), n1000000 = t0 && s[0].slice(-6);
    return n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91 ? "one" : n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92 ? "two" : (n10 == 3 || n10 == 4 || n10 == 9) && (n100 < 10 || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90 || n100 > 99) ? "few" : n != 0 && t0 && n1000000 == 0 ? "many" : "other";
  },
  bs: function bs(n) {
    var s = String(n).split("."), i = s[0], f = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
  },
  ceb: function ceb(n) {
    var s = String(n).split("."), i = s[0], f = s[1] || "", v0 = !s[1], i10 = i.slice(-1), f10 = f.slice(-1);
    return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
  },
  cs: function cs(n) {
    var s = String(n).split("."), i = s[0], v0 = !s[1];
    return n == 1 && v0 ? "one" : i >= 2 && i <= 4 && v0 ? "few" : !v0 ? "many" : "other";
  },
  cy: function cy(n) {
    return n == 0 ? "zero" : n == 1 ? "one" : n == 2 ? "two" : n == 3 ? "few" : n == 6 ? "many" : "other";
  },
  da: function da(n) {
    var s = String(n).split("."), i = s[0], t0 = Number(s[0]) == n;
    return n == 1 || !t0 && (i == 0 || i == 1) ? "one" : "other";
  },
  dsb: function dsb(n) {
    var s = String(n).split("."), i = s[0], f = s[1] || "", v0 = !s[1], i100 = i.slice(-2), f100 = f.slice(-2);
    return v0 && i100 == 1 || f100 == 1 ? "one" : v0 && i100 == 2 || f100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? "few" : "other";
  },
  dz: function dz(n) {
    return "other";
  },
  es: function es(n) {
    var s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
    return n == 1 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
  },
  ff: function ff(n) {
    return n >= 0 && n < 2 ? "one" : "other";
  },
  fr: function fr(n) {
    var s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
    return n >= 0 && n < 2 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
  },
  ga: function ga(n) {
    var s = String(n).split("."), t0 = Number(s[0]) == n;
    return n == 1 ? "one" : n == 2 ? "two" : t0 && n >= 3 && n <= 6 ? "few" : t0 && n >= 7 && n <= 10 ? "many" : "other";
  },
  gd: function gd(n) {
    var s = String(n).split("."), t0 = Number(s[0]) == n;
    return n == 1 || n == 11 ? "one" : n == 2 || n == 12 ? "two" : t0 && n >= 3 && n <= 10 || t0 && n >= 13 && n <= 19 ? "few" : "other";
  },
  he: function he(n) {
    var s = String(n).split("."), i = s[0], v0 = !s[1], t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1);
    return n == 1 && v0 ? "one" : i == 2 && v0 ? "two" : v0 && (n < 0 || n > 10) && t0 && n10 == 0 ? "many" : "other";
  },
  is: function is(n) {
    var s = String(n).split("."), i = s[0], t0 = Number(s[0]) == n, i10 = i.slice(-1), i100 = i.slice(-2);
    return t0 && i10 == 1 && i100 != 11 || !t0 ? "one" : "other";
  },
  it: function it(n) {
    var s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
    return n == 1 && v0 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
  },
  ksh: function ksh(n) {
    return n == 0 ? "zero" : n == 1 ? "one" : "other";
  },
  lt: function lt(n) {
    var s = String(n).split("."), f = s[1] || "", t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
    return n10 == 1 && (n100 < 11 || n100 > 19) ? "one" : n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19) ? "few" : f != 0 ? "many" : "other";
  },
  lv: function lv(n) {
    var s = String(n).split("."), f = s[1] || "", v = f.length, t0 = Number(s[0]) == n, n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2), f100 = f.slice(-2), f10 = f.slice(-1);
    return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? "zero" : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? "one" : "other";
  },
  mk: function mk(n) {
    var s = String(n).split("."), i = s[0], f = s[1] || "", v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2), f10 = f.slice(-1), f100 = f.slice(-2);
    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : "other";
  },
  mt: function mt(n) {
    var s = String(n).split("."), t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
    return n == 1 ? "one" : n == 0 || n100 >= 2 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 19 ? "many" : "other";
  },
  pa: function pa(n) {
    return n == 0 || n == 1 ? "one" : "other";
  },
  pl: function pl(n) {
    var s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
    return n == 1 && v0 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i != 1 && (i10 == 0 || i10 == 1) || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 12 && i100 <= 14 ? "many" : "other";
  },
  pt: function pt(n) {
    var s = String(n).split("."), i = s[0], v0 = !s[1], i1000000 = i.slice(-6);
    return i == 0 || i == 1 ? "one" : i != 0 && i1000000 == 0 && v0 ? "many" : "other";
  },
  ro: function ro(n) {
    var s = String(n).split("."), v0 = !s[1], t0 = Number(s[0]) == n, n100 = t0 && s[0].slice(-2);
    return n == 1 && v0 ? "one" : !v0 || n == 0 || n100 >= 2 && n100 <= 19 ? "few" : "other";
  },
  ru: function ru(n) {
    var s = String(n).split("."), i = s[0], v0 = !s[1], i10 = i.slice(-1), i100 = i.slice(-2);
    return v0 && i10 == 1 && i100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? "many" : "other";
  },
  se: function se(n) {
    return n == 1 ? "one" : n == 2 ? "two" : "other";
  },
  si: function si(n) {
    var s = String(n).split("."), i = s[0], f = s[1] || "";
    return n == 0 || n == 1 || i == 0 && f == 1 ? "one" : "other";
  },
  sl: function sl(n) {
    var s = String(n).split("."), i = s[0], v0 = !s[1], i100 = i.slice(-2);
    return v0 && i100 == 1 ? "one" : v0 && i100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || !v0 ? "few" : "other";
  }
};
$.as = $.am;
$.az = $.af;
$.bg = $.af;
$.bn = $.am;
$.brx = $.af;
$.ca = $.ast;
$.ce = $.af;
$.chr = $.af;
$.de = $.ast;
$.ee = $.af;
$.el = $.af;
$.en = $.ast;
$.et = $.ast;
$.eu = $.af;
$.fa = $.am;
$.fi = $.ast;
$.fil = $.ceb;
$.fo = $.af;
$.fur = $.af;
$.fy = $.ast;
$.gl = $.ast;
$.gu = $.am;
$.ha = $.af;
$.hi = $.am;
$.hr = $.bs;
$.hsb = $.dsb;
$.hu = $.af;
$.hy = $.ff;
$.ia = $.ast;
$.id = $.dz;
$.ig = $.dz;
$.ja = $.dz;
$.jgo = $.af;
$.jv = $.dz;
$.ka = $.af;
$.kea = $.dz;
$.kk = $.af;
$.kl = $.af;
$.km = $.dz;
$.kn = $.am;
$.ko = $.dz;
$.ku = $.af;
$.ky = $.af;
$.lb = $.af;
$.lkt = $.dz;
$.lo = $.dz;
$.ml = $.af;
$.mn = $.af;
$.mr = $.af;
$.ms = $.dz;
$.my = $.dz;
$.nb = $.af;
$.ne = $.af;
$.nl = $.ast;
$.nn = $.af;
$.no = $.af;
$.or = $.af;
$.pcm = $.am;
$.ps = $.af;
$.rm = $.af;
$.sah = $.dz;
$.sc = $.ast;
$.sd = $.af;
$.sk = $.cs;
$.so = $.af;
$.sq = $.af;
$.sr = $.bs;
$.su = $.dz;
$.sv = $.ast;
$.sw = $.ast;
$.ta = $.af;
$.te = $.af;
$.th = $.dz;
$.ti = $.pa;
$.tk = $.af;
$.to = $.dz;
$.tr = $.af;
$.ug = $.af;
$.uk = $.ru;
$.ur = $.ast;
$.uz = $.af;
$.vi = $.dz;
$.wae = $.af;
$.wo = $.dz;
$.yi = $.ast;
$.yo = $.dz;
$.yue = $.dz;
$.zh = $.dz;
$.zu = $.am;
var PluralRuleFunctions = $;
function getPluralRulesLocale(locale) {
  if (locale === "pt-PT") {
    return locale;
  }
  return getLanguageFromLanguageTag(locale);
}
var LANGUAGE_REG_EXP = /^([a-z0-9]+)/i;
function getLanguageFromLanguageTag(languageTag) {
  var match = languageTag.match(LANGUAGE_REG_EXP);
  if (!match) {
    throw new TypeError("Invalid locale: ".concat(languageTag));
  }
  return match[1];
}
function _classCallCheck$3(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var PluralRules = /* @__PURE__ */ function() {
  function PluralRules2(locale, options) {
    _classCallCheck$3(this, PluralRules2);
    var locales = PluralRules2.supportedLocalesOf(locale);
    if (locales.length === 0) {
      throw new RangeError("Unsupported locale: " + locale);
    }
    if (options && options.type !== "cardinal") {
      throw new RangeError('Only "cardinal" "type" is supported');
    }
    this.$ = PluralRuleFunctions[getPluralRulesLocale(locales[0])];
  }
  _createClass$3(PluralRules2, [{
    key: "select",
    value: function select(number) {
      return this.$(number);
    }
  }], [{
    key: "supportedLocalesOf",
    value: function supportedLocalesOf(locales) {
      if (typeof locales === "string") {
        locales = [locales];
      }
      return locales.filter(function(locale) {
        return PluralRuleFunctions[getPluralRulesLocale(locale)];
      });
    }
  }]);
  return PluralRules2;
}();
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$5(obj);
}
function ownKeys$9(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), true).forEach(function(key) {
      _defineProperty$9(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck$2(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var UNITS = ["second", "minute", "hour", "day", "week", "month", "quarter", "year"];
var NUMERIC_VALUES = ["auto", "always"];
var STYLE_VALUES = ["long", "short", "narrow"];
var LOCALE_MATCHER_VALUES = ["lookup", "best fit"];
var RelativeTimeFormat = /* @__PURE__ */ function() {
  function RelativeTimeFormat2() {
    var locales = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck$2(this, RelativeTimeFormat2);
    var numeric = options.numeric, style = options.style, localeMatcher = options.localeMatcher;
    this.numeric = "always";
    this.style = "long";
    this.localeMatcher = "lookup";
    if (numeric !== void 0) {
      if (NUMERIC_VALUES.indexOf(numeric) < 0) {
        throw new RangeError('Invalid "numeric" option: '.concat(numeric));
      }
      this.numeric = numeric;
    }
    if (style !== void 0) {
      if (STYLE_VALUES.indexOf(style) < 0) {
        throw new RangeError('Invalid "style" option: '.concat(style));
      }
      this.style = style;
    }
    if (localeMatcher !== void 0) {
      if (LOCALE_MATCHER_VALUES.indexOf(localeMatcher) < 0) {
        throw new RangeError('Invalid "localeMatcher" option: '.concat(localeMatcher));
      }
      this.localeMatcher = localeMatcher;
    }
    if (typeof locales === "string") {
      locales = [locales];
    }
    locales.push(getDefaultLocale());
    this.locale = RelativeTimeFormat2.supportedLocalesOf(locales, {
      localeMatcher: this.localeMatcher
    })[0];
    if (!this.locale) {
      throw new Error("No supported locale was found");
    }
    if (PluralRules.supportedLocalesOf(this.locale).length > 0) {
      this.pluralRules = new PluralRules(this.locale);
    } else {
      console.warn('"'.concat(this.locale, '" locale is not supported'));
    }
    if (typeof Intl !== "undefined" && Intl.NumberFormat) {
      this.numberFormat = new Intl.NumberFormat(this.locale);
      this.numberingSystem = this.numberFormat.resolvedOptions().numberingSystem;
    } else {
      this.numberingSystem = "latn";
    }
    this.locale = resolveLocale(this.locale, {
      localeMatcher: this.localeMatcher
    });
  }
  _createClass$2(RelativeTimeFormat2, [{
    key: "format",
    value: function format3() {
      var _parseFormatArgs = parseFormatArgs(arguments), _parseFormatArgs2 = _slicedToArray$1(_parseFormatArgs, 2), number = _parseFormatArgs2[0], unit = _parseFormatArgs2[1];
      return this.getRule(number, unit).replace("{0}", this.formatNumber(Math.abs(number)));
    }
  }, {
    key: "formatToParts",
    value: function formatToParts() {
      var _parseFormatArgs3 = parseFormatArgs(arguments), _parseFormatArgs4 = _slicedToArray$1(_parseFormatArgs3, 2), number = _parseFormatArgs4[0], unit = _parseFormatArgs4[1];
      var rule = this.getRule(number, unit);
      var valueIndex = rule.indexOf("{0}");
      if (valueIndex < 0) {
        return [{
          type: "literal",
          value: rule
        }];
      }
      var parts = [];
      if (valueIndex > 0) {
        parts.push({
          type: "literal",
          value: rule.slice(0, valueIndex)
        });
      }
      parts = parts.concat(this.formatNumberToParts(Math.abs(number)).map(function(part) {
        return _objectSpread$9(_objectSpread$9({}, part), {}, {
          unit
        });
      }));
      if (valueIndex + "{0}".length < rule.length - 1) {
        parts.push({
          type: "literal",
          value: rule.slice(valueIndex + "{0}".length)
        });
      }
      return parts;
    }
  }, {
    key: "getRule",
    value: function getRule(value, unit) {
      var unitMessages = getLocaleData$1(this.locale)[this.style][unit];
      if (typeof unitMessages === "string") {
        return unitMessages;
      }
      if (this.numeric === "auto") {
        if (value === -2 || value === -1) {
          var message = unitMessages["previous".concat(value === -1 ? "" : "-" + Math.abs(value))];
          if (message) {
            return message;
          }
        } else if (value === 1 || value === 2) {
          var _message = unitMessages["next".concat(value === 1 ? "" : "-" + Math.abs(value))];
          if (_message) {
            return _message;
          }
        } else if (value === 0) {
          if (unitMessages.current) {
            return unitMessages.current;
          }
        }
      }
      var pluralizedMessages = unitMessages[isNegative(value) ? "past" : "future"];
      if (typeof pluralizedMessages === "string") {
        return pluralizedMessages;
      }
      var quantifier = this.pluralRules && this.pluralRules.select(Math.abs(value)) || "other";
      return pluralizedMessages[quantifier] || pluralizedMessages.other;
    }
  }, {
    key: "formatNumber",
    value: function formatNumber(number) {
      return this.numberFormat ? this.numberFormat.format(number) : String(number);
    }
  }, {
    key: "formatNumberToParts",
    value: function formatNumberToParts(number) {
      return this.numberFormat && this.numberFormat.formatToParts ? this.numberFormat.formatToParts(number) : [{
        type: "integer",
        value: this.formatNumber(number)
      }];
    }
  }, {
    key: "resolvedOptions",
    value: function resolvedOptions() {
      return {
        locale: this.locale,
        style: this.style,
        numeric: this.numeric,
        numberingSystem: this.numberingSystem
      };
    }
  }]);
  return RelativeTimeFormat2;
}();
RelativeTimeFormat.supportedLocalesOf = function(locales) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof locales === "string") {
    locales = [locales];
  } else if (!Array.isArray(locales)) {
    throw new TypeError('Invalid "locales" argument');
  }
  return locales.filter(function(locale) {
    return resolveLocale(locale, options);
  });
};
RelativeTimeFormat.addLocale = addLocaleData$1;
RelativeTimeFormat.setDefaultLocale = setDefaultLocale;
RelativeTimeFormat.getDefaultLocale = getDefaultLocale;
RelativeTimeFormat.PluralRules = PluralRules;
var UNIT_ERROR = 'Invalid "unit" argument';
function parseUnit(unit) {
  if (_typeof$5(unit) === "symbol") {
    throw new TypeError(UNIT_ERROR);
  }
  if (typeof unit !== "string") {
    throw new RangeError("".concat(UNIT_ERROR, ": ").concat(unit));
  }
  if (unit[unit.length - 1] === "s") {
    unit = unit.slice(0, unit.length - 1);
  }
  if (UNITS.indexOf(unit) < 0) {
    throw new RangeError("".concat(UNIT_ERROR, ": ").concat(unit));
  }
  return unit;
}
var NUMBER_ERROR = 'Invalid "number" argument';
function parseNumber(value) {
  value = Number(value);
  if (Number.isFinite) {
    if (!Number.isFinite(value)) {
      throw new RangeError("".concat(NUMBER_ERROR, ": ").concat(value));
    }
  }
  return value;
}
function isNegativeZero(number) {
  return 1 / number === -Infinity;
}
function isNegative(number) {
  return number < 0 || number === 0 && isNegativeZero(number);
}
function parseFormatArgs(args) {
  if (args.length < 2) {
    throw new TypeError('"unit" argument is required');
  }
  return [parseNumber(args[0]), parseUnit(args[1])];
}
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$4(obj);
}
function _classCallCheck$1(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var Cache = /* @__PURE__ */ function() {
  function Cache2() {
    _classCallCheck$1(this, Cache2);
    this.cache = {};
  }
  _createClass$1(Cache2, [{
    key: "get",
    value: function get() {
      var cache = this.cache;
      for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
        keys[_key] = arguments[_key];
      }
      for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
        var key = _keys[_i];
        if (_typeof$4(cache) !== "object") {
          return;
        }
        cache = cache[key];
      }
      return cache;
    }
  }, {
    key: "put",
    value: function put2() {
      for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        keys[_key2] = arguments[_key2];
      }
      var value = keys.pop();
      var lastKey = keys.pop();
      var cache = this.cache;
      for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {
        var key = _keys2[_i2];
        if (_typeof$4(cache[key]) !== "object") {
          cache[key] = {};
        }
        cache = cache[key];
      }
      return cache[lastKey] = value;
    }
  }]);
  return Cache2;
}();
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$3(obj);
}
function _createForOfIteratorHelperLoose$1(o, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it2)
    return (it2 = it2.call(o)).next.bind(it2);
  if (Array.isArray(o) || (it2 = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it2)
      o = it2;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function chooseLocale(locales, isLocaleDataAvailable) {
  for (var _iterator = _createForOfIteratorHelperLoose$1(locales), _step; !(_step = _iterator()).done; ) {
    var locale = _step.value;
    if (isLocaleDataAvailable(locale)) {
      return locale;
    }
    var parts = locale.split("-");
    while (parts.length > 1) {
      parts.pop();
      locale = parts.join("-");
      if (isLocaleDataAvailable(locale)) {
        return locale;
      }
    }
  }
  throw new Error("No locale data has been registered for any of the locales: ".concat(locales.join(", ")));
}
function intlDateTimeFormatSupported() {
  var isIntlAvailable = (typeof Intl === "undefined" ? "undefined" : _typeof$3(Intl)) === "object";
  return isIntlAvailable && typeof Intl.DateTimeFormat === "function";
}
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function isStyleObject(object) {
  return isObject(object) && (Array.isArray(object.steps) || Array.isArray(object.gradation) || Array.isArray(object.flavour) || typeof object.flavour === "string" || Array.isArray(object.labels) || typeof object.labels === "string" || Array.isArray(object.units) || typeof object.custom === "function");
}
var OBJECT_CONSTRUCTOR = {}.constructor;
function isObject(object) {
  return _typeof$2(object) !== void 0 && object !== null && object.constructor === OBJECT_CONSTRUCTOR;
}
var minute = 60;
var hour = 60 * minute;
var day = 24 * hour;
var week = 7 * day;
var month = 30.44 * day;
var year = 146097 / 400 * day;
function getSecondsInUnit(unit) {
  switch (unit) {
    case "second":
      return 1;
    case "minute":
      return minute;
    case "hour":
      return hour;
    case "day":
      return day;
    case "week":
      return week;
    case "month":
      return month;
    case "year":
      return year;
  }
}
function getStepDenominator(step) {
  if (step.factor !== void 0) {
    return step.factor;
  }
  return getSecondsInUnit(step.unit || step.formatAs) || 1;
}
function getRoundFunction(round2) {
  switch (round2) {
    case "floor":
      return Math.floor;
    default:
      return Math.round;
  }
}
function getDiffRatioToNextRoundedNumber(round2) {
  switch (round2) {
    case "floor":
      return 1;
    default:
      return 0.5;
  }
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function getStepMinTime(step, _ref) {
  var prevStep = _ref.prevStep, timestamp = _ref.timestamp, now2 = _ref.now, future = _ref.future, round2 = _ref.round;
  var minTime3;
  if (prevStep) {
    if (prevStep.id || prevStep.unit) {
      minTime3 = step["threshold_for_".concat(prevStep.id || prevStep.unit)];
    }
  }
  if (minTime3 === void 0) {
    if (step.threshold !== void 0) {
      minTime3 = step.threshold;
      if (typeof minTime3 === "function") {
        minTime3 = minTime3(now2, future);
      }
    }
  }
  if (minTime3 === void 0) {
    minTime3 = step.minTime;
  }
  if (_typeof$1(minTime3) === "object") {
    if (prevStep && prevStep.id && minTime3[prevStep.id] !== void 0) {
      minTime3 = minTime3[prevStep.id];
    } else {
      minTime3 = minTime3["default"];
    }
  }
  if (typeof minTime3 === "function") {
    minTime3 = minTime3(timestamp, {
      future,
      getMinTimeForUnit: function getMinTimeForUnit(toUnit, fromUnit) {
        return _getMinTimeForUnit(toUnit, fromUnit || prevStep && prevStep.formatAs, {
          round: round2
        });
      }
    });
  }
  if (minTime3 === void 0) {
    if (step.test) {
      if (step.test(timestamp, {
        now: now2,
        future
      })) {
        minTime3 = 0;
      } else {
        minTime3 = 9007199254740991;
      }
    }
  }
  if (minTime3 === void 0) {
    if (prevStep) {
      if (step.formatAs && prevStep.formatAs) {
        minTime3 = _getMinTimeForUnit(step.formatAs, prevStep.formatAs, {
          round: round2
        });
      }
    } else {
      minTime3 = 0;
    }
  }
  if (minTime3 === void 0) {
    console.warn("[javascript-time-ago] A step should specify `minTime`:\n" + JSON.stringify(step, null, 2));
  }
  return minTime3;
}
function _getMinTimeForUnit(toUnit, fromUnit, _ref2) {
  var round2 = _ref2.round;
  var toUnitAmount = getSecondsInUnit(toUnit);
  var fromUnitAmount;
  if (fromUnit === "now") {
    fromUnitAmount = getSecondsInUnit(toUnit);
  } else {
    fromUnitAmount = getSecondsInUnit(fromUnit);
  }
  if (toUnitAmount !== void 0 && fromUnitAmount !== void 0) {
    return toUnitAmount - fromUnitAmount * (1 - getDiffRatioToNextRoundedNumber(round2));
  }
}
function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), true).forEach(function(key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function getStep(steps2, secondsPassed, _ref) {
  var now2 = _ref.now, future = _ref.future, round2 = _ref.round, units = _ref.units, getNextStep = _ref.getNextStep;
  steps2 = filterStepsByUnits(steps2, units);
  var step = _getStep(steps2, secondsPassed, {
    now: now2,
    future,
    round: round2
  });
  if (getNextStep) {
    if (step) {
      var prevStep = steps2[steps2.indexOf(step) - 1];
      var nextStep = steps2[steps2.indexOf(step) + 1];
      return [prevStep, step, nextStep];
    }
    return [void 0, void 0, steps2[0]];
  }
  return step;
}
function _getStep(steps2, secondsPassed, _ref2) {
  var now2 = _ref2.now, future = _ref2.future, round2 = _ref2.round;
  if (steps2.length === 0) {
    return;
  }
  var i = getStepIndex(steps2, secondsPassed, {
    now: now2,
    future: future || secondsPassed < 0,
    round: round2
  });
  if (i === -1) {
    return;
  }
  var step = steps2[i];
  if (step.granularity) {
    var secondsPassedGranular = getRoundFunction(round2)(Math.abs(secondsPassed) / getStepDenominator(step) / step.granularity) * step.granularity;
    if (secondsPassedGranular === 0 && i > 0) {
      return steps2[i - 1];
    }
  }
  return step;
}
function getStepIndex(steps2, secondsPassed, options) {
  var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var minTime3 = getStepMinTime(steps2[i], _objectSpread$8({
    prevStep: steps2[i - 1],
    timestamp: options.now - secondsPassed * 1e3
  }, options));
  if (minTime3 === void 0) {
    return i - 1;
  }
  if (Math.abs(secondsPassed) < minTime3) {
    return i - 1;
  }
  if (i === steps2.length - 1) {
    return i;
  }
  return getStepIndex(steps2, secondsPassed, options, i + 1);
}
function filterStepsByUnits(steps2, units) {
  return steps2.filter(function(_ref3) {
    var unit = _ref3.unit, formatAs = _ref3.formatAs;
    unit = unit || formatAs;
    if (unit) {
      return units.indexOf(unit) >= 0;
    }
    return true;
  });
}
function getTimeToNextUpdateForUnit(unit, timestamp, _ref) {
  var now2 = _ref.now, round2 = _ref.round;
  if (!getSecondsInUnit(unit)) {
    return;
  }
  var unitDenominator = getSecondsInUnit(unit) * 1e3;
  var future = timestamp > now2;
  var preciseAmount = Math.abs(timestamp - now2);
  var roundedAmount = getRoundFunction(round2)(preciseAmount / unitDenominator) * unitDenominator;
  if (future) {
    if (roundedAmount > 0) {
      return preciseAmount - roundedAmount + getDiffToPreviousRoundedNumber(round2, unitDenominator);
    } else {
      return preciseAmount - roundedAmount + 1;
    }
  }
  return -(preciseAmount - roundedAmount) + getDiffToNextRoundedNumber(round2, unitDenominator);
}
function getDiffToNextRoundedNumber(round2, unitDenominator) {
  return getDiffRatioToNextRoundedNumber(round2) * unitDenominator;
}
function getDiffToPreviousRoundedNumber(round2, unitDenominator) {
  return (1 - getDiffRatioToNextRoundedNumber(round2)) * unitDenominator + 1;
}
var YEAR = 365 * 24 * 60 * 60 * 1e3;
var INFINITY = 1e3 * YEAR;
function getTimeToNextUpdate(date, step, _ref) {
  var prevStep = _ref.prevStep, nextStep = _ref.nextStep, now2 = _ref.now, future = _ref.future, round2 = _ref.round;
  var timestamp = date.getTime ? date.getTime() : date;
  var getTimeToNextUpdateForUnit$1 = function getTimeToNextUpdateForUnit$12(unit2) {
    return getTimeToNextUpdateForUnit(unit2, timestamp, {
      now: now2,
      round: round2
    });
  };
  var timeToStepChange = getTimeToStepChange(future ? step : nextStep, timestamp, {
    future,
    now: now2,
    round: round2,
    prevStep: future ? prevStep : step
  });
  if (timeToStepChange === void 0) {
    return;
  }
  var timeToNextUpdate;
  if (step) {
    if (step.getTimeToNextUpdate) {
      timeToNextUpdate = step.getTimeToNextUpdate(timestamp, {
        getTimeToNextUpdateForUnit: getTimeToNextUpdateForUnit$1,
        getRoundFunction,
        now: now2,
        future,
        round: round2
      });
    }
    if (timeToNextUpdate === void 0) {
      var unit = step.unit || step.formatAs;
      if (unit) {
        timeToNextUpdate = getTimeToNextUpdateForUnit$1(unit);
      }
    }
  }
  if (timeToNextUpdate === void 0) {
    return timeToStepChange;
  }
  return Math.min(timeToNextUpdate, timeToStepChange);
}
function getStepChangesAt(currentOrNextStep, timestamp, _ref2) {
  var now2 = _ref2.now, future = _ref2.future, round2 = _ref2.round, prevStep = _ref2.prevStep;
  var minTime3 = getStepMinTime(currentOrNextStep, {
    timestamp,
    now: now2,
    future,
    round: round2,
    prevStep
  });
  if (minTime3 === void 0) {
    return;
  }
  if (future) {
    return timestamp - minTime3 * 1e3 + 1;
  } else {
    if (minTime3 === 0 && timestamp === now2) {
      return INFINITY;
    }
    return timestamp + minTime3 * 1e3;
  }
}
function getTimeToStepChange(step, timestamp, _ref3) {
  var now2 = _ref3.now, future = _ref3.future, round2 = _ref3.round, prevStep = _ref3.prevStep;
  if (step) {
    var stepChangesAt = getStepChangesAt(step, timestamp, {
      now: now2,
      future,
      round: round2,
      prevStep
    });
    if (stepChangesAt === void 0) {
      return;
    }
    return stepChangesAt - now2;
  } else {
    if (future) {
      return timestamp - now2 + 1;
    } else {
      return INFINITY;
    }
  }
}
var localesData = {};
function getLocaleData(locale) {
  return localesData[locale];
}
function addLocaleData(localeData) {
  if (!localeData) {
    throw new Error("[javascript-time-ago] No locale data passed.");
  }
  localesData[localeData.locale] = localeData;
}
var round$1 = [{
  formatAs: "now"
}, {
  formatAs: "second"
}, {
  formatAs: "minute"
}, {
  formatAs: "hour"
}, {
  formatAs: "day"
}, {
  formatAs: "week"
}, {
  formatAs: "month"
}, {
  formatAs: "year"
}];
var round = {
  steps: round$1,
  labels: "long"
};
function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
      _defineProperty$7(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var defaultStyle = _objectSpread$7(_objectSpread$7({}, round), {}, {
  steps: round.steps.filter(function(step) {
    return step.formatAs !== "second";
  })
});
var approximate$1 = [{
  factor: 1,
  unit: "now"
}, {
  threshold: 1,
  threshold_for_now: 45.5,
  factor: 1,
  unit: "second"
}, {
  threshold: 45.5,
  factor: minute,
  unit: "minute"
}, {
  threshold: 2.5 * minute,
  granularity: 5,
  factor: minute,
  unit: "minute"
}, {
  threshold: 22.5 * minute,
  factor: 0.5 * hour,
  unit: "half-hour"
}, {
  threshold: 42.5 * minute,
  threshold_for_minute: 52.5 * minute,
  factor: hour,
  unit: "hour"
}, {
  threshold: 20.5 / 24 * day,
  factor: day,
  unit: "day"
}, {
  threshold: 5.5 * day,
  factor: week,
  unit: "week"
}, {
  threshold: 3.5 * week,
  factor: month,
  unit: "month"
}, {
  threshold: 10.5 * month,
  factor: year,
  unit: "year"
}];
var approximate = {
  gradation: approximate$1,
  flavour: "long",
  units: ["now", "minute", "hour", "day", "week", "month", "year"]
};
var approximateTime = {
  gradation: approximate$1,
  flavour: "long-time",
  units: ["now", "minute", "hour", "day", "week", "month", "year"]
};
function getDate(value) {
  return value instanceof Date ? value : new Date(value);
}
var steps = [{
  formatAs: "second"
}, {
  formatAs: "minute"
}, {
  formatAs: "hour"
}];
var formatters = {};
var monthAndDay = {
  minTime: function minTime(timestamp, _ref) {
    _ref.future;
    var getMinTimeForUnit = _ref.getMinTimeForUnit;
    return getMinTimeForUnit("day");
  },
  format: function format(value, locale) {
    if (!formatters[locale]) {
      formatters[locale] = {};
    }
    if (!formatters[locale].dayMonth) {
      formatters[locale].dayMonth = new Intl.DateTimeFormat(locale, {
        month: "short",
        day: "numeric"
      });
    }
    return formatters[locale].dayMonth.format(getDate(value));
  }
};
var yearMonthAndDay = {
  minTime: function minTime2(timestamp, _ref2) {
    var future = _ref2.future;
    if (future) {
      var maxFittingNow = new Date(new Date(timestamp).getFullYear(), 0).getTime() - 1;
      return (timestamp - maxFittingNow) / 1e3;
    } else {
      var minFittingNow = new Date(new Date(timestamp).getFullYear() + 1, 0).getTime();
      return (minFittingNow - timestamp) / 1e3;
    }
  },
  format: function format2(value, locale) {
    if (!formatters[locale]) {
      formatters[locale] = {};
    }
    if (!formatters[locale].dayMonthYear) {
      formatters[locale].dayMonthYear = new Intl.DateTimeFormat(locale, {
        year: "numeric",
        month: "short",
        day: "numeric"
      });
    }
    return formatters[locale].dayMonthYear.format(getDate(value));
  }
};
if (intlDateTimeFormatSupported()) {
  steps.push(monthAndDay, yearMonthAndDay);
} else {
  steps.push({
    formatAs: "day"
  }, {
    formatAs: "week"
  }, {
    formatAs: "month"
  }, {
    formatAs: "year"
  });
}
var twitter = {
  steps,
  labels: [
    "mini",
    "short-time",
    "narrow",
    "short"
  ]
};
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var twitterNow = _objectSpread$6(_objectSpread$6({}, twitter), {}, {
  steps: [{
    formatAs: "now"
  }].concat(twitter.steps)
});
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty$5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var twitterMinute = _objectSpread$5(_objectSpread$5({}, twitter), {}, {
  steps: twitter.steps.filter(function(step) {
    return step.formatAs !== "second";
  })
});
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var twitterMinuteNow = _objectSpread$4(_objectSpread$4({}, twitterMinute), {}, {
  steps: [{
    formatAs: "now"
  }].concat(twitterMinute.steps)
});
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var twitterFirstMinute = _objectSpread$3(_objectSpread$3({}, twitter), {}, {
  steps: twitter.steps.filter(function(step) {
    return step.formatAs !== "second";
  }).map(function(step) {
    return step.formatAs === "minute" ? _objectSpread$3(_objectSpread$3({}, step), {}, {
      minTime: minute
    }) : step;
  })
});
var mini = {
  steps: [{
    formatAs: "second"
  }, {
    formatAs: "minute"
  }, {
    formatAs: "hour"
  }, {
    formatAs: "day"
  }, {
    formatAs: "month"
  }, {
    formatAs: "year"
  }],
  labels: [
    "mini",
    "short-time",
    "narrow",
    "short"
  ]
};
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var miniNow = _objectSpread$2(_objectSpread$2({}, mini), {}, {
  steps: [{
    formatAs: "now"
  }].concat(mini.steps)
});
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var miniMinute = _objectSpread$1(_objectSpread$1({}, mini), {}, {
  steps: mini.steps.filter(function(step) {
    return step.formatAs !== "second";
  })
});
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var miniMinuteNow = _objectSpread(_objectSpread({}, miniMinute), {}, {
  steps: [{
    formatAs: "now"
  }].concat(miniMinute.steps)
});
function getStyleByName(style) {
  switch (style) {
    case "default":
    case "round":
      return round;
    case "round-minute":
      return defaultStyle;
    case "approximate":
      return approximate;
    case "time":
    case "approximate-time":
      return approximateTime;
    case "mini":
      return mini;
    case "mini-now":
      return miniNow;
    case "mini-minute":
      return miniMinute;
    case "mini-minute-now":
      return miniMinuteNow;
    case "twitter":
      return twitter;
    case "twitter-now":
      return twitterNow;
    case "twitter-minute":
      return twitterMinute;
    case "twitter-minute-now":
      return twitterMinuteNow;
    case "twitter-first-minute":
      return twitterFirstMinute;
    default:
      return approximate;
  }
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it2)
    return (it2 = it2.call(o)).next.bind(it2);
  if (Array.isArray(o) || (it2 = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it2)
      o = it2;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var TimeAgo = /* @__PURE__ */ function() {
  function TimeAgo2() {
    var locales = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, polyfill2 = _ref.polyfill;
    _classCallCheck(this, TimeAgo2);
    if (typeof locales === "string") {
      locales = [locales];
    }
    this.locale = chooseLocale(locales.concat(TimeAgo2.getDefaultLocale()), getLocaleData);
    if (typeof Intl !== "undefined") {
      if (Intl.NumberFormat) {
        this.numberFormat = new Intl.NumberFormat(this.locale);
      }
    }
    if (polyfill2 === false) {
      this.IntlRelativeTimeFormat = Intl.RelativeTimeFormat;
      this.IntlPluralRules = Intl.PluralRules;
    } else {
      this.IntlRelativeTimeFormat = RelativeTimeFormat;
      this.IntlPluralRules = RelativeTimeFormat.PluralRules;
    }
    this.relativeTimeFormatCache = new Cache();
    this.pluralRulesCache = new Cache();
  }
  _createClass(TimeAgo2, [{
    key: "format",
    value: function format3(input, style, options) {
      if (!options) {
        if (style && !isStyle(style)) {
          options = style;
          style = void 0;
        } else {
          options = {};
        }
      }
      if (!style) {
        style = defaultStyle;
      }
      if (typeof style === "string") {
        style = getStyleByName(style);
      }
      var timestamp = getTimestamp(input);
      var _this$getLabels = this.getLabels(style.flavour || style.labels), labels = _this$getLabels.labels, labelsType = _this$getLabels.labelsType;
      var now2;
      if (style.now !== void 0) {
        now2 = style.now;
      }
      if (now2 === void 0 && options.now !== void 0) {
        now2 = options.now;
      }
      if (now2 === void 0) {
        now2 = Date.now();
      }
      var secondsPassed = (now2 - timestamp) / 1e3;
      var future = options.future || secondsPassed < 0;
      var nowLabel = getNowLabel(labels, getLocaleData(this.locale).now, getLocaleData(this.locale)["long"], future);
      if (style.custom) {
        var custom = style.custom({
          now: now2,
          date: new Date(timestamp),
          time: timestamp,
          elapsed: secondsPassed,
          locale: this.locale
        });
        if (custom !== void 0) {
          return custom;
        }
      }
      var units = getTimeIntervalMeasurementUnits(
        style.units,
        labels,
        nowLabel
      );
      var round2 = options.round || style.round;
      var _getStep2 = getStep(
        style.gradation || style.steps || defaultStyle.steps,
        secondsPassed,
        {
          now: now2,
          units,
          round: round2,
          future,
          getNextStep: true
        }
      ), _getStep22 = _slicedToArray(_getStep2, 3), prevStep = _getStep22[0], step = _getStep22[1], nextStep = _getStep22[2];
      var formattedDate = this.formatDateForStep(timestamp, step, secondsPassed, {
        labels,
        labelsType,
        nowLabel,
        now: now2,
        future,
        round: round2
      }) || "";
      if (options.getTimeToNextUpdate) {
        var timeToNextUpdate = getTimeToNextUpdate(timestamp, step, {
          nextStep,
          prevStep,
          now: now2,
          future,
          round: round2
        });
        return [formattedDate, timeToNextUpdate];
      }
      return formattedDate;
    }
  }, {
    key: "formatDateForStep",
    value: function formatDateForStep(timestamp, step, secondsPassed, _ref2) {
      var _this = this;
      var labels = _ref2.labels, labelsType = _ref2.labelsType, nowLabel = _ref2.nowLabel, now2 = _ref2.now, future = _ref2.future, round2 = _ref2.round;
      if (!step) {
        return;
      }
      if (step.format) {
        return step.format(timestamp, this.locale, {
          formatAs: function formatAs(unit2, value) {
            return _this.formatValue(value, unit2, {
              labels,
              future
            });
          },
          now: now2,
          future
        });
      }
      var unit = step.unit || step.formatAs;
      if (!unit) {
        throw new Error("[javascript-time-ago] Each step must define either `formatAs` or `format()`. Step: ".concat(JSON.stringify(step)));
      }
      if (unit === "now") {
        return nowLabel;
      }
      var amount = Math.abs(secondsPassed) / getStepDenominator(step);
      if (step.granularity) {
        amount = getRoundFunction(round2)(amount / step.granularity) * step.granularity;
      }
      var valueForFormatting = -1 * Math.sign(secondsPassed) * getRoundFunction(round2)(amount);
      if (valueForFormatting === 0) {
        if (future) {
          valueForFormatting = 0;
        } else {
          valueForFormatting = -0;
        }
      }
      switch (labelsType) {
        case "long":
        case "short":
        case "narrow":
          return this.getFormatter(labelsType).format(valueForFormatting, unit);
        default:
          return this.formatValue(valueForFormatting, unit, {
            labels,
            future
          });
      }
    }
  }, {
    key: "formatValue",
    value: function formatValue(value, unit, _ref3) {
      var labels = _ref3.labels, future = _ref3.future;
      return this.getFormattingRule(labels, unit, value, {
        future
      }).replace("{0}", this.formatNumber(Math.abs(value)));
    }
  }, {
    key: "getFormattingRule",
    value: function getFormattingRule(formattingRules, unit, value, _ref4) {
      var future = _ref4.future;
      this.locale;
      formattingRules = formattingRules[unit];
      if (typeof formattingRules === "string") {
        return formattingRules;
      }
      var pastOrFuture = value === 0 ? future ? "future" : "past" : value < 0 ? "past" : "future";
      var quantifierRules = formattingRules[pastOrFuture] || formattingRules;
      if (typeof quantifierRules === "string") {
        return quantifierRules;
      }
      var quantifier = this.getPluralRules().select(Math.abs(value));
      return quantifierRules[quantifier] || quantifierRules.other;
    }
  }, {
    key: "formatNumber",
    value: function formatNumber(number) {
      return this.numberFormat ? this.numberFormat.format(number) : String(number);
    }
  }, {
    key: "getFormatter",
    value: function getFormatter(labelsType) {
      return this.relativeTimeFormatCache.get(this.locale, labelsType) || this.relativeTimeFormatCache.put(this.locale, labelsType, new this.IntlRelativeTimeFormat(this.locale, {
        style: labelsType
      }));
    }
  }, {
    key: "getPluralRules",
    value: function getPluralRules() {
      return this.pluralRulesCache.get(this.locale) || this.pluralRulesCache.put(this.locale, new this.IntlPluralRules(this.locale));
    }
  }, {
    key: "getLabels",
    value: function getLabels() {
      var labelsType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (typeof labelsType === "string") {
        labelsType = [labelsType];
      }
      labelsType = labelsType.map(function(labelsType2) {
        switch (labelsType2) {
          case "tiny":
          case "mini-time":
            return "mini";
          default:
            return labelsType2;
        }
      });
      labelsType = labelsType.concat("long");
      var localeData = getLocaleData(this.locale);
      for (var _iterator = _createForOfIteratorHelperLoose(labelsType), _step; !(_step = _iterator()).done; ) {
        var _labelsType = _step.value;
        if (localeData[_labelsType]) {
          return {
            labelsType: _labelsType,
            labels: localeData[_labelsType]
          };
        }
      }
    }
  }]);
  return TimeAgo2;
}();
var defaultLocale = "en";
TimeAgo.getDefaultLocale = function() {
  return defaultLocale;
};
TimeAgo.setDefaultLocale = function(locale) {
  return defaultLocale = locale;
};
TimeAgo.addDefaultLocale = function(localeData) {
  if (defaultLocaleHasBeenSpecified) {
    return console.error("[javascript-time-ago] `TimeAgo.addDefaultLocale()` can only be called once. To add other locales, use `TimeAgo.addLocale()`.");
  }
  defaultLocaleHasBeenSpecified = true;
  TimeAgo.setDefaultLocale(localeData.locale);
  TimeAgo.addLocale(localeData);
};
var defaultLocaleHasBeenSpecified;
TimeAgo.addLocale = function(localeData) {
  addLocaleData(localeData);
  RelativeTimeFormat.addLocale(localeData);
};
TimeAgo.locale = TimeAgo.addLocale;
TimeAgo.addLabels = function(locale, name, labels) {
  var localeData = getLocaleData(locale);
  if (!localeData) {
    addLocaleData({
      locale
    });
    localeData = getLocaleData(locale);
  }
  localeData[name] = labels;
};
function getTimestamp(input) {
  if (input.constructor === Date || isMockedDate(input)) {
    return input.getTime();
  }
  if (typeof input === "number") {
    return input;
  }
  throw new Error("Unsupported relative time formatter input: ".concat(_typeof(input), ", ").concat(input));
}
function isMockedDate(object) {
  return _typeof(object) === "object" && typeof object.getTime === "function";
}
function getTimeIntervalMeasurementUnits(allowedUnits, labels, nowLabel) {
  var units = Object.keys(labels);
  if (nowLabel) {
    units.push("now");
  }
  if (allowedUnits) {
    units = allowedUnits.filter(function(unit) {
      return unit === "now" || units.indexOf(unit) >= 0;
    });
  }
  return units;
}
function getNowLabel(labels, nowLabels, longLabels, future) {
  var nowLabel = labels.now || nowLabels && nowLabels.now;
  if (nowLabel) {
    if (typeof nowLabel === "string") {
      return nowLabel;
    }
    if (future) {
      return nowLabel.future;
    } else {
      return nowLabel.past;
    }
  }
  if (longLabels && longLabels.second && longLabels.second.current) {
    return longLabels.second.current;
  }
}
function isStyle(variable) {
  return typeof variable === "string" || isStyleObject(variable);
}
var english_locale = {
  "locale": "en",
  "long": {
    "year": {
      "previous": "last year",
      "current": "this year",
      "next": "next year",
      "past": {
        "one": "{0} year ago",
        "other": "{0} years ago"
      },
      "future": {
        "one": "in {0} year",
        "other": "in {0} years"
      }
    },
    "quarter": {
      "previous": "last quarter",
      "current": "this quarter",
      "next": "next quarter",
      "past": {
        "one": "{0} quarter ago",
        "other": "{0} quarters ago"
      },
      "future": {
        "one": "in {0} quarter",
        "other": "in {0} quarters"
      }
    },
    "month": {
      "previous": "last month",
      "current": "this month",
      "next": "next month",
      "past": {
        "one": "{0} month ago",
        "other": "{0} months ago"
      },
      "future": {
        "one": "in {0} month",
        "other": "in {0} months"
      }
    },
    "week": {
      "previous": "last week",
      "current": "this week",
      "next": "next week",
      "past": {
        "one": "{0} week ago",
        "other": "{0} weeks ago"
      },
      "future": {
        "one": "in {0} week",
        "other": "in {0} weeks"
      }
    },
    "day": {
      "previous": "yesterday",
      "current": "today",
      "next": "tomorrow",
      "past": {
        "one": "{0} day ago",
        "other": "{0} days ago"
      },
      "future": {
        "one": "in {0} day",
        "other": "in {0} days"
      }
    },
    "hour": {
      "current": "this hour",
      "past": {
        "one": "{0} hour ago",
        "other": "{0} hours ago"
      },
      "future": {
        "one": "in {0} hour",
        "other": "in {0} hours"
      }
    },
    "minute": {
      "current": "this minute",
      "past": {
        "one": "{0} minute ago",
        "other": "{0} minutes ago"
      },
      "future": {
        "one": "in {0} minute",
        "other": "in {0} minutes"
      }
    },
    "second": {
      "current": "now",
      "past": {
        "one": "{0} second ago",
        "other": "{0} seconds ago"
      },
      "future": {
        "one": "in {0} second",
        "other": "in {0} seconds"
      }
    }
  },
  "short": {
    "year": {
      "previous": "last yr.",
      "current": "this yr.",
      "next": "next yr.",
      "past": "{0} yr. ago",
      "future": "in {0} yr."
    },
    "quarter": {
      "previous": "last qtr.",
      "current": "this qtr.",
      "next": "next qtr.",
      "past": {
        "one": "{0} qtr. ago",
        "other": "{0} qtrs. ago"
      },
      "future": {
        "one": "in {0} qtr.",
        "other": "in {0} qtrs."
      }
    },
    "month": {
      "previous": "last mo.",
      "current": "this mo.",
      "next": "next mo.",
      "past": "{0} mo. ago",
      "future": "in {0} mo."
    },
    "week": {
      "previous": "last wk.",
      "current": "this wk.",
      "next": "next wk.",
      "past": "{0} wk. ago",
      "future": "in {0} wk."
    },
    "day": {
      "previous": "yesterday",
      "current": "today",
      "next": "tomorrow",
      "past": {
        "one": "{0} day ago",
        "other": "{0} days ago"
      },
      "future": {
        "one": "in {0} day",
        "other": "in {0} days"
      }
    },
    "hour": {
      "current": "this hour",
      "past": "{0} hr. ago",
      "future": "in {0} hr."
    },
    "minute": {
      "current": "this minute",
      "past": "{0} min. ago",
      "future": "in {0} min."
    },
    "second": {
      "current": "now",
      "past": "{0} sec. ago",
      "future": "in {0} sec."
    }
  },
  "narrow": {
    "year": {
      "previous": "last yr.",
      "current": "this yr.",
      "next": "next yr.",
      "past": "{0} yr. ago",
      "future": "in {0} yr."
    },
    "quarter": {
      "previous": "last qtr.",
      "current": "this qtr.",
      "next": "next qtr.",
      "past": {
        "one": "{0} qtr. ago",
        "other": "{0} qtrs. ago"
      },
      "future": {
        "one": "in {0} qtr.",
        "other": "in {0} qtrs."
      }
    },
    "month": {
      "previous": "last mo.",
      "current": "this mo.",
      "next": "next mo.",
      "past": "{0} mo. ago",
      "future": "in {0} mo."
    },
    "week": {
      "previous": "last wk.",
      "current": "this wk.",
      "next": "next wk.",
      "past": "{0} wk. ago",
      "future": "in {0} wk."
    },
    "day": {
      "previous": "yesterday",
      "current": "today",
      "next": "tomorrow",
      "past": {
        "one": "{0} day ago",
        "other": "{0} days ago"
      },
      "future": {
        "one": "in {0} day",
        "other": "in {0} days"
      }
    },
    "hour": {
      "current": "this hour",
      "past": "{0} hr. ago",
      "future": "in {0} hr."
    },
    "minute": {
      "current": "this minute",
      "past": "{0} min. ago",
      "future": "in {0} min."
    },
    "second": {
      "current": "now",
      "past": "{0} sec. ago",
      "future": "in {0} sec."
    }
  },
  "now": {
    "now": {
      "current": "now",
      "future": "in a moment",
      "past": "just now"
    }
  },
  "mini": {
    "year": "{0}yr",
    "month": "{0}mo",
    "week": "{0}wk",
    "day": "{0}d",
    "hour": "{0}h",
    "minute": "{0}m",
    "second": "{0}s",
    "now": "now"
  },
  "short-time": {
    "year": "{0} yr.",
    "month": "{0} mo.",
    "week": "{0} wk.",
    "day": {
      "one": "{0} day",
      "other": "{0} days"
    },
    "hour": "{0} hr.",
    "minute": "{0} min.",
    "second": "{0} sec."
  },
  "long-time": {
    "year": {
      "one": "{0} year",
      "other": "{0} years"
    },
    "month": {
      "one": "{0} month",
      "other": "{0} months"
    },
    "week": {
      "one": "{0} week",
      "other": "{0} weeks"
    },
    "day": {
      "one": "{0} day",
      "other": "{0} days"
    },
    "hour": {
      "one": "{0} hour",
      "other": "{0} hours"
    },
    "minute": {
      "one": "{0} minute",
      "other": "{0} minutes"
    },
    "second": {
      "one": "{0} second",
      "other": "{0} seconds"
    }
  }
};
var SX_ACC_CREATED = '<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M12 6H18V8H12V6Z" fill="#F7F7F7"/>\n<path d="M14 10L14 4L16 4L16 10L14 10Z" fill="#F7F7F7"/>\n<circle cx="7" cy="5" r="2" stroke="#F7F7F7" stroke-width="2"/>\n<path fill-rule="evenodd" clip-rule="evenodd" d="M1 15C1.47608 12.1623 3.94405 10 6.91704 10C9.89004 10 12.358 12.1623 12.8341 15H10.791C10.347 13.2748 8.78088 12 6.91704 12C5.0532 12 3.4871 13.2748 3.04306 15H1Z" fill="#F7F7F7"/>\n</svg>\n';
var TxnList_svelte_svelte_type_style_lang = "";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
const get_first_slot_changes = (dirty) => ({});
const get_first_slot_context = (ctx) => ({});
function create_catch_block(ctx) {
  return {
    c: noop$1,
    m: noop$1,
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d: noop$1
  };
}
function create_then_block(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      name: ctx[18].title,
      detail: ctx[18].subtitle,
      amount: ctx[18].amount || "",
      fiat: ctx[18].fiat || "",
      $$slots: {
        below: [create_below_slot],
        right: [create_right_slot],
        icon: [create_icon_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const row_changes = {};
      if (dirty & 1)
        row_changes.name = ctx2[18].title;
      if (dirty & 1)
        row_changes.detail = ctx2[18].subtitle;
      if (dirty & 1)
        row_changes.amount = ctx2[18].amount || "";
      if (dirty & 1)
        row_changes.fiat = ctx2[18].fiat || "";
      if (dirty & 33) {
        row_changes.$$scope = { dirty, ctx: ctx2 };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_icon_slot(ctx) {
  let put2;
  let current;
  put2 = new Put({
    props: { element: ctx[18].icon }
  });
  return {
    c() {
      create_component(put2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(put2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const put_changes = {};
      if (dirty & 1)
        put_changes.element = ctx2[18].icon;
      put2.$set(put_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(put2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(put2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(put2, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 36,
      name: ctx[18].name,
      ref: ctx[18].pfp,
      circular: "pending" === ctx[15].type,
      rootStyle: "margin-left: 1em;"
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = {};
      if (dirty & 1)
        pfpdisplay_changes.name = ctx2[18].name;
      if (dirty & 1)
        pfpdisplay_changes.ref = ctx2[18].pfp;
      if (dirty & 1)
        pfpdisplay_changes.circular = "pending" === ctx2[15].type;
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_right_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = "string" === typeof ctx[18].pfp && create_if_block_2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ("string" === typeof ctx2[18].pfp) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Pending";
      attr(span, "class", "pill svelte-krovk1");
      toggle_class(span, "display_none", !ctx[18].pending);
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        toggle_class(span, "display_none", !ctx2[18].pending);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block(ctx) {
  let span;
  let a;
  let t_value = ctx[18].link.text + "";
  let t;
  let a_href_value;
  let mounted;
  let dispose;
  function click_handler2() {
    return ctx[4](ctx[18]);
  }
  return {
    c() {
      span = element("span");
      a = element("a");
      t = text(t_value);
      attr(a, "href", a_href_value = ctx[18].link.href);
      attr(span, "class", "link");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, a);
      append(a, t);
      if (!mounted) {
        dispose = listen(a, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t_value !== (t_value = ctx[18].link.text + ""))
        set_data(t, t_value);
      if (dirty & 1 && a_href_value !== (a_href_value = ctx[18].link.href)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_below_slot(ctx) {
  let t;
  let if_block1_anchor;
  let if_block0 = ctx[18].pending && create_if_block_1(ctx);
  let if_block1 = ctx[18].link && create_if_block(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[18].pending) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[18].link) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(if_block1_anchor);
    }
  };
}
function create_pending_block(ctx) {
  let t;
  return {
    c() {
      t = text("Loading event...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block(ctx) {
  let promise2;
  let t;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 18,
    blocks: [, , ,]
  };
  handle_promise(promise2 = ctx[1](ctx[15]), info);
  return {
    c() {
      info.block.c();
      t = space();
    },
    m(target, anchor) {
      info.block.m(target, info.anchor = anchor);
      info.mount = () => t.parentNode;
      info.anchor = t;
      insert(target, t, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & 1 && promise2 !== (promise2 = ctx[1](ctx[15])) && handle_promise(promise2, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      info.block.d(detaching);
      info.token = null;
      info = null;
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment(ctx) {
  let div;
  let t;
  let current;
  const first_slot_template = ctx[3].first;
  const first_slot = create_slot(first_slot_template, ctx, ctx[5], get_first_slot_context);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      if (first_slot)
        first_slot.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "txns no-margin");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (first_slot) {
        first_slot.m(div, null);
      }
      append(div, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (first_slot) {
        if (first_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            first_slot,
            first_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(first_slot_template, ctx2[5], dirty, get_first_slot_changes),
            get_first_slot_context
          );
        }
      }
      if (dirty & 3) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(first_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(first_slot, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (first_slot)
        first_slot.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
var TxnContext;
(function(TxnContext2) {
  TxnContext2["NONE"] = "none";
  TxnContext2["TOKEN"] = "token";
  TxnContext2["CONTACT"] = "contact";
})(TxnContext || (TxnContext = {}));
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { events } = $$props;
  let { context = TxnContext.NONE } = $$props;
  context === TxnContext.CONTACT;
  context === TxnContext.TOKEN;
  const mk_icon = (sx_icon) => {
    const dm_icon = dd("span", { class: "event-icon" });
    dm_icon.innerHTML = sx_icon;
    return dm_icon;
  };
  const DM_ICON_SEND = mk_icon(SX_SEND);
  mk_icon(SX_RECV);
  mk_icon(SX_ACC_CREATED);
  TimeAgo.addDefaultLocale(english_locale);
  const y_ago = new TimeAgo("en-US");
  function format_time_ago(xt_when) {
    return y_ago.format(xt_when, "twitter");
  }
  const H_EVENT_MAP = {
    async pending(g_event) {
      const { time: xt_when, data: { chain: p_chain, coin: si_coin, hash: si_txn, owner: sa_owner, msg: g_msg } } = g_event;
      const g_chain = await Chains.at(p_chain);
      const g_coin = g_chain.coins[si_coin];
      const x_amount = new BigNumber(g_event.data.msg.amount[0].amount).shiftedBy(-g_chain.coins[si_coin].decimals).toNumber();
      const sa_recipient = g_msg.toAddress;
      const p_contact = Agents.pathForContact(sa_recipient);
      const g_contact = await Agents.getContact(p_contact);
      return {
        title: `Send ${g_coin.name}`,
        name: si_coin,
        icon: DM_ICON_SEND,
        subtitle: `${format_time_ago(xt_when)} / ${g_contact ? g_contact.name : sa_recipient}`,
        amount: `${format_amount(x_amount, true)} ${si_coin}`,
        pfp: g_coin.pfp,
        pending: true
      };
    },
    async send(g_event) {
      const { time: xt_when, data: { chain: p_chain, coin: si_coin, hash: si_txn, owner: sa_owner, msg: g_msg, height: s_height } } = g_event;
      const g_chain = await Chains.at(p_chain);
      const g_coin = g_chain.coins[si_coin];
      const x_amount = new BigNumber(g_event.data.msg.amount[0].amount).shiftedBy(-g_chain.coins[si_coin].decimals).toNumber();
      const sa_recipient = g_msg.toAddress;
      const p_contact = Agents.pathForContact(sa_recipient);
      const g_contact = await Agents.getContact(p_contact);
      return {
        title: `Sent ${g_coin.name}`,
        name: si_coin,
        icon: mk_icon(SX_SEND),
        subtitle: `${format_time_ago(xt_when)} / ${g_contact ? g_contact.name : abbreviate_addr(sa_recipient)}`,
        amount: `${format_amount(x_amount, true)} ${si_coin}`,
        link: "SCRT" === si_coin ? {
          href: `https://secretnodes.com/secret/chains/pulsar-2/blocks/${s_height}/transactions/${si_txn}`,
          text: "View on block explorer"
        } : null,
        pfp: g_coin.pfp
      };
    },
    async account_created(g_event) {
      const { time: xt_when, data: { account: p_account } } = g_event;
      const g_account = await Accounts.at(p_account);
      return {
        title: `Account created`,
        subtitle: `${format_time_ago(xt_when)} / ${g_account.name}`,
        name: g_account.name,
        icon: mk_icon(SX_ACC_CREATED),
        pfp: g_account.pfp || ""
      };
    },
    async receive(g_event) {
      const { time: xt_when, data: { height: s_height, amount: s_amount, chain: p_chain, coin: si_coin, recipient: sa_recipient, sender: sa_sender } } = g_event;
      const sa_other = sa_sender;
      const p_contact = Agents.pathForContact(sa_other);
      const g_contact = await Agents.getContact(p_contact);
      const g_chain = await Chains.at(p_chain);
      const g_coin = g_chain.coins[si_coin];
      const [, s_size] = R_TRANSFER_AMOUNT.exec(s_amount);
      const x_amount = new BigNumber(s_size).shiftedBy(-g_chain.coins[si_coin].decimals).toNumber();
      return {
        title: `Received ${g_coin.name}`,
        name: si_coin,
        icon: mk_icon(SX_RECV),
        subtitle: `${format_time_ago(xt_when)} / ${g_contact ? g_contact.name : abbreviate_addr(sa_other)}`,
        amount: `${format_amount(x_amount, true)} ${si_coin}`,
        pfp: g_coin.pfp
      };
    },
    transaction(g_event) {
    }
  };
  async function detail_event(g_event) {
    return await H_EVENT_MAP[g_event.type](g_event);
  }
  const click_handler2 = (g_detail) => open_external_link(g_detail.link.href);
  $$self.$$set = ($$props2) => {
    if ("events" in $$props2)
      $$invalidate(0, events = $$props2.events);
    if ("context" in $$props2)
      $$invalidate(2, context = $$props2.context);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [events, detail_event, context, slots, click_handler2, $$scope];
}
class TxnList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { events: 0, context: 2 });
  }
}
function writableSync(w_value) {
  const yw_original = writable(w_value);
  return Object.assign(Object.create(yw_original), {
    set(w_set) {
      w_value = w_set;
      return yw_original.set(w_set);
    },
    get() {
      return w_value;
    }
  });
}
function derivedSync(z_src, f_transform) {
  if (Array.isArray(z_src)) {
    return Object.assign(Object.create(derived(z_src, f_transform)), {
      get() {
        return f_transform(...z_src);
      }
    });
  } else {
    let w_cache;
    const yw_original = derived(z_src, (w_input, fk_set) => {
      f_transform(w_input, (w_output) => {
        w_cache = w_output;
        fk_set(w_output);
      });
    });
    return Object.assign(Object.create(yw_original), {
      get() {
        return w_cache;
      }
    });
  }
}
const yw_navigator = writableSync(null);
const yw_chain_ref = writableSync("");
const yw_chain = derivedSync(yw_chain_ref, (p_chain, fk_set) => {
  void Chains.read().then((ks) => fk_set(ks.at(p_chain)));
  void Networks.read().then((ks) => ks.entries().some(([p_network, g_network]) => {
    if (p_chain === g_network.chain) {
      yw_network_ref.set(p_network);
      return true;
    }
    return false;
  }));
});
const yw_network_ref = writableSync("");
const yw_network = writableSync(null);
const yw_network_active = derivedSync(yw_network_ref, (p_network, fk_set) => {
  if (!p_network) {
    yw_network.set(null);
    fk_set(null);
  } else {
    (async () => {
      const ks_networks = await Networks.read();
      const g_network = ks_networks.at(p_network);
      yw_network.set(g_network);
      if (g_network.chain !== yw_chain_ref.get()) {
        yw_chain_ref.set(g_network.chain);
      }
      const ks_chains = await Chains.read();
      const g_chain = ks_chains.at(g_network.chain);
      fk_set(Networks.activate(g_network, g_chain));
    })();
  }
});
const yw_family = writableSync("");
yw_chain.subscribe((g_chain) => yw_family.set(g_chain?.family || ""));
const yw_account_ref = writableSync("");
const yw_account = derivedSync(yw_account_ref, (p_account, fk_set) => {
  void Accounts.read().then((ks) => fk_set(ks.at(p_account)));
});
const yw_owner = derived([yw_account, yw_chain], ([g_account, g_chain], fk_set) => {
  fk_set(Chains.addressFor(g_account.pubkey, g_chain));
});
const yw_menu_vendor = writableSync(false);
const yw_overlay_account = writableSync(false);
const yw_overlay_network = writableSync(false);
const store_cache = (si_store) => writableSync(null);
async function reload(si_store) {
  switch (si_store) {
    case SI_STORE_MEDIA: {
      const ks_medias = await Medias.read();
      yw_store_medias.update(() => ks_medias);
      break;
    }
    case SI_STORE_TAGS: {
      const ks_tags = await Tags.read();
      yw_store_tags.update(() => ks_tags);
    }
  }
}
const yw_store_medias = store_cache();
const yw_store_tags = store_cache();
global_receive({
  "updateStore"({ key: si_store }) {
    void reload(si_store);
  }
});
async function initialize_caches() {
  await Promise.all([
    reload(SI_STORE_MEDIA),
    reload(SI_STORE_TAGS)
  ]);
}
const yw_page = writableSync(null);
const yw_thread = writableSync(null);
const yw_path = writableSync("");
derivedSync(yw_path, ($yw) => `s2r://root/${$yw}`);
writableSync("");
const yw_notifications = writableSync([]);
const yw_nav_collapsed = writable(false);
const yw_nav_visible = writableSync(false);
const yw_progress = writableSync([0, 0]);
const yw_search = writable("");
const yw_cancel_search = writableSync(F_NOOP);
writableSync(null);
writableSync(0);
writableSync([]);
const yw_header_props = writableSync({});
writableSync(null);
const yw_menu_expanded = writableSync(false);
const yw_overscroll_pct = writableSync(0);
const yw_context_popup = writableSync(null);
const yw_popup = writableSync(null);
function popup_receive(p_account) {
  yw_context_popup.set({
    account: p_account
  });
  yw_popup.set(PopupReceive);
}
const yw_blur = writableSync(false);
void once_store_updates(yw_navigator).then(() => {
  const d_style_root = document.documentElement.style;
  window.addEventListener("resize", () => {
    d_style_root.setProperty("--app-window-width", `${window.innerWidth}px`);
    d_style_root.setProperty("--app-window-height", `${window.innerHeight}px`);
  });
  window.dispatchEvent(new Event("resize"));
  window.addEventListener("keydown", (d_event) => {
    if ("Escape" === d_event.key) {
      if (yw_popup.get()) {
        yw_popup.set(null);
      }
    }
  });
});
const $_EXISTING = Symbol("use-existing-cache");
const H_REGISTRY = {
  [P_PUBLIC_SUFFIX_LIST]: {
    format: "text",
    parse(sx_data) {
      if (!sx_data)
        return $_EXISTING;
      const a_suffixes = [];
      for (let sx_line of sx_data.split(/\n/g)) {
        sx_line = sx_line.replace(/\s+|\/\/.*$/, "");
        if (sx_line)
          a_suffixes.push(sx_line);
      }
      return a_suffixes;
    }
  },
  [P_STARSHELL_DECREES]: {
    format: "json",
    filter(z_data) {
      return z_data.filter((g_decree) => {
        return true;
      });
    }
  }
};
async function put(p_res, g_cache) {
  return await chrome.storage.local.set({ [`@cache:${p_res}`]: g_cache });
}
async function get_cache(p_res) {
  const si_key = `@cache:${p_res}`;
  return (await chrome.storage.local.get([si_key]))[si_key];
}
class WebResourceCache {
  static async updateAll() {
    for (const p_res in H_REGISTRY) {
      const g_entry = H_REGISTRY[p_res];
      const d_res = await fetch(p_res);
      switch (g_entry.format) {
        case "text": {
          const s_data = await d_res.text();
          const z_parsed = g_entry.parse(s_data);
          if ($_EXISTING === z_parsed)
            continue;
          await put(p_res, {
            etag: d_res.headers.get("etag") ?? "",
            data: s_data
          });
          break;
        }
        case "json": {
          let w_data = await d_res.json();
          if ("filter" in g_entry) {
            w_data = g_entry.filter(w_data);
          }
          await put(p_res, {
            etag: d_res.headers.get("etag") ?? "",
            data: w_data
          });
          break;
        }
      }
    }
  }
  static async get(p_res) {
    return (await get_cache(p_res))?.data || null;
  }
}
export { run_all as $, ActionsLine as A, open_external_link as B, CheckboxField as C, qs as D, Events as E, global_receive as F, initialize_caches as G, yw_navigator as H, ode as I, register as J, login as K, F_NOOP as L, set_style as M, create_slot as N, toggle_class as O, P_STARSHELL_DECREES as P, append as Q, listen as R, SvelteComponent as S, update_slot_base as T, get_all_dirty_from_scope as U, Vault as V, WebResourceCache as W, XT_SECONDS as X, get_slot_changes as Y, group_outros as Z, check_outros as _, transition_out as a, syserr as a$, yw_nav_visible as a0, yw_blur as a1, compute_slots as a2, getContext as a3, createEventDispatcher as a4, onMount as a5, bubble as a6, src_url_equal as a7, set_data as a8, create_out_transition as a9, ATU8_DUMMY_VECTOR as aA, AlreadyRegisteredError as aB, InvalidPassphraseError as aC, add_render_callback as aD, create_bidirectional_transition as aE, slide as aF, yw_owner as aG, load_pfps as aH, Entities as aI, StarSelect as aJ, yw_network_active as aK, BigNumber as aL, XT_MINUTES as aM, CoinGecko as aN, format_amount as aO, oderac as aP, yw_family as aQ, subscribe_store as aR, onDestroy as aS, Agents as aT, Address as aU, Select as aV, format_fiat as aW, SX_ICON_DROPDOWN as aX, fold as aY, Portrait as aZ, oderom as a_, yw_search as aa, yw_cancel_search as ab, yw_thread as ac, yw_menu_vendor as ad, yw_overlay_network as ae, yw_chain as af, yw_chain_ref as ag, yw_overlay_account as ah, yw_account as ai, empty as aj, assign as ak, PfpDisplay as al, get_spread_update as am, get_spread_object as an, Close as ao, set_input_value as ap, handle_promise as aq, Chains as ar, update_await_block_branch as as, destroy_each as at, Row as au, acceptable as av, Field as aw, NL_PASSPHRASE_MINIMUM as ax, NL_PASSPHRASE_MAXIMUM as ay, ATU8_DUMMY_PHRASE as az, component_subscribe as b, popup_receive as b0, forever as b1, Info as b2, SubHeader as b3, setContext as b4, afterUpdate as b5, writable as b6, tick as b7, Pfps as b8, ofe as b9, yw_network_ref as bA, once_store_updates as bB, timeout as bC, UnregisteredError as bD, RecoverableVaultError as bE, CorruptedVaultError as bF, P_PUBLIC_SUFFIX_LIST as bG, R_DOMAIN_LOCALHOST as bH, R_DOMAIN_IP as bI, session_storage_remove as bJ, create_store_class as bK, SI_STORE_APP_POLICIES as bL, WritableStore as bM, SI_STORE_SETTINGS as bN, WritableStoreDict as bO, session_storage_get as bP, global_broadcast as bQ, fold_attrs as bR, R_TRANSFER_AMOUNT as bS, syswarn as bT, abbreviate_addr as bU, sha256_sync$1 as bV, text_to_buffer as bW, ContactAgentType as ba, R_BECH32 as bb, InlineTags as bc, proper as bd, SX_ICON_EDIT$1 as be, SX_ICON_DELETE as bf, quintOut as bg, Apps as bh, Networks as bi, TxnList as bj, svg_element as bk, yw_overscroll_pct as bl, yw_popup as bm, yw_page as bn, yw_menu_expanded as bo, yw_notifications as bp, yw_nav_collapsed as bq, HtmlTag as br, yw_header_props as bs, yw_progress as bt, SX_ICON_CLOSE as bu, logout as bv, yw_network as bw, dd as bx, objects_might_differ as by, getAllContexts as bz, create_component as c, destroy_component as d, binding_callbacks as e, bind as f, space as g, element as h, init as i, insert as j, add_flush_callback as k, detach as l, mount_component as m, Secp256k1Key as n, Secrets as o, buffer_to_string8 as p, buffer_to_base64 as q, set_store_value as r, safe_not_equal as s, transition_in as t, Accounts as u, text as v, attr as w, noop$1 as x, yw_account_ref as y, SI_VERSION as z };
