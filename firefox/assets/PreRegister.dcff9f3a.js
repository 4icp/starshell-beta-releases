var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { S as SvelteComponent, i as init, s as safe_not_equal, h as element, M as set_style, j as insert, x as noop, l as detach, N as create_slot, g as space, w as attr, O as toggle_class, Q as append, R as listen, T as update_slot_base, U as get_all_dirty_from_scope, Y as get_slot_changes, t as transition_in, Z as group_outros, a as transition_out, _ as check_outros, $ as run_all, b as component_subscribe, a0 as yw_nav_visible, a1 as yw_blur, a2 as compute_slots, a3 as getContext, a4 as createEventDispatcher, a5 as onMount, r as set_store_value, a6 as bubble, e as binding_callbacks, a7 as src_url_equal, v as text, a8 as set_data, a9 as create_out_transition, aa as yw_search, ab as yw_cancel_search, ac as yw_thread, ad as yw_menu_vendor, ae as yw_overlay_network, af as yw_chain, ag as yw_chain_ref, ah as yw_overlay_account, ai as yw_account, y as yw_account_ref, aj as empty, ak as assign, al as PfpDisplay, c as create_component, m as mount_component, am as get_spread_update, an as get_spread_object, d as destroy_component, f as bind, k as add_flush_callback, ao as Close, ap as set_input_value, D as qs, aq as handle_promise, ar as Chains, as as update_await_block_branch, u as Accounts, at as destroy_each, au as Row, A as ActionsLine, av as acceptable, aw as Field, ax as NL_PASSPHRASE_MINIMUM, ay as NL_PASSPHRASE_MAXIMUM, V as Vault, az as ATU8_DUMMY_PHRASE, aA as ATU8_DUMMY_VECTOR, J as register$1, aB as AlreadyRegisteredError, aC as InvalidPassphraseError, K as login, aD as add_render_callback, aE as create_bidirectional_transition, aF as slide, aG as yw_owner, aH as load_pfps, I as ode, aI as Entities, aJ as StarSelect, aK as yw_network_active, aL as BigNumber, aM as XT_MINUTES, aN as CoinGecko, aO as format_amount, aP as oderac, aQ as yw_family, aR as subscribe_store, aS as onDestroy, aT as Agents, aU as Address, aV as Select, H as yw_navigator, E as Events, aW as format_fiat, aX as SX_ICON_DROPDOWN, aY as fold, C as CheckboxField, aZ as Portrait, a_ as oderom, a$ as syserr, b0 as popup_receive, B as open_external_link, b1 as forever, b2 as Info, b3 as SubHeader, b4 as setContext, b5 as afterUpdate, b6 as writable, b7 as tick, b8 as Pfps, L as F_NOOP, b9 as ofe, ba as ContactAgentType, bb as R_BECH32, bc as InlineTags, bd as proper, be as SX_ICON_EDIT, bf as SX_ICON_DELETE, bg as quintOut, bh as Apps, bi as Networks, F as global_receive, bj as TxnList, bk as svg_element, bl as yw_overscroll_pct, bm as yw_popup, bn as yw_page, bo as yw_menu_expanded, bp as yw_notifications, bq as yw_nav_collapsed, br as HtmlTag, bs as yw_header_props, bt as yw_progress, bu as SX_ICON_CLOSE, bv as logout, z as SI_VERSION, bw as yw_network, bx as dd, by as objects_might_differ, bz as getAllContexts, bA as yw_network_ref, bB as once_store_updates, bC as timeout, bD as UnregisteredError, bE as RecoverableVaultError, bF as CorruptedVaultError } from "./web-resource-cache.849924ed.js";
var global = "";
function create_fragment$M(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      set_style(span, "display", "none");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
class Blank extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$M, safe_not_equal, {});
  }
}
const get_help_slot_changes = (dirty) => ({});
const get_help_slot_context = (ctx) => ({});
function create_if_block$j(ctx) {
  let div;
  let current;
  const help_slot_template = ctx[21].help;
  const help_slot = create_slot(help_slot_template, ctx, ctx[20], get_help_slot_context);
  return {
    c() {
      div = element("div");
      if (help_slot)
        help_slot.c();
      attr(div, "class", "display_none");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (help_slot) {
        help_slot.m(div, null);
      }
      ctx[23](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (help_slot) {
        if (help_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            help_slot,
            help_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(help_slot_template, ctx2[20], dirty, get_help_slot_changes),
            get_help_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(help_slot, local);
      current = true;
    },
    o(local) {
      transition_out(help_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (help_slot)
        help_slot.d(detaching);
      ctx[23](null);
    }
  };
}
function create_fragment$L(ctx) {
  let div;
  let form_1;
  let t;
  let form_1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[21].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
  let if_block = "help" in ctx[10] && create_if_block$j(ctx);
  return {
    c() {
      div = element("div");
      form_1 = element("form");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(form_1, "class", form_1_class_value = "screen " + ctx[1] + " svelte-re7ihy");
      attr(form_1, "data-s2-exit", ctx[9]);
      attr(form_1, "style", ctx[3]);
      attr(form_1, "autocomplete", "off");
      toggle_class(form_1, "flex", true);
      toggle_class(form_1, "scroll", true);
      toggle_class(form_1, "nav", ctx[7]);
      toggle_class(form_1, "progress", ctx[0]);
      toggle_class(form_1, "transparent", ctx[2]);
      toggle_class(form_1, "sublimate", false);
      toggle_class(form_1, "blur", ctx[6]);
      attr(div, "class", "bounds svelte-re7ihy");
      toggle_class(div, "slides", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form_1);
      if (default_slot) {
        default_slot.m(form_1, null);
      }
      append(form_1, t);
      if (if_block)
        if_block.m(form_1, null);
      ctx[24](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(form_1, "submit", submit_handler_1),
          listen(form_1, "submit", ctx[22])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null),
            null
          );
        }
      }
      if ("help" in ctx2[10]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$j(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(form_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 2 && form_1_class_value !== (form_1_class_value = "screen " + ctx2[1] + " svelte-re7ihy")) {
        attr(form_1, "class", form_1_class_value);
      }
      if (!current || dirty & 8) {
        attr(form_1, "style", ctx2[3]);
      }
      if (dirty & 2) {
        toggle_class(form_1, "flex", true);
      }
      if (dirty & 2) {
        toggle_class(form_1, "scroll", true);
      }
      if (dirty & 130) {
        toggle_class(form_1, "nav", ctx2[7]);
      }
      if (dirty & 3) {
        toggle_class(form_1, "progress", ctx2[0]);
      }
      if (dirty & 6) {
        toggle_class(form_1, "transparent", ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(form_1, "sublimate", false);
      }
      if (dirty & 66) {
        toggle_class(form_1, "blur", ctx2[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const submit_handler_1 = (d_event) => void d_event.preventDefault();
function instance$I($$self, $$props, $$invalidate) {
  let $yw_nav_visible;
  let $yw_blur;
  component_subscribe($$self, yw_nav_visible, ($$value) => $$invalidate(25, $yw_nav_visible = $$value));
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(6, $yw_blur = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { nav = false } = $$props;
  const b_nav = nav;
  let { debug = "" } = $$props;
  let { progress = null } = $$props;
  let { full = false } = $$props;
  let { keyed = false } = $$props;
  let { classNames = "" } = $$props;
  const k_page = getContext("page");
  let { leaves = false } = $$props;
  let { swipes = false } = $$props;
  let { root = 0 === k_page.index } = $$props;
  let { slides = !leaves && !swipes && !root } = $$props;
  const b_slides = slides;
  let { form = false } = $$props;
  let { transparent = false } = $$props;
  let dm_screen;
  let dm_help = null;
  const si_exit = leaves ? "leaves" : swipes ? "swipes" : "";
  createEventDispatcher();
  onMount(() => {
    if (!k_page) {
      console.warn(`${debug || "unknown"} Screen missing page context`);
    } else {
      k_page.on({
        focus() {
          set_store_value(yw_nav_visible, $yw_nav_visible = b_nav, $yw_nav_visible);
        }
      });
    }
    if (keyed) {
      let x_scroll_top = 0;
      new MutationObserver(async (a_mutations) => {
        if (a_mutations[0]?.addedNodes.length) {
          try {
            x_scroll_top = dm_screen.scrollTop;
          } catch (e_null) {
          }
        } else if (a_mutations[0]?.removedNodes.length) {
          if (dm_screen) {
            $$invalidate(4, dm_screen.scrollTop = x_scroll_top, dm_screen);
          }
        }
      }).observe(dm_screen, { childList: true });
    }
  });
  let { style = "" } = $$props;
  function submit_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_help = $$value;
      $$invalidate(5, dm_help);
    });
  }
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_screen = $$value;
      $$invalidate(4, dm_screen);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("nav" in $$props2)
      $$invalidate(11, nav = $$props2.nav);
    if ("debug" in $$props2)
      $$invalidate(12, debug = $$props2.debug);
    if ("progress" in $$props2)
      $$invalidate(0, progress = $$props2.progress);
    if ("full" in $$props2)
      $$invalidate(13, full = $$props2.full);
    if ("keyed" in $$props2)
      $$invalidate(14, keyed = $$props2.keyed);
    if ("classNames" in $$props2)
      $$invalidate(1, classNames = $$props2.classNames);
    if ("leaves" in $$props2)
      $$invalidate(15, leaves = $$props2.leaves);
    if ("swipes" in $$props2)
      $$invalidate(16, swipes = $$props2.swipes);
    if ("root" in $$props2)
      $$invalidate(17, root = $$props2.root);
    if ("slides" in $$props2)
      $$invalidate(18, slides = $$props2.slides);
    if ("form" in $$props2)
      $$invalidate(19, form = $$props2.form);
    if ("transparent" in $$props2)
      $$invalidate(2, transparent = $$props2.transparent);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  return [
    progress,
    classNames,
    transparent,
    style,
    dm_screen,
    dm_help,
    $yw_blur,
    b_nav,
    b_slides,
    si_exit,
    $$slots,
    nav,
    debug,
    full,
    keyed,
    leaves,
    swipes,
    root,
    slides,
    form,
    $$scope,
    slots,
    submit_handler2,
    div_binding,
    form_1_binding
  ];
}
class Screen extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$L, safe_not_equal, {
      nav: 11,
      debug: 12,
      progress: 0,
      full: 13,
      keyed: 14,
      classNames: 1,
      leaves: 15,
      swipes: 16,
      root: 17,
      slides: 18,
      form: 19,
      transparent: 2,
      style: 3
    });
  }
}
function create_fragment$K(ctx) {
  let picture;
  let source;
  let t;
  let img;
  let img_src_value;
  let mounted;
  let dispose;
  return {
    c() {
      picture = element("picture");
      source = element("source");
      t = space();
      img = element("img");
      attr(source, "srcset", ctx[3]);
      attr(source, "media", "(min-resolution: 2dppx)");
      attr(img, "alt", ctx[1]);
      if (!src_url_equal(img.src, img_src_value = ctx[2]))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-5d3u97");
      attr(picture, "class", "no-margin logo svelte-5d3u97");
      set_style(picture, "width", ctx[0] + "px");
      set_style(picture, "height", ctx[0] + "px");
    },
    m(target, anchor) {
      insert(target, picture, anchor);
      append(picture, source);
      append(picture, t);
      append(picture, img);
      if (!mounted) {
        dispose = listen(picture, "click", ctx[6]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(picture);
      mounted = false;
      dispose();
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let { dim } = $$props;
  const x_dim = dim;
  let { alt = "StarShell logo" } = $$props;
  const s_alt = alt;
  const f_src = (x) => `/media/vendor/logo-${x}px.png`;
  const sr_default = f_src(x_dim);
  const sr_double = f_src(x_dim * 2);
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("dim" in $$props2)
      $$invalidate(4, dim = $$props2.dim);
    if ("alt" in $$props2)
      $$invalidate(5, alt = $$props2.alt);
  };
  return [x_dim, s_alt, sr_default, sr_double, dim, alt, click_handler2];
}
class StarShellLogo extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$K, safe_not_equal, { dim: 4, alt: 5 });
  }
}
const get_rows_slot_changes = (dirty) => ({});
const get_rows_slot_context = (ctx) => ({});
function create_fragment$J(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t0;
  let t1;
  let div1;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  const rows_slot_template = ctx[4].rows;
  const rows_slot = create_slot(rows_slot_template, ctx, ctx[3], get_rows_slot_context);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(ctx[1]);
      t1 = space();
      div1 = element("div");
      if (rows_slot)
        rows_slot.c();
      attr(h3, "class", "svelte-1f5uzt4");
      attr(div0, "class", "top svelte-1f5uzt4");
      attr(div1, "class", "rows svelte-1f5uzt4");
      attr(div2, "class", "overlay select svelte-1f5uzt4");
      attr(div3, "class", "cancel svelte-1f5uzt4");
      toggle_class(div3, "showing", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(h3, t0);
      append(div2, t1);
      append(div2, div1);
      if (rows_slot) {
        rows_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div3, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 2)
        set_data(t0, ctx2[1]);
      if (rows_slot) {
        if (rows_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            rows_slot,
            rows_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(rows_slot_template, ctx2[3], dirty, get_rows_slot_changes),
            get_rows_slot_context
          );
        }
      }
      if (dirty & 4) {
        toggle_class(div3, "showing", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rows_slot, local);
      if (div2_outro)
        div2_outro.end(1);
      current = true;
    },
    o(local) {
      transition_out(rows_slot, local);
      div2_outro = create_out_transition(div2, pause, {});
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (rows_slot)
        rows_slot.d(detaching);
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function pause(dm, gc) {
  return { duration: 200 };
}
function instance$G($$self, $$props, $$invalidate) {
  let $yw_blur;
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(6, $yw_blur = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { open = true } = $$props;
  let b_showing = false;
  setTimeout(
    () => {
      $$invalidate(2, b_showing = true);
    },
    10
  );
  const click_handler2 = () => {
    $$invalidate(2, b_showing = false);
    $$invalidate(0, open = false);
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      set_store_value(yw_blur, $yw_blur = open, $yw_blur);
    }
  };
  return [open, title, b_showing, $$scope, slots, click_handler2];
}
class OverlaySelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$J, safe_not_equal, { title: 1, open: 0 });
  }
}
var SX_ICON_ARROW_LEFT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-arrow-left-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-arrow-left-fg" d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"/>\n</svg>\n';
var SX_ICON_SEARCH = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-search-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-search-fg" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n</svg>\n';
var SX_CHECKED = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">\n	<style type="text/css">\n		.s2r-checked-circle-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n		.s2r-checked-circle-bg {\n			fill: var(--svg-color-bg, black);\n		}\n	</style>\n	<circle class="s2r-checked-circle-bg" cx="10" cy="10" r="8" />\n	<path class="s2r-checked-circle-fg" d="M10.0003 1.6665C5.40033 1.6665 1.66699 5.39984 1.66699 9.99984C1.66699 14.5998 5.40033 18.3332 10.0003 18.3332C14.6003 18.3332 18.3337 14.5998 18.3337 9.99984C18.3337 5.39984 14.6003 1.6665 10.0003 1.6665ZM8.33366 14.1665L4.16699 9.99984L5.34199 8.82484L8.33366 11.8082L14.6587 5.48317L15.8337 6.6665L8.33366 14.1665Z" />\n</svg>\n';
function get_each_context$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i][0];
  child_ctx[51] = list[i][1];
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[55] = list[i][0];
  child_ctx[56] = list[i][1];
  return child_ctx;
}
function create_if_block_11(ctx) {
  let starshelllogo;
  let current;
  starshelllogo = new StarShellLogo({
    props: {
      dim: 48,
      alt: "Click to view general status"
    }
  });
  starshelllogo.$on("click", ctx[35]);
  return {
    c() {
      create_component(starshelllogo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starshelllogo, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starshelllogo, detaching);
    }
  };
}
function create_if_block_10(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "class", "back svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_ARROW_LEFT;
      if (!mounted) {
        dispose = listen(span, "click", ctx[34]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_8(ctx) {
  let span;
  let t1;
  let if_block_anchor;
  let if_block = ctx[18] && create_if_block_9(ctx);
  return {
    c() {
      span = element("span");
      span.textContent = `${ctx[17]}`;
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "name svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[18])
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_9(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `- ${ctx[18]}`;
      attr(span, "class", "symbol svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_5$1(ctx) {
  let span;
  let previous_key = ctx[6];
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block_1$1(ctx);
  let if_block = ctx[5] && create_if_block_6(ctx);
  return {
    c() {
      span = element("span");
      key_block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "network svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      key_block.m(span, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[36]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64 && safe_not_equal(previous_key, previous_key = ctx2[6])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_1$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(span, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      key_block.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block_1$1(ctx) {
  let pfpdisplay;
  let current;
  const pfpdisplay_spread_levels = [{ resource: ctx[6] }, ctx[21](false)];
  let pfpdisplay_props = {};
  for (let i = 0; i < pfpdisplay_spread_levels.length; i += 1) {
    pfpdisplay_props = assign(pfpdisplay_props, pfpdisplay_spread_levels[i]);
  }
  pfpdisplay = new PfpDisplay({ props: pfpdisplay_props });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = dirty[0] & 2097216 ? get_spread_update(pfpdisplay_spread_levels, [
        dirty[0] & 64 && { resource: ctx2[6] },
        dirty[0] & 2097152 && get_spread_object(ctx2[21](false))
      ]) : {};
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let overlayselect;
  let updating_open;
  let current;
  function overlayselect_open_binding(value) {
    ctx[38](value);
  }
  let overlayselect_props = {
    title: "Switch Network",
    $$slots: { rows: [create_rows_slot_1] },
    $$scope: { ctx }
  };
  if (ctx[5] !== void 0) {
    overlayselect_props.open = ctx[5];
  }
  overlayselect = new OverlaySelect({ props: overlayselect_props });
  binding_callbacks.push(() => bind(overlayselect, "open", overlayselect_open_binding));
  return {
    c() {
      create_component(overlayselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayselect_changes = {};
      if (dirty[0] & 160 | dirty[1] & 268435456) {
        overlayselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty[0] & 32) {
        updating_open = true;
        overlayselect_changes.open = ctx2[5];
        add_flush_callback(() => updating_open = false);
      }
      overlayselect.$set(overlayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayselect, detaching);
    }
  };
}
function create_catch_block_1$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[54].entries();
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 160) {
        each_value_1 = ctx2[54].entries();
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_7(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "overlay-select icon svelte-1fcz7ql");
      set_style(span, "--icon-color", "var(--theme-color-primary)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_CHECKED;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_right_slot_1(ctx) {
  let t;
  let if_block = ctx[7] === ctx[55] && create_if_block_7();
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[7] === ctx2[55]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_7();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block_1$3(ctx) {
  let row;
  let current;
  function click_handler_3() {
    return ctx[37](ctx[55]);
  }
  row = new Row({
    props: {
      resource: ctx[56],
      detail: "Default Provider",
      $$slots: { right: [create_right_slot_1] },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_3);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 128 | dirty[1] & 268435456) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_rows_slot_1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1$1,
    then: create_then_block_1$1,
    catch: create_catch_block_1$1,
    value: 54,
    blocks: [, , ,]
  };
  handle_promise(Chains.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block_2$5(ctx) {
  let span;
  let previous_key = ctx[9];
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block$3(ctx);
  let if_block = ctx[8] && create_if_block_3$2(ctx);
  return {
    c() {
      span = element("span");
      key_block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "account svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      key_block.m(span, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[39]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512 && safe_not_equal(previous_key, previous_key = ctx2[9])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$3(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(span, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      key_block.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block$3(ctx) {
  let pfpdisplay;
  let current;
  const pfpdisplay_spread_levels = [{ resource: ctx[9] }, ctx[21](true)];
  let pfpdisplay_props = {};
  for (let i = 0; i < pfpdisplay_spread_levels.length; i += 1) {
    pfpdisplay_props = assign(pfpdisplay_props, pfpdisplay_spread_levels[i]);
  }
  pfpdisplay = new PfpDisplay({ props: pfpdisplay_props });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = dirty[0] & 2097664 ? get_spread_update(pfpdisplay_spread_levels, [
        dirty[0] & 512 && { resource: ctx2[9] },
        dirty[0] & 2097152 && get_spread_object(ctx2[21](true))
      ]) : {};
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_3$2(ctx) {
  let overlayselect;
  let updating_open;
  let current;
  function overlayselect_open_binding_1(value) {
    ctx[41](value);
  }
  let overlayselect_props = {
    title: "Switch Account",
    $$slots: { rows: [create_rows_slot] },
    $$scope: { ctx }
  };
  if (ctx[8] !== void 0) {
    overlayselect_props.open = ctx[8];
  }
  overlayselect = new OverlaySelect({ props: overlayselect_props });
  binding_callbacks.push(() => bind(overlayselect, "open", overlayselect_open_binding_1));
  return {
    c() {
      create_component(overlayselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayselect_changes = {};
      if (dirty[0] & 1280 | dirty[1] & 268435456) {
        overlayselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty[0] & 256) {
        updating_open = true;
        overlayselect_changes.open = ctx2[8];
        add_flush_callback(() => updating_open = false);
      }
      overlayselect.$set(overlayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayselect, detaching);
    }
  };
}
function create_catch_block$c(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$c(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[49].entries();
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1280) {
        each_value = ctx2[49].entries();
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_4$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "overlay-select icon svelte-1fcz7ql");
      set_style(span, "--icon-color", "var(--theme-color-primary)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_CHECKED;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_right_slot(ctx) {
  let t;
  let if_block = ctx[10] === ctx[50] && create_if_block_4$1();
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[10] === ctx2[50]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$1();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_icon_slot(ctx) {
  let pfpdisplay;
  let t;
  let current;
  pfpdisplay = new PfpDisplay({
    props: { dim: 32, resource: ctx[51] }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$9(ctx) {
  let row;
  let current;
  function click_handler_5() {
    return ctx[40](ctx[50]);
  }
  row = new Row({
    props: {
      resource: ctx[51],
      resourcePath: ctx[50],
      detail: ctx[51].extra?.total_fiat_cache ?? "(?)",
      $$slots: {
        icon: [create_icon_slot],
        right: [create_right_slot]
      },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_5);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 1024 | dirty[1] & 268435456) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$c(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_rows_slot(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$c,
    then: create_then_block$c,
    catch: create_catch_block$c,
    value: 49,
    blocks: [, , ,]
  };
  handle_promise(Accounts.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block_1$a(ctx) {
  let close;
  let current;
  close = new Close({});
  close.$on("click", ctx[42]);
  return {
    c() {
      create_component(close.$$.fragment);
    },
    m(target, anchor) {
      mount_component(close, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(close, detaching);
    }
  };
}
function create_if_block$i(ctx) {
  let div;
  let input;
  let t;
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      span = element("span");
      attr(input, "type", "text");
      input.autofocus = ctx[0];
      attr(input, "placeholder", "Search anything: token, account, contact, txn...");
      attr(span, "class", "action svelte-1fcz7ql");
      attr(div, "class", "search svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[3]);
      ctx[44](input);
      append(div, t);
      append(div, span);
      span.innerHTML = SX_ICON_SEARCH;
      if (ctx[0])
        input.focus();
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[43]),
          listen(input, "input", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1) {
        input.autofocus = ctx2[0];
      }
      if (dirty[0] & 8 && input.value !== ctx2[3]) {
        set_input_value(input, ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[44](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$I(ctx) {
  let div3;
  let div2;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span0;
  let div0;
  let t1;
  let div1;
  let t3;
  let span2;
  let span1;
  let t4;
  let t5;
  let t6;
  let current;
  const if_block_creators = [create_if_block_10, create_if_block_11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[11])
      return 0;
    if (!ctx2[12] && !ctx2[13])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[17] && create_if_block_8(ctx);
  let if_block2 = ctx[15] && create_if_block_5$1(ctx);
  let if_block3 = ctx[14] && create_if_block_2$5(ctx);
  let if_block4 = ctx[12] && create_if_block_1$a(ctx);
  let if_block5 = ctx[16] && create_if_block$i(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span0 = element("span");
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      div1.textContent = `${ctx[19]}`;
      t3 = space();
      span2 = element("span");
      span1 = element("span");
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (if_block5)
        if_block5.c();
      attr(div0, "class", "title svelte-1fcz7ql");
      attr(div1, "class", "subtitle svelte-1fcz7ql");
      attr(span0, "class", "main svelte-1fcz7ql");
      attr(span1, "class", "cluster svelte-1fcz7ql");
      attr(span2, "class", "right svelte-1fcz7ql");
      toggle_class(span2, "heightless", !ctx[15] && ctx[12]);
      attr(div2, "class", "top svelte-1fcz7ql");
      attr(div3, "class", "header svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      append(div2, t0);
      append(div2, span0);
      append(span0, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append(span0, t1);
      append(span0, div1);
      append(div2, t3);
      append(div2, span2);
      append(span2, span1);
      if (if_block2)
        if_block2.m(span1, null);
      append(span1, t4);
      if (if_block3)
        if_block3.m(span1, null);
      append(span2, t5);
      if (if_block4)
        if_block4.m(span2, null);
      append(div3, t6);
      if (if_block5)
        if_block5.m(div3, null);
      ctx[45](div3);
      current = true;
    },
    p(ctx2, dirty) {
      if (if_block0)
        if_block0.p(ctx2, dirty);
      if (ctx2[17])
        if_block1.p(ctx2, dirty);
      if (ctx2[15])
        if_block2.p(ctx2, dirty);
      if (ctx2[14])
        if_block3.p(ctx2, dirty);
      if (ctx2[12])
        if_block4.p(ctx2, dirty);
      if (ctx2[16])
        if_block5.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      ctx[45](null);
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let $yw_search;
  let $yw_cancel_search;
  let $yw_thread;
  let $yw_menu_vendor;
  let $yw_overlay_network;
  let $yw_chain;
  let $yw_chain_ref;
  let $yw_overlay_account;
  let $yw_account;
  let $yw_account_ref;
  component_subscribe($$self, yw_search, ($$value) => $$invalidate(46, $yw_search = $$value));
  component_subscribe($$self, yw_cancel_search, ($$value) => $$invalidate(47, $yw_cancel_search = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(48, $yw_thread = $$value));
  component_subscribe($$self, yw_menu_vendor, ($$value) => $$invalidate(4, $yw_menu_vendor = $$value));
  component_subscribe($$self, yw_overlay_network, ($$value) => $$invalidate(5, $yw_overlay_network = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(6, $yw_chain = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(7, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_overlay_account, ($$value) => $$invalidate(8, $yw_overlay_account = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(9, $yw_account = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(10, $yw_account_ref = $$value));
  let { pops = false } = $$props;
  const b_pops = pops;
  let { exits = false } = $$props;
  const b_exits = exits;
  let { plain = false } = $$props;
  const b_plain = plain;
  let { account = false } = $$props;
  const b_account = account;
  let { network = false } = $$props;
  const b_network = network;
  let { search: search2 = false } = $$props;
  const b_search = search2;
  let { title = "" } = $$props;
  const s_title = title;
  let { symbol = "" } = $$props;
  const s_symbol = symbol;
  let { subtitle = "" } = $$props;
  const s_subtitle = subtitle;
  const dispatch = createEventDispatcher();
  const overlay_pfp_props = (b_mirror = false) => ({
    dim: 21,
    bg: "satin",
    genStyle: "font-size:21px; outline:none;",
    rootStyle: `
			padding: 5px 6px;
			border: 2px solid var(--theme-color-border);
			border-radius: ${b_mirror ? "0 4px 4px 0" : "4px 0 0 4px"};
		`.replace(/\s+/g, " ")
  });
  const k_page = getContext("page");
  let dm_header;
  let dm_search;
  let { isSearchScreen = false } = $$props;
  let { search_input = "" } = $$props;
  let s_search = $yw_search;
  yw_search.subscribe((s_value) => {
    if (isSearchScreen && s_value) {
      console.log("search screen and search text");
      $$invalidate(3, s_search = s_value);
      if (dm_search) {
        setTimeout(
          () => {
            dm_search.focus();
          },
          0
        );
      }
    } else if (!s_value) {
      $$invalidate(3, s_search = "");
    }
  });
  function update_search(d_event) {
    if (isSearchScreen) {
      if (!s_search) {
        set_store_value(yw_search, $yw_search = "", $yw_search);
        $yw_cancel_search();
      } else {
        dispatch("search", s_search);
      }
    } else if (s_search) {
      $yw_thread.id;
      const dm_focus = qs(dm_header, ":focus");
      if (dm_focus) {
        dm_focus.blur();
      }
      set_store_value(
        yw_cancel_search,
        $yw_cancel_search = () => {
          $$invalidate(3, s_search = "");
          console.log("stealing focus for cancel search");
          dm_search.focus();
        },
        $yw_cancel_search
      );
      set_store_value(yw_search, $yw_search = s_search, $yw_search);
    }
  }
  const click_handler2 = () => k_page.pop();
  const click_handler_1 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = true, $yw_menu_vendor);
  const click_handler_2 = (d_event) => {
    d_event.stopPropagation();
    set_store_value(yw_overlay_network, $yw_overlay_network = !$yw_overlay_network, $yw_overlay_network);
  };
  const click_handler_3 = (p_chain) => {
    set_store_value(yw_chain_ref, $yw_chain_ref = p_chain, $yw_chain_ref);
    set_store_value(yw_overlay_network, $yw_overlay_network = false, $yw_overlay_network);
  };
  function overlayselect_open_binding(value) {
    $yw_overlay_network = value;
    yw_overlay_network.set($yw_overlay_network);
  }
  const click_handler_4 = (d_event) => {
    d_event.stopPropagation();
    set_store_value(yw_overlay_account, $yw_overlay_account = !$yw_overlay_account, $yw_overlay_account);
  };
  const click_handler_5 = (p_account) => {
    set_store_value(yw_account_ref, $yw_account_ref = p_account, $yw_account_ref);
    set_store_value(yw_overlay_account, $yw_overlay_account = false, $yw_overlay_account);
  };
  function overlayselect_open_binding_1(value) {
    $yw_overlay_account = value;
    yw_overlay_account.set($yw_overlay_account);
  }
  const click_handler_6 = () => dispatch("close");
  function input_input_handler() {
    s_search = this.value;
    $$invalidate(3, s_search);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_search = $$value;
      $$invalidate(2, dm_search);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_header = $$value;
      $$invalidate(1, dm_header);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("pops" in $$props2)
      $$invalidate(24, pops = $$props2.pops);
    if ("exits" in $$props2)
      $$invalidate(25, exits = $$props2.exits);
    if ("plain" in $$props2)
      $$invalidate(26, plain = $$props2.plain);
    if ("account" in $$props2)
      $$invalidate(27, account = $$props2.account);
    if ("network" in $$props2)
      $$invalidate(28, network = $$props2.network);
    if ("search" in $$props2)
      $$invalidate(29, search2 = $$props2.search);
    if ("title" in $$props2)
      $$invalidate(30, title = $$props2.title);
    if ("symbol" in $$props2)
      $$invalidate(31, symbol = $$props2.symbol);
    if ("subtitle" in $$props2)
      $$invalidate(32, subtitle = $$props2.subtitle);
    if ("isSearchScreen" in $$props2)
      $$invalidate(0, isSearchScreen = $$props2.isSearchScreen);
    if ("search_input" in $$props2)
      $$invalidate(33, search_input = $$props2.search_input);
  };
  return [
    isSearchScreen,
    dm_header,
    dm_search,
    s_search,
    $yw_menu_vendor,
    $yw_overlay_network,
    $yw_chain,
    $yw_chain_ref,
    $yw_overlay_account,
    $yw_account,
    $yw_account_ref,
    b_pops,
    b_exits,
    b_plain,
    b_account,
    b_network,
    b_search,
    s_title,
    s_symbol,
    s_subtitle,
    dispatch,
    overlay_pfp_props,
    k_page,
    update_search,
    pops,
    exits,
    plain,
    account,
    network,
    search2,
    title,
    symbol,
    subtitle,
    search_input,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    overlayselect_open_binding,
    click_handler_4,
    click_handler_5,
    overlayselect_open_binding_1,
    click_handler_6,
    input_input_handler,
    input_binding,
    div3_binding
  ];
}
class Header extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$F,
      create_fragment$I,
      safe_not_equal,
      {
        pops: 24,
        exits: 25,
        plain: 26,
        account: 27,
        network: 28,
        search: 29,
        title: 30,
        symbol: 31,
        subtitle: 32,
        isSearchScreen: 0,
        search_input: 33
      },
      null,
      [-1, -1]
    );
  }
}
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_if_block_1$9(ctx) {
  let span2;
  let span0;
  let t0;
  let t1_value = format_ms(ctx[2].value.offset) + "";
  let t1;
  let t2;
  let t3;
  let span1;
  let t4_value = ctx[2].value.message + "";
  let t4;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = text("+");
      t1 = text(t1_value);
      t2 = text("ms:");
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      attr(span0, "class", "offset");
      attr(span1, "class", "message");
      attr(span2, "class", "event");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span0, t0);
      append(span0, t1);
      append(span0, t2);
      append(span2, t3);
      append(span2, span1);
      append(span1, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = format_ms(ctx2[2].value.offset) + ""))
        set_data(t1, t1_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx2[2].value.message + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(span2);
    }
  };
}
function create_if_block$h(ctx) {
  let span;
  let t_value = ctx[2].value + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "string");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[2].value + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$8(ctx) {
  let li;
  let t;
  function select_block_type(ctx2, dirty) {
    if ("string" === ctx2[2].type)
      return create_if_block$h;
    if ("event" === ctx2[2].type)
      return create_if_block_1$9;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      li = element("li");
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (if_block)
        if_block.m(li, null);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(li, t);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_fragment$H(ctx) {
  let div;
  let ol;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "log-container svelte-13jddbg");
      toggle_class(div, "display_none", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ol, null);
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ol, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        toggle_class(div, "display_none", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
class Logger {
  constructor() {
    this._a_items = [];
  }
  get items() {
    return this._a_items;
  }
  set items(a_items) {
    this._a_items = a_items;
  }
  event(s_msg, xt_offset) {
    this._a_items.push({
      type: "event",
      value: { message: s_msg, offset: xt_offset }
    });
    return this;
  }
}
function format_ms(n_ms) {
  return (n_ms / 1e3).toFixed(2).padStart(5, "0");
}
function instance$E($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { hide = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("hide" in $$props2)
      $$invalidate(1, hide = $$props2.hide);
  };
  return [items, hide];
}
class Log extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$H, safe_not_equal, { items: 0, hide: 1 });
  }
}
function create_fragment$G(ctx) {
  let div;
  let img;
  let img_src_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      attr(img, "alt", "StarShell title");
      if (!src_url_equal(img.src, img_src_value = "/media/vendor/title.svg"))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-1htd4i8");
      attr(div, "class", "no-margin title svelte-1htd4i8");
      set_style(div, "width", ctx[0] + "px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  let { width = 180 } = $$props;
  const x_width = width;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
  };
  return [x_width, width];
}
class StarShellTitle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$G, safe_not_equal, { width: 1 });
  }
}
function create_default_slot$j(ctx) {
  let h3;
  let t1;
  let p0;
  let t3;
  let p1;
  let t5;
  let p2;
  let t7;
  let actionsline;
  let current;
  actionsline = new ActionsLine({
    props: {
      cancel: "pop",
      confirm: ["Use anyway", ctx[0]],
      wait: 5e3
    }
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Weak Password Warning";
      t1 = space();
      p0 = element("p");
      p0.textContent = "The password you entered was found on a list of the top ten thousand most commonly used passwords.";
      t3 = space();
      p1 = element("p");
      p1.textContent = "In order to help prevent the loss of funds, you are encouraged to create a strong, unique password.";
      t5 = space();
      p2 = element("p");
      p2.textContent = "How do you want to proceed?";
      t7 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, p0, anchor);
      insert(target, t3, anchor);
      insert(target, p1, anchor);
      insert(target, t5, anchor);
      insert(target, p2, anchor);
      insert(target, t7, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t7);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$F(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 32) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let { attempt_register } = $$props;
  let { weakness } = $$props;
  const k_page = getContext("page");
  function use_anyway() {
    attempt_register();
    k_page.pop();
  }
  $$self.$$set = ($$props2) => {
    if ("attempt_register" in $$props2)
      $$invalidate(1, attempt_register = $$props2.attempt_register);
    if ("weakness" in $$props2)
      $$invalidate(2, weakness = $$props2.weakness);
  };
  return [use_anyway, attempt_register, weakness];
}
class RegisterWeakPassword extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$F, safe_not_equal, { attempt_register: 1, weakness: 2 });
  }
}
function create_if_block_2$4(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[4]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 16)
        set_data(t, ctx2[4]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_2$6(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && ctx[4] && create_if_block_2$4(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "autocomplete", "new-password");
      attr(input, "name", "password");
      attr(input, "placeholder", "Password");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", ctx[10]),
          listen(input, "input", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (!ctx2[2] && ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 20) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$8(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[5]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 32)
        set_data(t, ctx2[5]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_1$8(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && ctx[5] && create_if_block_1$8(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "autocomplete", "new-password");
      attr(input, "name", "verify");
      attr(input, "placeholder", "Password");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", ctx[12]),
          listen(input, "input", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      if (!ctx2[2] && ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 36) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$g(ctx) {
  let pre;
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(ctx[3]);
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_default_slot$i(ctx) {
  let center;
  let div0;
  let starshelllogo;
  let t0;
  let starshelltitle;
  let t1;
  let p;
  let t3;
  let div1;
  let input;
  let t4;
  let field0;
  let t5;
  let field1;
  let t6;
  let log_1;
  let updating_items;
  let t7;
  let t8;
  let actionsline;
  let current;
  starshelllogo = new StarShellLogo({ props: { dim: 96 } });
  starshelltitle = new StarShellTitle({ props: { width: 150 } });
  field0 = new Field({
    props: {
      key: "password",
      name: "New password",
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      key: "verify-password",
      name: "Verify password",
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  function log_1_items_binding(value) {
    ctx[14](value);
  }
  let log_1_props = {};
  if (ctx[6].items !== void 0) {
    log_1_props.items = ctx[6].items;
  }
  log_1 = new Log({ props: log_1_props });
  binding_callbacks.push(() => bind(log_1, "items", log_1_items_binding));
  let if_block = ctx[3] && create_if_block$g(ctx);
  actionsline = new ActionsLine({
    props: { confirm: ctx[7] }
  });
  return {
    c() {
      center = element("center");
      div0 = element("div");
      create_component(starshelllogo.$$.fragment);
      t0 = space();
      create_component(starshelltitle.$$.fragment);
      t1 = space();
      p = element("p");
      p.textContent = "Create a new password to protect your wallet's data.";
      t3 = space();
      div1 = element("div");
      input = element("input");
      t4 = space();
      create_component(field0.$$.fragment);
      t5 = space();
      create_component(field1.$$.fragment);
      t6 = space();
      create_component(log_1.$$.fragment);
      t7 = space();
      if (if_block)
        if_block.c();
      t8 = space();
      create_component(actionsline.$$.fragment);
      attr(div0, "class", "intro svelte-pdf2wg");
      attr(p, "class", "narrow svelte-pdf2wg");
      input.hidden = true;
      attr(input, "type", "text");
      attr(input, "name", "username");
      attr(input, "autocomplete", "username");
      input.value = "StarShell Wallet User";
      attr(div1, "class", "form flex-rows");
    },
    m(target, anchor) {
      insert(target, center, anchor);
      append(center, div0);
      mount_component(starshelllogo, div0, null);
      append(div0, t0);
      mount_component(starshelltitle, div0, null);
      append(center, t1);
      append(center, p);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      append(div1, input);
      append(div1, t4);
      mount_component(field0, div1, null);
      append(div1, t5);
      mount_component(field1, div1, null);
      insert(target, t6, anchor);
      mount_component(log_1, target, anchor);
      insert(target, t7, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t8, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 8388629) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 8388646) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const log_1_changes = {};
      if (!updating_items && dirty & 64) {
        updating_items = true;
        log_1_changes.items = ctx2[6].items;
        add_flush_callback(() => updating_items = false);
      }
      log_1.$set(log_1_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$g(ctx2);
          if_block.c();
          if_block.m(t8.parentNode, t8);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const actionsline_changes = {};
      if (dirty & 128)
        actionsline_changes.confirm = ctx2[7];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      transition_in(starshelltitle.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(log_1.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      transition_out(starshelltitle.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(log_1.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(center);
      destroy_component(starshelllogo);
      destroy_component(starshelltitle);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      destroy_component(field0);
      destroy_component(field1);
      if (detaching)
        detach(t6);
      destroy_component(log_1, detaching);
      if (detaching)
        detach(t7);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t8);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$E(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8388863) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let b_password_acceptable;
  let a_confirm_action;
  const k_page = getContext("page");
  const completed = getContext("completed");
  let sh_phrase = "";
  let sh_verify = "";
  let s_error = "";
  let s_err_password = "";
  let s_err_verify = "";
  let xt_start = 0;
  let k_logger = new Logger();
  function log(s_msg) {
    $$invalidate(6, k_logger = k_logger.event(s_msg, Date.now() - xt_start));
  }
  k_page.on({
    restore() {
      $$invalidate(0, sh_phrase = $$invalidate(1, sh_verify = ""));
    }
  });
  function check_password() {
    if (sh_phrase && !acceptable(sh_phrase)) {
      if (sh_phrase.length < NL_PASSPHRASE_MINIMUM) {
        $$invalidate(4, s_err_password = "Password must be at least 5 characters");
      } else if (sh_phrase.length > NL_PASSPHRASE_MAXIMUM) {
        $$invalidate(4, s_err_password = "Password must be 1024 characters or fewer");
      } else {
        $$invalidate(4, s_err_password = "Password is not acceptable");
      }
      return;
    }
    $$invalidate(4, s_err_password = "");
  }
  function check_verify() {
    if (sh_phrase && !s_err_password && sh_phrase !== sh_verify) {
      $$invalidate(5, s_err_verify = "Passwords do not match");
      return;
    }
    $$invalidate(5, s_err_verify = "");
  }
  const dp_passwords = (async () => {
    const d_res = await fetch("/data/passwords-top-10k.txt");
    const s_list = await d_res.text();
    return s_list.split("\n");
  })();
  async function prepare_register() {
    const a_passwords = await dp_passwords;
    if (a_passwords.includes(sh_phrase)) {
      k_page.push({
        creator: RegisterWeakPassword,
        props: { attempt_register }
      });
    } else {
      await attempt_register();
    }
  }
  let b_busy = false;
  async function attempt_register() {
    if (!b_password_acceptable)
      return 1;
    if (b_busy)
      return 1;
    b_busy = true;
    const exit = () => (b_busy = false, 1);
    $$invalidate(3, s_error = "");
    xt_start = Date.now();
    log("Estimating time to complete");
    {
      const xt_start_est = window.performance.now();
      await Vault.deriveRootBits(ATU8_DUMMY_PHRASE, ATU8_DUMMY_VECTOR, 1 / 50);
      const xt_finish_est = window.performance.now();
      const xt_elapsed_est = xt_finish_est - xt_start_est;
      const xt_estimate = 2 * (2 * (xt_elapsed_est * 50));
      log(`About ${(xt_estimate / 1e3).toFixed(1)} seconds`);
    }
    try {
      await register$1(sh_phrase, log);
    } catch (e_register) {
      if (e_register instanceof AlreadyRegisteredError) {
        $$invalidate(3, s_error = "A passphrase is already registered");
      } else if (e_register instanceof InvalidPassphraseError) {
        $$invalidate(3, s_error = "Invalid passphrase");
      } else {
        $$invalidate(3, s_error = `Unexpected error occurred while attempting to register:
${e_register.stack || e_register.message}`);
      }
      return exit();
    }
    log("Verifying passphrase");
    try {
      await login(sh_phrase, false, log);
    } catch (e_login) {
      $$invalidate(3, s_error = "Failed to verify passphrase immediately after registration");
      await Vault.eraseBase();
      return exit();
    }
    log("Done");
    $$invalidate(3, s_error = "Success");
    if (completed)
      completed(true);
    return exit();
  }
  const blur_handler = () => check_password();
  function input_input_handler() {
    sh_phrase = this.value;
    $$invalidate(0, sh_phrase);
  }
  const blur_handler_1 = () => check_verify();
  function input_input_handler_1() {
    sh_verify = this.value;
    $$invalidate(1, sh_verify);
  }
  function log_1_items_binding(value) {
    if ($$self.$$.not_equal(k_logger.items, value)) {
      k_logger.items = value;
      $$invalidate(6, k_logger);
    }
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $$invalidate(2, b_password_acceptable = !!sh_phrase && sh_phrase === sh_verify && acceptable(sh_phrase));
    }
    if ($$self.$$.dirty & 4) {
      $$invalidate(7, a_confirm_action = ["Continue", prepare_register, !b_password_acceptable]);
    }
  };
  return [
    sh_phrase,
    sh_verify,
    b_password_acceptable,
    s_error,
    s_err_password,
    s_err_verify,
    k_logger,
    a_confirm_action,
    check_password,
    check_verify,
    blur_handler,
    input_input_handler,
    blur_handler_1,
    input_input_handler_1,
    log_1_items_binding
  ];
}
class Register extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$E, safe_not_equal, {});
  }
}
var SX_ICON_CONTACTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M19 5v14H5V5h14m0-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 9c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm6 10H6v-1.53c0-2.5 3.97-3.58 6-3.58s6 1.08 6 3.58V18zm-9.69-2h7.38c-.69-.56-2.38-1.12-3.69-1.12s-3.01.56-3.69 1.12z"/>\n</svg>';
var SX_ICON_CONTRACT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-analytics-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-analytics-fg" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/>\n	<path class="s2r-analytics-fg" d="M7 12h2v5H7zm8-5h2v10h-2zm-4 7h2v3h-2zm0-4h2v2h-2z"/>\n</svg>';
var SX_ICON_LOADING = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M13 5.08A7 7 0 0 1 18.92 11h3.03c-.47-4.72-4.23-8.48-8.95-8.95v3.03zM18.92 13A7 7 0 0 1 13 18.92v3.03c4.72-.47 8.48-4.23 8.95-8.95h-3.03zM11 18.92c-3.39-.49-6-3.4-6-6.92s2.61-6.43 6-6.92V2.05c-5.05.5-9 4.76-9 9.95 0 5.19 3.95 9.45 9 9.95v-3.03z"/>\n</svg>';
function create_catch_block$b(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$b(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding(value) {
    ctx[4](value);
  }
  let starselect_props = {
    id: "asset-select",
    pfpMap: ctx[1],
    placeholder: "Select asset",
    items: ctx[8]
  };
  if (ctx[0] !== void 0) {
    starselect_props.value = ctx[0];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (dirty & 2)
        starselect_changes.pfpMap = ctx2[1];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        starselect_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block$b(ctx) {
  let t;
  return {
    c() {
      t = text("Loading assets...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$D(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$b,
    then: create_then_block$b,
    catch: create_catch_block$b,
    value: 8,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "asset");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let $yw_owner;
  let $yw_chain;
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(5, $yw_owner = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(6, $yw_chain = $$value));
  let { assetRef = "" } = $$props;
  $yw_chain?.id || "*";
  let h_asset_pfps = {};
  async function load_assets() {
    const a_items = [];
    $$invalidate(1, h_asset_pfps = await load_pfps($yw_chain.coins, { dim: 19 }));
    for (const [si_coin, g_coin] of ode($yw_chain.coins)) {
      a_items.push({
        value: Entities.holdingPathFor($yw_owner, si_coin),
        object: g_coin,
        primary: si_coin,
        secondary: g_coin.name,
        pfp: g_coin.pfp
      });
    }
    return a_items;
  }
  let g_item = {
    value: assetRef,
    object: null,
    primary: "",
    secondary: "",
    pfp: ""
  };
  function starselect_value_binding(value) {
    g_item = value;
    $$invalidate(0, g_item);
  }
  $$self.$$set = ($$props2) => {
    if ("assetRef" in $$props2)
      $$invalidate(3, assetRef = $$props2.assetRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        $$invalidate(3, assetRef = g_item?.value || "");
      }
    }
  };
  return [g_item, h_asset_pfps, load_assets, assetRef, starselect_value_binding];
}
class AssetSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$D, safe_not_equal, { assetRef: 3 });
  }
}
var SX_ICON_INCREMENT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14l-6-6z"/>\n</svg>';
var SX_ICON_DECREMENT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"/>\n</svg>';
function create_if_block_1$7(ctx) {
  let span6;
  let span2;
  let span0;
  let t0;
  let t1;
  let t2;
  let span1;
  let t4;
  let span5;
  let span3;
  let t5;
  let span4;
  let mounted;
  let dispose;
  return {
    c() {
      span6 = element("span");
      span2 = element("span");
      span0 = element("span");
      t0 = text("= ");
      t1 = text(ctx[5]);
      t2 = space();
      span1 = element("span");
      span1.textContent = "USD";
      t4 = space();
      span5 = element("span");
      span3 = element("span");
      t5 = space();
      span4 = element("span");
      attr(span0, "class", "amount svelte-18lggj7");
      attr(span1, "class", "fiat svelte-18lggj7");
      attr(span2, "class", "equivalent svelte-18lggj7");
      attr(span3, "class", "icon increment clickable svelte-18lggj7");
      attr(span4, "class", "icon decrement clickable svelte-18lggj7");
      attr(span5, "class", "adjust svelte-18lggj7");
      attr(span6, "class", "occupy svelte-18lggj7");
    },
    m(target, anchor) {
      insert(target, span6, anchor);
      append(span6, span2);
      append(span2, span0);
      append(span0, t0);
      append(span0, t1);
      append(span2, t2);
      append(span2, span1);
      append(span6, t4);
      append(span6, span5);
      append(span5, span3);
      span3.innerHTML = SX_ICON_INCREMENT;
      append(span5, t5);
      append(span5, span4);
      span4.innerHTML = SX_ICON_DECREMENT;
      if (!mounted) {
        dispose = [
          listen(span3, "click", ctx[16]),
          listen(span3, "mousedown", ctx[17]),
          listen(span4, "click", ctx[18]),
          listen(span4, "mousedown", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t1, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(span6);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$f(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$C(ctx) {
  let div;
  let input;
  let input_disabled_value;
  let input_max_value;
  let input_step_value;
  let t0;
  let t1;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_1$7(ctx);
  let if_block1 = ctx[1] && create_if_block$f(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      input.disabled = input_disabled_value = !ctx[2];
      attr(input, "type", "number");
      attr(input, "min", "0");
      attr(input, "max", input_max_value = ctx[4] + "" || "0");
      attr(input, "step", input_step_value = "0." + "0".repeat((ctx[3]?.decimals || 1) - 1) + "1");
      input.required = true;
      input.value = ctx[0];
      attr(input, "class", "svelte-18lggj7");
      toggle_class(input, "invalid", ctx[1]);
      attr(div, "class", "amount-input svelte-18lggj7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[15](input);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[14]),
          listen(input, "input", ctx[7]),
          listen(input, "invalid", invalid_handler)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && input_disabled_value !== (input_disabled_value = !ctx2[2])) {
        input.disabled = input_disabled_value;
      }
      if (dirty & 16 && input_max_value !== (input_max_value = ctx2[4] + "" || "0")) {
        attr(input, "max", input_max_value);
      }
      if (dirty & 8 && input_step_value !== (input_step_value = "0." + "0".repeat((ctx2[3]?.decimals || 1) - 1) + "1")) {
        attr(input, "step", input_step_value);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 2) {
        toggle_class(input, "invalid", ctx2[1]);
      }
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$7(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$f(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[15](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function long_press(f_action) {
  let i_ticker = 0;
  const i_buffer = window.setTimeout(
    () => {
      i_ticker = window.setInterval(f_action, 90);
    },
    1e3
  );
  window.addEventListener(
    "mouseup",
    () => {
      clearTimeout(i_buffer);
      clearInterval(i_ticker);
    },
    { once: true }
  );
}
const invalid_handler = (d) => d.preventDefault();
function instance$z($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_owner;
  let $yw_network_active;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(21, $yw_chain = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(22, $yw_owner = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(23, $yw_network_active = $$value));
  let { value = "" } = $$props;
  const YG_ZERO = new BigNumber(0);
  const YG_ONE = new BigNumber(1);
  let { assetRef = "" } = $$props;
  let { bufferMax = 0 } = $$props;
  let g_asset;
  let yg_max = YG_ZERO;
  let yg_step = YG_ZERO;
  let s_fiat_equivalent = "";
  let si_coingecko = "";
  async function reload_asset() {
    $$invalidate(5, s_fiat_equivalent = "[...]");
    const g_entity = Entities.parseEntityPath(assetRef);
    if ("holding" === g_entity?.type) {
      const si_coin = g_entity.coin;
      $$invalidate(3, g_asset = $yw_chain.coins[si_coin]);
      const g_cached = $yw_network_active.cachedBalance($yw_owner, si_coin);
      if (g_cached && g_cached.timestamp > Date.now() - 5 * XT_MINUTES) {
        $$invalidate(4, yg_max = new BigNumber(g_cached.data.amount).shiftedBy(-g_asset.decimals).minus(new BigNumber(bufferMax)));
      }
      const g_bundle = await $yw_network_active.bankBalance($yw_owner, si_coin);
      if (assetRef === g_bundle.holding) {
        const yg_amount = new BigNumber(g_bundle.balance.amount).shiftedBy(-g_asset.decimals).minus(new BigNumber(bufferMax));
        if (!yg_amount.eq(yg_max)) {
          $$invalidate(4, yg_max = yg_amount);
        }
        const g_coin = $yw_chain.coins[si_coin];
        $$invalidate(13, si_coingecko = g_coin?.extra?.coingecko_id || "");
      }
    } else if ("token" === g_entity?.type) {
      $$invalidate(3, g_asset = null);
    }
    if (g_asset) {
      yg_step = YG_ONE.shiftedBy(-g_asset.decimals);
    } else {
      yg_step = YG_ZERO;
      $$invalidate(4, yg_max = YG_ZERO);
    }
  }
  function capture_input(d_event) {
    $$invalidate(0, value = d_event.target.value);
  }
  function increment() {
    const yg_next = yg_step.plus(value || 0);
    if (yg_next.lte(yg_max)) {
      $$invalidate(0, value = yg_next + "");
    } else {
      $$invalidate(0, value = yg_max + "");
    }
    check_validity();
  }
  function decrement() {
    const yg_next = yg_step.negated().plus(value || 0);
    if (yg_next.gte(0)) {
      if (yg_next.gt(yg_max)) {
        $$invalidate(0, value = yg_max + "");
      } else {
        $$invalidate(0, value = yg_next + "");
      }
    } else {
      $$invalidate(0, value = "0");
    }
    check_validity();
  }
  let { error = "" } = $$props;
  let dm_input;
  function invalidate(s_msg) {
    dm_input.setCustomValidity(s_msg);
    $$invalidate(1, error = s_msg);
  }
  function check_validity() {
    if (!value) {
      return invalidate("Enter an amount");
    }
    let yg_input;
    try {
      yg_input = new BigNumber(value);
    } catch (e_parse) {
      return invalidate("Invalid number");
    }
    if (yg_input.lt(YG_ZERO)) {
      return invalidate("Value must be positive");
    }
    if (yg_input.gt(yg_max)) {
      return invalidate("Insufficient balance");
    }
    $$invalidate(1, error = "");
  }
  let { showValidation = 0 } = $$props;
  const change_handler = () => check_validity();
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_input = $$value;
      $$invalidate(6, dm_input);
    });
  }
  const click_handler2 = () => increment();
  const mousedown_handler = () => long_press(increment);
  const click_handler_1 = () => decrement();
  const mousedown_handler_1 = () => long_press(decrement);
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("assetRef" in $$props2)
      $$invalidate(2, assetRef = $$props2.assetRef);
    if ("bufferMax" in $$props2)
      $$invalidate(11, bufferMax = $$props2.bufferMax);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("showValidation" in $$props2)
      $$invalidate(12, showValidation = $$props2.showValidation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      {
        if (assetRef) {
          void reload_asset();
        } else {
          $$invalidate(3, g_asset = null);
        }
      }
    }
    if ($$self.$$.dirty & 8193) {
      {
        if (si_coingecko) {
          (async () => {
            const h_versus = await CoinGecko.coinsVersus([si_coingecko], "usd", 1 * XT_MINUTES);
            if (si_coingecko in h_versus) {
              $$invalidate(5, s_fiat_equivalent = format_amount(+value * +h_versus[si_coingecko], true));
            } else {
              $$invalidate(5, s_fiat_equivalent = "(?)");
            }
          })();
        } else {
          $$invalidate(5, s_fiat_equivalent = "");
        }
      }
    }
    if ($$self.$$.dirty & 4097) {
      {
        if (showValidation) {
          check_validity();
        } else if (!value) {
          $$invalidate(1, error = "");
        }
      }
    }
  };
  return [
    value,
    error,
    assetRef,
    g_asset,
    yg_max,
    s_fiat_equivalent,
    dm_input,
    capture_input,
    increment,
    decrement,
    check_validity,
    bufferMax,
    showValidation,
    si_coingecko,
    change_handler,
    input_binding,
    click_handler2,
    mousedown_handler,
    click_handler_1,
    mousedown_handler_1
  ];
}
class AmountInput extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$C, safe_not_equal, {
      value: 0,
      assetRef: 2,
      bufferMax: 11,
      error: 1,
      showValidation: 12
    });
  }
}
function create_catch_block$a(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$a(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding(value) {
    ctx[4](value);
  }
  let starselect_props = {
    id: "sender-select",
    placeholder: "Select account",
    secondaryClass: "balance",
    items: ctx[1]
  };
  if (ctx[0] !== void 0) {
    starselect_props.value = ctx[0];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (!updating_value && dirty & 1) {
        updating_value = true;
        starselect_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block$a(ctx) {
  let t;
  return {
    c() {
      t = text("Loading accounts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$B(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$a,
    then: create_then_block$a,
    catch: create_catch_block$a,
    value: 1,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "sender");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let $yw_account_ref;
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(5, $yw_account_ref = $$value));
  let { accountRef = $yw_account_ref } = $$props;
  const mk_account = (p_acc, g_acc) => ({
    value: p_acc,
    primary: g_acc.name,
    secondary: g_acc.extra?.total_fiat_cache || "(?)"
  });
  let g_selected;
  let a_options;
  async function load_accounts() {
    const ks_accounts = await Accounts.read();
    $$invalidate(1, a_options = oderac(ks_accounts.raw, mk_account));
    $$invalidate(0, g_selected = a_options.find((g) => accountRef === g.value));
    return a_options;
  }
  function starselect_value_binding(value) {
    g_selected = value;
    $$invalidate(0, g_selected);
  }
  $$self.$$set = ($$props2) => {
    if ("accountRef" in $$props2)
      $$invalidate(3, accountRef = $$props2.accountRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (g_selected) {
        $$invalidate(3, accountRef = g_selected.value);
      }
    }
  };
  return [g_selected, a_options, load_accounts, accountRef, starselect_value_binding];
}
class SenderSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$B, safe_not_equal, { accountRef: 3 });
  }
}
function create_else_block$6(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Failed to locate contact";
      attr(span, "class", "warning");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$3(ctx) {
  let span;
  let address_1;
  let current;
  address_1 = new Address({ props: { address: ctx[0] } });
  return {
    c() {
      span = element("span");
      create_component(address_1.$$.fragment);
      attr(span, "class", "manual");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(address_1, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const address_1_changes = {};
      if (dirty & 1)
        address_1_changes.address = ctx2[0];
      address_1.$set(address_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(address_1);
    }
  };
}
function create_if_block$e(ctx) {
  let div;
  let span0;
  let t0;
  let span2;
  let span1;
  let t1_value = ctx[1].name + "";
  let t1;
  let t2;
  let address_1;
  let current;
  let if_block = ctx[1] && create_if_block_1$6(ctx);
  address_1 = new Address({
    props: {
      address: Chains.bech32(ctx[1].address)
    }
  });
  return {
    c() {
      div = element("div");
      span0 = element("span");
      if (if_block)
        if_block.c();
      t0 = space();
      span2 = element("span");
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      create_component(address_1.$$.fragment);
      attr(span0, "class", "contact-pfp svelte-1ontxbe");
      attr(span1, "class", "name svelte-1ontxbe");
      attr(span2, "class", "info svelte-1ontxbe");
      attr(div, "class", "contact svelte-1ontxbe");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      if (if_block)
        if_block.m(span0, null);
      append(div, t0);
      append(div, span2);
      append(span2, span1);
      append(span1, t1);
      append(span2, t2);
      mount_component(address_1, span2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if ((!current || dirty & 2) && t1_value !== (t1_value = ctx2[1].name + ""))
        set_data(t1, t1_value);
      const address_1_changes = {};
      if (dirty & 2)
        address_1_changes.address = Chains.bech32(ctx2[1].address);
      address_1.$set(address_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(address_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(address_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_component(address_1);
    }
  };
}
function create_if_block_1$6(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 28,
      resource: ctx[1],
      genStyle: "font-size:18px;"
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = {};
      if (dirty & 2)
        pfpdisplay_changes.resource = ctx2[1];
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_fragment$A(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$e, create_if_block_2$3, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    if (ctx2[0])
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let $yw_family;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(3, $yw_family = $$value));
  let { contact = null } = $$props;
  let g_contact = contact;
  let { address = "" } = $$props;
  async function reload_contacts() {
    const ks_agents = await Agents.read();
    const di_contacts = ks_agents.contacts($yw_family);
    if (!g_contact && address) {
      for (const [, g_contact_each] of di_contacts) {
        if (address === Chains.bech32(g_contact_each.address)) {
          $$invalidate(1, g_contact = g_contact_each);
          break;
        }
      }
    }
  }
  void reload_contacts();
  const f_unsub_agents = subscribe_store("agents", reload_contacts);
  onDestroy(() => {
    f_unsub_agents();
  });
  $$self.$$set = ($$props2) => {
    if ("contact" in $$props2)
      $$invalidate(2, contact = $$props2.contact);
    if ("address" in $$props2)
      $$invalidate(0, address = $$props2.address);
  };
  return [address, g_contact, contact];
}
class InlineContactSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$A, safe_not_equal, { contact: 2, address: 0 });
  }
}
function create_fragment$z(ctx) {
  let div;
  let inlinecontactselection;
  let div_class_value;
  let current;
  inlinecontactselection = new InlineContactSelection({
    props: {
      contact: ctx[1].contact,
      address: ctx[1].value
    }
  });
  return {
    c() {
      div = element("div");
      create_component(inlinecontactselection.$$.fragment);
      attr(div, "class", div_class_value = "item " + ctx[2] + " svelte-pgx3pp");
      toggle_class(div, "display_none", ctx[0] || !ctx[1].value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inlinecontactselection, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const inlinecontactselection_changes = {};
      if (dirty & 2)
        inlinecontactselection_changes.contact = ctx2[1].contact;
      if (dirty & 2)
        inlinecontactselection_changes.address = ctx2[1].value;
      inlinecontactselection.$set(inlinecontactselection_changes);
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "item " + ctx2[2] + " svelte-pgx3pp")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & 7) {
        toggle_class(div, "display_none", ctx2[0] || !ctx2[1].value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinecontactselection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontactselection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inlinecontactselection);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let { isActive = false } = $$props;
  let { isFirst = false } = $$props;
  let { isHover = false } = $$props;
  let { isSelectable = false } = $$props;
  let { getOptionLabel = void 0 } = $$props;
  let { item } = $$props;
  let { filterText = "" } = $$props;
  let itemClasses = "";
  $$self.$$set = ($$props2) => {
    if ("isActive" in $$props2)
      $$invalidate(0, isActive = $$props2.isActive);
    if ("isFirst" in $$props2)
      $$invalidate(3, isFirst = $$props2.isFirst);
    if ("isHover" in $$props2)
      $$invalidate(4, isHover = $$props2.isHover);
    if ("isSelectable" in $$props2)
      $$invalidate(5, isSelectable = $$props2.isSelectable);
    if ("getOptionLabel" in $$props2)
      $$invalidate(6, getOptionLabel = $$props2.getOptionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("filterText" in $$props2)
      $$invalidate(7, filterText = $$props2.filterText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 57) {
      {
        const classes = [];
        if (isActive) {
          classes.push("active");
        }
        if (isFirst) {
          classes.push("first");
        }
        if (isHover) {
          classes.push("hover");
        }
        if (!isSelectable) {
          classes.push("notSelectable");
        }
        $$invalidate(2, itemClasses = classes.join(" "));
      }
    }
  };
  return [
    isActive,
    item,
    itemClasses,
    isFirst,
    isHover,
    isSelectable,
    getOptionLabel,
    filterText
  ];
}
class RecipientSelectItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$z, safe_not_equal, {
      isActive: 0,
      isFirst: 3,
      isHover: 4,
      isSelectable: 5,
      getOptionLabel: 6,
      item: 1,
      filterText: 7
    });
  }
}
function create_fragment$y(ctx) {
  let div;
  let inlinecontactselection;
  let current;
  inlinecontactselection = new InlineContactSelection({
    props: {
      contact: ctx[0].contact,
      address: ctx[0].value
    }
  });
  return {
    c() {
      div = element("div");
      create_component(inlinecontactselection.$$.fragment);
      attr(div, "class", "selection svelte-aitqlq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inlinecontactselection, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const inlinecontactselection_changes = {};
      if (dirty & 1)
        inlinecontactselection_changes.contact = ctx2[0].contact;
      if (dirty & 1)
        inlinecontactselection_changes.address = ctx2[0].value;
      inlinecontactselection.$set(inlinecontactselection_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinecontactselection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontactselection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inlinecontactselection);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let { getSelectionLabel } = $$props;
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("getSelectionLabel" in $$props2)
      $$invalidate(1, getSelectionLabel = $$props2.getSelectionLabel);
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item, getSelectionLabel];
}
class RecipientSelectSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$y, safe_not_equal, { getSelectionLabel: 1, item: 0 });
  }
}
function create_catch_block$9(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$9(ctx) {
  let select_1;
  let updating_filterText;
  let updating_listOpen;
  let current;
  function select_1_filterText_binding(value) {
    ctx[14](value);
  }
  function select_1_listOpen_binding(value) {
    ctx[15](value);
  }
  let select_1_props = {
    id: "recipient-select",
    placeholder: "Address or contact",
    listOffset: 1,
    isClearable: !!ctx[0],
    isCreatable: !!ctx[3],
    Item: RecipientSelectItem,
    Selection: RecipientSelectSelection,
    items: ctx[8],
    value: ctx[4],
    noOptionsMessage: "Stop typing in the address. \n Use copy/paste instead!",
    containerClasses: ctx[1] ? "invalid" : ""
  };
  if (ctx[2] !== void 0) {
    select_1_props.filterText = ctx[2];
  }
  if (ctx[6] !== void 0) {
    select_1_props.listOpen = ctx[6];
  }
  select_1 = new Select({ props: select_1_props });
  binding_callbacks.push(() => bind(select_1, "filterText", select_1_filterText_binding));
  binding_callbacks.push(() => bind(select_1, "listOpen", select_1_listOpen_binding));
  select_1.$on("select", ctx[10]);
  select_1.$on("clear", ctx[11]);
  return {
    c() {
      create_component(select_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_1_changes = {};
      if (dirty & 1)
        select_1_changes.isClearable = !!ctx2[0];
      if (dirty & 8)
        select_1_changes.isCreatable = !!ctx2[3];
      if (dirty & 16)
        select_1_changes.value = ctx2[4];
      if (dirty & 2)
        select_1_changes.containerClasses = ctx2[1] ? "invalid" : "";
      if (!updating_filterText && dirty & 4) {
        updating_filterText = true;
        select_1_changes.filterText = ctx2[2];
        add_flush_callback(() => updating_filterText = false);
      }
      if (!updating_listOpen && dirty & 64) {
        updating_listOpen = true;
        select_1_changes.listOpen = ctx2[6];
        add_flush_callback(() => updating_listOpen = false);
      }
      select_1.$set(select_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_1, detaching);
    }
  };
}
function create_pending_block$9(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contacts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$d(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$x(ctx) {
  let div;
  let t;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$9,
    then: create_then_block$9,
    catch: create_catch_block$9,
    value: 8,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  let if_block = ctx[1] && create_if_block$d(ctx);
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "sender svelte-1rmr362");
      toggle_class(div, "hide-cursor", ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[16](div);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (ctx[1]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$d(ctx);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32) {
        toggle_class(div, "hide-cursor", ctx[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      if (if_block)
        if_block.d();
      ctx[16](null);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_family;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(13, $yw_chain = $$value));
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(17, $yw_family = $$value));
  let { address = "" } = $$props;
  const sa_input = address;
  let { error = "" } = $$props;
  let s_manual_input;
  let g_item_select;
  let a_contacts;
  const contact_to_option = (g) => ({
    value: Chains.bech32(g.address),
    label: g.name,
    contact: g
  });
  async function load_contacts() {
    const ks_agents = await Agents.read();
    const a_options = [{ value: "", label: "", contact: null }];
    $$invalidate(8, a_contacts = [...ks_agents.contacts($yw_family)]);
    for (const [, g_contact] of a_contacts) {
      const g_option = contact_to_option(g_contact);
      const sa_contact = Chains.bech32(g_contact.address);
      if (sa_input && sa_contact === sa_input) {
        $$invalidate(4, g_item_select = g_option);
      }
      a_options.push(g_option);
    }
    return a_options;
  }
  function select(d_event) {
    $$invalidate(0, address = d_event.detail.value);
    $$invalidate(1, error = "");
  }
  function clear() {
    $$invalidate(0, address = "");
  }
  let s_accepted_input = "";
  let b_hide_cursor = false;
  let b_list_open = false;
  function check_manual_input() {
    $$invalidate(3, s_accepted_input = "");
    if (!$yw_chain) {
      $$invalidate(1, error = "No chain set");
    } else if (!Chains.isValidAddressFor($yw_chain, s_manual_input, "acc")) {
      $$invalidate(1, error = "Invalid address for this chain");
    } else {
      $$invalidate(1, error = "");
      for (const [, g_contact] of a_contacts) {
        if (s_manual_input === Chains.bech32(g_contact.address)) {
          $$invalidate(2, s_manual_input = "");
          $$invalidate(4, g_item_select = contact_to_option(g_contact));
          $$invalidate(6, b_list_open = false);
          $$invalidate(5, b_hide_cursor = true);
          return;
        }
      }
      $$invalidate(3, s_accepted_input = s_manual_input);
      setTimeout(
        () => {
          qs(dm_sender, ".manual>.address").click();
          $$invalidate(6, b_list_open = false);
        },
        0
      );
    }
  }
  let dm_sender;
  let { showValidation = 0 } = $$props;
  function select_1_filterText_binding(value) {
    s_manual_input = value;
    $$invalidate(2, s_manual_input);
  }
  function select_1_listOpen_binding(value) {
    b_list_open = value;
    $$invalidate(6, b_list_open);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_sender = $$value;
      $$invalidate(7, dm_sender);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("address" in $$props2)
      $$invalidate(0, address = $$props2.address);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("showValidation" in $$props2)
      $$invalidate(12, showValidation = $$props2.showValidation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      {
        $$invalidate(5, b_hide_cursor = false);
        if (s_manual_input) {
          check_manual_input();
        } else {
          $$invalidate(5, b_hide_cursor = !!s_accepted_input);
          $$invalidate(3, s_accepted_input = "");
        }
      }
    }
    if ($$self.$$.dirty & 12293) {
      {
        if (showValidation) {
          if (!address) {
            if (s_manual_input) {
              check_manual_input();
            } else {
              $$invalidate(1, error = "Enter a recipient");
            }
          } else if (!Chains.isValidAddressFor($yw_chain, address, "acc")) {
            $$invalidate(1, error = "Invalid address for this chain");
          } else {
            $$invalidate(1, error = "");
          }
        } else if (!address) {
          $$invalidate(1, error = "");
        }
      }
    }
  };
  return [
    address,
    error,
    s_manual_input,
    s_accepted_input,
    g_item_select,
    b_hide_cursor,
    b_list_open,
    dm_sender,
    a_contacts,
    load_contacts,
    select,
    clear,
    showValidation,
    $yw_chain,
    select_1_filterText_binding,
    select_1_listOpen_binding,
    div_binding
  ];
}
class RecipientSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$x, safe_not_equal, { address: 0, error: 1, showValidation: 12 });
  }
}
function create_default_slot_6$3(ctx) {
  let div0;
  let t0_value = (ctx[1]?.name || "[...]") + "";
  let t0;
  let t1;
  let div1;
  let t2_value = (ctx[1]?.extra?.total_fiat_cache || "(?)") + "";
  let t2;
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = (ctx2[1]?.name || "[...]") + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = (ctx2[1]?.extra?.total_fiat_cache || "(?)") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
    }
  };
}
function create_default_slot_5$4(ctx) {
  let div0;
  let t0_value = (ctx[2] || "[...]") + "";
  let t0;
  let t1;
  let div1;
  let address;
  let current;
  address = new Address({
    props: { address: ctx[9] }
  });
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      create_component(address.$$.fragment);
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      mount_component(address, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 4) && t0_value !== (t0_value = (ctx2[2] || "[...]") + ""))
        set_data(t0, t0_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_component(address);
    }
  };
}
function create_else_block_3(ctx) {
  let t;
  return {
    c() {
      t = text("=[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$1(ctx) {
  let t_value = format_fiat(new BigNumber(ctx[8]).times(ctx[3]).toNumber()) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = format_fiat(new BigNumber(ctx2[8]).times(ctx2[3]).toNumber()) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$4(ctx) {
  let div0;
  let t3;
  let div1;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_3$1;
    return create_else_block_3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${ctx[8]}  ${ctx[7]}`;
      t3 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_else_block_2(ctx) {
  let t;
  return {
    c() {
      t = text("=[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$2(ctx) {
  let t_value = format_fiat(new BigNumber(ctx[10]).times(ctx[3]).toNumber()) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = format_fiat(new BigNumber(ctx2[10]).times(ctx2[3]).toNumber()) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$5(ctx) {
  let div0;
  let t3;
  let div1;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_2$2;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${ctx[10]}  ${ctx[7]}`;
      t3 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_else_block_1(ctx) {
  let t;
  return {
    c() {
      t = text("=[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$5(ctx) {
  let t_value = format_fiat(new BigNumber(ctx[4]).times(ctx[3]).toNumber()) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 24 && t_value !== (t_value = format_fiat(new BigNumber(ctx2[4]).times(ctx2[3]).toNumber()) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let div0;
  let t0_value = (ctx[4] || "[...]") + "";
  let t0;
  let t1;
  let t2;
  let t3;
  let div1;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_1$5;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(ctx[7]);
      t3 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      append(div0, t1);
      append(div0, t2);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t0_value !== (t0_value = (ctx2[4] || "[...]") + ""))
        set_data(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_else_block$5(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "(empty)";
      attr(span, "class", "empty-memo svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block$c(ctx) {
  let textarea;
  return {
    c() {
      textarea = element("textarea");
      textarea.disabled = true;
      textarea.value = ctx[0];
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        textarea.value = ctx2[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let if_block_anchor;
  function select_block_type_3(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block$c;
    return create_else_block$5;
  }
  let current_block_type = select_block_type_3(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot$h(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let hr0;
  let t2;
  let field1;
  let t3;
  let hr1;
  let t4;
  let field2;
  let t5;
  let hr2;
  let t6;
  let field3;
  let t7;
  let hr3;
  let t8;
  let field4;
  let t9;
  let hr4;
  let t10;
  let field5;
  let t11;
  let actionsline;
  let current;
  header = new Header({
    props: {
      pops: true,
      exits: true,
      title: "Sending",
      symbol: ctx[7],
      subtitle: ctx[5].name
    }
  });
  header.$on("close", ctx[17]);
  field0 = new Field({
    props: {
      short: true,
      key: "sender",
      name: "From",
      $$slots: { default: [create_default_slot_6$3] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      short: true,
      key: "recipient",
      name: "To",
      $$slots: { default: [create_default_slot_5$4] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      short: true,
      key: "amount",
      name: "Amount",
      $$slots: { default: [create_default_slot_4$4] },
      $$scope: { ctx }
    }
  });
  field3 = new Field({
    props: {
      short: true,
      key: "fee-review",
      name: "Fee",
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      short: true,
      key: "total",
      name: "Total",
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    }
  });
  field5 = new Field({
    props: {
      short: true,
      key: "memo",
      name: "Memo",
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      back: true,
      confirm: ["Approve", ctx[18]]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      hr0 = element("hr");
      t2 = space();
      create_component(field1.$$.fragment);
      t3 = space();
      hr1 = element("hr");
      t4 = space();
      create_component(field2.$$.fragment);
      t5 = space();
      hr2 = element("hr");
      t6 = space();
      create_component(field3.$$.fragment);
      t7 = space();
      hr3 = element("hr");
      t8 = space();
      create_component(field4.$$.fragment);
      t9 = space();
      hr4 = element("hr");
      t10 = space();
      create_component(field5.$$.fragment);
      t11 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      insert(target, hr0, anchor);
      insert(target, t2, anchor);
      mount_component(field1, target, anchor);
      insert(target, t3, anchor);
      insert(target, hr1, anchor);
      insert(target, t4, anchor);
      mount_component(field2, target, anchor);
      insert(target, t5, anchor);
      insert(target, hr2, anchor);
      insert(target, t6, anchor);
      mount_component(field3, target, anchor);
      insert(target, t7, anchor);
      insert(target, hr3, anchor);
      insert(target, t8, anchor);
      mount_component(field4, target, anchor);
      insert(target, t9, anchor);
      insert(target, hr4, anchor);
      insert(target, t10, anchor);
      mount_component(field5, target, anchor);
      insert(target, t11, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & 32)
        header_changes.subtitle = ctx2[5].name;
      header.$set(header_changes);
      const field0_changes = {};
      if (dirty & 16777218) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 16777220) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 16777224) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const field3_changes = {};
      if (dirty & 16777224) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty & 16777240) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      const field5_changes = {};
      if (dirty & 16777217) {
        field5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field5.$set(field5_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(field5.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(field5.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(hr0);
      if (detaching)
        detach(t2);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(hr1);
      if (detaching)
        detach(t4);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(hr2);
      if (detaching)
        detach(t6);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(hr3);
      if (detaching)
        detach(t8);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t9);
      if (detaching)
        detach(hr4);
      if (detaching)
        detach(t10);
      destroy_component(field5, detaching);
      if (detaching)
        detach(t11);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$w(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "SendNative",
      slides: true,
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 16777279) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let s_total;
  let $yw_navigator;
  let $yw_network_active;
  let $yw_chain;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(21, $yw_navigator = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(22, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(5, $yw_chain = $$value));
  const k_page = getContext("page");
  let { coin } = $$props;
  const si_coin = coin;
  const g_coin = $yw_chain.coins[si_coin];
  let { accountRef } = $$props;
  let g_account;
  let sa_sender;
  let { amount } = $$props;
  const s_amount = amount;
  let { recipient } = $$props;
  const sa_recipient = recipient;
  let s_recipient_title = "";
  let g_contact;
  let { fee } = $$props;
  const s_fee = fee;
  let { memo } = $$props;
  let x_worth = 0;
  (async (fk_resolve) => {
    const si_coingecko = g_coin.extra?.coingecko_id || "";
    if (si_coingecko) {
      const h_versus = await CoinGecko.coinsVersus([si_coingecko], "usd", 0);
      $$invalidate(3, x_worth = h_versus[si_coingecko]);
    }
  })();
  (async () => {
    const ks_accounts = await Accounts.read();
    $$invalidate(1, g_account = ks_accounts.at(accountRef));
    sa_sender = Chains.addressFor(g_account.pubkey);
    const p_contact = Agents.pathForContact(sa_recipient);
    g_contact = await Agents.getContact(p_contact);
    $$invalidate(2, s_recipient_title = g_contact?.name || "");
  })();
  async function approve() {
    const xg_amount = BigInt(new BigNumber(s_amount).shiftedBy(g_coin.decimals).toString());
    const g_attempt = await $yw_network_active.bankSend(sa_sender, sa_recipient, si_coin, xg_amount, memo);
    await Events.insert({
      type: "pending",
      time: Date.now(),
      data: g_attempt
    });
    k_page.reset();
    void $yw_navigator.activateThread(ThreadId.HISTORY);
  }
  const close_handler = () => k_page.reset();
  const func = () => approve();
  $$self.$$set = ($$props2) => {
    if ("coin" in $$props2)
      $$invalidate(12, coin = $$props2.coin);
    if ("accountRef" in $$props2)
      $$invalidate(13, accountRef = $$props2.accountRef);
    if ("amount" in $$props2)
      $$invalidate(14, amount = $$props2.amount);
    if ("recipient" in $$props2)
      $$invalidate(15, recipient = $$props2.recipient);
    if ("fee" in $$props2)
      $$invalidate(16, fee = $$props2.fee);
    if ("memo" in $$props2)
      $$invalidate(0, memo = $$props2.memo);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 65536) {
      $$invalidate(4, s_total = new BigNumber(s_amount).plus(fee).toString());
    }
  };
  return [
    memo,
    g_account,
    s_recipient_title,
    x_worth,
    s_total,
    $yw_chain,
    k_page,
    si_coin,
    s_amount,
    sa_recipient,
    s_fee,
    approve,
    coin,
    accountRef,
    amount,
    recipient,
    fee,
    close_handler,
    func
  ];
}
class SendNative extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$w, safe_not_equal, {
      coin: 12,
      accountRef: 13,
      amount: 14,
      recipient: 15,
      fee: 16,
      memo: 0
    });
  }
}
function create_default_slot_9(ctx) {
  let senderselect;
  let updating_accountRef;
  let current;
  function senderselect_accountRef_binding(value) {
    ctx[38](value);
  }
  let senderselect_props = {};
  if (ctx[13] !== void 0) {
    senderselect_props.accountRef = ctx[13];
  }
  senderselect = new SenderSelect({ props: senderselect_props });
  binding_callbacks.push(() => bind(senderselect, "accountRef", senderselect_accountRef_binding));
  return {
    c() {
      create_component(senderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(senderselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const senderselect_changes = {};
      if (!updating_accountRef && dirty[0] & 8192) {
        updating_accountRef = true;
        senderselect_changes.accountRef = ctx2[13];
        add_flush_callback(() => updating_accountRef = false);
      }
      senderselect.$set(senderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(senderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(senderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(senderselect, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let recipientselect;
  let updating_error;
  let updating_address;
  let current;
  function recipientselect_error_binding(value) {
    ctx[39](value);
  }
  function recipientselect_address_binding(value) {
    ctx[40](value);
  }
  let recipientselect_props = {
    showValidation: ctx[4]
  };
  if (ctx[6] !== void 0) {
    recipientselect_props.error = ctx[6];
  }
  if (ctx[0] !== void 0) {
    recipientselect_props.address = ctx[0];
  }
  recipientselect = new RecipientSelect({ props: recipientselect_props });
  binding_callbacks.push(() => bind(recipientselect, "error", recipientselect_error_binding));
  binding_callbacks.push(() => bind(recipientselect, "address", recipientselect_address_binding));
  return {
    c() {
      create_component(recipientselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipientselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recipientselect_changes = {};
      if (dirty[0] & 16)
        recipientselect_changes.showValidation = ctx2[4];
      if (!updating_error && dirty[0] & 64) {
        updating_error = true;
        recipientselect_changes.error = ctx2[6];
        add_flush_callback(() => updating_error = false);
      }
      if (!updating_address && dirty[0] & 1) {
        updating_address = true;
        recipientselect_changes.address = ctx2[0];
        add_flush_callback(() => updating_address = false);
      }
      recipientselect.$set(recipientselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipientselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipientselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipientselect, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let div;
  let checkboxfield;
  let updating_checked;
  let current;
  function checkboxfield_checked_binding(value) {
    ctx[41](value);
  }
  let checkboxfield_props = {
    id: "save-contact",
    $$slots: { default: [create_default_slot_7$1] },
    $$scope: { ctx }
  };
  if (ctx[5] !== void 0) {
    checkboxfield_props.checked = ctx[5];
  }
  checkboxfield = new CheckboxField({ props: checkboxfield_props });
  binding_callbacks.push(() => bind(checkboxfield, "checked", checkboxfield_checked_binding));
  return {
    c() {
      div = element("div");
      create_component(checkboxfield.$$.fragment);
      attr(div, "class", "new-address svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkboxfield, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const checkboxfield_changes = {};
      if (dirty[1] & 134217728) {
        checkboxfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_checked && dirty[0] & 32) {
        updating_checked = true;
        checkboxfield_changes.checked = ctx2[5];
        add_flush_callback(() => updating_checked = false);
      }
      checkboxfield.$set(checkboxfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkboxfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(checkboxfield);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let t;
  return {
    c() {
      t = text("Save to contacts");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$2(ctx) {
  let span2;
  let span0;
  let raw_value = ctx[17].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[17].text + "";
  let t1;
  let span2_class_value;
  let t2;
  let if_block_anchor;
  let current;
  let if_block = ctx[9] && create_if_block_5(ctx);
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span0, "class", "icon svelte-ipiv9p");
      attr(span1, "class", "text svelte-ipiv9p");
      attr(span2, "class", span2_class_value = "status " + ctx[3] + " svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      span0.innerHTML = raw_value;
      append(span2, t0);
      append(span2, span1);
      append(span1, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 131072) && raw_value !== (raw_value = ctx2[17].icon + ""))
        span0.innerHTML = raw_value;
      if ((!current || dirty[0] & 131072) && t1_value !== (t1_value = ctx2[17].text + ""))
        set_data(t1, t1_value);
      if (!current || dirty[0] & 8 && span2_class_value !== (span2_class_value = "status " + ctx2[3] + " svelte-ipiv9p")) {
        attr(span2, "class", span2_class_value);
      }
      if (ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let field;
  let current;
  field = new Field({
    props: {
      short: true,
      slides: true,
      key: "new-contact-name",
      name: "Contact Name",
      $$slots: { default: [create_default_slot_5$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty[0] & 256 | dirty[1] & 134217728) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[8]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256)
        set_data(t, ctx2[8]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_5$3(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[8] && create_if_block_4(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "id", "new-contact-name-value");
      attr(input, "type", "text");
      toggle_class(input, "invalid", ctx[8]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[24]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256) {
        toggle_class(input, "invalid", ctx2[8]);
      }
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_4$3(ctx) {
  let assetselect;
  let updating_assetRef;
  let current;
  function assetselect_assetRef_binding(value) {
    ctx[42](value);
  }
  let assetselect_props = {};
  if (ctx[1] !== void 0) {
    assetselect_props.assetRef = ctx[1];
  }
  assetselect = new AssetSelect({ props: assetselect_props });
  binding_callbacks.push(() => bind(assetselect, "assetRef", assetselect_assetRef_binding));
  return {
    c() {
      create_component(assetselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(assetselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const assetselect_changes = {};
      if (!updating_assetRef && dirty[0] & 2) {
        updating_assetRef = true;
        assetselect_changes.assetRef = ctx2[1];
        add_flush_callback(() => updating_assetRef = false);
      }
      assetselect.$set(assetselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(assetselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(assetselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(assetselect, detaching);
    }
  };
}
function create_default_slot_3$4(ctx) {
  let amountinput;
  let updating_error;
  let updating_value;
  let current;
  function amountinput_error_binding(value) {
    ctx[43](value);
  }
  function amountinput_value_binding(value) {
    ctx[44](value);
  }
  let amountinput_props = {
    bufferMax: ctx[10] ? x_fee : 0,
    assetRef: ctx[1],
    showValidation: ctx[4]
  };
  if (ctx[7] !== void 0) {
    amountinput_props.error = ctx[7];
  }
  if (ctx[2] !== void 0) {
    amountinput_props.value = ctx[2];
  }
  amountinput = new AmountInput({ props: amountinput_props });
  binding_callbacks.push(() => bind(amountinput, "error", amountinput_error_binding));
  binding_callbacks.push(() => bind(amountinput, "value", amountinput_value_binding));
  return {
    c() {
      create_component(amountinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(amountinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const amountinput_changes = {};
      if (dirty[0] & 1024)
        amountinput_changes.bufferMax = ctx2[10] ? x_fee : 0;
      if (dirty[0] & 2)
        amountinput_changes.assetRef = ctx2[1];
      if (dirty[0] & 16)
        amountinput_changes.showValidation = ctx2[4];
      if (!updating_error && dirty[0] & 128) {
        updating_error = true;
        amountinput_changes.error = ctx2[7];
        add_flush_callback(() => updating_error = false);
      }
      if (!updating_value && dirty[0] & 4) {
        updating_value = true;
        amountinput_changes.value = ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      amountinput.$set(amountinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(amountinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(amountinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(amountinput, detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let span2;
  let span0;
  let t1;
  let span1;
  let t2;
  let t3;
  let t4;
  let t5;
  let span4;
  let span3;
  let mounted;
  let dispose;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      span0.textContent = "Balance";
      t1 = space();
      span1 = element("span");
      t2 = text(ctx[11]);
      t3 = space();
      t4 = text(ctx[20]);
      t5 = space();
      span4 = element("span");
      span3 = element("span");
      span3.textContent = "USE MAX";
      attr(span0, "class", "label svelte-ipiv9p");
      attr(span1, "class", "amount svelte-ipiv9p");
      attr(span2, "class", "balance svelte-ipiv9p");
      attr(span3, "class", "link svelte-ipiv9p");
      toggle_class(span3, "disabled", ctx[19]);
      attr(span4, "class", "use-max");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span2, t1);
      append(span2, span1);
      append(span1, t2);
      append(span1, t3);
      append(span1, t4);
      insert(target, t5, anchor);
      insert(target, span4, anchor);
      append(span4, span3);
      if (!mounted) {
        dispose = listen(span3, "click", ctx[45]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data(t2, ctx2[11]);
      if (dirty[0] & 1048576)
        set_data(t4, ctx2[20]);
      if (dirty[0] & 524288) {
        toggle_class(span3, "disabled", ctx2[19]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(span4);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$4(ctx) {
  let span;
  let if_block = ctx[1] && create_if_block_2$1(ctx);
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      attr(span, "class", "balance-line svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$1(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block)
        if_block.d();
    }
  };
}
function create_default_slot_1$6(ctx) {
  let div0;
  let t2;
  let div1;
  let t3;
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${x_fee} SCRT`;
      t2 = space();
      div1 = element("div");
      t3 = text(ctx[18]);
      attr(div0, "class", "fee-amount");
      attr(div1, "class", "fee-fiat svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 262144)
        set_data(t3, ctx2[18]);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
    }
  };
}
function create_post_slot(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "manual-fee svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$4(ctx) {
  let span;
  let span_transition;
  let current;
  return {
    c() {
      span = element("span");
      span.textContent = "Caution: Memos are NOT private";
      attr(span, "class", "disclaimer svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, slide, { duration: 350, delay: 400 }, true);
        span_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!span_transition)
        span_transition = create_bidirectional_transition(span, slide, { duration: 350, delay: 400 }, false);
      span_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_if_block$b(ctx) {
  let div;
  let textarea;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      attr(textarea, "class", "svelte-ipiv9p");
      attr(div, "class", "input");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      set_input_value(textarea, ctx[15]);
      current = true;
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[47]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32768) {
        set_input_value(textarea, ctx2[15]);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 350 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 350 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$g(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let field1;
  let t2;
  let field2;
  let t3;
  let t4;
  let hr0;
  let t5;
  let field3;
  let t6;
  let field4;
  let t7;
  let field5;
  let t8;
  let hr1;
  let t9;
  let field6;
  let t10;
  let hr2;
  let t11;
  let div1;
  let div0;
  let span0;
  let t12;
  let span1;
  let t14;
  let t15;
  let t16;
  let actionsline;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: {
      pops: true,
      title: ctx[21] ? "Transferring" : "Sending",
      symbol: ctx[21] ? ctx[21].symbol : "",
      subtitle: ctx[12]?.name || "?"
    }
  });
  field0 = new Field({
    props: {
      short: true,
      key: "sender-select",
      name: "From",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      short: true,
      key: "recipient-select",
      name: "To",
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      short: true,
      key: "recipient-status",
      name: "",
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[9] && ctx[5] && create_if_block_3(ctx);
  field3 = new Field({
    props: {
      short: true,
      key: "asset-select",
      name: "Asset",
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      short: true,
      key: "amount",
      name: "Amount",
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  field5 = new Field({
    props: {
      short: true,
      key: "balance",
      name: "",
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  field6 = new Field({
    props: {
      short: true,
      key: "fee",
      name: "Fee",
      $$slots: {
        post: [create_post_slot],
        default: [create_default_slot_1$6]
      },
      $$scope: { ctx }
    }
  });
  let if_block1 = ctx[14] && create_if_block_1$4();
  let if_block2 = ctx[14] && create_if_block$b(ctx);
  actionsline = new ActionsLine({
    props: {
      cancel: "pop",
      confirm: ["Next", ctx[48], !ctx[16]]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      create_component(field1.$$.fragment);
      t2 = space();
      create_component(field2.$$.fragment);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      hr0 = element("hr");
      t5 = space();
      create_component(field3.$$.fragment);
      t6 = space();
      create_component(field4.$$.fragment);
      t7 = space();
      create_component(field5.$$.fragment);
      t8 = space();
      hr1 = element("hr");
      t9 = space();
      create_component(field6.$$.fragment);
      t10 = space();
      hr2 = element("hr");
      t11 = space();
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t12 = space();
      span1 = element("span");
      span1.textContent = "Add memo";
      t14 = space();
      if (if_block1)
        if_block1.c();
      t15 = space();
      if (if_block2)
        if_block2.c();
      t16 = space();
      create_component(actionsline.$$.fragment);
      attr(span0, "class", "icon dropdown svelte-ipiv9p");
      attr(span1, "class", "text");
      attr(div0, "class", "title clickable svelte-ipiv9p");
      attr(div1, "class", "memo svelte-ipiv9p");
      toggle_class(div1, "expanded", ctx[14]);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      mount_component(field1, target, anchor);
      insert(target, t2, anchor);
      mount_component(field2, target, anchor);
      insert(target, t3, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t4, anchor);
      insert(target, hr0, anchor);
      insert(target, t5, anchor);
      mount_component(field3, target, anchor);
      insert(target, t6, anchor);
      mount_component(field4, target, anchor);
      insert(target, t7, anchor);
      mount_component(field5, target, anchor);
      insert(target, t8, anchor);
      insert(target, hr1, anchor);
      insert(target, t9, anchor);
      mount_component(field6, target, anchor);
      insert(target, t10, anchor);
      insert(target, hr2, anchor);
      insert(target, t11, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span0);
      span0.innerHTML = SX_ICON_DROPDOWN;
      append(div0, t12);
      append(div0, span1);
      append(div0, t14);
      if (if_block1)
        if_block1.m(div0, null);
      append(div1, t15);
      if (if_block2)
        if_block2.m(div1, null);
      insert(target, t16, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[46]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty[0] & 4096)
        header_changes.subtitle = ctx2[12]?.name || "?";
      header.$set(header_changes);
      const field0_changes = {};
      if (dirty[0] & 8192 | dirty[1] & 134217728) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty[0] & 81 | dirty[1] & 134217728) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty[0] & 131624 | dirty[1] & 134217728) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      if (ctx2[9] && ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 544) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t4.parentNode, t4);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const field3_changes = {};
      if (dirty[0] & 2 | dirty[1] & 134217728) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty[0] & 1174 | dirty[1] & 134217728) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      const field5_changes = {};
      if (dirty[0] & 1574914 | dirty[1] & 134217728) {
        field5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field5.$set(field5_changes);
      const field6_changes = {};
      if (dirty[0] & 262144 | dirty[1] & 134217728) {
        field6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field6.$set(field6_changes);
      if (ctx2[14]) {
        if (if_block1) {
          if (dirty[0] & 16384) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$4();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[14]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 16384) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$b(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty[0] & 16384) {
        toggle_class(div1, "expanded", ctx2[14]);
      }
      const actionsline_changes = {};
      if (dirty[0] & 65536)
        actionsline_changes.confirm = ["Next", ctx2[48], !ctx2[16]];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(if_block0);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(field5.$$.fragment, local);
      transition_in(field6.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(if_block0);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(field5.$$.fragment, local);
      transition_out(field6.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t3);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(hr0);
      if (detaching)
        detach(t5);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t6);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t7);
      destroy_component(field5, detaching);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(hr1);
      if (detaching)
        detach(t9);
      destroy_component(field6, detaching);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(hr2);
      if (detaching)
        detach(t11);
      if (detaching)
        detach(div1);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach(t16);
      destroy_component(actionsline, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$v(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      form: true,
      slides: true,
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  screen.$on("submit", submit_handler);
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const screen_changes = {};
      if (dirty[0] & 2097151 | dirty[1] & 134217728) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
const si_versus = "usd";
let x_fee = 0.01;
const R_CONTACT_NAME = /^\S.{0,1023}$/;
const submit_handler = (d_submit) => {
  d_submit.preventDefault();
};
function instance$s($$self, $$props, $$invalidate) {
  let g_coin;
  let p_token;
  let s_symbol;
  let s_balance;
  let b_using_max;
  let si_coingecko;
  let s_fee_fiat;
  let g_address_type;
  let b_new_address;
  let s_err_new_contact;
  let b_form_valid;
  let $yw_network_active;
  let $yw_owner;
  let $yw_account;
  let $yw_chain;
  let $yw_account_ref;
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(35, $yw_network_active = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(36, $yw_owner = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(37, $yw_account = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(12, $yw_chain = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(53, $yw_account_ref = $$value));
  const k_page = getContext("page");
  let { sender = $yw_account } = $$props;
  let p_account = $yw_account_ref;
  let { native = Object.keys($yw_chain.coins)[0] } = $$props;
  let si_native = native;
  let { token = null } = $$props;
  let g_token2 = token;
  let { recipient = "" } = $$props;
  let sa_recipient = recipient;
  let p_asset = si_native ? Entities.holdingPathFor($yw_owner, si_native) : "";
  let h_addr_to_contact;
  let b_busy_agents = false;
  async function reload_agents(b_init = false) {
    if (b_busy_agents)
      return;
    b_busy_agents = true;
    const ks_agents = await Agents.read();
    const a_contacts = [...ks_agents.contacts()];
    $$invalidate(29, h_addr_to_contact = fold(a_contacts, ([p_contact, g_contact]) => ({
      [Chains.bech32(g_contact.address)]: p_contact
    })));
    b_busy_agents = false;
  }
  {
    const f_unsub_agents = subscribe_store("agents", reload_agents);
    const f_unsub_chain = yw_chain.subscribe(reload_agents);
    onDestroy(() => {
      f_unsub_agents();
      f_unsub_chain();
    });
  }
  let yg_balance = null;
  let s_amount = "";
  function use_max() {
    $$invalidate(2, s_amount = s_balance);
    if (g_coin) {
      $$invalidate(2, s_amount = new BigNumber(s_amount).minus(x_fee).toString());
    }
    $$invalidate(4, c_show_validations++, c_show_validations);
  }
  let x_worth = null;
  const H_ADDRESS_TYPES = {
    none: { icon: "<svg></svg>", text: "" },
    unknown: {
      icon: SX_ICON_LOADING,
      text: "Determining address type..."
    },
    personal: {
      icon: SX_ICON_CONTACTS,
      text: "Personal address"
    },
    contract: {
      icon: SX_ICON_CONTRACT,
      text: "Contract address"
    }
  };
  let si_address_type = "none";
  let b_memo_expanded = false;
  let s_memo = "";
  let b_submitted = false;
  function submit() {
    if (!b_form_valid) {
      $$invalidate(4, c_show_validations++, c_show_validations);
      return;
    } else {
      if (b_submitted)
        return false;
      b_submitted = true;
      if (si_native) {
        k_page.push({
          creator: SendNative,
          props: {
            accountRef: p_account,
            coin: si_native,
            recipient: sa_recipient,
            amount: s_amount,
            memo: s_memo,
            fee: x_fee + ""
          }
        });
      }
    }
  }
  let c_show_validations = 0;
  let b_checked_save_contact = false;
  let s_err_recipient = "";
  let s_err_amount = "";
  let s_new_contact = "";
  function input_new_contact(d_event) {
    $$invalidate(32, s_new_contact = d_event.target.value);
  }
  function senderselect_accountRef_binding(value) {
    p_account = value;
    $$invalidate(13, p_account);
  }
  function recipientselect_error_binding(value) {
    s_err_recipient = value;
    $$invalidate(6, s_err_recipient);
  }
  function recipientselect_address_binding(value) {
    sa_recipient = value;
    $$invalidate(0, sa_recipient);
  }
  function checkboxfield_checked_binding(value) {
    b_checked_save_contact = value;
    $$invalidate(5, b_checked_save_contact);
  }
  function assetselect_assetRef_binding(value) {
    p_asset = value;
    $$invalidate(1, p_asset);
  }
  function amountinput_error_binding(value) {
    s_err_amount = value;
    $$invalidate(7, s_err_amount);
  }
  function amountinput_value_binding(value) {
    s_amount = value;
    $$invalidate(2, s_amount);
  }
  const click_handler2 = () => use_max();
  const click_handler_1 = () => $$invalidate(14, b_memo_expanded = !b_memo_expanded);
  function textarea_input_handler() {
    s_memo = this.value;
    $$invalidate(15, s_memo);
  }
  const func = () => submit();
  $$self.$$set = ($$props2) => {
    if ("sender" in $$props2)
      $$invalidate(25, sender = $$props2.sender);
    if ("native" in $$props2)
      $$invalidate(26, native = $$props2.native);
    if ("token" in $$props2)
      $$invalidate(27, token = $$props2.token);
    if ("recipient" in $$props2)
      $$invalidate(28, recipient = $$props2.recipient);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4098) {
      $$invalidate(10, g_coin = p_asset && "holding" === Entities.parseEntityPath(p_asset)?.type && si_native ? $yw_chain.coins?.[si_native] : null);
    }
    if ($$self.$$.dirty[0] & 2) {
      $$invalidate(34, p_token = p_asset && "token" === Entities.parseEntityPath(p_asset)?.type && g_token2 ? Entities.pathFrom(g_token2) : "");
    }
    if ($$self.$$.dirty[0] & 1026 | $$self.$$.dirty[1] & 8) {
      {
        console.log({
          si_native,
          g_coin,
          p_asset,
          p_token,
          g_token: g_token2
        });
      }
    }
    if ($$self.$$.dirty[0] & 2 | $$self.$$.dirty[1] & 112) {
      {
        if ($yw_account && p_asset) {
          $$invalidate(30, yg_balance = null);
          queueMicrotask(async () => {
            $$invalidate(11, s_balance = "[...]");
            const g_cached = $yw_network_active.cachedBalance($yw_owner, si_native);
            if (g_cached && g_cached.timestamp > Date.now() - 5 * XT_MINUTES) {
              $$invalidate(30, yg_balance = new BigNumber(g_cached.data.amount));
            }
            const g_bundle = await $yw_network_active.bankBalance($yw_owner, si_native);
            if (g_bundle) {
              $$invalidate(30, yg_balance = new BigNumber(g_bundle.balance.amount));
            }
          });
        }
      }
    }
    if ($$self.$$.dirty[0] & 1073742848) {
      $$invalidate(11, s_balance = yg_balance ? format_amount(yg_balance.shiftedBy(-(g_coin || g_token2).decimals).toNumber()) : "");
    }
    if ($$self.$$.dirty[0] & 2052) {
      $$invalidate(19, b_using_max = s_amount === s_balance);
    }
    if ($$self.$$.dirty[0] & 1024) {
      $$invalidate(33, si_coingecko = (g_token2 || g_coin)?.extra?.coingecko_id || "");
    }
    if ($$self.$$.dirty[1] & 5) {
      {
        if (si_coingecko) {
          (async () => {
            const h_versus = await CoinGecko.coinsVersus([si_coingecko], si_versus);
            $$invalidate(31, x_worth = h_versus[si_coingecko]);
            if ("number" === typeof x_worth) {
              format_fiat(x_worth, si_versus);
            }
          })();
        }
      }
    }
    if ($$self.$$.dirty[1] & 1) {
      $$invalidate(18, s_fee_fiat = "number" === typeof x_worth ? format_fiat(x_fee * x_worth, "usd") : "");
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 16) {
      {
        if (!sa_recipient) {
          $$invalidate(3, si_address_type = "none");
        } else {
          $$invalidate(3, si_address_type = "unknown");
          (async () => {
            if (await $yw_network_active.isContract(sa_recipient)) {
              $$invalidate(3, si_address_type = "contract");
            } else {
              $$invalidate(3, si_address_type = "personal");
            }
          })();
        }
      }
    }
    if ($$self.$$.dirty[0] & 8) {
      $$invalidate(17, g_address_type = H_ADDRESS_TYPES[si_address_type]);
    }
    if ($$self.$$.dirty[0] & 536870913) {
      $$invalidate(9, b_new_address = sa_recipient && h_addr_to_contact && !(sa_recipient in h_addr_to_contact));
    }
    if ($$self.$$.dirty[0] & 48 | $$self.$$.dirty[1] & 2) {
      $$invalidate(8, s_err_new_contact = b_checked_save_contact && (c_show_validations || true) ? s_new_contact ? R_CONTACT_NAME.test(s_new_contact) ? "" : s_new_contact.length > 1024 ? "That name is way too long" : "Cannot begin with space" : "Enter a contact name to save new address" : "");
    }
    if ($$self.$$.dirty[0] & 48) {
      {
        if (b_checked_save_contact && !c_show_validations) {
          $$invalidate(8, s_err_new_contact = "");
        }
      }
    }
    if ($$self.$$.dirty[0] & 997 | $$self.$$.dirty[1] & 2) {
      $$invalidate(16, b_form_valid = sa_recipient && s_amount && !s_err_recipient && !s_err_amount && (!b_new_address || !b_checked_save_contact || s_new_contact && !s_err_new_contact) || false);
    }
    if ($$self.$$.dirty[0] & 197) {
      {
        console.log({
          to: sa_recipient,
          s_amount,
          s_err_recipient,
          s_err_amount
        });
      }
    }
  };
  $$invalidate(20, s_symbol = si_native || g_token2?.symbol || "");
  return [
    sa_recipient,
    p_asset,
    s_amount,
    si_address_type,
    c_show_validations,
    b_checked_save_contact,
    s_err_recipient,
    s_err_amount,
    s_err_new_contact,
    b_new_address,
    g_coin,
    s_balance,
    $yw_chain,
    p_account,
    b_memo_expanded,
    s_memo,
    b_form_valid,
    g_address_type,
    s_fee_fiat,
    b_using_max,
    s_symbol,
    g_token2,
    use_max,
    submit,
    input_new_contact,
    sender,
    native,
    token,
    recipient,
    h_addr_to_contact,
    yg_balance,
    x_worth,
    s_new_contact,
    si_coingecko,
    p_token,
    $yw_network_active,
    $yw_owner,
    $yw_account,
    senderselect_accountRef_binding,
    recipientselect_error_binding,
    recipientselect_address_binding,
    checkboxfield_checked_binding,
    assetselect_assetRef_binding,
    amountinput_error_binding,
    amountinput_value_binding,
    click_handler2,
    click_handler_1,
    textarea_input_handler,
    func
  ];
}
class Send extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$s,
      create_fragment$v,
      safe_not_equal,
      {
        sender: 25,
        native: 26,
        token: 27,
        recipient: 28
      },
      null,
      [-1, -1]
    );
  }
}
function create_fragment$u(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "\xA0";
      attr(div, "class", "gap no-margin svelte-1rn5flx");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class Gap extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$u, safe_not_equal, {});
  }
}
function as_amount(g_balance, g_coin) {
  const s_norm = g_balance.amount.padStart(g_coin.decimals + 2, "0");
  return s_norm.slice(0, -g_coin.decimals).replace(/^0+/, "0") + "." + s_norm.slice(-g_coin.decimals);
}
async function to_fiat(g_balance, g_coin, si_versus2 = "usd") {
  if ("0" === g_balance.amount)
    return new BigNumber(0);
  const si_gecko = g_coin.extra.coingecko_id;
  const g_versus = await CoinGecko.coinsVersus([si_gecko], si_versus2);
  return new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals).times(g_versus[si_gecko]);
}
async function coin_formats(g_balance, g_coin, si_versus2 = "usd") {
  const si_gecko = g_coin.extra.coingecko_id;
  const g_versus = await CoinGecko.coinsVersus([si_gecko], si_versus2);
  const x_worth = g_versus[si_gecko];
  const yg_balance = new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals).times(x_worth);
  return {
    versus: si_versus2,
    balance: yg_balance,
    fiat: yg_balance.times(x_worth).toNumber(),
    worth: x_worth
  };
}
function create_default_slot$f(ctx) {
  let header;
  let t0;
  let portrait;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      pops: true,
      account: true,
      network: true,
      title: ctx[3],
      subtitle: ctx[4]
    }
  });
  portrait = new Portrait({
    props: {
      pfp: ctx[2],
      resource: ctx[1] || g_token || null,
      resourcePath: ctx[8],
      title: ctx[5] ? `${format_amount(ctx[5].toNumber())} ${ctx[3]}` : "...",
      subtitle: `${ctx[6]} (${ctx[7]} per ${ctx[0]})`,
      actions: ctx[9],
      circular: true
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(portrait.$$.fragment);
      t1 = space();
      div = element("div");
      attr(div, "class", "txns no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(portrait, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & 8)
        header_changes.title = ctx2[3];
      if (dirty & 16)
        header_changes.subtitle = ctx2[4];
      header.$set(header_changes);
      const portrait_changes = {};
      if (dirty & 4)
        portrait_changes.pfp = ctx2[2];
      if (dirty & 2)
        portrait_changes.resource = ctx2[1] || g_token || null;
      if (dirty & 40)
        portrait_changes.title = ctx2[5] ? `${format_amount(ctx2[5].toNumber())} ${ctx2[3]}` : "...";
      if (dirty & 193)
        portrait_changes.subtitle = `${ctx2[6]} (${ctx2[7]} per ${ctx2[0]})`;
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$t(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "HoldingView",
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 262399) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
let g_token = null;
function instance$r($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_network_active;
  let $yw_chain_ref;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(13, $yw_chain = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(14, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(15, $yw_chain_ref = $$value));
  const k_page = getContext("page");
  let { entityRef } = $$props;
  const p_entity = entityRef;
  let si_type = "";
  let si_coin = "";
  let g_coin = null;
  let p_pfp = "";
  let s_symbol = "";
  let s_name = "";
  let yg_amount = null;
  let s_fiat = "";
  let s_worth = "";
  async function load_entity() {
    await Entities.read();
    const g_info = Entities.parseEntityPath(p_entity);
    if (!g_info) {
      throw new Error(`Attempted to load holding view on non-entity path "${p_entity}"`);
    }
    switch (g_info.type) {
      case "holding": {
        $$invalidate(0, si_type = "coin");
        ({ coin: si_coin } = g_info);
        const p_chain = g_info.chainRef;
        const g_chain = p_chain === $yw_chain_ref ? $yw_chain : await Chains.at(p_chain);
        $$invalidate(1, g_coin = g_chain.coins[si_coin]);
        $$invalidate(3, s_symbol = si_coin);
        $$invalidate(4, s_name = g_coin.name);
        $$invalidate(2, p_pfp = g_coin.pfp);
        const g_cached = $yw_network_active.cachedBalance(g_info.bech32, si_coin);
        let g_balance;
        if (g_cached && g_cached.timestamp >= Date.now() - 2 * XT_MINUTES) {
          g_balance = g_cached.data;
        } else {
          ({ balance: g_balance } = await $yw_network_active.bankBalance(g_info.bech32, si_coin));
        }
        $$invalidate(5, yg_amount = new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals));
        void coin_formats(g_balance, g_coin).then((g_formats) => {
          $$invalidate(6, s_fiat = format_fiat(g_formats.fiat, g_formats.versus));
          $$invalidate(7, s_worth = format_fiat(g_formats.worth, g_formats.versus));
        });
        break;
      }
      case "token": {
        $$invalidate(0, si_type = "token");
        const ks_entites = await Entities.read();
        ks_entites.tokens(g_info.entityRef, Entities.fungibleInterfacesFor($yw_chain));
        debugger;
        break;
      }
      default: {
        throw new Error(`Unhandled entity type: "${g_info.type}"`);
      }
    }
  }
  load_entity();
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: si_coin ? { native: si_coin } : {}
        });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("entityRef" in $$props2)
      $$invalidate(10, entityRef = $$props2.entityRef);
  };
  return [
    si_type,
    g_coin,
    p_pfp,
    s_symbol,
    s_name,
    yg_amount,
    s_fiat,
    s_worth,
    p_entity,
    gc_actions,
    entityRef
  ];
}
class HoldingView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$t, safe_not_equal, { entityRef: 10 });
  }
}
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i][0];
  child_ctx[24] = list[i][1];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i][0];
  child_ctx[33] = list[i][1];
  child_ctx[34] = list[i][2];
  child_ctx[35] = list[i][3];
  const constants_0 = Entities.holdingPathFor(child_ctx[3], child_ctx[27]);
  child_ctx[29] = constants_0;
  const constants_1 = {
    name: child_ctx[27],
    pfp: child_ctx[0].pfp
  };
  child_ctx[36] = constants_1;
  const constants_2 = child_ctx[35](to_fiat(child_ctx[34], child_ctx[33]));
  child_ctx[37] = constants_2;
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i][0];
  child_ctx[28] = list[i][1];
  const constants_0 = Entities.holdingPathFor(child_ctx[3], child_ctx[27]);
  child_ctx[29] = constants_0;
  return child_ctx;
}
function create_if_block_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "TESETNET";
      attr(div, "class", "testnet-reminder no-margin svelte-8v4b7t");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$a(ctx) {
  let div2;
  let div0;
  let span;
  let t1;
  let t2_value = ctx[0].testnet ? "testnet " : "";
  let t2;
  let t3_value = ctx[1].join(" or ") + "";
  let t3;
  let t4;
  let t5;
  let div1;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].testnet)
      return create_if_block_1$3;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span = element("span");
      span.textContent = "Warning:";
      t1 = text(" you don't have any ");
      t2 = text(t2_value);
      t3 = text(t3_value);
      t4 = text(" to pay gas fees.");
      t5 = space();
      div1 = element("div");
      if_block.c();
      attr(span, "class", "warning");
      attr(div0, "class", "message svelte-8v4b7t");
      attr(div1, "class", "buttons");
      attr(div2, "class", "no-gas text-align_center subinfo svelte-8v4b7t");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span);
      append(div0, t1);
      append(div0, t2);
      append(div0, t3);
      append(div0, t4);
      append(div2, t5);
      append(div2, div1);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t2_value !== (t2_value = ctx2[0].testnet ? "testnet " : ""))
        set_data(t2, t2_value);
      if (dirty[0] & 2 && t3_value !== (t3_value = ctx2[1].join(" or ") + ""))
        set_data(t3, t3_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_block.d();
    }
  };
}
function create_else_block$4(ctx) {
  let button;
  let t0;
  let t1_value = ctx[1].join(" or ") + "";
  let t1;
  return {
    c() {
      button = element("button");
      t0 = text("Buy ");
      t1 = text(t1_value);
      attr(button, "class", "pill");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t1_value !== (t1_value = ctx2[1].join(" or ") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
    }
  };
}
function create_if_block_1$3(ctx) {
  let button;
  let t0;
  let t1_value = ctx[1].join(" or ") + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text("Get ");
      t1 = text(t1_value);
      t2 = text(" from faucet");
      attr(button, "class", "pill");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", ctx[14]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t1_value !== (t1_value = ctx2[1].join(" or ") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block_1(ctx) {
  let t;
  let div;
  let address;
  let current;
  let if_block = ctx[1].length && create_if_block$a(ctx);
  address = new Address({
    props: {
      address: ctx[3],
      copyable: "text"
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      create_component(address.$$.fragment);
      attr(div, "class", "owner-address subinfo svelte-8v4b7t");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      mount_component(address, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$a(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const address_changes = {};
      if (dirty[0] & 8)
        address_changes.address = ctx2[3];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      destroy_component(address);
    }
  };
}
function create_catch_block_1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ctx[32];
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 777) {
        each_value_2 = ctx2[32];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_2(ctx) {
  let row;
  let current;
  function click_handler_2() {
    return ctx[17](ctx[29]);
  }
  row = new Row({
    props: {
      lockIcon: true,
      detail: "Native Coin",
      resourcePath: ctx[29],
      resource: ctx[36],
      amount: as_amount(ctx[34], ctx[33]),
      fiat: ctx[37].then(ctx[16])
    }
  });
  row.$on("click", click_handler_2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 8)
        row_changes.resourcePath = ctx[29];
      if (dirty[0] & 1)
        row_changes.resource = ctx[36];
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ode(ctx[0].coins);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 265) {
        each_value_1 = ode(ctx2[0].coins);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_1$2(ctx) {
  let row;
  let current;
  function click_handler_1() {
    return ctx[15](ctx[29]);
  }
  row = new Row({
    props: {
      lockIcon: true,
      detail: "Native Coin",
      name: ctx[27],
      pfp: ctx[0].pfp,
      amount: forever()
    }
  });
  row.$on("click", click_handler_1);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 1)
        row_changes.name = ctx[27];
      if (dirty[0] & 1)
        row_changes.pfp = ctx[0].pfp;
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_catch_block$8(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$8(ctx) {
  let each_1_anchor;
  let each_value = ode(ctx[7](ctx[22]));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 129) {
        each_value = ode(ctx2[7](ctx2[22]));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$7(ctx) {
  let t_value = ctx[24].spec + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t_value !== (t_value = ctx2[24].spec + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block$8(ctx) {
  let t;
  return {
    c() {
      t = text("Loading tokens...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_key_block$2(ctx) {
  let div;
  let t;
  let promise_1;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 32,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  let info_1 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$8,
    then: create_then_block$8,
    catch: create_catch_block$8,
    value: 22
  };
  handle_promise(promise_1 = Entities.readFungibleTokens(ctx[0]), info_1);
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      info_1.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      info_1.block.m(div, info_1.anchor = null);
      info_1.mount = () => div;
      info_1.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      info_1.ctx = ctx;
      if (dirty[0] & 1 && promise_1 !== (promise_1 = Entities.readFungibleTokens(ctx[0])) && handle_promise(promise_1, info_1))
        ;
      else {
        update_await_block_branch(info_1, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      info_1.block.d();
      info_1.token = null;
      info_1 = null;
    }
  };
}
function create_default_slot$e(ctx) {
  let header;
  let t0;
  let t1;
  let portrait;
  let t2;
  let previous_key = ctx[0];
  let t3;
  let gap;
  let t4;
  let previous_key_1 = ctx[4];
  let key_block1_anchor;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  let if_block = ctx[0].testnet && create_if_block_2();
  portrait = new Portrait({
    props: {
      noPfp: true,
      title: ctx[2],
      subtitle: ctx[5].name,
      resource: ctx[5],
      resourcePath: ctx[6],
      actions: {
        send: { label: "Send", trigger: ctx[12] },
        recv: {
          label: "Receive",
          trigger: ctx[13]
        }
      }
    }
  });
  let key_block0 = create_key_block_1(ctx);
  gap = new Gap({});
  let key_block1 = create_key_block$2(ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(portrait.$$.fragment);
      t2 = space();
      key_block0.c();
      t3 = space();
      create_component(gap.$$.fragment);
      t4 = space();
      key_block1.c();
      key_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(portrait, target, anchor);
      insert(target, t2, anchor);
      key_block0.m(target, anchor);
      insert(target, t3, anchor);
      mount_component(gap, target, anchor);
      insert(target, t4, anchor);
      key_block1.m(target, anchor);
      insert(target, key_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0].testnet) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_2();
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const portrait_changes = {};
      if (dirty[0] & 4)
        portrait_changes.title = ctx2[2];
      if (dirty[0] & 32)
        portrait_changes.subtitle = ctx2[5].name;
      if (dirty[0] & 32)
        portrait_changes.resource = ctx2[5];
      if (dirty[0] & 64)
        portrait_changes.resourcePath = ctx2[6];
      if (dirty[0] & 96)
        portrait_changes.actions = {
          send: { label: "Send", trigger: ctx2[12] },
          recv: {
            label: "Receive",
            trigger: ctx2[13]
          }
        };
      portrait.$set(portrait_changes);
      if (dirty[0] & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block0, 1, 1, noop);
        check_outros();
        key_block0 = create_key_block_1(ctx2);
        key_block0.c();
        transition_in(key_block0, 1);
        key_block0.m(t3.parentNode, t3);
      } else {
        key_block0.p(ctx2, dirty);
      }
      if (dirty[0] & 16 && safe_not_equal(previous_key_1, previous_key_1 = ctx2[4])) {
        group_outros();
        transition_out(key_block1, 1, 1, noop);
        check_outros();
        key_block1 = create_key_block$2(ctx2);
        key_block1.c();
        transition_in(key_block1, 1);
        key_block1.m(key_block1_anchor.parentNode, key_block1_anchor);
      } else {
        key_block1.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(portrait.$$.fragment, local);
      transition_in(key_block0);
      transition_in(gap.$$.fragment, local);
      transition_in(key_block1);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(portrait.$$.fragment, local);
      transition_out(key_block0);
      transition_out(gap.$$.fragment, local);
      transition_out(key_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t2);
      key_block0.d(detaching);
      if (detaching)
        detach(t3);
      destroy_component(gap, detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(key_block1_anchor);
      key_block1.d(detaching);
    }
  };
}
function create_fragment$s(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "HoldingsHome",
      nav: true,
      root: true,
      keyed: true,
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const screen_changes = {};
      if (dirty[0] & 127 | dirty[1] & 512) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_owner;
  let $yw_network_active;
  let $yw_account;
  let $yw_account_ref;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(0, $yw_chain = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(3, $yw_owner = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(4, $yw_network_active = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(5, $yw_account = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(6, $yw_account_ref = $$value));
  const merge_fungible_tokens = (h_fungibles) => oderom(h_fungibles, (_, h) => h);
  const k_page = getContext("page");
  let yg_total = new BigNumber(0);
  let c_balances = 0;
  let a_no_gas = [];
  let fk_resolve_total;
  let dp_total = new Promise((fk_resolve) => {
    fk_resolve_total = fk_resolve;
  });
  let g_chain_cached = $yw_chain;
  function check_total() {
    c_balances -= 1;
    if (!c_balances) {
      const s_total = format_fiat(yg_total.toNumber(), "usd");
      fk_resolve_total(s_total);
      const g_account = $yw_account;
      void Accounts.open((ks) => ks.put({
        ...g_account,
        extra: { total_fiat_cache: s_total }
      }));
    }
  }
  async function load_native_balances() {
    let h_balances;
    try {
      h_balances = await $yw_network_active.bankBalances($yw_owner);
    } catch (e_network) {
      syserr({ error: e_network, text: "Network error" });
      return [];
    }
    const a_outs = [];
    for (const [si_coin, g_coin] of ode($yw_chain.coins)) {
      const g_bundle = h_balances[si_coin];
      if (!g_bundle || "0" === g_bundle.balance.amount) {
        a_no_gas.push(si_coin);
      }
      c_balances += 1;
      a_outs.push([
        si_coin,
        $yw_chain.coins[si_coin],
        g_bundle?.balance || { amount: "0", denom: g_coin.denom },
        async (z_out) => {
          const yg_balance = await z_out;
          yg_total = yg_total.plus(yg_balance);
          check_total();
          return yg_balance;
        }
      ]);
    }
    if (!a_outs.length) {
      c_balances += 1;
      check_total();
    }
    $$invalidate(1, a_no_gas), $$invalidate(0, $yw_chain), $$invalidate(11, g_chain_cached);
    return a_outs;
  }
  const H_FAUCETS = {
    "theta-testnet-001": "https://discord.com/channels/669268347736686612/953697793476821092",
    "pulsar-2": "https://faucet.secrettestnet.io/"
  };
  const func = function() {
    k_page.push({
      creator: Send,
      props: { from: $yw_account }
    });
  };
  const func_12 = function() {
    popup_receive($yw_account_ref);
  };
  const click_handler2 = () => open_external_link(H_FAUCETS[$yw_chain.id]);
  const click_handler_1 = (p_entity) => {
    k_page.push({
      creator: HoldingView,
      props: { entityRef: p_entity }
    });
  };
  const func_2 = (yg) => format_fiat(yg.toNumber(), "usd");
  const click_handler_2 = (p_entity) => {
    k_page.push({
      creator: HoldingView,
      props: { entityRef: p_entity }
    });
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2049) {
      {
        if ($yw_chain !== g_chain_cached) {
          $$invalidate(11, g_chain_cached = $yw_chain);
          yg_total = new BigNumber(0);
          c_balances = 0;
          $$invalidate(2, dp_total = new Promise((fk_resolve) => {
            fk_resolve_total = fk_resolve;
          }));
          $$invalidate(1, a_no_gas = []);
        }
      }
    }
  };
  return [
    $yw_chain,
    a_no_gas,
    dp_total,
    $yw_owner,
    $yw_network_active,
    $yw_account,
    $yw_account_ref,
    merge_fungible_tokens,
    k_page,
    load_native_balances,
    H_FAUCETS,
    g_chain_cached,
    func,
    func_12,
    click_handler2,
    click_handler_1,
    func_2,
    click_handler_2
  ];
}
class HoldingsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$s, safe_not_equal, {}, null, [-1, -1]);
  }
}
function create_catch_block$7(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$7(ctx) {
  let field0;
  let t0;
  let field1;
  let t1;
  let field2;
  let t2;
  let actionsline;
  let current;
  field0 = new Field({
    props: {
      key: "profile-icon",
      name: "Profile icon"
    }
  });
  field1 = new Field({
    props: {
      key: "account-name",
      name: "Name",
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      key: "account-address",
      name: "Public address",
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      cancel: !ctx[4],
      back: true,
      confirm: ["Finish", ctx[6], !ctx[3]]
    }
  });
  return {
    c() {
      create_component(field0.$$.fragment);
      t0 = space();
      create_component(field1.$$.fragment);
      t1 = space();
      create_component(field2.$$.fragment);
      t2 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t0, anchor);
      mount_component(field1, target, anchor);
      insert(target, t1, anchor);
      mount_component(field2, target, anchor);
      insert(target, t2, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field1_changes = {};
      if (dirty & 8194) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 8196) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const actionsline_changes = {};
      if (dirty & 8)
        actionsline_changes.confirm = ["Finish", ctx2[6], !ctx2[3]];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "id", "account-name");
      attr(input, "type", "text");
      attr(input, "placeholder", "Satoshi");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$3(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: ctx[2]
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 4)
        address_changes.address = ctx2[2];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_default_slot_1$5(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      address: true,
      key: "account-address",
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 8196) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_pending_block$7(ctx) {
  let t;
  return {
    c() {
      t = text("Loading accounts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$d(ctx) {
  let h3;
  let t0_value = ctx[0] ? "Edit" : "New";
  let t0;
  let t1;
  let t2;
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$7,
    then: create_then_block$7,
    catch: create_catch_block$7,
    blocks: [, , ,]
  };
  handle_promise(ctx[5](), info);
  return {
    c() {
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" account");
      t2 = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, t1);
      insert(target, t2, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[0] ? "Edit" : "New"))
        set_data(t0, t0_value);
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$r(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8207) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let b_form_valid;
  let $yw_account_ref;
  let $yw_chain;
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(10, $yw_account_ref = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(8, $yw_chain = $$value));
  let { account } = $$props;
  const p_account = account;
  let g_account;
  let s_name = "";
  let sa_account;
  const completed = getContext("completed");
  const k_page = getContext("page");
  async function load_account() {
    const ks_accounts = await Accounts.read();
    $$invalidate(7, g_account = ks_accounts.at(p_account));
    $$invalidate(1, s_name = g_account.name);
  }
  async function save_account() {
    Object.assign(g_account, { name: s_name });
    await Accounts.open((ks_accounts) => ks_accounts.put(g_account));
    if (p_account === $yw_account_ref) {
      set_store_value(yw_account_ref, $yw_account_ref = p_account, $yw_account_ref);
    }
    if (completed) {
      completed(true);
    } else {
      k_page.reset();
    }
  }
  function input_input_handler() {
    s_name = this.value;
    $$invalidate(1, s_name);
  }
  $$self.$$set = ($$props2) => {
    if ("account" in $$props2)
      $$invalidate(0, account = $$props2.account);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$invalidate(3, b_form_valid = !!s_name);
    }
    if ($$self.$$.dirty & 384) {
      $$invalidate(2, sa_account = g_account ? Chains.addressFor(g_account.pubkey, $yw_chain) : "");
    }
  };
  return [
    account,
    s_name,
    sa_account,
    b_form_valid,
    completed,
    load_account,
    save_account,
    g_account,
    $yw_chain,
    input_input_handler
  ];
}
class AccountEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$r, safe_not_equal, { account: 0 });
  }
}
function create_catch_block$6(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$6(ctx) {
  let portrait;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[1],
      actions: ctx[3],
      $$slots: { subtitle: [create_subtitle_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portrait.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 65) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
    }
  };
}
function create_subtitle_slot$2(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: Chains.addressFor(ctx[0].pubkey)
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = Chains.addressFor(ctx2[0].pubkey);
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_pending_block$6(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$c(ctx) {
  let header;
  let t;
  let await_block_anchor;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      title: "Account"
    }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$6,
    then: create_then_block$6,
    catch: create_catch_block$6,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$q(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 65) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let { accountRef } = $$props;
  const p_account = accountRef;
  let g_account;
  const k_page = getContext("page");
  async function load_account() {
    const ks_accounts = await Accounts.read();
    return $$invalidate(0, g_account = ks_accounts.at(p_account));
  }
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: {
            from: Chains.addressFor(g_account.pubkey)
          }
        });
      }
    },
    recv: {
      label: "Receive",
      trigger() {
        popup_receive(p_account);
      }
    },
    edit: {
      label: "Edit",
      trigger() {
        k_page.push({
          creator: AccountEdit,
          props: { account: p_account }
        });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("accountRef" in $$props2)
      $$invalidate(4, accountRef = $$props2.accountRef);
  };
  return [g_account, p_account, load_account, gc_actions, accountRef];
}
class AccountView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$q, safe_not_equal, { accountRef: 4 });
  }
}
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i][0];
  child_ctx[6] = list[i][1];
  const constants_0 = Chains.addressFor(child_ctx[6].pubkey);
  child_ctx[7] = constants_0;
  return child_ctx;
}
function create_catch_block$5(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$5(ctx) {
  let previous_key = ctx[1];
  let key_block_anchor;
  let current;
  let key_block = create_key_block$1(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2 && safe_not_equal(previous_key, previous_key = ctx2[1])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_detail_slot$1(ctx) {
  let div;
  let t1;
  let address;
  let t2;
  let current;
  address = new Address({ props: { address: ctx[7] } });
  return {
    c() {
      div = element("div");
      div.textContent = "StarShell - - m/44'/118'/0'/0/??";
      t1 = space();
      create_component(address.$$.fragment);
      t2 = space();
      attr(div, "class", "hd-path");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
      mount_component(address, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = ctx2[7];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      destroy_component(address, detaching);
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$6(ctx) {
  let row;
  let current;
  function click_handler2() {
    return ctx[4](ctx[5]);
  }
  row = new Row({
    props: {
      resource: ctx[6],
      resourcePath: ctx[5],
      address: ctx[7],
      iconClass: "square pfp",
      $$slots: { detail: [create_detail_slot$1] },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1)
        row_changes.resource = ctx[6];
      if (dirty & 1)
        row_changes.resourcePath = ctx[5];
      if (dirty & 1)
        row_changes.address = ctx[7];
      if (dirty & 1025) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_key_block$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_pending_block$5(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$b(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "Accounts" } });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$5,
    then: create_then_block$5,
    catch: create_catch_block$5,
    blocks: [, , ,]
  };
  handle_promise(ctx[3](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$p(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Accounts",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1027) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let $yw_chain;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(1, $yw_chain = $$value));
  const k_page = getContext("page");
  let a_accounts;
  async function load_accounts() {
    const ks_accounts = await Accounts.read();
    return $$invalidate(0, a_accounts = ks_accounts.entries());
  }
  const click_handler2 = (p_account) => k_page.push({
    creator: AccountView,
    props: { accountRef: p_account }
  });
  return [a_accounts, $yw_chain, k_page, load_accounts, click_handler2];
}
class AccountsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$p, safe_not_equal, {});
  }
}
let id = 1;
function getId() {
  return `svelte-tabs-${id++}`;
}
function create_fragment$o(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-tabs");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "keydown", ctx[1]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
const TABS = {};
function removeAndUpdateSelected(arr, item, selectedStore) {
  const index = arr.indexOf(item);
  arr.splice(index, 1);
  selectedStore.update((selected) => selected === item ? arr[index] || arr[arr.length - 1] : selected);
}
function instance$m($$self, $$props, $$invalidate) {
  let $selectedTab;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { initialSelectedIndex = 0 } = $$props;
  const tabElements = [];
  const tabs = [];
  const panels = [];
  const controls = writable({});
  const labeledBy = writable({});
  const selectedTab = writable(null);
  component_subscribe($$self, selectedTab, (value) => $$invalidate(5, $selectedTab = value));
  const selectedPanel = writable(null);
  function registerItem(arr, item, selectedStore) {
    arr.push(item);
    selectedStore.update((selected) => selected || item);
    onDestroy(() => removeAndUpdateSelected(arr, item, selectedStore));
  }
  function selectTab(tab) {
    const index = tabs.indexOf(tab);
    selectedTab.set(tab);
    selectedPanel.set(panels[index]);
  }
  setContext(TABS, {
    registerTab(tab) {
      registerItem(tabs, tab, selectedTab);
    },
    registerTabElement(tabElement) {
      tabElements.push(tabElement);
    },
    registerPanel(panel) {
      registerItem(panels, panel, selectedPanel);
    },
    selectTab,
    selectedTab,
    selectedPanel,
    controls,
    labeledBy
  });
  onMount(() => {
    selectTab(tabs[initialSelectedIndex]);
  });
  afterUpdate(() => {
    for (let i = 0; i < tabs.length; i++) {
      controls.update((controlsData) => ({
        ...controlsData,
        [tabs[i].id]: panels[i].id
      }));
      labeledBy.update((labeledByData) => ({
        ...labeledByData,
        [panels[i].id]: tabs[i].id
      }));
    }
  });
  async function handleKeyDown(event) {
    if (event.target.classList.contains("svelte-tabs__tab")) {
      let selectedIndex = tabs.indexOf($selectedTab);
      switch (event.key) {
        case "ArrowRight":
          selectedIndex += 1;
          if (selectedIndex > tabs.length - 1) {
            selectedIndex = 0;
          }
          selectTab(tabs[selectedIndex]);
          tabElements[selectedIndex].focus();
          break;
        case "ArrowLeft":
          selectedIndex -= 1;
          if (selectedIndex < 0) {
            selectedIndex = tabs.length - 1;
          }
          selectTab(tabs[selectedIndex]);
          tabElements[selectedIndex].focus();
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("initialSelectedIndex" in $$props2)
      $$invalidate(2, initialSelectedIndex = $$props2.initialSelectedIndex);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [selectedTab, handleKeyDown, initialSelectedIndex, $$scope, slots];
}
class Tabs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$o, safe_not_equal, { initialSelectedIndex: 2 });
  }
}
function create_fragment$n(ctx) {
  let li;
  let li_aria_controls_value;
  let li_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  return {
    c() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      attr(li, "role", "tab");
      attr(li, "id", ctx[3].id);
      attr(li, "aria-controls", li_aria_controls_value = ctx[2][ctx[3].id]);
      attr(li, "aria-selected", ctx[1]);
      attr(li, "tabindex", li_tabindex_value = ctx[1] ? 0 : -1);
      attr(li, "class", "svelte-tabs__tab svelte-1fbofsd");
      toggle_class(li, "svelte-tabs__selected", ctx[1]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[10](li);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4 && li_aria_controls_value !== (li_aria_controls_value = ctx2[2][ctx2[3].id])) {
        attr(li, "aria-controls", li_aria_controls_value);
      }
      if (!current || dirty & 2) {
        attr(li, "aria-selected", ctx2[1]);
      }
      if (!current || dirty & 2 && li_tabindex_value !== (li_tabindex_value = ctx2[1] ? 0 : -1)) {
        attr(li, "tabindex", li_tabindex_value);
      }
      if (dirty & 2) {
        toggle_class(li, "svelte-tabs__selected", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let $selectedTab;
  let $controls;
  let { $$slots: slots = {}, $$scope } = $$props;
  let tabEl;
  const tab = { id: getId() };
  const { registerTab, registerTabElement, selectTab, selectedTab, controls } = getContext(TABS);
  component_subscribe($$self, selectedTab, (value) => $$invalidate(7, $selectedTab = value));
  component_subscribe($$self, controls, (value) => $$invalidate(2, $controls = value));
  let isSelected;
  registerTab(tab);
  onMount(async () => {
    await tick();
    registerTabElement(tabEl);
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tabEl = $$value;
      $$invalidate(0, tabEl);
    });
  }
  const click_handler2 = () => selectTab(tab);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(1, isSelected = $selectedTab === tab);
    }
  };
  return [
    tabEl,
    isSelected,
    $controls,
    tab,
    selectTab,
    selectedTab,
    controls,
    $selectedTab,
    $$scope,
    slots,
    li_binding,
    click_handler2
  ];
}
class Tab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$n, safe_not_equal, {});
  }
}
function create_fragment$m(ctx) {
  let ul;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr(ul, "role", "tablist");
      attr(ul, "class", "svelte-tabs__tab-list svelte-12yby2a");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TabList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$m, safe_not_equal, {});
  }
}
function create_if_block$9(ctx) {
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let div;
  let div_aria_labelledby_value;
  let current;
  let if_block = ctx[1] === ctx[2] && create_if_block$9(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "id", ctx[2].id);
      attr(div, "aria-labelledby", div_aria_labelledby_value = ctx[0][ctx[2].id]);
      attr(div, "class", "svelte-tabs__tab-panel svelte-epfyet");
      attr(div, "role", "tabpanel");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1] === ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 1 && div_aria_labelledby_value !== (div_aria_labelledby_value = ctx2[0][ctx2[2].id])) {
        attr(div, "aria-labelledby", div_aria_labelledby_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let $labeledBy;
  let $selectedPanel;
  let { $$slots: slots = {}, $$scope } = $$props;
  const panel = { id: getId() };
  const { registerPanel, selectedPanel, labeledBy } = getContext(TABS);
  component_subscribe($$self, selectedPanel, (value) => $$invalidate(1, $selectedPanel = value));
  component_subscribe($$self, labeledBy, (value) => $$invalidate(0, $labeledBy = value));
  registerPanel(panel);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [$labeledBy, $selectedPanel, panel, selectedPanel, labeledBy, $$scope, slots];
}
class TabPanel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$l, safe_not_equal, {});
  }
}
var SX_ICON_ASTRONAUT = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M64 224h13.5c24.7 56.5 80.9 96 146.5 96s121.8-39.5 146.5-96H384c8.8 0 16-7.2 16-16v-96c0-8.8-7.2-16-16-16h-13.5C345.8 39.5 289.6 0 224 0S102.2 39.5 77.5 96H64c-8.8 0-16 7.2-16 16v96c0 8.8 7.2 16 16 16zm40-88c0-22.1 21.5-40 48-40h144c26.5 0 48 17.9 48 40v24c0 53-43 96-96 96h-48c-53 0-96-43-96-96v-24zm72 72l12-36 36-12-36-12-12-36-12 36-36 12 36 12 12 36zm151.6 113.4C297.7 340.7 262.2 352 224 352s-73.7-11.3-103.6-30.6C52.9 328.5 0 385 0 454.4v9.6c0 26.5 21.5 48 48 48h80v-64c0-17.7 14.3-32 32-32h128c17.7 0 32 14.3 32 32v64h80c26.5 0 48-21.5 48-48v-9.6c0-69.4-52.9-125.9-120.4-133zM272 448c-8.8 0-16 7.2-16 16s7.2 16 16 16 16-7.2 16-16-7.2-16-16-16zm-96 0c-8.8 0-16 7.2-16 16v48h32v-48c0-8.8-7.2-16-16-16z"/></svg>';
function create_default_slot$a(ctx) {
  let header;
  let t0;
  let h3;
  let t2;
  let p0;
  let t4;
  let p1;
  let t6;
  let center;
  let span;
  let t7;
  let div;
  let button;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: { pops: true, title: "Not yet available" }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      h3 = element("h3");
      h3.textContent = "Nothing to see here!";
      t2 = space();
      p0 = element("p");
      p0.textContent = "This screen has not yet been implemented.";
      t4 = space();
      p1 = element("p");
      p1.textContent = "Please continue exploring the beta.";
      t6 = space();
      center = element("center");
      span = element("span");
      t7 = space();
      div = element("div");
      button = element("button");
      button.textContent = "Continue";
      attr(span, "class", "icon svelte-o7n71o");
      attr(button, "class", "primary");
      attr(div, "class", "action-line");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, h3, anchor);
      insert(target, t2, anchor);
      insert(target, p0, anchor);
      insert(target, t4, anchor);
      insert(target, p1, anchor);
      insert(target, t6, anchor);
      insert(target, center, anchor);
      append(center, span);
      span.innerHTML = SX_ICON_ASTRONAUT;
      insert(target, t7, anchor);
      insert(target, div, anchor);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(center);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$k(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 64) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let $yw_navigator;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(3, $yw_navigator = $$value));
  let { reset = false } = $$props;
  const b_reset = reset;
  const k_page = getContext("page");
  function cont() {
    if (b_reset) {
      k_page.reset();
      void $yw_navigator.activateThread(ThreadId.TOKENS);
    } else {
      k_page.pop();
    }
  }
  const click_handler2 = () => cont();
  $$self.$$set = ($$props2) => {
    if ("reset" in $$props2)
      $$invalidate(1, reset = $$props2.reset);
  };
  return [cont, reset, click_handler2];
}
class DeadEnd extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$k, safe_not_equal, { reset: 1 });
  }
}
function create_else_block$3(ctx) {
  let portrait;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[1],
      actions: ctx[2],
      $$slots: {
        subtitle: [create_subtitle_slot$1],
        default: [create_default_slot_1$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portrait.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 65) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
    }
  };
}
function create_if_block$8(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contact...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let t;
  return {
    c() {
      t = text("address");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_subtitle_slot$1(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: Chains.bech32(ctx[0].address)
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = Chains.bech32(ctx2[0].address);
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_default_slot$9(ctx) {
  let header;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      account: true
    }
  });
  const if_block_creators = [create_if_block$8, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$j(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 65) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let { contactRef } = $$props;
  const p_contact = contactRef;
  let g_contact;
  void Agents.getContact(p_contact).then((g) => $$invalidate(0, g_contact = g));
  const k_page = getContext("page");
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: { to: Chains.bech32(g_contact.address) }
        });
      }
    },
    edit: {
      label: "Edit",
      trigger() {
        k_page.push({
          creator: ContactEdit,
          props: { contactRef: p_contact }
        });
      }
    },
    delete: {
      label: "Delete",
      trigger() {
        k_page.push({ creator: DeadEnd });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("contactRef" in $$props2)
      $$invalidate(3, contactRef = $$props2.contactRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      g_contact ? Chains.bech32(g_contact.address) : "";
    }
  };
  return [g_contact, p_contact, gc_actions, contactRef];
}
class ContactView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$j, safe_not_equal, { contactRef: 3 });
  }
}
var SX_ICON_IMAGE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/>\n</svg>';
function create_if_block$7(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 48,
      ref: ctx[0],
      name: ctx[1]
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let div4;
  let div3;
  let span0;
  let t0;
  let span5;
  let div0;
  let t4;
  let div2;
  let div1;
  let span3;
  let t5;
  let span4;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] && create_if_block$7(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      span0 = element("span");
      if (if_block)
        if_block.c();
      t0 = space();
      span5 = element("span");
      div0 = element("div");
      div0.innerHTML = `<span class="warning svelte-1i7pjsy">Notice:</span> 
				<span class="info">Uploaded icons will be resized to be square. Only JPG &amp; PNG files less than 1MB allowed.</span>`;
      t4 = space();
      div2 = element("div");
      div1 = element("div");
      span3 = element("span");
      t5 = space();
      span4 = element("span");
      span4.textContent = "Upload Icon";
      attr(span0, "class", "left svelte-1i7pjsy");
      attr(div0, "class", "disclaimer svelte-1i7pjsy");
      attr(span3, "class", "icon svelte-1i7pjsy");
      attr(span4, "class", "text svelte-1i7pjsy");
      attr(div1, "class", "upload svelte-1i7pjsy");
      attr(div2, "class", "actions svelte-1i7pjsy");
      attr(span5, "class", "right svelte-1i7pjsy");
      attr(div3, "class", "row svelte-1i7pjsy");
      attr(div4, "class", "area svelte-1i7pjsy");
      toggle_class(div4, "intent-person", "person" === ctx[2]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, span0);
      if (if_block)
        if_block.m(span0, null);
      append(div3, t0);
      append(div3, span5);
      append(span5, div0);
      append(span5, t4);
      append(span5, div2);
      append(div2, div1);
      append(div1, span3);
      span3.innerHTML = SX_ICON_IMAGE;
      append(div1, t5);
      append(div1, span4);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[0])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { pfpRef } = $$props;
  const p_pfp = pfpRef || "";
  let { name = "" } = $$props;
  const s_name = name;
  let { intent = "token" } = $$props;
  const si_intent = intent;
  (async () => {
    if (p_pfp) {
      await Pfps.at(p_pfp);
    }
  })();
  const click_handler2 = () => F_NOOP;
  $$self.$$set = ($$props2) => {
    if ("pfpRef" in $$props2)
      $$invalidate(3, pfpRef = $$props2.pfpRef);
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("intent" in $$props2)
      $$invalidate(5, intent = $$props2.intent);
  };
  return [p_pfp, s_name, si_intent, pfpRef, name, intent, click_handler2];
}
class IconEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$i, safe_not_equal, { pfpRef: 3, name: 4, intent: 5 });
  }
}
function create_default_slot_6$1(ctx) {
  let iconeditor;
  let updating_name;
  let current;
  function iconeditor_name_binding(value) {
    ctx[17](value);
  }
  let iconeditor_props = {
    intent: "person",
    pfpRef: ctx[0]?.pfp
  };
  if (ctx[1] !== void 0) {
    iconeditor_props.name = ctx[1];
  }
  iconeditor = new IconEditor({ props: iconeditor_props });
  binding_callbacks.push(() => bind(iconeditor, "name", iconeditor_name_binding));
  return {
    c() {
      create_component(iconeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const iconeditor_changes = {};
      if (dirty & 1)
        iconeditor_changes.pfpRef = ctx2[0]?.pfp;
      if (!updating_name && dirty & 2) {
        updating_name = true;
        iconeditor_changes.name = ctx2[1];
        add_flush_callback(() => updating_name = false);
      }
      iconeditor.$set(iconeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconeditor, detaching);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let style;
  let t1;
  let span0;
  let t2_value = proper(ctx[9]) + "";
  let t2;
  let t3;
  let span1;
  let t4;
  let t5_value = ode(ctx[3]).filter(ctx[18]).map(func_1).join(", ") + "";
  let t5;
  let t6;
  return {
    c() {
      style = element("style");
      style.textContent = ".font-family_mono {\n  font-family: 'PT Mono';\n  white-space: pre;\n}\n.hide-scrollbar {\n  scrollbar-width: none;\n}\n.hide-scrollbar::-webkit-scrollbar {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-track {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-thumb {\n  background-color: rgba(0, 0, 0, 0.2);\n}\n.title {\n  font-family: Poppins;\n  font-weight: 400;\n  font-size: 14px;\n  color: var(--theme-color-text-light);\n}\n.examples {\n  margin-left: 0.5em;\n}";
      t1 = space();
      span0 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span1 = element("span");
      t4 = text("(");
      t5 = text(t5_value);
      t6 = text(")");
      attr(style, "lang", "less");
      attr(span0, "class", "title");
      attr(span1, "class", "examples");
    },
    m(target, anchor) {
      insert(target, style, anchor);
      insert(target, t1, anchor);
      insert(target, span0, anchor);
      append(span0, t2);
      insert(target, t3, anchor);
      insert(target, span1, anchor);
      append(span1, t4);
      append(span1, t5);
      append(span1, t6);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t2_value !== (t2_value = proper(ctx2[9]) + ""))
        set_data(t2, t2_value);
      if (dirty & 520 && t5_value !== (t5_value = ode(ctx2[3]).filter(ctx2[18]).map(func_1).join(", ") + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching)
        detach(style);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(span1);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "chain-family",
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 268435976) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_if_block_1$2(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[4]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[4] && create_if_block_1$2(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Enter a name");
      toggle_class(input, "invalid", ctx[4]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      if (dirty & 16) {
        toggle_class(input, "invalid", ctx2[4]);
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$6(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[5]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let input;
  let input_placeholder_value;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[5] && create_if_block$6(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "text");
      attr(input, "class", "address");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", input_placeholder_value = ctx[10].bech32s.acc + "1...");
      toggle_class(input, "invalid", ctx[5]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[2]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && input_placeholder_value !== (input_placeholder_value = ctx2[10].bech32s.acc + "1...")) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
      if (dirty & 32) {
        toggle_class(input, "invalid", ctx2[5]);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$3(ctx) {
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "placeholder", "");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(textarea, ctx[7]);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[21]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 128) {
        set_input_value(textarea, ctx2[7]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$8(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let field1;
  let t2;
  let field2;
  let t3;
  let field3;
  let t4;
  let field4;
  let t5;
  let hr;
  let t6;
  let h3;
  let t9;
  let inlinetags;
  let t10;
  let div;
  let button0;
  let t12;
  let button1;
  let t13_value = ctx[12] ? "Save" : "Add";
  let t13;
  let button1_readonly_value;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: {
      plain: true,
      pops: true,
      title: (ctx[12] ? "Edit" : "Add New") + " Contact"
    }
  });
  field0 = new Field({
    props: {
      key: "contact-pfp",
      name: "Profile Icon",
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      key: "chain-family",
      name: "Chain Family",
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      key: "contact-name",
      name: "Name",
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  field3 = new Field({
    props: {
      key: "contact-address",
      name: "Address",
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      key: "contact-notes",
      name: "Secure Notes",
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  inlinetags = new InlineTags({
    props: {
      editable: true,
      resourcePath: ctx[12]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      create_component(field1.$$.fragment);
      t2 = space();
      create_component(field2.$$.fragment);
      t3 = space();
      create_component(field3.$$.fragment);
      t4 = space();
      create_component(field4.$$.fragment);
      t5 = space();
      hr = element("hr");
      t6 = space();
      h3 = element("h3");
      h3.textContent = `${ctx[12] ? "Edit" : "Add"} Tags`;
      t9 = space();
      create_component(inlinetags.$$.fragment);
      t10 = space();
      div = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t12 = space();
      button1 = element("button");
      t13 = text(t13_value);
      attr(button1, "class", "primary");
      attr(button1, "readonly", button1_readonly_value = !ctx[8]);
      attr(div, "class", "action-line");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      mount_component(field1, target, anchor);
      insert(target, t2, anchor);
      mount_component(field2, target, anchor);
      insert(target, t3, anchor);
      mount_component(field3, target, anchor);
      insert(target, t4, anchor);
      mount_component(field4, target, anchor);
      insert(target, t5, anchor);
      insert(target, hr, anchor);
      insert(target, t6, anchor);
      insert(target, h3, anchor);
      insert(target, t9, anchor);
      mount_component(inlinetags, target, anchor);
      insert(target, t10, anchor);
      insert(target, div, anchor);
      append(div, button0);
      append(div, t12);
      append(div, button1);
      append(button1, t13);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[22]),
          listen(button1, "click", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 268435459) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 268435976) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 268435474) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const field3_changes = {};
      if (dirty & 268436516) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty & 268435584) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      if (!current || dirty & 256 && button1_readonly_value !== (button1_readonly_value = !ctx2[8])) {
        attr(button1, "readonly", button1_readonly_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t3);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t4);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(hr);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t9);
      destroy_component(inlinetags, detaching);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$h(ctx) {
  let screen;
  let current;
  let screen_props = {
    leaves: true,
    $$slots: { default: [create_default_slot$8] },
    $$scope: { ctx }
  };
  screen = new Screen({ props: screen_props });
  ctx[24](screen);
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 268437439) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[24](null);
      destroy_component(screen, detaching);
    }
  };
}
const func_1 = ([, g]) => g.bech32s.acc.hrp;
function instance$f($$self, $$props, $$invalidate) {
  let s_name;
  let s_addr;
  let sa_bech32;
  let s_notes;
  let si_agent_type;
  let b_form_valid;
  let $yw_family;
  let $yw_chain;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(9, $yw_family = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(10, $yw_chain = $$value));
  const k_page = getContext("page");
  let { contactRef = "" } = $$props;
  const p_contact = contactRef || "";
  let g_contact;
  if (p_contact)
    void Agents.getContact(p_contact).then((g) => $$invalidate(0, g_contact = g));
  let h_chains = {};
  (async function load_chains() {
    $$invalidate(3, h_chains = ofe((await Chains.read()).entries()));
  })();
  let s_err_name = "";
  let s_err_address = "";
  function pubkey_from_addr(sa_address, b_show_err = false) {
    const m_bech = R_BECH32.exec(sa_address);
    if (!m_bech) {
      if (b_show_err) {
        $$invalidate(5, s_err_address = "Invalid Bech32 address");
      }
      return "";
    }
    const [, s_chain, s_pubkey_local] = m_bech;
    let k_chain_match = null;
    for (const [, k_chain] of ode(H_CHAINS)) {
      if (k_chain.def.bechPrefix === s_chain) {
        k_chain_match = k_chain;
        break;
      }
    }
    if (b_show_err) {
      if (!k_chain_match) {
        $$invalidate(5, s_err_address = `No Cosmos SDK chains matched '${s_chain}'`);
      } else {
        $$invalidate(5, s_err_address = "");
      }
    }
    return $$invalidate(16, s_addr = s_pubkey_local);
  }
  let c_show_validations = 0;
  let y_screen;
  async function save() {
    if (!b_form_valid) {
      $$invalidate(15, c_show_validations++, c_show_validations);
      return;
    } else if (p_contact) {
      Object.assign(g_contact, {
        name: s_name,
        address: s_addr,
        pfp: g_contact.pfp,
        agentType: si_agent_type,
        notes: s_notes
      });
      k_page.reset();
    } else {
      $$invalidate(0, g_contact = {
        name: s_name,
        family: $yw_family,
        address: s_addr,
        pfp: g_contact.pfp,
        agentType: si_agent_type,
        notes: s_notes,
        space: "acc",
        origin: "user",
        chains: {}
      });
    }
    try {
      await Agents.open(async (ks_agents) => {
        await ks_agents.putContact(g_contact);
      });
      k_page.reset();
      k_page.push({
        creator: ContactView,
        props: { contactRef: p_contact }
      });
    } catch (e_write) {
    }
  }
  function iconeditor_name_binding(value) {
    s_name = value;
    $$invalidate(1, s_name), $$invalidate(0, g_contact);
  }
  const func = ([, g]) => $yw_family === g.family;
  function input_input_handler() {
    s_name = this.value;
    $$invalidate(1, s_name), $$invalidate(0, g_contact);
  }
  function input_input_handler_1() {
    sa_bech32 = this.value;
    $$invalidate(2, sa_bech32), $$invalidate(16, s_addr), $$invalidate(0, g_contact);
  }
  function textarea_input_handler() {
    s_notes = this.value;
    $$invalidate(7, s_notes), $$invalidate(0, g_contact);
  }
  const click_handler2 = () => k_page.pop();
  const click_handler_1 = () => save();
  function screen_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      y_screen = $$value;
      $$invalidate(6, y_screen);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("contactRef" in $$props2)
      $$invalidate(14, contactRef = $$props2.contactRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, s_name = g_contact?.name || "");
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(16, s_addr = g_contact?.address || "");
    }
    if ($$self.$$.dirty & 65536) {
      $$invalidate(2, sa_bech32 = s_addr ? Chains.bech32(s_addr) : "");
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(7, s_notes = g_contact?.notes || "");
    }
    if ($$self.$$.dirty & 1) {
      si_agent_type = g_contact?.agentType || ContactAgentType.PERSON;
    }
    if ($$self.$$.dirty & 6) {
      $$invalidate(8, b_form_valid = !!(s_name && pubkey_from_addr(sa_bech32)));
    }
    if ($$self.$$.dirty & 32774) {
      {
        if (c_show_validations) {
          $$invalidate(4, s_err_name = s_name ? "" : "Name must not be empty");
          pubkey_from_addr(sa_bech32, true);
        }
      }
    }
  };
  return [
    g_contact,
    s_name,
    sa_bech32,
    h_chains,
    s_err_name,
    s_err_address,
    y_screen,
    s_notes,
    b_form_valid,
    $yw_family,
    $yw_chain,
    k_page,
    p_contact,
    save,
    contactRef,
    c_show_validations,
    s_addr,
    iconeditor_name_binding,
    func,
    input_input_handler,
    input_input_handler_1,
    textarea_input_handler,
    click_handler2,
    click_handler_1,
    screen_binding
  ];
}
class ContactEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$h, safe_not_equal, { contactRef: 14 });
  }
}
var SX_ICON_DOTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-more-vert-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-more-vert-fg" d="M12 8C13.1 8 14 7.1 14 6C14 4.9 13.1 4 12 4C10.9 4 10 4.9 10 6C10 7.1 10.9 8 12 8ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10ZM12 16C10.9 16 10 16.9 10 18C10 19.1 10.9 20 12 20C13.1 20 14 19.1 14 18C14 16.9 13.1 16 12 16Z" fill="#FFB61A"/>\n</svg>\n';
var SX_ICON_SEND = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M9 16h6v-6h4l-7-7-7 7h4v6zm3-10.17L14.17 8H13v6h-2V8H9.83L12 5.83zM5 18h14v2H5z"/>\n</svg>';
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i][0];
  child_ctx[14] = list[i][1];
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_catch_block$4(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$4(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[12];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 63) {
        each_value = ctx2[12];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_detail_slot(ctx) {
  let address;
  let t;
  let current;
  address = new Address({
    props: {
      address: Chains.bech32(ctx[14].address + "")
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_prefix_slot(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "icon contact-type svelte-1l93agm");
      attr(span, "slot", "prefix");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_CONTACTS;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_tags_slot(ctx) {
  let inlinetags;
  let t;
  let current;
  inlinetags = new InlineTags({
    props: {
      collapsed: true,
      rootStyle: "margin: 0px;",
      resourcePath: ctx[13],
      $$slots: { prefix: [create_prefix_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inlinetags.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(inlinetags, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinetags_changes = {};
      if (dirty & 1048576) {
        inlinetags_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inlinetags.$set(inlinetags_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetags, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$5(ctx) {
  let span;
  let span_transition;
  let current;
  let each_value_1 = ctx[5];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(span, "class", "overlay");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span, null);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 36) {
        each_value_1 = ctx[5];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, slide, { duration: 300, easing: quintOut }, true);
        span_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!span_transition)
        span_transition = create_bidirectional_transition(span, slide, { duration: 300, easing: quintOut }, false);
      span_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_each(each_blocks, detaching);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_each_block_1$1(ctx) {
  let div;
  let span0;
  let raw_value = ctx[17].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[17].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler2(...args) {
    return ctx[9](ctx[17], ctx[14], ...args);
  }
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon");
      attr(span1, "class", "text");
      attr(div, "class", "action");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      span0.innerHTML = raw_value;
      append(div, t0);
      append(div, span1);
      append(span1, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(div, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_status_slot(ctx) {
  let span;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] === ctx[13] && create_if_block$5(ctx);
  return {
    c() {
      span = element("span");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      attr(span, "class", "icon more-menu");
      toggle_class(span, "active", ctx[0] === ctx[13]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_DOTS;
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[4](ctx[13], ctx[14]));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 5) {
        toggle_class(span, "active", ctx[0] === ctx[13]);
      }
      if (ctx[0] === ctx[13]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$5(ctx) {
  let row;
  let current;
  function click_handler_1(...args) {
    return ctx[10](ctx[14], ...args);
  }
  row = new Row({
    props: {
      resource: ctx[14],
      resourcePath: ctx[13],
      $$slots: {
        status: [create_status_slot],
        tags: [create_tags_slot],
        detail: [create_detail_slot]
      },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_1);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1048577) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contacts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$g(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block$4,
    value: 12,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "rows svelte-1l93agm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let $yw_family;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(11, $yw_family = $$value));
  const k_page = getContext("page");
  let { filter = (g) => true } = $$props;
  let { sort = (g_a, g_b) => g_a.name < g_b.name ? -1 : 1 } = $$props;
  let { append: append2 = [] } = $$props;
  async function load_contacts() {
    const ks_agents = await Agents.read();
    return [...ks_agents.contacts($yw_family)];
  }
  const hm_events = /* @__PURE__ */ new WeakMap();
  let si_overlay = "";
  function activate_overlay(p_contact, g_contact) {
    return (d_event) => {
      d_event.stopImmediatePropagation();
      const si_set = p_contact;
      if (hm_events.get(d_event)?.cancelMenu === si_set) {
        $$invalidate(0, si_overlay = "");
        return;
      }
      $$invalidate(0, si_overlay = si_set);
      window.addEventListener(
        "click",
        () => {
          hm_events.set(d_event, { cancelMenu: si_overlay });
          $$invalidate(0, si_overlay = "");
        },
        { capture: true, once: true }
      );
    };
  }
  const a_overlay_actions = [
    {
      label: "Edit",
      icon: SX_ICON_EDIT,
      click(g_contact) {
        k_page.push({
          creator: ContactEdit,
          props: { contact: g_contact }
        });
      }
    },
    {
      label: "Send",
      icon: SX_ICON_SEND,
      click(g_contact) {
        k_page.push({
          creator: Send,
          props: {
            recipient: Chains.bech32(g_contact.address)
          }
        });
      }
    },
    {
      label: "Delete",
      icon: SX_ICON_DELETE,
      click(g_contact) {
        k_page.push({ creator: DeadEnd, props: {} });
      }
    }
  ];
  const click_handler2 = (g_action, g_contact, d_event) => {
    d_event.stopPropagation();
    g_action.click(g_contact);
  };
  const click_handler_1 = (g_contact, d_event) => {
    if (!hm_events.get(d_event)?.cancelMenu) {
      k_page.push({
        creator: ContactView,
        props: { contact: g_contact }
      });
    }
  };
  $$self.$$set = ($$props2) => {
    if ("filter" in $$props2)
      $$invalidate(6, filter = $$props2.filter);
    if ("sort" in $$props2)
      $$invalidate(7, sort = $$props2.sort);
    if ("append" in $$props2)
      $$invalidate(8, append2 = $$props2.append);
  };
  return [
    si_overlay,
    k_page,
    load_contacts,
    hm_events,
    activate_overlay,
    a_overlay_actions,
    filter,
    sort,
    append2,
    click_handler2,
    click_handler_1
  ];
}
class ContactList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$g, safe_not_equal, { filter: 6, sort: 7, append: 8 });
  }
}
function create_default_slot_8(ctx) {
  let t;
  return {
    c() {
      t = text("All");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7(ctx) {
  let t;
  return {
    c() {
      t = text("Humans");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6(ctx) {
  let t;
  return {
    c() {
      t = text("Contracts");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let tab0;
  let t0;
  let tab1;
  let t1;
  let tab2;
  let current;
  tab0 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  tab1 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  tab2 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tab0.$$.fragment);
      t0 = space();
      create_component(tab1.$$.fragment);
      t1 = space();
      create_component(tab2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tab0, target, anchor);
      insert(target, t0, anchor);
      mount_component(tab1, target, anchor);
      insert(target, t1, anchor);
      mount_component(tab2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tab0_changes = {};
      if (dirty & 8) {
        tab0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab0.$set(tab0_changes);
      const tab1_changes = {};
      if (dirty & 8) {
        tab1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab1.$set(tab1_changes);
      const tab2_changes = {};
      if (dirty & 8) {
        tab2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab2.$set(tab2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tab0.$$.fragment, local);
      transition_in(tab1.$$.fragment, local);
      transition_in(tab2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tab0.$$.fragment, local);
      transition_out(tab1.$$.fragment, local);
      transition_out(tab2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tab0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(tab1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tab2, detaching);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({});
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_3$1(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({ props: { filter: ctx[0] } });
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({ props: { filter: ctx[1] } });
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_1$2(ctx) {
  let tablist;
  let t0;
  let tabpanel0;
  let t1;
  let tabpanel1;
  let t2;
  let tabpanel2;
  let current;
  tablist = new TabList({
    props: {
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  tabpanel0 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  tabpanel1 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  tabpanel2 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablist.$$.fragment);
      t0 = space();
      create_component(tabpanel0.$$.fragment);
      t1 = space();
      create_component(tabpanel1.$$.fragment);
      t2 = space();
      create_component(tabpanel2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablist, target, anchor);
      insert(target, t0, anchor);
      mount_component(tabpanel0, target, anchor);
      insert(target, t1, anchor);
      mount_component(tabpanel1, target, anchor);
      insert(target, t2, anchor);
      mount_component(tabpanel2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablist_changes = {};
      if (dirty & 8) {
        tablist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablist.$set(tablist_changes);
      const tabpanel0_changes = {};
      if (dirty & 8) {
        tabpanel0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel0.$set(tabpanel0_changes);
      const tabpanel1_changes = {};
      if (dirty & 8) {
        tabpanel1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel1.$set(tabpanel1_changes);
      const tabpanel2_changes = {};
      if (dirty & 8) {
        tabpanel2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel2.$set(tabpanel2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablist.$$.fragment, local);
      transition_in(tabpanel0.$$.fragment, local);
      transition_in(tabpanel1.$$.fragment, local);
      transition_in(tabpanel2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablist.$$.fragment, local);
      transition_out(tabpanel0.$$.fragment, local);
      transition_out(tabpanel1.$$.fragment, local);
      transition_out(tabpanel2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablist, detaching);
      if (detaching)
        detach(t0);
      destroy_component(tabpanel0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tabpanel1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(tabpanel2, detaching);
    }
  };
}
function create_default_slot$7(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let tabs;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "Contacts" } });
  tabs = new Tabs({
    props: {
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      create_component(tabs.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      mount_component(tabs, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_changes = {};
      if (dirty & 8) {
        tabs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabs.$set(tabs_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tabs, detaching);
    }
  };
}
function create_fragment$f(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      root: true,
      classNames: "contacts",
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$d($$self) {
  getContext("page");
  const func = (g_contact) => ContactAgentType.PERSON === g_contact.agentType;
  const func_12 = (g_contact) => ContactAgentType.CONTRACT === g_contact.agentType;
  return [func, func_12];
}
class ContactsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$f, safe_not_equal, {});
  }
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i][0];
  child_ctx[5] = list[i][1];
  return child_ctx;
}
function create_catch_block$3(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$4(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      pfp: ctx[5].pfp,
      name: ctx[5].host,
      resourcePath: ctx[4],
      iconClass: "square pfp"
    }
  });
  row.$on("click", ctx[2]);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$3(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$6(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({
    props: { bare: true, title: "Sites / Apps" }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    value: 3,
    blocks: [, , ,]
  };
  handle_promise(ctx[1](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$e(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "SitesHome",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 256) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$c($$self) {
  const k_page = getContext("page");
  async function load_apps() {
    const ks_apps = await Apps.read();
    return ks_apps.entries();
  }
  const click_handler2 = () => {
    k_page.push({});
  };
  return [k_page, load_apps, click_handler2];
}
class SitesHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$e, safe_not_equal, {});
  }
}
function create_else_block$2(ctx) {
  let portrait;
  let t0;
  let field;
  let t1;
  let if_block_anchor;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[2],
      actions: ctx[3],
      $$slots: {
        subtitle: [create_subtitle_slot],
        default: [create_default_slot_5]
      },
      $$scope: { ctx }
    }
  });
  field = new Field({
    props: {
      name: "gRPC-web URL",
      key: "grpc-web",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[0].rpcHost && create_if_block_1$1(ctx);
  return {
    c() {
      create_component(portrait.$$.fragment);
      t0 = space();
      create_component(field.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      insert(target, t0, anchor);
      mount_component(field, target, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 130) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
      const field_changes = {};
      if (dirty & 129) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
      if (ctx2[0].rpcHost) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      transition_in(field.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      transition_out(field.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field, detaching);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading network...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5(ctx) {
  let t;
  return {
    c() {
      t = text("address");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_subtitle_slot(ctx) {
  let span;
  let t0_value = ctx[1].name + "";
  let t0;
  let t1;
  let t2_value = ctx[1].id + "";
  let t2;
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" (");
      t2 = text(t2_value);
      t3 = text(")");
      attr(span, "class", "font-family_mono svelte-yy3tbl");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].name + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = ctx2[1].id + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_4(ctx) {
  let t_value = ctx[0].grpcWebUrl + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].grpcWebUrl + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "grpc-web-value",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 129) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let field;
  let current;
  field = new Field({
    props: {
      name: "RPC Host",
      key: "rpc",
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 129) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let t_value = ctx[0].rpcHost + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].rpcHost + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "rpc-value",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 129) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let header;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let gap;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      account: true
    }
  });
  const if_block_creators = [create_if_block$4, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  gap = new Gap({});
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      if_block.c();
      t1 = space();
      create_component(gap.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t1, anchor);
      mount_component(gap, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t1.parentNode, t1);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      transition_in(gap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      transition_out(gap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t1);
      destroy_component(gap, detaching);
    }
  };
}
function create_fragment$d(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 131) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let p_chain;
  let { networkRef } = $$props;
  const p_network = networkRef;
  let g_network;
  void Networks.at(p_network).then((g) => $$invalidate(0, g_network = g));
  let g_chain;
  getContext("page");
  const gc_actions = {};
  $$self.$$set = ($$props2) => {
    if ("networkRef" in $$props2)
      $$invalidate(4, networkRef = $$props2.networkRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(5, p_chain = g_network?.chain);
    }
    if ($$self.$$.dirty & 32) {
      if (p_chain) {
        void Chains.at(p_chain).then((g) => $$invalidate(1, g_chain = g));
      }
    }
  };
  return [g_network, g_chain, p_network, gc_actions, networkRef, p_chain];
}
class NetworkView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$d, safe_not_equal, { networkRef: 4 });
  }
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i][0];
  child_ctx[7] = list[i][1];
  const constants_0 = child_ctx[0].at(child_ctx[7].chain);
  child_ctx[8] = constants_0;
  return child_ctx;
}
function create_catch_block$2(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[5];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 7) {
        each_value = ctx2[5];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$3(ctx) {
  let row;
  let current;
  function click_handler2() {
    return ctx[3](ctx[6]);
  }
  row = new Row({
    props: {
      resource: ctx[7],
      resourcePath: ctx[6],
      iconClass: "square pfp",
      detail: `${ctx[8]?.name} (${ctx[8]?.id})`
    }
  });
  row.$on("click", click_handler2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1)
        row_changes.detail = `${ctx[8]?.name} (${ctx[8]?.id})`;
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$2(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$4(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { bare: true, title: "Networks" } });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2,
    value: 5,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$c(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "NetworksHome",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 2049) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  const k_page = getContext("page");
  let ks_chains;
  let ks_networks;
  async function load_networks() {
    $$invalidate(0, [ks_chains, ks_networks] = await Promise.all([Chains.read(), Networks.read()]), ks_chains);
    return ks_networks.entries();
  }
  const click_handler2 = (p_network) => {
    k_page.push({
      creator: NetworkView,
      props: { networkRef: p_network }
    });
  };
  return [ks_chains, k_page, load_networks, click_handler2];
}
class NetworksHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$c, safe_not_equal, {});
  }
}
function get_then_context(ctx) {
  const constants_0 = ctx[2].raw;
  ctx[3] = constants_0;
}
function create_catch_block$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$1(ctx) {
  get_then_context(ctx);
  let txnlist;
  let current;
  txnlist = new TxnList({ props: { events: ctx[3] } });
  return {
    c() {
      create_component(txnlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(txnlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      get_then_context(ctx2);
    },
    i(local) {
      if (current)
        return;
      transition_in(txnlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(txnlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(txnlist, detaching);
    }
  };
}
function create_pending_block$1(ctx) {
  let t;
  return {
    c() {
      t = text("Loading history...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_key_block(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    value: 2,
    blocks: [, , ,]
  };
  handle_promise(Events.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_default_slot$3(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let previous_key = ctx[0];
  let key_block_anchor;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "History", bare: true } });
  let key_block = create_key_block(ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_fragment$b(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 17) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let c_reloads = 1;
  const f_unsubscribe = global_receive({
    updateStore({ key: si_store }) {
      if ("events" === si_store) {
        $$invalidate(0, c_reloads++, c_reloads);
      }
    }
  });
  onDestroy(() => {
    f_unsubscribe();
  });
  return [c_reloads];
}
class HistoryHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$b, safe_not_equal, {});
  }
}
var ThreadId = /* @__PURE__ */ ((ThreadId2) => {
  ThreadId2["DEFAULT"] = "default";
  ThreadId2["INIT"] = "init";
  ThreadId2["SEARCH"] = "search";
  ThreadId2["TOKENS"] = "tokens";
  ThreadId2["NFTS"] = "nfts";
  ThreadId2["CONTACTS"] = "contacts";
  ThreadId2["HISTORY"] = "history";
  ThreadId2["NETWORKS"] = "networks";
  ThreadId2["ACCOUNTS"] = "accounts";
  ThreadId2["TAGS"] = "tags";
  ThreadId2["SITES"] = "sites";
  return ThreadId2;
})(ThreadId || {});
const H_THREADS = {
  ["default"]: Blank,
  ["init"]: Register,
  ["tokens"]: HoldingsHome,
  ["contacts"]: ContactsHome,
  ["history"]: HistoryHome,
  ["networks"]: NetworksHome,
  ["accounts"]: AccountsHome,
  ["sites"]: SitesHome
};
var Overscroll_svelte_svelte_type_style_lang = "";
function create_fragment$a(ctx) {
  let svg;
  let style;
  let t;
  let circle0;
  let circle1;
  let circle2;
  return {
    c() {
      svg = svg_element("svg");
      style = svg_element("style");
      t = text(".overscroll .bg {\n  fill: var(--theme-color-text-light);\n}\n.overscroll .ring {\n  fill: transparent;\n  stroke: #c4c4c4;\n}\n.overscroll .progress {\n  fill: transparent;\n  stroke: black;\n}\n");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      attr(style, "lang", "less");
      attr(circle0, "cx", "16");
      attr(circle0, "cy", "16");
      attr(circle0, "r", "16");
      attr(circle0, "class", "bg");
      attr(circle1, "cx", "16");
      attr(circle1, "cy", "16");
      attr(circle1, "r", "10");
      attr(circle1, "class", "ring");
      attr(circle1, "stroke-width", "3");
      set_style(circle1, "opacity", "0.2");
      attr(circle2, "cx", "16");
      attr(circle2, "cy", "16");
      attr(circle2, "r", "10");
      attr(circle2, "class", "progress svelte-1u2i3kk");
      attr(circle2, "stroke-width", "3");
      set_style(circle2, "stroke-dashoffset", 62 - ctx[1] * 62);
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "class", "overscroll svelte-1u2i3kk");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, style);
      append(style, t);
      append(svg, circle0);
      append(svg, circle1);
      append(svg, circle2);
      ctx[2](circle2);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        set_style(circle2, "stroke-dashoffset", 62 - ctx2[1] * 62);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      ctx[2](null);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $yw_overscroll_pct;
  component_subscribe($$self, yw_overscroll_pct, ($$value) => $$invalidate(1, $yw_overscroll_pct = $$value));
  let dm_progress;
  function circle2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_progress = $$value;
      $$invalidate(0, dm_progress);
    });
  }
  return [dm_progress, $yw_overscroll_pct, circle2_binding];
}
class Overscroll extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$a, safe_not_equal, {});
  }
}
var Popup_svelte_svelte_type_style_lang = "";
function create_fragment$9(ctx) {
  let div;
  let section;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[0];
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
  }
  return {
    c() {
      div = element("div");
      section = element("section");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(section, "class", "screen content svelte-rtd9ps");
      attr(div, "class", "popup svelte-rtd9ps");
      toggle_class(div, "showing", null !== ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, section);
      if (switch_instance) {
        mount_component(switch_instance, section, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(section, "click", click_handler),
          listen(div, "click", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (switch_value !== (switch_value = ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, section, null);
        } else {
          switch_instance = null;
        }
      }
      if (dirty & 1) {
        toggle_class(div, "showing", null !== ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
}
const click_handler = (d_event) => d_event.stopPropagation();
function instance$7($$self, $$props, $$invalidate) {
  let $yw_popup;
  component_subscribe($$self, yw_popup, ($$value) => $$invalidate(0, $yw_popup = $$value));
  const click_handler_1 = () => set_store_value(yw_popup, $yw_popup = null, $yw_popup);
  return [$yw_popup, click_handler_1];
}
class Popup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$9, safe_not_equal, {});
  }
}
var SX_ICON_EXPAND = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M12 16L18 10L16.59 8.59L12 13.17L7.41 8.59L6 10L12 16Z" />\n</svg>\n';
var SX_ICON_TOKENS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-tokens-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-tokens-fg" d="M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8Zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6ZM3 12a5.99 5.99 0 0 1 4-5.65V4.26C3.55 5.15 1 8.27 1 12c0 3.73 2.55 6.85 6 7.74v-2.09A5.99 5.99 0 0 1 3 12Z" />\n</svg>\n';
var SX_ICON_HISTORY = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M13 3a9 9 0 0 0-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42A8.954 8.954 0 0 0 13 21a9 9 0 0 0 0-18Zm-1 5v5l4.25 2.52.77-1.28-3.52-2.09V8H12Z" />\n</svg>\n';
var SX_ICON_MENU = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-menu-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-menu-fg" d="M4 19h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1Zm0-6h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1ZM3 6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1Z" />\n</svg>\n';
var Nav_svelte_svelte_type_style_lang = "";
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i][0];
  child_ctx[18] = list[i][1];
  return child_ctx;
}
function create_else_block$1(ctx) {
  let li;
  let div0;
  let html_tag;
  let raw_value = ctx[18].svg + "";
  let t0;
  let span;
  let t1;
  let div1;
  let t2_value = ctx[18].label + "";
  let t2;
  let t3;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[9](ctx[17]);
  }
  return {
    c() {
      li = element("li");
      div0 = element("div");
      html_tag = new HtmlTag(false);
      t0 = space();
      span = element("span");
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      html_tag.a = t0;
      attr(span, "class", "notification svelte-1ylq4j5");
      toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      attr(div0, "class", "icon svelte-1ylq4j5");
      attr(div1, "class", "label svelte-1ylq4j5");
      attr(li, "class", "button " + ctx[17] + " svelte-1ylq4j5");
      toggle_class(li, "active", ctx[0] === ctx[17]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      html_tag.m(raw_value, div0);
      append(div0, t0);
      append(div0, span);
      append(li, t1);
      append(li, div1);
      append(div1, t2);
      append(li, t3);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 18) {
        toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      }
      if (dirty & 17) {
        toggle_class(li, "active", ctx[0] === ctx[17]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$3(ctx) {
  let li;
  let div0;
  let html_tag;
  let raw_value = ctx[18].svg + "";
  let t0;
  let span;
  let t1;
  let div1;
  let t2_value = ctx[18].label + "";
  let t2;
  let t3;
  return {
    c() {
      li = element("li");
      div0 = element("div");
      html_tag = new HtmlTag(false);
      t0 = space();
      span = element("span");
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      html_tag.a = t0;
      attr(span, "class", "notification svelte-1ylq4j5");
      toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      attr(div0, "class", "icon svelte-1ylq4j5");
      attr(div1, "class", "label svelte-1ylq4j5");
      attr(li, "class", "button " + ctx[17] + " svelte-1ylq4j5");
      set_style(li, "opacity", "0.5");
      toggle_class(li, "active", ctx[0] === ctx[17]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      html_tag.m(raw_value, div0);
      append(div0, t0);
      append(div0, span);
      append(li, t1);
      append(li, div1);
      append(div1, t2);
      append(li, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 18) {
        toggle_class(span, "display_none", !ctx2[1].includes(ctx2[17]));
      }
      if (dirty & 17) {
        toggle_class(li, "active", ctx2[0] === ctx2[17]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_each_block$2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[18].disabled)
      return create_if_block$3;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$8(ctx) {
  let nav;
  let div;
  let t;
  let ul;
  let mounted;
  let dispose;
  let each_value = ode(ctx[4]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  return {
    c() {
      nav = element("nav");
      div = element("div");
      t = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "collapse icon svelte-1ylq4j5");
      attr(ul, "class", "bar svelte-1ylq4j5");
      attr(nav, "class", "svelte-1ylq4j5");
      toggle_class(nav, "collapsed", ctx[2]);
      toggle_class(nav, "visible", ctx[3]);
    },
    m(target, anchor) {
      insert(target, nav, anchor);
      append(nav, div);
      div.innerHTML = SX_ICON_EXPAND;
      append(nav, t);
      append(nav, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      if (!mounted) {
        dispose = listen(div, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 83) {
        each_value = ode(ctx2[4]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 4) {
        toggle_class(nav, "collapsed", ctx2[2]);
      }
      if (dirty & 8) {
        toggle_class(nav, "visible", ctx2[3]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(nav);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_thread;
  let $yw_page;
  let $yw_menu_expanded;
  let $yw_overlay_account;
  let $yw_overlay_network;
  let $yw_blur;
  let $yw_notifications;
  let $yw_nav_collapsed;
  let $yw_nav_visible;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(10, $yw_navigator = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(11, $yw_thread = $$value));
  component_subscribe($$self, yw_page, ($$value) => $$invalidate(7, $yw_page = $$value));
  component_subscribe($$self, yw_menu_expanded, ($$value) => $$invalidate(12, $yw_menu_expanded = $$value));
  component_subscribe($$self, yw_overlay_account, ($$value) => $$invalidate(13, $yw_overlay_account = $$value));
  component_subscribe($$self, yw_overlay_network, ($$value) => $$invalidate(14, $yw_overlay_network = $$value));
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(15, $yw_blur = $$value));
  component_subscribe($$self, yw_notifications, ($$value) => $$invalidate(1, $yw_notifications = $$value));
  component_subscribe($$self, yw_nav_collapsed, ($$value) => $$invalidate(2, $yw_nav_collapsed = $$value));
  component_subscribe($$self, yw_nav_visible, ($$value) => $$invalidate(3, $yw_nav_visible = $$value));
  const H_BUTTONS = {
    [ThreadId.TOKENS]: { svg: SX_ICON_TOKENS, label: "Tokens" },
    [ThreadId.CONTACTS]: {
      svg: SX_ICON_CONTACTS,
      label: "Contacts",
      disabled: true
    },
    [ThreadId.HISTORY]: { svg: SX_ICON_HISTORY, label: "History" },
    menu: { svg: SX_ICON_MENU, label: "Menu" }
  };
  const HM_HOMESCREENS = new Map(oderac(H_THREADS, (si_thread, dc_creator) => [dc_creator, si_thread]));
  let si_thread_head = "";
  function toggle_collapsed() {
    set_store_value(yw_nav_collapsed, $yw_nav_collapsed = !$yw_nav_collapsed, $yw_nav_collapsed);
  }
  function nav_click(si_button) {
    set_store_value(yw_notifications, $yw_notifications = $yw_notifications.filter((si) => si_button !== si), $yw_notifications);
    if ($yw_blur) {
      set_store_value(yw_blur, $yw_blur = false, $yw_blur);
    }
    if ($yw_overlay_network) {
      set_store_value(yw_overlay_network, $yw_overlay_network = false, $yw_overlay_network);
    }
    if ($yw_overlay_account) {
      set_store_value(yw_overlay_account, $yw_overlay_account = false, $yw_overlay_account);
    }
    switch (si_button) {
      case "menu": {
        set_store_value(yw_menu_expanded, $yw_menu_expanded = true, $yw_menu_expanded);
        break;
      }
      case si_thread_head: {
        $yw_navigator.activePage.dom.scrollTo({ top: 0, left: 0, behavior: "smooth" });
        break;
      }
      case $yw_thread.id: {
        const k_previous = $yw_page.peak();
        if (k_previous && HM_HOMESCREENS.get(k_previous.creator) === $yw_thread.id) {
          $yw_page.pop();
        } else {
          $yw_page.reset();
        }
        break;
      }
      default: {
        void $yw_navigator.activateThread(si_button);
        break;
      }
    }
  }
  const click_handler2 = () => toggle_collapsed();
  const click_handler_1 = (si_button) => nav_click(si_button);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(0, si_thread_head = $yw_page ? HM_HOMESCREENS.get($yw_page.creator) || "" : "");
    }
  };
  return [
    si_thread_head,
    $yw_notifications,
    $yw_nav_collapsed,
    $yw_nav_visible,
    H_BUTTONS,
    toggle_collapsed,
    nav_click,
    $yw_page,
    click_handler2,
    click_handler_1
  ];
}
class Nav extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$8, safe_not_equal, {});
  }
}
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
const PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
const MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
const BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
const FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
const AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}
var Search_svelte_svelte_type_style_lang = "";
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_each_block$1(ctx) {
  let genericrow;
  let current;
  genericrow = new GenericRow({ props: { item: ctx[9] } });
  return {
    c() {
      create_component(genericrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(genericrow, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(genericrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(genericrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(genericrow, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let header;
  let t0;
  let p;
  let t3;
  let div;
  let each_1_anchor;
  let current;
  const header_spread_levels = [
    { network: true },
    { account: true },
    { search: true },
    { isSearchScreen: true },
    ctx[2] || {}
  ];
  let header_props = {};
  for (let i = 0; i < header_spread_levels.length; i += 1) {
    header_props = assign(header_props, header_spread_levels[i]);
  }
  header = new Header({ props: header_props });
  header.$on("search", ctx[5]);
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      p = element("p");
      p.innerHTML = `<span style="color:var(--theme-color-caution);">Disclaimer:</span>
			This temporary search interface does not represent the look and function of the actual search interface currently under development for beta.`;
      t3 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      set_style(p, "font-size", "12px");
      attr(div, "class", "results no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, p, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append(div, each_1_anchor);
      ctx[6](div);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = dirty & 4 ? get_spread_update(header_spread_levels, [
        header_spread_levels[0],
        header_spread_levels[1],
        header_spread_levels[2],
        header_spread_levels[3],
        get_spread_object(ctx2[2] || {})
      ]) : {};
      header.$set(header_changes);
      if (dirty & 8) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(p);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      ctx[6](null);
    }
  };
}
function create_fragment$7(ctx) {
  let div;
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Search",
      root: true,
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(screen.$$.fragment);
      attr(div, "class", "search svelte-5f3tva");
      toggle_class(div, "display_none", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(screen, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 4102) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
      if (dirty & 1) {
        toggle_class(div, "display_none", !ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(screen);
    }
  };
}
var ClassType;
(function(ClassType2) {
  ClassType2["UNKNOWN"] = "unknown";
  ClassType2["FAMILY"] = "family";
  ClassType2["CHAIN"] = "chain";
  ClassType2["NETWORK"] = "network";
  ClassType2["ACCOUNT"] = "account";
  ClassType2["CONTACT"] = "contact";
  ClassType2["CONTRACT"] = "contract";
  ClassType2["TOKEN"] = "token";
  ClassType2["HOLDING"] = "holding";
  ClassType2["APP"] = "app";
  ClassType2["COIN"] = "coin";
  ClassType2["TAG"] = "tag";
  ClassType2["ICON"] = "icon";
  ClassType2["IBCT"] = "ibct";
  ClassType2["SNIP721"] = "snip721";
  ClassType2["TXN"] = "txn";
  ClassType2["OTHER"] = "other";
})(ClassType || (ClassType = {}));
function instance$5($$self, $$props, $$invalidate) {
  let $yw_search;
  let $yw_header_props;
  component_subscribe($$self, yw_search, ($$value) => $$invalidate(0, $yw_search = $$value));
  component_subscribe($$self, yw_header_props, ($$value) => $$invalidate(2, $yw_header_props = $$value));
  let dm_results;
  const a_results = [];
  let a_fuses = [];
  const fuzey = (a_items, a_keys) => new Fuse(
    a_items,
    {
      includeScore: true,
      includeMatches: true,
      keys: ["label", ...a_keys.map((s) => `details.${s}`)]
    }
  );
  (async () => {
    const ks_chains = await Chains.read();
    a_fuses = [
      (() => fuzey(
        ks_chains.entries().map(([p_chain, g_chain]) => ({
          class: ClassType.CHAIN,
          name: g_chain.name,
          resourcePath: p_chain,
          resource: g_chain,
          details: { name: g_chain.name, id: g_chain.id }
        })),
        ["id"]
      ))(),
      (() => fuzey(
        ks_chains.entries().flatMap(([p_chain, g_chain]) => oderac(g_chain.coins, (si_coin, g_coin) => ({
          class: ClassType.COIN,
          name: proper(g_coin.extra?.coingecko_id || "Unknown"),
          postname: si_coin,
          resourcePath: `${p_chain}/coin.${si_coin}`,
          resource: {
            name: proper(g_coin.extra?.coingecko_id || "Unknown"),
            pfp: g_chain.pfp,
            ...g_coin
          },
          details: {
            symbol: si_coin,
            denom: g_coin.denom,
            coingecko: g_coin.extra?.coingecko_id || ""
          }
        }))),
        ["symbol", "denom"]
      ))(),
      ...await Promise.all([
        (async () => {
          const ks_accounts = await Accounts.read();
          return fuzey(
            ks_accounts.entries().map(([p_account, g_account]) => {
              const a_addrs = [];
              const as_addrs = /* @__PURE__ */ new Set();
              for (const [, g_chain] of ks_chains) {
                as_addrs.add(Chains.addressFor(g_account.pubkey, g_chain));
              }
              a_addrs.push(...as_addrs);
              return {
                class: ClassType.ACCOUNT,
                name: g_account.name,
                resourcePath: p_account,
                resource: g_account,
                details: { name: g_account.name, addresses: a_addrs }
              };
            }),
            ["addresses"]
          );
        })(),
        (async () => {
          const ks_agents = await Agents.read();
          return fuzey(
            [...ks_agents.contacts()].map(([p_contact, g_contact]) => ({
              class: ClassType.CONTACT,
              name: g_contact.name,
              resourcePath: p_contact,
              resource: g_contact,
              details: {
                name: g_contact.name,
                notes: g_contact.notes,
                addresses: [...ks_chains.inFamily(g_contact.family)].map(([, g_chain]) => Chains.bech32(g_contact.address, g_chain))
              }
            })),
            ["notes"]
          );
        })(),
        (async () => {
          const ks_apps = await Apps.read();
          return fuzey(
            ks_apps.entries().map(([p_app, g_app]) => ({
              class: ClassType.APP,
              name: g_app.host,
              resourcePath: p_app,
              resource: g_app,
              details: { host: g_app.host }
            })),
            []
          );
        })(),
        (async () => {
          const a_tokens = [];
          for (const [, g_chain] of ks_chains.entries()) {
            for (const [si_spec, h_tokens] of ode(await Entities.readFungibleTokens(g_chain))) {
              for (const [p_token, g_token2] of ode(h_tokens)) {
                a_tokens.push({
                  class: ClassType.TOKEN,
                  name: g_token2.name,
                  resourcePath: p_token,
                  resource: g_token2,
                  details: {
                    spec: si_spec,
                    name: g_token2.name,
                    symbol: g_token2.symbol,
                    bech32: g_token2.bech32,
                    codehash: g_token2.hash
                  }
                });
              }
            }
          }
          return fuzey(a_tokens, ["spec", "symbol", "bech32", "codehash"]);
        })()
      ])
    ];
  })();
  function search2(s_search) {
    const a_groups = [];
    const a_hits = [];
    let c_total = 0;
    for (const y_fuse of a_fuses) {
      const a_hits_local = y_fuse.search(s_search);
      if (a_hits_local.length) {
        c_total += a_hits.length;
        a_hits.push(...a_hits_local);
        a_groups.push({
          top: a_hits_local[0].score,
          hits: a_hits_local
        });
      }
    }
    a_hits.sort((g_a, g_b) => g_b.score - g_a.score);
    $$invalidate(1, dm_results.innerHTML = "", dm_results);
    console.log(a_hits);
    for (const g_hit of a_hits) {
      new Row({
        target: dm_results,
        props: { ...g_hit.item, pfpDim: 32 }
      });
    }
  }
  const search_handler = (d_event) => search2(d_event.detail);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_results = $$value;
      $$invalidate(1, dm_results);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        if ($yw_search) {
          search2($yw_search);
        }
      }
    }
  };
  return [
    $yw_search,
    dm_results,
    $yw_header_props,
    a_results,
    search2,
    search_handler,
    div_binding
  ];
}
class Search extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$7, safe_not_equal, {});
  }
}
var Progress_svelte_svelte_type_style_lang = "";
function create_fragment$6(ctx) {
  let div1;
  let div0;
  let t0;
  let div2;
  let t1;
  let t2_value = (ctx[0][0] || ctx[0][1]) + "";
  let t2;
  let t3;
  let t4_value = ctx[0][1] + "";
  let t4;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      t1 = text("Step ");
      t2 = text(t2_value);
      t3 = text(" of ");
      t4 = text(t4_value);
      attr(div0, "class", "bar svelte-1hwu1hf");
      set_style(div0, "width", ctx[1] + "%");
      attr(div1, "class", "progress svelte-1hwu1hf");
      toggle_class(div1, "visible", ctx[0][0] > 0);
      attr(div2, "class", "step svelte-1hwu1hf");
      toggle_class(div2, "visible", ctx[0][0] > 0);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      append(div2, t1);
      append(div2, t2);
      append(div2, t3);
      append(div2, t4);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        set_style(div0, "width", ctx2[1] + "%");
      }
      if (dirty & 1) {
        toggle_class(div1, "visible", ctx2[0][0] > 0);
      }
      if (dirty & 1 && t2_value !== (t2_value = (ctx2[0][0] || ctx2[0][1]) + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx2[0][1] + ""))
        set_data(t4, t4_value);
      if (dirty & 1) {
        toggle_class(div2, "visible", ctx2[0][0] > 0);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div2);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let x_width_pct_bar;
  let $yw_progress;
  component_subscribe($$self, yw_progress, ($$value) => $$invalidate(0, $yw_progress = $$value));
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, x_width_pct_bar = $yw_progress[0] / $yw_progress[1] * 100);
    }
  };
  return [$yw_progress, x_width_pct_bar];
}
class Progress extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$6, safe_not_equal, {});
  }
}
var SX_ICON_CHAINS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="m18 16 4-4-4-4v3h-5.06A8.974 8.974 0 0 0 8 3.95 3.005 3.005 0 0 0 5 1C3.34 1 2 2.34 2 4s1.34 3 3 3c.95 0 1.78-.45 2.33-1.14C9.23 6.9 10.6 8.77 10.92 11h-3.1C7.4 9.84 6.3 9 5 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c1.3 0 2.4-.84 2.82-2h3.1c-.32 2.23-1.69 4.1-3.58 5.14C6.78 17.45 5.95 17 5 17c-1.66 0-3 1.34-3 3s1.34 3 3 3a2.99 2.99 0 0 0 2.99-2.95A8.974 8.974 0 0 0 12.93 13H18v3z"/>\n</svg>';
var SX_ICON_ACCOUNTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM7.07 18.28c.43-.9 3.05-1.78 4.93-1.78s4.51.88 4.93 1.78C15.57 19.36 13.86 20 12 20s-3.57-.64-4.93-1.72zm11.29-1.45c-1.43-1.74-4.9-2.33-6.36-2.33s-4.93.59-6.36 2.33A7.95 7.95 0 0 1 4 12c0-4.41 3.59-8 8-8s8 3.59 8 8c0 1.82-.62 3.49-1.64 4.83zM12 6c-1.94 0-3.5 1.56-3.5 3.5S10.06 13 12 13s3.5-1.56 3.5-3.5S13.94 6 12 6zm0 5c-.83 0-1.5-.67-1.5-1.5S11.17 8 12 8s1.5.67 1.5 1.5S12.83 11 12 11z"/>\n</svg>';
var SX_ICON_LOGOUT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M18 4v16H6V4h12m0-2H6c-1.1 0-2 .9-2 2v18h16V4c0-1.1-.9-2-2-2zm-2.5 8.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5S17 12.83 17 12s-.67-1.5-1.5-1.5z"/>\n</svg>';
var SideMenu_svelte_svelte_type_style_lang = "";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let li;
  let span0;
  let raw_value = ctx[10].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[10].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler_2() {
    return ctx[5](ctx[10]);
  }
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon svelte-fhv297");
      attr(span1, "class", "text svelte-fhv297");
      attr(li, "class", "svelte-fhv297");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span0);
      span0.innerHTML = raw_value;
      append(li, t0);
      append(li, span1);
      append(span1, t1);
      append(li, t2);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let li;
  let span0;
  let raw_value = ctx[10].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[10].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler_3() {
    return ctx[6](ctx[10]);
  }
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon svelte-fhv297");
      attr(span1, "class", "text svelte-fhv297");
      attr(li, "class", " svelte-fhv297");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span0);
      span0.innerHTML = raw_value;
      append(li, t0);
      append(li, span1);
      append(span1, t1);
      append(li, t2);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_3);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5(ctx) {
  let div6;
  let div0;
  let t0;
  let div5;
  let div1;
  let t1;
  let div4;
  let div2;
  let ul0;
  let t2;
  let hr;
  let t3;
  let div3;
  let ul1;
  let mounted;
  let dispose;
  let each_value_1 = ctx[2];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div6 = element("div");
      div0 = element("div");
      t0 = space();
      div5 = element("div");
      div1 = element("div");
      t1 = space();
      div4 = element("div");
      div2 = element("div");
      ul0 = element("ul");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      hr = element("hr");
      t3 = space();
      div3 = element("div");
      ul1 = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "backdrop svelte-fhv297");
      attr(div1, "class", "close icon svelte-fhv297");
      attr(ul0, "class", "session svelte-fhv297");
      attr(hr, "class", "svelte-fhv297");
      attr(div2, "class", "top svelte-fhv297");
      attr(ul1, "class", "items svelte-fhv297");
      attr(div3, "class", "main svelte-fhv297");
      attr(div4, "class", "menu svelte-fhv297");
      attr(div5, "class", "bar svelte-fhv297");
      attr(div6, "class", "side-menu svelte-fhv297");
      toggle_class(div6, "collapsed", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      append(div6, t0);
      append(div6, div5);
      append(div5, div1);
      div1.innerHTML = SX_ICON_CLOSE;
      append(div5, t1);
      append(div5, div4);
      append(div4, div2);
      append(div2, ul0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(ul0, null);
      }
      append(div2, t2);
      append(div2, hr);
      append(div4, t3);
      append(div4, div3);
      append(div3, ul1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul1, null);
      }
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[3]),
          listen(div1, "click", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value_1 = ctx2[2];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(ul0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & 2) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 1) {
        toggle_class(div6, "collapsed", !ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_menu_expanded;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(7, $yw_navigator = $$value));
  component_subscribe($$self, yw_menu_expanded, ($$value) => $$invalidate(0, $yw_menu_expanded = $$value));
  getContext("page");
  function activate(si_thread) {
    set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
    if (si_thread === $yw_navigator.activeThread.id) {
      $yw_navigator.activeThread.reset();
    } else {
      void $yw_navigator.activateThread(si_thread);
    }
  }
  const A_ITEMS = [
    {
      label: "Accounts",
      icon: SX_ICON_ACCOUNTS,
      click() {
        activate(ThreadId.ACCOUNTS);
      }
    },
    {
      label: "Networks",
      icon: SX_ICON_CHAINS,
      click() {
        activate(ThreadId.NETWORKS);
      }
    }
  ];
  const A_SESSION_ITEMS = [
    {
      label: "Log out",
      icon: SX_ICON_LOGOUT,
      async click() {
        await logout();
        globalThis.close();
      }
    }
  ];
  const click_handler2 = () => set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
  const click_handler_1 = () => set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
  const click_handler_2 = (g_item) => g_item.click();
  const click_handler_3 = (g_item) => g_item.click();
  return [
    $yw_menu_expanded,
    A_ITEMS,
    A_SESSION_ITEMS,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class SideMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$5, safe_not_equal, {});
  }
}
var VendorMenu_svelte_svelte_type_style_lang = "";
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text("[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$2(ctx) {
  let t0_value = (ctx[1] / 1e3).toFixed(2) + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" seconds");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = (ctx2[1] / 1e3).toFixed(2) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_fragment$4(ctx) {
  let div26;
  let div0;
  let t0;
  let div25;
  let div1;
  let t1;
  let div24;
  let div23;
  let div4;
  let div2;
  let t2;
  let div3;
  let t5;
  let div7;
  let div5;
  let t7;
  let div6;
  let t8;
  let t9;
  let div10;
  let div8;
  let t11;
  let div9;
  let span0;
  let t12;
  let t13;
  let div13;
  let div11;
  let t15;
  let div12;
  let span1;
  let t16;
  let t17;
  let div16;
  let div14;
  let t19;
  let div15;
  let t20;
  let t21;
  let t22;
  let div19;
  let div17;
  let t24;
  let div18;
  let t25;
  let div22;
  let div20;
  let t27;
  let div21;
  let t28;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block$2;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div26 = element("div");
      div0 = element("div");
      t0 = space();
      div25 = element("div");
      div1 = element("div");
      t1 = space();
      div24 = element("div");
      div23 = element("div");
      div4 = element("div");
      div2 = element("div");
      t2 = space();
      div3 = element("div");
      div3.textContent = `v${SI_VERSION}`;
      t5 = space();
      div7 = element("div");
      div5 = element("div");
      div5.textContent = "Network Status";
      t7 = space();
      div6 = element("div");
      t8 = text(ctx[2]);
      t9 = space();
      div10 = element("div");
      div8 = element("div");
      div8.textContent = "Chain Id";
      t11 = space();
      div9 = element("div");
      span0 = element("span");
      t12 = text(ctx[4]);
      t13 = space();
      div13 = element("div");
      div11 = element("div");
      div11.textContent = "Current Provider";
      t15 = space();
      div12 = element("div");
      span1 = element("span");
      t16 = text(ctx[3]);
      t17 = space();
      div16 = element("div");
      div14 = element("div");
      div14.textContent = "Current Block Height";
      t19 = space();
      div15 = element("div");
      t20 = text("#");
      t21 = text(ctx[0]);
      t22 = space();
      div19 = element("div");
      div17 = element("div");
      div17.textContent = "Average Block Time";
      t24 = space();
      div18 = element("div");
      if_block.c();
      t25 = space();
      div22 = element("div");
      div20 = element("div");
      div20.textContent = "Last Block Seen";
      t27 = space();
      div21 = element("div");
      t28 = text(ctx[5]);
      attr(div0, "class", "backdrop svelte-1y4wjl5");
      attr(div1, "class", "close icon svelte-1y4wjl5");
      attr(div4, "class", "app svelte-1y4wjl5");
      attr(div5, "class", "name svelte-1y4wjl5");
      attr(div6, "class", "value svelte-1y4wjl5");
      attr(div7, "class", "info svelte-1y4wjl5");
      attr(div8, "class", "name svelte-1y4wjl5");
      attr(span0, "class", "font-family_mono svelte-1y4wjl5");
      attr(div9, "class", "value svelte-1y4wjl5");
      attr(div10, "class", "info svelte-1y4wjl5");
      attr(div11, "class", "name svelte-1y4wjl5");
      attr(span1, "class", "font-family_mono svelte-1y4wjl5");
      attr(div12, "class", "value svelte-1y4wjl5");
      attr(div13, "class", "info svelte-1y4wjl5");
      attr(div14, "class", "name svelte-1y4wjl5");
      attr(div15, "class", "value svelte-1y4wjl5");
      attr(div16, "class", "info svelte-1y4wjl5");
      attr(div17, "class", "name svelte-1y4wjl5");
      attr(div18, "class", "value svelte-1y4wjl5");
      attr(div19, "class", "info svelte-1y4wjl5");
      attr(div20, "class", "name svelte-1y4wjl5");
      attr(div21, "class", "value svelte-1y4wjl5");
      attr(div22, "class", "info svelte-1y4wjl5");
      attr(div23, "class", "main svelte-1y4wjl5");
      attr(div24, "class", "menu svelte-1y4wjl5");
      attr(div25, "class", "bar svelte-1y4wjl5");
      attr(div26, "class", "vendor-menu svelte-1y4wjl5");
      toggle_class(div26, "collapsed", !ctx[6]);
    },
    m(target, anchor) {
      insert(target, div26, anchor);
      append(div26, div0);
      append(div26, t0);
      append(div26, div25);
      append(div25, div1);
      append(div25, t1);
      append(div25, div24);
      append(div24, div23);
      append(div23, div4);
      append(div4, div2);
      append(div4, t2);
      append(div4, div3);
      append(div23, t5);
      append(div23, div7);
      append(div7, div5);
      append(div7, t7);
      append(div7, div6);
      append(div6, t8);
      append(div23, t9);
      append(div23, div10);
      append(div10, div8);
      append(div10, t11);
      append(div10, div9);
      append(div9, span0);
      append(span0, t12);
      append(div23, t13);
      append(div23, div13);
      append(div13, div11);
      append(div13, t15);
      append(div13, div12);
      append(div12, span1);
      append(span1, t16);
      append(div23, t17);
      append(div23, div16);
      append(div16, div14);
      append(div16, t19);
      append(div16, div15);
      append(div15, t20);
      append(div15, t21);
      append(div23, t22);
      append(div23, div19);
      append(div19, div17);
      append(div19, t24);
      append(div19, div18);
      if_block.m(div18, null);
      append(div23, t25);
      append(div23, div22);
      append(div22, div20);
      append(div22, t27);
      append(div22, div21);
      append(div21, t28);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[8]),
          listen(div1, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4)
        set_data(t8, ctx2[2]);
      if (dirty & 16)
        set_data(t12, ctx2[4]);
      if (dirty & 8)
        set_data(t16, ctx2[3]);
      if (dirty & 1)
        set_data(t21, ctx2[0]);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div18, null);
        }
      }
      if (dirty & 32)
        set_data(t28, ctx2[5]);
      if (dirty & 64) {
        toggle_class(div26, "collapsed", !ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div26);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $yw_chain_ref;
  let $yw_network;
  let $yw_menu_vendor;
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(11, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_network, ($$value) => $$invalidate(7, $yw_network = $$value));
  component_subscribe($$self, yw_menu_vendor, ($$value) => $$invalidate(6, $yw_menu_vendor = $$value));
  let s_height = "";
  let xt_when = 0;
  let xt_avg_block_time = 0;
  let s_network_status = "Loading";
  let p_provider = "";
  let si_chain = "";
  global_receive({
    blockInfo(g_info) {
      if ($yw_chain_ref === g_info.chain) {
        $$invalidate(2, s_network_status = "Online");
        $$invalidate(4, si_chain = g_info.header.chain_id);
        $$invalidate(0, s_height = g_info.header.height);
        xt_when = Date.now();
        const a_recents = g_info.recents;
        if (a_recents.length > 1) {
          const a_gaps = [];
          for (let i_each = 1; i_each < a_recents.length; i_each++) {
            a_gaps.push(a_recents[i_each] - a_recents[i_each - 1]);
          }
          $$invalidate(1, xt_avg_block_time = a_gaps.reduce((c_out, x_value) => c_out + x_value, 0) / a_gaps.length);
        }
      }
    }
  });
  let s_long_ago = "[...]";
  const i_long_ago = window.setInterval(
    () => {
      if (xt_when > 0) {
        const xt_ago = Date.now() - xt_when;
        $$invalidate(5, s_long_ago = `${Math.round(xt_ago / 1e3)} seconds ago`);
      }
    },
    500
  );
  onDestroy(() => {
    clearInterval(i_long_ago);
  });
  const click_handler2 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = false, $yw_menu_vendor);
  const click_handler_1 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = false, $yw_menu_vendor);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      if ($yw_network) {
        $$invalidate(0, s_height = "[...]");
        xt_when = 0;
        $$invalidate(1, xt_avg_block_time = 0);
        $$invalidate(2, s_network_status = "Connecting");
        $$invalidate(3, p_provider = new URL($yw_network.grpcWebUrl).host);
        $$invalidate(4, si_chain = "");
      }
    }
  };
  return [
    s_height,
    xt_avg_block_time,
    s_network_status,
    p_provider,
    si_chain,
    s_long_ago,
    $yw_menu_vendor,
    $yw_network,
    click_handler2,
    click_handler_1
  ];
}
class VendorMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$4, safe_not_equal, {});
  }
}
class Page {
  constructor(gc_page, _kt_parent) {
    __publicField(this, "_dc_creator");
    __publicField(this, "_yc_component");
    __publicField(this, "_h_props");
    __publicField(this, "_h_context");
    __publicField(this, "_dm_page");
    __publicField(this, "_si_page");
    __publicField(this, "_h_events", {});
    __publicField(this, "_sr_path");
    __publicField(this, "_sx_pattern");
    this._kt_parent = _kt_parent;
    ({
      creator: this._dc_creator,
      props: this._h_props = {},
      context: this._h_context = {}
    } = gc_page);
    this._si_page = crypto.randomUUID();
    const dm_buffer = dd("div");
    const hm_context = new Map(ode({
      ...this._h_context,
      page: this
    }));
    this._yc_component = new this._dc_creator({
      target: dm_buffer,
      props: {
        ...this._h_props,
        k_page: this
      },
      context: hm_context
    });
    if (gc_page.events) {
      for (const [si_event, f_listener] of ode(gc_page.events)) {
        this._yc_component.$on(si_event, f_listener);
      }
    }
    const dm_state = dm_buffer.firstElementChild;
    if (!dm_state) {
      throw new Error(`No DOM element was created during page component spawning using: ${JSON.stringify(gc_page)}`);
    }
    this._dm_page = dm_state;
  }
  get id() {
    return this._si_page;
  }
  get index() {
    return this.thread.history.length;
  }
  get thread() {
    return this._kt_parent;
  }
  get creator() {
    return this._dc_creator;
  }
  get component() {
    return this._yc_component;
  }
  get props() {
    return this._h_props;
  }
  get dom() {
    return this._dm_page;
  }
  equivalent(w_other) {
    return w_other.creator === this.creator && !objects_might_differ(w_other.props || {}, this.props);
  }
  peak() {
    return this._kt_parent.peak();
  }
  push(gc_page) {
    return this._kt_parent.push(gc_page, this);
  }
  pop(gc_pop) {
    return this._kt_parent.pop(gc_pop || {}, this);
  }
  jump(gc_page, gc_jump) {
    return this._kt_parent.jump(gc_page, gc_jump || {}, this);
  }
  on(h_events) {
    for (const [si_event, f_listener] of ode(h_events)) {
      if (f_listener) {
        const a_listeners = this._h_events[si_event] = this._h_events[si_event] || [];
        a_listeners.push(f_listener);
      }
    }
  }
  async fire(si_event, a_args) {
    const a_listeners = this._h_events[si_event];
    if (a_listeners) {
      await Promise.all(a_listeners.map((f) => f(...a_args || [])));
    }
  }
  destroy() {
    this._yc_component.$destroy();
  }
  reset() {
    this._kt_parent.reset();
  }
}
class Thread {
  constructor(_si_thread, _gc_default, _k_navigator) {
    __publicField(this, "_dm_thread");
    __publicField(this, "_a_history", []);
    this._si_thread = _si_thread;
    this._gc_default = _gc_default;
    this._k_navigator = _k_navigator;
    this._dm_thread = dd("div", {
      "class": "thread",
      "data-thread-id": this._si_thread,
      "style": "z-index: 100;"
    });
  }
  get id() {
    return this._si_thread;
  }
  get default() {
    return this._gc_default;
  }
  get history() {
    return this._a_history;
  }
  get page() {
    return this._a_history[0];
  }
  get dom() {
    return this._dm_thread;
  }
  _place(gc_page) {
    const kp_new = new Page({
      ...gc_page,
      context: {
        ...this._k_navigator.context,
        ...gc_page.context
      }
    }, this);
    this._dm_thread.appendChild(kp_new.dom);
    this._a_history.unshift(kp_new);
    return kp_new;
  }
  reset(gc_page = this.default, gc_reset) {
    const {
      keepTop: b_keep_top
    } = gc_reset || {};
    const a_history = this._a_history;
    for (let i_state = b_keep_top ? 1 : 0; i_state < a_history.length; i_state++) {
      a_history[i_state].component.$destroy();
    }
    a_history.length = 0;
    const kp_new = this._place(gc_page);
    void this._k_navigator.after_reset(this, kp_new, gc_reset || {});
    return kp_new;
  }
  peak() {
    return this._a_history[1];
  }
  push(gc_page, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from pushing new screen");
    }
    if (!this._k_navigator.before_push(gc_page, kp_src, this)) {
      throw new Error("Prevented inactive thread from pushing new screen");
    }
    const kp_new = this._place(gc_page);
    void this._k_navigator.after_push(this, kp_src, kp_new);
    return kp_new;
  }
  pop(gc_pop, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from popping active screen");
    }
    if (this._a_history.length < 2) {
      throw new Error(`Failed to pop empty history`);
    }
    if (!this._k_navigator.before_pop(gc_pop, this._a_history[1], kp_src, this)) {
      throw new Error("Prevented inactive thread from popping active screen");
    }
    this._a_history.shift();
    const kp_dst = this.page;
    void this._k_navigator.after_pop(this, kp_src, kp_dst, gc_pop);
    return kp_dst;
  }
  jump(gc_page, gc_jump, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from jumping to screen");
    }
    if (!this._k_navigator.before_jump(gc_jump, gc_page, kp_src, this)) {
      throw new Error("Prevented inactive thread from jumping to screen");
    }
    const kp_prev = this._a_history[1];
    if (!gc_jump.force && kp_prev?.equivalent(gc_page)) {
      return this.pop({}, kp_src);
    }
    const kp_dst = new Page(gc_page, this);
    this.reset();
    set_zindex_relatively(kp_dst.dom, kp_src.dom, 1);
    void this._k_navigator.after_jump(this, kp_src, kp_dst, gc_jump).then(() => {
      try {
        kp_src.destroy();
      } catch (e_destroy) {
        console.warn(`Failed to destroy stale component belonging to page: ${kp_src.creator.name + ""}`);
        kp_src.dom.remove();
      }
    });
    return kp_dst;
  }
  hide() {
    this._dm_thread.style.display = "none";
  }
  show() {
    this._dm_thread.style.display = "initial";
  }
}
function set_zindex_relatively(dm_src, dm_dst, n_order) {
  const iz_src = +dm_src.style.zIndex;
  const iz_dst = iz_src + n_order;
  dm_src.style.zIndex = iz_src + "";
  dm_dst.style.zIndex = iz_dst + "";
}
class Navigator {
  constructor(_gc_navigator) {
    __publicField(this, "_h_threads", {});
    __publicField(this, "_h_thread_spawners");
    __publicField(this, "_dm_threads");
    __publicField(this, "_dm_buffer", dd("div"));
    __publicField(this, "_g_hooks");
    __publicField(this, "_h_context");
    __publicField(this, "_si_thread", ThreadId.DEFAULT);
    __publicField(this, "_c_thread_z", 200);
    this._gc_navigator = _gc_navigator;
    ({
      container: this._dm_threads,
      threads: this._h_thread_spawners,
      hooks: this._g_hooks,
      context: this._h_context = {}
    } = _gc_navigator);
    this._new_thread(ThreadId.DEFAULT);
  }
  get context() {
    return this._h_context;
  }
  _new_thread(si_thread, h_props = {}, h_context = {}) {
    const f_spawner = this._h_thread_spawners[si_thread];
    if (!f_spawner) {
      throw new Error(`Navigator has no such thread registered: '${si_thread}'`);
    }
    const kt_new = new Thread(si_thread, f_spawner(h_props, h_context), this);
    this._h_threads[si_thread] = kt_new;
    this._dm_threads.appendChild(kt_new.dom);
    kt_new.reset({
      ...kt_new.default,
      props: {
        ...kt_new.default.props,
        ...h_props
      }
    });
    return kt_new;
  }
  get activeThread() {
    return this._h_threads[this._si_thread];
  }
  get activePage() {
    return this.activeThread.page;
  }
  before_push(gc_page, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (false === this._g_hooks.before_change?.(kt_child, kp_src, "push"))
      return false;
    if (false === this._g_hooks.before_push?.(kt_child, kp_src, gc_page))
      return false;
    return true;
  }
  before_pop(gc_pop, kp_dst, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (false === this._g_hooks.before_change?.(kt_child, kp_src, "pop"))
      return false;
    if (false === this._g_hooks.before_pop?.(kt_child, kp_src, kp_dst, gc_pop))
      return false;
    return true;
  }
  before_jump(gc_jump, gc_page, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (false === this._g_hooks.before_change?.(kt_child, kp_src, "jump"))
      return false;
    if (false === this._g_hooks.before_jump?.(kt_child, kp_src, gc_page, gc_jump))
      return false;
    return true;
  }
  async before_switch(kt_src, si_thread) {
    if (false === this._g_hooks.before_change?.(kt_src, kt_src.page, "switch"))
      throw new Error("Cannot stop thread switch");
    await this._g_hooks.before_switch?.(kt_src, si_thread);
  }
  async after_push(kt_child, kp_src, kp_dst) {
    const h_extra = await this._g_hooks.after_push?.(kt_child, kp_src, kp_dst);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "push", h_extra || {});
  }
  async after_pop(kt_child, kp_src, kp_dst, gc_pop) {
    const h_extra = await this._g_hooks.after_pop?.(kt_child, kp_src, kp_dst, gc_pop);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "pop", h_extra || {});
  }
  async after_jump(kt_child, kp_src, kp_dst, gc_jump) {
    const h_extra = await this._g_hooks.after_jump?.(kt_child, kp_src, kp_dst, gc_jump);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "jump", h_extra || {});
  }
  async after_reset(kt_child, kp_dst, gc_reset) {
    const h_extra = await this._g_hooks.after_reset?.(kt_child, kp_dst, gc_reset);
    await this._g_hooks.after_change?.(kt_child, null, kp_dst, "reset", h_extra || {});
  }
  async after_switch(kt_src, kt_dst) {
    await this._g_hooks.after_switch?.(kt_src, kt_dst);
  }
  async activateThread(si_thread, h_props = {}) {
    const kt_src = this.activeThread;
    const kp_src = this.activePage;
    let kt_dst = this._h_threads[si_thread];
    if (si_thread !== this._si_thread) {
      await this.before_switch(kt_src, si_thread);
      this._si_thread;
      if (!kt_dst) {
        kt_dst = this._new_thread(si_thread, h_props);
      } else if (objects_might_differ(kt_dst.default.props || {}, h_props)) {
        const kp_dst = new Page({
          ...kt_dst.default,
          props: h_props,
          context: this._h_context
        }, kt_dst);
        kt_dst.reset(kp_dst, {
          keepTop: true
        });
        set_zindex_relatively(kp_src.dom, kp_dst.dom, -1);
      }
      this._si_thread = si_thread;
      this.activeThread.show();
      this.activeThread.dom.style.zIndex = this._c_thread_z++ + "";
      await this.after_switch(kt_src, kt_dst);
      return true;
    }
    return false;
  }
}
var System_svelte_svelte_type_style_lang = "";
function create_if_block$1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 25,
    blocks: [, , ,]
  };
  handle_promise(Vault.getRootKey(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[25] && create_if_block_1();
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1(ctx) {
  let overscrollsvelte;
  let t0;
  let navsvelte;
  let t1;
  let searchsvelte;
  let t2;
  let vendormenusvelte;
  let t3;
  let sidemenusvelte;
  let t4;
  let popupsvelte;
  let current;
  overscrollsvelte = new Overscroll({});
  navsvelte = new Nav({});
  searchsvelte = new Search({});
  vendormenusvelte = new VendorMenu({});
  sidemenusvelte = new SideMenu({});
  popupsvelte = new Popup({});
  return {
    c() {
      create_component(overscrollsvelte.$$.fragment);
      t0 = space();
      create_component(navsvelte.$$.fragment);
      t1 = space();
      create_component(searchsvelte.$$.fragment);
      t2 = space();
      create_component(vendormenusvelte.$$.fragment);
      t3 = space();
      create_component(sidemenusvelte.$$.fragment);
      t4 = space();
      create_component(popupsvelte.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overscrollsvelte, target, anchor);
      insert(target, t0, anchor);
      mount_component(navsvelte, target, anchor);
      insert(target, t1, anchor);
      mount_component(searchsvelte, target, anchor);
      insert(target, t2, anchor);
      mount_component(vendormenusvelte, target, anchor);
      insert(target, t3, anchor);
      mount_component(sidemenusvelte, target, anchor);
      insert(target, t4, anchor);
      mount_component(popupsvelte, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(overscrollsvelte.$$.fragment, local);
      transition_in(navsvelte.$$.fragment, local);
      transition_in(searchsvelte.$$.fragment, local);
      transition_in(vendormenusvelte.$$.fragment, local);
      transition_in(sidemenusvelte.$$.fragment, local);
      transition_in(popupsvelte.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overscrollsvelte.$$.fragment, local);
      transition_out(navsvelte.$$.fragment, local);
      transition_out(searchsvelte.$$.fragment, local);
      transition_out(vendormenusvelte.$$.fragment, local);
      transition_out(sidemenusvelte.$$.fragment, local);
      transition_out(popupsvelte.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overscrollsvelte, detaching);
      if (detaching)
        detach(t0);
      destroy_component(navsvelte, detaching);
      if (detaching)
        detach(t1);
      destroy_component(searchsvelte, detaching);
      if (detaching)
        detach(t2);
      destroy_component(vendormenusvelte, detaching);
      if (detaching)
        detach(t3);
      destroy_component(sidemenusvelte, detaching);
      if (detaching)
        detach(t4);
      destroy_component(popupsvelte, detaching);
    }
  };
}
function create_pending_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$3(ctx) {
  let main;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2;
  let progresssvelte;
  let t3;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  progresssvelte = new Progress({});
  let if_block = ctx[3] && create_if_block$1(ctx);
  return {
    c() {
      main = element("main");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(progresssvelte.$$.fragment);
      t3 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "content threads svelte-m1b0zj");
      attr(div1, "class", "content exitting svelte-m1b0zj");
      attr(main, "class", "viewport svelte-m1b0zj");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div0);
      ctx[8](div0);
      append(main, t0);
      append(main, div1);
      ctx[9](div1);
      append(main, t1);
      if (default_slot) {
        default_slot.m(main, null);
      }
      append(main, t2);
      mount_component(progresssvelte, main, null);
      append(main, t3);
      if (if_block)
        if_block.m(main, null);
      ctx[10](main);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (ctx2[3])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(progresssvelte.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(progresssvelte.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      ctx[8](null);
      ctx[9](null);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(progresssvelte);
      if (if_block)
        if_block.d();
      ctx[10](null);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_thread;
  let $yw_page;
  let $yw_account_ref;
  let $yw_account;
  let $yw_network_ref;
  let $yw_network_active;
  let $yw_chain_ref;
  let $yw_chain;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(11, $yw_navigator = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(12, $yw_thread = $$value));
  component_subscribe($$self, yw_page, ($$value) => $$invalidate(13, $yw_page = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(14, $yw_account_ref = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(15, $yw_account = $$value));
  component_subscribe($$self, yw_network_ref, ($$value) => $$invalidate(16, $yw_network_ref = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(17, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(18, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(19, $yw_chain = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { page } = $$props;
  const gc_page = page;
  let { mode } = $$props;
  const b_flow = "flow" === mode;
  const b_main = "app" === mode;
  let dm_viewport;
  let dm_threads;
  let dm_exitting;
  const h_context_all = Object.fromEntries(getAllContexts().entries());
  async function slide2(dm_slide, b_in = false) {
    await timeout(0);
    return new Promise((fk_resolve) => {
      dm_slide.addEventListener("transitionend", function transition_end(d_event) {
        if ("transform" === d_event.propertyName) {
          dm_slide.classList.add("slid");
          fk_resolve();
        }
      });
      dm_slide.style.transform = `translateX(${b_in ? "0px" : "var(--app-window-width)"})`;
    });
  }
  onMount(async () => {
    const gc_navigator = {
      container: dm_threads,
      context: h_context_all,
      threads: {
        default: () => ({ creator: Blank })
      },
      hooks: {
        before_change(kt_context, kp_src, kp_dst) {
          void kp_src.fire("blur");
        },
        after_push(kt_context, kp_src, kp_dst) {
          void tick().then(() => {
            void slide2(kp_dst.dom, true);
          });
        },
        after_pop(kt_context, kp_src, kp_dst, gc_pop) {
          void kp_dst.fire("restore");
          if (!gc_pop.bypassAnimation) {
            kp_src.dom.style.transform = `translateX(var(--app-window-width))`;
          }
        },
        after_change(kt_context, kp_src, kp_dst, s_transition, h_extra = {}) {
          set_store_value(yw_page, $yw_page = kp_dst, $yw_page);
          set_store_value(yw_thread, $yw_thread = kt_context, $yw_thread);
          void kp_dst.fire("focus");
        },
        async before_switch() {
          try {
            await Promise.all([
              $yw_chain || once_store_updates(yw_chain, true),
              Chains.read().then((ks) => set_store_value(yw_chain_ref, $yw_chain_ref = ode(ks.raw)[0][0], $yw_chain_ref)),
              $yw_network_active || once_store_updates(yw_network_active, true),
              Networks.read().then((ks) => set_store_value(yw_network_ref, $yw_network_ref = ode(ks.raw)[0][0], $yw_network_ref)),
              $yw_account || once_store_updates(yw_account, true),
              Accounts.read().then((ks) => set_store_value(yw_account_ref, $yw_account_ref = ode(ks.raw)[0][0], $yw_account_ref))
            ]);
            delete this.before_switch;
          } catch (e_load_default) {
          }
        },
        async after_switch(kt_src, kt_dst) {
          set_store_value(yw_page, $yw_page = kt_dst.page, $yw_page);
          set_store_value(yw_thread, $yw_thread = kt_dst, $yw_thread);
          void kt_dst.page.fire("focus");
          await tick();
          await slide2(kt_dst.page.dom, true);
        }
      }
    };
    if (b_flow) {
      gc_navigator.threads = { default: () => gc_page };
    } else if (b_main) {
      gc_navigator.threads = oderom(H_THREADS, (si_thread, dc_screen) => {
        return {
          [si_thread]: (h_props) => ({ creator: dc_screen, props: h_props })
        };
      });
      gc_navigator.threads.init = (h_props, h_context) => ({
        ...gc_page,
        props: { ...gc_page.props, ...h_props },
        context: { ...gc_page.context, ...h_context }
      });
    }
    const k_navigator = new Navigator(gc_navigator);
    set_store_value(yw_navigator, $yw_navigator = k_navigator, $yw_navigator);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_threads = $$value;
      $$invalidate(1, dm_threads);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_exitting = $$value;
      $$invalidate(2, dm_exitting);
    });
  }
  function main_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_viewport = $$value;
      $$invalidate(0, dm_viewport);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("page" in $$props2)
      $$invalidate(4, page = $$props2.page);
    if ("mode" in $$props2)
      $$invalidate(5, mode = $$props2.mode);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    dm_viewport,
    dm_threads,
    dm_exitting,
    b_main,
    page,
    mode,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    main_binding
  ];
}
class System extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$3, safe_not_equal, { page: 4, mode: 5 });
  }
}
var Authenticate_svelte_svelte_type_style_lang = "";
function create_if_block(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 2)
        set_data(t, ctx2[1]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_1(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "name", "password");
      attr(input, "placeholder", "Password");
      toggle_class(input, "invalid", ctx[1]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (dirty & 2) {
        toggle_class(input, "invalid", ctx2[1]);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$1(ctx) {
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t3;
  let div3;
  let field;
  let t4;
  let actionsline;
  let t5;
  let log_1;
  let updating_items;
  let current;
  field = new Field({
    props: {
      key: "password",
      name: "",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      confirm: ["Unlock", ctx[3]]
    }
  });
  function log_1_items_binding(value) {
    ctx[5](value);
  }
  let log_1_props = { hide: true };
  if (ctx[2].items !== void 0) {
    log_1_props.items = ctx[2].items;
  }
  log_1 = new Log({ props: log_1_props });
  binding_callbacks.push(() => bind(log_1, "items", log_1_items_binding));
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<img width="96" src="/media/vendor/logo-96px.png" srcset="/media/vendor/logo-96px.png 1x, /media/vendor/logo-192px.png 2x" alt="StarShell"/>`;
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<img src="/media/vendor/title.svg" alt=""/>`;
      t1 = space();
      div2 = element("div");
      div2.textContent = "\xA0";
      t3 = space();
      div3 = element("div");
      create_component(field.$$.fragment);
      t4 = space();
      create_component(actionsline.$$.fragment);
      t5 = space();
      create_component(log_1.$$.fragment);
      attr(div0, "class", "logo");
      attr(div1, "class", "title");
      attr(div2, "class", "line svelte-wsweyo");
      attr(div3, "class", "form flex-rows");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      insert(target, t3, anchor);
      insert(target, div3, anchor);
      mount_component(field, div3, null);
      insert(target, t4, anchor);
      mount_component(actionsline, target, anchor);
      insert(target, t5, anchor);
      mount_component(log_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 1027) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
      const log_1_changes = {};
      if (!updating_items && dirty & 4) {
        updating_items = true;
        log_1_changes.items = ctx2[2].items;
        add_flush_callback(() => updating_items = false);
      }
      log_1.$set(log_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      transition_in(log_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      transition_out(log_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div3);
      destroy_component(field);
      if (detaching)
        detach(t4);
      destroy_component(actionsline, detaching);
      if (detaching)
        detach(t5);
      destroy_component(log_1, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let t;
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Authenticate",
      classNames: "welcome",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1031) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(screen, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const completed = getContext("completed");
  let sh_password = "";
  let s_err_password = "";
  let b_busy = false;
  let xt_start = 0;
  let k_logger = new Logger();
  function log(s_msg) {
    $$invalidate(2, k_logger = k_logger.event(s_msg, Date.now() - xt_start));
  }
  async function attempt_unlock(b_recover = false) {
    if (b_busy)
      return 1;
    b_busy = true;
    const exit = () => (b_busy = false, 1);
    $$invalidate(1, s_err_password = "");
    xt_start = Date.now();
    log("Estimating time to complete");
    {
      const xt_start_est = window.performance.now();
      await Vault.deriveRootBits(ATU8_DUMMY_PHRASE, ATU8_DUMMY_VECTOR, 1 / 50);
      const xt_finish_est = window.performance.now();
      const xt_elapsed = xt_finish_est - xt_start_est;
      const xt_estimate = 2 * (xt_elapsed * 50);
      log(`About ${(xt_estimate / 1e3).toFixed(1)} seconds`);
    }
    try {
      await login(sh_password, b_recover, log);
    } catch (e_login) {
      if (e_login instanceof UnregisteredError) {
        $$invalidate(1, s_err_password = "No accounts detected");
      } else if (e_login instanceof InvalidPassphraseError) {
        $$invalidate(1, s_err_password = "Invalid passphrase");
      } else if (e_login instanceof RecoverableVaultError) {
        $$invalidate(1, s_err_password = "Vault is partially corrupted; attempting recovery...");
        return await attempt_unlock(true);
      } else if (b_recover) {
        $$invalidate(1, s_err_password = `Recovery failed. Vault may be irreparably corrupted.
${e_login.message}`);
      } else if (e_login instanceof CorruptedVaultError) {
        $$invalidate(1, s_err_password = `Vault appears to be irreparably corrupted.
${e_login.message}`);
      } else {
        $$invalidate(1, s_err_password = `Unknown error occurred: ${e_login.stack || e_login.message}`);
      }
      return exit();
    }
    if (completed)
      completed(true);
    return exit();
  }
  function input_input_handler() {
    sh_password = this.value;
    $$invalidate(0, sh_password);
  }
  function log_1_items_binding(value) {
    if ($$self.$$.not_equal(k_logger.items, value)) {
      k_logger.items = value;
      $$invalidate(2, k_logger);
    }
  }
  return [
    sh_password,
    s_err_password,
    k_logger,
    attempt_unlock,
    input_input_handler,
    log_1_items_binding
  ];
}
class Authenticate extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment$2, safe_not_equal, {});
  }
}
const dm_log = qs(document, "section#dom-log");
const dm_log_list = qs(document, "#dom-log-list");
function domlog(si_msg) {
  console.log(si_msg);
  dm_log_list?.append(dd("li", {}, [
    dd("pre", {}, [si_msg])
  ]));
}
var Horizon_svelte_svelte_type_style_lang = "";
function create_fragment$1(ctx) {
  let div;
  let raw_value = "&nbsp;";
  return {
    c() {
      div = element("div");
      attr(div, "class", "no-margin horizon svelte-12kmiz9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class Horizon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1, safe_not_equal, {});
  }
}
var PreRegister_svelte_svelte_type_style_lang = "";
function create_default_slot(ctx) {
  let starshelllogo;
  let t0;
  let starshelltitle;
  let t1;
  let horizon;
  let t2;
  let div2;
  let t6;
  let p;
  let t7;
  let actionsline;
  let current;
  starshelllogo = new StarShellLogo({ props: { dim: 96 } });
  starshelltitle = new StarShellTitle({});
  horizon = new Horizon({});
  actionsline = new ActionsLine({
    props: {
      confirm: ["Get Started"],
      contd: { creator: Register }
    }
  });
  return {
    c() {
      create_component(starshelllogo.$$.fragment);
      t0 = space();
      create_component(starshelltitle.$$.fragment);
      t1 = space();
      create_component(horizon.$$.fragment);
      t2 = space();
      div2 = element("div");
      div2.innerHTML = `<div>Welcome to the beta program.</div> 
		<div>Thank for you being a tester!</div>`;
      t6 = space();
      p = element("p");
      t7 = space();
      create_component(actionsline.$$.fragment);
      attr(div2, "class", "large");
    },
    m(target, anchor) {
      mount_component(starshelllogo, target, anchor);
      insert(target, t0, anchor);
      mount_component(starshelltitle, target, anchor);
      insert(target, t1, anchor);
      mount_component(horizon, target, anchor);
      insert(target, t2, anchor);
      insert(target, div2, anchor);
      insert(target, t6, anchor);
      insert(target, p, anchor);
      insert(target, t7, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      transition_in(starshelltitle.$$.fragment, local);
      transition_in(horizon.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      transition_out(starshelltitle.$$.fragment, local);
      transition_out(horizon.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starshelllogo, detaching);
      if (detaching)
        detach(t0);
      destroy_component(starshelltitle, detaching);
      if (detaching)
        detach(t1);
      destroy_component(horizon, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(p);
      if (detaching)
        detach(t7);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      root: true,
      classNames: "preregister",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
class PreRegister extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}
export { AccountEdit as A, Blank as B, Header as H, PreRegister as P, Screen as S, ThreadId as T, StarShellLogo as a, StarShellTitle as b, Horizon as c, dm_log as d, System as e, domlog as f, Authenticate as g };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJlUmVnaXN0ZXIuZGNmZjlmM2EuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0JsYW5rLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL1NjcmVlbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3VpL1N0YXJTaGVsbExvZ28uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9PdmVybGF5U2VsZWN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL2Fycm93LWxlZnQuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3NlYXJjaC5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vY2hlY2tlZC1jaXJjbGUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvSGVhZGVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvTG9nLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvU3RhclNoZWxsVGl0bGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vUmVnaXN0ZXJXZWFrUGFzc3dvcmQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vUmVnaXN0ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vYWNjb3VudF9ib3guc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2FuYWx5dGljcy5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vZG9udXRfbGFyZ2Uuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvQXNzZXRTZWxlY3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vZXhwYW5kX2xlc3Muc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2V4cGFuZF9tb3JlLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL3VpL0Ftb3VudElucHV0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvU2VuZGVyU2VsZWN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvSW5saW5lQ29udGFjdFNlbGVjdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3VpL1JlY2lwaWVudFNlbGVjdEl0ZW0uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9SZWNpcGllbnRTZWxlY3RTZWxlY3Rpb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9SZWNpcGllbnRTZWxlY3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vU2VuZE5hdGl2ZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9TZW5kLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvR2FwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jaGFpbi9jb2luLnRzIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSG9sZGluZ1ZpZXcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSG9sZGluZ3NIb21lLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRFZGl0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRWaWV3LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRzSG9tZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRhYnMvc3JjL2lkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10YWJzL3NyYy9UYWJzLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGFicy9zcmMvVGFiLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGFicy9zcmMvVGFiTGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRhYnMvc3JjL1RhYlBhbmVsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL3VzZXItYXN0cm9uYXV0LnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9EZWFkRW5kLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0NvbnRhY3RWaWV3LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL2ltYWdlLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL3VpL0ljb25FZGl0b3Iuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vQ29udGFjdEVkaXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vbW9yZS12ZXJ0LnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvaWNvbi91cGxvYWQuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvQ29udGFjdExpc3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vQ29udGFjdHNIb21lLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL1NpdGVzSG9tZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9OZXR3b3JrVmlldy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9OZXR3b3Jrc0hvbWUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSGlzdG9yeUhvbWUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9kZWYudHMiLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vT3ZlcnNjcm9sbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vUG9wdXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vZXhwYW5kLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvaWNvbi90b2tlbnMuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2hpc3Rvcnkuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL21lbnUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL3N5c3RlbS9OYXYuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Z1c2UuanMvZGlzdC9mdXNlLmVzbS5qcyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL3N5c3RlbS9TZWFyY2guc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9jb250YWluZXIvc3lzdGVtL1Byb2dyZXNzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL21lZGlhdGlvbi5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vYWNjb3VudF9jaXJjbGUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3NlbnNvcl9kb29yLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vU2lkZU1lbnUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9jb250YWluZXIvc3lzdGVtL1ZlbmRvck1lbnUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9uYXYvcGFnZS50cyIsIi4uLy4uLy4uL3NyYy9hcHAvbmF2L3RocmVhZC50cyIsIi4uLy4uLy4uL3NyYy9hcHAvbmF2L25hdmlnYXRvci50cyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL1N5c3RlbS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9BdXRoZW50aWNhdGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2VudHJ5L2ZhbGxiYWNrLnRzIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9Ib3Jpem9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL1ByZVJlZ2lzdGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c3BhbiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj48L3NwYW4+XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIiBsYW5nPVwidHNcIj5cblx0bGV0IGNfc2NyZWVucyA9IDA7XG48L3NjcmlwdD5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYXJyaXZhbCwgeXdfYmx1ciwgeXdfaGVscCwgeXdfbmF2X2NvbGxhcHNlZCwgeXdfbmF2X3Zpc2libGUsIHl3X292ZXJzY3JvbGxfcGN0LCB5d19wcm9ncmVzcyB9IGZyb20gJyMvYXBwL21lbSc7XG5cblx0aW1wb3J0IHR5cGUgeyBQYWdlIH0gZnJvbSAnLi4vc2NyZWVuL19zY3JlZW5zJztcblxuXHRpbXBvcnQgeyB0aW1lb3V0IH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIGdldENvbnRleHQsIG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgbmF2ID0gZmFsc2U7XG5cdGNvbnN0IGJfbmF2ID0gbmF2O1xuXG5cdGV4cG9ydCBsZXQgZGVidWcgPSAnJztcblx0ZXhwb3J0IGxldCBwcm9ncmVzczogbnVsbCB8IFtudW1iZXIsIG51bWJlcl0gPSBudWxsO1xuXHRleHBvcnQgbGV0IGZ1bGwgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBrZXllZCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGNsYXNzTmFtZXMgPSAnJztcblxuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRleHBvcnQgbGV0IGxlYXZlcyA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IHN3aXBlcyA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IHJvb3QgPSAwID09PSBrX3BhZ2UuaW5kZXg7XG5cdGV4cG9ydCBsZXQgc2xpZGVzID0gIWxlYXZlcyAmJiAhc3dpcGVzICYmICFyb290O1xuXHRjb25zdCBiX3NsaWRlcyA9IHNsaWRlcztcblxuXHRleHBvcnQgbGV0IGZvcm0gPSBmYWxzZTtcblx0Y29uc3QgYl9mb3JtID0gISFmb3JtO1xuXG5cdGV4cG9ydCBsZXQgdHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuXHRsZXQgZG1fc2NyZWVuOiBIVE1MRWxlbWVudDtcblxuXHQvLyBAbXZwXG5cdGxldCBkbV9oZWxwOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG5cdGNvbnN0IHNpX2V4aXQgPSBsZWF2ZXM/ICdsZWF2ZXMnOiBzd2lwZXM/ICdzd2lwZXMnOiAnJztcblxuXHRjb25zdCBkaXNwYXRjaEV2ZW50ID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cdG9uTW91bnQoKCkgPT4ge1xuXHRcdGlmKCFrX3BhZ2UpIHtcblx0XHRcdGNvbnNvbGUud2FybihgJHtkZWJ1ZyB8fCAndW5rbm93bid9IFNjcmVlbiBtaXNzaW5nIHBhZ2UgY29udGV4dGApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGxpc3RlbiBmb3IgcGFnZSBldmVudHNcblx0XHRcdGtfcGFnZS5vbih7XG5cdFx0XHRcdC8vIG9uIHBhZ2UgZm9jdXNcblx0XHRcdFx0Zm9jdXMoKSB7XG5cdFx0XHRcdFx0Ly8gc2V0IG5hdiB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0JHl3X25hdl92aXNpYmxlID0gYl9uYXY7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyAvLyBzY3JvbGxpbmdcblx0XHQvLyBkbV9zY3JlZW4uYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZGVfd2hlZWwpID0+IHtcblx0XHQvLyBcdC8vIG92ZXJzY3JvbGxcblx0XHQvLyBcdGlmKDAgPT09IGRtX3NjcmVlbi5zY3JvbGxUb3ApIHtcblx0XHQvLyBcdFx0aWYoZGVfd2hlZWwuRE9NX0RFTFRBX1BJWEVMID09PSBkZV93aGVlbC5kZWx0YU1vZGUpIHtcblx0XHQvLyBcdFx0XHQvLyBjb25zdCB4X2RlbHRhX3kgPSBkZV93aGVlbC5kZWx0YVk7XG5cdFx0Ly8gXHRcdFx0Ly8gY29uc3QgeF9wY3QgPSBNYXRoLm1pbihNYXRoLmFicyh4X2RlbHRhX3kpLCA1MCkgLyA1MDtcblx0XHQvLyBcdFx0XHQvLyAkeXdfb3ZlcnNjcm9sbF9wY3QgPSB4X3BjdDtcblx0XHQvLyBcdFx0XHQvLyBjb25zb2xlLmxvZygoeF9wY3QgKiAxMDApLnRvRml4ZWQoMikpO1xuXG5cdFx0Ly8gXHRcdFx0Ly8gY29uc29sZS5sb2coe1xuXHRcdC8vIFx0XHRcdC8vIFx0ZGVsdGFZOiBkZV93aGVlbC5kZWx0YVksXG5cdFx0Ly8gXHRcdFx0Ly8gXHQvLyB3aGVlbERlbHRhWTogZGVfd2hlZWwud2hlZWxEZWx0YVksXG5cdFx0Ly8gXHRcdFx0Ly8gXHRzY3JlZW5ZOiBkZV93aGVlbC5zY3JlZW5ZLFxuXHRcdC8vIFx0XHRcdC8vIFx0bW9kZTogZGVfd2hlZWwuZGVsdGFNb2RlLFxuXHRcdC8vIFx0XHRcdC8vIH0pO1xuXHRcdC8vIFx0XHR9XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfSk7XG5cblx0XHQvLyBhcnJpdmFsKGRtX3NjcmVlbiwgKCkgPT4ge1xuXHRcdC8vIFx0Y29uc29sZS5sb2coJ2Fycml2ZWQgdG8gc2NyZWVuJyk7XG5cdFx0Ly8gXHQkeXdfbmF2X3Zpc2libGUgPSBuYXY7XG5cdFx0Ly8gXHQvLyAkeXdfbmF2X2NvbGxhcHNlZCA9ICFuYXY7XG5cblx0XHQvLyBcdC8vIGlmKG5hdikge1xuXHRcdC8vIFx0Ly8gXHQkeXdfbmF2X3Zpc2libGUgPSB0cnVlO1xuXHRcdC8vIFx0Ly8gfVxuXG5cdFx0Ly8gXHRpZihwcm9ncmVzcykge1xuXHRcdC8vIFx0XHQkeXdfcHJvZ3Jlc3MgPSBwcm9ncmVzcztcblx0XHQvLyBcdH1cblxuXHRcdC8vIFx0JHl3X2hlbHAgPSBkbV9oZWxwXG5cdFx0Ly8gXHRcdD8gQXJyYXkuZnJvbShkbV9oZWxwLmNsb25lTm9kZSh0cnVlKS5jaGlsZE5vZGVzKSBhcyBIVE1MRWxlbWVudFtdXG5cdFx0Ly8gXHRcdDogW107XG5cblx0XHQvLyBcdGRpc3BhdGNoRXZlbnQoJ2Fycml2ZScpO1xuXHRcdC8vIH0pO1xuXG5cdFx0Ly8gaWYgc2NyZWVuIGhhcyBrZXllZCBzdmVsdGUgY29tcG9uZW50c1xuXHRcdGlmKGtleWVkKSB7XG5cdFx0XHRsZXQgeF9zY3JvbGxfdG9wID0gMDtcblxuXHRcdFx0Ly8gc3ZlbHRlIHdpbGwgcmVwbGFjZSB0aG9zZSBlbGVtZW50cyB3aGVuIGNoYW5naW5nIHNjcmVlbnNcblx0XHRcdChuZXcgTXV0YXRpb25PYnNlcnZlcihhc3luYyhhX211dGF0aW9ucykgPT4ge1xuXHRcdFx0XHQvLyBrZXllZCBjb21wb25lbnQgd2FzIHJlbW92ZWRcblx0XHRcdFx0aWYoYV9tdXRhdGlvbnNbMF0/LmFkZGVkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHhfc2Nyb2xsX3RvcCA9IGRtX3NjcmVlbi5zY3JvbGxUb3A7XG5cdFx0XHRcdFx0fSBjYXRjaChlX251bGwpIHt9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8ga2V5ZWQgY29tcG9uZW50IHdhcyByZXN0b3JlZFxuXHRcdFx0XHRlbHNlIGlmKGFfbXV0YXRpb25zWzBdPy5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYoZG1fc2NyZWVuKSB7XG5cdFx0XHRcdFx0XHRkbV9zY3JlZW4uc2Nyb2xsVG9wID0geF9zY3JvbGxfdG9wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSkpLm9ic2VydmUoZG1fc2NyZWVuLCB7XG5cdFx0XHRcdGNoaWxkTGlzdDogdHJ1ZSxcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0ZXhwb3J0IGxldCBzdHlsZSA9ICcnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdGRpdi5ib3VuZHMge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0cGFkZGluZy1sZWZ0OiBjYWxjKDUwdncgLSAodmFyKC0tYXBwLW1heC13aWR0aCkgLyAyKSk7XG5cdH1cblxuXHQuc2xpZGVzIHtcblx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoY2FsYyh2YXIoLS1hcHAtd2luZG93LXdpZHRoKSAvIDIpKTtcblx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC42cyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdH1cblxuXHRAbWVkaWEocHJlZmVycy1yZWR1Y2VkLW1vdGlvbikge1xuXHRcdC5zbGlkZXMge1xuXHRcdFx0dHJhbnNpdGlvbjogbm9uZSAwcyBsaW5lYXI7XG5cdFx0fVxuXHR9XG5cblx0c2VjdGlvbi5zY3JlZW4sZm9ybS5zY3JlZW4ge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRtYXgtd2lkdGg6IHZhcigtLWFwcC1tYXgtd2lkdGgpO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblxuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblxuXHRcdC5mb250KHJlZ3VsYXIpO1xuXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXG5cdFx0b3BhY2l0eTogMTtcblx0XHRmaWx0ZXI6IGJsdXIoMCk7XG5cblx0XHQvLyB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC42cyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cblx0XHQmLnRyYW5zcGFyZW50IHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdH1cblxuXHRcdCYucHJvZ3Jlc3Mge1xuXHRcdFx0cGFkZGluZy10b3A6IDIycHg7XG5cdFx0fVxuXG5cdFx0Ji5uYXYge1xuXHRcdFx0cGFkZGluZy1ib3R0b206IDcxcHg7XG5cdFx0fVxuXG5cdFx0Ji5mbGV4IHtcblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0YWxpZ24taXRlbXM6IHN0cmV0Y2g7XG5cdFx0XHRnYXA6IHZhcigtLWdhcCwgdmFyKC0tdWktcGFkZGluZykpO1xuXG5cdFx0XHQ+OmZpcnN0LWNoaWxkOm5vdCgubm8tbWFyZ2luKSB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1hcmdpbi10b3A6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCY+KiB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGZsZXg6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ6Z2xvYmFsKCY6bm90KC5uby1tYXJnaW4pKSB7XG5cdFx0XHRcdFx0bWFyZ2luOiAwIHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHQmLnNjcm9sbCB7XG5cdFx0XHRvdmVyZmxvdy15OiBzY3JvbGw7XG5cdFx0XHRvdmVyc2Nyb2xsLWJlaGF2aW9yLXk6IGNvbnRhaW47XG5cdFx0XHQuaGlkZS1zY3JvbGxiYXIoKTtcblx0XHR9XG5cblx0XHQvLyAmLnNsaWRlcyB7XG5cdFx0Ly8gXHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoY2FsYyh2YXIoLS1hcHAtd2luZG93LXdpZHRoKSAvIDIpKTtcblx0XHQvLyBcdHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjZzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0XHQvLyB9XG5cblx0XHQmLnNsaWQge1xuXHRcdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuNXMgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdH1cblxuXHRcdCZbZGF0YS1zMi1leGl0XTpub3QoW2RhdGEtczItZXhpdD0nJ10pIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQvLyBsZWZ0OiAwO1xuXHRcdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMHB4KTtcblx0XHRcdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuNXMgdmFyKC0tZWFzZS1vdXQtcXVpbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdEBrZXlmcmFtZXMgZmFkZS1hd2F5IHtcblx0XHRcdDAlIHtcblx0XHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdH1cblxuXHRcdFx0NzUlIHtcblx0XHRcdFx0b3BhY2l0eTogMDtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0QGtleWZyYW1lcyBibHVyLWF3YXkge1xuXHRcdFx0MCUge1xuXHRcdFx0XHRmaWx0ZXI6IGJsdXIoMCk7XG5cdFx0XHR9XG5cblx0XHRcdDEwMCUge1xuXHRcdFx0XHRmaWx0ZXI6IGJsdXIoMTRweCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0QGtleWZyYW1lcyBzY2FsZS11cCB7XG5cdFx0XHQwJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogc2NhbGUoMSk7XG5cdFx0XHR9XG5cblx0XHRcdDEwMCUge1xuXHRcdFx0XHR0cmFuc2Zvcm06IHNjYWxlKDEuNzUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEBrZXlmcmFtZXMgc3VibGltYXRlIHtcblx0XHQvLyBcdDAlIHtcblx0XHQvLyBcdFx0b3BhY2l0eTogMTtcblx0XHQvLyBcdFx0dHJhbnNmb3JtOiBzY2FsZSgxKTtcblx0XHQvLyBcdFx0ZmlsdGVyOiBibHVyKDApO1xuXHRcdC8vIFx0fVxuXG5cdFx0Ly8gXHQyNSUge1xuXHRcdC8vIFx0XHRmaWx0ZXI6IGJsdXIoMTRweCk7XG5cdFx0Ly8gXHR9XG5cblx0XHQvLyBcdDgwJSB7XG5cdFx0Ly8gXHRcdG9wYWNpdHk6IDA7XG5cdFx0Ly8gXHR9XG5cblx0XHQvLyBcdDEwMCUge1xuXHRcdC8vIFx0XHR0cmFuc2Zvcm06IHNjYWxlKDEuNzUpXG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfVxuXG5cdFx0QGtleWZyYW1lcyB0dXJuLWF3YXkge1xuXHRcdFx0MCUge1xuXHRcdFx0XHR0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDBweCkgcm90YXRlWSgwZGVnKTtcblx0XHRcdH1cblxuXHRcdFx0MSUge1xuXHRcdFx0XHR0cmFuc2Zvcm06IHBlcnNwZWN0aXZlKDE1MDBweCkgcm90YXRlWSgwZGVnKTtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMTUwMHB4KSByb3RhdGVZKC04MGRlZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0QGtleWZyYW1lcyBmYWRlLW91dCB7XG5cdFx0XHQwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0XHR9XG5cblx0XHRcdDEwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0XHR9XG5cblx0XHRcdDgwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDA7XG5cdFx0XHR9XG5cblx0XHRcdDEwMCUge1xuXHRcdFx0XHRvcGFjaXR5OiAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCYuc3VibGltYXRlIHtcblx0XHRcdC8vIGFuaW1hdGlvbjogXG5cdFx0XHQvLyBcdHNjYWxlLXVwIDEwMDBtcyB2YXIoLS1lYXNlLW91dC1jdWJpYykgZm9yd2FyZHMsXG5cdFx0XHQvLyBcdGZhZGUtYXdheSAxMDAwbXMgdmFyKC0tZWFzZS1vdXQtcXVhZCkgZm9yd2FyZHMsXG5cdFx0XHQvLyBcdGJsdXItYXdheSAyMDBtcyB2YXIoLS1lYXNlLW91dC1xdWFkKSBmb3J3YXJkcztcblxuXHRcdFx0Ly8gLS1taW1pYzogMTAwMG1zIHZhcigtLWVhc2Utb3V0LXF1aW50KSBmb3J3YXJkcztcblx0XHRcdC8vIGFuaW1hdGlvbjogdHVybi1hd2F5IHZhcigtLW1pbWljKSxcblx0XHRcdC8vIFx0ZmFkZS1vdXQgdmFyKC0tbWltaWMpO1xuXHRcdFx0Ly8gdHJhbnNmb3JtLW9yaWdpbjogMTIwJTtcblxuXHRcdFx0dHJhbnNpdGlvbjogb3BhY2l0eSA0MDBtcyB2YXIoLS1lYXNlLW91dC1xdWFkKTtcblx0XHRcdG9wYWNpdHk6IDA7XG5cdFx0fVxuXG5cdFx0Ji5tYXRlcmlhbGl6ZSB7XG5cblx0XHR9XG5cblx0XHQ+Kjpub3QoLmhlYWRlcikge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdHRyYW5zaXRpb246IGZpbHRlciA0MDBtcyB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ji5ibHVyIHtcblx0XHRcdD4qOm5vdCguaGVhZGVyKSB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGZpbHRlcjogYmx1cigycHgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cblxuXHRcdC8qXG5cdFx0XHRDb3BpZWQgZnJvbSBzY3JlZW4ubGVzc1xuXHRcdCovXG5cdFx0KiB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XG5cdFx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC50ZXh0Om5vdChidXR0b24gLnRleHQpOm5vdCgucm93IC50ZXh0KSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0dXNlci1zZWxlY3Q6IHRleHQ7XG5cdFx0XHRcdGN1cnNvcjogZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpbnB1dCx0ZXh0YXJlYSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0dXNlci1zZWxlY3Q6IGluaXRpYWw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnZhbGlkYXRpb24tbWVzc2FnZSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0LmZvbnQodGlueSk7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1jYXV0aW9uKTtcblx0XHRcdFx0dGV4dC1hbGlnbjogcmlnaHQ7XG5cdFx0XHRcdHdpZHRoOiAxMDAlO1xuXG5cdFx0XHRcdHBhZGRpbmctdG9wOiAzcHg7XG5cdFx0XHRcdG1hcmdpbi1sZWZ0OiAtOXB4O1xuXHRcdFx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnVzZXItc2VsZWN0X2FsbCB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0dXNlci1zZWxlY3Q6IGFsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuYWN0aW9ucy13YWxsLCAuYWN0aW9ucy1saW5lIHtcblx0XHRcdGJ1dHRvbiB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1pbi1oZWlnaHQ6IHZhcigtLXVpLXJvdy1oZWlnaHQpO1xuXHRcdFx0XHRcdG1heC1oZWlnaHQ6IHZhcigtLXVpLXJvdy1oZWlnaHQpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXG5cdFx0XHRcdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0tdWktYm9yZGVyLXJhZGl1cyk7XG5cblx0XHRcdFx0XHR0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDFzIHZhcigtLWVhc2Utb3V0LWV4cG8pLFxuXHRcdFx0XHRcdFx0Y29sb3IgMnMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ji5wcmltYXJ5IHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWRhcmspO1xuXHRcdFx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0JjpkaXNhYmxlZCwmW3JlYWRvbmx5PVwidHJ1ZVwiXSB7XG5cdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdFx0XHRcdFx0Y3Vyc29yOiBub3QtYWxsb3dlZDtcblx0XHRcdFx0XHRcdFx0b3BhY2l0eTogMC40O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJ1dHRvbiB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0XHR9XG5cblx0XHRcdCYucGlsbCB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdC5mb250KHJlZ3VsYXIsIEBzaXplOiAxMXB4LCBAd2VpZ2h0OiA1MDApO1xuXHRcdFx0XHRcdG1hcmdpbjogMDtcblx0XHRcdFx0XHRwYWRkaW5nOiAwLjRlbSAxZW07XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdGJvcmRlci1yYWRpdXM6IDQwMGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aDMge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGZvbnQtd2VpZ2h0OiA1MDA7XG5cdFx0XHRcdG1hcmdpbjogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuYWN0aW9uLXdhbGwge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xuXHRcdFx0XHRnYXA6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0fVxuXG5cdFx0XHQmPmJ1dHRvbiB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGZsZXg6IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRwIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udChyZWd1bGFyLCBAd2VpZ2h0OiAzMDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5mb3JtLWVudHJ5KCkge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0XHRoZWlnaHQ6IHZhcigtLXVpLXJvdy1oZWlnaHQpO1xuXHRcdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0XHRwYWRkaW5nLWxlZnQ6IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHRcdGJvcmRlci1yYWRpdXM6IHZhcigtLXVpLWJvcmRlci1yYWRpdXMpO1xuXHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXG5cdFx0XHRcdGZvbnQtd2VpZ2h0OiAzMDA7XG5cdFx0XHR9XG5cblx0XHRcdCY6OnBsYWNlaG9sZGVyIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0Zm9udC13ZWlnaHQ6IDMwMDtcblx0XHRcdFx0XHQvLyBjb2xvcjogcmdiKDExNywxMTcsMTE3KTtcblx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdG9wYWNpdHk6IDAuNztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQmOmZvY3VzIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0b3V0bGluZTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aW5wdXQge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGZvbnQtc2l6ZTogaW5oZXJpdDtcblx0XHRcdH1cblxuXHRcdFx0Jlt0eXBlPVwidGV4dFwiXSwmW3R5cGU9XCJwYXNzd29yZFwiXSwmW3R5cGU9XCJudW1iZXJcIl0ge1xuXHRcdFx0XHQuZm9ybS1lbnRyeSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQmLmludmFsaWQ6bm90KDpmb2N1cykge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRib3JkZXI6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1jYXV0aW9uKSAhaW1wb3J0YW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCYuYWRkcmVzcyB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdC5mb250KG1vbm8tdGlueSk7XG5cdFx0XHRcdFx0bGV0dGVyLXNwYWNpbmc6IDAuMjVweDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5zZWxlY3RDb250YWluZXIuaW52YWxpZCB7XG5cdFx0XHRpbnB1dCB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pICFpbXBvcnRhbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZXh0YXJlYSB7XG5cdFx0XHQuZm9ybS1lbnRyeSgpO1xuXG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0LmZvbnQocmVndWxhcik7XG5cblx0XHRcdFx0cGFkZGluZzogMWV4IDJleDtcblx0XHRcdFx0aGVpZ2h0OiAxMC43NWV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0LmZsZXgtcm93cyB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0YWxpZ24taXRlbXM6IHN0cmV0Y2g7XG5cdFx0XHRcdGdhcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHR9XG5cblx0XHRcdCY+KiB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGZsZXg6IDA7XG5cdFx0XHRcdFx0bWFyZ2luLXRvcDogMDtcblx0XHRcdFx0XHRtYXJnaW4tYm90dG9tOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmZvbnQtdmFyaWFudF9tb25vIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udChtb25vKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuZm9udC12YXJpYW50X21vbm8tdGlueSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0LmZvbnQobW9uby10aW55KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuY29sb3ItaWNvbi1zZW5kIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3Itb3JhbmdlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuY29sb3ItaWNvbi1yZWN2IHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3Itc2xpbWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5saW5rIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdH1cblxuXHRcdFx0Jjpob3ZlciB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnN2ZWx0ZS10YWJzIHtcblx0XHRcdD51bC5zdmVsdGUtdGFic19fdGFiLWxpc3Qge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRcdGp1c3RpZnktY29udGVudDogc3RyZXRjaDtcblxuXHRcdFx0XHRcdG1hcmdpbi1sZWZ0OiBjYWxjKDBweCAtIHZhcigtLXVpLXBhZGRpbmcpKTtcblx0XHRcdFx0XHRtYXJnaW4tcmlnaHQ6IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHRcdFx0XHRcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0PmxpLnN2ZWx0ZS10YWJzX190YWIge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0ZmxleDogMTtcblx0XHRcdFx0XHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblxuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWdyYXltZWQpO1xuXHRcdFx0XHRcdFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRcdFx0XHRcdFx0cGFkZGluZzogMTJweCAwLjc1ZW07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ji5zdmVsdGUtdGFic19fc2VsZWN0ZWQge1xuXHRcdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHRcdFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQ+ZGl2LnN2ZWx0ZS10YWJzX190YWItcGFuZWwge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRtYXJnaW4tdG9wOiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG48L3N0eWxlPlxuPCEtLSBjbGFzczpzbGlkZXM9e3NsaWRlc30gLS0+XG5cbjxkaXYgY2xhc3M9XCJib3VuZHNcIlxuXHRjbGFzczpzbGlkZXM9e2Jfc2xpZGVzfVxuPlxuXHQ8Zm9ybVxuXHRcdGNsYXNzPVwic2NyZWVuIHtjbGFzc05hbWVzfVwiXG5cdFx0Y2xhc3M6ZmxleD17dHJ1ZX1cblx0XHRjbGFzczpzY3JvbGw9e3RydWV9XG5cdFx0Y2xhc3M6bmF2PXtiX25hdn1cblx0XHRjbGFzczpwcm9ncmVzcz17cHJvZ3Jlc3N9XG5cdFx0Y2xhc3M6dHJhbnNwYXJlbnQ9e3RyYW5zcGFyZW50fVxuXHRcdGNsYXNzOnN1YmxpbWF0ZT17ZmFsc2V9XG5cdFx0Y2xhc3M6Ymx1cj17JHl3X2JsdXJ9XG5cdFx0ZGF0YS1zMi1leGl0PXtzaV9leGl0fVxuXHRcdGJpbmQ6dGhpcz17ZG1fc2NyZWVufVxuXHRcdG9uOnN1Ym1pdD17ZF9ldmVudCA9PiB2b2lkIGRfZXZlbnQucHJldmVudERlZmF1bHQoKX1cblx0XHRvbjpzdWJtaXRcblx0XHRzdHlsZT1cIntzdHlsZX1cIlxuXHRcdGF1dG9jb21wbGV0ZT1cIm9mZlwiXG5cdD5cblx0XHQ8c2xvdD48L3Nsb3Q+XG5cblx0XHR7I2lmICdoZWxwJyBpbiAkJHNsb3RzfVxuXHRcdFx0PGRpdiBjbGFzcz1cImRpc3BsYXlfbm9uZVwiIGJpbmQ6dGhpcz17ZG1faGVscH0+XG5cdFx0XHRcdDxzbG90IG5hbWU9XCJoZWxwXCIgLz5cblx0XHRcdDwvZGl2PlxuXHRcdHsvaWZ9XG5cdDwvZm9ybT5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgRl9OT09QIH0gZnJvbSBcIiMvdXRpbC9iZWx0XCI7XG5cblx0LyoqXG5cdCAqIHRhcmdldCBkaW1lbnNpbm9zXG5cdCAqL1xuXHRleHBvcnQgbGV0IGRpbTogMzIgfCA0OCB8IDY0IHwgOTYgfCAxMjg7XG5cdGNvbnN0IHhfZGltID0gZGltO1xuXG5cdC8qKlxuXHQgKiBhbHRlcm5hdGl2ZSB0ZXh0XG5cdCAqL1xuXHRleHBvcnQgbGV0IGFsdCA9ICdTdGFyU2hlbGwgbG9nbyc7XG5cdGNvbnN0IHNfYWx0ID0gYWx0O1xuXG5cdGNvbnN0IGZfc3JjID0gKHg6IG51bWJlcikgPT4gYC9tZWRpYS92ZW5kb3IvbG9nby0ke3h9cHgucG5nYDtcblxuXHRjb25zdCBzcl9kZWZhdWx0ID0gZl9zcmMoeF9kaW0pO1xuXHRjb25zdCBzcl9kb3VibGUgPSBmX3NyYyh4X2RpbSAqIDIpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQubG9nbyB7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdHBhZGRpbmc6IDA7XG5cdFx0Ym9yZGVyOiAwO1xuXHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0bWFyZ2luLWxlZnQ6IGF1dG87XG5cdFx0bWFyZ2luLXJpZ2h0OiBhdXRvO1xuXG5cdFx0aW1nIHtcblx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPHBpY3R1cmUgY2xhc3M9XCJuby1tYXJnaW4gbG9nb1wiIHN0eWxlPVwid2lkdGg6e3hfZGltfXB4OyBoZWlnaHQ6e3hfZGltfXB4O1wiIG9uOmNsaWNrPlxuXHQ8c291cmNlIHNyY3NldD1cIntzcl9kb3VibGV9XCIgbWVkaWE9XCIobWluLXJlc29sdXRpb246IDJkcHB4KVwiPlxuXHQ8aW1nIGFsdD17c19hbHR9IHNyYz1cIntzcl9kZWZhdWx0fVwiIC8+XG48L3BpY3R1cmU+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge3l3X2JsdXJ9IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCBTWF9JQ09OX0FERF9TTUFMTCBmcm9tICcjL2ljb24vYWRkLXNtYWxsLnN2Zz9yYXcnO1xuXHRcblx0ZXhwb3J0IGxldCB0aXRsZTogc3RyaW5nO1xuXHRleHBvcnQgbGV0IG9wZW4gPSB0cnVlO1xuXG5cdCQ6ICR5d19ibHVyID0gb3BlbjtcblxuXHRsZXQgYl9zaG93aW5nID0gZmFsc2U7XG5cdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdGJfc2hvd2luZyA9IHRydWU7XG5cdH0sIDEwKTtcblxuXHRmdW5jdGlvbiBwYXVzZShkbTogSFRNTEVsZW1lbnQsIGdjOiBhbnkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZHVyYXRpb246IDIwMCxcblx0XHR9O1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LmNhbmNlbCB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHR6LWluZGV4OiA1MDAwO1xuXG5cdFx0Ji5zaG93aW5nIHtcblx0XHRcdD4ub3ZlcmxheSB7XG5cdFx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0XHRcdC8vIGhlaWdodDogYXV0bztcblx0XHRcdFx0aGVpZ2h0OiAzMjBweDtcblxuXHRcdFx0XHRtYXgtaGVpZ2h0OiAzMjBweDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQub3ZlcmxheSB7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHR0b3A6IDRlbTtcblx0XHRcdHJpZ2h0OiAyMHB4O1xuXHRcdFx0ei1pbmRleDogMTAwMDtcblx0XHRcdHdpZHRoOiAzMDBweDtcblx0XHRcdHBhZGRpbmctbGVmdDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHRwYWRkaW5nLXJpZ2h0OiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdHBhZGRpbmctYm90dG9tOiB2YXIoLS11aS1wYWRkaW5nKTtcblxuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjk1KTtcblx0XHRcdGJvcmRlci1yYWRpdXM6IDhweDtcblx0XHRcdG1heC1oZWlnaHQ6IDMyMHB4O1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRvdmVyc2Nyb2xsLWJlaGF2aW9yOiBjb250YWluO1xuXHRcdFx0b3ZlcmZsb3c6IHNjcm9sbDtcblx0XHRcdC5oaWRlLXNjcm9sbGJhcigpO1xuXG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0b3BhY2l0eTogMC4yNTtcblx0XHRcdHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXMgbGluZWFyLCBoZWlnaHQgMjUwbXMgdmFyKC0tZWFzZS1vdXQtZXhwbyk7XG5cdFx0XHRoZWlnaHQ6IDA7XG5cblx0XHRcdD4udG9wIHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXG5cdFx0XHRcdD5oMyB7XG5cdFx0XHRcdFx0bWFyZ2luOiAxNnB4IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LmFkZC1uZXcge1xuXHRcdFx0XHRcdD4uaWNvbiB7XG5cdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDhweDtcblx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdD4ucm93cyB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdC0tcm93LXBhZGRpbmc6IDEycHg7XG5cblxuXHRcdFx0XHQub3ZlcmxheS1zZWxlY3QuaWNvbiB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDIwcHg7XG5cdFx0XHRcdFx0XHRhbGlnbi1zZWxmOiBjZW50ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5yb3cge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0cGFkZGluZy10b3A6IHZhcigtLXJvdy1wYWRkaW5nKSAhaW1wb3J0YW50O1xuXHRcdFx0XHRcdFx0cGFkZGluZy1sZWZ0OiAwICFpbXBvcnRhbnQ7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLXJpZ2h0OiB2YXIoLS1yb3ctcGFkZGluZykgIWltcG9ydGFudDtcblx0XHRcdFx0XHRcdHBhZGRpbmctYm90dG9tOiB2YXIoLS1yb3ctcGFkZGluZykgIWltcG9ydGFudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJjYW5jZWxcIlxuXHRjbGFzczpzaG93aW5nPXtiX3Nob3dpbmd9XG5cdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0Yl9zaG93aW5nID0gZmFsc2U7XG5cdFx0b3BlbiA9IGZhbHNlO1xuXHR9fVxuPlxuXHQ8ZGl2IGNsYXNzPVwib3ZlcmxheSBzZWxlY3RcIiBvdXQ6cGF1c2U+XG5cdFx0PGRpdiBjbGFzcz1cInRvcFwiPlxuXHRcdFx0PGgzPlxuXHRcdFx0XHR7dGl0bGV9XG5cdFx0XHQ8L2gzPlxuPCEtLSBcblx0XHRcdDxidXR0b24gY2xhc3M9XCJwaWxsIGFkZC1uZXdcIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fQUREX1NNQUxMfVxuXHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdFx0QWRkIE5ld1xuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L2J1dHRvbj4gLS0+XG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwicm93c1wiPlxuXHRcdFx0PHNsb3QgbmFtZT1cInJvd3NcIj48L3Nsb3Q+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC9kaXY+IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+XFxuXFx0XFx0LnMyci1hcnJvdy1sZWZ0LWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1hcnJvdy1sZWZ0LWZnXFxcIiBkPVxcXCJNMjAsMTFWMTNIOEwxMy41LDE4LjVMMTIuMDgsMTkuOTJMNC4xNiwxMkwxMi4wOCw0LjA4TDEzLjUsNS41TDgsMTFIMjBaXFxcIi8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLXNlYXJjaC1mZyB7XFxuXFx0XFx0XFx0ZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcblxcdFxcdH1cXG5cXHQ8L3N0eWxlPlxcblxcdDxwYXRoIGNsYXNzPVxcXCJzMnItc2VhcmNoLWZnXFxcIiBkPVxcXCJNMTUuNSAxNGgtLjc5bC0uMjgtLjI3QTYuNDcxIDYuNDcxIDAgMCAwIDE2IDkuNSA2LjUgNi41IDAgMSAwIDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6XFxcIi8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLWNoZWNrZWQtY2lyY2xlLWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdFxcdC5zMnItY2hlY2tlZC1jaXJjbGUtYmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1iZywgYmxhY2spO1xcblxcdFxcdH1cXG5cXHQ8L3N0eWxlPlxcblxcdDxjaXJjbGUgY2xhc3M9XFxcInMyci1jaGVja2VkLWNpcmNsZS1iZ1xcXCIgY3g9XFxcIjEwXFxcIiBjeT1cXFwiMTBcXFwiIHI9XFxcIjhcXFwiIC8+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1jaGVja2VkLWNpcmNsZS1mZ1xcXCIgZD1cXFwiTTEwLjAwMDMgMS42NjY1QzUuNDAwMzMgMS42NjY1IDEuNjY2OTkgNS4zOTk4NCAxLjY2Njk5IDkuOTk5ODRDMS42NjY5OSAxNC41OTk4IDUuNDAwMzMgMTguMzMzMiAxMC4wMDAzIDE4LjMzMzJDMTQuNjAwMyAxOC4zMzMyIDE4LjMzMzcgMTQuNTk5OCAxOC4zMzM3IDkuOTk5ODRDMTguMzMzNyA1LjM5OTg0IDE0LjYwMDMgMS42NjY1IDEwLjAwMDMgMS42NjY1Wk04LjMzMzY2IDE0LjE2NjVMNC4xNjY5OSA5Ljk5OTg0TDUuMzQxOTkgOC44MjQ4NEw4LjMzMzY2IDExLjgwODJMMTQuNjU4NyA1LjQ4MzE3TDE1LjgzMzcgNi42NjY1TDguMzMzNjYgMTQuMTY2NVpcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIsIGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCBTdGFyU2hlbGxMb2dvIGZyb20gJy4vU3RhclNoZWxsTG9nby5zdmVsdGUnO1xuXHRpbXBvcnQgT3ZlcmxheVNlbGVjdCBmcm9tICcuL092ZXJsYXlTZWxlY3Quc3ZlbHRlJztcblx0aW1wb3J0IFBmcERpc3BsYXkgZnJvbSAnLi9QZnBEaXNwbGF5LnN2ZWx0ZSc7XG5cdGltcG9ydCBDbG9zZSBmcm9tICcuL0Nsb3NlLnN2ZWx0ZSc7XG5cdGltcG9ydCBSb3cgZnJvbSAnLi9Sb3cuc3ZlbHRlJztcblxuXHRpbXBvcnQgU1hfSUNPTl9BUlJPV19MRUZUIGZyb20gJyMvaWNvbi9hcnJvdy1sZWZ0LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9TRUFSQ0ggZnJvbSAnIy9pY29uL3NlYXJjaC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0NIRUNLRUQgZnJvbSAnIy9pY29uL2NoZWNrZWQtY2lyY2xlLnN2Zz9yYXcnO1xuXHRcblx0aW1wb3J0IHtcblx0XHR5d19hY2NvdW50LFxuXHRcdHl3X2FjY291bnRfcmVmLFxuXHRcdHl3X2NhbmNlbF9zZWFyY2gsXG5cdFx0eXdfY2hhaW4sXG5cdFx0eXdfY2hhaW5fcmVmLFxuXHRcdHl3X21lbnVfdmVuZG9yLFxuXHRcdHl3X292ZXJsYXlfYWNjb3VudCxcblx0XHR5d19vdmVybGF5X25ldHdvcmssXG5cdFx0eXdfc2VhcmNoLFxuXHRcdHl3X3RocmVhZCxcblx0fSBmcm9tICcuLi9tZW0nO1xuXG5cdGltcG9ydCB0eXBlIHtcblx0XHRQYWdlLFxuXHR9IGZyb20gJyMjL3NjcmVlbi9fc2NyZWVucyc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgQWNjb3VudHMgfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHsgcXMgfSBmcm9tICcjL3V0aWwvZG9tJztcblx0XG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIGluY2x1ZGVzIGEgYmFjayBidXR0b24gdG8gcG9wIHRoaXMgcGFnZSBmcm9tIHRoZSBzdGFja1xuXHQgKi9cblx0ZXhwb3J0IGxldCBwb3BzID0gZmFsc2U7XG5cdGNvbnN0IGJfcG9wcyA9IHBvcHM7XG5cblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgaW5jbHVkZXMgYW4gZXhpdCBidXR0b24gdG8gcmVzZXQgdGhlIHN0YWNrXG5cdCAqL1xuXHRleHBvcnQgbGV0IGV4aXRzID0gZmFsc2U7XG5cdGNvbnN0IGJfZXhpdHMgPSBleGl0cztcblxuXHQvKipcblx0ICogSWYgYHRydWVgLCBkb2VzIG5vdCBkaXNwbGF5IHRoZSBsb2dvIGluIGNhc2VzIHdoZXJlIHRoZSBsb2dvIHdvdWxkIGRpc3BsYXlcblx0ICovXG5cdGV4cG9ydCBsZXQgcGxhaW4gPSBmYWxzZTtcblx0Y29uc3QgYl9wbGFpbiA9IHBsYWluO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIGFsbG93cyB0aGUgYWNjb3VudCB0byBiZSBzd2l0Y2hlZFxuXHQgKi9cblx0ZXhwb3J0IGxldCBhY2NvdW50ID0gZmFsc2U7XG5cdGNvbnN0IGJfYWNjb3VudCA9IGFjY291bnQ7XG5cblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgYWxsb3dzIHRoZSBuZXR3b3JrIHRvIGJlIHN3aXRjaGVkXG5cdCAqL1xuXHRleHBvcnQgbGV0IG5ldHdvcmsgPSBmYWxzZTtcblx0Y29uc3QgYl9uZXR3b3JrID0gbmV0d29yaztcblxuXHQvKipcblx0ICogSWYgYHRydWVgLCBpbmNsdWRlcyBhIHNlYXJjaCBpbnB1dCBib3hcblx0ICovXG5cdGV4cG9ydCBsZXQgc2VhcmNoID0gZmFsc2U7XG5cdGNvbnN0IGJfc2VhcmNoID0gc2VhcmNoO1xuXG5cdC8qKlxuXHQgKiBUaGUgcHJpbWFyeSB0aXRsZSB0byBkaXNwbGF5XG5cdCAqL1xuXHRleHBvcnQgbGV0IHRpdGxlID0gJyc7XG5cdGNvbnN0IHNfdGl0bGUgPSB0aXRsZTtcblxuXHQvKipcblx0ICogQSBzaG9ydCBzdHJpbmcgdG8gZGlzcGxheSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgdGhlIHRpdGxlXG5cdCAqL1xuXHRleHBvcnQgbGV0IHN5bWJvbCA9ICcnO1xuXHRjb25zdCBzX3N5bWJvbCA9IHN5bWJvbDtcblxuXHQvKipcblx0ICogVGhlIHN1YnN0aXRsZSB0byBkaXNwbGF5IHVuZGVyIHRoZSBwcmltYXJ5IHRpdGxlXG5cdCAqL1xuXHRleHBvcnQgbGV0IHN1YnRpdGxlID0gJyc7XG5cdGNvbnN0IHNfc3VidGl0bGUgPSBzdWJ0aXRsZTtcblxuXHQvLyBldmVudCBkaXNwYXRjaGVyIGZvciBwYXJlbnQgY29tcG9uZW50XG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XG5cblx0Ly8gZGltZW5zaW9uIG9mIHRoZSBhY2NvdW50IGFuZCBuZXR3b3JrIGljb25zXG5cdGNvbnN0IG92ZXJsYXlfcGZwX3Byb3BzID0gKGJfbWlycm9yPWZhbHNlKSA9PiAoe1xuXHRcdGRpbTogMjEsXG5cdFx0Ymc6ICdzYXRpbicsXG5cdFx0Z2VuU3R5bGU6ICdmb250LXNpemU6MjFweDsgb3V0bGluZTpub25lOycsXG5cdFx0cm9vdFN0eWxlOiBgXG5cdFx0XHRwYWRkaW5nOiA1cHggNnB4O1xuXHRcdFx0Ym9yZGVyOiAycHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdGJvcmRlci1yYWRpdXM6ICR7Yl9taXJyb3I/ICcwIDRweCA0cHggMCc6ICc0cHggMCAwIDRweCd9O1xuXHRcdGAucmVwbGFjZSgvXFxzKy9nLCAnICcpLFxuXHR9KSBhcyBjb25zdDtcblxuXHQvLyBnZXQgcGFnZSBmcm9tIGNvbnRleHRcblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8vICQ6IHBfYWNjb3VudF9pY29uID0gYl9hY2NvdW50PyAkeXdfYWNjb3VudD8uZGVmPy5pY29uUmVmOiBudWxsO1xuXG5cblx0bGV0IGRtX2hlYWRlcjogSFRNTEVsZW1lbnQ7XG5cblx0bGV0IGRtX3NlYXJjaDogSFRNTEVsZW1lbnQ7XG5cblx0Ly8gaW1wb3J0IFNYX1NFQVJDSCBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9maWxsZWQvc2VhcmNoLnN2Zz9yYXcnO1xuXG5cdC8vIGltcG9ydCBTWF9MT0dPIGZyb20gJyMvYXNzZXQvdmVuZG9yL2xvZ28uc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9EUk9QX0RPV04gZnJvbSAnIy9hc3NldC9uYXYvZHJvcC1kb3duLnN2Zz9yYXcnO1xuXG5cdC8vIGltcG9ydCBTWF9DSEVDS0VEIGZyb20gJyMvYXNzZXQvbmF2L2NoZWNrZWQtY2lyY2xlLnN2Zz9yYXcnO1xuXG5cdC8vIGltcG9ydCBQdXQgZnJvbSAnLi9QdXQuc3ZlbHRlJztcblx0Ly8gaW1wb3J0IHsgZm9ybWF0X2ZpYXQsIEhfQUNDT1VOVFMsIEhfQ0hBSU5TLCBIX0hPTERJTkdTLCBIX0lDT05TLCBIX1RPS0VOUywgSF9WRVJTVVNfVVNEIH0gZnJvbSAnIy9zaW0vZGF0YSc7XG5cdC8vIGltcG9ydCB7IG1pY3JvdGFzaywgb2RlLCB0aW1lb3V0IH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHQvLyBpbXBvcnQgeyBxcyB9IGZyb20gJyMvdXRpbC9kb20nO1xuXHQvLyBpbXBvcnQgQ2xvc2UgZnJvbSAnLi9DbG9zZS5zdmVsdGUnO1xuXHQvLyBpbXBvcnQgT3ZlcmxheVNlbGVjdCBmcm9tICcuL092ZXJsYXlTZWxlY3Quc3ZlbHRlJztcblx0Ly8gaW1wb3J0IFJvdyBmcm9tICcuL1Jvdy5zdmVsdGUnO1xuXG5cdC8vIGltcG9ydCB7XG5cdC8vIFx0QWNjb3VudCxcblx0Ly8gXHRJY29uLFxuXHQvLyBcdEhvbGRpbmcsXG5cdC8vIH0gZnJvbSAnIy9vYmplY3RzJztcblx0Ly8gaW1wb3J0IFBmcCBmcm9tICcuL1BmcC5zdmVsdGUnO1xuXG5cblxuXHRleHBvcnQgbGV0IGlzU2VhcmNoU2NyZWVuID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgc2VhcmNoX2lucHV0ID0gJyc7XG5cblx0bGV0IHNfc2VhcmNoID0gJHl3X3NlYXJjaDtcblxuXG5cdC8vIG9uTW91bnQoKCkgPT4ge1xuXHQvLyBcdGlmKCR5d19zZWFyY2gpIHtcblx0Ly8gXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHQvLyBcdFx0XHRjb25zb2xlLmxvZygnc3RlYWxpbmcgZm9jdXMgZm9yIGVudHJ5IHNlYXJjaCcpO1xuXHQvLyBcdFx0XHRkbV9zZWFyY2guZm9jdXMoKTtcblx0Ly8gXHRcdH0sIDApO1xuXHQvLyBcdH1cblx0Ly8gfSk7XG5cblx0eXdfc2VhcmNoLnN1YnNjcmliZSgoc192YWx1ZSkgPT4ge1xuXHRcdGlmKGlzU2VhcmNoU2NyZWVuICYmIHNfdmFsdWUpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdzZWFyY2ggc2NyZWVuIGFuZCBzZWFyY2ggdGV4dCcpO1xuXHRcdFx0c19zZWFyY2ggPSBzX3ZhbHVlO1xuXHRcdFx0aWYoZG1fc2VhcmNoKSB7XG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdGRtX3NlYXJjaC5mb2N1cygpO1xuXHRcdFx0XHR9LCAwKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZighc192YWx1ZSkge1xuXHRcdFx0c19zZWFyY2ggPSAnJztcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZV9zZWFyY2goZF9ldmVudDogRXZlbnQpIHtcblx0XHQvLyBjdXJyZW50bHkgaW4gc2VhcmNoIHRocmVhZFxuXHRcdGlmKGlzU2VhcmNoU2NyZWVuKSB7XG5cdFx0XHQvLyBzZWFyY2ggaXMgYmVpbmcgY2FuY2VsbGVkXG5cdFx0XHRpZighc19zZWFyY2gpIHtcblx0XHRcdFx0JHl3X3NlYXJjaCA9ICcnO1xuXHRcdFx0XHQkeXdfY2FuY2VsX3NlYXJjaCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGRpc3BhdGNoKCdzZWFyY2gnLCBzX3NlYXJjaCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIG5vdCBzZWFyY2ggc2NyZWVuLCBidXQgdXNlciB0eXBlZCBzb21ldGhpbmdcblx0XHRlbHNlIGlmKHNfc2VhcmNoKSB7XG5cdFx0XHRjb25zdCBzaV9jYWNoZSA9ICR5d190aHJlYWQuaWQ7XG5cblx0XHRcdGNvbnN0IGRtX2ZvY3VzID0gcXMoZG1faGVhZGVyLCAnOmZvY3VzJykgYXMgSFRNTEVsZW1lbnQ7XG5cdFx0XHRpZihkbV9mb2N1cykge1xuXHRcdFx0XHRkbV9mb2N1cy5ibHVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGRtX2hlYWRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cblx0XHRcdC8vIGNvbnN0IGRtX2Nsb25lID0gJHl3X3NjcmVlbl9kb20uY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50O1xuXHRcdFx0Ly8gJHl3X2V4aXR0aW5nX2RvbS5hcHBlbmQoZG1fY2xvbmUpXG5cblx0XHRcdC8vICR5d19oZWFkZXJfcHJvcHMgPSB7XG5cdFx0XHQvLyBcdHBvcHMsXG5cdFx0XHQvLyBcdGFjY291bnQsXG5cdFx0XHQvLyBcdG5ldHdvcmssXG5cdFx0XHQvLyBcdHNlYXJjaCxcblx0XHRcdC8vIFx0bmFtZSxcblx0XHRcdC8vIFx0c3ltYm9sLFxuXHRcdFx0Ly8gXHRzdWJuYW1lLFxuXHRcdFx0Ly8gXHRzZWFyY2hfaW5wdXQ6ICR5d19zZWFyY2gsXG5cdFx0XHQvLyB9O1xuXG5cdFx0XHQkeXdfY2FuY2VsX3NlYXJjaCA9ICgpID0+IHtcblx0XHRcdFx0Ly8gZG1faGVhZGVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG5cdFx0XHRcdC8vICR5d19zZWFyY2ggPSAnJztcblxuXHRcdFx0XHQvLyAkeXdfdGhyZWFkX2lkID0gc2lfY2FjaGU7XG5cblx0XHRcdFx0c19zZWFyY2ggPSAnJztcblxuXHRcdFx0XHRjb25zb2xlLmxvZygnc3RlYWxpbmcgZm9jdXMgZm9yIGNhbmNlbCBzZWFyY2gnKTtcblx0XHRcdFx0ZG1fc2VhcmNoLmZvY3VzKCk7XG5cdFx0XHR9O1xuXG5cblx0XHRcdC8vIHNhdmUgc2VhcmNoIHN0cmluZ1xuXHRcdFx0JHl3X3NlYXJjaCA9IHNfc2VhcmNoO1xuXG5cdFx0XHQvLyAvLyBzZXQgdGhyZWFkXG5cdFx0XHQvLyAkeXdfdGhyZWFkX2lkID0gVGhyZWFkSWQuU0VBUkNIO1xuXHRcdH1cblx0fVxuXG5cdC8vIGFzeW5jIGZ1bmN0aW9uIHNlYXJjaF9pbnB1dCgpIHtcblx0Ly8gXHRhd2FpdCB0aWNrKCk7XG5cdC8vIFx0ZGVidWdnZXI7XG5cdC8vIFx0aWYoc19zZWFyY2hfaW5wdXQpIHtcblx0Ly8gXHRcdGlmKFRocmVhZElkLlNFQVJDSCAhPT0gJHl3X3RocmVhZF9pZCkge1xuXHQvLyBcdFx0XHRkbV9oZWFkZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXHQvLyBcdFx0XHQvLyBjb25zdCBkbV9jbG9uZSA9IGRtX2hlYWRlci5jbG9uZU5vZGUodHJ1ZSk7XG5cdFx0XHRcdFxuXHQvLyBcdFx0XHQkeXdfdGhyZWFkX2lkID0gVGhyZWFkSWQuU0VBUkNIO1xuXHQvLyBcdFx0fVxuXHQvLyBcdH0gXG5cdC8vIH1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQuaGVhZGVyIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0Z2FwOiAxNnB4O1xuXG5cdFx0Ji5ibHVyIHtcblx0XHRcdD4qOm5vdCgudG9wKSB7XG5cdFx0XHRcdGZpbHRlcjogYmx1cigycHgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdD4qOm5vdCgudG9wKSB7XG5cdFx0XHR0cmFuc2l0aW9uOiBibHVyIDQwMG1zIHZhcigtLWVhc2Utb3V0LWN1YmljKTtcblx0XHR9XG5cdH1cblxuXHQudG9wIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXG5cdFx0Pi5iYWNrIHtcblx0XHRcdGZsZXg6IDE7XG5cdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0XHRtYXgtd2lkdGg6IDI0cHg7XG5cdFx0XHRtYXJnaW4tcmlnaHQ6IDIwcHg7XG5cdFx0fVxuXG5cdFx0Pi5sb2dvLmljb24ge1xuXHRcdFx0LS1pY29uLWRpYW1ldGVyOiAzMnB4O1xuXHRcdFx0dHJhbnNmb3JtOiBzY2FsZSgxLjQyNSk7XG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0fVxuXG5cdFx0Pi5tYWluIHtcblx0XHRcdGZsZXg6IDM7XG5cdFx0XHQvLyBtYXgtd2lkdGg6IGZpdC1jb250ZW50O1xuXHRcdFx0Y3Vyc29yOiBkZWZhdWx0O1xuXHRcdFx0bWFyZ2luLXJpZ2h0OiAxZW07XG5cdFx0XHRtaW4td2lkdGg6IDI1JTtcblxuXHRcdFx0Pi50aXRsZSB7XG5cdFx0XHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0XHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdFx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXG5cdFx0XHRcdD4ubmFtZSB7XG5cdFx0XHRcdFx0Zm9udC13ZWlnaHQ6IDUwMDtcblx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LnN5bWJvbCB7XG5cdFx0XHRcdFx0Zm9udC13ZWlnaHQ6IDQwMDtcblx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdD4uc3VidGl0bGUge1xuXHRcdFx0XHRmb250LXNpemU6IDEycHg7XG5cdFx0XHRcdGZvbnQtd2VpZ2h0OiA1MDA7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pi5yaWdodCB7XG5cdFx0XHRmbGV4OiA1O1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdG1heC13aWR0aDogbWF4LWNvbnRlbnQ7XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0Z2FwOiAxZW07XG5cblx0XHRcdC8vIC8vIGZvciBhYnNvbHV0ZS1wb3NpdGlvbmVkIG92ZXJsYXkgY2hpbGRcblx0XHRcdC8vIHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuXHRcdFx0Ji5oZWlnaHRsZXNzIHtcblx0XHRcdFx0aGVpZ2h0OiAwO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyA+Lm5ldHdvcmsge1xuXHRcdFx0Ly8gXHRmbGV4OiAzO1xuXHRcdFx0Ly8gXHRtYXgtd2lkdGg6IGZpdC1jb250ZW50O1xuXHRcdFx0Ly8gXHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0XHQvLyBcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0XHQvLyBcdG1hcmdpbi10b3A6IC0xN3B4O1xuXG5cdFx0XHQvLyBcdD4uaWNvbiB7XG5cdFx0XHQvLyBcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdC8vIFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHQvLyBcdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHRcdC8vIFx0XHRtYXJnaW4tbGVmdDogLTRweDtcblx0XHRcdC8vIFx0fVxuXHRcdFx0Ly8gfVxuXG5cdFx0XHQ+LmNsdXN0ZXIge1xuXHRcdFx0XHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0XHRcdFx0QHJhZGl1czogNXB4O1xuXG5cdFx0XHRcdD4qIHtcblx0XHRcdFx0XHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNvbGxhcHNlIGFkamFjZW50IGJvcmRlcnNcblx0XHRcdFx0PjpudGgtY2hpbGQobisxKSB7XG5cdFx0XHRcdFx0bWFyZ2luLWxlZnQ6IC0ycHg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyA+c3Bhbi5uZXR3b3JrIHtcblx0XHRcdFx0Ly8gXHQtLWljb24tZGlhbWV0ZXI6IDI2cHg7XG5cdFx0XHRcdC8vIFx0LS1idXR0b24tZGlhbWV0ZXI6IDMycHg7XG5cdFx0XHRcdC8vIFx0bWFyZ2luLWJvdHRvbTogLTFweDtcblx0XHRcdFx0Ly8gfVxuXG5cdFx0XHRcdC8vID4uYWNjb3VudCw+Lm5ldHdvcmsge1xuXHRcdFx0XHQvLyBcdC0taWNvbi1kaWFtZXRlcjogMzJweDtcblxuXHRcdFx0XHQvLyBcdGZsZXg6IDE7XG5cdFx0XHRcdC8vIFx0bWF4LXdpZHRoOiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdFx0Ly8gXHRtaW4td2lkdGg6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHQvLyBcdG1hcmdpbi1ib3R0b206IC01cHg7XG5cdFx0XHRcdC8vIFx0Y3Vyc29yOiBwb2ludGVyO1xuXG5cdFx0XHRcdC8vIFx0LmZhY2Uge1xuXHRcdFx0XHQvLyBcdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRcdFx0XHQvLyBcdFx0d2lkdGg6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHQvLyBcdFx0aGVpZ2h0OiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdFx0Ly8gXHRcdGJvcmRlci1yYWRpdXM6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHQvLyBcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdC8vIFx0fVxuXHRcdFx0XHQvLyB9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LnNlYXJjaCB7XG5cdFx0Zm9udC13ZWlnaHQ6IDQwMDtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0XHQ+LmFjdGlvbiB7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDIwcHg7XG5cdFx0XHR3aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRoZWlnaHQ6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0ZmlsbDogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHJpZ2h0OiAxMnB4O1xuXHRcdFx0dG9wOiBjYWxjKDUwJSAtICh2YXIoLS1pY29uLWRpYW1ldGVyKSAvIDIpKTtcblxuXHRcdFx0PnN2ZyB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0XHRcdGhlaWdodDogMTAwJTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImhlYWRlclwiIGJpbmQ6dGhpcz17ZG1faGVhZGVyfT4gIDwhLS0gY2xhc3M6Ymx1cj17JHl3X2JsdXJ9IC0tPlxuXHQ8IS0tIHRvcCByb3cgLS0+XG5cdDxkaXYgY2xhc3M9XCJ0b3BcIj5cblx0XHQ8IS0tIGxlZnRtb3N0IGFjdGlvbi9idXR0b24gLS0+XG5cdFx0eyNpZiBiX3BvcHN9XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImJhY2tcIiBvbjpjbGljaz17KCkgPT4ga19wYWdlLnBvcCgpfT5cblx0XHRcdFx0e0BodG1sIFNYX0lDT05fQVJST1dfTEVGVH1cblx0XHRcdFx0PCEtLSA8QXJyb3dCYWNrSWNvbiBzaXplPScyNHB4JyAvPiAtLT5cblx0XHRcdFx0PCEtLSA8aW1nIHNyYz1cIi9tZWRpYS9uYXYvYXJyb3ctbGVmdC5zdmdcIiBhbHQ9XCJDbGljayB0byBnbyBiYWNrXCIgLz4gLS0+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0ezplbHNlIGlmICFiX2V4aXRzICYmICFiX3BsYWlufVxuXHRcdFx0PFN0YXJTaGVsbExvZ28gZGltPXs0OH0gYWx0PVwiQ2xpY2sgdG8gdmlldyBnZW5lcmFsIHN0YXR1c1wiIG9uOmNsaWNrPXsoKSA9PiAkeXdfbWVudV92ZW5kb3IgPSB0cnVlfSAvPlxuXHRcdHsvaWZ9XG5cblx0XHQ8IS0tIG1haW4gdGl0bGUgc2VjdGlvbiBvbiB0aGUgbGVmdCAtLT5cblx0XHQ8c3BhbiBjbGFzcz1cIm1haW5cIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxuXHRcdFx0XHR7I2lmIHNfdGl0bGV9XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHR7c190aXRsZX1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0eyNpZiBzX3N5bWJvbH1cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwic3ltYm9sXCI+XG5cdFx0XHRcdFx0XHRcdC0ge3Nfc3ltYm9sfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0XHRcdHtzX3N1YnRpdGxlfVxuXHRcdFx0PC9kaXY+XG5cdFx0PC9zcGFuPlxuXG5cdFx0PCEtLSBhbGwgdG9wIGFjdGlvbnMgdGhhdCBhcHBlYXIgb24gdGhlIHJpZ2h0IHNpZGUgLS0+XG5cdFx0PHNwYW4gY2xhc3M9XCJyaWdodFwiIGNsYXNzOmhlaWdodGxlc3M9eyFiX25ldHdvcmsgJiYgYl9leGl0c30+XG5cdFx0XHQ8IS0tIGFjY291bnQvbmV0d29yayBzd2l0Y2ggY2x1c3RlciAtLT5cblx0XHRcdDxzcGFuIGNsYXNzPVwiY2x1c3RlclwiPlxuXHRcdFx0XHQ8IS0tIG5ldHdvcmsgc3dpdGNoZXIgLS0+XG5cdFx0XHRcdHsjaWYgYl9uZXR3b3JrfVxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibmV0d29ya1wiIG9uOmNsaWNrPXsoZF9ldmVudCkgPT4ge1xuXHRcdFx0XHRcdFx0ZF9ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdCR5d19vdmVybGF5X25ldHdvcmsgPSAhJHl3X292ZXJsYXlfbmV0d29yaztcblx0XHRcdFx0XHR9fT5cblx0XHRcdFx0XHRcdHsja2V5ICR5d19jaGFpbn1cblx0XHRcdFx0XHRcdFx0PFBmcERpc3BsYXlcblx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZT17JHl3X2NoYWlufVxuXHRcdFx0XHRcdFx0XHRcdHsuLi5vdmVybGF5X3BmcF9wcm9wcyhmYWxzZSl9XG5cdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHR7L2tleX1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHR7I2lmICR5d19vdmVybGF5X25ldHdvcmt9XG5cdFx0XHRcdFx0XHQ8T3ZlcmxheVNlbGVjdFxuXHRcdFx0XHRcdFx0XHR0aXRsZT0nU3dpdGNoIE5ldHdvcmsnXG5cdFx0XHRcdFx0XHRcdGJpbmQ6b3Blbj17JHl3X292ZXJsYXlfbmV0d29ya31cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicm93c1wiPlxuXHRcdFx0XHRcdFx0XHRcdHsjYXdhaXQgQ2hhaW5zLnJlYWQoKX1cblx0XHRcdFx0XHRcdFx0XHRcdC4uLlxuXHRcdFx0XHRcdFx0XHRcdHs6dGhlbiBrc19jaGFpbnN9IFxuXHRcdFx0XHRcdFx0XHRcdFx0eyNlYWNoIGtzX2NoYWlucy5lbnRyaWVzKCkgYXMgW3BfY2hhaW4sIGdfY2hhaW5dfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb3VyY2U9e2dfY2hhaW59XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGV0YWlsPSdEZWZhdWx0IFByb3ZpZGVyJ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfY2hhaW5fcmVmID0gcF9jaGFpbjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCR5d19vdmVybGF5X25ldHdvcmsgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicmlnaHRcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsjaWYgJHl3X2NoYWluX3JlZiA9PT0gcF9jaGFpbn1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJvdmVybGF5LXNlbGVjdCBpY29uXCIgc3R5bGU9XCItLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1wiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBTWF9DSEVDS0VEfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHRcdFx0XHR7L2F3YWl0fVxuXHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0XHRcdDwvT3ZlcmxheVNlbGVjdD5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHR7L2lmfVxuXG5cdFx0XHRcdDwhLS0gYWNjb3VudCBzd2l0Y2hlciAtLT5cblx0XHRcdFx0eyNpZiBiX2FjY291bnR9XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJhY2NvdW50XCIgb246Y2xpY2s9eyhkX2V2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRkX2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0JHl3X292ZXJsYXlfYWNjb3VudCA9ICEkeXdfb3ZlcmxheV9hY2NvdW50O1xuXHRcdFx0XHRcdH19PlxuXHRcdFx0XHRcdFx0eyNrZXkgJHl3X2FjY291bnR9XG5cdFx0XHRcdFx0XHRcdDxQZnBEaXNwbGF5XG5cdFx0XHRcdFx0XHRcdFx0cmVzb3VyY2U9eyR5d19hY2NvdW50fVxuXHRcdFx0XHRcdFx0XHRcdHsuLi5vdmVybGF5X3BmcF9wcm9wcyh0cnVlKX1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdHsva2V5fVxuXG5cdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0eyNpZiAkeXdfb3ZlcmxheV9hY2NvdW50fVxuXHRcdFx0XHRcdFx0PE92ZXJsYXlTZWxlY3Rcblx0XHRcdFx0XHRcdFx0dGl0bGU9J1N3aXRjaCBBY2NvdW50J1xuXHRcdFx0XHRcdFx0XHRiaW5kOm9wZW49eyR5d19vdmVybGF5X2FjY291bnR9XG5cdFx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInJvd3NcIj5cblx0XHRcdFx0XHRcdFx0XHR7I2F3YWl0IEFjY291bnRzLnJlYWQoKX1cblx0XHRcdFx0XHRcdFx0XHRcdC4uLlxuXHRcdFx0XHRcdFx0XHRcdHs6dGhlbiBrc19hY2NvdW50c31cblx0XHRcdFx0XHRcdFx0XHRcdDwhLS0geyNpZiBrc19hY2NvdW50cy5lbnRyaWVzKCkubGVuZ3RoID4gMn1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5hbWU9XCJBbGwgQWNjb3VudHNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRldGFpbD17Zm9ybWF0X2ZpYXQoT2JqZWN0LnZhbHVlcyhIX0FDQ09VTlRTKS5yZWR1Y2UoKGNfc3VtLCBrX2FjY291bnQpID0+IGNfc3VtICsgKGtfYWNjb3VudC5hZ2dyZWdhdG9yPyAwOiBIb2xkaW5nLnVzZFN1bShrX2FjY291bnQuaG9sZGluZ3MoSF9IT0xESU5HUywgJHl3X2NoYWluKSwgSF9UT0tFTlMsIEhfVkVSU1VTX1VTRCkpLCAwKSl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHBfYWNjb3VudF9hbGwgPSBBY2NvdW50LnJlZkZyb21JZCgnKicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHl3X2FjY291bnQgPSBIX0FDQ09VTlRTW3BfYWNjb3VudF9hbGxdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHl3X292ZXJsYXlfYWNjb3VudCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJyaWdodFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyNpZiAkeXdfYWNjb3VudC5kZWYuaXJpID09PSBBY2NvdW50LnJlZkZyb21JZCgnKicpfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm92ZXJsYXktc2VsZWN0IGljb25cIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgU1hfQ0hFQ0tFRH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cImljb25cIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwicGZwIHNxdWFyZSBpY29uIGFnZ3JlZ2F0b3JcIiBzdHlsZT1cImRpc3BsYXk6IGlubGluZS1ibG9jazsgZm9udC1zaXplOjMwcHg7IG1hcmdpbi1sZWZ0OmF1dG87IG1hcmdpbi1yaWdodDphdXRvO1wiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRBXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9Sb3c+XG5cdFx0XHRcdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdFx0XHRcdFx0LS0+XG5cblx0XHRcdFx0XHRcdFx0XHRcdDwhLS0geyNlYWNoIGtzX2FjY291bnRzLmVudHJpZXMoKS5maWx0ZXIoKFssa10pID0+ICFrLmFnZ3JlZ2F0b3IpIGFzIFtwX2FjY291bnQsIGtfYWNjb3VudF19IC0tPlxuXHRcdFx0XHRcdFx0XHRcdFx0eyNlYWNoIGtzX2FjY291bnRzLmVudHJpZXMoKSBhcyBbcF9hY2NvdW50LCBnX2FjY291bnRdfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb3VyY2U9e2dfYWNjb3VudH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg9e3BfYWNjb3VudH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXRhaWw9e2dfYWNjb3VudC5leHRyYT8udG90YWxfZmlhdF9jYWNoZSA/PyAnKD8pJ31cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHl3X2FjY291bnRfcmVmID0gcF9hY2NvdW50O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHl3X292ZXJsYXlfYWNjb3VudCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJyaWdodFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyNpZiAkeXdfYWNjb3VudF9yZWYgPT09IHBfYWNjb3VudH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJvdmVybGF5LXNlbGVjdCBpY29uXCIgc3R5bGU9XCItLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1wiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBTWF9DSEVDS0VEfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PFBmcERpc3BsYXkgZGltPXszMn0gcmVzb3VyY2U9e2dfYWNjb3VudH0gLz5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0PC9Sb3c+XG5cdFx0XHRcdFx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdFx0XHRcdFx0ey9hd2FpdH1cblx0XHRcdFx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHQ8L092ZXJsYXlTZWxlY3Q+XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0ey9pZn1cblx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0PCEtLSBleGl0IGJ1dHRvbiAtLT5cblx0XHRcdHsjaWYgYl9leGl0c31cblx0XHRcdFx0PENsb3NlIG9uOmNsaWNrPXsoKSA9PiBkaXNwYXRjaCgnY2xvc2UnKX0gLz5cblx0XHRcdHsvaWZ9XG5cdFx0PC9zcGFuPlxuXHQ8L2Rpdj5cblx0eyNpZiBiX3NlYXJjaH1cblx0XHQ8ZGl2IGNsYXNzPVwic2VhcmNoXCI+XG5cdFx0XHQ8aW5wdXQgdHlwZT1cInRleHRcIlxuXHRcdFx0XHRhdXRvZm9jdXM9e2lzU2VhcmNoU2NyZWVufVxuXHRcdFx0XHRwbGFjZWhvbGRlcj0nU2VhcmNoIGFueXRoaW5nOiB0b2tlbiwgYWNjb3VudCwgY29udGFjdCwgdHhuLi4uJ1xuXHRcdFx0XHRiaW5kOnZhbHVlPXtzX3NlYXJjaH1cblx0XHRcdFx0b246aW5wdXQ9e3VwZGF0ZV9zZWFyY2h9XG5cdFx0XHRcdGJpbmQ6dGhpcz17ZG1fc2VhcmNofVxuXHRcdFx0PlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJhY3Rpb25cIj5cblx0XHRcdFx0PCEtLSA8aW1nIHNyYz1cIi9hc3NldHMvbWVkaWEvbmF2L3NlYXJjaC5zdmdcIiBhbHQ9XCJcIiAvPiAtLT5cblx0XHRcdFx0e0BodG1sIFNYX0lDT05fU0VBUkNIfVxuXHRcdFx0PC9zcGFuPlxuXHRcdDwvZGl2PlxuXHR7L2lmfVxuPC9kaXY+XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIiBsYW5nPVwidHNcIj5cblx0ZXhwb3J0IG5hbWVzcGFjZSBMb2dJdGVtIHtcblx0XHRleHBvcnQgaW50ZXJmYWNlIFN0cmluZyB7XG5cdFx0XHR0eXBlOiAnc3RyaW5nJztcblx0XHRcdHZhbHVlOiBzdHJpbmc7XG5cdFx0fVxuXG5cdFx0ZXhwb3J0IGludGVyZmFjZSBFdmVudCB7XG5cdFx0XHR0eXBlOiAnZXZlbnQnO1xuXHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0bWVzc2FnZTogc3RyaW5nO1xuXHRcdFx0XHRvZmZzZXQ6IG51bWJlcjtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZXhwb3J0IHR5cGUgQW55ID0gU3RyaW5nIHwgRXZlbnQ7XG5cdH1cblxuXHRleHBvcnQgdHlwZSBMb2dJdGVtID0gTG9nSXRlbS5Bbnk7XG5cblx0ZXhwb3J0IGNsYXNzIExvZ2dlciB7XG5cdFx0Ly8gcHJpdmF0ZSBfYV9pdGVtczogTG9nSXRlbVtdID0gW107XG5cblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMuX2FfaXRlbXMgPSBbXTtcblx0XHR9XG5cblx0XHRnZXQgaXRlbXMoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYV9pdGVtcztcblx0XHR9XG5cblx0XHRzZXQgaXRlbXMoYV9pdGVtczogTG9nSXRlbVtdKSB7XG5cdFx0XHR0aGlzLl9hX2l0ZW1zID0gYV9pdGVtcztcblx0XHR9XG5cblx0XHRldmVudChzX21zZzogc3RyaW5nLCB4dF9vZmZzZXQ6IG51bWJlcik6IHRoaXMge1xuXHRcdFx0dGhpcy5fYV9pdGVtcy5wdXNoKHtcblx0XHRcdFx0dHlwZTogJ2V2ZW50Jyxcblx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRtZXNzYWdlOiBzX21zZyxcblx0XHRcdFx0XHRvZmZzZXQ6IHh0X29mZnNldCxcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXG5cdGV4cG9ydCBsZXQgaXRlbXM6IExvZ0l0ZW1bXTtcblxuXHRleHBvcnQgbGV0IGhpZGUgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBmb3JtYXRfbXMobl9tczogbnVtYmVyKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKG5fbXMgLyAxMDAwKS50b0ZpeGVkKDIpLnBhZFN0YXJ0KDUsICcwJyk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0LmxvZy1jb250YWluZXIge1xuXHRcdGZvbnQtZmFtaWx5OiAnUFQgTW9ubycsIG1vbm9zcGFjZTtcblxuXHRcdD5vbCB7XG5cdFx0XHQ+bGkge1xuXHRcdFx0XHQ+c3BhbiB7XG5cdFx0XHRcdFx0Ji5zdHJpbmcge1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ji5ldmVudCB7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwibG9nLWNvbnRhaW5lclwiIGNsYXNzOmRpc3BsYXlfbm9uZT17aGlkZX0+XG5cdDxvbD5cblx0XHR7I2VhY2ggaXRlbXMgYXMgZ19pdGVtfVxuXHRcdFx0PGxpPlxuXHRcdFx0XHR7I2lmICdzdHJpbmcnID09PSBnX2l0ZW0udHlwZX1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInN0cmluZ1wiPntnX2l0ZW0udmFsdWV9PC9zcGFuPlxuXHRcdFx0XHR7OmVsc2UgaWYgJ2V2ZW50JyA9PT0gZ19pdGVtLnR5cGV9XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJldmVudFwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJvZmZzZXRcIj4re2Zvcm1hdF9tcyhnX2l0ZW0udmFsdWUub2Zmc2V0KX1tczogPC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJtZXNzYWdlXCI+e2dfaXRlbS52YWx1ZS5tZXNzYWdlfTwvc3Bhbj5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHQ8L2xpPlxuXHRcdHsvZWFjaH1cblx0PC9vbD5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0Ly8gdGFyZ2V0IHdpZHRoXG5cdGV4cG9ydCBsZXQgd2lkdGggPSAxODA7XG5cdGNvbnN0IHhfd2lkdGggPSB3aWR0aDtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0LnRpdGxlIHtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRib3JkZXI6IDA7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cblx0XHRtYXJnaW4tbGVmdDogYXV0bztcblx0XHRtYXJnaW4tcmlnaHQ6IGF1dG87XG5cblx0XHRoZWlnaHQ6IGF1dG87XG5cblx0XHRpbWcge1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwibm8tbWFyZ2luIHRpdGxlXCIgc3R5bGU9XCJ3aWR0aDp7eF93aWR0aH1weDtcIj5cblx0PGltZyBhbHQ9XCJTdGFyU2hlbGwgdGl0bGVcIiBzcmM9XCIvbWVkaWEvdmVuZG9yL3RpdGxlLnN2Z1wiIC8+XG48L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7Z2V0Q29udGV4dH0gZnJvbSAnc3ZlbHRlJztcblxuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcblx0aW1wb3J0IHtTY3JlZW4sIHR5cGUgUGFnZX0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblxuXHRleHBvcnQgbGV0IGF0dGVtcHRfcmVnaXN0ZXI6IFZvaWRGdW5jdGlvbjtcblx0ZXhwb3J0IGxldCB3ZWFrbmVzczogbnVtYmVyO1xuXHRjb25zdCBpX3dlYWtuZXNzID0gd2Vha25lc3M7XG5cblx0Ly8gZ2V0IHBhZ2UgZnJvbSBjb250ZXh0XG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRmdW5jdGlvbiB1c2VfYW55d2F5KCkge1xuXHRcdGF0dGVtcHRfcmVnaXN0ZXIoKTtcblx0XHRrX3BhZ2UucG9wKCk7XG5cdH1cbjwvc2NyaXB0PlxuXG48U2NyZWVuPlxuXHQ8aDM+XG5cdFx0V2VhayBQYXNzd29yZCBXYXJuaW5nXG5cdDwvaDM+XG5cblx0PHA+XG5cdFx0VGhlIHBhc3N3b3JkIHlvdSBlbnRlcmVkIHdhcyBmb3VuZCBvbiBhIGxpc3Qgb2YgdGhlIHRvcCB0ZW4gdGhvdXNhbmQgbW9zdCBjb21tb25seSB1c2VkIHBhc3N3b3Jkcy5cblx0PC9wPlxuXG5cdDxwPlxuXHRcdEluIG9yZGVyIHRvIGhlbHAgcHJldmVudCB0aGUgbG9zcyBvZiBmdW5kcywgeW91IGFyZSBlbmNvdXJhZ2VkIHRvIGNyZWF0ZSBhIHN0cm9uZywgdW5pcXVlIHBhc3N3b3JkLlxuXHQ8L3A+XG5cblx0PHA+XG5cdFx0SG93IGRvIHlvdSB3YW50IHRvIHByb2NlZWQ/XG5cdDwvcD5cblxuXHQ8QWN0aW9uc0xpbmUgY2FuY2VsPSdwb3AnIGNvbmZpcm09e1snVXNlIGFueXdheScsIHVzZV9hbnl3YXldfSB3YWl0PXs1MDAwfSAvPlxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBQYWdlLCBTY3JlZW4gfSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRpbXBvcnQgRmllbGQgZnJvbSAnIy9hcHAvdWkvRmllbGQuc3ZlbHRlJztcblx0aW1wb3J0IExvZywgeyBMb2dnZXIgfSBmcm9tICcjL2FwcC91aS9Mb2cuc3ZlbHRlJztcblxuXHRpbXBvcnQgeyBWYXVsdCB9IGZyb20gJyMvY3J5cHRvL3ZhdWx0Jztcblx0aW1wb3J0IHtcblx0XHRBVFU4X0RVTU1ZX1BIUkFTRSxcblx0XHRBVFU4X0RVTU1ZX1ZFQ1RPUixcblx0XHRhY2NlcHRhYmxlLFxuXHRcdGxvZ2luLFxuXHRcdHJlZ2lzdGVyLFxuXHRcdEFscmVhZHlSZWdpc3RlcmVkRXJyb3IsXG5cdFx0SW52YWxpZFBhc3NwaHJhc2VFcnJvcixcblx0XHROTF9QQVNTUEhSQVNFX01JTklNVU0sXG5cdFx0TkxfUEFTU1BIUkFTRV9NQVhJTVVNLFxuXHR9IGZyb20gJyMvc2hhcmUvYXV0aCc7XG5cblx0aW1wb3J0IHR5cGUgeyBDb21wbGV0ZWQgfSBmcm9tICcjL2VudHJ5L2Zsb3cnO1xuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcblx0aW1wb3J0IHsgc2xpZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XG5cdGltcG9ydCBTdGFyU2hlbGxMb2dvIGZyb20gJy4uL3VpL1N0YXJTaGVsbExvZ28uc3ZlbHRlJztcblx0aW1wb3J0IFN0YXJTaGVsbFRpdGxlIGZyb20gJy4uL3VpL1N0YXJTaGVsbFRpdGxlLnN2ZWx0ZSc7XG5cdGltcG9ydCBSZWdpc3RlcldlYWtQYXNzd29yZFN2ZWx0ZSBmcm9tICcuL1JlZ2lzdGVyV2Vha1Bhc3N3b3JkLnN2ZWx0ZSc7XG5cblx0Ly8gZ2V0IHBhZ2UgZnJvbSBjb250ZXh0XG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHQvLyB3aWxsIGJlIHNldCBpZiB0aGlzIGlzIHBhcnQgb2YgYSBmbG93XG5cdGNvbnN0IGNvbXBsZXRlZCA9IGdldENvbnRleHQ8Q29tcGxldGVkIHwgdW5kZWZpbmVkPignY29tcGxldGVkJyk7XG5cblx0Ly8gYmluZGluZ3Ncblx0bGV0IHNoX3BocmFzZSA9ICcnO1xuXHRsZXQgc2hfdmVyaWZ5ID0gJyc7XG5cdGxldCBzX2Vycm9yID0gJyc7XG5cblx0bGV0IHNfZXJyX3Bhc3N3b3JkID0gJyc7XG5cdGxldCBzX2Vycl92ZXJpZnkgPSAnJztcblxuXHQvLyB0aW1lIHN0YXJ0ZWQgcmVnaXN0cmF0aW9uXG5cdGxldCB4dF9zdGFydCA9IDA7XG5cblx0Ly8gbG9nZ2VyIGluc3RhY2Vcblx0bGV0IGtfbG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG5cdC8vIGxvZyB0byBsb2dnZXJcblx0ZnVuY3Rpb24gbG9nKHNfbXNnOiBzdHJpbmcpIHtcblx0XHRrX2xvZ2dlciA9IGtfbG9nZ2VyLmV2ZW50KHNfbXNnLCBEYXRlLm5vdygpIC0geHRfc3RhcnQpO1xuXHR9XG5cblxuXHQvLyBjb250aW51b3VzbHkgY2hlY2sgdGhlIGFjY2VwdGFiaWxpdHkgb2YgdGhlIHBhc3N3b3JkXG5cdCQ6IGJfcGFzc3dvcmRfYWNjZXB0YWJsZSA9ICEhc2hfcGhyYXNlICYmIHNoX3BocmFzZSA9PT0gc2hfdmVyaWZ5ICYmIGFjY2VwdGFibGUoc2hfcGhyYXNlKTtcblxuXHQvLyB1cGRhdGUgdGhlIGNvbmZpcm0gYWN0aW9uXG5cdCQ6IGFfY29uZmlybV9hY3Rpb24gPSBbJ0NvbnRpbnVlJywgcHJlcGFyZV9yZWdpc3RlciwgIWJfcGFzc3dvcmRfYWNjZXB0YWJsZV0gYXMgY29uc3Q7XG5cblxuXHQvLyBsaXN0ZW4gZm9yIHBhZ2UgZXZlbnQgcmVzdG9yZVxuXHRrX3BhZ2Uub24oe1xuXHRcdHJlc3RvcmUoKSB7XG5cdFx0XHQvLyBjbGVhciBwYXNzd29yZHNcblx0XHRcdHNoX3BocmFzZSA9IHNoX3ZlcmlmeSA9ICcnO1xuXHRcdH0sXG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGNoZWNrX3Bhc3N3b3JkKCkge1xuXHRcdGlmKHNoX3BocmFzZSAmJiAhYWNjZXB0YWJsZShzaF9waHJhc2UpKSB7XG5cdFx0XHRpZihzaF9waHJhc2UubGVuZ3RoIDwgTkxfUEFTU1BIUkFTRV9NSU5JTVVNKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gJ1Bhc3N3b3JkIG11c3QgYmUgYXQgbGVhc3QgNSBjaGFyYWN0ZXJzJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoc2hfcGhyYXNlLmxlbmd0aCA+IE5MX1BBU1NQSFJBU0VfTUFYSU1VTSkge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9ICdQYXNzd29yZCBtdXN0IGJlIDEwMjQgY2hhcmFjdGVycyBvciBmZXdlcic7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSAnUGFzc3dvcmQgaXMgbm90IGFjY2VwdGFibGUnO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c19lcnJfcGFzc3dvcmQgPSAnJztcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrX3ZlcmlmeSgpIHtcblx0XHRpZihzaF9waHJhc2UgJiYgIXNfZXJyX3Bhc3N3b3JkICYmIHNoX3BocmFzZSAhPT0gc2hfdmVyaWZ5KSB7XG5cdFx0XHRzX2Vycl92ZXJpZnkgPSAnUGFzc3dvcmRzIGRvIG5vdCBtYXRjaCc7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c19lcnJfdmVyaWZ5ID0gJyc7XG5cdH1cblxuXHQvLyBkb3dubG9hZCB0b3AgMTBrIGxpc3QgYW5kIHBhcnNlIGl0XG5cdGNvbnN0IGRwX3Bhc3N3b3JkcyA9IChhc3luYygpID0+IHtcblx0XHRjb25zdCBkX3JlcyA9IGF3YWl0IGZldGNoKCcvZGF0YS9wYXNzd29yZHMtdG9wLTEway50eHQnKTtcblx0XHRjb25zdCBzX2xpc3QgPSBhd2FpdCBkX3Jlcy50ZXh0KCk7XG5cdFx0cmV0dXJuIHNfbGlzdC5zcGxpdCgnXFxuJyk7XG5cdH0pKCk7XG5cblx0Ly8gcHJlcGFyZSB0byByZWdpc3RlclxuXHRhc3luYyBmdW5jdGlvbiBwcmVwYXJlX3JlZ2lzdGVyKCkge1xuXHRcdC8vIGNoZWNrIGFnYWluc3QgdG9wIDEwayBsaXN0XG5cdFx0Y29uc3QgYV9wYXNzd29yZHMgPSBhd2FpdCBkcF9wYXNzd29yZHM7XG5cblx0XHQvLyBwYXNzd29yZCBmb3VuZCBpbiBsaXN0XG5cdFx0aWYoYV9wYXNzd29yZHMuaW5jbHVkZXMoc2hfcGhyYXNlKSkge1xuXHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRjcmVhdG9yOiBSZWdpc3RlcldlYWtQYXNzd29yZFN2ZWx0ZSxcblx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRhdHRlbXB0X3JlZ2lzdGVyLFxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8vIHBhc3N3b3JkIG5vdCBpbiBsaXN0XG5cdFx0ZWxzZSB7XG5cdFx0XHRhd2FpdCBhdHRlbXB0X3JlZ2lzdGVyKCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gcmVnaXN0cmF0aW9uIGlzIGJ1c3lcblx0bGV0IGJfYnVzeSA9IGZhbHNlO1xuXHRcblx0Ly8gYXR0ZW1wdCB0byByZWdpc3RlclxuXHRhc3luYyBmdW5jdGlvbiBhdHRlbXB0X3JlZ2lzdGVyKCk6IFByb21pc2U8MT4ge1xuXHRcdC8vIGludmFsaWQgc3RhdGVcblx0XHRpZighYl9wYXNzd29yZF9hY2NlcHRhYmxlKSByZXR1cm4gMTtcblxuXHRcdC8vIGRvIG5vdCBpbnRlcnVwdDsgbG9ja1xuXHRcdGlmKGJfYnVzeSkgcmV0dXJuIDE7IGJfYnVzeSA9IHRydWU7XG5cblx0XHQvLyBwcmVwIGdyYWNlZnVsIGV4aXRcblx0XHRjb25zdCBleGl0ID0gKCk6IDEgPT4gKGJfYnVzeSA9IGZhbHNlLCAxKTtcblxuXHRcdC8vIHJlc2V0IGVycm9yXG5cdFx0c19lcnJvciA9ICcnO1xuXG5cdFx0Ly8gc3RhcnQgdGltZXJcblx0XHR4dF9zdGFydCA9IERhdGUubm93KCk7XG5cblx0XHRsb2coJ0VzdGltYXRpbmcgdGltZSB0byBjb21wbGV0ZScpO1xuXG5cdFx0Ly8gZXN0aW1hdGUgdGltZSB0byBjb21wbGV0ZVxuXHRcdHtcblx0XHRcdGNvbnN0IHh0X3N0YXJ0X2VzdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdGF3YWl0IFZhdWx0LmRlcml2ZVJvb3RCaXRzKEFUVThfRFVNTVlfUEhSQVNFLCBBVFU4X0RVTU1ZX1ZFQ1RPUiwgMSAvIDUwKTtcblx0XHRcdGNvbnN0IHh0X2ZpbmlzaF9lc3QgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHRcdGNvbnN0IHh0X2VsYXBzZWRfZXN0ID0geHRfZmluaXNoX2VzdCAtIHh0X3N0YXJ0X2VzdDtcblx0XHRcdGNvbnN0IHh0X2VzdGltYXRlID0gMiAqICgyICogKHh0X2VsYXBzZWRfZXN0ICogNTApKTtcblx0XHRcdGxvZyhgQWJvdXQgJHsoeHRfZXN0aW1hdGUgLyAxMDAwKS50b0ZpeGVkKDEpfSBzZWNvbmRzYCk7XG5cdFx0fVxuXG5cdFx0Ly8gYXR0ZW1wdCB0byByZWdpc3RlclxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCByZWdpc3RlcihzaF9waHJhc2UsIGxvZyk7XG5cdFx0fVxuXHRcdC8vIGhhbmRsZSBlcnJvclxuXHRcdGNhdGNoKGVfcmVnaXN0ZXIpIHtcblx0XHRcdGlmKGVfcmVnaXN0ZXIgaW5zdGFuY2VvZiBBbHJlYWR5UmVnaXN0ZXJlZEVycm9yKSB7XG5cdFx0XHRcdHNfZXJyb3IgPSAnQSBwYXNzcGhyYXNlIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCc7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGVfcmVnaXN0ZXIgaW5zdGFuY2VvZiBJbnZhbGlkUGFzc3BocmFzZUVycm9yKSB7XG5cdFx0XHRcdHNfZXJyb3IgPSAnSW52YWxpZCBwYXNzcGhyYXNlJztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzX2Vycm9yID0gYFVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgYXR0ZW1wdGluZyB0byByZWdpc3RlcjpcXG4ke2VfcmVnaXN0ZXIuc3RhY2sgfHwgZV9yZWdpc3Rlci5tZXNzYWdlfWA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGV4aXRcblx0XHRcdHJldHVybiBleGl0KCk7XG5cdFx0fVxuXG5cdFx0bG9nKCdWZXJpZnlpbmcgcGFzc3BocmFzZScpO1xuXG5cdFx0Ly8gYXR0ZW1wdCBsb2dpblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBsb2dpbihzaF9waHJhc2UsIGZhbHNlLCBsb2cpO1xuXHRcdH1cblx0XHQvLyBmYWlsZWQgdG8gdmVyaWZ5XG5cdFx0Y2F0Y2goZV9sb2dpbikge1xuXHRcdFx0c19lcnJvciA9ICdGYWlsZWQgdG8gdmVyaWZ5IHBhc3NwaHJhc2UgaW1tZWRpYXRlbHkgYWZ0ZXIgcmVnaXN0cmF0aW9uJztcblxuXHRcdFx0Ly8gcmVzZXQgdmF1bHRcblx0XHRcdGF3YWl0IFZhdWx0LmVyYXNlQmFzZSgpO1xuXG5cdFx0XHQvLyBleGl0XG5cdFx0XHRyZXR1cm4gZXhpdCgpO1xuXHRcdH1cblxuXHRcdGxvZygnRG9uZScpO1xuXG5cdFx0Ly8gcHJvY2VlZFxuXHRcdHNfZXJyb3IgPSAnU3VjY2Vzcyc7XG5cblx0XHQvLyBjb21wbGV0ZVxuXHRcdGlmKGNvbXBsZXRlZCkgY29tcGxldGVkKHRydWUpO1xuXG5cdFx0Ly8gZG9uZVxuXHRcdHJldHVybiBleGl0KCk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHQuaW50cm8ge1xuXHRcdG1hcmdpbi10b3A6IDFlbTtcblx0XHQvLyBtYXJnaW4tYm90dG9tOiA0ZW07XG5cdFx0bWFyZ2luLWJvdHRvbTogMDtcblxuXHRcdC5sZWFkIHtcblx0XHRcdG1hcmdpbi10b3A6IDFlbTtcblx0XHRcdG1hcmdpbi1ib3R0b206IDA7XG5cdFx0fVxuXG5cdFx0LnRpdGxlIHtcblx0XHRcdGxldHRlci1zcGFjaW5nOiAxcHg7XG5cdFx0XHRmb250LXdlaWdodDogMTAwO1xuXHRcdFx0Zm9udC1zaXplOiAyN3B4O1xuXHRcdFx0Y29sb3I6ICNkMGQwZDA7XG5cdFx0XHRtYXJnaW46IDA7XG5cblx0XHRcdGVtIHtcblx0XHRcdFx0Zm9udC1zaXplOiAzMnB4O1xuXHRcdFx0XHRmb250LXN0eWxlOiBub3JtYWw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmxvZ28ge1xuXHRcdFx0aGVpZ2h0OiAzNHZoO1xuXHRcdFx0d2lkdGg6IGF1dG87XG5cdFx0fVxuXG5cdFx0Lmljb24ge1xuXHRcdFx0LS1zdmctY29sb3ItZmc6IHNpbHZlcjtcblx0XHRcdC8vIC0tc3ZnLWNvbG9yLWJnOiAjZjUyNTI1O1xuXHRcdFx0d2lkdGg6IGNhbGMoMTAwJSAtIDYwcHgpO1xuXHRcdFx0aGVpZ2h0OiBhdXRvO1xuXG5cdFx0XHQuZ3JhcGhpYyh7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdHdpZHRoOiAxNzJweDtcblx0XHRcdFx0XHRoZWlnaHQ6IDEzN3B4O1xuXHRcdFx0XHRcdG1hcmdpbjogMTBweCAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0PnN2ZyB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1hcmdpbjogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0fVxuXG5cdC5uYXJyb3cge1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0Zm9udC13ZWlnaHQ6IDMwMDtcblx0XHRtYXgtd2lkdGg6IDE4ZW07XG5cdH1cbjwvc3R5bGU+XG5cbjxTY3JlZW4+XG5cdDxjZW50ZXI+XG5cdFx0PGRpdiBjbGFzcz1cImludHJvXCI+XG5cdFx0XHQ8U3RhclNoZWxsTG9nbyBkaW09ezk2fSAvPlxuXG5cdFx0XHQ8U3RhclNoZWxsVGl0bGUgd2lkdGg9ezE1MH0gLz5cblx0XHQ8L2Rpdj5cblxuXHRcdDxwIGNsYXNzPVwibmFycm93XCI+XG5cdFx0XHRDcmVhdGUgYSBuZXcgcGFzc3dvcmQgdG8gcHJvdGVjdCB5b3VyIHdhbGxldCdzIGRhdGEuXG5cdFx0PC9wPlxuXHQ8L2NlbnRlcj5cblxuXHQ8ZGl2IGNsYXNzPVwiZm9ybSBmbGV4LXJvd3NcIj5cblx0XHQ8aW5wdXQgaGlkZGVuXG5cdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRuYW1lPVwidXNlcm5hbWVcIlxuXHRcdFx0YXV0b2NvbXBsZXRlPVwidXNlcm5hbWVcIlxuXHRcdFx0dmFsdWU9XCJTdGFyU2hlbGwgV2FsbGV0IFVzZXJcIj5cblxuXHRcdDxGaWVsZCBrZXk9XCJwYXNzd29yZFwiIG5hbWU9XCJOZXcgcGFzc3dvcmRcIj5cblx0XHRcdDxpbnB1dFxuXHRcdFx0XHR0eXBlPVwicGFzc3dvcmRcIlxuXHRcdFx0XHRhdXRvY29tcGxldGU9XCJuZXctcGFzc3dvcmRcIlxuXHRcdFx0XHRuYW1lPVwicGFzc3dvcmRcIlxuXHRcdFx0XHRwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCJcblx0XHRcdFx0b246Ymx1cj17KCkgPT4gY2hlY2tfcGFzc3dvcmQoKX1cblx0XHRcdFx0YmluZDp2YWx1ZT17c2hfcGhyYXNlfT5cblxuXHRcdFx0eyNpZiAhYl9wYXNzd29yZF9hY2NlcHRhYmxlICYmIHNfZXJyX3Bhc3N3b3JkfVxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsaWRhdGlvbi1tZXNzYWdlXCIgdHJhbnNpdGlvbjpzbGlkZT17e2R1cmF0aW9uOjMwMH19PlxuXHRcdFx0XHRcdHtzX2Vycl9wYXNzd29yZH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXHRcdDwvRmllbGQ+XG5cblx0XHQ8RmllbGQga2V5PVwidmVyaWZ5LXBhc3N3b3JkXCIgbmFtZT1cIlZlcmlmeSBwYXNzd29yZFwiPlxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdHR5cGU9XCJwYXNzd29yZFwiXG5cdFx0XHRcdGF1dG9jb21wbGV0ZT1cIm5ldy1wYXNzd29yZFwiXG5cdFx0XHRcdG5hbWU9XCJ2ZXJpZnlcIlxuXHRcdFx0XHRwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCJcblx0XHRcdFx0b246Ymx1cj17KCkgPT4gY2hlY2tfdmVyaWZ5KCl9XG5cdFx0XHRcdGJpbmQ6dmFsdWU9e3NoX3ZlcmlmeX0+XG5cblx0XHRcdHsjaWYgIWJfcGFzc3dvcmRfYWNjZXB0YWJsZSAmJiBzX2Vycl92ZXJpZnl9XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzAwfX0+XG5cdFx0XHRcdFx0e3NfZXJyX3ZlcmlmeX1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXHRcdDwvRmllbGQ+XG5cblx0PC9kaXY+XG5cblx0PExvZyBiaW5kOml0ZW1zPXtrX2xvZ2dlci5pdGVtc30gLz5cblxuXHR7I2lmIHNfZXJyb3J9XG5cdFx0PHByZT57c19lcnJvcn08L3ByZT5cblx0ey9pZn1cblxuXG5cdDxBY3Rpb25zTGluZSBjb25maXJtPXthX2NvbmZpcm1fYWN0aW9ufSAvPlxuPC9TY3JlZW4+XG4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTE5IDV2MTRINVY1aDE0bTAtMkg1YTIgMiAwIDAgMC0yIDJ2MTRhMiAyIDAgMCAwIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0tNyA5Yy0xLjY1IDAtMy0xLjM1LTMtM3MxLjM1LTMgMy0zIDMgMS4zNSAzIDMtMS4zNSAzLTMgM3ptMC00Yy0uNTUgMC0xIC40NS0xIDFzLjQ1IDEgMSAxIDEtLjQ1IDEtMS0uNDUtMS0xLTF6bTYgMTBINnYtMS41M2MwLTIuNSAzLjk3LTMuNTggNi0zLjU4czYgMS4wOCA2IDMuNThWMTh6bS05LjY5LTJoNy4zOGMtLjY5LS41Ni0yLjM4LTEuMTItMy42OS0xLjEycy0zLjAxLjU2LTMuNjkgMS4xMnpcXFwiLz5cXG48L3N2Zz5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItYW5hbHl0aWNzLWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1hbmFseXRpY3MtZmdcXFwiIGQ9XFxcIk0xOSAzSDVjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptMCAxNkg1VjVoMTR2MTR6XFxcIi8+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1hbmFseXRpY3MtZmdcXFwiIGQ9XFxcIk03IDEyaDJ2NUg3em04LTVoMnYxMGgtMnptLTQgN2gydjNoLTJ6bTAtNGgydjJoLTJ6XFxcIi8+XFxuPC9zdmc+XCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTEzIDUuMDhBNyA3IDAgMCAxIDE4LjkyIDExaDMuMDNjLS40Ny00LjcyLTQuMjMtOC40OC04Ljk1LTguOTV2My4wM3pNMTguOTIgMTNBNyA3IDAgMCAxIDEzIDE4LjkydjMuMDNjNC43Mi0uNDcgOC40OC00LjIzIDguOTUtOC45NWgtMy4wM3pNMTEgMTguOTJjLTMuMzktLjQ5LTYtMy40LTYtNi45MnMyLjYxLTYuNDMgNi02LjkyVjIuMDVjLTUuMDUuNS05IDQuNzYtOSA5Ljk1IDAgNS4xOSAzLjk1IDkuNDUgOSA5Ljk1di0zLjAzelxcXCIvPlxcbjwvc3ZnPlwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IFN0YXJTZWxlY3QsIHsgU2VsZWN0T3B0aW9uIH0gZnJvbSAnLi9TdGFyU2VsZWN0LnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHtvZGUsIG9kZXJhZn0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCB7eXdfYWNjb3VudCwgeXdfY2hhaW4sIHl3X293bmVyfSBmcm9tICcjIy9tZW0nO1xuXHRpbXBvcnQgdHlwZSB7IFJlc291cmNlIH0gZnJvbSAnIy9tZXRhL3Jlc291cmNlJztcblx0aW1wb3J0IHR5cGUgeyBUb2tlbiwgVG9rZW5QYXRoLCBUb2tlblNwZWNLZXkgfSBmcm9tICcjL21ldGEvdG9rZW4nO1xuXHRpbXBvcnQgeyBFbnRpdGllcyB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgdHlwZSB7IEVudGl0eVBhdGggfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB0eXBlIHsgUGZwUGF0aCB9IGZyb20gJyMvbWV0YS9wZnAnO1xuXHRpbXBvcnQgeyBsb2FkX3BmcHMgfSBmcm9tICcuLi9zdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgYXNzZXRSZWY6IEVudGl0eVBhdGggfCAnJyA9ICcnO1xuXG5cdGNvbnN0IHNpX2NoYWluID0gJHl3X2NoYWluPy5pZCB8fCAnKic7XG5cblx0bGV0IGhfYXNzZXRfcGZwczogUmVjb3JkPFBmcFBhdGgsIEhUTUxFbGVtZW50PiA9IHt9O1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYXNzZXRzKCkge1xuXHRcdGNvbnN0IGFfaXRlbXM6IFNlbGVjdE9wdGlvbltdID0gW107XG5cblx0XHRoX2Fzc2V0X3BmcHMgPSBhd2FpdCBsb2FkX3BmcHMoJHl3X2NoYWluLmNvaW5zLCB7XG5cdFx0XHRkaW06IDE5LFxuXHRcdH0pO1xuXG5cdFx0Zm9yKGNvbnN0IFtzaV9jb2luLCBnX2NvaW5dIG9mIG9kZSgkeXdfY2hhaW4uY29pbnMpKSB7XG5cdFx0XHRhX2l0ZW1zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogRW50aXRpZXMuaG9sZGluZ1BhdGhGb3IoJHl3X293bmVyLCBzaV9jb2luKSxcblx0XHRcdFx0b2JqZWN0OiBnX2NvaW4sXG5cdFx0XHRcdHByaW1hcnk6IHNpX2NvaW4sXG5cdFx0XHRcdHNlY29uZGFyeTogZ19jb2luLm5hbWUsXG5cdFx0XHRcdHBmcDogZ19jb2luLnBmcCxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhX2l0ZW1zO1xuXHR9XG5cblx0Ly8gdGhlIGN1cnJlbnQgaXRlbSBzZWxlY3RlZCBieSB1c2VyXG5cdGxldCBnX2l0ZW06IFNlbGVjdE9wdGlvbjxFbnRpdHlQYXRoPiA9IHtcblx0XHR2YWx1ZTogYXNzZXRSZWYgYXMgRW50aXR5UGF0aCxcblx0XHRvYmplY3Q6IG51bGwhLFxuXHRcdHByaW1hcnk6ICcnLFxuXHRcdHNlY29uZGFyeTogJycsXG5cdFx0cGZwOiAnJyBhcyBQZnBQYXRoLFxuXHR9O1xuXHQkOiB7XG5cdFx0Ly8gcHJvcGFnYXRlIGNoYW5nZSBiYWNrIHRvIGV4cG9ydGVkIGJpbmRpbmdcblx0XHRhc3NldFJlZiA9IGdfaXRlbT8udmFsdWUgfHwgJyc7XG5cdH1cblxuXHQvLyBhc3luYyBmdW5jdGlvbiBsb2FkX3Rva2VucygpIHtcblx0Ly8gXHQvLyBwcmVwIGFuIG91dHB1dCBsaXN0IG9mIHNlbGVjdCBpdGVtc1xuXHQvLyBcdGNvbnN0IGFfaXRlbXMgPSBbXTtcblxuXHQvLyBcdC8vIHJlYWQgYWxsIGZ1bmdpYmxlIHRva2VucyBmb3IgdGhpcyBjaGFpblxuXHQvLyBcdGNvbnN0IGhfaW50ZXJmYWNlcyA9IGF3YWl0IEVudGl0aWVzLnJlYWRGdW5naWJsZVRva2VucygkeXdfY2hhaW4pO1xuXG5cdC8vIFx0Ly8gZWFjaCBpbnRlcmZhY2Vcblx0Ly8gXHRmb3IoY29uc3Qgc2lfaW50ZXJmYWNlIGluIGhfaW50ZXJmYWNlcykge1xuXHQvLyBcdFx0Ly8gcmVmIHRva2VuIGRpY3Rcblx0Ly8gXHRcdGNvbnN0IGhfdG9rZW5zID0gaF9pbnRlcmZhY2VzW3NpX2ludGVyZmFjZSBhcyBUb2tlblNwZWNLZXldO1xuXG5cdC8vIFx0XHQvLyBlYWNoIHRva2VuXG5cdC8vIFx0XHRmb3IoY29uc3QgcF90b2tlbiBpbiBoX3Rva2Vucykge1xuXHQvLyBcdFx0XHQvLyByZWYgdG9rZW5cblx0Ly8gXHRcdFx0Y29uc3QgZ190b2tlbiA9IGhfdG9rZW5zW3BfdG9rZW4gYXMgVG9rZW5QYXRoXTtcblxuXHQvLyBcdFx0XHQvLyBhZGQgdG8gc2VsZWN0IGl0ZW1zIGxpc3Rcblx0Ly8gXHRcdFx0YV9pdGVtcy5wdXNoKHtcblx0Ly8gXHRcdFx0XHR2YWx1ZTogcF90b2tlbixcblx0Ly8gXHRcdFx0XHRsYWJlbDogYCR7Z190b2tlbi5iZWNoMzJ9ICR7Z190b2tlbi5zeW1ib2x9ICR7Z190b2tlbi5uYW1lfWAsXG5cdC8vIFx0XHRcdH0pO1xuXHQvLyBcdFx0fVxuXHQvLyBcdH1cblx0Ly8gfVxuXG5cdC8vIGNvbnN0IGFfdG9rZW5zID0gb2RlcmFmKEhfVE9LRU5TLCAoXywga190b2tlbikgPT4ge1xuXHQvLyBcdGNvbnN0IGtfY2hhaW4gPSBIX0NIQUlOU1trX3Rva2VuLmRlZi5jaGFpblJlZl07XG5cblx0Ly8gXHRpZihzaV9jaGFpbiA9PT0ga19jaGFpbi5kZWYuaWQpIHtcblx0Ly8gXHRcdHJldHVybiBbe1xuXHQvLyBcdFx0XHR2YWx1ZToga190b2tlbi5kZWYuaXJpLFxuXHQvLyBcdFx0XHRsYWJlbDogYCR7a190b2tlbi5kZWYuYWRkcmVzc30gJHtrX3Rva2VuLmRlZi5zeW1ib2x9ICR7a190b2tlbi5kZWYubGFiZWx9YCxcblx0Ly8gXHRcdFx0cHJpbWFyeToga190b2tlbi5kZWYuc3ltYm9sLFxuXHQvLyBcdFx0XHRzZWNvbmRhcnk6IGtfdG9rZW4uZGVmLmxhYmVsLFxuXHQvLyBcdFx0XHR0b2tlbjoga190b2tlbixcblx0Ly8gXHRcdH1dO1xuXHQvLyBcdH1cblxuXHQvLyBcdHJldHVybiBbXTtcblx0Ly8gfSk7XG5cblx0Ly8gbGV0IGdfdG9rZW5fc2VsZWN0ID0ga190b2tlbj8gYV90b2tlbnMuZmluZChnID0+IGcudmFsdWUgPT09IGtfdG9rZW4uZGVmLmlyaSk6IHZvaWQgMDtcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImFzc2V0XCI+XG5cdHsjYXdhaXQgbG9hZF9hc3NldHMoKX1cblx0XHRMb2FkaW5nIGFzc2V0cy4uLlxuXHR7OnRoZW4gYV9hc3NldHN9XG5cdFx0PFN0YXJTZWxlY3QgaWQ9XCJhc3NldC1zZWxlY3RcIlxuXHRcdFx0cGZwTWFwPXtoX2Fzc2V0X3BmcHN9XG5cdFx0XHRwbGFjZWhvbGRlcj1cIlNlbGVjdCBhc3NldFwiXG5cdFx0XHRpdGVtcz17YV9hc3NldHN9XG5cdFx0XHRiaW5kOnZhbHVlPXtnX2l0ZW19XG5cdFx0Lz5cblx0ey9hd2FpdH1cbjwvZGl2PiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJtMTIgOC02IDYgMS40MSAxLjQxTDEyIDEwLjgzbDQuNTkgNC41OEwxOCAxNGwtNi02elxcXCIvPlxcbjwvc3ZnPlwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIk0xNi41OSA4LjU5IDEyIDEzLjE3IDcuNDEgOC41OSA2IDEwbDYgNiA2LTYtMS40MS0xLjQxelxcXCIvPlxcbjwvc3ZnPlwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5cdC8vIGltcG9ydCB7IHl3X2Fzc2V0X3NlbmQsIHl3X2hvbGRpbmdfc2VuZCB9IGZyb20gJyMjL21lbSc7XG5cblx0aW1wb3J0IFNYX0lDT05fSU5DUkVNRU5UIGZyb20gJyMvaWNvbi9leHBhbmRfbGVzcy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fREVDUkVNRU5UIGZyb20gJyMvaWNvbi9leHBhbmRfbW9yZS5zdmc/cmF3Jztcblx0aW1wb3J0IHR5cGUgeyBFbnRpdHksIEVudGl0eVBhdGgsIE5hdGl2ZUNvaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgeyBFbnRpdGllcyB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgeyB5d19hY2NvdW50LCB5d19jaGFpbiwgeXdfbmV0d29ya19hY3RpdmUsIHl3X293bmVyIH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IHsgWFRfTUlOVVRFUyB9IGZyb20gJyMvc2hhcmUvY29uc3RhbnRzJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBmb3JtYXRfYW1vdW50IH0gZnJvbSAnIy91dGlsL2Zvcm1hdCc7XG5cdGltcG9ydCB7IENvaW5HZWNrbyB9IGZyb20gJyMvc3RvcmUvd2ViLWFwaXMnO1xuXG5cdGV4cG9ydCBsZXQgdmFsdWUgPSAnJztcblxuXHRjb25zdCBZR19aRVJPID0gbmV3IEJpZ051bWJlcigwKTtcblx0Y29uc3QgWUdfT05FID0gbmV3IEJpZ051bWJlcigxKTtcblxuXHRleHBvcnQgbGV0IGFzc2V0UmVmOiBFbnRpdHlQYXRoIHwgJycgPSAnJztcblxuXHQvKipcblx0ICogTGVhdmUgYSBidWZmZXIgZm9yIHRoZSBtYXhpbXVtIGFtb3VudCB0aGF0IGNhbiBiZSB1c2VkXG5cdCAqL1xuXHRleHBvcnQgbGV0IGJ1ZmZlck1heDogQmlnTnVtYmVyIHwgbnVtYmVyID0gMDtcblxuXHRsZXQgZ19hc3NldDogTmF0aXZlQ29pbiB8IG51bGw7XG5cblx0bGV0IHlnX21heDogQmlnTnVtYmVyID0gWUdfWkVSTztcblx0bGV0IHlnX3N0ZXA6IEJpZ051bWJlciA9IFlHX1pFUk87XG5cdGxldCBzX2ZpYXRfZXF1aXZhbGVudCA9ICcnO1xuXG5cdCQ6IHtcblx0XHRpZihhc3NldFJlZikge1xuXHRcdFx0dm9pZCByZWxvYWRfYXNzZXQoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRnX2Fzc2V0ID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHRsZXQgc2lfY29pbmdlY2tvID0gJyc7XG5cdCQ6IHtcblx0XHRpZihzaV9jb2luZ2Vja28pIHtcblx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0Y29uc3QgaF92ZXJzdXMgPSBhd2FpdCBDb2luR2Vja28uY29pbnNWZXJzdXMoW3NpX2NvaW5nZWNrb10sICd1c2QnLCAxKlhUX01JTlVURVMpO1xuXHRcdFx0XHRpZihzaV9jb2luZ2Vja28gaW4gaF92ZXJzdXMpIHtcblx0XHRcdFx0XHRzX2ZpYXRfZXF1aXZhbGVudCA9IGZvcm1hdF9hbW91bnQoK3ZhbHVlICogK2hfdmVyc3VzW3NpX2NvaW5nZWNrb10sIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHNfZmlhdF9lcXVpdmFsZW50ID0gJyg/KSc7XG5cdFx0XHRcdH1cblx0XHRcdH0pKCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c19maWF0X2VxdWl2YWxlbnQgPSAnJztcblx0XHR9XG5cdH1cblxuXHRhc3luYyBmdW5jdGlvbiByZWxvYWRfYXNzZXQoKSB7XG5cdFx0c19maWF0X2VxdWl2YWxlbnQgPSAnWy4uLl0nO1xuXG5cdFx0Y29uc3QgZ19lbnRpdHkgPSBFbnRpdGllcy5wYXJzZUVudGl0eVBhdGgoYXNzZXRSZWYgYXMgRW50aXR5UGF0aCk7XG5cdFx0aWYoJ2hvbGRpbmcnID09PSBnX2VudGl0eT8udHlwZSkge1xuXHRcdFx0Y29uc3Qgc2lfY29pbiA9IGdfZW50aXR5LmNvaW47XG5cblx0XHRcdGdfYXNzZXQgPSAkeXdfY2hhaW4uY29pbnNbc2lfY29pbl07XG5cblx0XHRcdGNvbnN0IGdfY2FjaGVkID0gJHl3X25ldHdvcmtfYWN0aXZlLmNhY2hlZEJhbGFuY2UoJHl3X293bmVyLCBzaV9jb2luKTtcblxuXHRcdFx0aWYoZ19jYWNoZWQgJiYgZ19jYWNoZWQudGltZXN0YW1wID4gRGF0ZS5ub3coKSAtICg1ICogWFRfTUlOVVRFUykpIHtcblx0XHRcdFx0eWdfbWF4ID0gbmV3IEJpZ051bWJlcihnX2NhY2hlZC5kYXRhLmFtb3VudCkuc2hpZnRlZEJ5KC1nX2Fzc2V0LmRlY2ltYWxzKS5taW51cyhuZXcgQmlnTnVtYmVyKGJ1ZmZlck1heCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBnX2J1bmRsZSA9IGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5iYW5rQmFsYW5jZSgkeXdfb3duZXIsIHNpX2NvaW4pO1xuXG5cdFx0XHQvLyBzdGlsbCBvbiBzYW1lIGNvaW5cblx0XHRcdGlmKGFzc2V0UmVmID09PSBnX2J1bmRsZS5ob2xkaW5nKSB7XG5cdFx0XHRcdGNvbnN0IHlnX2Ftb3VudCA9IG5ldyBCaWdOdW1iZXIoZ19idW5kbGUuYmFsYW5jZS5hbW91bnQpLnNoaWZ0ZWRCeSgtZ19hc3NldC5kZWNpbWFscykubWludXMobmV3IEJpZ051bWJlcihidWZmZXJNYXgpKTtcblx0XHRcdFx0aWYoIXlnX2Ftb3VudC5lcSh5Z19tYXgpKSB7XG5cdFx0XHRcdFx0eWdfbWF4ID0geWdfYW1vdW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZ19jb2luID0gJHl3X2NoYWluLmNvaW5zW3NpX2NvaW5dO1xuXG5cdFx0XHRcdHNpX2NvaW5nZWNrbyA9IGdfY29pbj8uZXh0cmE/LmNvaW5nZWNrb19pZCB8fCAnJztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZigndG9rZW4nID09PSBnX2VudGl0eT8udHlwZSkge1xuXHRcdFx0Ly8gY29uc3QgaF9pbnRlcmZhY2VzID0gRW50aXRpZXMuaW5mb0ZvclRva2VuKCk7XG5cdFx0XHQvLyAuLi5cblx0XHRcdC8vIFRPRE86IGltcGxlbWVudFxuXHRcdFx0Z19hc3NldCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYoZ19hc3NldCkge1xuXHRcdFx0eWdfc3RlcCA9IFlHX09ORS5zaGlmdGVkQnkoLWdfYXNzZXQuZGVjaW1hbHMpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHlnX3N0ZXAgPSBZR19aRVJPO1xuXHRcdFx0eWdfbWF4ID0gWUdfWkVSTztcblx0XHR9XG5cdH1cblxuXG5cdC8vICQ6IHhnX2Ftb3VudCA9IEJpZ0ludCgobmV3IEJpZ051bWJlcih2YWx1ZSkpLnNoaWZ0ZWRCeSgkeXdfYXNzZXRfc2VuZD8uZGVmLmRlY2ltYWxzIHx8IDApKycnKTtcblxuXHQvLyAkOiB5Z19zdGVwID0gZ19hc3NldD8gWUdfT05FLnNoaWZ0ZWRCeSgtZ19hc3NldC5kZWNpbWFscyk6IFlHX1pFUk87XG5cdC8vICQ6IHlnX21heCA9IENoYWlucy5cblx0Ly8gZ19hc3NldD8uYW1vdW50KEhfVE9LRU5TKSB8fCBZR19aRVJPO1xuXG5cdC8vIC8vIGZpeCBzdmVsdGUncyBzdHVwaWQgbWlzdGFrZSBvZiBjb2VyY2luZyBpbnB1dFt0eXBlPVwibnVtYmVyXCJdIHZhbHVlcyB0byBlcyBudW1iZXJzXG5cdC8vICQ6IHtcblx0Ly8gXHRpZignbnVtYmVyJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG5cdC8vIFx0XHR2YWx1ZSA9IGRtX2lucHV0LnZhbHVlO1xuXHQvLyBcdH1cblx0Ly8gfVxuXG5cdGZ1bmN0aW9uIGNhcHR1cmVfaW5wdXQoZF9ldmVudDogRXZlbnQpIHtcblx0XHR2YWx1ZSA9IChkX2V2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluY3JlbWVudCgpIHtcblx0XHRjb25zdCB5Z19uZXh0ID0geWdfc3RlcC5wbHVzKHZhbHVlIHx8IDApO1xuXG5cdFx0aWYoeWdfbmV4dC5sdGUoeWdfbWF4KSkge1xuXHRcdFx0dmFsdWUgPSB5Z19uZXh0KycnO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZhbHVlID0geWdfbWF4KycnO1xuXHRcdH1cblxuXHRcdGNoZWNrX3ZhbGlkaXR5KCk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNyZW1lbnQoKSB7XG5cdFx0Y29uc3QgeWdfbmV4dCA9IHlnX3N0ZXAubmVnYXRlZCgpLnBsdXModmFsdWUgfHwgMCk7XG5cdFx0aWYoeWdfbmV4dC5ndGUoMCkpIHtcblx0XHRcdGlmKHlnX25leHQuZ3QoeWdfbWF4KSkge1xuXHRcdFx0XHR2YWx1ZSA9IHlnX21heCsnJztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IHlnX25leHQrJyc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFsdWUgPSAnMCc7XG5cdFx0fVxuXG5cdFx0Y2hlY2tfdmFsaWRpdHkoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvbmdfcHJlc3MoZl9hY3Rpb246IFZvaWRGdW5jdGlvbikge1xuXHRcdGxldCBpX3RpY2tlciA9IDA7XG5cdFx0Y29uc3QgaV9idWZmZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRpX3RpY2tlciA9IHdpbmRvdy5zZXRJbnRlcnZhbChmX2FjdGlvbiwgOTApO1xuXHRcdH0sIDEwMDApO1xuXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB7XG5cdFx0XHRjbGVhclRpbWVvdXQoaV9idWZmZXIpO1xuXHRcdFx0Y2xlYXJJbnRlcnZhbChpX3RpY2tlcik7XG5cdFx0fSwge1xuXHRcdFx0b25jZTogdHJ1ZSxcblx0XHR9KTtcblx0fVxuXG5cdGV4cG9ydCBsZXQgZXJyb3IgPSAnJztcblx0bGV0IGRtX2lucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xuXG5cdGZ1bmN0aW9uIGludmFsaWRhdGUoc19tc2c6IHN0cmluZykge1xuXHRcdGRtX2lucHV0LnNldEN1c3RvbVZhbGlkaXR5KHNfbXNnKTtcblx0XHRlcnJvciA9IHNfbXNnO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tfdmFsaWRpdHkoKSB7XG5cdFx0aWYoIXZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaW52YWxpZGF0ZSgnRW50ZXIgYW4gYW1vdW50Jyk7XG5cdFx0fVxuXG5cdFx0bGV0IHlnX2lucHV0ITogQmlnTnVtYmVyO1xuXHRcdHRyeSB7XG5cdFx0XHR5Z19pbnB1dCA9IG5ldyBCaWdOdW1iZXIodmFsdWUpO1xuXHRcdH1cblx0XHRjYXRjaChlX3BhcnNlKSB7XG5cdFx0XHRyZXR1cm4gaW52YWxpZGF0ZSgnSW52YWxpZCBudW1iZXInKTtcblx0XHR9XG5cblx0XHRpZih5Z19pbnB1dC5sdChZR19aRVJPKSkge1xuXHRcdFx0cmV0dXJuIGludmFsaWRhdGUoJ1ZhbHVlIG11c3QgYmUgcG9zaXRpdmUnKTtcblx0XHR9XG5cblx0XHRpZih5Z19pbnB1dC5ndCh5Z19tYXgpKSB7XG5cdFx0XHRyZXR1cm4gaW52YWxpZGF0ZSgnSW5zdWZmaWNpZW50IGJhbGFuY2UnKTtcblx0XHR9XG5cblx0XHRlcnJvciA9ICcnO1xuXHR9XG5cblx0ZXhwb3J0IGxldCBzaG93VmFsaWRhdGlvbiA9IDA7XG5cdCQ6IHtcblx0XHRpZihzaG93VmFsaWRhdGlvbikge1xuXHRcdFx0Y2hlY2tfdmFsaWRpdHkoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZighdmFsdWUpIHtcblx0XHRcdGVycm9yID0gJyc7XG5cdFx0fVxuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0aW5wdXRbdHlwZT1cIm51bWJlclwiXSB7XG5cdFx0YXBwZWFyYW5jZTogdGV4dGZpZWxkO1xuXG5cdFx0Jjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiwgJjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XG5cdFx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG5cdFx0fVxuXHR9XG5cblx0LmFtb3VudC1pbnB1dCB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHR9XG5cblx0Lm9jY3VweSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHJpZ2h0OiAwO1xuXHRcdHRvcDogMDtcblx0XHRoZWlnaHQ6IHZhcigtLXVpLXJvdy1oZWlnaHQpO1xuXG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXG5cdFx0LmFkanVzdCB7XG5cblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0XHRnYXA6IDRweDtcblx0XHRcdG1hcmdpbi1yaWdodDogOHB4O1xuXG5cdFx0XHQuaWNvbiB7XG5cdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdFx0cGFkZGluZzogMHB4IDhweDtcblx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAxNnB4O1xuXHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXG5cdFx0XHRcdDpnbG9iYWwoc3ZnKSB7XG5cdFx0XHRcdFx0d2lkdGg6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHRcdGhlaWdodDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQuaW5jcmVtZW50IHtcblx0XHRcdFx0XHRwYWRkaW5nLXRvcDogNHB4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LmRlY3JlbWVudCB7XG5cdFx0XHRcdFx0cGFkZGluZy1ib3R0b206IDRweDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5lcXVpdmFsZW50IHtcblx0XHRcdC5mb250KHJlZ3VsYXIsIEBzaXplOiAxM3B4LCBAd2VpZ2h0OiAzMDApO1xuXG5cdFx0XHQuYW1vdW50IHtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdH1cblxuXHRcdFx0LmZpYXQge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiYW1vdW50LWlucHV0XCI+XG5cdDxpbnB1dFxuXHRcdGRpc2FibGVkPXshYXNzZXRSZWZ9XG5cdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0bWluPVwiMFwiXG5cdFx0bWF4PXt5Z19tYXgrJycgfHwgJzAnfVxuXHRcdHN0ZXA9XCIwLnsnMCcucmVwZWF0KChnX2Fzc2V0Py5kZWNpbWFscyB8fCAxKSAtIDEpfTFcIlxuXHRcdHJlcXVpcmVkXG5cdFx0b246Y2hhbmdlPXsoKSA9PiBjaGVja192YWxpZGl0eSgpfVxuXHRcdG9uOmlucHV0PXtjYXB0dXJlX2lucHV0fVxuXHRcdHt2YWx1ZX1cblx0XHRiaW5kOnRoaXM9e2RtX2lucHV0fVxuXHRcdG9uOmludmFsaWQ9e2QgPT4gZC5wcmV2ZW50RGVmYXVsdCgpfVxuXHRcdGNsYXNzOmludmFsaWQ9e2Vycm9yfVxuXHQ+XG5cblx0eyNpZiBnX2Fzc2V0fVxuXHRcdDxzcGFuIGNsYXNzPVwib2NjdXB5XCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImVxdWl2YWxlbnRcIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJhbW91bnRcIj5cblx0XHRcdFx0XHQ9IHtzX2ZpYXRfZXF1aXZhbGVudH1cblx0XHRcdFx0XHQ8IS0tICBhbW91bnRfdG9fZmlhdCgrdmFsdWUsICR5d19hc3NldF9zZW5kLCB0cnVlKSAtLT5cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImZpYXRcIj5cblx0XHRcdFx0XHRVU0Rcblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9zcGFuPlxuXG5cdFx0XHQ8c3BhbiBjbGFzcz1cImFkanVzdFwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb24gaW5jcmVtZW50IGNsaWNrYWJsZVwiXG5cdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IGluY3JlbWVudCgpfVxuXHRcdFx0XHRcdG9uOm1vdXNlZG93bj17KCkgPT4gbG9uZ19wcmVzcyhpbmNyZW1lbnQpfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fSU5DUkVNRU5UfVxuXHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGRlY3JlbWVudCBjbGlja2FibGVcIlxuXHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiBkZWNyZW1lbnQoKX1cblx0XHRcdFx0XHRvbjptb3VzZWRvd249eygpID0+IGxvbmdfcHJlc3MoZGVjcmVtZW50KX1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdHtAaHRtbCBTWF9JQ09OX0RFQ1JFTUVOVH1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9zcGFuPlxuXHRcdDwvc3Bhbj5cblx0ey9pZn1cblxuXHR7I2lmIGVycm9yfVxuXHRcdDxzcGFuIGNsYXNzPVwidmFsaWRhdGlvbi1tZXNzYWdlXCI+XG5cdFx0XHR7ZXJyb3J9XG5cdFx0PC9zcGFuPlxuXHR7L2lmfVxuPC9kaXY+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgeXdfYWNjb3VudF9yZWYsIHl3X2NoYWlufSBmcm9tICcjIy9tZW0nO1xuXHRpbXBvcnQgdHlwZSB7QWNjb3VudCwgQWNjb3VudFBhdGh9IGZyb20gJyMvbWV0YS9hY2NvdW50Jztcblx0aW1wb3J0IHsgQWNjb3VudHMgfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHsgb2RlLCBvZGVyYWMgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblxuXHRpbXBvcnQgU3RhclNlbGVjdCwgeyBTZWxlY3RPcHRpb24gfSBmcm9tICcuL1N0YXJTZWxlY3Quc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IGFjY291bnRSZWY6IEFjY291bnRQYXRoID0gJHl3X2FjY291bnRfcmVmO1xuXHQvLyBjb25zdCBwX2FjY291bnQgPSBhY2NvdW50UmVmO1xuXG5cblx0Y29uc3QgbWtfYWNjb3VudCA9IChwX2FjYzogQWNjb3VudFBhdGgsIGdfYWNjOiBBY2NvdW50WydpbnRlcmZhY2UnXSkgPT4gKHtcblx0XHR2YWx1ZTogcF9hY2MsXG5cdFx0cHJpbWFyeTogZ19hY2MubmFtZSxcblx0XHRzZWNvbmRhcnk6IGdfYWNjLmV4dHJhPy50b3RhbF9maWF0X2NhY2hlIHx8ICcoPyknLFxuXHRcdC8vIHNlY29uZGFyeTogZm9ybWF0X2ZpYXQoZ19hY2MuaG9sZGluZ3MoSF9IT0xESU5HUywgJHl3X2NoYWluKVxuXHRcdFx0Ly8gLnJlZHVjZSgoY19zdW0sIGtfaG9sZGluZykgPT4gY19zdW0gKyBrX2hvbGRpbmcudG9Vc2QoSF9UT0tFTlMsIEhfVkVSU1VTX1VTRCksIDApKSxcblx0fSk7XG5cblx0bGV0IGdfc2VsZWN0ZWQ6IFNlbGVjdE9wdGlvbjxBY2NvdW50UGF0aD47ICAvLyA9IG1rX2FjY291bnQoJHl3X2FjY291bnRfcmVmLCAkeXdfYWNjb3VudCk7XG5cdGxldCBhX29wdGlvbnM6IHR5cGVvZiBnX3NlbGVjdGVkW107XG5cblx0Ly8gcmVhY3RpdmVseSB1cGRhdGUgdGhlIGV4cG9ydGVkIGFjY291bnQgcmVmIGJpbmRpbmdcblx0JDogaWYoZ19zZWxlY3RlZCkge1xuXHRcdGFjY291bnRSZWYgPSBnX3NlbGVjdGVkLnZhbHVlO1xuXHR9XG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9hY2NvdW50cygpIHtcblx0XHRjb25zdCBrc19hY2NvdW50cyA9IGF3YWl0IEFjY291bnRzLnJlYWQoKTtcblxuXHRcdGFfb3B0aW9ucyA9IG9kZXJhYyhrc19hY2NvdW50cy5yYXcsIG1rX2FjY291bnQpO1xuXHRcdGdfc2VsZWN0ZWQgPSBhX29wdGlvbnMuZmluZChnID0+IGFjY291bnRSZWYgPT09IGcudmFsdWUpITtcblxuXHRcdHJldHVybiBhX29wdGlvbnM7XG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcbjwvc3R5bGU+XG5cblxuPGRpdiBjbGFzcz1cInNlbmRlclwiPlxuXHR7I2F3YWl0IGxvYWRfYWNjb3VudHMoKX1cblx0XHRMb2FkaW5nIGFjY291bnRzLi4uXG5cdHs6dGhlbiBhX29wdGlvbnN9XG5cdFx0PFN0YXJTZWxlY3QgaWQ9XCJzZW5kZXItc2VsZWN0XCJcblx0XHRcdHBsYWNlaG9sZGVyPVwiU2VsZWN0IGFjY291bnRcIlxuXHRcdFx0c2Vjb25kYXJ5Q2xhc3M9J2JhbGFuY2UnXG5cdFx0XHRpdGVtcz17YV9vcHRpb25zfVxuXHRcdFx0YmluZDp2YWx1ZT17Z19zZWxlY3RlZH1cblx0XHQvPlxuXHR7L2F3YWl0fVxuPC9kaXY+IiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCIgbGFuZz1cInRzXCI+XG5cdGV4cG9ydCBpbnRlcmZhY2UgQ29udGFjdE9wdGlvbiB7XG5cdFx0dmFsdWU6IENoYWluLkJlY2gzMlN0cmluZztcblx0XHRsYWJlbDogc3RyaW5nO1xuXHRcdGNvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddO1xuXHR9XG48L3NjcmlwdD5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHt5d19jaGFpbiwgeXdfZmFtaWx5fSBmcm9tICcjIy9tZW0nO1xuXHRpbXBvcnQgdHlwZSB7IENoYWluIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IHR5cGUgeyBDb250YWN0LCBDb250YWN0UGF0aCB9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHsgQWdlbnRzIH0gZnJvbSAnIy9zdG9yZS9hZ2VudHMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IHN1YnNjcmliZV9zdG9yZSB9IGZyb20gJyMvc3RvcmUvX2Jhc2UnO1xuXHRpbXBvcnQgeyBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgUGZwRGlzcGxheSBmcm9tICcuL1BmcERpc3BsYXkuc3ZlbHRlJztcblxuXHQvKipcblx0ICogUmVzb3VyY2UgcGF0aCB0byB0aGUgY29udGFjdFxuXHQgKi9cblx0ZXhwb3J0IGxldCBjb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSB8IG51bGwgPSBudWxsO1xuXHRsZXQgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSA9IGNvbnRhY3QhO1xuXG5cdC8qKlxuXHQgKiBNYW51YWxseSBlbnRlcmVkIGFkZHJlc3Ncblx0ICovXG5cdGV4cG9ydCBsZXQgYWRkcmVzczogQ2hhaW4uQmVjaDMyU3RyaW5nID0gJyc7XG5cblx0Ly8gLy8gcmVzb2x2ZWQgY29udGFjdFxuXHQvLyBsZXQgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXTtcblxuXHQvLyBsb2FkIGNvbnRhY3QgZGVmIGZyb20gc3RvcmVcblx0YXN5bmMgZnVuY3Rpb24gcmVsb2FkX2NvbnRhY3RzKCkge1xuXHRcdC8vIGxvYWQgYWdlbnRzIHN0b3JlXG5cdFx0Y29uc3Qga3NfYWdlbnRzID0gYXdhaXQgQWdlbnRzLnJlYWQoKTtcblxuXHRcdC8vIGNvbnRhY3QgaXRlcmF0b3Jcblx0XHRjb25zdCBkaV9jb250YWN0cyA9IGtzX2FnZW50cy5jb250YWN0cygkeXdfZmFtaWx5KTtcbi8vIGRlYnVnZ2VyO1xuLy8gXHRcdC8vIGNvbnRhY3QgaXMgcHJlc2VudFxuLy8gXHRcdGlmKGdfY29udGFjdCkge1xuLy8gXHRcdFx0Ly8gZWFjaCBjb250YWN0XG4vLyBcdFx0XHRmb3IoY29uc3QgW3BfY29udGFjdF9lYWNoLCBnX2NvbnRhY3RfZWFjaF0gb2YgZGlfY29udGFjdHMpIHtcbi8vIFx0XHRcdFx0Ly8gZm91bmQgbWF0Y2hcbi8vIFx0XHRcdFx0aWYocF9jb250YWN0ID09PSBwX2NvbnRhY3RfZWFjaCkge1xuLy8gXHRcdFx0XHRcdGdfY29udGFjdCA9IGdfY29udGFjdF9lYWNoO1xuLy8gXHRcdFx0XHRcdGJyZWFrO1xuLy8gXHRcdFx0XHR9XG4vLyBcdFx0XHR9XG4vLyBcdFx0fVxuXHRcdC8vIG9ubHkgYWRkcmVzcyB3YXMgZ2l2ZW5cblx0XHRpZighZ19jb250YWN0ICYmIGFkZHJlc3MpIHtcblx0XHRcdC8vIGVhY2ggY29udGFjdFxuXHRcdFx0Zm9yKGNvbnN0IFssIGdfY29udGFjdF9lYWNoXSBvZiBkaV9jb250YWN0cykge1xuXHRcdFx0XHQvLyBjaGVjayBpZiBhZGRyZXNzIGV4aXN0cyBpbiBjb250YWN0cywgZm91bmQgbWF0Y2hcblx0XHRcdFx0aWYoYWRkcmVzcyA9PT0gQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3RfZWFjaC5hZGRyZXNzKSkge1xuXHRcdFx0XHRcdGdfY29udGFjdCA9IGdfY29udGFjdF9lYWNoO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dm9pZCByZWxvYWRfY29udGFjdHMoKTtcblx0Y29uc3QgZl91bnN1Yl9hZ2VudHMgPSBzdWJzY3JpYmVfc3RvcmUoJ2FnZW50cycsIHJlbG9hZF9jb250YWN0cyk7XG5cdG9uRGVzdHJveSgoKSA9PiB7XG5cdFx0Zl91bnN1Yl9hZ2VudHMoKTtcblx0fSk7XG5cblxuXHQvLyBleHBvcnQgbGV0IGdfaXRlbToge1xuXHQvLyBcdGNvbnRhY3Q6IENvbnRhY3Q7XG5cdC8vIFx0aXNHcm91cEhlYWRlcj86IGJvb2xlYW47XG5cdC8vIFx0aXNHcm91cEl0ZW0/OiBib29sZWFuO1xuXHQvLyBcdGlzQ3JlYXRvcj86IGJvb2xlYW47XG5cdC8vIH0gfCB1bmRlZmluZWQgPSB2b2lkIDA7XG5cblx0PC9zY3JpcHQ+XG5cdFxuXHQ8c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0XHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblx0XG5cdFx0LmNvbnRhY3Qge1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiByb3c7XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcblx0XHRcdC8vIHBhZGRpbmctdG9wOiAzcHg7XG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94Oztcblx0XG5cdFx0XHQ+LmNvbnRhY3QtcGZwIHtcblx0XHRcdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0XHRcdC0tcHJveHktaWNvbi1kaWFtZXRlcjogMjZweDtcblx0XHRcdFx0bGluZS1oZWlnaHQ6IDI2cHg7XG5cdFx0XHRcdG1hcmdpbi1yaWdodDogNnB4O1xuXHRcblx0XHRcdFx0Pi5pY29uIHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdGJvcmRlci1yYWRpdXM6IDIwJTtcblx0XHRcdFx0XHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdFx0XHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC5pY29uLWRvbSB7XG5cdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiB1bnNldDtcblx0XHRcdFx0XHRcdFx0Zm9udC1zaXplOiAxNHB4OyBcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQ+LmluZm8ge1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdFx0XHRtYXgtd2lkdGg6IDE3MnB4O1xuXHRcblx0XHRcdFx0Pi5uYW1lIHtcblx0XHRcdFx0XHRsaW5lLWhlaWdodDogMS4yZW07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdD4uYWRkcmVzcyB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHQvLyAuZm9udChtb25vLXRpbnkpO1xuXHRcdFx0XHRcdFx0bGluZS1oZWlnaHQ6IDEuMmVtO1xuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyA+KiB7XG5cdFx0XHQvLyBcdDpnbG9iYWwoJikge1xuXHRcdFx0Ly8gXHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdFx0XHQvLyBcdH1cblx0XHRcdC8vIH1cblx0XHR9XG5cdFxuXHRcdC5tYW51YWwge1xuXHRcdFx0LmFkZHJlc3Mge1xuXHRcdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gMy41Y2gpO1xuXHRcdFx0fVxuXHRcdH1cblx0PC9zdHlsZT5cblx0XG5cdHsjaWYgZ19jb250YWN0fVxuXHRcdDxkaXYgY2xhc3M9XCJjb250YWN0XCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImNvbnRhY3QtcGZwXCI+XG5cdFx0XHRcdHsjaWYgZ19jb250YWN0fVxuXHRcdFx0XHRcdDxQZnBEaXNwbGF5IGRpbT17Mjh9IHJlc291cmNlPXtnX2NvbnRhY3R9IGdlblN0eWxlPSdmb250LXNpemU6MThweDsnIC8+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHQ8L3NwYW4+XG5cdFxuXHRcdFx0PHNwYW4gY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdHtnX2NvbnRhY3QubmFtZX1cblx0XHRcdFx0PC9zcGFuPlxuXHRcblx0XHRcdFx0PEFkZHJlc3MgYWRkcmVzcz17Q2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcyl9IC8+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9kaXY+XG5cdHs6ZWxzZSBpZiBhZGRyZXNzfVxuXHRcdDxzcGFuIGNsYXNzPVwibWFudWFsXCI+XG5cdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXthZGRyZXNzfSAvPlxuXHRcdDwvc3Bhbj5cblx0ezplbHNlfVxuXHRcdDxzcGFuIGNsYXNzPVwid2FybmluZ1wiPlxuXHRcdFx0RmFpbGVkIHRvIGxvY2F0ZSBjb250YWN0XG5cdFx0PC9zcGFuPlxuXHR7L2lmfSIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdFBhdGh9IGZyb20gJyMvbWV0YS9jb250YWN0JztcblxuXHRpbXBvcnQgSW5saW5lQ29udGFjdFNlbGVjdGlvbiwgeyBDb250YWN0T3B0aW9uIH0gZnJvbSAnLi9JbmxpbmVDb250YWN0U2VsZWN0aW9uLnN2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBpc0FjdGl2ZSA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGlzRmlyc3QgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBpc0hvdmVyID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgaXNTZWxlY3RhYmxlID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgZ2V0T3B0aW9uTGFiZWwgPSB2b2lkIDA7XG5cdGV4cG9ydCBsZXQgaXRlbTogQ29udGFjdE9wdGlvbjtcblx0Ly8gXHRpc0dyb3VwSGVhZGVyPzogYm9vbGVhbjtcblx0Ly8gXHRpc0dyb3VwSXRlbT86IGJvb2xlYW47XG5cdC8vIH07XG5cdGV4cG9ydCBsZXQgZmlsdGVyVGV4dCA9ICcnO1xuXG5cdGxldCBpdGVtQ2xhc3NlcyA9ICcnO1xuXG5cdCQ6IHtcblx0XHRjb25zdCBjbGFzc2VzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdGlmKGlzQWN0aXZlKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2FjdGl2ZScpO1xuXHRcdH1cblx0XG5cdFx0aWYoaXNGaXJzdCkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdmaXJzdCcpO1xuXHRcdH1cblx0XG5cdFx0aWYoaXNIb3Zlcikge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdob3ZlcicpO1xuXHRcdH1cblx0XG5cdFx0Ly8gaWYoaXRlbS5pc0dyb3VwSGVhZGVyKSB7XG5cdFx0Ly8gXHRjbGFzc2VzLnB1c2goJ2dyb3VwSGVhZGVyJyk7XG5cdFx0Ly8gfVxuXHRcblx0XHQvLyBpZihpdGVtLmlzR3JvdXBJdGVtKSB7XG5cdFx0Ly8gXHRjbGFzc2VzLnB1c2goJ2dyb3VwSXRlbScpO1xuXHRcdC8vIH1cblx0XG5cdFx0aWYoIWlzU2VsZWN0YWJsZSkge1xuXHRcdFx0Y2xhc3Nlcy5wdXNoKCdub3RTZWxlY3RhYmxlJyk7XG5cdFx0fVxuXHRcblx0XHRpdGVtQ2xhc3NlcyA9IGNsYXNzZXMuam9pbignICcpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5pdGVtIHtcblx0XHRjdXJzb3I6IGRlZmF1bHQ7XG5cdFx0aGVpZ2h0OiB2YXIoLS1oZWlnaHQsIDQycHgpO1xuXHRcdGxpbmUtaGVpZ2h0OiB2YXIoLS1oZWlnaHQsIDQycHgpO1xuXHRcdHBhZGRpbmc6IHZhcigtLWl0ZW1QYWRkaW5nLCAwIDIwcHgpO1xuXHRcdGNvbG9yOiB2YXIoLS1pdGVtQ29sb3IsIGluaGVyaXQpO1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRwYWRkaW5nLWxlZnQ6IDhweDtcblx0fVxuXG5cdC5ncm91cEhlYWRlciB7XG5cdFx0dGV4dC10cmFuc2Zvcm06IHZhcigtLWdyb3VwVGl0bGVUZXh0VHJhbnNmb3JtLCB1cHBlcmNhc2UpO1xuXHR9XG5cblx0Lmdyb3VwSXRlbSB7XG5cdFx0cGFkZGluZy1sZWZ0OiB2YXIoLS1ncm91cEl0ZW1QYWRkaW5nTGVmdCwgNDBweCk7XG5cdH1cblxuXHQuaXRlbTphY3RpdmUge1xuXHRcdGJhY2tncm91bmQ6IHZhcigtLWl0ZW1BY3RpdmVCYWNrZ3JvdW5kLCAjYjlkYWZmKTtcblx0fVxuXG5cdC5pdGVtLmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogdmFyKC0taXRlbUlzQWN0aXZlQkcsICMwMDdhZmYpO1xuXHRcdGNvbG9yOiB2YXIoLS1pdGVtSXNBY3RpdmVDb2xvciwgI2ZmZik7XG5cdH1cblxuXHQuaXRlbS5ub3RTZWxlY3RhYmxlIHtcblx0XHRjb2xvcjogdmFyKC0taXRlbUlzTm90U2VsZWN0YWJsZUNvbG9yLCAjOTk5KTtcblx0fVxuXG5cdC5pdGVtLmZpcnN0IHtcblx0XHRib3JkZXItcmFkaXVzOiB2YXIoLS1pdGVtRmlyc3RCb3JkZXJSYWRpdXMsIDRweCA0cHggMCAwKTtcblx0fVxuXG5cdC5pdGVtLmhvdmVyOm5vdCguYWN0aXZlKSB7XG5cdFx0YmFja2dyb3VuZDogdmFyKC0taXRlbUhvdmVyQkcsICNlN2YyZmYpO1xuXHRcdGNvbG9yOiB2YXIoLS1pdGVtSG92ZXJDb2xvciwgaW5oZXJpdCk7XG5cdH1cbjwvc3R5bGU+XG5cblxuPGRpdiBjbGFzcz1cIml0ZW0ge2l0ZW1DbGFzc2VzfVwiIGNsYXNzOmRpc3BsYXlfbm9uZT17aXNBY3RpdmUgfHwgIWl0ZW0udmFsdWV9PlxuXHQ8SW5saW5lQ29udGFjdFNlbGVjdGlvbiBjb250YWN0PXtpdGVtLmNvbnRhY3R9IGFkZHJlc3M9e2l0ZW0udmFsdWV9IC8+XG48L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdFBhdGh9IGZyb20gJyMvbWV0YS9jb250YWN0JztcblxuXHRpbXBvcnQgSW5saW5lQ29udGFjdFNlbGVjdGlvbiwgeyBDb250YWN0T3B0aW9uIH0gZnJvbSAnLi9JbmxpbmVDb250YWN0U2VsZWN0aW9uLnN2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBnZXRTZWxlY3Rpb25MYWJlbDtcblx0ZXhwb3J0IGxldCBpdGVtOiBDb250YWN0T3B0aW9uO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQuc2VsZWN0aW9uIHtcblx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHRvdmVyZmxvdy14OiBoaWRkZW47XG5cdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0cGFkZGluZy1sZWZ0OiA4cHg7XG5cblx0XHQubWFudWFsPi5hZGRyZXNzIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gMy41Y2gpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwic2VsZWN0aW9uXCI+XG5cdDxJbmxpbmVDb250YWN0U2VsZWN0aW9uIGNvbnRhY3Q9e2l0ZW0uY29udGFjdH0gYWRkcmVzcz17aXRlbS52YWx1ZX0gLz5cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7eXdfYWNjb3VudCwgeXdfY2hhaW4sIHl3X2ZhbWlseSwgeXdfaGVscH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgUmVjaXBpZW50U2VsZWN0SXRlbSBmcm9tICcuL1JlY2lwaWVudFNlbGVjdEl0ZW0uc3ZlbHRlJztcblxuXHRpbXBvcnQgU2VsZWN0IGZyb20gJ3N2ZWx0ZS1zZWxlY3QnO1xuXHRpbXBvcnQgU1hfSUNPTl9TQ0FOIGZyb20gJyMvaWNvbi9xcl9jb2RlX3NjYW5uZXIuc3ZnP3Jhdyc7XG5cdGltcG9ydCBSZWNpcGllbnRTZWxlY3RTZWxlY3Rpb24gZnJvbSAnLi9SZWNpcGllbnRTZWxlY3RTZWxlY3Rpb24uc3ZlbHRlJztcblx0aW1wb3J0IHtvZGVyYWN9IGZyb20gJyMvdXRpbC9iZWx0Jztcblx0aW1wb3J0IHtvbk1vdW50fSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQge2RkLCBxc30gZnJvbSAnIy91dGlsL2RvbSc7XG5cdGltcG9ydCB0eXBlIHtBZ2VudFBhdGgsIENoYWlufSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgdHlwZSB7IENvbnRhY3QgfSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgdHlwZSB7IENvbnRhY3RPcHRpb24gfSBmcm9tICcuL0lubGluZUNvbnRhY3RTZWxlY3Rpb24uc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IGFkZHJlc3M6IENoYWluLkJlY2gzMlN0cmluZyA9ICcnO1xuXHRjb25zdCBzYV9pbnB1dCA9IGFkZHJlc3M7XG5cblx0ZXhwb3J0IGxldCBlcnJvciA9ICcnO1xuXG5cdGxldCBzX21hbnVhbF9pbnB1dDogc3RyaW5nO1xuXHRsZXQgZ19pdGVtX3NlbGVjdDogQ29udGFjdE9wdGlvbjtcblxuXHRsZXQgYV9jb250YWN0czogW0FnZW50UGF0aCwgQ29udGFjdFsnaW50ZXJmYWNlJ11dW107XG5cblx0Y29uc3QgY29udGFjdF90b19vcHRpb24gPSAoZzogQ29udGFjdFsnaW50ZXJmYWNlJ10pOiBDb250YWN0T3B0aW9uID0+ICh7XG5cdFx0dmFsdWU6IENoYWlucy5iZWNoMzIoZy5hZGRyZXNzKSxcblx0XHRsYWJlbDogZy5uYW1lLFxuXHRcdGNvbnRhY3Q6IGcsXG5cdH0pO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfY29udGFjdHMoKTogUHJvbWlzZTxDb250YWN0T3B0aW9uW10+IHtcblx0XHRjb25zdCBrc19hZ2VudHMgPSBhd2FpdCBBZ2VudHMucmVhZCgpO1xuXG5cdFx0Y29uc3QgYV9vcHRpb25zOiBDb250YWN0T3B0aW9uW10gPSBbe1xuXHRcdFx0dmFsdWU6ICcnLFxuXHRcdFx0bGFiZWw6ICcnLFxuXHRcdFx0Y29udGFjdDogbnVsbCEsXG5cdFx0fV07XG5cblx0XHRhX2NvbnRhY3RzID0gWy4uLmtzX2FnZW50cy5jb250YWN0cygkeXdfZmFtaWx5KV07XG5cdFx0Zm9yKGNvbnN0IFssIGdfY29udGFjdF0gb2YgYV9jb250YWN0cykge1xuXHRcdFx0Y29uc3QgZ19vcHRpb24gPSBjb250YWN0X3RvX29wdGlvbihnX2NvbnRhY3QpO1xuXG5cdFx0XHRjb25zdCBzYV9jb250YWN0ID0gQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcyk7XG5cdFx0XHRpZihzYV9pbnB1dCAmJiBzYV9jb250YWN0ID09PSBzYV9pbnB1dCkge1xuXHRcdFx0XHRnX2l0ZW1fc2VsZWN0ID0gZ19vcHRpb247XG5cdFx0XHR9XG5cblx0XHRcdGFfb3B0aW9ucy5wdXNoKGdfb3B0aW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYV9vcHRpb25zO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VsZWN0KGRfZXZlbnQ6IEN1c3RvbUV2ZW50PENvbnRhY3RPcHRpb24+KSB7XG5cdFx0YWRkcmVzcyA9IGRfZXZlbnQuZGV0YWlsLnZhbHVlO1xuXHRcdGVycm9yID0gJyc7XG5cdH1cblxuXHRmdW5jdGlvbiBjbGVhcigpIHtcblx0XHRhZGRyZXNzID0gJyc7XG5cdH1cblxuXHRsZXQgc19hY2NlcHRlZF9pbnB1dCA9ICcnO1xuXHRsZXQgYl9oaWRlX2N1cnNvciA9IGZhbHNlO1xuXG5cdGxldCBiX2xpc3Rfb3BlbiA9IGZhbHNlO1xuXG5cdCQ6IHtcblx0XHRiX2hpZGVfY3Vyc29yID0gZmFsc2U7XG5cblx0XHRpZihzX21hbnVhbF9pbnB1dCkge1xuXHRcdFx0Y2hlY2tfbWFudWFsX2lucHV0KCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Yl9oaWRlX2N1cnNvciA9ICEhc19hY2NlcHRlZF9pbnB1dDtcblx0XHRcdHNfYWNjZXB0ZWRfaW5wdXQgPSAnJztcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja19tYW51YWxfaW5wdXQoKSB7XG5cdFx0c19hY2NlcHRlZF9pbnB1dCA9ICcnO1xuXG5cdFx0aWYoISR5d19jaGFpbikge1xuXHRcdFx0Ly8gc2hvdWxkIG5vdCBiZSBhYmxlIHRvIGdldCBoZXJlIHdpdGhvdXQgYmVpbmcgb24gYSBjaGFpblxuXHRcdFx0ZXJyb3IgPSAnTm8gY2hhaW4gc2V0Jztcblx0XHR9XG5cdFx0ZWxzZSBpZighQ2hhaW5zLmlzVmFsaWRBZGRyZXNzRm9yKCR5d19jaGFpbiwgc19tYW51YWxfaW5wdXQsICdhY2MnKSkge1xuXHRcdFx0ZXJyb3IgPSAnSW52YWxpZCBhZGRyZXNzIGZvciB0aGlzIGNoYWluJztcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRlcnJvciA9ICcnO1xuXG5cdFx0XHQvLyBzZWFyY2ggZm9yIGFkZHJlc3MgaW4gY29udGFjdHNcblx0XHRcdGZvcihjb25zdCBbLCBnX2NvbnRhY3RdIG9mIGFfY29udGFjdHMpIHtcblx0XHRcdFx0Ly8gY29udGFjdCBleGlzdHNcblx0XHRcdFx0aWYoc19tYW51YWxfaW5wdXQgPT09IENoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MpKSB7XG5cdFx0XHRcdFx0Ly8gY2xlYXIgZmlsdGVyIHRleHRcblx0XHRcdFx0XHRzX21hbnVhbF9pbnB1dCA9ICcnO1xuXHRcblx0XHRcdFx0XHQvLyBzZWxlY3QgY29udGFjdCBpbnN0ZWFkIG9mIHVzaW5nIHJhdyBhZGRyZXNzXG5cdFx0XHRcdFx0Z19pdGVtX3NlbGVjdCA9IGNvbnRhY3RfdG9fb3B0aW9uKGdfY29udGFjdCk7XG5cblx0XHRcdFx0XHQvLyBjbG9zZSBsaXN0XG5cdFx0XHRcdFx0Yl9saXN0X29wZW4gPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIGhpZGUgY3Vyc29yXG5cdFx0XHRcdFx0Yl9oaWRlX2N1cnNvciA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHNfYWNjZXB0ZWRfaW5wdXQgPSBzX21hbnVhbF9pbnB1dDtcblxuXHRcdFx0Ly8gc2VsZWN0IGFkZHJlc3MgaW1tZWRpYXRlbHlcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHQocXMoZG1fc2VuZGVyLCAnLm1hbnVhbD4uYWRkcmVzcycpIGFzIEhUTUxFbGVtZW50KS5jbGljaygpO1xuXHRcdFx0XHRiX2xpc3Rfb3BlbiA9IGZhbHNlO1xuXHRcdFx0fSwgMCk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGRtX3NlbmRlcjogSFRNTEVsZW1lbnQ7XG5cdFxuXHRleHBvcnQgbGV0IHNob3dWYWxpZGF0aW9uID0gMDtcblx0JDoge1xuXHRcdGlmKHNob3dWYWxpZGF0aW9uKSB7XG5cdFx0XHRpZighYWRkcmVzcykge1xuXHRcdFx0XHRpZihzX21hbnVhbF9pbnB1dCkge1xuXHRcdFx0XHRcdGNoZWNrX21hbnVhbF9pbnB1dCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGVycm9yID0gJ0VudGVyIGEgcmVjaXBpZW50Jztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZighQ2hhaW5zLmlzVmFsaWRBZGRyZXNzRm9yKCR5d19jaGFpbiwgYWRkcmVzcywgJ2FjYycpKSB7XG5cdFx0XHRcdGVycm9yID0gJ0ludmFsaWQgYWRkcmVzcyBmb3IgdGhpcyBjaGFpbic7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZXJyb3IgPSAnJztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZighYWRkcmVzcykge1xuXHRcdFx0ZXJyb3IgPSAnJztcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblxuXHQuc2VuZGVyIHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0XHQuc3R5bGUtc3ZlbHRlLXNlbGVjdCgpO1xuXHRcdC5mb250KHJlZ3VsYXIsIDQwMCwgMTNweCk7XG5cblx0XHQtLWlucHV0UGFkZGluZzogMTZweDtcblx0XHQtLXBhZGRpbmc6IDAgNHB4O1xuXHRcdC0taXRlbVBhZGRpbmc6IDA7XG5cdFx0LS1zZWxlY3RlZEl0ZW1QYWRkaW5nOiAwO1xuXG5cdFx0PmlucHV0IHtcblx0XHRcdCY6OmFmdGVyIHtcblx0XHRcdFx0Y29udGVudDogJyc7XG5cdFx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdFx0cmlnaHQ6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pi5pY29uIHtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRyaWdodDogMDtcblx0XHRcdHBhZGRpbmc6IDEycHg7XG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0fVxuXG5cdFx0Lmxpc3RDb250YWluZXIgLmVtcHR5IHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ji5oaWRlLWN1cnNvciB7XG5cdFx0XHQuc2VsZWN0Q29udGFpbmVyIGlucHV0W3R5cGU9XCJ0ZXh0XCJdIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0Y2FyZXQtY29sb3I6IHRyYW5zcGFyZW50Oztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwic2VuZGVyXCIgYmluZDp0aGlzPXtkbV9zZW5kZXJ9IGNsYXNzOmhpZGUtY3Vyc29yPXtiX2hpZGVfY3Vyc29yfT5cblx0eyNhd2FpdCBsb2FkX2NvbnRhY3RzKCl9XG5cdFx0TG9hZGluZyBjb250YWN0cy4uLlxuXHR7OnRoZW4gYV9jb250YWN0c31cblx0XHQ8U2VsZWN0IGlkPVwicmVjaXBpZW50LXNlbGVjdFwiXG5cdFx0XHRwbGFjZWhvbGRlcj1cIkFkZHJlc3Mgb3IgY29udGFjdFwiXG5cdFx0XHRsaXN0T2Zmc2V0PXsxfVxuXHRcdFx0aXNDbGVhcmFibGU9eyEhYWRkcmVzc31cblx0XHRcdGlzQ3JlYXRhYmxlPXshIXNfYWNjZXB0ZWRfaW5wdXR9XG5cdFx0XHRJdGVtPXtSZWNpcGllbnRTZWxlY3RJdGVtfVxuXHRcdFx0U2VsZWN0aW9uPXtSZWNpcGllbnRTZWxlY3RTZWxlY3Rpb259XG5cdFx0XHRpdGVtcz17YV9jb250YWN0c31cblx0XHRcdHZhbHVlPXtnX2l0ZW1fc2VsZWN0fVxuXHRcdFx0bm9PcHRpb25zTWVzc2FnZT17J1N0b3AgdHlwaW5nIGluIHRoZSBhZGRyZXNzLiBcXG4gVXNlIGNvcHkvcGFzdGUgaW5zdGVhZCEnfVxuXHRcdFx0YmluZDpmaWx0ZXJUZXh0PXtzX21hbnVhbF9pbnB1dH1cblx0XHRcdGJpbmQ6bGlzdE9wZW49e2JfbGlzdF9vcGVufVxuXHRcdFx0b246c2VsZWN0PXtzZWxlY3R9XG5cdFx0XHRvbjpjbGVhcj17Y2xlYXJ9XG5cdFx0XHRjb250YWluZXJDbGFzc2VzPXtlcnJvcj8gJ2ludmFsaWQnOiAnJ31cblx0XHQvPlxuXHR7L2F3YWl0fVxuXG5cbjwhLS0gXG5cdDxzcGFuIGNsYXNzPVwiaWNvblwiIGNsYXNzOnZpc2liaWxpdHlfaGlkZGVuPXshIWFkZHJlc3N9IG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0JHl3X2hlbHAgPSBbXG5cdFx0XHRkZCgnYnInKSxcblx0XHRcdGRkKCdwJywge30sIFtgTm8gUVIgY29kZSBzY2FubmVyIGluIE1WUC4gQnV0IHlvdSBjYW4gdHJ5IGNvcHlpbmcgdGhlIGFkZHJlc3MgdGV4dCBieSB1c2luZyB5b3VyIGRldmljZSdzIGJ1aWx0LWluIGNhbWVyYSBhcHAuYF0pLFxuXHRcdFx0ZGQoJ2JyJyksXG5cdFx0XHRkZCgnYnInKSxcblx0XHRdO1xuXHR9fT5cblx0XHR7QGh0bWwgU1hfSUNPTl9TQ0FOfVxuXHQ8L3NwYW4+IC0tPlxuXG5cdHsjaWYgZXJyb3J9XG5cdFx0PHNwYW4gY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIj5cblx0XHRcdHtlcnJvcn1cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG48L2Rpdj4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIiBsYW5nPVwidHNcIj5cblxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgQWNjb3VudCwgQWNjb3VudFBhdGggfSBmcm9tIFwiIy9tZXRhL2FjY291bnRcIjtcblx0aW1wb3J0IHR5cGUgeyBCZWNoMzIgfSBmcm9tIFwiIy9tZXRhL2NoYWluXCI7XG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdCB9IGZyb20gXCIjL21ldGEvY29udGFjdFwiO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gXCIjL3N0b3JlL2FjY291bnRzXCI7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gXCIjL3N0b3JlL2FnZW50c1wiO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tIFwiIy9zdG9yZS9jaGFpbnNcIjtcblx0aW1wb3J0IHsgRXZlbnRzIH0gZnJvbSBcIiMvc3RvcmUvZXZlbnRzXCI7XG5cdGltcG9ydCB7IENvaW5HZWNrbyB9IGZyb20gXCIjL3N0b3JlL3dlYi1hcGlzXCI7XG5cdGltcG9ydCB7IGZvcm1hdF9maWF0IH0gZnJvbSBcIiMvdXRpbC9mb3JtYXRcIjtcblx0aW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XG5cblx0aW1wb3J0IHsgZ2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcblx0aW1wb3J0IHsgVGhyZWFkSWQgfSBmcm9tIFwiLi4vZGVmXCI7XG5cdGltcG9ydCB7IHl3X2NoYWluLCB5d19uYXZpZ2F0b3IsIHl3X25ldHdvcmtfYWN0aXZlIH0gZnJvbSBcIi4uL21lbVwiO1xuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSBcIi4uL3VpL0FjdGlvbnNMaW5lLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgQWRkcmVzcyBmcm9tIFwiLi4vdWkvQWRkcmVzcy5zdmVsdGVcIjtcblx0aW1wb3J0IEZpZWxkIGZyb20gXCIuLi91aS9GaWVsZC5zdmVsdGVcIjtcblx0aW1wb3J0IHsgU2NyZWVuLCBIZWFkZXIsIHR5cGUgUGFnZSB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHQvKipcblx0ICogTmF0aXZlIGNvaW4gaWRcblx0ICovXG5cdGV4cG9ydCBsZXQgY29pbjogc3RyaW5nO1xuXHRjb25zdCBzaV9jb2luID0gY29pbjtcblxuXHRjb25zdCBnX2NvaW4gPSAkeXdfY2hhaW4uY29pbnNbc2lfY29pbl07XG5cblx0ZXhwb3J0IGxldCBhY2NvdW50UmVmOiBBY2NvdW50UGF0aDtcblx0bGV0IGdfYWNjb3VudDogQWNjb3VudFsnaW50ZXJmYWNlJ107XG5cdGxldCBzYV9zZW5kZXI6IEJlY2gzMi5TdHJpbmc7XG5cblx0ZXhwb3J0IGxldCBhbW91bnQ6IHN0cmluZztcblx0Y29uc3Qgc19hbW91bnQgPSBhbW91bnQ7XG5cblx0ZXhwb3J0IGxldCByZWNpcGllbnQ6IEJlY2gzMi5TdHJpbmc7XG5cdGNvbnN0IHNhX3JlY2lwaWVudCA9IHJlY2lwaWVudDtcblxuXHRsZXQgc19yZWNpcGllbnRfdGl0bGUgPSAnJztcblxuXHRsZXQgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSB8IG51bGw7XG5cblx0ZXhwb3J0IGxldCBmZWU6IHN0cmluZztcblx0Y29uc3Qgc19mZWUgPSBmZWU7XG5cblx0JDogc190b3RhbCA9IG5ldyBCaWdOdW1iZXIoc19hbW91bnQpLnBsdXMoZmVlKS50b1N0cmluZygpO1xuXG5cdGV4cG9ydCBsZXQgbWVtbzogc3RyaW5nO1xuXG5cdGxldCB4X3dvcnRoID0gMDtcblxuXHQoYXN5bmMoZmtfcmVzb2x2ZSkgPT4ge1xuXHRcdGNvbnN0IHNpX2NvaW5nZWNrbyA9IGdfY29pbi5leHRyYT8uY29pbmdlY2tvX2lkIHx8ICcnO1xuXG5cdFx0aWYoc2lfY29pbmdlY2tvKSB7XG5cdFx0XHRjb25zdCBoX3ZlcnN1cyA9IGF3YWl0IENvaW5HZWNrby5jb2luc1ZlcnN1cyhbc2lfY29pbmdlY2tvXSwgJ3VzZCcsIDApO1xuXHRcdFx0eF93b3J0aCA9IGhfdmVyc3VzW3NpX2NvaW5nZWNrb107XG5cdFx0fVxuXHR9KSgpO1xuXG5cdChhc3luYygpID0+IHtcblx0XHRjb25zdCBrc19hY2NvdW50cyA9IGF3YWl0IEFjY291bnRzLnJlYWQoKTtcblxuXHRcdGdfYWNjb3VudCA9IGtzX2FjY291bnRzLmF0KGFjY291bnRSZWYpITtcblx0XHRzYV9zZW5kZXIgPSBDaGFpbnMuYWRkcmVzc0ZvcihnX2FjY291bnQucHVia2V5KTtcblxuXHRcdGNvbnN0IHBfY29udGFjdCA9IEFnZW50cy5wYXRoRm9yQ29udGFjdChzYV9yZWNpcGllbnQpO1xuXHRcdGdfY29udGFjdCA9IGF3YWl0IEFnZW50cy5nZXRDb250YWN0KHBfY29udGFjdCk7XG5cblx0XHRzX3JlY2lwaWVudF90aXRsZSA9IGdfY29udGFjdD8ubmFtZSB8fCAnJztcblx0fSkoKTtcblxuXHRhc3luYyBmdW5jdGlvbiBhcHByb3ZlKCkge1xuXHRcdGNvbnN0IHhnX2Ftb3VudCA9IEJpZ0ludChuZXcgQmlnTnVtYmVyKHNfYW1vdW50KS5zaGlmdGVkQnkoZ19jb2luLmRlY2ltYWxzKS50b1N0cmluZygpKTtcblxuXHRcdGNvbnN0IGdfYXR0ZW1wdCA9IGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5iYW5rU2VuZChzYV9zZW5kZXIsIHNhX3JlY2lwaWVudCwgc2lfY29pbiwgeGdfYW1vdW50LCBtZW1vKTtcblxuXHRcdC8vIHByZXBlbmQgcGVuZGluZyBldmVudCB0byBldmVudHMgc3RvcmVcblx0XHRhd2FpdCBFdmVudHMuaW5zZXJ0KHtcblx0XHRcdHR5cGU6ICdwZW5kaW5nJyxcblx0XHRcdHRpbWU6IERhdGUubm93KCksXG5cdFx0XHRkYXRhOiBnX2F0dGVtcHQsXG5cdFx0fSk7XG5cblx0XHQvLyByZXNldCBwYWdlXG5cdFx0a19wYWdlLnJlc2V0KCk7XG5cblx0XHQvLyBhY3RpdmF0ZSBoaXN0b3J5IHRocmVhZFxuXHRcdHZvaWQgJHl3X25hdmlnYXRvci5hY3RpdmF0ZVRocmVhZChUaHJlYWRJZC5ISVNUT1JZKTtcblx0fVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LnRpdGxlIHtcblxuXHR9XG5cblx0LnN1YnRpdGxlIHtcblx0XHQuZm9udCh0aW55KTtcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHR9XG5cblx0LmVtcHR5LW1lbW8ge1xuXHRcdC5mb250KHRpbnkpO1xuXHRcdGZvbnQtc3R5bGU6IGl0YWxpYztcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHR9XG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdTZW5kTmF0aXZlJyBzbGlkZXM+XG5cdDxIZWFkZXIgcG9wcyBleGl0c1xuXHRcdG9uOmNsb3NlPXsoKSA9PiBrX3BhZ2UucmVzZXQoKX1cblx0XHR0aXRsZT0nU2VuZGluZydcblx0XHRzeW1ib2w9e3NpX2NvaW59XG5cdFx0c3VidGl0bGU9eyR5d19jaGFpbi5uYW1lfVxuXHQvPlxuXG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0nc2VuZGVyJ1xuXHRcdG5hbWU9J0Zyb20nXG5cdD5cblx0XHQ8ZGl2IGNsYXNzPVwidGl0bGVcIj5cblx0XHRcdHtnX2FjY291bnQ/Lm5hbWUgfHwgJ1suLi5dJ31cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0e2dfYWNjb3VudD8uZXh0cmE/LnRvdGFsX2ZpYXRfY2FjaGUgfHwgJyg/KSd9XG5cdFx0PC9kaXY+XG5cdDwvRmllbGQ+XG5cblx0PGhyPlxuXG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0ncmVjaXBpZW50J1xuXHRcdG5hbWU9J1RvJ1xuXHQ+XG5cdFx0PGRpdiBjbGFzcz1cInRpdGxlXCI+XG5cdFx0XHR7c19yZWNpcGllbnRfdGl0bGUgfHwgJ1suLi5dJ31cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0PEFkZHJlc3MgYWRkcmVzcz17c2FfcmVjaXBpZW50fSAvPlxuXHRcdDwvZGl2PlxuXHQ8L0ZpZWxkPlxuXG5cdDxocj5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2Ftb3VudCdcblx0XHRuYW1lPSdBbW91bnQnXG5cdD5cblx0XHQ8ZGl2IGNsYXNzPVwidGl0bGVcIj5cblx0XHRcdHtzX2Ftb3VudH0ge3NpX2NvaW59XG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwic3VidGl0bGVcIj5cblx0XHRcdHsjaWYgeF93b3J0aH1cblx0XHRcdFx0e2Zvcm1hdF9maWF0KG5ldyBCaWdOdW1iZXIoc19hbW91bnQpLnRpbWVzKHhfd29ydGgpLnRvTnVtYmVyKCkpfVxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ9Wy4uLl1cblx0XHRcdHsvaWZ9XG5cdFx0PC9kaXY+XG5cdDwvRmllbGQ+XG5cblx0PGhyPlxuXHRcblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdmZWUtcmV2aWV3J1xuXHRcdG5hbWU9J0ZlZSdcblx0PlxuXHRcdDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxuXHRcdFx0e3NfZmVlfSB7c2lfY29pbn1cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0eyNpZiB4X3dvcnRofVxuXHRcdFx0XHR7Zm9ybWF0X2ZpYXQobmV3IEJpZ051bWJlcihzX2ZlZSkudGltZXMoeF93b3J0aCkudG9OdW1iZXIoKSl9XG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdD1bLi4uXVxuXHRcdFx0ey9pZn1cblx0XHQ8L2Rpdj5cblx0PC9GaWVsZD5cblxuXHQ8aHI+XG5cdFxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J3RvdGFsJ1xuXHRcdG5hbWU9J1RvdGFsJ1xuXHQ+XG5cdFx0PGRpdiBjbGFzcz1cInRpdGxlXCI+XG5cdFx0XHR7c190b3RhbCB8fCAnWy4uLl0nfSB7c2lfY29pbn1cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0eyNpZiB4X3dvcnRofVxuXHRcdFx0XHR7Zm9ybWF0X2ZpYXQobmV3IEJpZ051bWJlcihzX3RvdGFsKS50aW1lcyh4X3dvcnRoKS50b051bWJlcigpKX1cblx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0PVsuLi5dXG5cdFx0XHR7L2lmfVxuXHRcdDwvZGl2PlxuXHQ8L0ZpZWxkPlxuXG5cdDxocj5cblx0XG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0nbWVtbydcblx0XHRuYW1lPSdNZW1vJ1xuXHQ+XG5cdFx0eyNpZiBtZW1vfVxuXHRcdFx0PHRleHRhcmVhIGRpc2FibGVkPnttZW1vfTwvdGV4dGFyZWE+XG5cdFx0ezplbHNlfVxuXHRcdFx0PHNwYW4gY2xhc3M9XCJlbXB0eS1tZW1vXCI+KGVtcHR5KTwvc3Bhbj5cblx0XHR7L2lmfVxuXHQ8L0ZpZWxkPlxuXG5cblx0PEFjdGlvbnNMaW5lIGJhY2sgY29uZmlybT17WydBcHByb3ZlJywgKCkgPT4gYXBwcm92ZSgpXX0gLz5cblxuPC9TY3JlZW4+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0LCBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblxuXHRpbXBvcnQge1xuXHRcdHl3X2FjY291bnQsXG5cdFx0eXdfYWNjb3VudF9yZWYsXG5cdFx0eXdfY2hhaW4sXG5cdFx0eXdfY2hhaW5fcmVmLFxuXHRcdHl3X25ldHdvcmtfYWN0aXZlLFxuXHRcdHl3X293bmVyLFxuXHRcdHl3X3NlbmRfYXNzZXQsXG5cdFx0Ly8geXdfYXNzZXRfc2VuZCxcblx0XHQvLyB5d19ob2xkaW5nX3NlbmQsXG5cdH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgU1hfSUNPTl9QRVJTT05BTCBmcm9tICcjL2ljb24vYWNjb3VudF9ib3guc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NPTlRSQUNUIGZyb20gJyMvaWNvbi9hbmFseXRpY3Muc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0xPQURJTkcgZnJvbSAnIy9pY29uL2RvbnV0X2xhcmdlLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9JTkZPIGZyb20gJyMvaWNvbi9pbmZvLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9EUk9QRE9XTiBmcm9tICcjL2ljb24vZHJvcC1kb3duLnN2Zz9yYXcnO1xuXG5cdGltcG9ydCBBc3NldFNlbGVjdCBmcm9tICcjIy91aS9Bc3NldFNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgQW1vdW50SW5wdXQgZnJvbSAnIyMvdWkvQW1vdW50SW5wdXQuc3ZlbHRlJztcblx0aW1wb3J0IENoZWNrYm94RmllbGQgZnJvbSAnIyMvdWkvQ2hlY2tib3hGaWVsZC5zdmVsdGUnO1xuXHRpbXBvcnQgSGVhZGVyIGZyb20gJyMjL3VpL0hlYWRlci5zdmVsdGUnO1xuXHRpbXBvcnQgRmllbGQgZnJvbSAnIyMvdWkvRmllbGQuc3ZlbHRlJztcblxuXHQvLyBpbXBvcnQgRXhlY3V0ZSBmcm9tICcuL0V4ZWN1dGUuc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBBY2NvdW50LCBBY2NvdW50UGF0aCB9IGZyb20gJyMvbWV0YS9hY2NvdW50JztcblxuXHRpbXBvcnQgeyBTY3JlZW4sIHR5cGUgUGFnZSB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgdHlwZSB7IFRva2VuIH0gZnJvbSAnIy9tZXRhL3Rva2VuJztcblx0aW1wb3J0IHsgRW50aXRpZXMgfSBmcm9tICcjL3N0b3JlL2VudGl0aWVzJztcblx0aW1wb3J0IFNlbmRlclNlbGVjdCBmcm9tICcuLi91aS9TZW5kZXJTZWxlY3Quc3ZlbHRlJztcblx0aW1wb3J0IFJlY2lwaWVudFNlbGVjdCBmcm9tICcuLi91aS9SZWNpcGllbnRTZWxlY3Quc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBDaGFpbiwgRW50aXR5UGF0aCwgTmF0aXZlQ29pbiB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdCwgQ29udGFjdFBhdGggfSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cdGltcG9ydCB7IHN1YnNjcmliZV9zdG9yZSB9IGZyb20gJyMvc3RvcmUvX2Jhc2UnO1xuXHRpbXBvcnQgeyBBZ2VudHMgfSBmcm9tICcjL3N0b3JlL2FnZW50cyc7XG5cdGltcG9ydCB7IGZvbGQsIG9mZSB9IGZyb20gJyMvdXRpbC9iZWx0Jztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBDb2luR2Vja28gfSBmcm9tICcjL3N0b3JlL3dlYi1hcGlzJztcblx0aW1wb3J0IHsgZm9ybWF0X2Ftb3VudCwgZm9ybWF0X2ZpYXQgfSBmcm9tICcjL3V0aWwvZm9ybWF0Jztcblx0aW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuXHRpbXBvcnQgeyBYVF9NSU5VVEVTIH0gZnJvbSAnIy9zaGFyZS9jb25zdGFudHMnO1xuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcbmltcG9ydCBTZW5kTmF0aXZlIGZyb20gJy4vU2VuZE5hdGl2ZS5zdmVsdGUnO1xuXG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8qKlxuXHQgKiBXaGljaCBhY2NvdW50IHRvIGluaXRpYXRlIHNlbmQgZnJvbVxuXHQgKi9cblx0ZXhwb3J0IGxldCBzZW5kZXI6IEFjY291bnRbJ2ludGVyZmFjZSddID0gJHl3X2FjY291bnQ7XG5cdGxldCBwX2FjY291bnQ6IEFjY291bnRQYXRoID0gJHl3X2FjY291bnRfcmVmO1xuXG5cdC8qKlxuXHQgKiBOYXRpdmUgY29pbiBzeW1ib2wgdG8gdXNlIGZvciB0aGUgdHJhbnNmZXJcblx0ICovXG5cdGV4cG9ydCBsZXQgbmF0aXZlOiBrZXlvZiB0eXBlb2YgJHl3X2NoYWluLmNvaW5zID0gT2JqZWN0LmtleXMoJHl3X2NoYWluLmNvaW5zKVswXTtcblx0bGV0IHNpX25hdGl2ZSA9IG5hdGl2ZTtcblxuXHQvKipcblx0ICogVG9rZW4gdG8gdXNlIGZvciB0cmFuc2ZlciAoaW5zdGVhZCBvZiBuYXRpdmUgY29pbilcblx0ICovXG5cdGV4cG9ydCBsZXQgdG9rZW46IFRva2VuWydpbnRlcmZhY2UnXSB8IG51bGwgPSBudWxsO1xuXHRsZXQgZ190b2tlbiA9IHRva2VuO1xuXG5cblx0LyoqXG5cdCAqIEFkZHJlc3Mgb2YgaW5pdGlhbCByZWNlaXZlclxuXHQgKi9cblx0ZXhwb3J0IGxldCByZWNpcGllbnQgPSAnJztcblx0bGV0IHNhX3JlY2lwaWVudCA9IHJlY2lwaWVudDtcblxuXG5cdGxldCBwX2Fzc2V0OiBFbnRpdHlQYXRoIHwgJycgPSBzaV9uYXRpdmVcblx0XHQ/IEVudGl0aWVzLmhvbGRpbmdQYXRoRm9yKCR5d19vd25lciwgc2lfbmF0aXZlKVxuXHRcdDogJyc7XG5cdFx0Ly8gOiBFbnRpdGllcy5wYXRoRnJvbShnX3Rva2VuKTtcblxuXG5cdC8vIHJlYWN0aXZlbHkgYXNzaWduIHRoZSBjb2luIHN0cnVjdCBmb3IgdGhlIG5hdGl2ZSBhc3NldFxuXHQkOiBnX2NvaW4gPSBwX2Fzc2V0ICYmICdob2xkaW5nJyA9PT0gRW50aXRpZXMucGFyc2VFbnRpdHlQYXRoKHBfYXNzZXQpPy50eXBlICYmIHNpX25hdGl2ZT8gJHl3X2NoYWluLmNvaW5zPy5bc2lfbmF0aXZlXTogbnVsbDtcblx0XG5cdC8vIHJlYWN0aXZlbHkgYXNzaWduIHRoZSB0b2tlbidzIHBhdGhcblx0JDogcF90b2tlbiA9IHBfYXNzZXQgJiYgJ3Rva2VuJyA9PT0gRW50aXRpZXMucGFyc2VFbnRpdHlQYXRoKHBfYXNzZXQpPy50eXBlICYmIGdfdG9rZW4/IEVudGl0aWVzLnBhdGhGcm9tKGdfdG9rZW4pOiAnJztcblxuXG5cdC8vIGNhY2hlIG9mIGNvbnRhY3RzXG5cdGxldCBoX2NvbnRhY3RzOiBSZWNvcmQ8Q29udGFjdFBhdGgsIENvbnRhY3RbJ2ludGVyZmFjZSddPjtcblxuXHQvLyBhZGRyZXNzIHRvIGNvbnRhY3QgbG9va3VwIGNhY2hlXG5cdGxldCBoX2FkZHJfdG9fY29udGFjdDogUmVjb3JkPENoYWluLkJlY2gzMlN0cmluZywgQ29udGFjdFBhdGg+O1xuXG5cdC8vIGFzc2V0IHN5bWJvbFxuXHQkOiBzX3N5bWJvbCA9IHNpX25hdGl2ZSB8fCBnX3Rva2VuPy5zeW1ib2wgfHwgJyc7XG5cblxuXG5cblx0bGV0IGJfYnVzeV9hZ2VudHMgPSBmYWxzZTtcblx0YXN5bmMgZnVuY3Rpb24gcmVsb2FkX2FnZW50cyhiX2luaXQ9ZmFsc2UpIHtcblx0XHQvLyBhbHJlYWR5IGJ1c3kgcmVsb2FkaW5nXG5cdFx0aWYoYl9idXN5X2FnZW50cykgcmV0dXJuO1xuXG5cdFx0Ly8gbm93IGl0J3MgYnVzeVxuXHRcdGJfYnVzeV9hZ2VudHMgPSB0cnVlO1xuXG5cdFx0Ly8gbG9hZCBhZ2VudHMgc3RvcmVcblx0XHRjb25zdCBrc19hZ2VudHMgPSBhd2FpdCBBZ2VudHMucmVhZCgpO1xuXG5cdFx0Ly8gcmVhZCBjb250YWN0IGVudHJpZXNcblx0XHRjb25zdCBhX2NvbnRhY3RzID0gWy4uLmtzX2FnZW50cy5jb250YWN0cygpXTtcblxuXHRcdC8vIHJlcGxhY2UgY2FjaGVcblx0XHRoX2NvbnRhY3RzID0gb2ZlKGFfY29udGFjdHMpO1xuXG5cdFx0Ly8gcmVwbGFjZSBhZGRyZXNzIGxvb2t1cCBjYWNoZVxuXHRcdGhfYWRkcl90b19jb250YWN0ID0gZm9sZChhX2NvbnRhY3RzLCAoW3BfY29udGFjdCwgZ19jb250YWN0XSkgPT4gKHtcblx0XHRcdFtDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKV06IHBfY29udGFjdCxcblx0XHR9KSk7XG5cblx0XHQvLyBubyBsb25nZXIgYnVzeVxuXHRcdGJfYnVzeV9hZ2VudHMgPSBmYWxzZTtcblx0fVxuXG5cdC8vIHN1YnNjcmlwdGlvbnNcblx0e1xuXHRcdC8vIHJlbG9hZCBhZ2VudHMgd2hlbiBhZ2VudHMgc3RvcmUgdXBkYXRlc1xuXHRcdGNvbnN0IGZfdW5zdWJfYWdlbnRzID0gc3Vic2NyaWJlX3N0b3JlKCdhZ2VudHMnLCByZWxvYWRfYWdlbnRzKTtcblxuXHRcdC8vIHJlbG9hZCBhZ2VudHMgd2hlbiBjaGFpbiBjaGFuZ2VzXG5cdFx0Y29uc3QgZl91bnN1Yl9jaGFpbiA9IHl3X2NoYWluLnN1YnNjcmliZShyZWxvYWRfYWdlbnRzIGFzIFZvaWRGdW5jdGlvbik7XG5cblx0XHQvLyB1bnN1YnNjcmliZSB3aGVuIHNjcmVlbiBpcyBkZXN0cm95ZWRcblx0XHRvbkRlc3Ryb3koKCkgPT4ge1xuXHRcdFx0Zl91bnN1Yl9hZ2VudHMoKTtcblx0XHRcdGZfdW5zdWJfY2hhaW4oKTtcblx0XHR9KTtcblx0fVxuXG5cdCQ6IHtcblx0XHRjb25zb2xlLmxvZyh7XG5cdFx0XHRzaV9uYXRpdmUsXG5cdFx0XHRnX2NvaW4sXG5cdFx0XHRwX2Fzc2V0LFxuXHRcdFx0cF90b2tlbixcblx0XHRcdGdfdG9rZW4sXG5cdFx0fSk7XG5cdH1cblxuXHQvLyByZWFjdGl2ZWx5IGNvbXB1dGUgdGhlIGJhbGFuY2Ugb2YgdGhlIHNlbGVjdGVkIGFzc2V0XG5cdGxldCB5Z19iYWxhbmNlOiBCaWdOdW1iZXIgfCBudWxsID0gbnVsbDtcblx0JDogc19iYWxhbmNlID0geWdfYmFsYW5jZT8gZm9ybWF0X2Ftb3VudCh5Z19iYWxhbmNlLnNoaWZ0ZWRCeSgtKGdfY29pbiB8fCBnX3Rva2VuKSEuZGVjaW1hbHMpLnRvTnVtYmVyKCkpOiAnJztcblx0JDoge1xuXHRcdC8vIHJlYWN0IHRvIGFjY291bnQgYW5kIGFzc2V0IGNoYW5nZXNcblx0XHRpZigkeXdfYWNjb3VudCAmJiBwX2Fzc2V0KSB7XG5cdFx0XHR5Z19iYWxhbmNlID0gbnVsbDtcblxuXHRcdFx0Ly8gZ28gYXN5bmNcblx0XHRcdHF1ZXVlTWljcm90YXNrKGFzeW5jKCkgPT4ge1xuXHRcdFx0XHQvLyBpbmRpY2F0ZSBsb2FkaW5nIHN0YXRlXG5cdFx0XHRcdHNfYmFsYW5jZSA9ICdbLi4uXSc7XG5cblx0XHRcdFx0Ly8gc3RhcnQgd2l0aCB0aGUgY2FjaGVkIGJhbGFuY2UgaWYgaXQgZXhpc3RzXG5cdFx0XHRcdGNvbnN0IGdfY2FjaGVkID0gJHl3X25ldHdvcmtfYWN0aXZlLmNhY2hlZEJhbGFuY2UoJHl3X293bmVyLCBzaV9uYXRpdmUpO1xuXHRcdFx0XHRpZihnX2NhY2hlZCAmJiBnX2NhY2hlZC50aW1lc3RhbXAgPiBEYXRlLm5vdygpIC0gKDUgKiBYVF9NSU5VVEVTKSkge1xuXHRcdFx0XHRcdHlnX2JhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKGdfY2FjaGVkLmRhdGEuYW1vdW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGdldCB0aGUgbGF0ZXN0IGJhbGFuY2Vcblx0XHRcdFx0Y29uc3QgZ19idW5kbGUgPSBhd2FpdCAkeXdfbmV0d29ya19hY3RpdmUuYmFua0JhbGFuY2UoJHl3X293bmVyLCBzaV9uYXRpdmUpO1xuXHRcdFx0XHRpZihnX2J1bmRsZSkge1xuXHRcdFx0XHRcdHlnX2JhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKGdfYnVuZGxlLmJhbGFuY2UuYW1vdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBpbnB1dCBhbW91bnQgdXNlciBpbnRlbmRzIHRvIHNlbmRcblx0bGV0IHNfYW1vdW50ID0gJyc7XG5cblx0Ly8gYXBwbHkgdGhlIG1heGltdW0gYW1vdW50IHRoZSB1c2VyIGNhbiBwb3NzaWJseSBzZW5kXG5cdGZ1bmN0aW9uIHVzZV9tYXgoKSB7XG5cdFx0c19hbW91bnQgPSBzX2JhbGFuY2U7XG5cblx0XHQvLyB0YWtlIGF3YXkgZnJvbSBnYXMgZmVlXG5cdFx0aWYoZ19jb2luKSB7XG5cdFx0XHRzX2Ftb3VudCA9IG5ldyBCaWdOdW1iZXIoc19hbW91bnQpLm1pbnVzKHhfZmVlKS50b1N0cmluZygpO1xuXHRcdH1cblxuXHRcdGNfc2hvd192YWxpZGF0aW9ucysrO1xuXHR9XG5cblx0Ly8gcmVhY3RpdmVseSBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBtYXggaXMgY3VycmVudGx5IGJlaW5nIHVzZWRcblx0JDogYl91c2luZ19tYXggPSBzX2Ftb3VudCA9PT0gc19iYWxhbmNlO1xuXG5cdC8vICQ6IHtcblx0Ly8gXHRpZihnX3Rva2VuICYmIEVudGl0aWVzLnBhdGhGcm9tKGdfdG8pICE9PSBwX2VudGl0eSkge1xuXHQvLyBcdFx0c19hbW91bnQgPSAnJztcblx0Ly8gXHRcdGNfc2hvd192YWxpZGF0aW9ucyA9IDA7XG5cdC8vIFx0XHRwX2VudGl0eSA9IGdfdG9rZW4uaXJpO1xuXHQvLyBcdH1cblx0Ly8gfVxuXG5cblxuXHQvLyByZWFjdGl2ZWx5IGFzc2lnbiB0aGUgY29pbmdlY2tvIGlkIGZyb20gdGhlIGFzc2V0IHN0cnVjdFxuXHQkOiBzaV9jb2luZ2Vja28gPSAoZ190b2tlbiB8fCBnX2NvaW4pPy5leHRyYT8uY29pbmdlY2tvX2lkIHx8ICcnO1xuXG5cdC8vIHJlYWN0aXZlbHkgZmV0Y2ggdGhlIHdvcnRoIG9mIHRoZSBhc3NldFxuXHRsZXQgeF93b3J0aDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cdGxldCBzX3dvcnRoID0gJyc7XG5cdGNvbnN0IHNpX3ZlcnN1cyA9ICd1c2QnO1xuXHQkOiB7XG5cdFx0Ly8gY29pbmdlY2tvIGlkIGlzIHNldFxuXHRcdGlmKHNpX2NvaW5nZWNrbykge1xuXHRcdFx0Ly8gaW5kaWNhdGUgbG9hZGluZyBzdGF0ZVxuXHRcdFx0c193b3J0aCA9ICdbLi4uXSc7XG5cblx0XHRcdC8vIGdvIGFzeW5jXG5cdFx0XHQoYXN5bmMoKSA9PiB7XG5cdFx0XHRcdC8vIGxvYWQgdGhlIGFzc2V0J3Mgd29ydGggZnJvbSBjb2luZ2Vja29cblx0XHRcdFx0Y29uc3QgaF92ZXJzdXMgPSBhd2FpdCBDb2luR2Vja28uY29pbnNWZXJzdXMoW3NpX2NvaW5nZWNrb10gYXMgc3RyaW5nW10sIHNpX3ZlcnN1cyk7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBmaWF0IGRpc3BsYXlcblx0XHRcdFx0eF93b3J0aCA9IGhfdmVyc3VzW3NpX2NvaW5nZWNrb107XG5cdFx0XHRcdGlmKCdudW1iZXInID09PSB0eXBlb2YgeF93b3J0aCkge1xuXHRcdFx0XHRcdHNfd29ydGggPSBmb3JtYXRfZmlhdCh4X3dvcnRoLCBzaV92ZXJzdXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNldCBlcnJvciBpbmRpY2F0aW9uXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHNfd29ydGggPSAnKD8pJztcblx0XHRcdFx0fVxuXHRcdFx0fSkoKTtcblx0XHR9XG5cdFx0Ly8gZG9uJ3QgZGlzcGxheSBhbnl0aGluZ1xuXHRcdGVsc2Uge1xuXHRcdFx0c193b3J0aCA9ICcnO1xuXHRcdH1cblx0fVxuXG5cblx0bGV0IHhfZmVlID0gMC4wMTtcblx0XG5cdCQ6IHNfZmVlX2ZpYXQgPSAnbnVtYmVyJyA9PT0gdHlwZW9mIHhfd29ydGg/IGZvcm1hdF9maWF0KHhfZmVlICogeF93b3J0aCwgJ3VzZCcpOiAnJztcblxuXHRcblx0XG5cdC8vIC8vIFxuXHQvLyBpZigkeXdfYXNzZXRfc2VuZCkge1xuXHQvLyBcdCR5d19jaGFpbl9yZWYgPSAkeXdfYXNzZXRfc2VuZC5jaGFpblJlZjtcblx0Ly8gfVxuXG5cdGNvbnN0IEhfQUREUkVTU19UWVBFUyA9IHtcblx0XHRub25lOiB7XG5cdFx0XHRpY29uOiAnPHN2Zz48L3N2Zz4nLFxuXHRcdFx0dGV4dDogJycsXG5cdFx0fSxcblxuXHRcdHVua25vd246IHtcblx0XHRcdGljb246IFNYX0lDT05fTE9BRElORyxcblx0XHRcdHRleHQ6ICdEZXRlcm1pbmluZyBhZGRyZXNzIHR5cGUuLi4nLFxuXHRcdH0sXG5cblx0XHRwZXJzb25hbDoge1xuXHRcdFx0aWNvbjogU1hfSUNPTl9QRVJTT05BTCxcblx0XHRcdHRleHQ6ICdQZXJzb25hbCBhZGRyZXNzJyxcblx0XHR9LFxuXG5cdFx0Y29udHJhY3Q6IHtcblx0XHRcdGljb246IFNYX0lDT05fQ09OVFJBQ1QsXG5cdFx0XHR0ZXh0OiAnQ29udHJhY3QgYWRkcmVzcycsXG5cdFx0fSxcblx0fSBhcyBjb25zdDtcblxuXHRsZXQgc2lfYWRkcmVzc190eXBlOiBrZXlvZiB0eXBlb2YgSF9BRERSRVNTX1RZUEVTID0gJ25vbmUnO1xuXHQkOiBnX2FkZHJlc3NfdHlwZSA9IEhfQUREUkVTU19UWVBFU1tzaV9hZGRyZXNzX3R5cGVdO1xuXG5cblxuXHQkOiB7XG5cdFx0aWYoIXNhX3JlY2lwaWVudCkge1xuXHRcdFx0c2lfYWRkcmVzc190eXBlID0gJ25vbmUnO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHNpX2FkZHJlc3NfdHlwZSA9ICd1bmtub3duJztcblxuXHRcdFx0KGFzeW5jKCkgPT4ge1xuXHRcdFx0XHRpZihhd2FpdCAkeXdfbmV0d29ya19hY3RpdmUuaXNDb250cmFjdChzYV9yZWNpcGllbnQpKSB7XG5cdFx0XHRcdFx0c2lfYWRkcmVzc190eXBlID0gJ2NvbnRyYWN0Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzaV9hZGRyZXNzX3R5cGUgPSAncGVyc29uYWwnO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSgpO1xuXHRcdH1cblx0fVxuXG5cblxuXG5cdGxldCBiX21lbW9fZXhwYW5kZWQgPSBmYWxzZTtcblx0bGV0IHNfbWVtbyA9ICcnO1xuXG5cdGxldCBiX3N1Ym1pdHRlZCA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIHN1Ym1pdCgpIHtcblx0XHRpZighYl9mb3JtX3ZhbGlkKSB7XG5cdFx0XHRjX3Nob3dfdmFsaWRhdGlvbnMrKztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZihiX3N1Ym1pdHRlZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRiX3N1Ym1pdHRlZCA9IHRydWU7XG5cblx0XHRcdGlmKHNpX25hdGl2ZSkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogU2VuZE5hdGl2ZSxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0YWNjb3VudFJlZjogcF9hY2NvdW50LFxuXHRcdFx0XHRcdFx0Y29pbjogc2lfbmF0aXZlLFxuXHRcdFx0XHRcdFx0cmVjaXBpZW50OiBzYV9yZWNpcGllbnQsXG5cdFx0XHRcdFx0XHRhbW91bnQ6IHNfYW1vdW50LFxuXHRcdFx0XHRcdFx0bWVtbzogc19tZW1vLFxuXHRcdFx0XHRcdFx0ZmVlOiB4X2ZlZSsnJyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBrX3BhZ2UucHVzeXdfc2VuZF9hc3NldFxuXHRcdFx0XHQvLyBcdGNyZWF0b3I6IEV4ZWN1dGUsXG5cdFx0XHRcdC8vIFx0cHJvcHM6IHtcblx0XHRcdFx0Ly8gXHRcdGNvbnRyYWN0OiAkeXdfYXNzZXRfc2VuZD8uYWRkcmVzcyxcblx0XHRcdFx0Ly8gXHRcdHNuaXAyMDogeXdfc2VuZF9hc3NldFxuXHRcdFx0XHQvLyBcdFx0XHR0cmFuc2Zlcjoge1xuXHRcdFx0XHQvLyBcdFx0XHRcdHJlY2lwaWVudDogc2FfcmVjZWl2ZXIsXG5cdFx0XHRcdC8vIFx0XHRcdFx0YW1vdW50OiAkeXdfYXNzZXRfc2VuZD8uZGVub21Gcm9tU3RyaW5nKHNfYW1vdW50KSB8fCAnMCcsXG5cdFx0XHRcdC8vIFx0XHRcdH0sXG5cdFx0XHRcdC8vIFx0XHR9LFxuXHRcdFx0XHQvLyBcdH0sXG5cdFx0XHRcdC8vIH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGxldCBjX3Nob3dfdmFsaWRhdGlvbnMgPSAwO1xuXG5cdGxldCBiX2NoZWNrZWRfc2F2ZV9jb250YWN0ID0gZmFsc2U7XG5cdGxldCBiX2RlYWQgPSBmYWxzZTtcblxuXG5cdGxldCBzX2Vycl9yZWNpcGllbnQgPSAnJztcblx0bGV0IHNfZXJyX2Ftb3VudCA9ICcnO1xuXG5cdCQ6IGJfbmV3X2FkZHJlc3MgPSBzYV9yZWNpcGllbnQgJiYgaF9hZGRyX3RvX2NvbnRhY3QgJiYgIShzYV9yZWNpcGllbnQgaW4gaF9hZGRyX3RvX2NvbnRhY3QpO1xuXG5cblx0Y29uc3QgUl9DT05UQUNUX05BTUUgPSAvXlxcUy57MCwxMDIzfSQvO1xuXHRcblx0bGV0IHNfbmV3X2NvbnRhY3QgPSAnJztcblx0JDogc19lcnJfbmV3X2NvbnRhY3QgPSBiX2NoZWNrZWRfc2F2ZV9jb250YWN0ICYmIChjX3Nob3dfdmFsaWRhdGlvbnMgfHwgdHJ1ZSlcblx0XHQ/IHNfbmV3X2NvbnRhY3Rcblx0XHRcdD8gUl9DT05UQUNUX05BTUUudGVzdChzX25ld19jb250YWN0KVxuXHRcdFx0XHQ/ICcnXG5cdFx0XHRcdDogc19uZXdfY29udGFjdC5sZW5ndGggPiAxMDI0XG5cdFx0XHRcdFx0PyAnVGhhdCBuYW1lIGlzIHdheSB0b28gbG9uZydcblx0XHRcdFx0XHQ6ICdDYW5ub3QgYmVnaW4gd2l0aCBzcGFjZSdcblx0XHRcdDogJ0VudGVyIGEgY29udGFjdCBuYW1lIHRvIHNhdmUgbmV3IGFkZHJlc3MnXG5cdFx0OiAnJztcblxuXHQkOiB7XG5cdFx0aWYoYl9jaGVja2VkX3NhdmVfY29udGFjdCAmJiAhY19zaG93X3ZhbGlkYXRpb25zKSB7XG5cdFx0XHRzX2Vycl9uZXdfY29udGFjdCA9ICcnO1xuXHRcdH1cblx0fVxuXG5cdCQ6IGJfZm9ybV92YWxpZCA9IChzYV9yZWNpcGllbnRcblx0XHQmJiBzX2Ftb3VudFxuXHRcdCYmICFzX2Vycl9yZWNpcGllbnRcblx0XHQmJiAhc19lcnJfYW1vdW50XG5cdFx0JiYgKCFiX25ld19hZGRyZXNzIHx8ICFiX2NoZWNrZWRfc2F2ZV9jb250YWN0IHx8IChzX25ld19jb250YWN0ICYmICFzX2Vycl9uZXdfY29udGFjdCkpXG5cdCkgfHwgZmFsc2U7XG5cblx0JDoge1xuXHRcdGNvbnNvbGUubG9nKHtcblx0XHRcdHRvOiBzYV9yZWNpcGllbnQsXG5cdFx0XHRzX2Ftb3VudCxcblx0XHRcdHNfZXJyX3JlY2lwaWVudCxcblx0XHRcdHNfZXJyX2Ftb3VudCxcblx0XHR9KTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gaW5wdXRfbmV3X2NvbnRhY3QoZF9ldmVudDogRXZlbnQpIHtcblx0XHRzX25ld19jb250YWN0ID0gKGRfZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xuXHR9XG48L3NjcmlwdD5cblxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnX2Jhc2UubGVzcyc7XG5cblx0QGtleWZyYW1lcyBzcGluIHtcblx0XHRmcm9tIHtcblx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuXHRcdH1cblx0XHR0byB7XG5cdFx0XHR0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuXHRcdH1cblx0fVxuXG5cdCNmaWVsZC1yZWNpcGllbnQtc3RhdHVzIHtcblx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdG1hcmdpbi10b3A6IC0xMnB4O1xuXHRcdFx0cGFkZGluZy1sZWZ0OiA2cHg7XG5cdFx0fVxuXG5cdFx0LnN0YXR1cyB7XG5cdFx0XHQ6Z2xvYmFsKCYudW5rbm93bj4uaWNvbikge1xuXHRcdFx0XHRhbmltYXRpb246IHNwaW4gMXMgbGluZWFyIGluZmluaXRlO1xuXHRcdFx0fVxuXHRcdFx0Omdsb2JhbCgmLmNvbnRyYWN0Pi5pY29uKSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcblx0XHRcdH1cblx0XHRcdDpnbG9iYWwoJi5jb250cmFjdD4uaWNvbikge1xuXHRcdFx0XHR0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LnN0YXR1cyB7XG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWdyYXltZWQpO1xuXG5cdFx0Pioge1xuXHRcdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHR9XG5cblx0XHQ+Lmljb24ge1xuXHRcdFx0LS1wcm94eS1pY29uLWRpYW1ldGVyOiAyMHB4O1xuXHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ncmF5bWVkKTtcblxuXHRcdFx0Omdsb2JhbChzdmcpIHtcblx0XHRcdFx0d2lkdGg6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHRoZWlnaHQ6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdD4udGV4dCB7XG5cdFx0XHQuZm9udCh0aW55KTtcblx0XHR9XG5cdH1cblxuXG5cdCNmaWVsZC1iYWxhbmNlIHtcblx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdG1hcmdpbi10b3A6IC0xMnB4O1xuXHRcdH1cblx0fVxuXG5cdC5iYWxhbmNlLWxpbmUge1xuXHRcdC5mb250KHRpbnksIEBzaXplOiAxMnB4LCBAd2VpZ2h0OiAzMDApO1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXG5cdFx0Pi5iYWxhbmNlIHtcblx0XHRcdD4ubGFiZWwge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHQ+LmFtb3VudCB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQuZmVlLWZpYXQge1xuXHRcdC5mb250KHRpbnkpO1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdH1cblxuXHQjZmllbGQtZmVlIHtcblx0XHQuZmllbGQtdmFsdWUge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGZsZXg6IDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Lm1hbnVhbC1mZWUge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGZsZXg6IDI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0I2ZpZWxkLW1hbnVhbC1mZWUge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0bWFyZ2luLXRvcDogLTEycHg7XG5cdFx0fVxuXHR9XG5cblx0Lm1hbnVhbC1mZWUge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRnYXA6IDAuNWVtO1xuXG5cdFx0Pi5pY29uLmluZm8ge1xuXHRcdFx0LS1pY29uLWRpYW1ldGVyOiAxOHB4O1xuXHRcdFx0cGFkZGluZzogMnB4O1xuXHRcdH1cblx0fVxuXG5cdC5tZW1vIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0Z2FwOiAwLjc1ZW07XG5cblx0XHQudGl0bGUge1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGdhcDogNHB4O1xuXHRcdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdFx0XHQuaWNvbiB7XG5cdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjJweDtcblx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdH1cblx0XG5cdFx0XHQ+LmRpc2NsYWltZXIge1xuXHRcdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pO1xuXHRcdFx0XHRyaWdodDogMDtcblx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHRib3R0b206IDAuNWV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5kcm9wZG93bi5pY29uIHtcblx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuXHRcdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDMwMG1zIHZhcigtLWVhc2Utb3V0LXF1YWQpO1xuXHRcdH1cblxuXHRcdCYuZXhwYW5kZWQge1xuXHRcdFx0LmRyb3Bkb3duLmljb24ge1xuXHRcdFx0XHR0cmFuc2Zvcm06IHJvdGF0ZSgtMTgwZGVnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQuaW5wdXQge1xuXHRcdFx0dGV4dGFyZWEge1xuXHRcdFx0XHRyZXNpemU6IHZlcnRpY2FsO1xuXHRcdFx0XHRtaW4taGVpZ2h0OiAxMC43NWV4O1xuXHRcdFx0XHRtYXgtaGVpZ2h0OiA0MGV4O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC5uZXctYWRkcmVzcyB7XG5cdFx0bWFyZ2luLXRvcDogMTJweDtcblx0fVxuXG5cdC5kaXNhYmxlZC5saW5rIHtcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdGZvbnQtc3R5bGU6IGl0YWxpYztcblx0XHR0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaDtcblx0fVxuPC9zdHlsZT5cblxuXG48U2NyZWVuIGZvcm0gc2xpZGVzIG9uOnN1Ym1pdD17KGRfc3VibWl0KSA9PiB7XG5cdGRfc3VibWl0LnByZXZlbnREZWZhdWx0KCk7XG59fT5cblx0PEhlYWRlciBwb3BzXG5cdFx0dGl0bGU9e2dfdG9rZW4/ICdUcmFuc2ZlcnJpbmcnOiAnU2VuZGluZyd9XG5cdFx0c3ltYm9sPXtnX3Rva2VuPyBnX3Rva2VuLnN5bWJvbDogJyd9XG5cdFx0c3VidGl0bGU9eyR5d19jaGFpbj8ubmFtZSB8fCAnPyd9XG5cdC8+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdzZW5kZXItc2VsZWN0J1xuXHRcdG5hbWU9J0Zyb20nXG5cdD5cblx0XHQ8U2VuZGVyU2VsZWN0XG5cdFx0XHRiaW5kOmFjY291bnRSZWY9e3BfYWNjb3VudH1cblx0XHRcdC8+XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdyZWNpcGllbnQtc2VsZWN0J1xuXHRcdG5hbWU9J1RvJ1xuXHQ+XG5cdFx0PFJlY2lwaWVudFNlbGVjdFxuXHRcdFx0YmluZDplcnJvcj17c19lcnJfcmVjaXBpZW50fVxuXHRcdFx0YmluZDphZGRyZXNzPXtzYV9yZWNpcGllbnR9XG5cdFx0XHRzaG93VmFsaWRhdGlvbj17Y19zaG93X3ZhbGlkYXRpb25zfVxuXHRcdC8+XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdyZWNpcGllbnQtc3RhdHVzJ1xuXHRcdG5hbWU9Jydcblx0PlxuXHRcdDxzcGFuIGNsYXNzPVwic3RhdHVzIHtzaV9hZGRyZXNzX3R5cGV9XCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0e0BodG1sIGdfYWRkcmVzc190eXBlLmljb259XG5cdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0e2dfYWRkcmVzc190eXBlLnRleHR9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9zcGFuPlxuXG5cdFx0eyNpZiBiX25ld19hZGRyZXNzfVxuXHRcdFx0PGRpdiBjbGFzcz1cIm5ldy1hZGRyZXNzXCI+XG5cdFx0XHRcdDxDaGVja2JveEZpZWxkIGlkPVwic2F2ZS1jb250YWN0XCIgYmluZDpjaGVja2VkPXtiX2NoZWNrZWRfc2F2ZV9jb250YWN0fSA+XG5cdFx0XHRcdFx0U2F2ZSB0byBjb250YWN0c1xuXHRcdFx0XHQ8L0NoZWNrYm94RmllbGQ+XG5cdFx0XHQ8L2Rpdj5cblx0XHR7L2lmfVxuXHQ8L0ZpZWxkPlxuXG5cdHsjaWYgYl9uZXdfYWRkcmVzcyAmJiBiX2NoZWNrZWRfc2F2ZV9jb250YWN0fVxuXHRcdDxGaWVsZCBzaG9ydCBzbGlkZXNcblx0XHRcdGtleT0nbmV3LWNvbnRhY3QtbmFtZSdcblx0XHRcdG5hbWU9J0NvbnRhY3QgTmFtZSdcblx0XHQ+XG5cdFx0XHQ8aW5wdXQgaWQ9XCJuZXctY29udGFjdC1uYW1lLXZhbHVlXCIgdHlwZT1cInRleHRcIiBvbjppbnB1dD17aW5wdXRfbmV3X2NvbnRhY3R9IGNsYXNzOmludmFsaWQ9e3NfZXJyX25ld19jb250YWN0fT5cblxuXHRcdFx0eyNpZiBzX2Vycl9uZXdfY29udGFjdH1cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIj5cblx0XHRcdFx0XHR7c19lcnJfbmV3X2NvbnRhY3R9XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdHsvaWZ9XG5cdFx0PC9GaWVsZD5cblx0ey9pZn1cblxuXHQ8aHI+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdhc3NldC1zZWxlY3QnXG5cdFx0bmFtZT0nQXNzZXQnXG5cdD5cblx0XHQ8QXNzZXRTZWxlY3QgYmluZDphc3NldFJlZj17cF9hc3NldH0gLz5cblx0PC9GaWVsZD5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2Ftb3VudCdcblx0XHRuYW1lPSdBbW91bnQnXG5cdD5cblx0XHQ8QW1vdW50SW5wdXRcblx0XHRcdGJ1ZmZlck1heD17Z19jb2luPyB4X2ZlZTogMH1cblx0XHRcdGFzc2V0UmVmPXtwX2Fzc2V0fVxuXHRcdFx0YmluZDplcnJvcj17c19lcnJfYW1vdW50fVxuXHRcdFx0YmluZDp2YWx1ZT17c19hbW91bnR9XG5cdFx0XHRzaG93VmFsaWRhdGlvbj17Y19zaG93X3ZhbGlkYXRpb25zfVxuXHRcdC8+XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdiYWxhbmNlJ1xuXHRcdG5hbWU9Jydcblx0PlxuXHRcdDxzcGFuIGNsYXNzPVwiYmFsYW5jZS1saW5lXCI+XG5cdFx0XHR7I2lmIHBfYXNzZXR9XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiYmFsYW5jZVwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibGFiZWxcIj5cblx0XHRcdFx0XHRcdEJhbGFuY2Vcblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJhbW91bnRcIj5cblx0XHRcdFx0XHRcdHtzX2JhbGFuY2V9IHtzX3N5bWJvbH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cInVzZS1tYXhcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImxpbmtcIiBjbGFzczpkaXNhYmxlZD17Yl91c2luZ19tYXh9IG9uOmNsaWNrPXsoKSA9PiB1c2VfbWF4KCl9PlVTRSBNQVg8L3NwYW4+XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdHsvaWZ9XG5cdFx0PC9zcGFuPlxuXHQ8L0ZpZWxkPlxuXG5cdDxocj5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2ZlZSdcblx0XHRuYW1lPSdGZWUnXG5cdD5cblx0XHQ8ZGl2IGNsYXNzPVwiZmVlLWFtb3VudFwiPlxuXHRcdFx0e3hfZmVlfSBTQ1JUXG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwiZmVlLWZpYXRcIj5cblx0XHRcdHtzX2ZlZV9maWF0fVxuXHRcdDwvZGl2PlxuXG5cdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicG9zdFwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cIm1hbnVhbC1mZWVcIj5cbjwhLS0gXG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwibGluayBkaXNhYmxlZFwiPlNldCBmZWUgbWFudWFsbHk8L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvbiBpbmZvXCI+XG5cdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fSU5GT31cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQgLS0+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0PC9GaWVsZD5cblxuXHQ8aHI+XG5cblx0PGRpdiBjbGFzcz1cIm1lbW9cIiBjbGFzczpleHBhbmRlZD17Yl9tZW1vX2V4cGFuZGVkfT5cblx0XHQ8ZGl2IGNsYXNzPVwidGl0bGUgY2xpY2thYmxlXCIgb246Y2xpY2s9eygpID0+IGJfbWVtb19leHBhbmRlZCA9ICFiX21lbW9fZXhwYW5kZWR9PlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGRyb3Bkb3duXCI+XG5cdFx0XHRcdHtAaHRtbCBTWF9JQ09OX0RST1BET1dOfVxuXHRcdFx0PC9zcGFuPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdEFkZCBtZW1vXG5cdFx0XHQ8L3NwYW4+XG5cblx0XHRcdHsjaWYgYl9tZW1vX2V4cGFuZGVkfVxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImRpc2NsYWltZXJcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzUwLCBkZWxheTo0MDB9fT5cblx0XHRcdFx0XHRDYXV0aW9uOiBNZW1vcyBhcmUgTk9UIHByaXZhdGVcblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0ey9pZn1cblx0XHQ8L2Rpdj5cblxuXHRcdHsjaWYgYl9tZW1vX2V4cGFuZGVkfVxuXHRcdFx0PGRpdiBjbGFzcz1cImlucHV0XCIgdHJhbnNpdGlvbjpzbGlkZT17e2R1cmF0aW9uOjM1MH19PlxuXHRcdFx0XHQ8dGV4dGFyZWEgYmluZDp2YWx1ZT17c19tZW1vfT48L3RleHRhcmVhPlxuXHRcdFx0PC9kaXY+XG5cdFx0ey9pZn1cblx0PC9kaXY+XG5cblx0PEFjdGlvbnNMaW5lIGNhbmNlbD0ncG9wJyBjb25maXJtPXtbJ05leHQnLCAoKSA9PiBzdWJtaXQoKSwgIWJfZm9ybV92YWxpZF19IC8+XG5cbjwhLS0gXG5cdDxkaXYgY2xhc3M9XCJhY3Rpb24tbGluZVwiIGNsYXNzOnBvaW50ZXItZXZlbnRzX25vbmU9e2JfZGVhZH0+XG5cdFx0PGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb246Y2xpY2s9eygpID0+ICgoYl9kZWFkID0gdHJ1ZSkgJiYga19wYWdlLnBvcCgpKX0+XG5cdFx0XHRDYW5jZWxcblx0XHQ8L2J1dHRvbj4gLS0+XG48IS0tIFxuXHRcdDxidXR0b24gY2xhc3M9XCJwcmltYXJ5XCIgb246Y2xpY2s9eygpID0+IHN1Ym1pdCgpfSByZWFkb25seT17IWJfZm9ybV92YWxpZH0+XG5cdFx0XHROZXh0XG5cdFx0PC9idXR0b24+IC0tPlxuXHQ8IS0tIDwvZGl2PiAtLT5cbjwvU2NyZWVuPiIsIjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQuZ2FwIHtcblx0XHRoZWlnaHQ6IDhweDtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcblx0XHRtYXJnaW4tYm90dG9tOiBjYWxjKDBweCAtIHZhcigtLXVpLXBhZGRpbmcpKTtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImdhcCBuby1tYXJnaW5cIj4mbmJzcDs8L2Rpdj4iLCJpbXBvcnQgdHlwZSB7TmF0aXZlQ29pbn0gZnJvbSAnIy9tZXRhL2NoYWluJztcbmltcG9ydCB0eXBlIHtDb2lufSBmcm9tICdjb3Ntb3MtZ3JwYy9kaXN0L2Nvc21vcy9iYXNlL3YxYmV0YTEvY29pbic7XG5cbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7Q29pbkdlY2tvfSBmcm9tICcjL3N0b3JlL3dlYi1hcGlzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFzX2Ftb3VudChnX2JhbGFuY2U6IENvaW4sIGdfY29pbjogTmF0aXZlQ29pbik6IHN0cmluZyB7XG5cdGNvbnN0IHNfbm9ybSA9IGdfYmFsYW5jZS5hbW91bnQucGFkU3RhcnQoZ19jb2luLmRlY2ltYWxzICsgMiwgJzAnKTtcblxuXHRyZXR1cm4gc19ub3JtLnNsaWNlKDAsIC1nX2NvaW4uZGVjaW1hbHMpLnJlcGxhY2UoL14wKy8sICcwJykrJy4nK3Nfbm9ybS5zbGljZSgtZ19jb2luLmRlY2ltYWxzKTtcblxuXHQvLyAvLyBnX2NvaW4uZGVjaW1hbHNcblx0Ly8gcmV0dXJuIGdfYmFsYW5jZS5hbW91bnQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b19maWF0KGdfYmFsYW5jZTogQ29pbiwgZ19jb2luOiBOYXRpdmVDb2luLCBzaV92ZXJzdXM9J3VzZCcpOiBQcm9taXNlPEJpZ051bWJlcj4ge1xuXHQvLyB6ZXJvXG5cdGlmKCcwJyA9PT0gZ19iYWxhbmNlLmFtb3VudCkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMCk7XG5cblx0Ly8gbG9va3VwIHByaWNlXG5cdGNvbnN0IHNpX2dlY2tvID0gZ19jb2luLmV4dHJhIS5jb2luZ2Vja29faWQ7XG5cdGNvbnN0IGdfdmVyc3VzID0gYXdhaXQgQ29pbkdlY2tvLmNvaW5zVmVyc3VzKFtzaV9nZWNrb10sIHNpX3ZlcnN1cyk7XG5cblx0Ly8gcGFyc2UgYmFsYW5jZSBhbmQgbXVsdGlwbHkgYnkgdmFsdWVcblx0cmV0dXJuIG5ldyBCaWdOdW1iZXIoZ19iYWxhbmNlLmFtb3VudCkuc2hpZnRlZEJ5KC1nX2NvaW4uZGVjaW1hbHMpLnRpbWVzKGdfdmVyc3VzW3NpX2dlY2tvXSk7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBDb2luRm9ybWF0cyB7XG5cdC8qKlxuXHQgKiBUaGUgaWQgb2YgdGhlIGZpYXQgdGhpcyBjb2luIGlzIHZlcnN1c1xuXHQgKi9cblx0dmVyc3VzOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIFRoZSBiYWxhbmNlIG9mIHRoZSBob2xkaW5nXG5cdCAqL1xuXHRiYWxhbmNlOiBCaWdOdW1iZXI7XG5cblx0LyoqXG5cdCAqIFRoZSB0b3RhbCBcblx0ICovXG5cdGZpYXQ6IG51bWJlcjtcblxuXHQvKipcblx0ICogVGhlIHdvcnRoIG9mIGV4YWN0bHkgMSBjb2luIHZlcnN1cyB0aGUgZ2l2ZW4gZmlhdFxuXHQgKi9cblx0d29ydGg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvaW5fZm9ybWF0cyhnX2JhbGFuY2U6IENvaW4sIGdfY29pbjogTmF0aXZlQ29pbiwgc2lfdmVyc3VzPSd1c2QnKTogUHJvbWlzZTxDb2luRm9ybWF0cz4ge1xuXHQvLyBsb29rdXAgcHJpY2Vcblx0Y29uc3Qgc2lfZ2Vja28gPSBnX2NvaW4uZXh0cmEhLmNvaW5nZWNrb19pZDtcblx0Y29uc3QgZ192ZXJzdXMgPSBhd2FpdCBDb2luR2Vja28uY29pbnNWZXJzdXMoW3NpX2dlY2tvXSwgc2lfdmVyc3VzKTtcblxuXHRjb25zdCB4X3dvcnRoID0gZ192ZXJzdXNbc2lfZ2Vja29dO1xuXG5cdGNvbnN0IHlnX2JhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKGdfYmFsYW5jZS5hbW91bnQpLnNoaWZ0ZWRCeSgtZ19jb2luLmRlY2ltYWxzKS50aW1lcyh4X3dvcnRoKVxuXG5cdC8vIHBhcnNlIGJhbGFuY2UgYW5kIG11bHRpcGx5IGJ5IHZhbHVlXG5cdHJldHVybiB7XG5cdFx0dmVyc3VzOiBzaV92ZXJzdXMsXG5cdFx0YmFsYW5jZTogeWdfYmFsYW5jZSxcblx0XHRmaWF0OiB5Z19iYWxhbmNlLnRpbWVzKHhfd29ydGgpLnRvTnVtYmVyKCksXG5cdFx0d29ydGg6IHhfd29ydGgsXG5cdH07XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cblx0aW1wb3J0IFNYX0lDT05fU0VORCBmcm9tICcjL2ljb24vc2VuZC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fUkVDViBmcm9tICcjL2ljb24vcmVjdi5zdmc/cmF3JztcblxuXHQvLyBpbXBvcnQge2RlZmluaXRpb259IGZyb20gJ0Bmb3J0YXdlc29tZS9mcmVlLXNvbGlkLXN2Zy1pY29ucy9mYVJvYm90Jztcblx0Ly8gY29uc3QgU1hQX1JPQk9UID0gZGVmaW5pdGlvbi5pY29uWzRdO1xuXHRjb25zdCBTWFBfUk9CT1QgPSAnJztcblxuXHQvLyBpbXBvcnQgU1hfTk9SVEhfRUFTVCBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9maWxsZWQvbm9ydGhfZWFzdC5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0VESVQgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvZmlsbGVkL2VkaXQuc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9JTkZPIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL2luZm8uc3ZnP3Jhdyc7XG5cblx0aW1wb3J0IFNYX0lDT05fUEVSU09OQUwgZnJvbSAnIy9pY29uL2FjY291bnRfYm94LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9DT05UUkFDVCBmcm9tICcjL2ljb24vYW5hbHl0aWNzLnN2Zz9yYXcnO1xuXHRpbXBvcnQgeyBIZWFkZXIsIFNjcmVlbiwgdHlwZSBQYWdlIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cdGltcG9ydCBQb3J0cmFpdCwgeyBBY3Rpb25zIH0gZnJvbSAnLi4vdWkvUG9ydHJhaXQuc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBFbnRpdHlQYXRoLCBOYXRpdmVDb2luIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IHsgRW50aXRpZXMgfSBmcm9tICcjL3N0b3JlL2VudGl0aWVzJztcblx0aW1wb3J0IHsgeXdfY2hhaW4sIHl3X2NoYWluX3JlZiwgeXdfbmV0d29ya19hY3RpdmUgfSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgeyBTSV9TVE9SRV9DSEFJTlMsIFhUX01JTlVURVMgfSBmcm9tICcjL3NoYXJlL2NvbnN0YW50cyc7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgU2VuZCBmcm9tICcuL1NlbmQuc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBUb2tlbiwgVG9rZW5QYXRoIH0gZnJvbSAnIy9tZXRhL3Rva2VuJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBjb2luX2Zvcm1hdHMsIHRvX2ZpYXQgfSBmcm9tICcjL2NoYWluL2NvaW4nO1xuXHRpbXBvcnQgeyBmb3JtYXRfYW1vdW50LCBmb3JtYXRfZmlhdCB9IGZyb20gJyMvdXRpbC9mb3JtYXQnO1xuXHRpbXBvcnQgdHlwZSB7IENvaW4gfSBmcm9tICdjb3Ntb3MtZ3JwYy9kaXN0L2Nvc21vcy9iYXNlL3YxYmV0YTEvY29pbic7XG5cdGltcG9ydCB0eXBlIHsgUGZwUGF0aCB9IGZyb20gJyMvbWV0YS9wZnAnO1xuaW1wb3J0IFBmcERpc3BsYXkgZnJvbSAnLi4vdWkvUGZwRGlzcGxheS5zdmVsdGUnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHQvKipcblx0ICogRW50aXR5IHBhdGggc2hvdWxkIGJlIGVpdGhlciBhIGhvbGRpbmcgb3IgdG9rZW5cblx0ICovXG5cdGV4cG9ydCBsZXQgZW50aXR5UmVmOiBFbnRpdHlQYXRoO1xuXHRjb25zdCBwX2VudGl0eSA9IGVudGl0eVJlZjtcblxuXG5cdC8vIGVpdGhlciBhIG5hdGl2ZSBjb2luIG9yIGEgZnVuZ2libGUgdG9rZW5cblx0bGV0IHNpX3R5cGU6ICdjb2luJyB8ICd0b2tlbicgfCAnJyA9ICcnO1xuXG5cdC8vIHRoZSBjb2luJ3MgaWQgYW5kIG9iamVjdCAoaWYgaXRzIGEgY29pbilcblx0bGV0IHNpX2NvaW4gPSAnJztcblx0bGV0IGdfY29pbjogTmF0aXZlQ29pbiB8IG51bGwgPSBudWxsO1xuXG5cdC8vIHRoZSB0b2tlbidzIHBhdGggYW5kIG9iamVjdCAoaWYgaXQncyBhIHRva2VuKVxuXHRsZXQgcF90b2tlbjogVG9rZW5QYXRoIHwgJycgPSAnJztcblx0bGV0IGdfdG9rZW46IFRva2VuWydpbnRlcmZhY2UnXSB8IG51bGwgPSBudWxsO1xuXG5cblx0Ly8gaXRzIHBmcFxuXHRsZXQgcF9wZnA6IFBmcFBhdGggfCAnJyA9ICcnO1xuXG5cdC8vIGl0cyBTWU1CTFxuXHRsZXQgc19zeW1ib2wgPSAnJztcblxuXHQvLyBpdHMgbmFtZVxuXHRsZXQgc19uYW1lID0gJyc7XG5cdFxuXHQvLyB0aGUgYW1vdW50IHRoZSBvd25lciBob2xkc1xuXHRsZXQgeWdfYW1vdW50OiBCaWdOdW1iZXIgfCBudWxsID0gbnVsbDtcblxuXHQvLyB0aGUgZXF1aXZhbGVudCBpbiBmaWF0XG5cdGxldCBzX2ZpYXQgPSAnJztcblxuXHQvLyB0aGUgZmlhdCB3b3J0aCBvZiBleGFjdGx5IDEgY29pbi90b2tlblxuXHRsZXQgc193b3J0aCA9ICcnO1xuXG5cblx0Ly8gY29uc3QgeF92ZXJzdXNfdXNkID0gSF9WRVJTVVNfVVNEW3BfdG9rZW5dLnZhbHVlO1xuXG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9lbnRpdHkoKSB7XG5cdFx0Y29uc3Qga3NfZW50aXRpZXMgPSBhd2FpdCBFbnRpdGllcy5yZWFkKCk7XG5cblx0XHRjb25zdCBnX2luZm8gPSBFbnRpdGllcy5wYXJzZUVudGl0eVBhdGgocF9lbnRpdHkpO1xuXG5cdFx0aWYoIWdfaW5mbykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gbG9hZCBob2xkaW5nIHZpZXcgb24gbm9uLWVudGl0eSBwYXRoIFwiJHtwX2VudGl0eX1cImApO1xuXHRcdH1cblxuXHRcdHN3aXRjaChnX2luZm8udHlwZSkge1xuXHRcdFx0Ly8gbmF0aXZlIGNvaW5cblx0XHRcdGNhc2UgJ2hvbGRpbmcnOiB7XG5cdFx0XHRcdHNpX3R5cGUgPSAnY29pbic7XG5cblx0XHRcdFx0Ly8gZGVzdHJ1Y3R1cmVcblx0XHRcdFx0KHtcblx0XHRcdFx0XHRjb2luOiBzaV9jb2luLFxuXHRcdFx0XHR9ID0gZ19pbmZvKTtcblxuXHRcdFx0XHQvLyBsb29rdXAgZGV0YWlscyBmcm9tIGNoYWluXG5cdFx0XHRcdGNvbnN0IHBfY2hhaW4gPSBnX2luZm8uY2hhaW5SZWY7XG5cdFx0XHRcdGNvbnN0IGdfY2hhaW4gPSBwX2NoYWluID09PSAkeXdfY2hhaW5fcmVmPyAkeXdfY2hhaW46IChhd2FpdCBDaGFpbnMuYXQocF9jaGFpbikpITtcblx0XHRcdFx0Z19jb2luID0gZ19jaGFpbi5jb2luc1tzaV9jb2luXTtcblxuXHRcdFx0XHQvLyBzZXQgZGV0YWlsc1xuXHRcdFx0XHRzX3N5bWJvbCA9IHNpX2NvaW47XG5cdFx0XHRcdHNfbmFtZSA9IGdfY29pbi5uYW1lO1xuXHRcdFx0XHRwX3BmcCA9IGdfY29pbi5wZnA7XG5cblx0XHRcdFx0Ly8gcmVhZCBjYWNoZVxuXHRcdFx0XHRjb25zdCBnX2NhY2hlZCA9ICR5d19uZXR3b3JrX2FjdGl2ZS5jYWNoZWRCYWxhbmNlKGdfaW5mby5iZWNoMzIsIHNpX2NvaW4pO1xuXG5cdFx0XHRcdGxldCBnX2JhbGFuY2U6IENvaW47XG5cblx0XHRcdFx0Ly8gY2FjaGUgaXMgd2l0aGluIGFza2luZyB0aW1lXG5cdFx0XHRcdGlmKGdfY2FjaGVkICYmIGdfY2FjaGVkLnRpbWVzdGFtcCA+PSBEYXRlLm5vdygpIC0gKDIgKiBYVF9NSU5VVEVTKSkge1xuXHRcdFx0XHRcdGdfYmFsYW5jZSA9IGdfY2FjaGVkLmRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gZGVzdHJ1Y3R1cmUgYmFsYW5jZVxuXHRcdFx0XHRcdCh7XG5cdFx0XHRcdFx0XHRiYWxhbmNlOiBnX2JhbGFuY2UsXG5cdFx0XHRcdFx0fSA9IGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5iYW5rQmFsYW5jZShnX2luZm8uYmVjaDMyLCBzaV9jb2luKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBzZXQgYW1vdW50XG5cdFx0XHRcdHlnX2Ftb3VudCA9IG5ldyBCaWdOdW1iZXIoZ19iYWxhbmNlLmFtb3VudCkuc2hpZnRlZEJ5KC1nX2NvaW4uZGVjaW1hbHMpO1xuXG5cdFx0XHRcdC8vIHNldCBmaWF0IGFtb3VudCBhc3luY2hyb25vdXNseVxuXHRcdFx0XHR2b2lkIGNvaW5fZm9ybWF0cyhnX2JhbGFuY2UsIGdfY29pbikudGhlbigoZ19mb3JtYXRzKSA9PiB7XG5cdFx0XHRcdFx0c19maWF0ID0gZm9ybWF0X2ZpYXQoZ19mb3JtYXRzLmZpYXQsIGdfZm9ybWF0cy52ZXJzdXMpO1xuXHRcdFx0XHRcdHNfd29ydGggPSBmb3JtYXRfZmlhdChnX2Zvcm1hdHMud29ydGgsIGdfZm9ybWF0cy52ZXJzdXMpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Ly8gdG9rZW5cblx0XHRcdGNhc2UgJ3Rva2VuJzoge1xuXHRcdFx0XHRzaV90eXBlID0gJ3Rva2VuJztcblxuXHRcdFx0XHQvLyBzZXQgdG9rZW4gcGF0aFxuXHRcdFx0XHRwX3Rva2VuID0gcF9lbnRpdHkgYXMgVG9rZW5QYXRoO1xuXG5cdFx0XHRcdC8vIHJlYWQgdG9rZW4gaW50ZXJmYWNlc1xuXHRcdFx0XHRjb25zdCBrc19lbnRpdGVzID0gYXdhaXQgRW50aXRpZXMucmVhZCgpO1xuXHRcdFx0XHRjb25zdCBoX2lmYWNlcyA9IGtzX2VudGl0ZXMudG9rZW5zKGdfaW5mby5lbnRpdHlSZWYsIEVudGl0aWVzLmZ1bmdpYmxlSW50ZXJmYWNlc0ZvcigkeXdfY2hhaW4pKTtcblx0XHRcdFx0ZGVidWdnZXI7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgZW50aXR5IHR5cGU6IFwiJHtnX2luZm8udHlwZX1cImApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGxvYWRfZW50aXR5KCk7XG5cblx0Ly8gZXhwb3J0IGNvbnN0IGFjY291bnRJZCA9IE9iamVjdC52YWx1ZXMoSF9BQ0NPVU5UUykuZmluZCgoaykgPT4gay5hZGRyZXNzKGtfY2hhaW4pID09PSBob2xkaW5nLmRlZi5ob2xkZXJBZGRyKT8uZGVmLmlkIHx8ICR5d19jaGFpbi5kZWYuaWQ7XG5cblx0Ly8gY29uc3Qga19hY2NvdW50ID0gJHl3X2FjY291bnQ7XG5cdC8vIHl3X2FjY291bnQuc3Vic2NyaWJlKChfa19hY2NvdW50KSA9PiB7XG5cdC8vIFx0aWYoJHl3X3BhdHRlcm4uZW5kc1dpdGgoJy90b2tlbnMve3Rva2VuSWR9L2hvbGRpbmdzL3thY2NvdW50SWR9L3ZpZXcnKSAmJiBrX2FjY291bnQuZGVmLnB1YmtleSAhPT0gX2tfYWNjb3VudC5kZWYucHVia2V5KSB7XG5cdC8vIFx0XHRyZXN0YXJ0KCk7XG5cdC8vIFx0fVxuXHQvLyB9KTtcblxuXHQvLyBjb25zdCBIX1RYTl9JQ09OUyA9IHtcblx0Ly8gXHRbVHhuLlR5cGUuVU5LTl06IEljb24uQkxBTkssXG5cdC8vIFx0W1R4bi5UeXBlLlNFTkRdOiBJY29uLmZyb21IdG1sKFNYX0lDT05fU0VORCwge2NsYXNzOidpY29uLTIwJ30pLFxuXHQvLyBcdFtUeG4uVHlwZS5SRUNWXTogSWNvbi5mcm9tSHRtbChTWF9JQ09OX1JFQ1YsIHtjbGFzczonaWNvbi0yMCd9KSxcblx0Ly8gXHRbVHhuLlR5cGUuQ09NUF06IEljb24uZnJvbUh0bWwoYDxzdmc+PHBhdGggZD1cIiR7U1hQX1JPQk9UfVwiLz48L3N2Zz5gLCB7Y2xhc3M6J2ljb24tMjAnfSksXG5cdC8vIFx0W1R4bi5UeXBlLlNOSVAyMF9YRkVSXTogSWNvbi5mcm9tSHRtbChTWF9JQ09OX1JFQ1YsIHtjbGFzczonaWNvbi0yMCd9KSxcblx0Ly8gfSBhcyBSZWNvcmQ8VHhuLlR5cGUgfCBUeG4uQmFua2lzaFR5cGUsIEljb24+O1xuXG5cdC8vIGNvbnN0IEhfU1VNTUFSSVpFUlMgPSB7XG5cdC8vIFx0W1R4bi5UeXBlLlVOS05dOiAoXykgPT4gJ1Vua25vd24nLFxuXHQvLyBcdFtUeG4uVHlwZS5TRU5EXTogKGspID0+IGBTZW5kIG9uICR7ay5kYXRlKCl9YCxcblx0Ly8gXHRbVHhuLlR5cGUuUkVDVl06IChrKSA9PiBgUmVjZWl2ZSBvbiAke2suZGF0ZSgpfWAsXG5cdC8vIFx0W1R4bi5UeXBlLkNPTVBdOiAoaykgPT4gYENvbXB1dGUgb24gJHtrLmRhdGUoKX1gLFxuXHQvLyB9IGFzIFJlY29yZDxUeG4uVHlwZSB8IFR4bi5CYW5raXNoVHlwZSwgKGtfdHhuOiBUeG4pID0+IHN0cmluZz47XG5cblx0Ly8gY29uc3QgSF9UWE5fQ0xBU1NFUyA9IHtcblx0Ly8gXHRbVHhuLlR5cGUuU0VORF06ICdjb2xvci1pY29uLXNlbmQnLFxuXHQvLyBcdFtUeG4uVHlwZS5SRUNWXTogJ2NvbG9yLWljb24tcmVjdicsXG5cdC8vIH0gYXMgUmVjb3JkPFR4bi5UeXBlIHwgVHhuLkJhbmtpc2hUeXBlLCBzdHJpbmc+O1xuXG5cdC8vIHRoZSBzZXQgb2YgYWN0aW9ucyBhdmFpbGFibGUgb24gdGhpcyBhc3NldFxuXHRjb25zdCBnY19hY3Rpb25zOiBBY3Rpb25zID0ge1xuXHRcdHNlbmQ6IHtcblx0XHRcdGxhYmVsOiAnU2VuZCcsXG5cdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogU2VuZCxcblx0XHRcdFx0XHRwcm9wczogZ190b2tlblxuXHRcdFx0XHRcdFx0PyB7XG5cdFx0XHRcdFx0XHRcdHRva2VuOiBnX3Rva2VuLFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0OiBzaV9jb2luXG5cdFx0XHRcdFx0XHRcdD8ge1xuXHRcdFx0XHRcdFx0XHRcdG5hdGl2ZTogc2lfY29pbixcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQ6IHt9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0fTtcblxuXHQvLyAvLyBob21lIHRva2VuXG5cdC8vIGNvbnN0IGtfaWJjdF9uYXRpdmUgPSBIX0lCQ1RTW0liY3QucmVmRnJvbUhvbWVUb2tlbihnZF90b2tlbi5pcmkpXTtcblx0Ly8gaWYoa19pYmN0X25hdGl2ZSkge1xuXHQvLyBcdGdjX2FjdGlvbnMud3JhcCA9IHtcblx0Ly8gXHRcdGxhYmVsOiAnV3JhcCcsXG5cdC8vIFx0XHR0cmlnZ2VyKCkge1xuXHQvLyBcdFx0XHRwdXNoX3NjcmVlbihEZWFkRW5kKTtcblx0Ly8gXHRcdH0sXG5cdC8vIFx0fTtcblx0Ly8gfVxuXG5cdC8vIC8vIGNvbG9ueSB0b2tlblxuXHQvLyBpZihrX3Rva2VuLmliY3QpIHtcblx0Ly8gXHRnY19hY3Rpb25zLnVud3JhcCA9IHtcblx0Ly8gXHRcdGxhYmVsOiAnVW53cmFwJyxcblx0Ly8gXHRcdHRyaWdnZXIoKSB7XG5cdC8vIFx0XHRcdHB1c2hfc2NyZWVuKERlYWRFbmQpO1xuXHQvLyBcdFx0fSxcblx0Ly8gXHR9O1xuXHQvLyB9XG5cblx0Ly8gLy8gbm9uLW5hdGl2ZSB0b2tlblxuXHQvLyBpZighZ2RfdG9rZW4ubmF0aXZlKSB7XG5cdC8vIFx0T2JqZWN0LmFzc2lnbihnY19hY3Rpb25zLCB7XG5cdC8vIFx0XHRlZGl0OiB7XG5cdC8vIFx0XHRcdGxhYmVsOiAnRWRpdCcsXG5cdC8vIFx0XHRcdHRyaWdnZXIoKSB7XG5cdC8vIFx0XHRcdFx0cHVzaF9zY3JlZW4oVG9rZW5FZGl0LCB7XG5cdC8vIFx0XHRcdFx0XHR0b2tlbjoga190b2tlbixcblx0Ly8gXHRcdFx0XHR9KTtcblx0Ly8gXHRcdFx0fSxcblx0Ly8gXHRcdH0sXG5cdC8vIFx0fSk7XG5cdC8vIH1cblxuXHQvLyBmdW5jdGlvbiBkZXRhaWxfYmFua2lzaChnX2Jhbmtpc2g/OiBUeG4uQmFua2lzaCB8IG51bGwpOiB7cHJlZml4OnN0cmluZywgbmFtZTpzdHJpbmcsIGljb246c3RyaW5nfSB7XG5cdC8vIFx0aWYoIWdfYmFua2lzaCkgcmV0dXJuIHtwcmVmaXg6JycsIG5hbWU6JycsIGljb246Jyd9O1xuXG5cdC8vIFx0Y29uc3Qga19jb250YWN0ID0gSF9BRERSX1RPX0NPTlRBQ1RbZ19iYW5raXNoLmFkZHJlc3NdO1xuXG5cdC8vIFx0cmV0dXJuIHtcblx0Ly8gXHRcdHByZWZpeDogKFR4bi5CYW5raXNoVHlwZS5TRU5EID09PSBnX2Jhbmtpc2gudHlwZT8gJ3RvJzogJ2ZyJykrJzonLFxuXHQvLyBcdFx0bmFtZToga19jb250YWN0PyBrX2NvbnRhY3QuZGVmLmxhYmVsOiAnJyxcblx0Ly8gXHRcdGljb246IGtfY29udGFjdFxuXHQvLyBcdFx0XHQ/IENvbnRhY3QuVHlwZS5QRVJTT04gPT09IGtfY29udGFjdC5kZWYudHlwZVxuXHQvLyBcdFx0XHRcdD8gU1hfSUNPTl9QRVJTT05BTFxuXHQvLyBcdFx0XHRcdDogU1hfSUNPTl9DT05UUkFDVFxuXHQvLyBcdFx0XHQ6ICcnLFxuXHQvLyBcdH07XG5cdC8vIH1cblxuXHRcblx0Ly8gY29uc3QgYV9hbGxvd2FuY2VzID0gZ2RfdG9rZW4uYWxsb3dhbmNlcy5tYXAoKGdfYWxsb3dhbmNlKSA9PiB7XG5cdC8vIFx0Y29uc3Qga19zcGVuZGVyID0gSF9BRERSX1RPX0NPTlRSQUNUW2dfYWxsb3dhbmNlLnNwZW5kZXJdO1xuXHQvLyBcdGlmKCFrX3NwZW5kZXIpIHtcblx0Ly8gXHRcdGRlYnVnZ2VyO1xuXHQvLyBcdH1cblxuXHQvLyBcdGxldCBzX2Ftb3VudDtcblx0Ly8gXHRjb25zdCB5Z19hbW91bnQgPSBuZXcgQmlnTnVtYmVyKGdfYWxsb3dhbmNlLmFtb3VudCk7XG5cdC8vIFx0aWYoeWdfYW1vdW50LmlzR3JlYXRlclRoYW4obmV3IEJpZ051bWJlcignMTAwMDAwMDAwMDAwMDAwMDAwMCcpKSkge1xuXHQvLyBcdFx0c19hbW91bnQgPSAnTGltaXRsZXNzJztcblx0Ly8gXHR9XG5cdC8vIFx0ZWxzZSB7XG5cdC8vIFx0XHRmb3JtYXRfYW1vdW50KGtfdG9rZW4uYXBwcm94KEJpZ0ludChnX2FsbG93YW5jZS5hbW91bnQpKSk7XG5cdC8vIFx0fVxuXG5cdC8vIFx0bGV0IHNfZXhwaXJ5O1xuXHQvLyBcdGNvbnN0IHhfZXhwaXJlcyA9IGdfYWxsb3dhbmNlLmV4cGlyYXRpb247XG5cdC8vIFx0aWYoeF9leHBpcmVzKSB7XG5cdC8vIFx0XHRjb25zdCBkdF93aGVuID0gbmV3IERhdGUoeF9leHBpcmVzICogMWUzKTtcblxuXHQvLyBcdFx0c19leHBpcnkgPSBkdF93aGVuLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7XG5cdC8vIFx0XHRcdG1vbnRoOiAnc2hvcnQnLFxuXHQvLyBcdFx0XHRkYXk6ICdudW1lcmljJyxcblx0Ly8gXHRcdFx0eWVhcjogZHRfd2hlbi5nZXRGdWxsWWVhcigpICE9PSAobmV3IERhdGUoKSkuZ2V0RnVsbFllYXIoKT8gJ251bWVyaWMnOiB2b2lkIDAsXG5cdC8vIFx0XHR9KTtcblx0Ly8gXHR9XG5cdC8vIFx0ZWxzZSB7XG5cdC8vIFx0XHRzX2V4cGlyeSA9ICdOZXZlciBleHBpcmVzJztcblx0Ly8gXHR9XG5cblx0Ly8gXHRyZXR1cm4ge1xuXHQvLyBcdFx0Li4uZ19hbGxvd2FuY2UsXG5cdC8vIFx0XHRrX3NwZW5kZXIsXG5cdC8vIFx0XHRzX2Ftb3VudCxcblx0Ly8gXHRcdHNfZXhwaXJ5LFxuXHQvLyBcdH07XG5cdC8vIH0pO1xuXG5cdC8vIGlmKFRhc2tzLlZFUklGWSA9PT0gJHl3X3Rhc2sgJiYgJ0FUT00nID09PSBnZF90b2tlbi5zeW1ib2wgJiYgZ2RfdG9rZW4ubmF0aXZlICYmICcyJyA9PT0gJHl3X2FjY291bnQuZGVmLmlkKSB7XG5cdC8vIFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdC8vIFx0XHQkeXdfdGFzayA9IC0keXdfdGFzaztcblx0Ly8gXHR9LCAxNDAwKTtcblx0Ly8gfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdC50eG5zIHtcblx0XHQucm93IC5pY29uIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0XHRcdGJvcmRlci1yYWRpdXM6IDMycHg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LnNlY3Rpb24ge1xuXHRcdG1hcmdpbjogMDtcblx0XHRib3JkZXItdG9wOiA2cHggc29saWQgYmxhY2s7XG5cdFx0Ym9yZGVyLWJvdHRvbTogNnB4IHNvbGlkIGJsYWNrO1xuXG5cdFx0LmJhciB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdHBhZGRpbmc6IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHQubGVmdCB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdGdhcDogMC41ZXg7XG5cblx0XHRcdFx0Pi50aXRsZSB7XG5cdFx0XHRcdFx0LmZvbnQocmVndWxhcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LmluZm8ge1xuXHRcdFx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LnJpZ2h0IHtcblxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC50eG4tdHlwZS5pY29uIHtcblx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdC0taWNvbi1kaWFtZXRlcjogMThweDtcblx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbiBkZWJ1Zz0nSG9sZGluZ1ZpZXcnIG5hdiBzbGlkZXM+XG5cdDxIZWFkZXIgcG9wcyBhY2NvdW50IG5ldHdvcmtcblx0XHR0aXRsZT17c19zeW1ib2x9XG5cdFx0c3VidGl0bGU9e3NfbmFtZX1cblx0PlxuXHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInRpdGxlXCI+XG5cblx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0PC9IZWFkZXI+XG5cblx0PFBvcnRyYWl0XG5cdFx0cGZwPXtwX3BmcH1cblx0XHRyZXNvdXJjZT17Z19jb2luIHx8IGdfdG9rZW4gfHwgbnVsbH1cblx0XHRyZXNvdXJjZVBhdGg9e3BfZW50aXR5fVxuXHRcdHRpdGxlPXt5Z19hbW91bnQ/IGAke2Zvcm1hdF9hbW91bnQoeWdfYW1vdW50LnRvTnVtYmVyKCkpfSAke3Nfc3ltYm9sfWA6ICcuLi4nfVxuXHRcdHN1YnRpdGxlPXtgJHtzX2ZpYXR9ICgke3Nfd29ydGh9IHBlciAke3NpX3R5cGV9KWB9XG5cdFx0YWN0aW9ucz17Z2NfYWN0aW9uc31cblx0XHRjaXJjdWxhclxuXHQvPlxuXG5cdDxkaXYgY2xhc3M9XCJ0eG5zIG5vLW1hcmdpblwiPlxuXG5cdFx0PCEtLSB7I2lmIGtfaWJjdF9uYXRpdmV9XG5cdFx0XHQ8ZGl2IGNsYXNzPVwic2VjdGlvblwiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYmFyXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsZWZ0XCI+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibGFiZWxcIj5cblx0XHRcdFx0XHRcdFx0U3Rha2Vcblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHRcdFx0RWFybiB1cCB0byAyNCUgcGVyIHllYXJcblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInJpZ2h0XCI+XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwicGlsbFwiPlxuXHRcdFx0XHRcdFx0XHRTdGFrZSB7Z2RfdG9rZW4uc3ltYm9sfVxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdFx0IC0tPlxuXHRcdDwhLS0gezplbHNlIGlmICR5d19jaGFpbi5kZWYuaWQuc3RhcnRzV2l0aCgnc2VjcmV0LScpfSAtLT5cbjwhLS0gXG5cdFx0XHQ8ZGl2IGNsYXNzPVwic2VjdGlvblwiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYmFyXCIgc3R5bGU9e2FfYWxsb3dhbmNlcy5sZW5ndGg/IFwiYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XCI6ICcnfT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImxlZnRcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJsYWJlbFwiPlxuXHRcdFx0XHRcdFx0XHRBbGxvd2FuY2VzICh7Z2RfdG9rZW4uYWxsb3dhbmNlcy5sZW5ndGh9KVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdFx0XHRBY2NvdW50cyBhbGxvd2VkIHRvIHNwZW5kIHRoaXMgdG9rZW5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInJpZ2h0XCI+XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwicGlsbFwiIG9uOmNsaWNrPXsoKSA9PiBwdXNoX3NjcmVlbihEZWFkRW5kKX0+XG5cdFx0XHRcdFx0XHRcdE1hbmFnZVxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHR7I2VhY2ggYV9hbGxvd2FuY2VzIGFzIGdfYWxsb3dhbmNlLCBpX2FsbG93YW5jZX1cblx0XHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0XHRuYW1lPXtnX2FsbG93YW5jZS5rX3NwZW5kZXIuZGVmLmxhYmVsfVxuXHRcdFx0XHRcdFx0YWRkcmVzcz17Z19hbGxvd2FuY2Uua19zcGVuZGVyLmRlZi5hZGRyZXNzfVxuXHRcdFx0XHRcdFx0YW1vdW50PXtnX2FsbG93YW5jZS5zX2Ftb3VudH1cblx0XHRcdFx0XHRcdGZpYXQ9e2dfYWxsb3dhbmNlLnNfZXhwaXJ5fVxuXHRcdFx0XHRcdFx0aWNvblJlZj17Z19hbGxvd2FuY2Uua19zcGVuZGVyLmRlZi5pY29uUmVmfVxuXHRcdFx0XHRcdFx0aWNvbkNsYXNzPSdzaXRlJ1xuXHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHB1c2hfc2NyZWVuKERlYWRFbmQpfVxuXHRcdFx0XHRcdFx0cm9vdFN0eWxlPXtpX2FsbG93YW5jZSA9PT0gYV9hbGxvd2FuY2VzLmxlbmd0aC0xPyAnYm9yZGVyLWJvdHRvbTogbm9uZTsnOiAnJ31cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0PC9Sb3c+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdDwvZGl2PiAtLT5cblxuXHRcdDwhLS0gey9pZn0gLS0+XG48IS0tIFxuXHRcdHsjZWFjaCBhX2hpc3RvcnkgYXMga190eG59XG5cdFx0XHR7QGNvbnN0IGdfYmFua2lzaCA9IGtfdHhuLmJhbmtpc2goJHl3X2FjY291bnQuYWRkcmVzcygkeXdfY2hhaW4pKX1cblx0XHRcdHtAY29uc3QgZ2RfdHhuID0ga190eG4uZGVmfVxuXHRcdFx0e0Bjb25zdCBnX2RldGFpbCA9IGRldGFpbF9iYW5raXNoKGdfYmFua2lzaCl9XG5cblx0XHRcdHsjaWYgZ19iYW5raXNofVxuXHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0aWNvbj17SF9UWE5fSUNPTlNbZ19iYW5raXNoLnR5cGVdfVxuXHRcdFx0XHRcdGljb25DbGFzcz17SF9UWE5fQ0xBU1NFU1tnX2Jhbmtpc2gudHlwZV0gfHwgJyd9XG5cdFx0XHRcdFx0bmFtZT17SF9TVU1NQVJJWkVSU1tnX2Jhbmtpc2gudHlwZV0oa190eG4pfVxuXHRcdFx0XHRcdGFkZHJlc3M9e2dfYmFua2lzaC5hZGRyZXNzfVxuXHRcdFx0XHRcdGRldGFpbD17Z19kZXRhaWwubmFtZX1cblx0XHRcdFx0XHRwcmVmaXg9e2dfZGV0YWlsLnByZWZpeH1cblx0XHRcdFx0XHRhbW91bnQ9e2Zvcm1hdF9hbW91bnQoa190b2tlbi5hcHByb3goZ19iYW5raXNoLmFtb3VudCkpfVxuXHRcdFx0XHRcdGZpYXQ9e2Ftb3VudF90b19maWF0KGtfdG9rZW4uYXBwcm94KGdfYmFua2lzaC5hbW91bnQpLCBrX3Rva2VuKX1cblx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gcHVzaF9zY3JlZW4oRGVhZEVuZCl9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJkZXRhaWxcIj5cblx0XHRcdFx0XHRcdHsjaWYgZ19kZXRhaWwuaWNvbn1cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0eG4tdHlwZSBpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0e0BodG1sIGdfZGV0YWlsLmljb259XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0XHR7I2lmIGdfZGV0YWlsLm5hbWV9XG5cdFx0XHRcdFx0XHRcdHtnX2RldGFpbC5uYW1lfVxuXHRcdFx0XHRcdFx0ezplbHNlIGlmIGdfYmFua2lzaC5hZGRyZXNzfVxuXHRcdFx0XHRcdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXtnX2Jhbmtpc2guYWRkcmVzc30gLz5cblx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdFx0XHRcdDwvUm93PlxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0aWNvbj17SF9UWE5fSUNPTlNbZ2RfdHhuLnR5cGVdfVxuXHRcdFx0XHRcdGljb25DbGFzcz17SF9UWE5fQ0xBU1NFU1tnZF90eG4udHlwZV0gfHwgJyd9XG5cdFx0XHRcdFx0bmFtZT17SF9TVU1NQVJJWkVSU1tnZF90eG4udHlwZV0oa190eG4pfVxuXHRcdFx0XHRcdGFkZHJlc3M9e2dkX3R4bi5hZGRyZXNzfVxuXHRcdFx0XHRcdGFtb3VudD17Zm9ybWF0X2Ftb3VudChrX3Rva2VuLmFwcHJveChnZF90eG4uYW1vdW50KSl9XG5cdFx0XHRcdFx0ZmlhdD17YW1vdW50X3RvX2ZpYXQoa190b2tlbi5hcHByb3goZ2RfdHhuLmFtb3VudCksIGtfdG9rZW4pfVxuXHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiBwdXNoX3NjcmVlbihEZWFkRW5kKX1cblx0XHRcdFx0Lz5cblx0XHRcdHsvaWZ9XG5cdFx0ey9lYWNofSAtLT5cblx0PC9kaXY+XG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgdHlwZSB7IFRva2VuU3BlY0tleSB9IGZyb20gJyMvbWV0YS90b2tlbic7XG5cblx0aW1wb3J0IHsgRW50aXRpZXMsIFRva2VuRGljdCB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgeyBEaWN0LCBmb3JldmVyLCBvZGUsIG9kZXJvbSwgUHJvbWlzYWJsZSB9IGZyb20gJyMvdXRpbC9iZWx0Jztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IHl3X2FjY291bnQsIHl3X2FjY291bnRfcmVmLCB5d19jaGFpbiwgeXdfY2hhaW5fcmVmLCB5d19wb3B1cCwgeXdfY29udGV4dF9wb3B1cCwgcG9wdXBfcmVjZWl2ZSwgeXdfbmV0d29yaywgeXdfbmV0d29ya19hY3RpdmUsIHl3X293bmVyIH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IFBvcnRyYWl0IGZyb20gJy4uL3VpL1BvcnRyYWl0LnN2ZWx0ZSc7XG5cdGltcG9ydCBTZW5kIGZyb20gJy4vU2VuZC5zdmVsdGUnO1xuXHRpbXBvcnQgUG9wdXBSZWNlaXZlIGZyb20gJy4uL3VpL1BvcHVwUmVjZWl2ZS5zdmVsdGUnO1xuXHRpbXBvcnQgUm93IGZyb20gJy4uL3VpL1Jvdy5zdmVsdGUnO1xuXHRpbXBvcnQgeyBIZWFkZXIsIFNjcmVlbiwgdHlwZSBQYWdlIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgQ29pbkdlY2tvIH0gZnJvbSAnIy9zdG9yZS93ZWItYXBpcyc7XG5cdGltcG9ydCB7IGZvcm1hdF9hbW91bnQsIGZvcm1hdF9maWF0IH0gZnJvbSAnIy91dGlsL2Zvcm1hdCc7XG5cdGltcG9ydCB0eXBlIHsgQ29pbiB9IGZyb20gJ2Nvc21vcy1ncnBjL2Rpc3QvY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luJztcblx0aW1wb3J0IHR5cGUgeyBDaGFpbiwgTmF0aXZlQ29pbiB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB0eXBlIHsgVmFsdWVzIH0gZnJvbSAnIy9tZXRhL2JlbHQnO1xuXHRpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cdGltcG9ydCBBZGRyZXNzIGZyb20gJy4uL3VpL0FkZHJlc3Muc3ZlbHRlJztcblx0aW1wb3J0IEdhcCBmcm9tICcuLi91aS9HYXAuc3ZlbHRlJztcblx0aW1wb3J0IHsgb3Blbl9leHRlcm5hbF9saW5rIH0gZnJvbSAnIy91dGlsL2RvbSc7XG5cdGltcG9ydCBUb2tlbnNBZGQgZnJvbSAnLi9Ub2tlbnNBZGQuc3ZlbHRlJztcblx0aW1wb3J0IHsgYXNfYW1vdW50LCB0b19maWF0IH0gZnJvbSAnIy9jaGFpbi9jb2luJztcblx0aW1wb3J0IEhvbGRpbmdWaWV3IGZyb20gJy4vSG9sZGluZ1ZpZXcuc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBCYWxhbmNlQnVuZGxlIH0gZnJvbSAnIy9zdG9yZS9uZXR3b3Jrcyc7XG5cdGltcG9ydCB7IHN5c2VyciB9IGZyb20gJy4uL2NvbW1vbic7XG5cdGltcG9ydCB7IEFjY291bnRzIH0gZnJvbSAnIy9zdG9yZS9hY2NvdW50cyc7XG5cblx0Ly8gJDogc2Ffb3duZXIgPSBDaGFpbnMuYWRkcmVzc0ZvcigkeXdfYWNjb3VudC5wdWJrZXksICR5d19jaGFpbik7XG5cblx0Y29uc3QgbWVyZ2VfZnVuZ2libGVfdG9rZW5zID0gKGhfZnVuZ2libGVzOiBSZWNvcmQ8VG9rZW5TcGVjS2V5LCBUb2tlbkRpY3Q+KSA9PiBvZGVyb20oaF9mdW5naWJsZXMsIChfLCBoKSA9PiBoKTtcblxuXHQvLyBnZXQgcGFnZSBmcm9tIGNvbnRleHRcblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGxldCB5Z190b3RhbCA9IG5ldyBCaWdOdW1iZXIoMCk7XG5cdGxldCBjX2JhbGFuY2VzID0gMDtcblx0bGV0IGJfYmFsYW5jZXNfcmVhZHkgPSB0cnVlO1xuXHRsZXQgYV9ub19nYXM6IHN0cmluZ1tdID0gW107XG5cblx0bGV0IGZrX3Jlc29sdmVfdG90YWw6IChzX3RvdGFsOiBzdHJpbmcpID0+IHZvaWQ7XG5cdGxldCBkcF90b3RhbCA9IG5ldyBQcm9taXNlPHN0cmluZz4oKGZrX3Jlc29sdmUpID0+IHtcblx0XHRma19yZXNvbHZlX3RvdGFsID0gZmtfcmVzb2x2ZTtcblx0fSk7XG5cblx0bGV0IGdfY2hhaW5fY2FjaGVkID0gJHl3X2NoYWluO1xuXHQkOiB7XG5cdFx0aWYoJHl3X2NoYWluICE9PSBnX2NoYWluX2NhY2hlZCkge1xuXHRcdFx0Z19jaGFpbl9jYWNoZWQgPSAkeXdfY2hhaW47XG5cdFx0XHR5Z190b3RhbCA9IG5ldyBCaWdOdW1iZXIoMCk7XG5cdFx0XHRjX2JhbGFuY2VzID0gMDtcblx0XHRcdGRwX3RvdGFsID0gbmV3IFByb21pc2U8c3RyaW5nPigoZmtfcmVzb2x2ZSkgPT4ge1xuXHRcdFx0XHRma19yZXNvbHZlX3RvdGFsID0gZmtfcmVzb2x2ZTtcblx0XHRcdH0pO1xuXHRcdFx0YV9ub19nYXMgPSBbXTtcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGNoZWNrX3RvdGFsKCkge1xuXHRcdGNfYmFsYW5jZXMgLT0gMTtcblx0XHRpZihiX2JhbGFuY2VzX3JlYWR5ICYmICFjX2JhbGFuY2VzKSB7XG5cdFx0XHRjb25zdCBzX3RvdGFsID0gZm9ybWF0X2ZpYXQoeWdfdG90YWwudG9OdW1iZXIoKSwgJ3VzZCcpO1xuXHRcdFx0ZmtfcmVzb2x2ZV90b3RhbChzX3RvdGFsKTtcblxuXHRcdFx0Ly8gc2F2ZSB0byBjYWNoZVxuXHRcdFx0Y29uc3QgZ19hY2NvdW50ID0gJHl3X2FjY291bnQ7XG5cdFx0XHR2b2lkIEFjY291bnRzLm9wZW4oa3MgPT4ga3MucHV0KHtcblx0XHRcdFx0Li4uZ19hY2NvdW50LFxuXHRcdFx0XHRleHRyYToge1xuXHRcdFx0XHRcdHRvdGFsX2ZpYXRfY2FjaGU6IHNfdG90YWwsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9XG5cblx0dHlwZSBTdWJtaXR0ZXIgPSAoel9vdXQ6IFByb21pc2FibGU8QmlnTnVtYmVyPikgPT4gUHJvbWlzZTxCaWdOdW1iZXI+O1xuXG5cdC8vIGFzeW5jIGZ1bmN0aW9uIHdpdGhfYmFsYW5jZTx3X3ZhbHVlPihkcF90aGluZzogUHJvbWlzYWJsZTx3X3ZhbHVlPik6IFByb21pc2U8W3dfdmFsdWUsIFN1Ym1pdHRlcl0+IHtcblx0Ly8gXHRjX2JhbGFuY2VzICs9IDE7XG5cblx0Ly8gXHRjb25zdCB3X3ZhbHVlID0gYXdhaXQgZHBfdGhpbmc7XG5cblx0Ly8gXHRyZXR1cm4gW1xuXHQvLyBcdFx0d192YWx1ZSxcblx0Ly8gXHRcdGFzeW5jKHpfb3V0OiBQcm9taXNhYmxlPEJpZ051bWJlcj4pOiBQcm9taXNlPEJpZ051bWJlcj4gPT4ge1xuXHQvLyBcdFx0XHRjb25zdCB5Z19iYWxhbmNlID0gYXdhaXQgel9vdXQ7XG5cblx0Ly8gXHRcdFx0eWdfdG90YWwgPSB5Z190b3RhbC5wbHVzKHlnX2JhbGFuY2UpO1xuXG5cdC8vIFx0XHRcdGNoZWNrX3RvdGFsKCk7XG5cdC8vIFx0XHRcdHJldHVybiB5Z19iYWxhbmNlO1xuXHQvLyBcdFx0fSxcblx0Ly8gXHRdO1xuXHQvLyB9XG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9uYXRpdmVfYmFsYW5jZXMoKSB7XG5cdFx0bGV0IGhfYmFsYW5jZXM6IERpY3Q8QmFsYW5jZUJ1bmRsZT47XG5cdFx0dHJ5IHtcblx0XHRcdGhfYmFsYW5jZXMgPSBhd2FpdCAkeXdfbmV0d29ya19hY3RpdmUuYmFua0JhbGFuY2VzKCR5d19vd25lcik7XG5cdFx0fVxuXHRcdGNhdGNoKGVfbmV0d29yaykge1xuXHRcdFx0c3lzZXJyKHtcblx0XHRcdFx0ZXJyb3I6IGVfbmV0d29yayBhcyBFcnJvcixcblx0XHRcdFx0dGV4dDogJ05ldHdvcmsgZXJyb3InLFxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdFx0Y29uc3QgYV9vdXRzOiBbc3RyaW5nLCBOYXRpdmVDb2luLCBDb2luLCBTdWJtaXR0ZXJdW10gPSBbXTtcblxuXHRcdGZvcihjb25zdCBbc2lfY29pbiwgZ19jb2luXSBvZiBvZGUoJHl3X2NoYWluLmNvaW5zKSkge1xuXHRcdFx0Y29uc3QgZ19idW5kbGUgPSBoX2JhbGFuY2VzW3NpX2NvaW5dO1xuXG5cdFx0XHRpZighZ19idW5kbGUgfHwgJzAnID09PSBnX2J1bmRsZS5iYWxhbmNlLmFtb3VudCkge1xuXHRcdFx0XHRhX25vX2dhcy5wdXNoKHNpX2NvaW4pO1xuXHRcdFx0fVxuXG5cdFx0XHRjX2JhbGFuY2VzICs9IDE7XG5cblx0XHRcdGFfb3V0cy5wdXNoKFtcblx0XHRcdFx0c2lfY29pbixcblx0XHRcdFx0JHl3X2NoYWluLmNvaW5zW3NpX2NvaW5dLFxuXHRcdFx0XHRnX2J1bmRsZT8uYmFsYW5jZSB8fCB7YW1vdW50OicwJywgZGVub206Z19jb2luLmRlbm9tfSxcblx0XHRcdFx0YXN5bmMoel9vdXQ6IFByb21pc2FibGU8QmlnTnVtYmVyPik6IFByb21pc2U8QmlnTnVtYmVyPiA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgeWdfYmFsYW5jZSA9IGF3YWl0IHpfb3V0O1xuXG5cdFx0XHRcdFx0eWdfdG90YWwgPSB5Z190b3RhbC5wbHVzKHlnX2JhbGFuY2UpO1xuXG5cdFx0XHRcdFx0Y2hlY2tfdG90YWwoKTtcblx0XHRcdFx0XHRyZXR1cm4geWdfYmFsYW5jZTtcblx0XHRcdFx0fSxcblx0XHRcdF0pO1xuXHRcdH1cblxuXHRcdGlmKCFhX291dHMubGVuZ3RoKSB7XG5cdFx0XHRjX2JhbGFuY2VzICs9IDE7XG5cdFx0XHRjaGVja190b3RhbCgpO1xuXHRcdH1cblxuXHRcdGFfbm9fZ2FzID0gYV9ub19nYXM7XG5cblx0XHRyZXR1cm4gYV9vdXRzO1xuXHR9XG5cblxuXHRjb25zdCBIX0ZBVUNFVFMgPSB7XG5cdFx0J3RoZXRhLXRlc3RuZXQtMDAxJzogJ2h0dHBzOi8vZGlzY29yZC5jb20vY2hhbm5lbHMvNjY5MjY4MzQ3NzM2Njg2NjEyLzk1MzY5Nzc5MzQ3NjgyMTA5MicsXG5cdFx0J3B1bHNhci0yJzogJ2h0dHBzOi8vZmF1Y2V0LnNlY3JldHRlc3RuZXQuaW8vJyxcblx0fTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQudGVzdG5ldC1yZW1pbmRlciB7XG5cdFx0LmZvbnQodGlueSk7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0dHJhbnNmb3JtOiBzY2FsZVgoMS4yNSk7XG5cdFx0bWFyZ2luLWJvdHRvbTogY2FsYygwcHggLSB2YXIoLS11aS1wYWRkaW5nKSAtIHZhcigtLWlubGluZS1wYWRkaW5nKSk7XG5cdH1cblxuXHQuc3ViaW5mbyB7XG5cdFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0cGFkZGluZy10b3A6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHR9XG5cblx0Lm5vLWdhcyB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdGdhcDogdmFyKC0taW5saW5lLXBhZGRpbmcpO1xuXHRcdC5tZXNzYWdlIHtcblx0XHRcdC5mb250KHRpbnkpO1xuXHRcdH1cblx0fVxuXG5cdC5vd25lci1hZGRyZXNzIHtcblx0fVxuXG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdIb2xkaW5nc0hvbWUnIG5hdiByb290IGtleWVkPlxuXG5cdDxIZWFkZXIgc2VhcmNoIG5ldHdvcmsgYWNjb3VudCA+XG5cdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwidGl0bGVcIj5cblxuXHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHQ8L0hlYWRlcj5cblxuXHR7I2lmICR5d19jaGFpbi50ZXN0bmV0fVxuXHRcdDxkaXYgY2xhc3M9XCJ0ZXN0bmV0LXJlbWluZGVyIG5vLW1hcmdpblwiPlxuXHRcdFx0VEVTRVRORVRcblx0XHQ8L2Rpdj5cblx0ey9pZn1cblxuXHQ8IS0tIHRpdGxlPXtmb3JtYXRfZmlhdCh4X3VzZF9iYWxhbmNlKX0gLS0+XG5cdDxQb3J0cmFpdFxuXHRcdG5vUGZwXG5cdFx0dGl0bGU9e2RwX3RvdGFsfVxuXHRcdHN1YnRpdGxlPXskeXdfYWNjb3VudC5uYW1lfVxuXHRcdHJlc291cmNlPXskeXdfYWNjb3VudH1cblx0XHRyZXNvdXJjZVBhdGg9eyR5d19hY2NvdW50X3JlZn1cblx0XHRhY3Rpb25zPXt7XG5cdFx0XHRzZW5kOiB7XG5cdFx0XHRcdGxhYmVsOiAnU2VuZCcsXG5cdFx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdFx0Y3JlYXRvcjogU2VuZCxcblx0XHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRcdGZyb206ICR5d19hY2NvdW50LFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cdFx0XHRyZWN2OiB7XG5cdFx0XHRcdGxhYmVsOiAnUmVjZWl2ZScsXG5cdFx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdFx0cG9wdXBfcmVjZWl2ZSgkeXdfYWNjb3VudF9yZWYpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblx0XHRcdC8vIGFkZDoge1xuXHRcdFx0Ly8gXHRsYWJlbDogJ0FkZCBUb2tlbicsXG5cdFx0XHQvLyBcdHRyaWdnZXIoKSB7XG5cdFx0XHQvLyBcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0Ly8gXHRcdFx0Y3JlYXRvcjogVG9rZW5zQWRkLFxuXHRcdFx0Ly8gXHRcdH0pO1xuXHRcdFx0Ly8gXHR9LFxuXHRcdFx0Ly8gfSxcblx0XHR9fVxuXHQvPlxuXG5cdHsja2V5ICR5d19jaGFpbn1cblx0XHR7I2lmIGFfbm9fZ2FzLmxlbmd0aH1cblx0XHRcdDxkaXYgY2xhc3M9XCJuby1nYXMgdGV4dC1hbGlnbl9jZW50ZXIgc3ViaW5mb1wiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwibWVzc2FnZVwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwid2FybmluZ1wiPldhcm5pbmc6PC9zcGFuPiB5b3UgZG9uJ3QgaGF2ZSBhbnkgeyR5d19jaGFpbi50ZXN0bmV0PyAndGVzdG5ldCAnOicnfXthX25vX2dhcy5qb2luKCcgb3IgJyl9IHRvIHBheSBnYXMgZmVlcy5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImJ1dHRvbnNcIj5cblx0XHRcdFx0XHR7I2lmICR5d19jaGFpbi50ZXN0bmV0fVxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cInBpbGxcIiBvbjpjbGljaz17KCkgPT4gb3Blbl9leHRlcm5hbF9saW5rKEhfRkFVQ0VUU1skeXdfY2hhaW4uaWRdKX0+R2V0IHthX25vX2dhcy5qb2luKCcgb3IgJyl9IGZyb20gZmF1Y2V0PC9idXR0b24+XG5cdFx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdFx0PGJ1dHRvbiBjbGFzcz1cInBpbGxcIj5CdXkge2Ffbm9fZ2FzLmpvaW4oJyBvciAnKX08L2J1dHRvbj5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdHsvaWZ9XG5cblx0XHQ8ZGl2IGNsYXNzPVwib3duZXItYWRkcmVzcyBzdWJpbmZvXCI+XG5cdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXskeXdfb3duZXJ9IGNvcHlhYmxlPSd0ZXh0JyAvPlxuXHRcdDwvZGl2PlxuXHR7L2tleX1cblxuXG5cdDxHYXAgLz5cblxuXHQ8IS0tIHsja2V5IGFfaG9sZGluZ3N9XG5cdFx0PEhvbGRpbmdzTGlzdCBob2xkaW5ncz17YV9ob2xkaW5nc30gLz5cblx0ey9rZXl9IC0tPlxuXG5cdHsja2V5ICR5d19uZXR3b3JrX2FjdGl2ZX1cblx0XHQ8ZGl2IGNsYXNzPVwicm93cyBuby1tYXJnaW5cIj5cblx0XHRcdDwhLS0gbmF0aXZlIGNvaW4ocykgLS0+XG5cdFx0XHR7I2F3YWl0IGxvYWRfbmF0aXZlX2JhbGFuY2VzKCl9XG5cdFx0XHRcdHsjZWFjaCBvZGUoJHl3X2NoYWluLmNvaW5zKSBhcyBbc2lfY29pbiwgZ19idW5kbGVdfVxuXHRcdFx0XHRcdHtAY29uc3QgcF9lbnRpdHkgPSBFbnRpdGllcy5ob2xkaW5nUGF0aEZvcigkeXdfb3duZXIsIHNpX2NvaW4pfVxuXHRcdFx0XHRcdDxSb3cgbG9ja0ljb24gZGV0YWlsPSdOYXRpdmUgQ29pbidcblx0XHRcdFx0XHRcdG5hbWU9e3NpX2NvaW59XG5cdFx0XHRcdFx0XHRwZnA9eyR5d19jaGFpbi5wZnB9XG5cdFx0XHRcdFx0XHRhbW91bnQ9e2ZvcmV2ZXIoJycpfVxuXHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdGNyZWF0b3I6IEhvbGRpbmdWaWV3LFxuXHRcdFx0XHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbnRpdHlSZWY6IHBfZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR7L2VhY2h9XG5cdFx0XHR7OnRoZW4gYV9iYWxhbmNlc31cblx0XHRcdFx0eyNlYWNoIGFfYmFsYW5jZXMgYXMgW3NpX2NvaW4sIGdfY29pbiwgZ19iYWxhbmNlLCBmX3N1Ym1pdF19XG5cdFx0XHRcdHtAY29uc3QgcF9lbnRpdHkgPSBFbnRpdGllcy5ob2xkaW5nUGF0aEZvcigkeXdfb3duZXIsIHNpX2NvaW4pfVxuXHRcdFx0XHRcdHtAY29uc3QgZ19yZXNvdXJjZSA9IHtcblx0XHRcdFx0XHRcdG5hbWU6IHNpX2NvaW4sXG5cdFx0XHRcdFx0XHRwZnA6ICR5d19jaGFpbi5wZnAsXG5cdFx0XHRcdFx0fX1cblx0XHRcdFx0XHR7QGNvbnN0IGRwX3dvcnRoID0gZl9zdWJtaXQodG9fZmlhdChnX2JhbGFuY2UsIGdfY29pbikpfVxuXHRcdFx0XHRcdDxSb3cgbG9ja0ljb24gZGV0YWlsPSdOYXRpdmUgQ29pbidcblx0XHRcdFx0XHRcdHJlc291cmNlUGF0aD17cF9lbnRpdHl9XG5cdFx0XHRcdFx0XHRyZXNvdXJjZT17Z19yZXNvdXJjZX1cblx0XHRcdFx0XHRcdGFtb3VudD17YXNfYW1vdW50KGdfYmFsYW5jZSwgZ19jb2luKX1cblx0XHRcdFx0XHRcdGZpYXQ9e2RwX3dvcnRoLnRoZW4oeWcgPT4gZm9ybWF0X2ZpYXQoeWcudG9OdW1iZXIoKSwgJ3VzZCcpKX1cblx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRjcmVhdG9yOiBIb2xkaW5nVmlldyxcblx0XHRcdFx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW50aXR5UmVmOiBwX2VudGl0eSxcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0ey9lYWNofVxuXHRcdFx0ey9hd2FpdH1cblxuXG5cdFx0XHR7I2F3YWl0IEVudGl0aWVzLnJlYWRGdW5naWJsZVRva2VucygkeXdfY2hhaW4pfVxuXHRcdFx0XHRMb2FkaW5nIHRva2Vucy4uLlxuXHRcdFx0ezp0aGVuIGhfZnVuZ2libGVzfVxuXHRcdFx0XHR7I2VhY2ggb2RlKG1lcmdlX2Z1bmdpYmxlX3Rva2VucyhoX2Z1bmdpYmxlcykpIGFzIFtwX3Rva2VuLCBnX3Rva2VuXX1cblx0XHRcdFx0XHR7Z190b2tlbi5zcGVjfVxuXHRcdFx0XHR7L2VhY2h9XG5cdFx0XHR7L2F3YWl0fVxuXHRcdDwvZGl2PlxuXHR7L2tleX1cbjwvU2NyZWVuPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IHR5cGUgeyBDb21wbGV0ZWQgfSBmcm9tICcjL2VudHJ5L2Zsb3cnO1xuXG5cdGltcG9ydCB0eXBlIHtBY2NvdW50LCBBY2NvdW50UGF0aH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXHRpbXBvcnQgdHlwZSB7QmVjaDMyfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQge0FjY291bnRzfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHtDaGFpbnN9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHt5d19hY2NvdW50X3JlZiwgeXdfY2hhaW59IGZyb20gJy4uL21lbSc7XG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcuLi91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuXHRpbXBvcnQgQWRkcmVzcyBmcm9tICcuLi91aS9BZGRyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBGaWVsZCBmcm9tICcuLi91aS9GaWVsZC5zdmVsdGUnO1xuXHRpbXBvcnQgSW5saW5lVGFncyBmcm9tICcuLi91aS9JbmxpbmVUYWdzLnN2ZWx0ZSc7XG5cdGltcG9ydCBJbmZvIGZyb20gJyMjL3VpL0luZm8uc3ZlbHRlJztcblx0aW1wb3J0IHtTY3JlZW4sIHR5cGUgUGFnZX0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblxuXHRleHBvcnQgbGV0IGFjY291bnQ6IEFjY291bnRQYXRoO1xuXHRjb25zdCBwX2FjY291bnQgPSBhY2NvdW50O1xuXG5cdGxldCBnX2FjY291bnQ6IEFjY291bnRbJ2ludGVyZmFjZSddO1xuXG5cdGxldCBzX25hbWUgPSAnJztcblx0bGV0IHNhX2FjY291bnQ6IEJlY2gzMi5TdHJpbmc7XG5cblx0JDogYl9mb3JtX3ZhbGlkID0gISFzX25hbWU7XG5cblx0JDogc2FfYWNjb3VudCA9IGdfYWNjb3VudD8gQ2hhaW5zLmFkZHJlc3NGb3IoZ19hY2NvdW50LnB1YmtleSwgJHl3X2NoYWluKTogJyc7XG5cblx0Y29uc3QgY29tcGxldGVkID0gZ2V0Q29udGV4dDxDb21wbGV0ZWQgfCB1bmRlZmluZWQ+KCdjb21wbGV0ZWQnKTtcblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYWNjb3VudCgpIHtcblx0XHRjb25zdCBrc19hY2NvdW50cyA9IGF3YWl0IEFjY291bnRzLnJlYWQoKTtcblx0XHRnX2FjY291bnQgPSBrc19hY2NvdW50cy5hdChwX2FjY291bnQpITtcblx0XHRzX25hbWUgPSBnX2FjY291bnQubmFtZTtcblx0fVxuXG5cdGFzeW5jIGZ1bmN0aW9uIHNhdmVfYWNjb3VudCgpIHtcblx0XHRPYmplY3QuYXNzaWduKGdfYWNjb3VudCwge1xuXHRcdFx0bmFtZTogc19uYW1lLFxuXHRcdH0pO1xuXG5cdFx0YXdhaXQgQWNjb3VudHMub3Blbihrc19hY2NvdW50cyA9PiBrc19hY2NvdW50cy5wdXQoZ19hY2NvdW50KSk7XG5cblx0XHQvLyBlZGl0dGVkIGFjdGl2ZSBhY2NvdW50OyByZWxvYWRcblx0XHRpZihwX2FjY291bnQgPT09ICR5d19hY2NvdW50X3JlZikge1xuXHRcdFx0JHl3X2FjY291bnRfcmVmID0gcF9hY2NvdW50O1xuXHRcdH1cblxuXHRcdGlmKGNvbXBsZXRlZCkge1xuXHRcdFx0Y29tcGxldGVkKHRydWUpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGtfcGFnZS5yZXNldCgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIGZ1bmN0aW9uIHNhdmUoKSB7XG5cdC8vIFx0aWYoIWJfZm9ybV92YWxpZCkgcmV0dXJuO1xuXG5cdC8vIFx0Y29uc3QgZ19zYXZlID0ge1xuXHQvLyBcdFx0bGFiZWw6IGFjY291bnROYW1lLFxuXHQvLyBcdFx0dGFnUmVmczogYV90YWdzLm1hcChrID0+IGsuZGVmLmlyaSksXG5cdC8vIFx0fTtcblxuXHQvLyBcdGlmKGFjY291bnQpIHtcblx0Ly8gXHRcdE9iamVjdC5hc3NpZ24oYWNjb3VudC5kZWYsIGdfc2F2ZSk7XG5cblx0Ly8gXHRcdHJlc3RhcnQoKTtcblxuXHQvLyBcdFx0aWYoVGFza3MuQUREX1RBRyA9PT0gJHl3X3Rhc2spIHtcblx0Ly8gXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdC8vIFx0XHRcdFx0JHl3X3Rhc2sgPSAtJHl3X3Rhc2s7XG5cdC8vIFx0XHRcdH0sIDEyMDApO1xuXHQvLyBcdFx0fVxuXHQvLyBcdH1cblx0Ly8gXHRlbHNlIHtcblx0Ly8gXHRcdGNvbnN0IGdkX2FjY291bnQgPSBBY2NvdW50LkRlZi5mcm9tQ29uZmlnKHtcblx0Ly8gXHRcdFx0Li4uZ19zYXZlLFxuXHQvLyBcdFx0XHRwdWJrZXk6IHNhX2FjY291bnQucmVwbGFjZSgvXlxcdysxL2csICcnKSxcblx0Ly8gXHRcdFx0aWNvblJlZjogcF9pY29uLFxuXHQvLyBcdFx0fSk7XG5cblx0Ly8gXHRcdGNvbnN0IGtfYWNjb3VudCA9IEhfQUNDT1VOVFNbZ2RfYWNjb3VudC5pcmldID0gbmV3IEFjY291bnQoZ2RfYWNjb3VudCk7XG5cblx0Ly8gXHRcdHJlc3RhcnQoKTtcblxuXHQvLyBcdFx0cHVzaF9zY3JlZW4oQWNjb3VudFZpZXcsIHtcblx0Ly8gXHRcdFx0YWNjb3VudDoga19hY2NvdW50LFxuXHQvLyBcdFx0fSk7XG5cdC8vIFx0fVxuXHQvLyB9XG5cbjwvc2NyaXB0PlxuXG48U2NyZWVuPlxuXHQ8aDM+XG5cdFx0e2FjY291bnQ/ICdFZGl0JzogJ05ldyd9IGFjY291bnRcblx0PC9oMz5cblxuXHR7I2F3YWl0IGxvYWRfYWNjb3VudCgpfVxuXHRcdExvYWRpbmcgYWNjb3VudHMuLi5cblx0ezp0aGVufVxuXHRcdDxGaWVsZCBrZXk9XCJwcm9maWxlLWljb25cIiBuYW1lPVwiUHJvZmlsZSBpY29uXCI+XG5cdFx0XHQ8IS0tIDxJY29uRWRpdG9yIGludGVudD0ncGVyc29uJyBpY29uUmVmPXtwX2ljb259IC8+IC0tPlxuXHRcdDwvRmllbGQ+XG5cblx0XHQ8RmllbGQga2V5PVwiYWNjb3VudC1uYW1lXCIgbmFtZT1cIk5hbWVcIj5cblx0XHRcdDxpbnB1dCBpZD1cImFjY291bnQtbmFtZVwiIHR5cGU9XCJ0ZXh0XCIgYmluZDp2YWx1ZT17c19uYW1lfSBwbGFjZWhvbGRlcj1cIlNhdG9zaGlcIj5cblx0XHQ8L0ZpZWxkPlxuXG5cdFx0PCEtLSA8RmllbGQga2V5PVwiYWNjb3VudC1wYXRoXCIgbmFtZT1cIkRlcml2YXRpb24gcGF0aFwiPlxuXHRcdFx0PEluZm8ga2V5PVwiYWNjb3VudC1wYXRoXCI+XG5cdFx0XHRcdG0vNDQnLzExOCcvMCcvMC97T2JqZWN0LnZhbHVlcyhIX0FDQ09VTlRTKS5sZW5ndGh9XG5cdFx0XHQ8L0luZm8+XG5cdFx0PC9GaWVsZD4gLS0+XG5cblx0XHQ8RmllbGQga2V5PVwiYWNjb3VudC1hZGRyZXNzXCIgbmFtZT1cIlB1YmxpYyBhZGRyZXNzXCI+XG5cdFx0XHQ8SW5mbyBhZGRyZXNzIGtleT1cImFjY291bnQtYWRkcmVzc1wiPlxuXHRcdFx0XHQ8QWRkcmVzcyBjb3B5YWJsZSBhZGRyZXNzPXtzYV9hY2NvdW50fSAvPlxuXHRcdFx0PC9JbmZvPlxuXHRcdDwvRmllbGQ+XG48IS0tIFxuXHRcdDxGaWVsZCBrZXk9XCJhY2NvdW50LXRhZ3NcIiBuYW1lPVwiQWRkIHRhZ3NcIj5cblx0XHRcdDxJbmxpbmVUYWdzIGVkaXRhYmxlIHJlc291cmNlUGF0aD17cF9hY2NvdW50fSAvPlxuXHRcdDwvRmllbGQ+IC0tPlxuXG5cdFx0PEFjdGlvbnNMaW5lIGNhbmNlbD17IWNvbXBsZXRlZH0gYmFjayBjb25maXJtPXtbJ0ZpbmlzaCcsIHNhdmVfYWNjb3VudCwgIWJfZm9ybV92YWxpZF19IC8+XG5cblx0XHQ8IS0tIDxkaXYgY2xhc3M9XCJhY3Rpb24tbGluZSBjbGlja2FibGVcIj5cblx0XHRcdDxidXR0b24gb246Y2xpY2s9eygpID0+IHBvcCgpfT5cblx0XHRcdFx0Q2FuY2VsXG5cdFx0XHQ8L2J1dHRvbj5cblxuXHRcdFx0PGJ1dHRvbiBjbGFzcz1cInByaW1hcnlcIiByZWFkb25seT17IWJfZm9ybV92YWxpZH0gb246Y2xpY2s9eygpID0+IHNhdmUoKX0+XG5cdFx0XHRcdEZpbmlzaFxuXHRcdFx0PC9idXR0b24+XG5cdFx0PC9kaXY+IC0tPlxuXHR7L2F3YWl0fVxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUge0FjY291bnQsIEFjY291bnRQYXRofSBmcm9tICcjL21ldGEvYWNjb3VudCc7XG5cdGltcG9ydCB7QWNjb3VudHN9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQge0NoYWluc30gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXG5cdGltcG9ydCB7Z2V0Q29udGV4dH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHtwb3B1cF9yZWNlaXZlfSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgQWRkcmVzcyBmcm9tICcuLi91aS9BZGRyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBQb3J0cmFpdCBmcm9tICcuLi91aS9Qb3J0cmFpdC5zdmVsdGUnO1xuXHRpbXBvcnQgQWNjb3VudEVkaXQgZnJvbSAnLi9BY2NvdW50RWRpdC5zdmVsdGUnO1xuXHRpbXBvcnQgU2VuZCBmcm9tICcuL1NlbmQuc3ZlbHRlJztcblxuXHRpbXBvcnQge1xuXHRcdFNjcmVlbixcblx0XHRIZWFkZXIsXG5cdFx0dHlwZSBQYWdlLFxuXHR9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGV4cG9ydCBsZXQgYWNjb3VudFJlZjogQWNjb3VudFBhdGg7XG5cdGNvbnN0IHBfYWNjb3VudCA9IGFjY291bnRSZWY7XG5cblx0bGV0IGdfYWNjb3VudDogQWNjb3VudFsnaW50ZXJmYWNlJ107XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9hY2NvdW50KCk6IFByb21pc2U8QWNjb3VudFsnaW50ZXJmYWNlJ10+IHtcblx0XHRjb25zdCBrc19hY2NvdW50cyA9IGF3YWl0IEFjY291bnRzLnJlYWQoKTtcblxuXHRcdHJldHVybiBnX2FjY291bnQgPSBrc19hY2NvdW50cy5hdChwX2FjY291bnQpITtcblx0fVxuXG5cdGNvbnN0IGdjX2FjdGlvbnMgPSB7XG5cdFx0c2VuZDoge1xuXHRcdFx0bGFiZWw6ICdTZW5kJyxcblx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBTZW5kLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRmcm9tOiBDaGFpbnMuYWRkcmVzc0ZvcihnX2FjY291bnQucHVia2V5KSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHRyZWN2OiB7XG5cdFx0XHRsYWJlbDogJ1JlY2VpdmUnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0cG9wdXBfcmVjZWl2ZShwX2FjY291bnQpO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRcdGVkaXQ6IHtcblx0XHRcdGxhYmVsOiAnRWRpdCcsXG5cdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogQWNjb3VudEVkaXQsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdGFjY291bnQ6IHBfYWNjb3VudCxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0fTtcblxuPC9zY3JpcHQ+XG5cbjwhLS0gXG48c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJwZnBcIj5cblx0eyNpZiBIX0lDT05TW2FjY291bnQuZGVmLmljb25SZWZdfVxuXHRcdDxQdXQgZWxlbWVudD17SF9JQ09OU1thY2NvdW50LmRlZi5pY29uUmVmXS5yZW5kZXIoKX0gLz5cblx0ezplbHNlfVxuXHRcdDxzcGFuIGNsYXNzPVwicGZwLWdlblwiPlxuXHRcdFx0e2FjY291bnQuZGVmLmxhYmVsWzBdfVxuXHRcdDwvc3Bhbj5cblx0ey9pZn1cbjwvc3ZlbHRlOmZyYWdtZW50PiAtLT5cblxuPFNjcmVlbiBuYXY+XG5cdDxIZWFkZXIgcG9wcyBzZWFyY2ggbmV0d29ya1xuXHRcdHRpdGxlPVwiQWNjb3VudFwiXG5cdD48L0hlYWRlcj5cblxuXHR7I2F3YWl0IGxvYWRfYWNjb3VudCgpfVxuXHRcdExvYWRpbmcuLi5cblx0ezp0aGVufVxuXHRcdDxQb3J0cmFpdFxuXHRcdFx0cmVzb3VyY2U9e2dfYWNjb3VudH1cblx0XHRcdHJlc291cmNlUGF0aD17cF9hY2NvdW50fVxuXHRcdFx0YWN0aW9ucz17Z2NfYWN0aW9uc31cblx0XHQ+XG5cdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0XHQ8QWRkcmVzcyBjb3B5YWJsZSBhZGRyZXNzPXtDaGFpbnMuYWRkcmVzc0ZvcihnX2FjY291bnQucHVia2V5KX0gLz5cblx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdDwvUG9ydHJhaXQ+XG5cdHsvYXdhaXR9XG5cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgQWNjb3VudCwgQWNjb3VudFBhdGggfSBmcm9tICcjL21ldGEvYWNjb3VudCc7XG5cdGltcG9ydCB7IEFjY291bnRzIH0gZnJvbSAnIy9zdG9yZS9hY2NvdW50cyc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHsgeXdfY2hhaW4gfSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgQWRkcmVzcyBmcm9tICcuLi91aS9BZGRyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBSb3cgZnJvbSAnLi4vdWkvUm93LnN2ZWx0ZSc7XG5cdGltcG9ydCBBY2NvdW50Q3JlYXRlIGZyb20gJy4vQWNjb3VudENyZWF0ZS5zdmVsdGUnO1xuXHRpbXBvcnQgQWNjb3VudFZpZXcgZnJvbSAnLi9BY2NvdW50Vmlldy5zdmVsdGUnO1xuXG5cdGltcG9ydCB7XG5cdFx0U2NyZWVuLFxuXHRcdEhlYWRlcixcblx0XHRTdWJIZWFkZXIsXG5cdFx0dHlwZSBQYWdlLFxuXHR9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRsZXQgYV9hY2NvdW50czogW0FjY291bnRQYXRoLCBBY2NvdW50WydpbnRlcmZhY2UnXV1bXTtcblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9hY2NvdW50cygpOiBQcm9taXNlPHR5cGVvZiBhX2FjY291bnRzPiB7XG5cdFx0Y29uc3Qga3NfYWNjb3VudHMgPSBhd2FpdCBBY2NvdW50cy5yZWFkKCk7XG5cblx0XHRyZXR1cm4gYV9hY2NvdW50cyA9IGtzX2FjY291bnRzLmVudHJpZXMoKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdC5oZC1wYXRoIHtcblx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxTY3JlZW4gZGVidWc9J0FjY291bnRzJyBuYXYgcm9vdD5cblx0PEhlYWRlciBzZWFyY2ggbmV0d29yayBhY2NvdW50XG5cdD5cblx0PC9IZWFkZXI+XG5cblx0PFN1YkhlYWRlclxuXHRcdHRpdGxlPVwiQWNjb3VudHNcIlxuXHQvPlxuXHRcdDwhLS0gb246YWRkX25ldz17KCkgPT4ga19wYWdlLnB1c2goe1xuXHRcdFx0Y3JlYXRvcjogQWNjb3VudENyZWF0ZSxcblx0XHR9KX0gLS0+XG5cblx0PGRpdiBjbGFzcz1cInJvd3Mgbm8tbWFyZ2luXCI+XG5cdFx0eyNhd2FpdCBsb2FkX2FjY291bnRzKCl9XG5cdFx0XHRMb2FkaW5nLi4uXG5cdFx0ezp0aGVufVxuXHRcdFx0eyNrZXkgJHl3X2NoYWlufVxuXHRcdFx0XHR7I2VhY2ggYV9hY2NvdW50cyBhcyBbcF9hY2NvdW50LCBnX2FjY291bnRdfVxuXHRcdFx0XHRcdHtAY29uc3Qgc2Ffb3duZXIgPSBDaGFpbnMuYWRkcmVzc0ZvcihnX2FjY291bnQucHVia2V5KX1cblx0XHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0XHRyZXNvdXJjZT17Z19hY2NvdW50fVxuXHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoPXtwX2FjY291bnR9XG5cdFx0XHRcdFx0XHRhZGRyZXNzPXtzYV9vd25lcn1cblx0XHRcdFx0XHRcdGljb25DbGFzcz17J3NxdWFyZSBwZnAnfVxuXHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0Y3JlYXRvcjogQWNjb3VudFZpZXcsXG5cdFx0XHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRcdFx0YWNjb3VudFJlZjogcF9hY2NvdW50LFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0fSl9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwiZGV0YWlsXCI+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJoZC1wYXRoXCI+XG5cdFx0XHRcdFx0XHRcdFx0U3RhclNoZWxsIC0gLSBtLzQ0Jy8xMTgnLzAnLzAvPz9cblx0XHRcdFx0XHRcdFx0XHQ8IS0tIFN0YXJTaGVsbCAtIG0vNDQnLzExOCcvMCcvMC97K2dfYWNjb3VudC5pZC0xfSAtLT5cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHRcdFx0PEFkZHJlc3MgYWRkcmVzcz17c2Ffb3duZXJ9IC8+XG5cdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0ey9lYWNofVxuXHRcdFx0ey9rZXl9XG5cdFx0ey9hd2FpdH1cblx0PC9kaXY+XG48L1NjcmVlbj4iLCJsZXQgaWQgPSAxO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRJZCgpIHtcbiAgcmV0dXJuIGBzdmVsdGUtdGFicy0ke2lkKyt9YDtcbn1cbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxuICBleHBvcnQgY29uc3QgVEFCUyA9IHt9O1xuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlLCBzZXRDb250ZXh0LCBvbkRlc3Ryb3ksIG9uTW91bnQsIHRpY2sgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XG5cbiAgZXhwb3J0IGxldCBpbml0aWFsU2VsZWN0ZWRJbmRleCA9IDA7XG5cbiAgY29uc3QgdGFiRWxlbWVudHMgPSBbXTtcbiAgY29uc3QgdGFicyA9IFtdO1xuICBjb25zdCBwYW5lbHMgPSBbXTtcblxuICBjb25zdCBjb250cm9scyA9IHdyaXRhYmxlKHt9KTtcbiAgY29uc3QgbGFiZWxlZEJ5ID0gd3JpdGFibGUoe30pO1xuXG4gIGNvbnN0IHNlbGVjdGVkVGFiID0gd3JpdGFibGUobnVsbCk7XG4gIGNvbnN0IHNlbGVjdGVkUGFuZWwgPSB3cml0YWJsZShudWxsKTtcblxuICBmdW5jdGlvbiByZW1vdmVBbmRVcGRhdGVTZWxlY3RlZChhcnIsIGl0ZW0sIHNlbGVjdGVkU3RvcmUpIHtcbiAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHNlbGVjdGVkU3RvcmUudXBkYXRlKHNlbGVjdGVkID0+IHNlbGVjdGVkID09PSBpdGVtID8gKGFycltpbmRleF0gfHwgYXJyW2Fyci5sZW5ndGggLSAxXSkgOiBzZWxlY3RlZCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3Rlckl0ZW0oYXJyLCBpdGVtLCBzZWxlY3RlZFN0b3JlKSB7XG4gICAgYXJyLnB1c2goaXRlbSk7XG4gICAgc2VsZWN0ZWRTdG9yZS51cGRhdGUoc2VsZWN0ZWQgPT4gc2VsZWN0ZWQgfHwgaXRlbSk7XG4gICAgb25EZXN0cm95KCgpID0+IHJlbW92ZUFuZFVwZGF0ZVNlbGVjdGVkKGFyciwgaXRlbSwgc2VsZWN0ZWRTdG9yZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0VGFiKHRhYikge1xuICAgIGNvbnN0IGluZGV4ID0gdGFicy5pbmRleE9mKHRhYik7XG4gICAgc2VsZWN0ZWRUYWIuc2V0KHRhYik7XG4gICAgc2VsZWN0ZWRQYW5lbC5zZXQocGFuZWxzW2luZGV4XSk7XG4gIH1cblxuICBzZXRDb250ZXh0KFRBQlMsIHtcbiAgICByZWdpc3RlclRhYih0YWIpIHtcbiAgICAgIHJlZ2lzdGVySXRlbSh0YWJzLCB0YWIsIHNlbGVjdGVkVGFiKTtcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJUYWJFbGVtZW50KHRhYkVsZW1lbnQpIHtcbiAgICAgIHRhYkVsZW1lbnRzLnB1c2godGFiRWxlbWVudCk7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyUGFuZWwocGFuZWwpIHtcbiAgICAgIHJlZ2lzdGVySXRlbShwYW5lbHMsIHBhbmVsLCBzZWxlY3RlZFBhbmVsKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VGFiLFxuXG4gICAgc2VsZWN0ZWRUYWIsXG4gICAgc2VsZWN0ZWRQYW5lbCxcblxuICAgIGNvbnRyb2xzLFxuICAgIGxhYmVsZWRCeVxuICB9KTtcblxuICBvbk1vdW50KCgpID0+IHtcbiAgICBzZWxlY3RUYWIodGFic1tpbml0aWFsU2VsZWN0ZWRJbmRleF0pO1xuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb250cm9scy51cGRhdGUoY29udHJvbHNEYXRhID0+ICh7Li4uY29udHJvbHNEYXRhLCBbdGFic1tpXS5pZF06IHBhbmVsc1tpXS5pZH0pKTtcbiAgICAgIGxhYmVsZWRCeS51cGRhdGUobGFiZWxlZEJ5RGF0YSA9PiAoey4uLmxhYmVsZWRCeURhdGEsIFtwYW5lbHNbaV0uaWRdOiB0YWJzW2ldLmlkfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzdmVsdGUtdGFic19fdGFiJykpIHtcbiAgICAgIGxldCBzZWxlY3RlZEluZGV4ID0gdGFicy5pbmRleE9mKCRzZWxlY3RlZFRhYik7XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgIHNlbGVjdGVkSW5kZXggKz0gMTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCA+IHRhYnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdFRhYih0YWJzW3NlbGVjdGVkSW5kZXhdKTtcbiAgICAgICAgICB0YWJFbGVtZW50c1tzZWxlY3RlZEluZGV4XS5mb2N1cygpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgICAgc2VsZWN0ZWRJbmRleCAtPSAxO1xuICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IHRhYnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZWN0VGFiKHRhYnNbc2VsZWN0ZWRJbmRleF0pO1xuICAgICAgICAgIHRhYkVsZW1lbnRzW3NlbGVjdGVkSW5kZXhdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInN2ZWx0ZS10YWJzXCIgb246a2V5ZG93bj17aGFuZGxlS2V5RG93bn0+XG4gIDxzbG90Pjwvc2xvdD5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCwgb25Nb3VudCwgdGljayB9IGZyb20gJ3N2ZWx0ZSc7XG5cbiAgaW1wb3J0IGdldElkIGZyb20gJy4vaWQnO1xuICBpbXBvcnQgeyBUQUJTIH0gZnJvbSAnLi9UYWJzLnN2ZWx0ZSc7XG5cbiAgbGV0IHRhYkVsO1xuXG4gIGNvbnN0IHRhYiA9IHtcbiAgICBpZDogZ2V0SWQoKVxuICB9O1xuICBjb25zdCB7IHJlZ2lzdGVyVGFiLCByZWdpc3RlclRhYkVsZW1lbnQsIHNlbGVjdFRhYiwgc2VsZWN0ZWRUYWIsIGNvbnRyb2xzIH0gPSBnZXRDb250ZXh0KFRBQlMpO1xuXG4gIGxldCBpc1NlbGVjdGVkO1xuICAkOiBpc1NlbGVjdGVkID0gJHNlbGVjdGVkVGFiID09PSB0YWI7XG5cbiAgcmVnaXN0ZXJUYWIodGFiKTtcblxuICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCB0aWNrKCk7XG4gICAgcmVnaXN0ZXJUYWJFbGVtZW50KHRhYkVsKTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXHQuc3ZlbHRlLXRhYnNfX3RhYiB7XG5cdFx0Ym9yZGVyOiBub25lO1xuXHRcdGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRjb2xvcjogIzAwMDAwMDtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgbGlzdC1zdHlsZTogbm9uZTtcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgcGFkZGluZzogMC41ZW0gMC43NWVtO1xuXHR9XG5cdFxuICAuc3ZlbHRlLXRhYnNfX3RhYjpmb2N1cyB7XG4gICAgb3V0bGluZTogdGhpbiBkb3R0ZWQ7XG4gIH1cblxuXHQuc3ZlbHRlLXRhYnNfX3NlbGVjdGVkIHtcblx0XHRib3JkZXItYm90dG9tOiAycHggc29saWQgIzRGODFFNTtcbiAgICBjb2xvcjogIzRGODFFNTtcblx0fVxuPC9zdHlsZT5cblxuPGxpXG4gIGJpbmQ6dGhpcz17dGFiRWx9XG4gIHJvbGU9XCJ0YWJcIlxuICBpZD17dGFiLmlkfVxuICBhcmlhLWNvbnRyb2xzPXskY29udHJvbHNbdGFiLmlkXX1cbiAgYXJpYS1zZWxlY3RlZD17aXNTZWxlY3RlZH1cbiAgdGFiaW5kZXg9XCJ7aXNTZWxlY3RlZCA/IDAgOiAtMX1cIlxuICBjbGFzczpzdmVsdGUtdGFic19fc2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gIGNsYXNzPVwic3ZlbHRlLXRhYnNfX3RhYlwiXG4gIG9uOmNsaWNrPXsoKSA9PiBzZWxlY3RUYWIodGFiKX0+XG5cdDxzbG90Pjwvc2xvdD5cbjwvbGk+XG4iLCI8c3R5bGU+XG5cdC5zdmVsdGUtdGFic19fdGFiLWxpc3Qge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjQ0NDQ0NDO1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuXHR9XG48L3N0eWxlPlxuXG48dWwgcm9sZT1cInRhYmxpc3RcIiBjbGFzcz1cInN2ZWx0ZS10YWJzX190YWItbGlzdFwiPlxuICA8c2xvdD48L3Nsb3Q+XG48L3VsPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cbiAgaW1wb3J0IGdldElkIGZyb20gJy4vaWQnO1xuICBpbXBvcnQgeyBUQUJTIH0gZnJvbSAnLi9UYWJzLnN2ZWx0ZSc7XG5cbiAgY29uc3QgcGFuZWwgPSB7XG4gICAgaWQ6IGdldElkKClcbiAgfTtcbiAgY29uc3QgeyByZWdpc3RlclBhbmVsLCBzZWxlY3RlZFBhbmVsLCBsYWJlbGVkQnkgfSA9IGdldENvbnRleHQoVEFCUyk7XG5cbiAgcmVnaXN0ZXJQYW5lbChwYW5lbCk7XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICAuc3ZlbHRlLXRhYnNfX3RhYi1wYW5lbCB7XG4gICAgbWFyZ2luLXRvcDogMC41ZW07XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXYgXG4gIGlkPXtwYW5lbC5pZH1cbiAgYXJpYS1sYWJlbGxlZGJ5PXskbGFiZWxlZEJ5W3BhbmVsLmlkXX1cbiAgY2xhc3M9XCJzdmVsdGUtdGFic19fdGFiLXBhbmVsXCJcbiAgcm9sZT1cInRhYnBhbmVsXCI+XG4gIHsjaWYgJHNlbGVjdGVkUGFuZWwgPT09IHBhbmVsfVxuICAgIDxzbG90Pjwvc2xvdD5cbiAgey9pZn1cbjwvZGl2PlxuIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDQ0OCA1MTJcXFwiPjwhLS0gRm9udCBBd2Vzb21lIEZyZWUgNS4xNS40IGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgKEljb25zOiBDQyBCWSA0LjAsIEZvbnRzOiBTSUwgT0ZMIDEuMSwgQ29kZTogTUlUIExpY2Vuc2UpIC0tPjxwYXRoIGQ9XFxcIk02NCAyMjRoMTMuNWMyNC43IDU2LjUgODAuOSA5NiAxNDYuNSA5NnMxMjEuOC0zOS41IDE0Ni41LTk2SDM4NGM4LjggMCAxNi03LjIgMTYtMTZ2LTk2YzAtOC44LTcuMi0xNi0xNi0xNmgtMTMuNUMzNDUuOCAzOS41IDI4OS42IDAgMjI0IDBTMTAyLjIgMzkuNSA3Ny41IDk2SDY0Yy04LjggMC0xNiA3LjItMTYgMTZ2OTZjMCA4LjggNy4yIDE2IDE2IDE2em00MC04OGMwLTIyLjEgMjEuNS00MCA0OC00MGgxNDRjMjYuNSAwIDQ4IDE3LjkgNDggNDB2MjRjMCA1My00MyA5Ni05NiA5NmgtNDhjLTUzIDAtOTYtNDMtOTYtOTZ2LTI0em03MiA3MmwxMi0zNiAzNi0xMi0zNi0xMi0xMi0zNi0xMiAzNi0zNiAxMiAzNiAxMiAxMiAzNnptMTUxLjYgMTEzLjRDMjk3LjcgMzQwLjcgMjYyLjIgMzUyIDIyNCAzNTJzLTczLjctMTEuMy0xMDMuNi0zMC42QzUyLjkgMzI4LjUgMCAzODUgMCA0NTQuNHY5LjZjMCAyNi41IDIxLjUgNDggNDggNDhoODB2LTY0YzAtMTcuNyAxNC4zLTMyIDMyLTMyaDEyOGMxNy43IDAgMzIgMTQuMyAzMiAzMnY2NGg4MGMyNi41IDAgNDgtMjEuNSA0OC00OHYtOS42YzAtNjkuNC01Mi45LTEyNS45LTEyMC40LTEzM3pNMjcyIDQ0OGMtOC44IDAtMTYgNy4yLTE2IDE2czcuMiAxNiAxNiAxNiAxNi03LjIgMTYtMTYtNy4yLTE2LTE2LTE2em0tOTYgMGMtOC44IDAtMTYgNy4yLTE2IDE2djQ4aDMydi00OGMwLTguOC03LjItMTYtMTYtMTZ6XFxcIi8+PC9zdmc+XCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXG5cdGltcG9ydCBTWF9JQ09OX0FTVFJPTkFVVCBmcm9tICcjL2ljb24vdXNlci1hc3Ryb25hdXQuc3ZnP3Jhdyc7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBUaHJlYWRJZCB9IGZyb20gJy4uL2RlZic7XG5cdGltcG9ydCB7IHl3X25hdmlnYXRvciB9IGZyb20gJy4uL21lbSc7XG5cdGltcG9ydCB0eXBlIHsgUGFnZSB9IGZyb20gJy4uL25hdi9wYWdlJztcblx0aW1wb3J0IHsgU2NyZWVuLCBIZWFkZXIgfSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRleHBvcnQgbGV0IHJlc2V0ID0gZmFsc2U7XG5cdGNvbnN0IGJfcmVzZXQgPSByZXNldDtcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0ZnVuY3Rpb24gY29udCgpIHtcblx0XHRpZihiX3Jlc2V0KSB7XG5cdFx0XHRrX3BhZ2UucmVzZXQoKTtcblx0XHRcdHZvaWQgJHl3X25hdmlnYXRvci5hY3RpdmF0ZVRocmVhZChUaHJlYWRJZC5UT0tFTlMpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGtfcGFnZS5wb3AoKTtcblx0XHR9XG5cdH1cblx0PC9zY3JpcHQ+XG5cdFxuXHQ8c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0XHQuaWNvbiB7XG5cdFx0XHRwYWRkaW5nLXRvcDogMjUlO1xuXHRcdH1cblx0PC9zdHlsZT5cblx0XG5cdDxTY3JlZW4+XG5cdFx0PEhlYWRlciBwb3BzXG5cdFx0XHR0aXRsZT1cIk5vdCB5ZXQgYXZhaWxhYmxlXCJcblx0XHQvPlxuXHRcblx0XHQ8aDM+XG5cdFx0XHROb3RoaW5nIHRvIHNlZSBoZXJlIVxuXHRcdDwvaDM+XG5cdFxuXHRcdDxwPlxuXHRcdFx0VGhpcyBzY3JlZW4gaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC5cblx0XHQ8L3A+XG5cdFxuXHRcdDxwPlxuXHRcdFx0UGxlYXNlIGNvbnRpbnVlIGV4cGxvcmluZyB0aGUgYmV0YS5cblx0XHQ8L3A+XG5cdFxuXHRcdDxjZW50ZXI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0e0BodG1sIFNYX0lDT05fQVNUUk9OQVVUfVxuXHRcdFx0PC9zcGFuPlxuXHRcdDwvY2VudGVyPlxuXHRcblx0XHQ8ZGl2IGNsYXNzPVwiYWN0aW9uLWxpbmVcIj5cblx0XHRcdDxidXR0b24gY2xhc3M9XCJwcmltYXJ5XCIgb246Y2xpY2s9eygpID0+IGNvbnQoKX0+XG5cdFx0XHRcdENvbnRpbnVlXG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQ8L2Rpdj5cblx0PC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHt5d19hY2NvdW50LCB5d19jaGFpbn0gZnJvbSAnIyMvbWVtJztcblx0aW1wb3J0IHR5cGUgeyBDb250YWN0LCBDb250YWN0UGF0aCB9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHsgQWdlbnRzIH0gZnJvbSAnIy9zdG9yZS9hZ2VudHMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRcblx0aW1wb3J0IHsgSGVhZGVyLCB0eXBlIFBhZ2UsIFNjcmVlbiB9IGZyb20gJy4uL3NjcmVlbi9fc2NyZWVucyc7XG5cdGltcG9ydCBBZGRyZXNzIGZyb20gJyMjL3VpL0FkZHJlc3Muc3ZlbHRlJztcblx0aW1wb3J0IFBvcnRyYWl0IGZyb20gJyMjL3VpL1BvcnRyYWl0LnN2ZWx0ZSc7XG5cdGltcG9ydCBTZW5kIGZyb20gJyMjL3NjcmVlbi9TZW5kLnN2ZWx0ZSc7XG5cdC8vIGltcG9ydCBUeG5MaXN0LCB7IFR4bkNvbnRleHQgfSBmcm9tICcjIy91aS9UeG5MaXN0LnN2ZWx0ZSc7XG5cdGltcG9ydCBDb250YWN0RWRpdCBmcm9tICcuL0NvbnRhY3RFZGl0LnN2ZWx0ZSc7XG5cdGltcG9ydCBEZWFkRW5kIGZyb20gJy4vRGVhZEVuZC5zdmVsdGUnO1xuXG5cblx0ZXhwb3J0IGxldCBjb250YWN0UmVmOiBDb250YWN0UGF0aDtcblx0Y29uc3QgcF9jb250YWN0ID0gY29udGFjdFJlZjtcblxuXHRsZXQgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXTtcblx0dm9pZCBBZ2VudHMuZ2V0Q29udGFjdChwX2NvbnRhY3QpLnRoZW4oZyA9PiBnX2NvbnRhY3QgPSBnISk7XG5cblx0JDogc2FfY29udGFjdCA9IGdfY29udGFjdD8gQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcyk6ICcnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRjb25zdCBnY19hY3Rpb25zID0ge1xuXHRcdHNlbmQ6IHtcblx0XHRcdGxhYmVsOiAnU2VuZCcsXG5cdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogU2VuZCxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0dG86IENoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MpLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRcdGVkaXQ6IHtcblx0XHRcdGxhYmVsOiAnRWRpdCcsXG5cdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogQ29udGFjdEVkaXQsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdGNvbnRhY3RSZWY6IHBfY29udGFjdCxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHRkZWxldGU6IHtcblx0XHRcdGxhYmVsOiAnRGVsZXRlJyxcblx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBEZWFkRW5kLFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0fTtcblxuXHQvLyAkOiBhX3R4bnMgPSBBX1RYTlMuZmlsdGVyKChrX3R4bikgPT4ge1xuXHQvLyBcdGNvbnN0IGdkX3R4biA9IGtfdHhuLmRlZjtcblxuXHQvLyBcdGlmKHNhX2NvbnRhY3QgPT09IGdkX3R4bi5hZGRyZXNzKSByZXR1cm4gdHJ1ZTtcblxuXHQvLyBcdGNvbnN0IGdfYmFua2lzaCA9IGtfdHhuLmJhbmtpc2goJHl3X2FjY291bnQuYWRkcmVzcygkeXdfY2hhaW4pKTtcblx0Ly8gXHRpZihnX2Jhbmtpc2gpIHtcblx0Ly8gXHRcdHJldHVybiBzYV9jb250YWN0ID09PSBnX2Jhbmtpc2guYWRkcmVzcztcblx0Ly8gXHR9XG5cblx0Ly8gXHRyZXR1cm4gZmFsc2U7XG5cdC8vIH0pO1xuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJ19iYXNlLmxlc3MnO1xuXG5cblx0LnBmcC1nZW4ge1xuXHRcdC5mb250KGh1Z2UsIEBzaXplOiAzMHB4KTtcblx0XHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRib3JkZXItcmFkaXVzOiAyMCU7XG5cdFx0b3V0bGluZTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdGJhY2tncm91bmQ6IHJhZGlhbC1ncmFkaWVudChlbGxpcHNlIGZhcnRoZXN0LXNpZGUgYXQgYm90dG9tIHJpZ2h0LCAjMDcwODBhLCAjMGYxMzE3KTtcblx0fVxuPC9zdHlsZT5cblxuXG48U2NyZWVuIG5hdiBzbGlkZXM+XG5cdDxIZWFkZXIgcG9wcyBzZWFyY2ggbmV0d29yayBhY2NvdW50IC8+XG5cblx0eyNpZiAhZ19jb250YWN0fVxuXHRcdExvYWRpbmcgY29udGFjdC4uLlxuXHR7OmVsc2V9XG5cdFx0PFBvcnRyYWl0XG5cdFx0XHRyZXNvdXJjZT17Z19jb250YWN0fVxuXHRcdFx0cmVzb3VyY2VQYXRoPXtwX2NvbnRhY3R9XG5cdFx0XHRhY3Rpb25zPXtnY19hY3Rpb25zfVxuXHRcdD5cblx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInN1YnRpdGxlXCI+XG5cdFx0XHRcdDxBZGRyZXNzIGNvcHlhYmxlIGFkZHJlc3M9e0NoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MpfSAvPlxuXHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+YWRkcmVzc1xuXHRcdDwvUG9ydHJhaXQ+XG48IS0tIFxuXHRcdDxUeG5MaXN0XG5cdFx0XHRjb250ZXh0PXtUeG5Db250ZXh0LkNPTlRBQ1R9XG5cdFx0XHR0eG5zPXthX3R4bnN9XG5cdFx0Lz4gLS0+XG5cdDwhLS0gXG5cdFx0PGRpdiBjbGFzcz1cInR4bnMgbm8tbWFyZ2luXCI+XG5cdFx0XHR7I2lmICFhX3R4bnMubGVuZ3RofVxuXHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdE5vIHRyYW5zYWN0aW9ucyB5ZXRcblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXG5cdFx0XHR7I2VhY2ggYV90eG5zIGFzIGtfdHhufVxuXHRcdFx0XHR7QGNvbnN0IGdkX3R4biA9IGtfdHhuLmRlZn1cblx0XHRcdFx0e0Bjb25zdCBrX3Rva2VuID0gSF9BRERSRVNTX1RPX1RPS0VOW2tfdHhuLmRlZi5hZGRyZXNzXX1cblx0XHRcdFx0e0Bjb25zdCBnX2Jhbmtpc2ggPSBrX3R4bi5iYW5raXNoKCR5d19hY2NvdW50LmFkZHJlc3MoJHl3X2NoYWluKSl9XG5cdFx0XHRcdHtAY29uc3QgYV9kZWJ1ZyA9IFtnX2Jhbmtpc2gsIGtfdHhuXX1cblx0XHRcdFx0PC8hLS0ge0BkZWJ1ZyBhX2RlYnVnfSAtLS8+XG5cblx0XHRcdFx0eyNpZiBUeG4uVHlwZS5SRUNWID09PSBnZF90eG4udHlwZX1cblx0XHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0XHRuYW1lPVwiUmVjZWl2ZWQgU0NSVFwiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdDwvUm93PlxuXHRcdFx0XHRcdDwvIS0tIGFwcHJveChnZF90eG4uYW1vdW50KSAtLS8+XG5cdFx0XHRcdHs6ZWxzZSBpZiBUeG4uVHlwZS5TRU5EID09PSBnZF90eG4udHlwZX1cblx0XHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0XHRuYW1lPVwiU2VudCBTQ1JUXCJcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0PC9Sb3c+XG5cdFx0XHRcdHsvaWZ9XG5cdFx0XHR7L2VhY2h9XG5cdFx0PC9kaXY+IC0tPlxuXHR7L2lmfVxuXG48L1NjcmVlbj4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIk0xOSA1djE0SDVWNWgxNG0wLTJINWMtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0tNC44NiA4Ljg2LTMgMy44N0w5IDEzLjE0IDYgMTdoMTJsLTMuODYtNS4xNHpcXFwiLz5cXG48L3N2Zz5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCBTWF9JQ09OX0lNQUdFIGZyb20gJyMvaWNvbi9pbWFnZS5zdmc/cmF3Jztcblx0aW1wb3J0IHR5cGUgeyBQZnAsIFBmcFBhdGggfSBmcm9tICcjL21ldGEvcGZwJztcblx0aW1wb3J0IHsgUGZwcyB9IGZyb20gJyMvc3RvcmUvcGZwcyc7XG5cdGltcG9ydCB7IEZfTk9PUCB9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXHRpbXBvcnQgUGZwRGlzcGxheSBmcm9tICcuL1BmcERpc3BsYXkuc3ZlbHRlJztcblx0XG5cdGV4cG9ydCBsZXQgcGZwUmVmOiAnJyB8IFBmcFBhdGg7XG5cdGNvbnN0IHBfcGZwID0gcGZwUmVmIHx8ICcnO1xuXG5cdGV4cG9ydCBsZXQgbmFtZSA9ICcnO1xuXHRjb25zdCBzX25hbWUgPSBuYW1lO1xuXG5cdGV4cG9ydCBsZXQgaW50ZW50OiAndG9rZW4nIHwgJ3BlcnNvbicgPSAndG9rZW4nO1xuXHRjb25zdCBzaV9pbnRlbnQgPSBpbnRlbnQ7XG5cblx0bGV0IGdfcGZwOiBQZnBbJ2ludGVyZmFjZSddO1xuXG5cdChhc3luYygpID0+IHtcblx0XHRpZihwX3BmcCkge1xuXHRcdFx0Z19wZnAgPSAoYXdhaXQgUGZwcy5hdChwX3BmcCkpITtcblx0XHR9XG5cdH0pKCk7XG5cblx0Ly8gY29uc3QgcF9pY29uID0gaWNvblJlZiB8fCBJY29uLkRlZi5CTEFOSy5pcmk7XG5cblx0Ly8gY29uc3Qga19pY29uID0gcF9pY29uPyBIX0lDT05TW3BfaWNvbl06IEljb24uQkxBTks7XG48L3NjcmlwdD5cblx0XG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQuYXJlYSB7XG5cdFx0Ym9yZGVyOiAxcHggZGFzaGVkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0Ym9yZGVyLXJhZGl1czogNHB4O1xuXG5cdFx0Pi5yb3cge1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0XHRcdG1hcmdpbjogdmFyKC0tdWktcGFkZGluZyk7XG5cblx0XHRcdD4qIHtcblx0XHRcdFx0ZmxleDogYXV0bztcblx0XHRcdH1cblxuXHRcdFx0Pi5sZWZ0IHtcblx0XHRcdFx0ZmxleDogMTtcblxuXHRcdFx0XHQ+Lmljb24ucGZwIHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdC0tYnV0dG9uLWRpYW1ldGVyOiA2NHB4O1xuXHRcdFx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiA2NHB4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQ+LnJpZ2h0IHtcblx0XHRcdFx0ZmxleDogMztcblx0XHRcdFx0cGFkZGluZzogMCBjYWxjKHZhcigtLXVpLXBhZGRpbmcpIC8gMik7XG5cdFx0XHRcdG1hcmdpbi10b3A6IC00cHg7XG5cdFx0XHRcdC8vIHBhZGRpbmctdG9wOiBjYWxjKHZhcigtLXVpLXBhZGRpbmcpIC8gMS41KTtcblxuXHRcdFx0XHQ+LmRpc2NsYWltZXIge1xuXHRcdFx0XHRcdC5mb250KHRpbnkpO1xuXG5cdFx0XHRcdFx0Pi53YXJuaW5nIHtcblx0XHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1jYXV0aW9uKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+LmluZm8ge1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHBhZGRpbmctYm90dG9tOiAyMHB4O1xuXG5cdFx0XHQuYWN0aW9ucyB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0bWFyZ2luLXRvcDogNHB4O1xuXG5cdFx0XHRcdC8vIHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cdFx0XHRcdC8vIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdFx0Ly8gbWFyZ2luLXRvcDogNHB4O1xuXHRcdFx0XHQvLyBtYXJnaW4tbGVmdDogLTRweDtcblxuXHRcdFx0XHQ+KiB7XG5cdFx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXG5cdFx0XHRcdFx0Jjpob3ZlciB7XG5cdFx0XHRcdFx0XHQ+LnRleHQge1xuXHRcdFx0XHRcdFx0XHR0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+KiB7XG5cdFx0XHRcdFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdD4uaWNvbiB7XG5cdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyMHB4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImFyZWFcIiBjbGFzczppbnRlbnQtcGVyc29uPXsncGVyc29uJyA9PT0gc2lfaW50ZW50fT5cblx0PGRpdiBjbGFzcz1cInJvd1wiPlxuXHRcdDxzcGFuIGNsYXNzPVwibGVmdFwiPlxuXHRcdFx0PCEtLSA8c3BhbiBjbGFzcz1cImljb24gcGZwXCIgY2xhc3M6c3F1YXJlPXsncGVyc29uJyA9PT0gaW50ZW50fT5cblx0XHRcdFx0PFB1dCBlbGVtZW50PXtIX0lDT05TW3BfaWNvbl0ucmVuZGVyKCl9IC8+XG5cdFx0XHQ8L3NwYW4+IC0tPlxuXHRcdFx0eyNpZiBwX3BmcH1cblx0XHRcdFx0PFBmcERpc3BsYXkgZGltPXs0OH0gcmVmPXtwX3BmcH0gbmFtZT17c19uYW1lfSAvPlxuXHRcdFx0ey9pZn1cblx0XHRcdDwhLS0gPFBmcERpc3BsYXkgYmluZDppY29uUmVmPXtpY29uUmVmfSBiaW5kOm5hbWU9e25hbWV9IC8+IC0tPlxuXHRcdDwvc3Bhbj5cblxuXHRcdDxzcGFuIGNsYXNzPVwicmlnaHRcIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJkaXNjbGFpbWVyXCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwid2FybmluZ1wiPlxuXHRcdFx0XHRcdE5vdGljZTpcblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHRVcGxvYWRlZCBpY29ucyB3aWxsIGJlIHJlc2l6ZWQgdG8gYmUgc3F1YXJlLiBPbmx5IEpQRyAmIFBORyBmaWxlcyBsZXNzIHRoYW4gMU1CIGFsbG93ZWQuXG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IGNsYXNzPVwiYWN0aW9uc1wiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwidXBsb2FkXCIgb246Y2xpY2s9eygpID0+IEZfTk9PUH0+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9JTUFHRX1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdFx0XHRVcGxvYWQgSWNvblxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L3NwYW4+XG5cdDwvZGl2PlxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge2dldENvbnRleHQsIFN2ZWx0ZUNvbXBvbmVudH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHttaWNyb3Rhc2ssIG9kZSwgb2ZlLCBwcm9wZXJ9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXHRpbXBvcnQgeyBDb250YWN0LCBDb250YWN0QWdlbnRUeXBlLCBDb250YWN0UGF0aCB9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHsgQWdlbnRzIH0gZnJvbSAnIy9zdG9yZS9hZ2VudHMnO1xuXHRpbXBvcnQgdHlwZSB7IFBhZ2UgfSBmcm9tICcuLi9uYXYvcGFnZSc7XG5cdGltcG9ydCB7IHl3X2NoYWluLCB5d19mYW1pbHkgfSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IFJfQkVDSDMyIH0gZnJvbSAnIy9zaGFyZS9jb25zdGFudHMnO1xuXHRpbXBvcnQgeyBUYWdzIH0gZnJvbSAnIy9zdG9yZS90YWdzJztcblx0aW1wb3J0IHsgSGVhZGVyLCBTY3JlZW4gfSBmcm9tICcuL19zY3JlZW5zJztcblx0aW1wb3J0IENvbnRhY3RWaWV3IGZyb20gJy4vQ29udGFjdFZpZXcuc3ZlbHRlJztcblx0aW1wb3J0IEZpZWxkIGZyb20gJy4uL3VpL0ZpZWxkLnN2ZWx0ZSc7XG5cdGltcG9ydCBJbmZvIGZyb20gJy4uL3VpL0luZm8uc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBDaGFpbiwgQ2hhaW5QYXRoIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IElubGluZVRhZ3MgZnJvbSAnLi4vdWkvSW5saW5lVGFncy5zdmVsdGUnO1xuXHRpbXBvcnQgSWNvbkVkaXRvciBmcm9tICcuLi91aS9JY29uRWRpdG9yLnN2ZWx0ZSc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8qKlxuXHQgKiBDb250YWN0IHJlc291cmNlIHBhdGhcblx0ICovXG5cdGV4cG9ydCBsZXQgY29udGFjdFJlZjogQ29udGFjdFBhdGggfCAnJyA9ICcnO1xuXHRjb25zdCBwX2NvbnRhY3QgPSBjb250YWN0UmVmIHx8ICcnO1xuXG5cdC8vIHByZXAgb2JqZWN0IHBsYWNlaG9sZGVyXG5cdGxldCBnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddO1xuXG5cdC8vIHBhdGggd2FzIGdpdmVuOyBsb2FkIGNvbnRhY3Rcblx0aWYocF9jb250YWN0KSB2b2lkIEFnZW50cy5nZXRDb250YWN0KHBfY29udGFjdCkudGhlbihnID0+IGdfY29udGFjdCA9IGchKTtcblxuXHQvLyBsb2FkIGFsbCBjaGFpbnNcblx0bGV0IGhfY2hhaW5zOiBSZWNvcmQ8Q2hhaW5QYXRoLCBDaGFpblsnaW50ZXJmYWNlJ10+ID0ge307XG5cdChhc3luYyBmdW5jdGlvbiBsb2FkX2NoYWlucygpIHtcblx0XHRoX2NoYWlucyA9IG9mZSgoYXdhaXQgQ2hhaW5zLnJlYWQoKSkuZW50cmllcygpKTtcblx0fSkoKTtcblxuXHQvLyByZWFjdGl2ZWx5IGRlc3RydWN0dXJlIGNvbnRhY3QncyBwcm9wZXJ0aWVzXG5cdCQ6IHNfbmFtZSA9IGdfY29udGFjdD8ubmFtZSB8fCAnJztcblx0JDogc19hZGRyID0gZ19jb250YWN0Py5hZGRyZXNzIHx8ICcnO1xuXHQkOiBzYV9iZWNoMzIgPSBzX2FkZHI/IENoYWlucy5iZWNoMzIoc19hZGRyIGFzIHN0cmluZyk6ICcnO1xuXHQkOiBzX25vdGVzID0gZ19jb250YWN0Py5ub3RlcyB8fCAnJztcblx0JDogc2lfYWdlbnRfdHlwZSA9IGdfY29udGFjdD8uYWdlbnRUeXBlIHx8IENvbnRhY3RBZ2VudFR5cGUuUEVSU09OO1xuXG5cdGxldCBzX2Vycl9uYW1lID0gJyc7XG5cdGxldCBzX2Vycl9hZGRyZXNzID0gJyc7XG5cblx0ZnVuY3Rpb24gcHVia2V5X2Zyb21fYWRkcihzYV9hZGRyZXNzOiBzdHJpbmcsIGJfc2hvd19lcnI9ZmFsc2UpOiBzdHJpbmcge1xuXHRcdGNvbnN0IG1fYmVjaCA9IFJfQkVDSDMyLmV4ZWMoc2FfYWRkcmVzcyk7XG5cdFx0aWYoIW1fYmVjaCkge1xuXHRcdFx0aWYoYl9zaG93X2Vycikge1xuXHRcdFx0XHRzX2Vycl9hZGRyZXNzID0gJ0ludmFsaWQgQmVjaDMyIGFkZHJlc3MnO1xuXHRcdFx0fVxuXHRcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRjb25zdCBbLCBzX2NoYWluLCBzX3B1YmtleV9sb2NhbF0gPSBtX2JlY2g7XG5cblx0XHRsZXQga19jaGFpbl9tYXRjaCA9IG51bGw7XG5cdFx0Zm9yKGNvbnN0IFssIGtfY2hhaW5dIG9mIG9kZShIX0NIQUlOUykpIHtcblx0XHRcdGlmKGtfY2hhaW4uZGVmLmJlY2hQcmVmaXggPT09IHNfY2hhaW4pIHtcblx0XHRcdFx0a19jaGFpbl9tYXRjaCA9IGtfY2hhaW47XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKGJfc2hvd19lcnIpIHtcblx0XHRcdGlmKCFrX2NoYWluX21hdGNoKSB7XG5cdFx0XHRcdHNfZXJyX2FkZHJlc3MgPSBgTm8gQ29zbW9zIFNESyBjaGFpbnMgbWF0Y2hlZCAnJHtzX2NoYWlufSdgO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNfZXJyX2FkZHJlc3MgPSAnJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc19hZGRyID0gc19wdWJrZXlfbG9jYWw7XG5cdH1cblxuXHQkOiBiX2Zvcm1fdmFsaWQgPSAhIShzX25hbWUgJiYgcHVia2V5X2Zyb21fYWRkcihzYV9iZWNoMzIpKTtcblx0bGV0IGNfc2hvd192YWxpZGF0aW9ucyA9IDA7XG5cblx0JDoge1xuXHRcdGlmKGNfc2hvd192YWxpZGF0aW9ucykge1xuXHRcdFx0c19lcnJfbmFtZSA9IHNfbmFtZT8gJyc6ICdOYW1lIG11c3Qgbm90IGJlIGVtcHR5Jztcblx0XHRcdHB1YmtleV9mcm9tX2FkZHIoc2FfYmVjaDMyLCB0cnVlKTtcblx0XHR9XG5cdH1cblxuXHRsZXQgYl9idXN5ID0gZmFsc2U7XG5cblx0bGV0IHlfc2NyZWVuOiBTdmVsdGVDb21wb25lbnQ7XG5cdGFzeW5jIGZ1bmN0aW9uIHNhdmUoKSB7XG5cdFx0aWYoIWJfZm9ybV92YWxpZCkge1xuXHRcdFx0Y19zaG93X3ZhbGlkYXRpb25zKys7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZWxzZSBpZihwX2NvbnRhY3QpIHtcblx0XHRcdE9iamVjdC5hc3NpZ24oZ19jb250YWN0LCB7XG5cdFx0XHRcdG5hbWU6IHNfbmFtZSxcblx0XHRcdFx0YWRkcmVzczogc19hZGRyLFxuXHRcdFx0XHRwZnA6IGdfY29udGFjdC5wZnAsXG5cdFx0XHRcdGFnZW50VHlwZTogc2lfYWdlbnRfdHlwZSxcblx0XHRcdFx0bm90ZXM6IHNfbm90ZXMsXG5cdFx0XHR9KTtcblxuXHRcdFx0a19wYWdlLnJlc2V0KCk7XG5cdFx0XHQvLyBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdC8vIFx0dHJ5IHtcblx0XHRcdC8vIFx0XHR5X3NjcmVlbi4kZGVzdHJveSgpO1xuXHRcdFx0Ly8gXHR9XG5cdFx0XHQvLyBcdGNhdGNoKGUpIHt9XG5cdFxuXHRcdFx0Ly8gXHRjb250YWN0ID0gSF9DT05UQUNUU1tjb250YWN0LmRlZi5pcmldO1xuXHRcdFx0Ly8gXHRwdXNoX3NjcmVlbihDb250YWN0Vmlldywge1xuXHRcdFx0Ly8gXHRcdGNvbnRhY3QsXG5cdFx0XHQvLyBcdH0pO1xuXHRcdFx0Ly8gfSwgNSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Z19jb250YWN0ID0ge1xuXHRcdFx0XHRuYW1lOiBzX25hbWUsXG5cdFx0XHRcdGZhbWlseTogJHl3X2ZhbWlseSxcblx0XHRcdFx0YWRkcmVzczogc19hZGRyLFxuXHRcdFx0XHRwZnA6IGdfY29udGFjdC5wZnAsXG5cdFx0XHRcdGFnZW50VHlwZTogc2lfYWdlbnRfdHlwZSxcblx0XHRcdFx0bm90ZXM6IHNfbm90ZXMsXG5cdFx0XHRcdHNwYWNlOiAnYWNjJyxcblx0XHRcdFx0b3JpZ2luOiAndXNlcicsXG5cdFx0XHRcdGNoYWluczoge30sXG5cdFx0XHR9O1xuXHRcdH1cblxuXG5cdFx0Yl9idXN5ID0gdHJ1ZTtcblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgQWdlbnRzLm9wZW4oYXN5bmMoa3NfYWdlbnRzKSA9PiB7XG5cdFx0XHRcdGF3YWl0IGtzX2FnZW50cy5wdXRDb250YWN0KGdfY29udGFjdCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0a19wYWdlLnJlc2V0KCk7XG5cblx0XHRcdC8vIGltbWVkaWF0ZWx5IG9wZW4gbmV3IGNvbnRhY3Rcblx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0Y3JlYXRvcjogQ29udGFjdFZpZXcsXG5cdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0Y29udGFjdFJlZjogcF9jb250YWN0LFxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGNhdGNoKGVfd3JpdGUpIHtcblx0XHRcdGJfYnVzeSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIGxldCBwX2ljb246IEljb24uUmVmID0gY29udGFjdD8uZGVmLmljb25SZWYgfHwgJycgYXMgSWNvbi5SZWY7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0I2NoYWluLWZhbWlseSB7XG5cdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRmbGV4OiAxO1xuXHRcdFx0YWxpZ24taXRlbXM6IGJhc2VsaW5lO1xuXHRcdFx0LmZvbnQodGlueSk7XG5cdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48U2NyZWVuIGJpbmQ6dGhpcz17eV9zY3JlZW59IGxlYXZlcz5cblx0PEhlYWRlclxuXHRcdHBsYWluIHBvcHNcblx0XHR0aXRsZT1cIntwX2NvbnRhY3Q/ICdFZGl0JzogJ0FkZCBOZXcnfSBDb250YWN0XCJcblx0Lz5cblxuXHQ8RmllbGRcblx0XHRrZXk9XCJjb250YWN0LXBmcFwiXG5cdFx0bmFtZT1cIlByb2ZpbGUgSWNvblwiXG5cdD5cblx0XHQ8SWNvbkVkaXRvciBpbnRlbnQ9J3BlcnNvbicgcGZwUmVmPXtnX2NvbnRhY3Q/LnBmcH0gYmluZDpuYW1lPXtzX25hbWV9IC8+XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkXG5cdFx0a2V5PVwiY2hhaW4tZmFtaWx5XCJcblx0XHRuYW1lPVwiQ2hhaW4gRmFtaWx5XCJcblx0PlxuXHRcdDxJbmZvIGtleT1cImNoYWluLWZhbWlseVwiPlxuXHRcdFx0PHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdFx0XHRcdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0XHRcdFx0LnRpdGxlIHtcblx0XHRcdFx0XHQuZm9udChyZWd1bGFyKTtcblx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQuZXhhbXBsZXMge1xuXHRcdFx0XHRcdG1hcmdpbi1sZWZ0OiAwLjVlbTtcblx0XHRcdFx0fVxuXHRcdFx0PC9zdHlsZT5cblxuXHRcdFx0PHNwYW4gY2xhc3M9XCJ0aXRsZVwiPlxuXHRcdFx0XHR7cHJvcGVyKCR5d19mYW1pbHkpfVxuXHRcdFx0PC9zcGFuPlxuXG5cdFx0XHQ8c3BhbiBjbGFzcz1cImV4YW1wbGVzXCI+XG5cdFx0XHRcdCh7b2RlKGhfY2hhaW5zKS5maWx0ZXIoKFssIGddKSA9PiAkeXdfZmFtaWx5ID09PSBnLmZhbWlseSkubWFwKChbLCBnXSkgPT4gZy5iZWNoMzJzLmFjYy5ocnApLmpvaW4oJywgJyl9KVxuXHRcdFx0PC9zcGFuPlxuXHRcdDwvSW5mbz5cblx0PC9GaWVsZD5cblxuXG5cdDxGaWVsZFxuXHRcdGtleT1cImNvbnRhY3QtbmFtZVwiXG5cdFx0bmFtZT1cIk5hbWVcIlxuXHQ+XG5cdFx0PGlucHV0IGNsYXNzOmludmFsaWQ9e3NfZXJyX25hbWV9IHR5cGU9XCJ0ZXh0XCIgc3BlbGxjaGVjaz1cImZhbHNlXCIgYmluZDp2YWx1ZT17c19uYW1lfSBwbGFjZWhvbGRlcj1cIkVudGVyIGEgbmFtZVwiPlxuXG5cdFx0eyNpZiBzX2Vycl9uYW1lfVxuXHRcdFx0PHNwYW4gY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIj5cblx0XHRcdFx0e3NfZXJyX25hbWV9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0ey9pZn1cblx0PC9GaWVsZD5cblxuXHQ8RmllbGRcblx0XHRrZXk9XCJjb250YWN0LWFkZHJlc3NcIlxuXHRcdG5hbWU9XCJBZGRyZXNzXCJcblx0PlxuXHRcdDxpbnB1dFxuXHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0Y2xhc3M9XCJhZGRyZXNzXCJcblx0XHRcdGNsYXNzOmludmFsaWQ9e3NfZXJyX2FkZHJlc3N9XG5cdFx0XHRzcGVsbGNoZWNrPVwiZmFsc2VcIlxuXHRcdFx0cGxhY2Vob2xkZXI9XCJ7JHl3X2NoYWluLmJlY2gzMnMuYWNjfTEuLi5cIlxuXHRcdFx0YmluZDp2YWx1ZT17c2FfYmVjaDMyfVxuXHRcdD5cblxuXHRcdHsjaWYgc19lcnJfYWRkcmVzc31cblx0XHRcdDxzcGFuIGNsYXNzPVwidmFsaWRhdGlvbi1tZXNzYWdlXCI+XG5cdFx0XHRcdHtzX2Vycl9hZGRyZXNzfVxuXHRcdFx0PC9zcGFuPlxuXHRcdHsvaWZ9XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkXG5cdFx0a2V5PVwiY29udGFjdC1ub3Rlc1wiXG5cdFx0bmFtZT1cIlNlY3VyZSBOb3Rlc1wiXG5cdD5cblx0XHQ8dGV4dGFyZWEgYmluZDp2YWx1ZT17c19ub3Rlc30gcGxhY2Vob2xkZXI9XCJcIj48L3RleHRhcmVhPlxuXHQ8L0ZpZWxkPlxuXG5cdDxocj5cblxuXHQ8aDM+XG5cdFx0e3BfY29udGFjdD8gJ0VkaXQnOiAnQWRkJ30gVGFnc1xuXHQ8L2gzPlxuXG5cdDxJbmxpbmVUYWdzIGVkaXRhYmxlIHJlc291cmNlUGF0aD17cF9jb250YWN0fSAvPlxuXG5cdDxkaXYgY2xhc3M9XCJhY3Rpb24tbGluZVwiPlxuXHRcdDxidXR0b24gb246Y2xpY2s9eygpID0+IGtfcGFnZS5wb3AoKX0+XG5cdFx0XHRCYWNrXG5cdFx0PC9idXR0b24+XG5cblx0XHQ8YnV0dG9uIGNsYXNzPVwicHJpbWFyeVwiIG9uOmNsaWNrPXsoKSA9PiBzYXZlKCl9IHJlYWRvbmx5PXshYl9mb3JtX3ZhbGlkfT5cblx0XHRcdHtwX2NvbnRhY3Q/ICdTYXZlJzogJ0FkZCd9XG5cdFx0PC9idXR0b24+XG5cdDwvZGl2PlxuPC9TY3JlZW4+IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+XFxuXFx0XFx0LnMyci1tb3JlLXZlcnQtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0PC9zdHlsZT5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLW1vcmUtdmVydC1mZ1xcXCIgZD1cXFwiTTEyIDhDMTMuMSA4IDE0IDcuMSAxNCA2QzE0IDQuOSAxMy4xIDQgMTIgNEMxMC45IDQgMTAgNC45IDEwIDZDMTAgNy4xIDEwLjkgOCAxMiA4Wk0xMiAxMEMxMC45IDEwIDEwIDEwLjkgMTAgMTJDMTAgMTMuMSAxMC45IDE0IDEyIDE0QzEzLjEgMTQgMTQgMTMuMSAxNCAxMkMxNCAxMC45IDEzLjEgMTAgMTIgMTBaTTEyIDE2QzEwLjkgMTYgMTAgMTYuOSAxMCAxOEMxMCAxOS4xIDEwLjkgMjAgMTIgMjBDMTMuMSAyMCAxNCAxOS4xIDE0IDE4QzE0IDE2LjkgMTMuMSAxNiAxMiAxNlpcXFwiIGZpbGw9XFxcIiNGRkI2MUFcXFwiLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNOSAxNmg2di02aDRsLTctNy03IDdoNHY2em0zLTEwLjE3TDE0LjE3IDhIMTN2NmgtMlY4SDkuODNMMTIgNS44M3pNNSAxOGgxNHYySDV6XFxcIi8+XFxuPC9zdmc+XCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge3F1aW50T3V0fSBmcm9tICdzdmVsdGUvZWFzaW5nJztcblx0aW1wb3J0IHt5d19mYW1pbHl9IGZyb20gJyMjL21lbSc7XG5cblx0aW1wb3J0IFNYX0lDT05fRE9UUyBmcm9tICcjL2ljb24vbW9yZS12ZXJ0LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9FRElUIGZyb20gJyMvaWNvbi9lZGl0LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9TRU5EIGZyb20gJyMvaWNvbi91cGxvYWQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0RFTEVURSBmcm9tICcjL2ljb24vZGVsZXRlLnN2Zz9yYXcnO1xuXG5cdGltcG9ydCBTWF9JQ09OX1BFUlNPTkFMIGZyb20gJyMvaWNvbi9hY2NvdW50X2JveC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ09OVFJBQ1QgZnJvbSAnIy9pY29uL2FuYWx5dGljcy5zdmc/cmF3JztcblxuXHRpbXBvcnQge3NsaWRlfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XG5cdGltcG9ydCBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgUm93IGZyb20gJy4vUm93LnN2ZWx0ZSc7XG5cdGltcG9ydCBQdXQgZnJvbSAnLi9QdXQuc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUge0RpY3QsIEpzb25QcmltaXRpdmV9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXHRpbXBvcnQgSW5saW5lVGFncyBmcm9tICcuL0lubGluZVRhZ3Muc3ZlbHRlJztcblxuXHRpbXBvcnQgQ29udGFjdEVkaXQgZnJvbSAnIyMvc2NyZWVuL0NvbnRhY3RFZGl0LnN2ZWx0ZSc7XG5cdGltcG9ydCBTZW5kIGZyb20gJyMjL3NjcmVlbi9TZW5kLnN2ZWx0ZSc7XG5cdGltcG9ydCBEZWFkRW5kIGZyb20gJyMjL3NjcmVlbi9EZWFkRW5kLnN2ZWx0ZSc7XG5cdGltcG9ydCBDb250YWN0VmlldyBmcm9tICcjIy9zY3JlZW4vQ29udGFjdFZpZXcuc3ZlbHRlJztcblxuXHRpbXBvcnQgdHlwZSB7Q29udGFjdCwgQ29udGFjdFBhdGh9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHtBZ2VudHN9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHtDaGFpbnN9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblxuXHRpbXBvcnQgdHlwZSB7UGFnZX0gZnJvbSAnLi4vc2NyZWVuL19zY3JlZW5zJztcblx0aW1wb3J0IHtnZXRDb250ZXh0fSBmcm9tICdzdmVsdGUnO1xuXG5cdC8vIGdldCBwYWdlIGZyb20gY29udGV4dFxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblxuXHRleHBvcnQgbGV0IGZpbHRlcjogKGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ10pID0+IGJvb2xlYW4gPSBnID0+IHRydWU7XG5cblx0ZXhwb3J0IGxldCBzb3J0OiAoZ19hOiBDb250YWN0WydpbnRlcmZhY2UnXSwgZ19iOiBDb250YWN0WydpbnRlcmZhY2UnXSkgPT4gbnVtYmVyID0gKGdfYSwgZ19iKSA9PiBnX2EubmFtZSA8IGdfYi5uYW1lPyAtMTogMTtcblxuXHRleHBvcnQgbGV0IGFwcGVuZDogQ29udGFjdFsnaW50ZXJmYWNlJ11bXSA9IFtdO1xuXG5cblx0Ly8gbG9hZCBhbGwgY29udGFjdHMgZm9yIHRoZSBjdXJyZW50IGNoYWluJ3MgZmFtaWx5IGFzIGEgbGlzdFxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX2NvbnRhY3RzKCk6IFByb21pc2U8W0NvbnRhY3RQYXRoLCBDb250YWN0WydpbnRlcmZhY2UnXV1bXT4ge1xuXHRcdC8vIHJlYWQgZnJvbSBhZ2VudHMgc3RvcmVcblx0XHRjb25zdCBrc19hZ2VudHMgPSBhd2FpdCBBZ2VudHMucmVhZCgpO1xuXG5cdFx0Ly8gc3ByZWFkIGl0ZXJhdG9yIGludG8gYXJyYXlcblx0XHRyZXR1cm4gWy4uLmtzX2FnZW50cy5jb250YWN0cygkeXdfZmFtaWx5KV07XG5cdH1cblxuXHRjb25zdCBobV9ldmVudHMgPSBuZXcgV2Vha01hcDxFdmVudCwgRGljdDxKc29uUHJpbWl0aXZlPj4oKTtcblxuXHRsZXQgc2lfb3ZlcmxheSA9ICcnO1xuXHRmdW5jdGlvbiBhY3RpdmF0ZV9vdmVybGF5KHBfY29udGFjdDogc3RyaW5nLCBnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddKTogKGQ6IE1vdXNlRXZlbnQpID0+IHZvaWQge1xuXHRcdHJldHVybiAoZF9ldmVudDogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0Ly8gcHJldmVudCBldmVudCBmcm9tIGJ1YmJsaW5nXG5cdFx0XHRkX2V2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHQvLyByZWYgZW50cnkgaWRcblx0XHRcdGNvbnN0IHNpX3NldCA9IHBfY29udGFjdDtcblxuXHRcdFx0Ly8gb3ZlcmxheSBhbHJlYWR5IHNldCB0byB0aGlzIGVudHJ5OyBoaWRlIGl0XG5cdFx0XHRpZihobV9ldmVudHMuZ2V0KGRfZXZlbnQpPy5jYW5jZWxNZW51ID09PSBzaV9zZXQpIHtcblx0XHRcdFx0c2lfb3ZlcmxheSA9ICcnO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldCBvdmVybGF5IHRvIHRoaXMgZW50cnlcblx0XHRcdHNpX292ZXJsYXkgPSBzaV9zZXQ7XG5cblx0XHRcdC8vIHJlbW92ZSBvbiBjbGljayBldmVudFxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuXHRcdFx0XHRobV9ldmVudHMuc2V0KGRfZXZlbnQsIHtcblx0XHRcdFx0XHRjYW5jZWxNZW51OiBzaV9vdmVybGF5LFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2lfb3ZlcmxheSA9ICcnO1xuXHRcdFx0fSwge1xuXHRcdFx0XHRjYXB0dXJlOiB0cnVlLFxuXHRcdFx0XHRvbmNlOiB0cnVlLFxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fVxuXG5cdGNvbnN0IGFfb3ZlcmxheV9hY3Rpb25zOiB7XG5cdFx0bGFiZWw6IHN0cmluZztcblx0XHRpY29uOiBzdHJpbmc7XG5cdFx0Y2xpY2soZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSk6IHZvaWQ7XG5cdH1bXSA9IFtcblx0XHR7XG5cdFx0XHRsYWJlbDogJ0VkaXQnLFxuXHRcdFx0aWNvbjogU1hfSUNPTl9FRElULFxuXHRcdFx0Y2xpY2soZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogQ29udGFjdEVkaXQsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdGNvbnRhY3Q6IGdfY29udGFjdCxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRsYWJlbDogJ1NlbmQnLFxuXHRcdFx0aWNvbjogU1hfSUNPTl9TRU5ELFxuXHRcdFx0Y2xpY2soZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogU2VuZCxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0cmVjaXBpZW50OiBDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRsYWJlbDogJ0RlbGV0ZScsXG5cdFx0XHRpY29uOiBTWF9JQ09OX0RFTEVURSxcblx0XHRcdGNsaWNrKGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ10pIHtcblx0XHRcdFx0Ly8gVE9ETzpcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IERlYWRFbmQsXG5cdFx0XHRcdFx0cHJvcHM6IHt9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQucm93cyB7XG5cdFx0bWFyZ2luLWxlZnQ6IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHRcdG1hcmdpbi1yaWdodDogY2FsYygwcHggLSB2YXIoLS11aS1wYWRkaW5nKSk7XG5cblx0XHQucm93IHtcblx0XHRcdC5zdGF0dXMge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQuaWNvbi5tb3JlLW1lbnUge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0cGFkZGluZy10b3A6IDUwJTtcblx0XHRcdFx0XHRcdHBhZGRpbmctYm90dG9tOiA1MCU7XG5cdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdFx0b3V0bGluZTogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbjogMzUwbXMgb3V0bGluZS1jb2xvciB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Omdsb2JhbCgmOmhvdmVyKSB7XG5cdFx0XHRcdFx0XHRvdXRsaW5lLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdDpnbG9iYWwoJjphY3RpdmUpLCA6Z2xvYmFsKCYuYWN0aXZlKSB7XG5cdFx0XHRcdFx0XHRvdXRsaW5lLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQub3ZlcmxheSB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiAxMHB4IDE0cHg7XG5cdFx0XHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG5cdFx0XHRcdFx0XHRib3JkZXItcmFkaXVzOiA4cHg7XG5cdFx0XHRcdFx0XHRyaWdodDogMjZweDtcblx0XHRcdFx0XHRcdHRvcDogLTE4cHg7XG5cdFx0XHRcdFx0XHRtaW4td2lkdGg6IDEyMHB4O1xuXHRcdFx0XHRcdFx0ei1pbmRleDogMTAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdD4uYWN0aW9uIHtcblx0XHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRcdFx0XHRwYWRkaW5nOiAxMHB4IDhweDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Pi50ZXh0IHtcblx0XHRcdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFkZGluZy1sZWZ0OiAxMHB4O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Lmljb24ge1xuXHRcdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQuaWNvbi5jb250YWN0LXR5cGUge1xuXHRcdC0taWNvbi1kaWFtZXRlcjogMTZweDtcblx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0fVxuXG5cdC5wZnAtZ2VuIHtcblx0XHQuZm9udChodWdlKTtcblx0XHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRib3JkZXItcmFkaXVzOiAyMCU7XG5cdFx0b3V0bGluZTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdGJhY2tncm91bmQ6IHJhZGlhbC1ncmFkaWVudChlbGxpcHNlIGZhcnRoZXN0LXNpZGUgYXQgYm90dG9tIHJpZ2h0LCAjMDcwODBhLCAjMGYxMzE3KTtcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInJvd3NcIj5cblx0eyNhd2FpdCBsb2FkX2NvbnRhY3RzKCl9XG5cdFx0TG9hZGluZyBjb250YWN0cy4uLlxuXHR7OnRoZW4gYV9saXN0fVxuXHRcdHsjZWFjaCBhX2xpc3QgYXMgW3BfY29udGFjdCwgZ19jb250YWN0XX1cblx0XHRcdDxSb3dcblx0XHRcdFx0cmVzb3VyY2U9e2dfY29udGFjdH1cblx0XHRcdFx0cmVzb3VyY2VQYXRoPXtwX2NvbnRhY3R9XG5cdFx0XHRcdG9uOmNsaWNrPXsoZF9ldmVudCkgPT4ge1xuXHRcdFx0XHRcdGlmKCFobV9ldmVudHMuZ2V0KGRfZXZlbnQpPy5jYW5jZWxNZW51KSB7XG5cdFx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdGNyZWF0b3I6IENvbnRhY3RWaWV3LFxuXHRcdFx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRhY3Q6IGdfY29udGFjdCxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fX1cblx0XHRcdD5cblx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwiZGV0YWlsXCI+XG5cdFx0XHRcdFx0PEFkZHJlc3MgYWRkcmVzcz17Q2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcysnJyl9IC8+XG5cdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXG5cdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInRhZ3NcIj5cblx0XHRcdFx0XHQ8SW5saW5lVGFncyBjb2xsYXBzZWQgcm9vdFN0eWxlPSdtYXJnaW46IDBweDsnXG5cdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg9e3BfY29udGFjdH1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb24gY29udGFjdC10eXBlXCIgc2xvdD1cInByZWZpeFwiPlxuXHRcdFx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9QRVJTT05BTH1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8L0lubGluZVRhZ3M+XG5cdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXG5cdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInN0YXR1c1wiPlxuXHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRjbGFzcz1cImljb24gbW9yZS1tZW51XCJcblx0XHRcdFx0XHRcdGNsYXNzOmFjdGl2ZT17c2lfb3ZlcmxheSA9PT0gcF9jb250YWN0fVxuXHRcdFx0XHRcdFx0b246Y2xpY2s9e2FjdGl2YXRlX292ZXJsYXkocF9jb250YWN0LCBnX2NvbnRhY3QpfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdHtAaHRtbCBTWF9JQ09OX0RPVFN9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0eyNpZiBzaV9vdmVybGF5ID09PSBwX2NvbnRhY3R9XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm92ZXJsYXlcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzAwLCBlYXNpbmc6cXVpbnRPdXR9fT5cblx0XHRcdFx0XHRcdFx0eyNlYWNoIGFfb3ZlcmxheV9hY3Rpb25zIGFzIGdfYWN0aW9ufVxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJhY3Rpb25cIiBvbjpjbGljaz17KGRfZXZlbnQpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGRfZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRnX2FjdGlvbi5jbGljayhnX2NvbnRhY3QpO1xuXHRcdFx0XHRcdFx0XHRcdH19PlxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBnX2FjdGlvbi5pY29ufVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0e2dfYWN0aW9uLmxhYmVsfVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdFx0XHQ8L1Jvdz5cblx0XHR7L2VhY2h9XG5cdHsvYXdhaXR9XG48L2Rpdj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge2dldENvbnRleHR9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IHtcblx0XHRUYWJzLFxuXHRcdFRhYixcblx0XHRUYWJMaXN0LFxuXHRcdFRhYlBhbmVsLFxuXHR9IGZyb20gJ3N2ZWx0ZS10YWJzJztcblxuXHRpbXBvcnQge1xuXHRcdFNjcmVlbixcblx0XHRIZWFkZXIsXG5cdFx0dHlwZSBQYWdlLFxuXHR9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGltcG9ydCBDb250YWN0RWRpdCBmcm9tICcuL0NvbnRhY3RFZGl0LnN2ZWx0ZSc7XG5cdGltcG9ydCBTdWJIZWFkZXIgZnJvbSAnLi4vdWkvU3ViSGVhZGVyLnN2ZWx0ZSc7XG5cdGltcG9ydCBDb250YWN0TGlzdCBmcm9tICcuLi91aS9Db250YWN0TGlzdC5zdmVsdGUnO1xuXHRpbXBvcnQge0NvbnRhY3RBZ2VudFR5cGV9IGZyb20gJyMvbWV0YS9jb250YWN0JztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQuc2NyZWVuLmNvbnRhY3RzIGRpdi5zdmVsdGUtdGFicz5kaXYuc3ZlbHRlLXRhYnNfX3RhYi1wYW5lbCB7XG5cdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRtYXJnaW4tdG9wOiAtMXB4O1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbiBuYXYgcm9vdCBjbGFzc05hbWVzPSdjb250YWN0cyc+XG5cdDxIZWFkZXIgc2VhcmNoIG5ldHdvcmsgYWNjb3VudFxuXHQ+XG5cdDwvSGVhZGVyPlxuXG5cdDxTdWJIZWFkZXIgdGl0bGU9XCJDb250YWN0c1wiXG5cdC8+XG5cdDwhLS0gYnV0dG9ucz17WydFeHBvcnQnXX0gLS0+XG5cdDwhLS0gb246YWRkX25ldz17KCkgPT4ga19wYWdlLnB1c2goe2NyZWF0b3I6Q29udGFjdEVkaXR9KX0gLS0+XG5cdFxuXHQ8VGFicz5cblx0XHQ8VGFiTGlzdD5cblx0XHRcdDxUYWI+XG5cdFx0XHRcdEFsbFxuXHRcdFx0PC9UYWI+XG5cblx0XHRcdDxUYWI+XG5cdFx0XHRcdEh1bWFuc1xuXHRcdFx0PC9UYWI+XG5cblx0XHRcdDxUYWI+XG5cdFx0XHRcdENvbnRyYWN0c1xuXHRcdFx0PC9UYWI+XG5cdFx0PC9UYWJMaXN0PlxuXG5cblx0XHQ8IS0tIEFsbCAtLT5cblx0XHQ8VGFiUGFuZWw+XG5cdFx0XHQ8Q29udGFjdExpc3QgLz5cblx0XHQ8L1RhYlBhbmVsPlxuXG5cblx0XHQ8IS0tIEh1bWFucyAtLT5cblx0XHQ8VGFiUGFuZWw+XG5cdFx0XHQ8Q29udGFjdExpc3Rcblx0XHRcdFx0ZmlsdGVyPXtnX2NvbnRhY3QgPT4gQ29udGFjdEFnZW50VHlwZS5QRVJTT04gPT09IGdfY29udGFjdC5hZ2VudFR5cGV9XG5cdFx0XHQvPlxuXHRcdDwvVGFiUGFuZWw+XG5cblx0XHRcblx0XHQ8IS0tIENvbnRyYWN0cyAtLT5cblx0XHQ8VGFiUGFuZWw+XG5cdFx0XHQ8Q29udGFjdExpc3Rcblx0XHRcdFx0ZmlsdGVyPXtnX2NvbnRhY3QgPT4gQ29udGFjdEFnZW50VHlwZS5DT05UUkFDVCA9PT0gZ19jb250YWN0LmFnZW50VHlwZX1cblx0XHRcdC8+XG5cdFx0PC9UYWJQYW5lbD5cblxuXHQ8L1RhYnM+XG5cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IEFwcHMgfSBmcm9tIFwiIy9zdG9yZS9hcHBzXCI7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cdGltcG9ydCBIZWFkZXIgZnJvbSBcIi4uL3VpL0hlYWRlci5zdmVsdGVcIjtcblx0aW1wb3J0IFJvdyBmcm9tIFwiLi4vdWkvUm93LnN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyBQYWdlLCBTY3JlZW4sIFN1YkhlYWRlciB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX2FwcHMoKSB7XG5cdFx0Y29uc3Qga3NfYXBwcyA9IGF3YWl0IEFwcHMucmVhZCgpO1xuXG5cdFx0cmV0dXJuIGtzX2FwcHMuZW50cmllcygpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdFxuPC9zdHlsZT5cblxuPFNjcmVlbiBkZWJ1Zz0nU2l0ZXNIb21lJyBuYXYgcm9vdD5cblx0PEhlYWRlciBzZWFyY2ggbmV0d29yayBhY2NvdW50IC8+XG5cblx0PFN1YkhlYWRlciBiYXJlXG5cdFx0dGl0bGU9J1NpdGVzIC8gQXBwcydcblx0Lz5cblxuXHQ8ZGl2IGNsYXNzPVwicm93cyBuby1tYXJnaW5cIj5cblx0XHR7I2F3YWl0IGxvYWRfYXBwcygpfVxuXHRcdFx0TG9hZGluZy4uLlxuXHRcdHs6dGhlbiBhX2FwcHN9IFxuXHRcdFx0eyNlYWNoIGFfYXBwcyBhcyBbcF9hcHAsIGdfYXBwXX1cblx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdHBmcD17Z19hcHAucGZwfVxuXHRcdFx0XHRcdG5hbWU9e2dfYXBwLmhvc3R9XG5cdFx0XHRcdFx0cmVzb3VyY2VQYXRoPXtwX2FwcH1cblx0XHRcdFx0XHRpY29uQ2xhc3M9eydzcXVhcmUgcGZwJ31cblx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHQvLyBjcmVhdG9yOiBTaXRlVmlldyxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH19XG5cdFx0XHRcdD5cblx0XHRcdFx0PC9Sb3c+XG5cdFx0XHR7L2VhY2h9XG5cdFx0ey9hd2FpdH1cblx0PC9kaXY+XG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge3l3X2FjY291bnQsIHl3X2NoYWlufSBmcm9tICcjIy9tZW0nO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRcblx0aW1wb3J0IHsgSGVhZGVyLCB0eXBlIFBhZ2UsIFNjcmVlbiB9IGZyb20gJy4uL3NjcmVlbi9fc2NyZWVucyc7XG5cdGltcG9ydCBQb3J0cmFpdCBmcm9tICcjIy91aS9Qb3J0cmFpdC5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IE5ldHdvcmssIE5ldHdvcmtQYXRoIH0gZnJvbSAnIy9tZXRhL25ldHdvcmsnO1xuXHRpbXBvcnQgeyBOZXR3b3JrcyB9IGZyb20gJyMvc3RvcmUvbmV0d29ya3MnO1xuXHRpbXBvcnQgdHlwZSB7IENoYWluLCBDaGFpblBhdGggfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuaW1wb3J0IEZpZWxkIGZyb20gJy4uL3VpL0ZpZWxkLnN2ZWx0ZSc7XG5pbXBvcnQgSW5mbyBmcm9tICcuLi91aS9JbmZvLnN2ZWx0ZSc7XG5pbXBvcnQgR2FwIGZyb20gJy4uL3VpL0dhcC5zdmVsdGUnO1xuXG5cblx0ZXhwb3J0IGxldCBuZXR3b3JrUmVmOiBOZXR3b3JrUGF0aDtcblx0Y29uc3QgcF9uZXR3b3JrID0gbmV0d29ya1JlZjtcblxuXHRsZXQgZ19uZXR3b3JrOiBOZXR3b3JrWydpbnRlcmZhY2UnXTtcblx0dm9pZCBOZXR3b3Jrcy5hdChwX25ldHdvcmspLnRoZW4oZyA9PiBnX25ldHdvcmsgPSBnISk7XG5cblx0JDogcF9jaGFpbiA9IGdfbmV0d29yaz8uY2hhaW47XG5cblx0bGV0IGdfY2hhaW46IENoYWluWydpbnRlcmZhY2UnXTtcblx0JDogaWYocF9jaGFpbikge1xuXHRcdHZvaWQgQ2hhaW5zLmF0KHBfY2hhaW4gYXMgQ2hhaW5QYXRoKS50aGVuKGcgPT4gZ19jaGFpbiA9IGchKTtcblx0fVxuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRjb25zdCBnY19hY3Rpb25zID0ge1xuXHRcdC8vIHNlbmQ6IHtcblx0XHQvLyBcdGxhYmVsOiAnU2VuZCcsXG5cdFx0Ly8gXHR0cmlnZ2VyKCkge1xuXHRcdC8vIFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0Ly8gXHRcdFx0Y3JlYXRvcjogU2VuZCxcblx0XHQvLyBcdFx0XHRwcm9wczoge1xuXHRcdC8vIFx0XHRcdFx0dG86IENoYWlucy5iZWNoMzIoZ19uZXR3b3JrLmFkZHJlc3MpLFxuXHRcdC8vIFx0XHRcdH0sXG5cdFx0Ly8gXHRcdH0pO1xuXHRcdC8vIFx0fSxcblx0XHQvLyB9LFxuXHRcdC8vIGVkaXQ6IHtcblx0XHQvLyBcdGxhYmVsOiAnRWRpdCcsXG5cdFx0Ly8gXHR0cmlnZ2VyKCkge1xuXHRcdC8vIFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0Ly8gXHRcdFx0Y3JlYXRvcjogQ29udGFjdEVkaXQsXG5cdFx0Ly8gXHRcdFx0cHJvcHM6IHtcblx0XHQvLyBcdFx0XHRcdGNvbnRhY3RSZWY6IHBfbmV0d29yayxcblx0XHQvLyBcdFx0XHR9LFxuXHRcdC8vIFx0XHR9KTtcblx0XHQvLyBcdH0sXG5cdFx0Ly8gfSxcblx0XHQvLyBkZWxldGU6IHtcblx0XHQvLyBcdGxhYmVsOiAnRGVsZXRlJyxcblx0XHQvLyBcdHRyaWdnZXIoKSB7XG5cdFx0Ly8gXHRcdGtfcGFnZS5wdXNoKHtcblx0XHQvLyBcdFx0XHRjcmVhdG9yOiBEZWFkRW5kLFxuXHRcdC8vIFx0XHR9KTtcblx0XHQvLyBcdH0sXG5cdFx0Ly8gfSxcblx0fTtcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblxuXG5cdC5wZnAtZ2VuIHtcblx0XHQuZm9udChodWdlLCBAc2l6ZTogMzBweCk7XG5cdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Ym9yZGVyLXJhZGl1czogMjAlO1xuXHRcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoZWxsaXBzZSBmYXJ0aGVzdC1zaWRlIGF0IGJvdHRvbSByaWdodCwgIzA3MDgwYSwgIzBmMTMxNyk7XG5cdH1cbjwvc3R5bGU+XG5cblxuPFNjcmVlbiBuYXYgc2xpZGVzPlxuXHQ8SGVhZGVyIHBvcHMgc2VhcmNoIG5ldHdvcmsgYWNjb3VudCAvPlxuXG5cdHsjaWYgIWdfY2hhaW59XG5cdFx0TG9hZGluZyBuZXR3b3JrLi4uXG5cdHs6ZWxzZX1cblx0XHQ8UG9ydHJhaXRcblx0XHRcdHJlc291cmNlPXtnX25ldHdvcmt9XG5cdFx0XHRyZXNvdXJjZVBhdGg9e3BfbmV0d29ya31cblx0XHRcdGFjdGlvbnM9e2djX2FjdGlvbnN9XG5cdFx0PlxuXHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwic3VidGl0bGVcIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJmb250LWZhbWlseV9tb25vXCI+XG5cdFx0XHRcdFx0e2dfY2hhaW4ubmFtZX0gKHtnX2NoYWluLmlkfSlcblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+YWRkcmVzc1xuXHRcdDwvUG9ydHJhaXQ+XG5cblx0XHQ8RmllbGRcblx0XHRcdG5hbWU9J2dSUEMtd2ViIFVSTCdcblx0XHRcdGtleT0nZ3JwYy13ZWInXG5cdFx0PlxuXHRcdFx0PEluZm8ga2V5PSdncnBjLXdlYi12YWx1ZSc+XG5cdFx0XHRcdHtnX25ldHdvcmsuZ3JwY1dlYlVybH1cblx0XHRcdDwvSW5mbz5cblx0XHQ8L0ZpZWxkPlxuXG5cdFx0eyNpZiBnX25ldHdvcmsucnBjSG9zdH1cblx0XHRcdDxGaWVsZFxuXHRcdFx0XHRuYW1lPSdSUEMgSG9zdCdcblx0XHRcdFx0a2V5PSdycGMnXG5cdFx0XHQ+XG5cdFx0XHRcdDxJbmZvIGtleT0ncnBjLXZhbHVlJz5cblx0XHRcdFx0XHR7Z19uZXR3b3JrLnJwY0hvc3R9XG5cdFx0XHRcdDwvSW5mbz5cblx0XHRcdDwvRmllbGQ+XG5cdFx0ey9pZn1cblx0ey9pZn1cblxuXHQ8R2FwIC8+XG5cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7Q2hhaW5zfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7TmV0d29ya3N9IGZyb20gJyMvc3RvcmUvbmV0d29ya3MnO1xuXHRpbXBvcnQge2dldENvbnRleHR9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBIZWFkZXIgZnJvbSAnLi4vdWkvSGVhZGVyLnN2ZWx0ZSc7XG5cdGltcG9ydCBSb3cgZnJvbSAnLi4vdWkvUm93LnN2ZWx0ZSc7XG5cdGltcG9ydCBOZXR3b3JrVmlldyBmcm9tICcuL05ldHdvcmtWaWV3LnN2ZWx0ZSc7XG5cdGltcG9ydCB7UGFnZSwgU2NyZWVuLCBTdWJIZWFkZXJ9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRsZXQga3NfY2hhaW5zOiBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIENoYWlucy5yZWFkPj47XG5cdGxldCBrc19uZXR3b3JrczogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBOZXR3b3Jrcy5yZWFkPj47XG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfbmV0d29ya3MoKSB7XG5cdFx0W1xuXHRcdFx0a3NfY2hhaW5zLFxuXHRcdFx0a3NfbmV0d29ya3MsXG5cdFx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcblx0XHRcdENoYWlucy5yZWFkKCksXG5cdFx0XHROZXR3b3Jrcy5yZWFkKCksXG5cdFx0XSk7XG5cblx0XHRyZXR1cm4ga3NfbmV0d29ya3MuZW50cmllcygpO1xuXHR9XG5cblx0Ly8gZnVuY3Rpb24gYWRkX25ld19uZXR3b3JrKCkge1xuXHQvLyBcdGtfcGFnZS5wdXNoKHtcblx0Ly8gXHRcdGNyZWF0b3I6IE5ldHdvcmtDcmVhdGUsXG5cdC8vIFx0fSk7XG5cdC8vIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0XG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdOZXR3b3Jrc0hvbWUnIG5hdiByb290PlxuXHQ8SGVhZGVyIHNlYXJjaCBuZXR3b3JrIGFjY291bnQgLz5cblxuXHQ8U3ViSGVhZGVyIGJhcmVcblx0XHR0aXRsZT0nTmV0d29ya3MnXG5cdC8+XG5cdFx0PCEtLSBvbjphZGRfbmV3PXthZGRfbmV3X25ldHdvcmt9IC0tPlxuXG5cdDxkaXYgY2xhc3M9XCJyb3dzIG5vLW1hcmdpblwiPlxuXHRcdHsjYXdhaXQgbG9hZF9uZXR3b3JrcygpfVxuXHRcdFx0TG9hZGluZy4uLlxuXHRcdHs6dGhlbiBhX25ldHdvcmtzfSBcblx0XHRcdHsjZWFjaCBhX25ldHdvcmtzIGFzIFtwX25ldHdvcmssIGdfbmV0d29ya119XG5cdFx0XHRcdHtAY29uc3QgZ19jaGFpbiA9IGtzX2NoYWlucy5hdChnX25ldHdvcmsuY2hhaW4pfVxuXHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0cmVzb3VyY2U9e2dfbmV0d29ya31cblx0XHRcdFx0XHRyZXNvdXJjZVBhdGg9e3BfbmV0d29ya31cblx0XHRcdFx0XHRpY29uQ2xhc3M9eydzcXVhcmUgcGZwJ31cblx0XHRcdFx0XHRkZXRhaWw9e2Ake2dfY2hhaW4/Lm5hbWV9ICgke2dfY2hhaW4/LmlkfSlgfVxuXHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdGNyZWF0b3I6IE5ldHdvcmtWaWV3LFxuXHRcdFx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0XHRcdG5ldHdvcmtSZWY6IHBfbmV0d29yayxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH19XG5cdFx0XHRcdD5cblx0XHRcdFx0PC9Sb3c+XG5cdFx0XHR7L2VhY2h9XG5cdFx0ey9hd2FpdH1cblx0PC9kaXY+XG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBnbG9iYWxfcmVjZWl2ZSB9IGZyb20gJyMvc2NyaXB0L21zZy1nbG9iYWwnO1xuXG5cdGltcG9ydCB7IEV2ZW50cyB9IGZyb20gJyMvc3RvcmUvZXZlbnRzJztcblx0aW1wb3J0IHsgb25EZXN0cm95IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHsgb25jZV9zdG9yZV91cGRhdGVzIH0gZnJvbSAnLi4vc3ZlbHRlJztcblx0aW1wb3J0IFR4bkxpc3QgZnJvbSAnLi4vdWkvVHhuTGlzdC5zdmVsdGUnO1xuXG5cdGltcG9ydCB7XG5cdFx0U2NyZWVuLFxuXHRcdEhlYWRlcixcblx0XHRTdWJIZWFkZXIsXG5cdFx0dHlwZSBQYWdlLFxuXHR9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGxldCBjX3JlbG9hZHMgPSAxO1xuXHRjb25zdCBmX3Vuc3Vic2NyaWJlID0gZ2xvYmFsX3JlY2VpdmUoe1xuXHRcdHVwZGF0ZVN0b3JlKHtrZXk6c2lfc3RvcmV9KSB7XG5cdFx0XHRpZignZXZlbnRzJyA9PT0gc2lfc3RvcmUpIHtcblx0XHRcdFx0Y19yZWxvYWRzKys7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG5cblx0b25EZXN0cm95KCgpID0+IHtcblx0XHRmX3Vuc3Vic2NyaWJlKCk7XG5cdH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG48L3N0eWxlPlxuXG48U2NyZWVuIG5hdiByb290XG4+XG5cdDxIZWFkZXIgc2VhcmNoIG5ldHdvcmsgYWNjb3VudFxuXHQ+XG5cdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwidGl0bGVcIj5cblxuXHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHQ8L0hlYWRlcj5cblxuXHQ8U3ViSGVhZGVyXG5cdFx0dGl0bGU9J0hpc3RvcnknXG5cdFx0YmFyZVxuXHQ+PC9TdWJIZWFkZXI+XG5cblx0PCEtLSBcblx0PHAgc3R5bGU9J2ZvbnQtc2l6ZToxMnB4Jz5cblx0XHQ8c3BhbiBzdHlsZT0nY29sb3I6dmFyKC0tdGhlbWUtY29sb3ItY2F1dGlvbik7Jz5EaXNjbGFpbWVyOiA8L3NwYW4+XG5cdFx0VGhpcyB0ZW1wb3JhcnkgaGlzdG9yeSBpbnRlcmZhY2UgZG9lcyBub3QgcmVwcmVzZW50IHRoZSBsb29rIGFuZCBmdW5jdGlvbiBvZiB0aGUgYWN0dWFsIGhpc3RvcnkgaW50ZXJmYWNlIGN1cnJlbnRseSB1bmRlciBkZXZlbG9wbWVudCBmb3IgYmV0YS5cblx0PC9wPiAtLT5cblxuXHR7I2tleSBjX3JlbG9hZHN9XG5cdFx0eyNhd2FpdCBFdmVudHMucmVhZCgpfVxuXHRcdFx0TG9hZGluZyBoaXN0b3J5Li4uXG5cdFx0ezp0aGVuIGtzX2V2ZW50c31cblx0XHRcdHtAY29uc3QgYV9ldmVudHMgPSBrc19ldmVudHMucmF3fVxuXG5cdFx0XHQ8VHhuTGlzdFxuXHRcdFx0XHRldmVudHM9e2FfZXZlbnRzfVxuXHRcdFx0Lz5cblx0XHR7L2F3YWl0fVxuXHR7L2tleX1cbjwvU2NyZWVuPlxuIiwiaW1wb3J0IEJsYW5rU3ZlbHRlIGZyb20gJy4vc2NyZWVuL0JsYW5rLnN2ZWx0ZSc7XG5pbXBvcnQgUmVnaXN0ZXJTdmVsdGUgZnJvbSAnLi9zY3JlZW4vUmVnaXN0ZXIuc3ZlbHRlJztcbmltcG9ydCBIb2xkaW5nc0hvbWVTdmVsdGUgZnJvbSAnLi9zY3JlZW4vSG9sZGluZ3NIb21lLnN2ZWx0ZSc7XG5pbXBvcnQgQWNjb3VudEhvbWVTdmVsdGUgZnJvbSAnLi9zY3JlZW4vQWNjb3VudHNIb21lLnN2ZWx0ZSc7XG5pbXBvcnQgQ29udGFjdHNIb21lU3ZlbHRlIGZyb20gJy4vc2NyZWVuL0NvbnRhY3RzSG9tZS5zdmVsdGUnO1xuaW1wb3J0IFNpdGVzSG9tZVN2ZWx0ZSBmcm9tICcuL3NjcmVlbi9TaXRlc0hvbWUuc3ZlbHRlJztcbmltcG9ydCBOZXR3b3Jrc0hvbWVTdmVsdGUgZnJvbSAnLi9zY3JlZW4vTmV0d29ya3NIb21lLnN2ZWx0ZSc7XG5pbXBvcnQgSGlzdG9yeUhvbWVTdmVsdGUgZnJvbSAnLi9zY3JlZW4vSGlzdG9yeUhvbWUuc3ZlbHRlJztcblxuZXhwb3J0IGVudW0gVGhyZWFkSWQge1xuXHRERUZBVUxUPSdkZWZhdWx0Jyxcblx0SU5JVD0naW5pdCcsXG5cdFNFQVJDSD0nc2VhcmNoJyxcblx0VE9LRU5TPSd0b2tlbnMnLFxuXHRORlRTPSduZnRzJyxcblx0Q09OVEFDVFM9J2NvbnRhY3RzJyxcblx0SElTVE9SWT0naGlzdG9yeScsXG5cdE5FVFdPUktTPSduZXR3b3JrcycsXG5cdEFDQ09VTlRTPSdhY2NvdW50cycsXG5cdFRBR1M9J3RhZ3MnLFxuXHRTSVRFUz0nc2l0ZXMnLFxufVxuXG5leHBvcnQgY29uc3QgSF9USFJFQURTID0ge1xuXHRbVGhyZWFkSWQuREVGQVVMVF06IEJsYW5rU3ZlbHRlLFxuXHRbVGhyZWFkSWQuSU5JVF06IFJlZ2lzdGVyU3ZlbHRlLFxuXHQvLyBbVGhyZWFkSWQuU0VBUkNIXTogU2VhcmNoLFxuXHRbVGhyZWFkSWQuVE9LRU5TXTogSG9sZGluZ3NIb21lU3ZlbHRlLFxuXHQvLyBbVGhyZWFkSWQuTkZUU106IEdhbGxlcnksXG5cdFtUaHJlYWRJZC5DT05UQUNUU106IENvbnRhY3RzSG9tZVN2ZWx0ZSxcblx0W1RocmVhZElkLkhJU1RPUlldOiBIaXN0b3J5SG9tZVN2ZWx0ZSxcblx0W1RocmVhZElkLk5FVFdPUktTXTogTmV0d29ya3NIb21lU3ZlbHRlLFxuXHRbVGhyZWFkSWQuQUNDT1VOVFNdOiBBY2NvdW50SG9tZVN2ZWx0ZSxcblx0Ly8gLy8gW1RocmVhZElkLlRhZ3NdOiBUYWdzLFxuXHRbVGhyZWFkSWQuU0lURVNdOiBTaXRlc0hvbWVTdmVsdGUsXG59IGFzIGNvbnN0O1xuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtcblx0XHR5d19vdmVyc2Nyb2xsX3BjdCxcblx0fSBmcm9tICcjIy9tZW0nO1xuXG5cdGxldCBkbV9wcm9ncmVzczogU1ZHQ2lyY2xlRWxlbWVudDtcblxuXHQvLyAkOiB7XG5cdC8vIFx0ZG1fcHJvZ3Jlc3Muc3R5bGUuJHl3X292ZXJzY3JvbGxfcGN0XG5cdC8vIH1cbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRzdmcge1xuXHRcdGRpc3BsYXk6IG5vbmU7XG5cdFx0ei1pbmRleDogMjAwMDE7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMTBweDtcblx0XHRsZWZ0OiBjYWxjKDUwJSAtIDE2cHgpO1xuXG5cdFx0LnByb2dyZXNzIHtcblx0XHRcdHN0cm9rZS1kYXNoYXJyYXk6IDYyO1xuXHRcdFx0c3Ryb2tlLWRhc2hvZmZzZXQ6IDYyO1xuXHRcdFx0c3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xuXHRcdFx0dHJhbnNpdGlvbjogc3Ryb2tlLWRhc2hhcnJheSAxMDBtcyBsaW5lYXI7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG5cbjxzdmcgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCAzMiAzMlwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBjbGFzcz1cIm92ZXJzY3JvbGxcIj5cblx0PHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdFx0Lm92ZXJzY3JvbGwge1xuXHRcdFx0LmJnIHtcblx0XHRcdFx0ZmlsbDogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC5yaW5nIHtcblx0XHRcdFx0ZmlsbDogdHJhbnNwYXJlbnQ7XG5cdFx0XHRcdHN0cm9rZTogI2M0YzRjNDtcblx0XHRcdH1cblxuXHRcdFx0LnByb2dyZXNzIHtcblx0XHRcdFx0ZmlsbDogdHJhbnNwYXJlbnQ7XG5cdFx0XHRcdHN0cm9rZTogYmxhY2s7XG5cdFx0XHR9XG5cdFx0fVxuXHQ8L3N0eWxlPlxuXG5cdDxjaXJjbGUgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTZcIiBjbGFzcz1cImJnXCIgLz5cblxuXHQ8Y2lyY2xlIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjEwXCIgY2xhc3M9XCJyaW5nXCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0eWxlPVwib3BhY2l0eTowLjI7XCIgLz5cblxuXHQ8Y2lyY2xlIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjEwXCIgY2xhc3M9XCJwcm9ncmVzc1wiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHlsZT1cInN0cm9rZS1kYXNob2Zmc2V0Ons2MiAtICgkeXdfb3ZlcnNjcm9sbF9wY3QgKiA2Mil9XCIgYmluZDp0aGlzPXtkbV9wcm9ncmVzc30gLz5cblx0XG5cdDwhLS0gPHBhdGggZD1cIk0xNiAxNiBBMTYgNiB7eGFfcGN0fSB7eGFfcGN0fVwiIGNsYXNzPVwiczJyLW92ZXJmbG93LWZnXCIgLz4gLS0+XG48L3N2Zz4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge1xuXHRcdHl3X3BvcHVwLFxuXHR9IGZyb20gJyMjL21lbSc7XG5cblxuXHRcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHQucG9wdXAge1xuXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogdmFyKC0tYXBwLXdpbmRvdy1oZWlnaHQpO1xuXHRcdGxlZnQ6IDA7XG5cdFx0ei1pbmRleDogMTEwMDtcblxuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblxuXHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XG5cdFx0dHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjM1cyBsaW5lYXI7XG5cblx0XHQmLnNob3dpbmcge1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0cG9pbnRlci1ldmVudHM6IGluaXRpYWw7XG5cdFx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XG5cblx0XHRcdD4uY29udGVudCB7XG5cdFx0XHRcdC8vIHRvcDogMjRweDtcblx0XHRcdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKDI0cHgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdD4uY29udGVudCB7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHQvLyB0b3A6IHZhcigtLWFwcC13aW5kb3ctaGVpZ2h0KTtcblx0XHRcdHRvcDogMDtcblx0XHRcdGxlZnQ6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0d2lkdGg6IGNhbGMoMTAwJSAtIHZhcigtLXVpLXBhZGRpbmcpIC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHRcdFx0aGVpZ2h0OiA4NyU7XG5cdFx0XHRvdmVyZmxvdy15OiBzY3JvbGw7XG5cdFx0XHQuaGlkZS1zY3JvbGxiYXIoKTtcblxuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0Ym9yZGVyLXJhZGl1czogOHB4O1xuXHRcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRcdHBhZGRpbmc6IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdGdhcDogdmFyKC0tdWktcGFkZGluZyk7XG5cblx0XHRcdC8vIHRyYW5zaXRpb246IHRvcCA2NzVtcyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gNjc1bXMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKHZhcigtLWFwcC13aW5kb3ctaGVpZ2h0KSk7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwicG9wdXBcIiBjbGFzczpzaG93aW5nPXtudWxsICE9PSAkeXdfcG9wdXB9IG9uOmNsaWNrPXsoKSA9PiAkeXdfcG9wdXAgPSBudWxsfT5cblx0PHNlY3Rpb24gY2xhc3M9XCJzY3JlZW4gY29udGVudFwiIG9uOmNsaWNrPXsoZF9ldmVudCkgPT4gZF9ldmVudC5zdG9wUHJvcGFnYXRpb24oKX0+XG5cdFx0PHN2ZWx0ZTpjb21wb25lbnQgdGhpcz17JHl3X3BvcHVwfT48L3N2ZWx0ZTpjb21wb25lbnQ+XG5cdDwvc2VjdGlvbj5cbjwvZGl2PlxuIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIk0xMiAxNkwxOCAxMEwxNi41OSA4LjU5TDEyIDEzLjE3TDcuNDEgOC41OUw2IDEwTDEyIDE2WlxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItdG9rZW5zLWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci10b2tlbnMtZmdcXFwiIGQ9XFxcIk0xNSA0Yy00LjQyIDAtOCAzLjU4LTggOHMzLjU4IDggOCA4IDgtMy41OCA4LTgtMy41OC04LTgtOFptMCAxNGMtMy4zMSAwLTYtMi42OS02LTZzMi42OS02IDYtNiA2IDIuNjkgNiA2LTIuNjkgNi02IDZaTTMgMTJhNS45OSA1Ljk5IDAgMCAxIDQtNS42NVY0LjI2QzMuNTUgNS4xNSAxIDguMjcgMSAxMmMwIDMuNzMgMi41NSA2Ljg1IDYgNy43NHYtMi4wOUE1Ljk5IDUuOTkgMCAwIDEgMyAxMlpcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTEzIDNhOSA5IDAgMCAwLTkgOUgxbDMuODkgMy44OS4wNy4xNEw5IDEySDZjMC0zLjg3IDMuMTMtNyA3LTdzNyAzLjEzIDcgNy0zLjEzIDctNyA3Yy0xLjkzIDAtMy42OC0uNzktNC45NC0yLjA2bC0xLjQyIDEuNDJBOC45NTQgOC45NTQgMCAwIDAgMTMgMjFhOSA5IDAgMCAwIDAtMThabS0xIDV2NWw0LjI1IDIuNTIuNzctMS4yOC0zLjUyLTIuMDlWOEgxMlpcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLW1lbnUtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0PC9zdHlsZT5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLW1lbnUtZmdcXFwiIGQ9XFxcIk00IDE5aDE2Yy41NSAwIDEtLjQ1IDEtMXMtLjQ1LTEtMS0xSDRjLS41NSAwLTEgLjQ1LTEgMXMuNDUgMSAxIDFabTAtNmgxNmMuNTUgMCAxLS40NSAxLTFzLS40NS0xLTEtMUg0Yy0uNTUgMC0xIC40NS0xIDFzLjQ1IDEgMSAxWk0zIDZjMCAuNTUuNDUgMSAxIDFoMTZjLjU1IDAgMS0uNDUgMS0xcy0uNDUtMS0xLTFINGMtLjU1IDAtMSAuNDUtMSAxWlxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IEhfVEhSRUFEUywgVGhyZWFkSWQgfSBmcm9tICcjIy9kZWYnO1xuXHRpbXBvcnQge1xuXHRcdHl3X3BhdHRlcm4sXG5cdFx0eXdfbmF2X2NvbGxhcHNlZCxcblx0XHQvLyB5d190aHJlYWRfaWQsXG5cdFx0eXdfbmF2X3Zpc2libGUsXG5cdFx0eXdfbWVudV9leHBhbmRlZCxcblx0XHR5d19ibHVyLFxuXHRcdHl3X292ZXJsYXlfbmV0d29yayxcblx0XHR5d19vdmVybGF5X2FjY291bnQsXG5cdFx0eXdfbm90aWZpY2F0aW9ucyxcblx0XHR5d19uYXZpZ2F0b3IsXG5cdFx0eXdfcGFnZSxcblx0XHR5d190aHJlYWQsXG5cdH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgeyBvZGUsIG9kZXJhYywgb2Rlcm9tIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCBTWF9JQ09OX0VYUEFORCBmcm9tICcjL2ljb24vZXhwYW5kLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9UT0tFTlMgZnJvbSAnIy9pY29uL3Rva2Vucy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ09OVEFDVFMgZnJvbSAnIy9pY29uL2FjY291bnRfYm94LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9ISVNUT1JZIGZyb20gJyMvaWNvbi9oaXN0b3J5LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9ORlQgZnJvbSAnIy9pY29uL25mdHMuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX01FTlUgZnJvbSAnIy9pY29uL21lbnUuc3ZnP3Jhdyc7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IFBhZ2UgfSBmcm9tICcjL2FwcC9uYXYvcGFnZSc7XG5cdGltcG9ydCBIb2xkaW5nc0hvbWUgZnJvbSAnIy9hcHAvc2NyZWVuL0hvbGRpbmdzSG9tZS5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvciB9IGZyb20gJyMvbWV0YS9zdmVsdGUnO1xuXG5cdC8vIG5hdiBiYXIgZGVmaW5pdGlvblxuXHRjb25zdCBIX0JVVFRPTlMgPSB7XG5cdFx0W1RocmVhZElkLlRPS0VOU106IHtcblx0XHRcdHN2ZzogU1hfSUNPTl9UT0tFTlMsXG5cdFx0XHRsYWJlbDogJ1Rva2VucycsXG5cdFx0fSxcblx0XHRbVGhyZWFkSWQuQ09OVEFDVFNdOiB7XG5cdFx0XHRzdmc6IFNYX0lDT05fQ09OVEFDVFMsXG5cdFx0XHRsYWJlbDogJ0NvbnRhY3RzJyxcblx0XHRcdGRpc2FibGVkOiB0cnVlLFxuXHRcdH0sXG5cdFx0Ly8gW1RocmVhZElkLk5GVFNdOiB7XG5cdFx0Ly8gXHRzdmc6IFNYX0lDT05fTkZULFxuXHRcdC8vIFx0bGFiZWw6ICdORlRzJyxcblx0XHQvLyB9LFxuXHRcdFtUaHJlYWRJZC5ISVNUT1JZXToge1xuXHRcdFx0c3ZnOiBTWF9JQ09OX0hJU1RPUlksXG5cdFx0XHRsYWJlbDogJ0hpc3RvcnknLFxuXHRcdFx0Ly8gZGlzYWJsZWQ6IHRydWUsXG5cdFx0fSxcblx0XHRtZW51OiB7XG5cdFx0XHRzdmc6IFNYX0lDT05fTUVOVSxcblx0XHRcdGxhYmVsOiAnTWVudScsXG5cdFx0fSxcblx0fSBhcyBSZWNvcmQ8c3RyaW5nLCB7XG5cdFx0c3ZnOiBzdHJpbmc7XG5cdFx0bGFiZWw6IHN0cmluZztcblx0fT47XG5cblx0Y29uc3QgSE1fSE9NRVNDUkVFTlMgPSBuZXcgTWFwPFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvciwgVGhyZWFkSWQ+KFxuXHRcdG9kZXJhYyhIX1RIUkVBRFMsIChzaV90aHJlYWQsIGRjX2NyZWF0b3IpID0+IFtkY19jcmVhdG9yLCBzaV90aHJlYWQgYXMgVGhyZWFkSWRdKSk7XG5cblx0bGV0IHNpX3RocmVhZF9oZWFkOiAnJyB8IFRocmVhZElkID0gJyc7XG5cdCQ6IHNpX3RocmVhZF9oZWFkID0gJHl3X3BhZ2U/IEhNX0hPTUVTQ1JFRU5TLmdldCgkeXdfcGFnZS5jcmVhdG9yKSB8fCAnJzogJyc7XG5cblx0XG5cdGZ1bmN0aW9uIHRvZ2dsZV9jb2xsYXBzZWQoKSB7XG5cdFx0JHl3X25hdl9jb2xsYXBzZWQgPSAhJHl3X25hdl9jb2xsYXBzZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBuYXZfY2xpY2soc2lfYnV0dG9uOiBzdHJpbmcpIHtcblx0XHQvLyByZW1vdmUgbm90aWZpY2F0aW9uXG5cdFx0JHl3X25vdGlmaWNhdGlvbnMgPSAkeXdfbm90aWZpY2F0aW9ucy5maWx0ZXIoc2kgPT4gc2lfYnV0dG9uICE9PSBzaSk7XG5cblx0XHQvLyBibHVyIGlzIGFjdGl2ZVxuXHRcdGlmKCR5d19ibHVyKSB7XG5cdFx0XHQvLyBjYW5jZWwgYmx1clxuXHRcdFx0JHl3X2JsdXIgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBuZXR3b3JrIG92ZXJsYXkgaXMgYWN0aXZlXG5cdFx0aWYoJHl3X292ZXJsYXlfbmV0d29yaykge1xuXHRcdFx0JHl3X292ZXJsYXlfbmV0d29yayA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGFjY291bnQgb3ZlcmxheSBpcyBhY3RpdmVcblx0XHRpZigkeXdfb3ZlcmxheV9hY2NvdW50KSB7XG5cdFx0XHQkeXdfb3ZlcmxheV9hY2NvdW50ID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gZGVwZW5kaW5nIG9uIGJ1dHRvbiBjbGlja1xuXHRcdHN3aXRjaChzaV9idXR0b24pIHtcblx0XHRcdC8vIG1lbnVcblx0XHRcdGNhc2UgJ21lbnUnOiB7XG5cdFx0XHRcdC8vIGV4cGFuZCBtZW51XG5cdFx0XHRcdCR5d19tZW51X2V4cGFuZGVkID0gdHJ1ZTtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Ly8gY3VycmVudCB0aHJlYWQgaGVhZCBsb2FkZWRcblx0XHRcdGNhc2Ugc2lfdGhyZWFkX2hlYWQ6IHtcblx0XHRcdFx0Ly8gc2Nyb2xsIHRvIHRvcCBzbW9vdGhseVxuXHRcdFx0XHQkeXdfbmF2aWdhdG9yLmFjdGl2ZVBhZ2UuZG9tLnNjcm9sbFRvKHtcblx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRiZWhhdmlvcjogJ3Ntb290aCcsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB3aXRoaW4gdGhpcyB0aHJlYWRcblx0XHRcdGNhc2UgJHl3X3RocmVhZC5pZDoge1xuXHRcdFx0XHQvLyBwcmV2aW91czsgcG9wXG5cdFx0XHRcdGNvbnN0IGtfcHJldmlvdXMgPSAkeXdfcGFnZS5wZWFrKCk7XG5cdFx0XHRcdGlmKGtfcHJldmlvdXMgJiYgSE1fSE9NRVNDUkVFTlMuZ2V0KGtfcHJldmlvdXMuY3JlYXRvcikgPT09ICR5d190aHJlYWQuaWQpIHtcblx0XHRcdFx0XHQkeXdfcGFnZS5wb3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBjdXJyZW50IHRocmVhZCB3b24ndCBjYXVzZSB1cGRhdGVcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0JHl3X3BhZ2UucmVzZXQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzd2l0Y2ggdGhyZWFkXG5cdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdC8vICR5d190aHJlYWRfaWQgPSBzaV9idXR0b24gYXMgVGhyZWFkSWQ7XG5cdFx0XHRcdHZvaWQgJHl3X25hdmlnYXRvci5hY3RpdmF0ZVRocmVhZChzaV9idXR0b24gYXMgVGhyZWFkSWQpO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0Ly8gY29uc3QgSE1fSE9NRVNDUkVFTlMgPSBuZXcgTWFwPFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvciwgVGhyZWFkSWQ+KFtcblx0Ly8gXHRbSG9sZGluZ3MsIFRocmVhZElkLlRPS0VOU10sXG5cdC8vIFx0W0NvbnRhY3RMaXN0LCBUaHJlYWRJZC5DT05UQUNUU10sXG5cdC8vIF0pO1xuXG5cdC8vIGNvbnN0IEhfSE9NRVM6IFJlY29yZDxzdHJpbmcsIFRocmVhZElkPiA9IHtcblx0Ly8gXHQnL2ZhbWlsaWVzL3tmYW1pbHlJZH0vY2hhaW5zL3tjaGFpbklkfS9ob2xkaW5ncy97YWNjb3VudElkfSc6IFRocmVhZElkLlRPS0VOUyxcblx0Ly8gXHQnL2ZhbWlsaWVzL3tmYW1pbHlJZH0vY2hhaW5zL3tjaGFpbklkfS9nYWxsZXJ5L3thY2NvdW50SWR9JzogVGhyZWFkSWQuTkZUUyxcblx0Ly8gXHQnL2NvbnRhY3RzJzogVGhyZWFkSWQuQ09OVEFDVFMsXG5cdC8vIFx0Ly8gJy9uZXR3b3Jrcyc6IFRocmVhZElkLk5FVFdPUktTLFxuXHQvLyBcdCcvYWNjb3VudHMnOiBUaHJlYWRJZC5BQ0NPVU5UUyxcblx0Ly8gXHQnL2hpc3RvcnknOiBUaHJlYWRJZC5ISVNUT1JZLFxuXHQvLyB9O1xuXG5cdC8vIGxldCBzaV90aHJlYWRfaGVhZDogJycgfCBUaHJlYWRJZCA9ICcnO1xuXHQvLyAkOiB7XG5cdC8vIFx0JHl3X3BhZ2Vcblx0Ly8gXHQkeXdfdGhyZWFkXG5cdC8vIFx0Ly8gY29uc3Qgc3hfcGF0dGVybiA9ICR5d19wYXR0ZXJuO1xuXG5cdC8vIFx0c2lfdGhyZWFkX2hlYWQgPSBIX0hPTUVTW3N4X3BhdHRlcm5dIHx8ICcnO1xuXHQvLyB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0bmF2IHtcblx0XHQtLW5hdi1oZWlnaHQ6IDcycHg7XG5cblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0Ym90dG9tOiAwO1xuXHRcdGhlaWdodDogdmFyKC0tbmF2LWhlaWdodCk7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdHotaW5kZXg6IDEwMDA7XG5cblx0XHR0cmFuc2l0aW9uOiBib3R0b20gMXMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXG5cdFx0ZGlzcGxheTogbm9uZTtcblx0XHQmLnZpc2libGUge1xuXHRcdFx0ZGlzcGxheTogaW5pdGlhbDtcblx0XHR9XG5cblx0XHQmLmNvbGxhcHNlZCB7XG5cdFx0XHRib3R0b206IGNhbGMoMHB4IC0gdmFyKC0tbmF2LWhlaWdodCkpO1xuXG5cdFx0XHQ+LmNvbGxhcHNlLmljb24+c3ZnIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoLTE4MGRlZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQ+LmNvbGxhcHNlLmljb24ge1xuXHRcdFx0LS1idXR0b24tZGlhbWV0ZXI6IDMycHg7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cblx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0cmlnaHQ6IDA7XG5cdFx0XHR0b3A6IGNhbGMoMHB4IC0gdmFyKC0tYnV0dG9uLWRpYW1ldGVyKSk7XG5cblx0XHRcdGJvcmRlci1yYWRpdXM6IDA7XG5cdFx0XHRib3JkZXItYm90dG9tLXdpZHRoOiAwO1xuXHRcdFx0Ym9yZGVyLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblxuXHRcdFx0PnN2ZyB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuXHRcdFx0XHRcdHRyYW5zaXRpb246IHRyYW5zZm9ybSAxcyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdH1cblxuXHRcdD4uYmFyIHtcblx0XHRcdGxpc3Qtc3R5bGU6IG5vbmU7XG5cdFx0XHRwYWRkaW5nOiAwO1xuXHRcdFx0bWFyZ2luOiAwO1xuXG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXG5cdFx0XHRib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblxuXHRcdFx0Pi5idXR0b24ge1xuXHRcdFx0XHRmbGV4OiAxO1xuXHRcdFx0XHRwYWRkaW5nLXRvcDogMTFweDtcblx0XHRcdFx0cGFkZGluZy1ib3R0b206IDEycHg7XG5cblx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cblx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXG5cdFx0XHRcdCYuYWN0aXZlIHtcblx0XHRcdFx0XHQmLnRva2VucyB7XG5cdFx0XHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCYuY29udGFjdHMge1xuXHRcdFx0XHRcdFx0LS1zdmctY29sb3ItZmc6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQmLm5mdHMge1xuXHRcdFx0XHRcdFx0LS1zdmctY29sb3ItZmc6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQmLmhpc3Rvcnkge1xuXHRcdFx0XHRcdFx0LS1zdmctY29sb3ItZmc6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdD4ubGFiZWwge1xuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4uaWNvbiB7XG5cdFx0XHRcdFx0LmluaGVyaXQoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC5ub3RpZmljYXRpb24ge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdFx0XHR3aWR0aDogN3B4O1xuXHRcdFx0XHRcdGhlaWdodDogN3B4O1xuXHRcdFx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXNreSk7XG5cdFx0XHRcdFx0Ym9yZGVyLXJhZGl1czogN3B4O1xuXHRcdFx0XHRcdG1hcmdpbi10b3A6IDE1cHg7XG5cdFx0XHRcdFx0Ym9yZGVyOiAycHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0XHRcdG1hcmdpbi1sZWZ0OiAtOXB4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5sYWJlbCB7XG5cdFx0XHRcdFx0Zm9udC1zaXplOiAxMXB4O1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxuYXYgY2xhc3M6Y29sbGFwc2VkPXskeXdfbmF2X2NvbGxhcHNlZH0gY2xhc3M6dmlzaWJsZT17JHl3X25hdl92aXNpYmxlfT5cblx0PGRpdiBjbGFzcz1cImNvbGxhcHNlIGljb25cIiBvbjpjbGljaz17KCkgPT4gdG9nZ2xlX2NvbGxhcHNlZCgpfT5cblx0XHR7QGh0bWwgU1hfSUNPTl9FWFBBTkR9XG5cdDwvZGl2PlxuXHQ8dWwgY2xhc3M9XCJiYXJcIj5cblx0XHR7I2VhY2ggb2RlKEhfQlVUVE9OUykgYXMgW3NpX2J1dHRvbiwgZ19idXR0b25dfVxuXHRcdFx0eyNpZiBnX2J1dHRvbi5kaXNhYmxlZH1cblx0XHRcdFx0PGxpIGNsYXNzPVwiYnV0dG9uIHtzaV9idXR0b259XCIgY2xhc3M6YWN0aXZlPXtzaV90aHJlYWRfaGVhZCA9PT0gc2lfYnV0dG9ufSBzdHlsZT1cIm9wYWNpdHk6IDAuNTtcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0e0BodG1sIGdfYnV0dG9uLnN2Z31cblxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJub3RpZmljYXRpb25cIiBjbGFzczpkaXNwbGF5X25vbmU9eyEkeXdfbm90aWZpY2F0aW9ucy5pbmNsdWRlcyhzaV9idXR0b24pfT48L3NwYW4+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxhYmVsXCI+XG5cdFx0XHRcdFx0XHR7Z19idXR0b24ubGFiZWx9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdDxsaSBjbGFzcz1cImJ1dHRvbiB7c2lfYnV0dG9ufVwiIGNsYXNzOmFjdGl2ZT17c2lfdGhyZWFkX2hlYWQgPT09IHNpX2J1dHRvbn0gb246Y2xpY2s9eygpID0+IG5hdl9jbGljayhzaV9idXR0b24pfT5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0e0BodG1sIGdfYnV0dG9uLnN2Z31cblxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJub3RpZmljYXRpb25cIiBjbGFzczpkaXNwbGF5X25vbmU9eyEkeXdfbm90aWZpY2F0aW9ucy5pbmNsdWRlcyhzaV9idXR0b24pfT48L3NwYW4+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxhYmVsXCI+XG5cdFx0XHRcdFx0XHR7Z19idXR0b24ubGFiZWx9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHR7L2lmfVxuXHRcdHsvZWFjaH1cblx0XHQ8L3VsPlxuPC9uYXY+XG4iLCIvKipcbiAqIEZ1c2UuanMgdjYuNi4yIC0gTGlnaHR3ZWlnaHQgZnV6enktc2VhcmNoIChodHRwOi8vZnVzZWpzLmlvKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMiBLaXJvIFJpc2sgKGh0dHA6Ly9raXJvLm1lKVxuICogQWxsIFJpZ2h0cyBSZXNlcnZlZC4gQXBhY2hlIFNvZnR3YXJlIExpY2Vuc2UgMi4wXG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gIUFycmF5LmlzQXJyYXlcbiAgICA/IGdldFRhZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsdWUpXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2Jhc2VUb1N0cmluZy5qc1xuY29uc3QgSU5GSU5JVFkgPSAxIC8gMDtcbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZhbHVlICsgJyc7XG4gIHJldHVybiByZXN1bHQgPT0gJzAnICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyAnLTAnIDogcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvaXNCb29sZWFuLmpzXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA9PT0gdHJ1ZSB8fFxuICAgIHZhbHVlID09PSBmYWxzZSB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gJ1tvYmplY3QgQm9vbGVhbl0nKVxuICApXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbi8vIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzQmxhbmsodmFsdWUpIHtcbiAgcmV0dXJuICF2YWx1ZS50cmltKCkubGVuZ3RoXG59XG5cbi8vIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2dldFRhZy5qc1xuZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsXG4gICAgPyB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICdbb2JqZWN0IFVuZGVmaW5lZF0nXG4gICAgICA6ICdbb2JqZWN0IE51bGxdJ1xuICAgIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxufVxuXG5jb25zdCBFWFRFTkRFRF9TRUFSQ0hfVU5BVkFJTEFCTEUgPSAnRXh0ZW5kZWQgc2VhcmNoIGlzIG5vdCBhdmFpbGFibGUnO1xuXG5jb25zdCBJTkNPUlJFQ1RfSU5ERVhfVFlQRSA9IFwiSW5jb3JyZWN0ICdpbmRleCcgdHlwZVwiO1xuXG5jb25zdCBMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkgPSAoa2V5KSA9PlxuICBgSW52YWxpZCB2YWx1ZSBmb3Iga2V5ICR7a2V5fWA7XG5cbmNvbnN0IFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRSA9IChtYXgpID0+XG4gIGBQYXR0ZXJuIGxlbmd0aCBleGNlZWRzIG1heCBvZiAke21heH0uYDtcblxuY29uc3QgTUlTU0lOR19LRVlfUFJPUEVSVFkgPSAobmFtZSkgPT4gYE1pc3NpbmcgJHtuYW1lfSBwcm9wZXJ0eSBpbiBrZXlgO1xuXG5jb25zdCBJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUgPSAoa2V5KSA9PlxuICBgUHJvcGVydHkgJ3dlaWdodCcgaW4ga2V5ICcke2tleX0nIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyYDtcblxuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuY2xhc3MgS2V5U3RvcmUge1xuICBjb25zdHJ1Y3RvcihrZXlzKSB7XG4gICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgIHRoaXMuX2tleU1hcCA9IHt9O1xuXG4gICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBsZXQgb2JqID0gY3JlYXRlS2V5KGtleSk7XG5cbiAgICAgIHRvdGFsV2VpZ2h0ICs9IG9iai53ZWlnaHQ7XG5cbiAgICAgIHRoaXMuX2tleXMucHVzaChvYmopO1xuICAgICAgdGhpcy5fa2V5TWFwW29iai5pZF0gPSBvYmo7XG5cbiAgICAgIHRvdGFsV2VpZ2h0ICs9IG9iai53ZWlnaHQ7XG4gICAgfSk7XG5cbiAgICAvLyBOb3JtYWxpemUgd2VpZ2h0cyBzbyB0aGF0IHRoZWlyIHN1bSBpcyBlcXVhbCB0byAxXG4gICAgdGhpcy5fa2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGtleS53ZWlnaHQgLz0gdG90YWxXZWlnaHQ7XG4gICAgfSk7XG4gIH1cbiAgZ2V0KGtleUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleU1hcFtrZXlJZF1cbiAgfVxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9rZXlzXG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLl9rZXlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgbGV0IHBhdGggPSBudWxsO1xuICBsZXQgaWQgPSBudWxsO1xuICBsZXQgc3JjID0gbnVsbDtcbiAgbGV0IHdlaWdodCA9IDE7XG4gIGxldCBnZXRGbiA9IG51bGw7XG5cbiAgaWYgKGlzU3RyaW5nKGtleSkgfHwgaXNBcnJheShrZXkpKSB7XG4gICAgc3JjID0ga2V5O1xuICAgIHBhdGggPSBjcmVhdGVLZXlQYXRoKGtleSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChrZXkpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaGFzT3duLmNhbGwoa2V5LCAnbmFtZScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTUlTU0lOR19LRVlfUFJPUEVSVFkoJ25hbWUnKSlcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0ga2V5Lm5hbWU7XG4gICAgc3JjID0gbmFtZTtcblxuICAgIGlmIChoYXNPd24uY2FsbChrZXksICd3ZWlnaHQnKSkge1xuICAgICAgd2VpZ2h0ID0ga2V5LndlaWdodDtcblxuICAgICAgaWYgKHdlaWdodCA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0tFWV9XRUlHSFRfVkFMVUUobmFtZSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgobmFtZSk7XG4gICAgaWQgPSBjcmVhdGVLZXlJZChuYW1lKTtcbiAgICBnZXRGbiA9IGtleS5nZXRGbjtcbiAgfVxuXG4gIHJldHVybiB7IHBhdGgsIGlkLCB3ZWlnaHQsIHNyYywgZ2V0Rm4gfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlQYXRoKGtleSkge1xuICByZXR1cm4gaXNBcnJheShrZXkpID8ga2V5IDoga2V5LnNwbGl0KCcuJylcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5SWQoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkuam9pbignLicpIDoga2V5XG59XG5cbmZ1bmN0aW9uIGdldChvYmosIHBhdGgpIHtcbiAgbGV0IGxpc3QgPSBbXTtcbiAgbGV0IGFyciA9IGZhbHNlO1xuXG4gIGNvbnN0IGRlZXBHZXQgPSAob2JqLCBwYXRoLCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG9iaikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIXBhdGhbaW5kZXhdKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhdGggbGVmdCwgd2UndmUgYXJyaXZlZCBhdCB0aGUgb2JqZWN0IHdlIGNhcmUgYWJvdXQuXG4gICAgICBsaXN0LnB1c2gob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGtleSA9IHBhdGhbaW5kZXhdO1xuXG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGF0IHRoZSBsYXN0IHZhbHVlIGluIHRoZSBwYXRoLCBhbmQgaWYgaXQncyBhIHN0cmluZy9udW1iZXIvYm9vbCxcbiAgICAgIC8vIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgaWYgKFxuICAgICAgICBpbmRleCA9PT0gcGF0aC5sZW5ndGggLSAxICYmXG4gICAgICAgIChpc1N0cmluZyh2YWx1ZSkgfHwgaXNOdW1iZXIodmFsdWUpIHx8IGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgICApIHtcbiAgICAgICAgbGlzdC5wdXNoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGFyciA9IHRydWU7XG4gICAgICAgIC8vIFNlYXJjaCBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBkZWVwR2V0KHZhbHVlW2ldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFuIG9iamVjdC4gUmVjdXJzZSBmdXJ0aGVyLlxuICAgICAgICBkZWVwR2V0KHZhbHVlLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoc2luY2UgcGF0aCB1c2VkIHRvIGJlIGEgc3RyaW5nKVxuICBkZWVwR2V0KG9iaiwgaXNTdHJpbmcocGF0aCkgPyBwYXRoLnNwbGl0KCcuJykgOiBwYXRoLCAwKTtcblxuICByZXR1cm4gYXJyID8gbGlzdCA6IGxpc3RbMF1cbn1cblxuY29uc3QgTWF0Y2hPcHRpb25zID0ge1xuICAvLyBXaGV0aGVyIHRoZSBtYXRjaGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IHNldC4gV2hlbiBgdHJ1ZWAsIGVhY2ggcmVjb3JkIGluIHRoZSByZXN1bHRcbiAgLy8gc2V0IHdpbGwgaW5jbHVkZSB0aGUgaW5kaWNlcyBvZiB0aGUgbWF0Y2hlZCBjaGFyYWN0ZXJzLlxuICAvLyBUaGVzZSBjYW4gY29uc2VxdWVudGx5IGJlIHVzZWQgZm9yIGhpZ2hsaWdodGluZyBwdXJwb3Nlcy5cbiAgaW5jbHVkZU1hdGNoZXM6IGZhbHNlLFxuICAvLyBXaGVuIGB0cnVlYCwgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHdpbGwgY29udGludWUgdG8gdGhlIGVuZCBvZiBhIHNlYXJjaCBwYXR0ZXJuIGV2ZW4gaWZcbiAgLy8gYSBwZXJmZWN0IG1hdGNoIGhhcyBhbHJlYWR5IGJlZW4gbG9jYXRlZCBpbiB0aGUgc3RyaW5nLlxuICBmaW5kQWxsTWF0Y2hlczogZmFsc2UsXG4gIC8vIE1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBtdXN0IGJlIG1hdGNoZWQgYmVmb3JlIGEgcmVzdWx0IGlzIGNvbnNpZGVyZWQgYSBtYXRjaFxuICBtaW5NYXRjaENoYXJMZW5ndGg6IDFcbn07XG5cbmNvbnN0IEJhc2ljT3B0aW9ucyA9IHtcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBhbGdvcml0aG0gY29udGludWVzIHNlYXJjaGluZyB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dCBldmVuIGlmIGEgcGVyZmVjdFxuICAvLyBtYXRjaCBpcyBmb3VuZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgc2FtZSBpbnB1dC5cbiAgaXNDYXNlU2Vuc2l0aXZlOiBmYWxzZSxcbiAgLy8gV2hlbiB0cnVlLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICBpbmNsdWRlU2NvcmU6IGZhbHNlLFxuICAvLyBMaXN0IG9mIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIHNlYXJjaGVkLiBUaGlzIGFsc28gc3VwcG9ydHMgbmVzdGVkIHByb3BlcnRpZXMuXG4gIGtleXM6IFtdLFxuICAvLyBXaGV0aGVyIHRvIHNvcnQgdGhlIHJlc3VsdCBsaXN0LCBieSBzY29yZVxuICBzaG91bGRTb3J0OiB0cnVlLFxuICAvLyBEZWZhdWx0IHNvcnQgZnVuY3Rpb246IHNvcnQgYnkgYXNjZW5kaW5nIHNjb3JlLCBhc2NlbmRpbmcgaW5kZXhcbiAgc29ydEZuOiAoYSwgYikgPT5cbiAgICBhLnNjb3JlID09PSBiLnNjb3JlID8gKGEuaWR4IDwgYi5pZHggPyAtMSA6IDEpIDogYS5zY29yZSA8IGIuc2NvcmUgPyAtMSA6IDFcbn07XG5cbmNvbnN0IEZ1enp5T3B0aW9ucyA9IHtcbiAgLy8gQXBwcm94aW1hdGVseSB3aGVyZSBpbiB0aGUgdGV4dCBpcyB0aGUgcGF0dGVybiBleHBlY3RlZCB0byBiZSBmb3VuZD9cbiAgbG9jYXRpb246IDAsXG4gIC8vIEF0IHdoYXQgcG9pbnQgZG9lcyB0aGUgbWF0Y2ggYWxnb3JpdGhtIGdpdmUgdXAuIEEgdGhyZXNob2xkIG9mICcwLjAnIHJlcXVpcmVzIGEgcGVyZmVjdCBtYXRjaFxuICAvLyAob2YgYm90aCBsZXR0ZXJzIGFuZCBsb2NhdGlvbiksIGEgdGhyZXNob2xkIG9mICcxLjAnIHdvdWxkIG1hdGNoIGFueXRoaW5nLlxuICB0aHJlc2hvbGQ6IDAuNixcbiAgLy8gRGV0ZXJtaW5lcyBob3cgY2xvc2UgdGhlIG1hdGNoIG11c3QgYmUgdG8gdGhlIGZ1enp5IGxvY2F0aW9uIChzcGVjaWZpZWQgYWJvdmUpLlxuICAvLyBBbiBleGFjdCBsZXR0ZXIgbWF0Y2ggd2hpY2ggaXMgJ2Rpc3RhbmNlJyBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZnV6enkgbG9jYXRpb25cbiAgLy8gd291bGQgc2NvcmUgYXMgYSBjb21wbGV0ZSBtaXNtYXRjaC4gQSBkaXN0YW5jZSBvZiAnMCcgcmVxdWlyZXMgdGhlIG1hdGNoIGJlIGF0XG4gIC8vIHRoZSBleGFjdCBsb2NhdGlvbiBzcGVjaWZpZWQsIGEgdGhyZXNob2xkIG9mICcxMDAwJyB3b3VsZCByZXF1aXJlIGEgcGVyZmVjdCBtYXRjaFxuICAvLyB0byBiZSB3aXRoaW4gODAwIGNoYXJhY3RlcnMgb2YgdGhlIGZ1enp5IGxvY2F0aW9uIHRvIGJlIGZvdW5kIHVzaW5nIGEgMC44IHRocmVzaG9sZC5cbiAgZGlzdGFuY2U6IDEwMFxufTtcblxuY29uc3QgQWR2YW5jZWRPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgaXQgZW5hYmxlcyB0aGUgdXNlIG9mIHVuaXgtbGlrZSBzZWFyY2ggY29tbWFuZHNcbiAgdXNlRXh0ZW5kZWRTZWFyY2g6IGZhbHNlLFxuICAvLyBUaGUgZ2V0IGZ1bmN0aW9uIHRvIHVzZSB3aGVuIGZldGNoaW5nIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIC8vIFRoZSBkZWZhdWx0IHdpbGwgc2VhcmNoIG5lc3RlZCBwYXRocyAqaWUgZm9vLmJhci5iYXoqXG4gIGdldEZuOiBnZXQsXG4gIC8vIFdoZW4gYHRydWVgLCBzZWFyY2ggd2lsbCBpZ25vcmUgYGxvY2F0aW9uYCBhbmQgYGRpc3RhbmNlYCwgc28gaXQgd29uJ3QgbWF0dGVyXG4gIC8vIHdoZXJlIGluIHRoZSBzdHJpbmcgdGhlIHBhdHRlcm4gYXBwZWFycy5cbiAgLy8gTW9yZSBpbmZvOiBodHRwczovL2Z1c2Vqcy5pby9jb25jZXB0cy9zY29yaW5nLXRoZW9yeS5odG1sI2Z1enppbmVzcy1zY29yZVxuICBpZ25vcmVMb2NhdGlvbjogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSByZWxldmFuY2Ugc2NvcmUgKHVzZWQgZm9yIHNvcnRpbmcpIHdpbGxcbiAgLy8gaWdub3JlIHRoZSBmaWVsZC1sZW5ndGggbm9ybS5cbiAgLy8gTW9yZSBpbmZvOiBodHRwczovL2Z1c2Vqcy5pby9jb25jZXB0cy9zY29yaW5nLXRoZW9yeS5odG1sI2ZpZWxkLWxlbmd0aC1ub3JtXG4gIGlnbm9yZUZpZWxkTm9ybTogZmFsc2UsXG4gIC8vIFRoZSB3ZWlnaHQgdG8gZGV0ZXJtaW5lIGhvdyBtdWNoIGZpZWxkIGxlbmd0aCBub3JtIGVmZmVjdHMgc2NvcmluZy5cbiAgZmllbGROb3JtV2VpZ2h0OiAxXG59O1xuXG52YXIgQ29uZmlnID0ge1xuICAuLi5CYXNpY09wdGlvbnMsXG4gIC4uLk1hdGNoT3B0aW9ucyxcbiAgLi4uRnV6enlPcHRpb25zLFxuICAuLi5BZHZhbmNlZE9wdGlvbnNcbn07XG5cbmNvbnN0IFNQQUNFID0gL1teIF0rL2c7XG5cbi8vIEZpZWxkLWxlbmd0aCBub3JtOiB0aGUgc2hvcnRlciB0aGUgZmllbGQsIHRoZSBoaWdoZXIgdGhlIHdlaWdodC5cbi8vIFNldCB0byAzIGRlY2ltYWxzIHRvIHJlZHVjZSBpbmRleCBzaXplLlxuZnVuY3Rpb24gbm9ybSh3ZWlnaHQgPSAxLCBtYW50aXNzYSA9IDMpIHtcbiAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG0gPSBNYXRoLnBvdygxMCwgbWFudGlzc2EpO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0KHZhbHVlKSB7XG4gICAgICBjb25zdCBudW1Ub2tlbnMgPSB2YWx1ZS5tYXRjaChTUEFDRSkubGVuZ3RoO1xuXG4gICAgICBpZiAoY2FjaGUuaGFzKG51bVRva2VucykpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldChudW1Ub2tlbnMpXG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHQgZnVuY3Rpb24gaXMgMS9zcXJ0KHgpLCB3ZWlnaHQgbWFrZXMgdGhhdCB2YXJpYWJsZVxuICAgICAgY29uc3Qgbm9ybSA9IDEgLyBNYXRoLnBvdyhudW1Ub2tlbnMsIDAuNSAqIHdlaWdodCk7XG5cbiAgICAgIC8vIEluIHBsYWNlIG9mIGB0b0ZpeGVkKG1hbnRpc3NhKWAsIGZvciBmYXN0ZXIgY29tcHV0YXRpb25cbiAgICAgIGNvbnN0IG4gPSBwYXJzZUZsb2F0KE1hdGgucm91bmQobm9ybSAqIG0pIC8gbSk7XG5cbiAgICAgIGNhY2hlLnNldChudW1Ub2tlbnMsIG4pO1xuXG4gICAgICByZXR1cm4gblxuICAgIH0sXG4gICAgY2xlYXIoKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXNlSW5kZXgge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sXG4gICAgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodFxuICB9ID0ge30pIHtcbiAgICB0aGlzLm5vcm0gPSBub3JtKGZpZWxkTm9ybVdlaWdodCwgMyk7XG4gICAgdGhpcy5nZXRGbiA9IGdldEZuO1xuICAgIHRoaXMuaXNDcmVhdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldEluZGV4UmVjb3JkcygpO1xuICB9XG4gIHNldFNvdXJjZXMoZG9jcyA9IFtdKSB7XG4gICAgdGhpcy5kb2NzID0gZG9jcztcbiAgfVxuICBzZXRJbmRleFJlY29yZHMocmVjb3JkcyA9IFtdKSB7XG4gICAgdGhpcy5yZWNvcmRzID0gcmVjb3JkcztcbiAgfVxuICBzZXRLZXlzKGtleXMgPSBbXSkge1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgdGhpcy5fa2V5c01hcCA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoa2V5LCBpZHgpID0+IHtcbiAgICAgIHRoaXMuX2tleXNNYXBba2V5LmlkXSA9IGlkeDtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNDcmVhdGVkIHx8ICF0aGlzLmRvY3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmlzQ3JlYXRlZCA9IHRydWU7XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PFN0cmluZz5cbiAgICBpZiAoaXNTdHJpbmcodGhpcy5kb2NzWzBdKSkge1xuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgICAgdGhpcy5kb2NzLmZvckVhY2goKGRvYywgZG9jSW5kZXgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgZG9jSW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3JtLmNsZWFyKCk7XG4gIH1cbiAgLy8gQWRkcyBhIGRvYyB0byB0aGUgZW5kIG9mIHRoZSBpbmRleFxuICBhZGQoZG9jKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5zaXplKCk7XG5cbiAgICBpZiAoaXNTdHJpbmcoZG9jKSkge1xuICAgICAgdGhpcy5fYWRkU3RyaW5nKGRvYywgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRkT2JqZWN0KGRvYywgaWR4KTtcbiAgICB9XG4gIH1cbiAgLy8gUmVtb3ZlcyB0aGUgZG9jIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb2YgdGhlIGluZGV4XG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMucmVjb3Jkcy5zcGxpY2UoaWR4LCAxKTtcblxuICAgIC8vIENoYW5nZSByZWYgaW5kZXggb2YgZXZlcnkgc3Vic3F1ZW50IGRvY1xuICAgIGZvciAobGV0IGkgPSBpZHgsIGxlbiA9IHRoaXMuc2l6ZSgpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMucmVjb3Jkc1tpXS5pIC09IDE7XG4gICAgfVxuICB9XG4gIGdldFZhbHVlRm9ySXRlbUF0S2V5SWQoaXRlbSwga2V5SWQpIHtcbiAgICByZXR1cm4gaXRlbVt0aGlzLl9rZXlzTWFwW2tleUlkXV1cbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlY29yZHMubGVuZ3RoXG4gIH1cbiAgX2FkZFN0cmluZyhkb2MsIGRvY0luZGV4KSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZG9jKSB8fCBpc0JsYW5rKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCByZWNvcmQgPSB7XG4gICAgICB2OiBkb2MsXG4gICAgICBpOiBkb2NJbmRleCxcbiAgICAgIG46IHRoaXMubm9ybS5nZXQoZG9jKVxuICAgIH07XG5cbiAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIF9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCkge1xuICAgIGxldCByZWNvcmQgPSB7IGk6IGRvY0luZGV4LCAkOiB7fSB9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGtleSAoaS5lLCBwYXRoKSwgYW5kIGZldGNoIHRoZSB2YWx1ZSBhdCB0aGF0IGtleVxuICAgIHRoaXMua2V5cy5mb3JFYWNoKChrZXksIGtleUluZGV4KSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBrZXkuZ2V0Rm4gPyBrZXkuZ2V0Rm4oZG9jKSA6IHRoaXMuZ2V0Rm4oZG9jLCBrZXkucGF0aCk7XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGxldCBzdWJSZWNvcmRzID0gW107XG4gICAgICAgIGNvbnN0IHN0YWNrID0gW3sgbmVzdGVkQXJySW5kZXg6IC0xLCB2YWx1ZSB9XTtcblxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgeyBuZXN0ZWRBcnJJbmRleCwgdmFsdWUgfSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgc3ViUmVjb3JkID0ge1xuICAgICAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICAgICAgaTogbmVzdGVkQXJySW5kZXgsXG4gICAgICAgICAgICAgIG46IHRoaXMubm9ybS5nZXQodmFsdWUpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJSZWNvcmRzLnB1c2goc3ViUmVjb3JkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBrKSA9PiB7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIG5lc3RlZEFyckluZGV4OiBrLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIDtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmQuJFtrZXlJbmRleF0gPSBzdWJSZWNvcmRzO1xuICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgdjogdmFsdWUsXG4gICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgfTtcblxuICAgICAgICByZWNvcmQuJFtrZXlJbmRleF0gPSBzdWJSZWNvcmQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogdGhpcy5rZXlzLFxuICAgICAgcmVjb3JkczogdGhpcy5yZWNvcmRzXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4KFxuICBrZXlzLFxuICBkb2NzLFxuICB7IGdldEZuID0gQ29uZmlnLmdldEZuLCBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0IH0gPSB7fVxuKSB7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMubWFwKGNyZWF0ZUtleSkpO1xuICBteUluZGV4LnNldFNvdXJjZXMoZG9jcyk7XG4gIG15SW5kZXguY3JlYXRlKCk7XG4gIHJldHVybiBteUluZGV4XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW5kZXgoXG4gIGRhdGEsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSBkYXRhO1xuICBjb25zdCBteUluZGV4ID0gbmV3IEZ1c2VJbmRleCh7IGdldEZuLCBmaWVsZE5vcm1XZWlnaHQgfSk7XG4gIG15SW5kZXguc2V0S2V5cyhrZXlzKTtcbiAgbXlJbmRleC5zZXRJbmRleFJlY29yZHMocmVjb3Jkcyk7XG4gIHJldHVybiBteUluZGV4XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZSQxKFxuICBwYXR0ZXJuLFxuICB7XG4gICAgZXJyb3JzID0gMCxcbiAgICBjdXJyZW50TG9jYXRpb24gPSAwLFxuICAgIGV4cGVjdGVkTG9jYXRpb24gPSAwLFxuICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IGFjY3VyYWN5ID0gZXJyb3JzIC8gcGF0dGVybi5sZW5ndGg7XG5cbiAgaWYgKGlnbm9yZUxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGFjY3VyYWN5XG4gIH1cblxuICBjb25zdCBwcm94aW1pdHkgPSBNYXRoLmFicyhleHBlY3RlZExvY2F0aW9uIC0gY3VycmVudExvY2F0aW9uKTtcblxuICBpZiAoIWRpc3RhbmNlKSB7XG4gICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXG4gICAgcmV0dXJuIHByb3hpbWl0eSA/IDEuMCA6IGFjY3VyYWN5XG4gIH1cblxuICByZXR1cm4gYWNjdXJhY3kgKyBwcm94aW1pdHkgLyBkaXN0YW5jZVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TWFza1RvSW5kaWNlcyhcbiAgbWF0Y2htYXNrID0gW10sXG4gIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGhcbikge1xuICBsZXQgaW5kaWNlcyA9IFtdO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChsZXQgbGVuID0gbWF0Y2htYXNrLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgbGV0IG1hdGNoID0gbWF0Y2htYXNrW2ldO1xuICAgIGlmIChtYXRjaCAmJiBzdGFydCA9PT0gLTEpIHtcbiAgICAgIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaCAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgIGVuZCA9IGkgLSAxO1xuICAgICAgaWYgKGVuZCAtIHN0YXJ0ICsgMSA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKFtzdGFydCwgZW5kXSk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8vIChpLTEgLSBzdGFydCkgKyAxID0+IGkgLSBzdGFydFxuICBpZiAobWF0Y2htYXNrW2kgLSAxXSAmJiBpIC0gc3RhcnQgPj0gbWluTWF0Y2hDaGFyTGVuZ3RoKSB7XG4gICAgaW5kaWNlcy5wdXNoKFtzdGFydCwgaSAtIDFdKTtcbiAgfVxuXG4gIHJldHVybiBpbmRpY2VzXG59XG5cbi8vIE1hY2hpbmUgd29yZCBzaXplXG5jb25zdCBNQVhfQklUUyA9IDMyO1xuXG5mdW5jdGlvbiBzZWFyY2goXG4gIHRleHQsXG4gIHBhdHRlcm4sXG4gIHBhdHRlcm5BbHBoYWJldCxcbiAge1xuICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICB9ID0ge31cbikge1xuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfQklUUykge1xuICAgIHRocm93IG5ldyBFcnJvcihQQVRURVJOX0xFTkdUSF9UT09fTEFSR0UoTUFYX0JJVFMpKVxuICB9XG5cbiAgY29uc3QgcGF0dGVybkxlbiA9IHBhdHRlcm4ubGVuZ3RoO1xuICAvLyBTZXQgc3RhcnRpbmcgbG9jYXRpb24gYXQgYmVnaW5uaW5nIHRleHQgYW5kIGluaXRpYWxpemUgdGhlIGFscGhhYmV0LlxuICBjb25zdCB0ZXh0TGVuID0gdGV4dC5sZW5ndGg7XG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIGxvY2F0aW9uID4gdGV4dC5sZW5ndGhcbiAgY29uc3QgZXhwZWN0ZWRMb2NhdGlvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvY2F0aW9uLCB0ZXh0TGVuKSk7XG4gIC8vIEhpZ2hlc3Qgc2NvcmUgYmV5b25kIHdoaWNoIHdlIGdpdmUgdXAuXG4gIGxldCBjdXJyZW50VGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAvLyBJcyB0aGVyZSBhIG5lYXJieSBleGFjdCBtYXRjaD8gKHNwZWVkdXApXG4gIGxldCBiZXN0TG9jYXRpb24gPSBleHBlY3RlZExvY2F0aW9uO1xuXG4gIC8vIFBlcmZvcm1hbmNlOiBvbmx5IGNvbXB1dGVyIG1hdGNoZXMgd2hlbiB0aGUgbWluTWF0Y2hDaGFyTGVuZ3RoID4gMVxuICAvLyBPUiBpZiBgaW5jbHVkZU1hdGNoZXNgIGlzIHRydWUuXG4gIGNvbnN0IGNvbXB1dGVNYXRjaGVzID0gbWluTWF0Y2hDaGFyTGVuZ3RoID4gMSB8fCBpbmNsdWRlTWF0Y2hlcztcbiAgLy8gQSBtYXNrIG9mIHRoZSBtYXRjaGVzLCB1c2VkIGZvciBidWlsZGluZyB0aGUgaW5kaWNlc1xuICBjb25zdCBtYXRjaE1hc2sgPSBjb21wdXRlTWF0Y2hlcyA/IEFycmF5KHRleHRMZW4pIDogW107XG5cbiAgbGV0IGluZGV4O1xuXG4gIC8vIEdldCBhbGwgZXhhY3QgbWF0Y2hlcywgaGVyZSBmb3Igc3BlZWQgdXBcbiAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBiZXN0TG9jYXRpb24pKSA+IC0xKSB7XG4gICAgbGV0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgY3VycmVudExvY2F0aW9uOiBpbmRleCxcbiAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG5cbiAgICBjdXJyZW50VGhyZXNob2xkID0gTWF0aC5taW4oc2NvcmUsIGN1cnJlbnRUaHJlc2hvbGQpO1xuICAgIGJlc3RMb2NhdGlvbiA9IGluZGV4ICsgcGF0dGVybkxlbjtcblxuICAgIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBwYXR0ZXJuTGVuKSB7XG4gICAgICAgIG1hdGNoTWFza1tpbmRleCArIGldID0gMTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSBiZXN0IGxvY2F0aW9uXG4gIGJlc3RMb2NhdGlvbiA9IC0xO1xuXG4gIGxldCBsYXN0Qml0QXJyID0gW107XG4gIGxldCBmaW5hbFNjb3JlID0gMTtcbiAgbGV0IGJpbk1heCA9IHBhdHRlcm5MZW4gKyB0ZXh0TGVuO1xuXG4gIGNvbnN0IG1hc2sgPSAxIDw8IChwYXR0ZXJuTGVuIC0gMSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpICs9IDEpIHtcbiAgICAvLyBTY2FuIGZvciB0aGUgYmVzdCBtYXRjaDsgZWFjaCBpdGVyYXRpb24gYWxsb3dzIGZvciBvbmUgbW9yZSBlcnJvci5cbiAgICAvLyBSdW4gYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSBob3cgZmFyIGZyb20gdGhlIG1hdGNoIGxvY2F0aW9uIHdlIGNhbiBzdHJheVxuICAgIC8vIGF0IHRoaXMgZXJyb3IgbGV2ZWwuXG4gICAgbGV0IGJpbk1pbiA9IDA7XG4gICAgbGV0IGJpbk1pZCA9IGJpbk1heDtcblxuICAgIHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcbiAgICAgIGNvbnN0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgICBlcnJvcnM6IGksXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCxcbiAgICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNjb3JlIDw9IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgYmluTWluID0gYmluTWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmluTWF4ID0gYmluTWlkO1xuICAgICAgfVxuXG4gICAgICBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XG4gICAgfVxuXG4gICAgLy8gVXNlIHRoZSByZXN1bHQgZnJvbSB0aGlzIGl0ZXJhdGlvbiBhcyB0aGUgbWF4aW11bSBmb3IgdGhlIG5leHQuXG4gICAgYmluTWF4ID0gYmluTWlkO1xuXG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoMSwgZXhwZWN0ZWRMb2NhdGlvbiAtIGJpbk1pZCArIDEpO1xuICAgIGxldCBmaW5pc2ggPSBmaW5kQWxsTWF0Y2hlc1xuICAgICAgPyB0ZXh0TGVuXG4gICAgICA6IE1hdGgubWluKGV4cGVjdGVkTG9jYXRpb24gKyBiaW5NaWQsIHRleHRMZW4pICsgcGF0dGVybkxlbjtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGJpdCBhcnJheVxuICAgIGxldCBiaXRBcnIgPSBBcnJheShmaW5pc2ggKyAyKTtcblxuICAgIGJpdEFycltmaW5pc2ggKyAxXSA9ICgxIDw8IGkpIC0gMTtcblxuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGogLT0gMSkge1xuICAgICAgbGV0IGN1cnJlbnRMb2NhdGlvbiA9IGogLSAxO1xuICAgICAgbGV0IGNoYXJNYXRjaCA9IHBhdHRlcm5BbHBoYWJldFt0ZXh0LmNoYXJBdChjdXJyZW50TG9jYXRpb24pXTtcblxuICAgICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICAgIC8vIFNwZWVkIHVwOiBxdWljayBib29sIHRvIGludCBjb252ZXJzaW9uIChpLmUsIGBjaGFyTWF0Y2ggPyAxIDogMGApXG4gICAgICAgIG1hdGNoTWFza1tjdXJyZW50TG9jYXRpb25dID0gKyEhY2hhck1hdGNoO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCBwYXNzOiBleGFjdCBtYXRjaFxuICAgICAgYml0QXJyW2pdID0gKChiaXRBcnJbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2g7XG5cbiAgICAgIC8vIFN1YnNlcXVlbnQgcGFzc2VzOiBmdXp6eSBtYXRjaFxuICAgICAgaWYgKGkpIHtcbiAgICAgICAgYml0QXJyW2pdIHw9XG4gICAgICAgICAgKChsYXN0Qml0QXJyW2ogKyAxXSB8IGxhc3RCaXRBcnJbal0pIDw8IDEpIHwgMSB8IGxhc3RCaXRBcnJbaiArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoYml0QXJyW2pdICYgbWFzaykge1xuICAgICAgICBmaW5hbFNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgICAgIGVycm9yczogaSxcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXG4gICAgICAgIC8vIEJ1dCBjaGVjayBhbnl3YXkuXG4gICAgICAgIGlmIChmaW5hbFNjb3JlIDw9IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAvLyBJbmRlZWQgaXQgaXNcbiAgICAgICAgICBjdXJyZW50VGhyZXNob2xkID0gZmluYWxTY29yZTtcbiAgICAgICAgICBiZXN0TG9jYXRpb24gPSBjdXJyZW50TG9jYXRpb247XG5cbiAgICAgICAgICAvLyBBbHJlYWR5IHBhc3NlZCBgbG9jYCwgZG93bmhpbGwgZnJvbSBoZXJlIG9uIGluLlxuICAgICAgICAgIGlmIChiZXN0TG9jYXRpb24gPD0gZXhwZWN0ZWRMb2NhdGlvbikge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXaGVuIHBhc3NpbmcgYGJlc3RMb2NhdGlvbmAsIGRvbid0IGV4Y2VlZCBvdXIgY3VycmVudCBkaXN0YW5jZSBmcm9tIGBleHBlY3RlZExvY2F0aW9uYC5cbiAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBleHBlY3RlZExvY2F0aW9uIC0gYmVzdExvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIGhvcGUgZm9yIGEgKGJldHRlcikgbWF0Y2ggYXQgZ3JlYXRlciBlcnJvciBsZXZlbHMuXG4gICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBlcnJvcnM6IGkgKyAxLFxuICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGlmIChzY29yZSA+IGN1cnJlbnRUaHJlc2hvbGQpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgbGFzdEJpdEFyciA9IGJpdEFycjtcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpc01hdGNoOiBiZXN0TG9jYXRpb24gPj0gMCxcbiAgICAvLyBDb3VudCBleGFjdCBtYXRjaGVzICh0aG9zZSB3aXRoIGEgc2NvcmUgb2YgMCkgdG8gYmUgXCJhbG1vc3RcIiBleGFjdFxuICAgIHNjb3JlOiBNYXRoLm1heCgwLjAwMSwgZmluYWxTY29yZSlcbiAgfTtcblxuICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gY29udmVydE1hc2tUb0luZGljZXMobWF0Y2hNYXNrLCBtaW5NYXRjaENoYXJMZW5ndGgpO1xuICAgIGlmICghaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5pc01hdGNoID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBpbmRpY2VzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pIHtcbiAgbGV0IG1hc2sgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGNvbnN0IGNoYXIgPSBwYXR0ZXJuLmNoYXJBdChpKTtcbiAgICBtYXNrW2NoYXJdID0gKG1hc2tbY2hhcl0gfHwgMCkgfCAoMSA8PCAobGVuIC0gaSAtIDEpKTtcbiAgfVxuXG4gIHJldHVybiBtYXNrXG59XG5cbmNsYXNzIEJpdGFwU2VhcmNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9O1xuXG4gICAgdGhpcy5wYXR0ZXJuID0gaXNDYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcblxuICAgIHRoaXMuY2h1bmtzID0gW107XG5cbiAgICBpZiAoIXRoaXMucGF0dGVybi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGFkZENodW5rID0gKHBhdHRlcm4sIHN0YXJ0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuY2h1bmtzLnB1c2goe1xuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBhbHBoYWJldDogY3JlYXRlUGF0dGVybkFscGhhYmV0KHBhdHRlcm4pLFxuICAgICAgICBzdGFydEluZGV4XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgbGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIGlmIChsZW4gPiBNQVhfQklUUykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3QgcmVtYWluZGVyID0gbGVuICUgTUFYX0JJVFM7XG4gICAgICBjb25zdCBlbmQgPSBsZW4gLSByZW1haW5kZXI7XG5cbiAgICAgIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoaSwgTUFYX0JJVFMpLCBpKTtcbiAgICAgICAgaSArPSBNQVhfQklUUztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbWFpbmRlcikge1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gbGVuIC0gTUFYX0JJVFM7XG4gICAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybi5zdWJzdHIoc3RhcnRJbmRleCksIHN0YXJ0SW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4sIDApO1xuICAgIH1cbiAgfVxuXG4gIHNlYXJjaEluKHRleHQpIHtcbiAgICBjb25zdCB7IGlzQ2FzZVNlbnNpdGl2ZSwgaW5jbHVkZU1hdGNoZXMgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmICghaXNDYXNlU2Vuc2l0aXZlKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEV4YWN0IG1hdGNoXG4gICAgaWYgKHRoaXMucGF0dGVybiA9PT0gdGV4dCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgaXNNYXRjaDogdHJ1ZSxcbiAgICAgICAgc2NvcmU6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICByZXN1bHQuaW5kaWNlcyA9IFtbMCwgdGV4dC5sZW5ndGggLSAxXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBCaXRhcCBhbGdvcml0aG1cbiAgICBjb25zdCB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcbiAgICBsZXQgaGFzTWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jaHVua3MuZm9yRWFjaCgoeyBwYXR0ZXJuLCBhbHBoYWJldCwgc3RhcnRJbmRleCB9KSA9PiB7XG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2godGV4dCwgcGF0dGVybiwgYWxwaGFiZXQsIHtcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uICsgc3RhcnRJbmRleCxcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgaGFzTWF0Y2hlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG5cbiAgICAgIGlmIChpc01hdGNoICYmIGluZGljZXMpIHtcbiAgICAgICAgYWxsSW5kaWNlcyA9IFsuLi5hbGxJbmRpY2VzLCAuLi5pbmRpY2VzXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCByZXN1bHQgPSB7XG4gICAgICBpc01hdGNoOiBoYXNNYXRjaGVzLFxuICAgICAgc2NvcmU6IGhhc01hdGNoZXMgPyB0b3RhbFNjb3JlIC8gdGhpcy5jaHVua3MubGVuZ3RoIDogMVxuICAgIH07XG5cbiAgICBpZiAoaGFzTWF0Y2hlcyAmJiBpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgcmVzdWx0LmluZGljZXMgPSBhbGxJbmRpY2VzO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5jbGFzcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgfVxuICBzdGF0aWMgaXNNdWx0aU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5tdWx0aVJlZ2V4KVxuICB9XG4gIHN0YXRpYyBpc1NpbmdsZU1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZ2V0TWF0Y2gocGF0dGVybiwgdGhpcy5zaW5nbGVSZWdleClcbiAgfVxuICBzZWFyY2goLyp0ZXh0Ki8pIHt9XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoKHBhdHRlcm4sIGV4cCkge1xuICBjb25zdCBtYXRjaGVzID0gcGF0dGVybi5tYXRjaChleHApO1xuICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gOiBudWxsXG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2V4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL149XCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9ePSguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQgPT09IHRoaXMucGF0dGVybjtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICFmaXJlXG5cbmNsYXNzIEludmVyc2VFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4pO1xuICAgIGNvbnN0IGlzTWF0Y2ggPSBpbmRleCA9PT0gLTE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogXmZpbGVcblxuY2xhc3MgUHJlZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdwcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIV5maXJlXG5cbmNsYXNzIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2UtcHJlZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVxcXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9ICF0ZXh0LnN0YXJ0c1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAuZmlsZSRcblxuY2xhc3MgU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdzdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiguKilcXCQkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9IHRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFt0ZXh0Lmxlbmd0aCAtIHRoaXMucGF0dGVybi5sZW5ndGgsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICEuZmlsZSRcblxuY2xhc3MgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1zdWZmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcIiguKilcIlxcJCQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuZW5kc1dpdGgodGhpcy5wYXR0ZXJuKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBGdXp6eU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICAgIHRoaXMuX2JpdGFwU2VhcmNoID0gbmV3IEJpdGFwU2VhcmNoKHBhdHRlcm4sIHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdmdXp6eSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYml0YXBTZWFyY2guc2VhcmNoSW4odGV4dClcbiAgfVxufVxuXG4vLyBUb2tlbjogJ2ZpbGVcblxuY2xhc3MgSW5jbHVkZU1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2luY2x1ZGUnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXidcIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14nKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBsZXQgbG9jYXRpb24gPSAwO1xuICAgIGxldCBpbmRleDtcblxuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBjb25zdCBwYXR0ZXJuTGVuID0gdGhpcy5wYXR0ZXJuLmxlbmd0aDtcblxuICAgIC8vIEdldCBhbGwgZXhhY3QgbWF0Y2hlc1xuICAgIHdoaWxlICgoaW5kZXggPSB0ZXh0LmluZGV4T2YodGhpcy5wYXR0ZXJuLCBsb2NhdGlvbikpID4gLTEpIHtcbiAgICAgIGxvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuICAgICAgaW5kaWNlcy5wdXNoKFtpbmRleCwgbG9jYXRpb24gLSAxXSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNNYXRjaCA9ICEhaW5kaWNlcy5sZW5ndGg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzXG4gICAgfVxuICB9XG59XG5cbi8vIOKdl09yZGVyIGlzIGltcG9ydGFudC4gRE8gTk9UIENIQU5HRS5cbmNvbnN0IHNlYXJjaGVycyA9IFtcbiAgRXhhY3RNYXRjaCxcbiAgSW5jbHVkZU1hdGNoLFxuICBQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlUHJlZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZVN1ZmZpeEV4YWN0TWF0Y2gsXG4gIFN1ZmZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VFeGFjdE1hdGNoLFxuICBGdXp6eU1hdGNoXG5dO1xuXG5jb25zdCBzZWFyY2hlcnNMZW4gPSBzZWFyY2hlcnMubGVuZ3RoO1xuXG4vLyBSZWdleCB0byBzcGxpdCBieSBzcGFjZXMsIGJ1dCBrZWVwIGFueXRoaW5nIGluIHF1b3RlcyB0b2dldGhlclxuY29uc3QgU1BBQ0VfUkUgPSAvICsoPz0oPzpbXlxcXCJdKlxcXCJbXlxcXCJdKlxcXCIpKlteXFxcIl0qJCkvO1xuY29uc3QgT1JfVE9LRU4gPSAnfCc7XG5cbi8vIFJldHVybiBhIDJEIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBxdWVyeSwgZm9yIHNpbXBsZXIgcGFyc2luZy5cbi8vIEV4YW1wbGU6XG4vLyBcIl5jb3JlIGdvJCB8IHJiJCB8IHB5JCB4eSRcIiA9PiBbW1wiXmNvcmVcIiwgXCJnbyRcIl0sIFtcInJiJFwiXSwgW1wicHkkXCIsIFwieHkkXCJdXVxuZnVuY3Rpb24gcGFyc2VRdWVyeShwYXR0ZXJuLCBvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoT1JfVE9LRU4pLm1hcCgoaXRlbSkgPT4ge1xuICAgIGxldCBxdWVyeSA9IGl0ZW1cbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdChTUEFDRV9SRSlcbiAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gJiYgISFpdGVtLnRyaW0oKSk7XG5cbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBxdWVyeS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgcXVlcnlJdGVtID0gcXVlcnlbaV07XG5cbiAgICAgIC8vIDEuIEhhbmRsZSBtdWx0aXBsZSBxdWVyeSBtYXRjaCAoaS5lLCBvbmNlIHRoYXQgYXJlIHF1b3RlZCwgbGlrZSBgXCJoZWxsbyB3b3JsZFwiYClcbiAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgbGV0IGlkeCA9IC0xO1xuICAgICAgd2hpbGUgKCFmb3VuZCAmJiArK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc011bHRpTWF0Y2gocXVlcnlJdGVtKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBzZWFyY2hlcih0b2tlbiwgb3B0aW9ucykpO1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMi4gSGFuZGxlIHNpbmdsZSBxdWVyeSBtYXRjaGVzIChpLmUsIG9uY2UgdGhhdCBhcmUgKm5vdCogcXVvdGVkKVxuICAgICAgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoKytpZHggPCBzZWFyY2hlcnNMZW4pIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbaWR4XTtcbiAgICAgICAgbGV0IHRva2VuID0gc2VhcmNoZXIuaXNTaW5nbGVNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzXG4gIH0pXG59XG5cbi8vIFRoZXNlIGV4dGVuZGVkIG1hdGNoZXJzIGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgbWF0Y2hlcywgYXMgb3Bwb3NlZFxuLy8gdG8gYSBzaW5nbCBtYXRjaFxuY29uc3QgTXVsdGlNYXRjaFNldCA9IG5ldyBTZXQoW0Z1enp5TWF0Y2gudHlwZSwgSW5jbHVkZU1hdGNoLnR5cGVdKTtcblxuLyoqXG4gKiBDb21tYW5kLWxpa2Ugc2VhcmNoaW5nXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogR2l2ZW4gbXVsdGlwbGUgc2VhcmNoIHRlcm1zIGRlbGltaXRlZCBieSBzcGFjZXMuZS5nLiBgXmpzY3JpcHQgLnB5dGhvbiQgcnVieSAhamF2YWAsXG4gKiBzZWFyY2ggaW4gYSBnaXZlbiB0ZXh0LlxuICpcbiAqIFNlYXJjaCBzeW50YXg6XG4gKlxuICogfCBUb2tlbiAgICAgICB8IE1hdGNoIHR5cGUgICAgICAgICAgICAgICAgIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBganNjcmlwdGAgICB8IGZ1enp5LW1hdGNoICAgICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBmdXp6eSBtYXRjaCBganNjcmlwdGAgICAgICAgfFxuICogfCBgPXNjaGVtZWAgICB8IGV4YWN0LW1hdGNoICAgICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBhcmUgYHNjaGVtZWAgICAgICAgICAgICAgICAgfFxuICogfCBgJ3B5dGhvbmAgICB8IGluY2x1ZGUtbWF0Y2ggICAgICAgICAgICAgIHwgSXRlbXMgdGhhdCBpbmNsdWRlIGBweXRob25gICAgICAgICAgICAgfFxuICogfCBgIXJ1YnlgICAgICB8IGludmVyc2UtZXhhY3QtbWF0Y2ggICAgICAgIHwgSXRlbXMgdGhhdCBkbyBub3QgaW5jbHVkZSBgcnVieWAgICAgICAgfFxuICogfCBgXmphdmFgICAgICB8IHByZWZpeC1leGFjdC1tYXRjaCAgICAgICAgIHwgSXRlbXMgdGhhdCBzdGFydCB3aXRoIGBqYXZhYCAgICAgICAgICAgfFxuICogfCBgIV5lYXJsYW5nYCB8IGludmVyc2UtcHJlZml4LWV4YWN0LW1hdGNoIHwgSXRlbXMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBgZWFybGFuZ2AgfFxuICogfCBgLmpzJGAgICAgICB8IHN1ZmZpeC1leGFjdC1tYXRjaCAgICAgICAgIHwgSXRlbXMgdGhhdCBlbmQgd2l0aCBgLmpzYCAgICAgICAgICAgICAgfFxuICogfCBgIS5nbyRgICAgICB8IGludmVyc2Utc3VmZml4LWV4YWN0LW1hdGNoIHwgSXRlbXMgdGhhdCBkbyBub3QgZW5kIHdpdGggYC5nb2AgICAgICAgfFxuICpcbiAqIEEgc2luZ2xlIHBpcGUgY2hhcmFjdGVyIGFjdHMgYXMgYW4gT1Igb3BlcmF0b3IuIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nXG4gKiBxdWVyeSBtYXRjaGVzIGVudHJpZXMgdGhhdCBzdGFydCB3aXRoIGBjb3JlYCBhbmQgZW5kIHdpdGggZWl0aGVyYGdvYCwgYHJiYCxcbiAqIG9yYHB5YC5cbiAqXG4gKiBgYGBcbiAqIF5jb3JlIGdvJCB8IHJiJCB8IHB5JFxuICogYGBgXG4gKi9cbmNsYXNzIEV4dGVuZGVkU2VhcmNoIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcGF0dGVybixcbiAgICB7XG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb24sXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBpZ25vcmVMb2NhdGlvbixcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2VcbiAgICB9O1xuXG4gICAgdGhpcy5wYXR0ZXJuID0gaXNDYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcGFyc2VRdWVyeSh0aGlzLnBhdHRlcm4sIHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgY29uZGl0aW9uKF8sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy51c2VFeHRlbmRlZFNlYXJjaFxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeTtcblxuICAgIGlmICghcXVlcnkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgICBzY29yZTogMVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgaW5jbHVkZU1hdGNoZXMsIGlzQ2FzZVNlbnNpdGl2ZSB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGV4dCA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHRleHQgOiB0ZXh0LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBsZXQgbnVtTWF0Y2hlcyA9IDA7XG4gICAgbGV0IGFsbEluZGljZXMgPSBbXTtcbiAgICBsZXQgdG90YWxTY29yZSA9IDA7XG5cbiAgICAvLyBPUnNcbiAgICBmb3IgKGxldCBpID0gMCwgcUxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IHFMZW47IGkgKz0gMSkge1xuICAgICAgY29uc3Qgc2VhcmNoZXJzID0gcXVlcnlbaV07XG5cbiAgICAgIC8vIFJlc2V0IGluZGljZXNcbiAgICAgIGFsbEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgIG51bU1hdGNoZXMgPSAwO1xuXG4gICAgICAvLyBBTkRzXG4gICAgICBmb3IgKGxldCBqID0gMCwgcExlbiA9IHNlYXJjaGVycy5sZW5ndGg7IGogPCBwTGVuOyBqICs9IDEpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbal07XG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgaW5kaWNlcywgc2NvcmUgfSA9IHNlYXJjaGVyLnNlYXJjaCh0ZXh0KTtcblxuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgIG51bU1hdGNoZXMgKz0gMTtcbiAgICAgICAgICB0b3RhbFNjb3JlICs9IHNjb3JlO1xuICAgICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHNlYXJjaGVyLmNvbnN0cnVjdG9yLnR5cGU7XG4gICAgICAgICAgICBpZiAoTXVsdGlNYXRjaFNldC5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcyA9IFsuLi5hbGxJbmRpY2VzLCAuLi5pbmRpY2VzXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFsbEluZGljZXMucHVzaChpbmRpY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxTY29yZSA9IDA7XG4gICAgICAgICAgbnVtTWF0Y2hlcyA9IDA7XG4gICAgICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT1IgY29uZGl0aW9uLCBzbyBpZiBUUlVFLCByZXR1cm5cbiAgICAgIGlmIChudW1NYXRjaGVzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgaXNNYXRjaDogdHJ1ZSxcbiAgICAgICAgICBzY29yZTogdG90YWxTY29yZSAvIG51bU1hdGNoZXNcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm90aGluZyB3YXMgbWF0Y2hlZFxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoOiBmYWxzZSxcbiAgICAgIHNjb3JlOiAxXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHJlZ2lzdGVyZWRTZWFyY2hlcnMgPSBbXTtcblxuZnVuY3Rpb24gcmVnaXN0ZXIoLi4uYXJncykge1xuICByZWdpc3RlcmVkU2VhcmNoZXJzLnB1c2goLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaGVyKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlZ2lzdGVyZWRTZWFyY2hlcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgc2VhcmNoZXJDbGFzcyA9IHJlZ2lzdGVyZWRTZWFyY2hlcnNbaV07XG4gICAgaWYgKHNlYXJjaGVyQ2xhc3MuY29uZGl0aW9uKHBhdHRlcm4sIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gbmV3IHNlYXJjaGVyQ2xhc3MocGF0dGVybiwgb3B0aW9ucylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEJpdGFwU2VhcmNoKHBhdHRlcm4sIG9wdGlvbnMpXG59XG5cbmNvbnN0IExvZ2ljYWxPcGVyYXRvciA9IHtcbiAgQU5EOiAnJGFuZCcsXG4gIE9SOiAnJG9yJ1xufTtcblxuY29uc3QgS2V5VHlwZSA9IHtcbiAgUEFUSDogJyRwYXRoJyxcbiAgUEFUVEVSTjogJyR2YWwnXG59O1xuXG5jb25zdCBpc0V4cHJlc3Npb24gPSAocXVlcnkpID0+XG4gICEhKHF1ZXJ5W0xvZ2ljYWxPcGVyYXRvci5BTkRdIHx8IHF1ZXJ5W0xvZ2ljYWxPcGVyYXRvci5PUl0pO1xuXG5jb25zdCBpc1BhdGggPSAocXVlcnkpID0+ICEhcXVlcnlbS2V5VHlwZS5QQVRIXTtcblxuY29uc3QgaXNMZWFmID0gKHF1ZXJ5KSA9PlxuICAhaXNBcnJheShxdWVyeSkgJiYgaXNPYmplY3QocXVlcnkpICYmICFpc0V4cHJlc3Npb24ocXVlcnkpO1xuXG5jb25zdCBjb252ZXJ0VG9FeHBsaWNpdCA9IChxdWVyeSkgPT4gKHtcbiAgW0xvZ2ljYWxPcGVyYXRvci5BTkRdOiBPYmplY3Qua2V5cyhxdWVyeSkubWFwKChrZXkpID0+ICh7XG4gICAgW2tleV06IHF1ZXJ5W2tleV1cbiAgfSkpXG59KTtcblxuLy8gV2hlbiBgYXV0b2AgaXMgYHRydWVgLCB0aGUgcGFyc2UgZnVuY3Rpb24gd2lsbCBpbmZlciBhbmQgaW5pdGlhbGl6ZSBhbmQgYWRkXG4vLyB0aGUgYXBwcm9wcmlhdGUgYFNlYXJjaGVyYCBpbnN0YW5jZVxuZnVuY3Rpb24gcGFyc2UocXVlcnksIG9wdGlvbnMsIHsgYXV0byA9IHRydWUgfSA9IHt9KSB7XG4gIGNvbnN0IG5leHQgPSAocXVlcnkpID0+IHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHF1ZXJ5KTtcblxuICAgIGNvbnN0IGlzUXVlcnlQYXRoID0gaXNQYXRoKHF1ZXJ5KTtcblxuICAgIGlmICghaXNRdWVyeVBhdGggJiYga2V5cy5sZW5ndGggPiAxICYmICFpc0V4cHJlc3Npb24ocXVlcnkpKSB7XG4gICAgICByZXR1cm4gbmV4dChjb252ZXJ0VG9FeHBsaWNpdChxdWVyeSkpXG4gICAgfVxuXG4gICAgaWYgKGlzTGVhZihxdWVyeSkpIHtcbiAgICAgIGNvbnN0IGtleSA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRIXSA6IGtleXNbMF07XG5cbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBpc1F1ZXJ5UGF0aCA/IHF1ZXJ5W0tleVR5cGUuUEFUVEVSTl0gOiBxdWVyeVtrZXldO1xuXG4gICAgICBpZiAoIWlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihMT0dJQ0FMX1NFQVJDSF9JTlZBTElEX1FVRVJZX0ZPUl9LRVkoa2V5KSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICBrZXlJZDogY3JlYXRlS2V5SWQoa2V5KSxcbiAgICAgICAgcGF0dGVyblxuICAgICAgfTtcblxuICAgICAgaWYgKGF1dG8pIHtcbiAgICAgICAgb2JqLnNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIG9wZXJhdG9yOiBrZXlzWzBdXG4gICAgfTtcblxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5leHQoaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgaWYgKCFpc0V4cHJlc3Npb24ocXVlcnkpKSB7XG4gICAgcXVlcnkgPSBjb252ZXJ0VG9FeHBsaWNpdChxdWVyeSk7XG4gIH1cblxuICByZXR1cm4gbmV4dChxdWVyeSlcbn1cblxuLy8gUHJhY3RpY2FsIHNjb3JpbmcgZnVuY3Rpb25cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShcbiAgcmVzdWx0cyxcbiAgeyBpZ25vcmVGaWVsZE5vcm0gPSBDb25maWcuaWdub3JlRmllbGROb3JtIH1cbikge1xuICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgIGxldCB0b3RhbFNjb3JlID0gMTtcblxuICAgIHJlc3VsdC5tYXRjaGVzLmZvckVhY2goKHsga2V5LCBub3JtLCBzY29yZSB9KSA9PiB7XG4gICAgICBjb25zdCB3ZWlnaHQgPSBrZXkgPyBrZXkud2VpZ2h0IDogbnVsbDtcblxuICAgICAgdG90YWxTY29yZSAqPSBNYXRoLnBvdyhcbiAgICAgICAgc2NvcmUgPT09IDAgJiYgd2VpZ2h0ID8gTnVtYmVyLkVQU0lMT04gOiBzY29yZSxcbiAgICAgICAgKHdlaWdodCB8fCAxKSAqIChpZ25vcmVGaWVsZE5vcm0gPyAxIDogbm9ybSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQuc2NvcmUgPSB0b3RhbFNjb3JlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTWF0Y2hlcyhyZXN1bHQsIGRhdGEpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHJlc3VsdC5tYXRjaGVzO1xuICBkYXRhLm1hdGNoZXMgPSBbXTtcblxuICBpZiAoIWlzRGVmaW5lZChtYXRjaGVzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCkgPT4ge1xuICAgIGlmICghaXNEZWZpbmVkKG1hdGNoLmluZGljZXMpIHx8ICFtYXRjaC5pbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmRpY2VzLCB2YWx1ZSB9ID0gbWF0Y2g7XG5cbiAgICBsZXQgb2JqID0ge1xuICAgICAgaW5kaWNlcyxcbiAgICAgIHZhbHVlXG4gICAgfTtcblxuICAgIGlmIChtYXRjaC5rZXkpIHtcbiAgICAgIG9iai5rZXkgPSBtYXRjaC5rZXkuc3JjO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5pZHggPiAtMSkge1xuICAgICAgb2JqLnJlZkluZGV4ID0gbWF0Y2guaWR4O1xuICAgIH1cblxuICAgIGRhdGEubWF0Y2hlcy5wdXNoKG9iaik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TY29yZShyZXN1bHQsIGRhdGEpIHtcbiAgZGF0YS5zY29yZSA9IHJlc3VsdC5zY29yZTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KFxuICByZXN1bHRzLFxuICBkb2NzLFxuICB7XG4gICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgaW5jbHVkZVNjb3JlID0gQ29uZmlnLmluY2x1ZGVTY29yZVxuICB9ID0ge31cbikge1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBbXTtcblxuICBpZiAoaW5jbHVkZU1hdGNoZXMpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybU1hdGNoZXMpO1xuICBpZiAoaW5jbHVkZVNjb3JlKSB0cmFuc2Zvcm1lcnMucHVzaCh0cmFuc2Zvcm1TY29yZSk7XG5cbiAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXN1bHQpID0+IHtcbiAgICBjb25zdCB7IGlkeCB9ID0gcmVzdWx0O1xuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGl0ZW06IGRvY3NbaWR4XSxcbiAgICAgIHJlZkluZGV4OiBpZHhcbiAgICB9O1xuXG4gICAgaWYgKHRyYW5zZm9ybWVycy5sZW5ndGgpIHtcbiAgICAgIHRyYW5zZm9ybWVycy5mb3JFYWNoKCh0cmFuc2Zvcm1lcikgPT4ge1xuICAgICAgICB0cmFuc2Zvcm1lcihyZXN1bHQsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfSlcbn1cblxuY2xhc3MgRnVzZSB7XG4gIGNvbnN0cnVjdG9yKGRvY3MsIG9wdGlvbnMgPSB7fSwgaW5kZXgpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLkNvbmZpZywgLi4ub3B0aW9ucyB9O1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5vcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoICYmXG4gICAgICAhdHJ1ZVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSlcbiAgICB9XG5cbiAgICB0aGlzLl9rZXlTdG9yZSA9IG5ldyBLZXlTdG9yZSh0aGlzLm9wdGlvbnMua2V5cyk7XG5cbiAgICB0aGlzLnNldENvbGxlY3Rpb24oZG9jcywgaW5kZXgpO1xuICB9XG5cbiAgc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCkge1xuICAgIHRoaXMuX2RvY3MgPSBkb2NzO1xuXG4gICAgaWYgKGluZGV4ICYmICEoaW5kZXggaW5zdGFuY2VvZiBGdXNlSW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoSU5DT1JSRUNUX0lOREVYX1RZUEUpXG4gICAgfVxuXG4gICAgdGhpcy5fbXlJbmRleCA9XG4gICAgICBpbmRleCB8fFxuICAgICAgY3JlYXRlSW5kZXgodGhpcy5vcHRpb25zLmtleXMsIHRoaXMuX2RvY3MsIHtcbiAgICAgICAgZ2V0Rm46IHRoaXMub3B0aW9ucy5nZXRGbixcbiAgICAgICAgZmllbGROb3JtV2VpZ2h0OiB0aGlzLm9wdGlvbnMuZmllbGROb3JtV2VpZ2h0XG4gICAgICB9KTtcbiAgfVxuXG4gIGFkZChkb2MpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9kb2NzLnB1c2goZG9jKTtcbiAgICB0aGlzLl9teUluZGV4LmFkZChkb2MpO1xuICB9XG5cbiAgcmVtb3ZlKHByZWRpY2F0ZSA9ICgvKiBkb2MsIGlkeCAqLykgPT4gZmFsc2UpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fZG9jcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY29uc3QgZG9jID0gdGhpcy5fZG9jc1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUoZG9jLCBpKSkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0KGkpO1xuICAgICAgICBpIC09IDE7XG4gICAgICAgIGxlbiAtPSAxO1xuXG4gICAgICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICByZW1vdmVBdChpZHgpIHtcbiAgICB0aGlzLl9kb2NzLnNwbGljZShpZHgsIDEpO1xuICAgIHRoaXMuX215SW5kZXgucmVtb3ZlQXQoaWR4KTtcbiAgfVxuXG4gIGdldEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9teUluZGV4XG4gIH1cblxuICBzZWFyY2gocXVlcnksIHsgbGltaXQgPSAtMSB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZSxcbiAgICAgIHNob3VsZFNvcnQsXG4gICAgICBzb3J0Rm4sXG4gICAgICBpZ25vcmVGaWVsZE5vcm1cbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBpc1N0cmluZyhxdWVyeSlcbiAgICAgID8gaXNTdHJpbmcodGhpcy5fZG9jc1swXSlcbiAgICAgICAgPyB0aGlzLl9zZWFyY2hTdHJpbmdMaXN0KHF1ZXJ5KVxuICAgICAgICA6IHRoaXMuX3NlYXJjaE9iamVjdExpc3QocXVlcnkpXG4gICAgICA6IHRoaXMuX3NlYXJjaExvZ2ljYWwocXVlcnkpO1xuXG4gICAgY29tcHV0ZVNjb3JlKHJlc3VsdHMsIHsgaWdub3JlRmllbGROb3JtIH0pO1xuXG4gICAgaWYgKHNob3VsZFNvcnQpIHtcbiAgICAgIHJlc3VsdHMuc29ydChzb3J0Rm4pO1xuICAgIH1cblxuICAgIGlmIChpc051bWJlcihsaW1pdCkgJiYgbGltaXQgPiAtMSkge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQocmVzdWx0cywgdGhpcy5fZG9jcywge1xuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBpbmNsdWRlU2NvcmVcbiAgICB9KVxuICB9XG5cbiAgX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkgc3RyaW5nIGluIHRoZSBpbmRleFxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyB2OiB0ZXh0LCBpOiBpZHgsIG46IG5vcm0gfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGl0ZW06IHRleHQsXG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIG1hdGNoZXM6IFt7IHNjb3JlLCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoTG9naWNhbChxdWVyeSkge1xuXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuXG4gICAgY29uc3QgZXZhbHVhdGUgPSAobm9kZSwgaXRlbSwgaWR4KSA9PiB7XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgeyBrZXlJZCwgc2VhcmNoZXIgfSA9IG5vZGU7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICBrZXk6IHRoaXMuX2tleVN0b3JlLmdldChrZXlJZCksXG4gICAgICAgICAgdmFsdWU6IHRoaXMuX215SW5kZXguZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCksXG4gICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGV2YWx1YXRlKGNoaWxkLCBpdGVtLCBpZHgpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgIHJlcy5wdXNoKC4uLnJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5vcGVyYXRvciA9PT0gTG9naWNhbE9wZXJhdG9yLkFORCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfTtcblxuICAgIGNvbnN0IHJlY29yZHMgPSB0aGlzLl9teUluZGV4LnJlY29yZHM7XG4gICAgY29uc3QgcmVzdWx0TWFwID0ge307XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7ICQ6IGl0ZW0sIGk6IGlkeCB9KSA9PiB7XG4gICAgICBpZiAoaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIGxldCBleHBSZXN1bHRzID0gZXZhbHVhdGUoZXhwcmVzc2lvbiwgaXRlbSwgaWR4KTtcblxuICAgICAgICBpZiAoZXhwUmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEZWR1cGUgd2hlbiBhZGRpbmdcbiAgICAgICAgICBpZiAoIXJlc3VsdE1hcFtpZHhdKSB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XSA9IHsgaWR4LCBpdGVtLCBtYXRjaGVzOiBbXSB9O1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdE1hcFtpZHhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwUmVzdWx0cy5mb3JFYWNoKCh7IG1hdGNoZXMgfSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2lkeF0ubWF0Y2hlcy5wdXNoKC4uLm1hdGNoZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgX3NlYXJjaE9iamVjdExpc3QocXVlcnkpIHtcbiAgICBjb25zdCBzZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IHsga2V5cywgcmVjb3JkcyB9ID0gdGhpcy5fbXlJbmRleDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBMaXN0IGlzIEFycmF5PE9iamVjdD5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmICghaXNEZWZpbmVkKGl0ZW0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgICBrZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKFxuICAgICAgICAgIC4uLnRoaXMuX2ZpbmRNYXRjaGVzKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBpdGVtW2tleUluZGV4XSxcbiAgICAgICAgICAgIHNlYXJjaGVyXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBtYXRjaGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuICBfZmluZE1hdGNoZXMoeyBrZXksIHZhbHVlLCBzZWFyY2hlciB9KSB7XG4gICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBsZXQgbWF0Y2hlcyA9IFtdO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICAgIGlmICghaXNEZWZpbmVkKHRleHQpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgbm9ybSxcbiAgICAgICAgICAgIGluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgdjogdGV4dCwgbjogbm9ybSB9ID0gdmFsdWU7XG5cbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goeyBzY29yZSwga2V5LCB2YWx1ZTogdGV4dCwgbm9ybSwgaW5kaWNlcyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlc1xuICB9XG59XG5cbkZ1c2UudmVyc2lvbiA9ICc2LjYuMic7XG5GdXNlLmNyZWF0ZUluZGV4ID0gY3JlYXRlSW5kZXg7XG5GdXNlLnBhcnNlSW5kZXggPSBwYXJzZUluZGV4O1xuRnVzZS5jb25maWcgPSBDb25maWc7XG5cbntcbiAgRnVzZS5wYXJzZVF1ZXJ5ID0gcGFyc2U7XG59XG5cbntcbiAgcmVnaXN0ZXIoRXh0ZW5kZWRTZWFyY2gpO1xufVxuXG5leHBvcnQgeyBGdXNlIGFzIGRlZmF1bHQgfTtcbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiIHR5cGU9XCJ0c1wiPlx0XG5cdGV4cG9ydCBlbnVtIENsYXNzVHlwZSB7XG5cdFx0VU5LTk9XTiA9ICd1bmtub3duJyxcblxuXHRcdC8vIHNldCBvZiBjaGFpbnMgd2hpY2ggc2hhcmUgYSBjb21tb24gYWRkcmVzcyBzcGFjZSwgc3VjaCB0aGF0IHVzZXIgYWNjb3VudHMgYXJlIHRyYW5zbGF0YWJsZSBhY3Jvc3MgbWVtYmVyc1xuXHRcdEZBTUlMWSA9ICdmYW1pbHknLFxuXG5cdFx0Ly8gc3BlY2lmaWMgYmxvY2tjaGFpblxuXHRcdENIQUlOID0gJ2NoYWluJyxcblxuXHRcdC8vIGNvbmZpZ3VyYXRpb24gZm9yIGhvdyB0byBjb21tdW5pY2F0ZSB3aXRoIGNoYWluXG5cdFx0TkVUV09SSyA9ICduZXR3b3JrJyxcblxuXHRcdC8vIFxuXHRcdEFDQ09VTlQgPSAnYWNjb3VudCcsXG5cblx0XHQvLyBwdWJrZXkgYXNzb2NpYXRlZCB3aXRoIGRpc3RpbmN0IGZhbWlseSAnbWVtYmVyJ1xuXHRcdENPTlRBQ1QgPSAnY29udGFjdCcsXG5cblx0XHQvLyBvbi1jaGFpbiByZXNvdXJjZSB0aGF0IG9ubHkgZXhpc3RzIHRoaXMgY2hhaW5cblx0XHRDT05UUkFDVCA9ICdjb250cmFjdCcsXG5cblx0XHQvLyBhZGRyZXNzYWJsZSBhc3NldCBhc3NvY2lhdGVkIHdpdGggZGlzdGluY3QgY2hhaW5cblx0XHRUT0tFTiA9ICd0b2tlbicsXG5cblx0XHQvLyBhc3NldCBob2xkaW5nc1xuXHRcdEhPTERJTkcgPSAnaG9sZGluZycsXG5cblx0XHQvLyBhcHAgY29ubmVjdGlvblxuXHRcdEFQUCA9ICdhcHAnLFxuXG5cdFx0Ly8gbmF0aXZlIGNvaW5cblx0XHRDT0lOID0gJ2NvaW4nLFxuXG5cdFx0VEFHID0gJ3RhZycsXG5cdFx0SUNPTiA9ICdpY29uJyxcblxuXHRcdElCQ1QgPSAnaWJjdCcsXG5cdFx0U05JUDcyMSA9ICdzbmlwNzIxJyxcblx0XHRUWE4gPSAndHhuJyxcblx0XHRPVEhFUiA9ICdvdGhlcicsXG5cdH1cblxuXHRleHBvcnQgaW50ZXJmYWNlIFNlYXJjaEl0ZW0ge1xuXHRcdGNsYXNzOiBDbGFzc1R5cGU7XG5cdFx0cmVzb3VyY2VQYXRoOiBSZXNvdXJjZS5QYXRoO1xuXHRcdG5hbWU6IHN0cmluZztcblx0XHRyZXNvdXJjZTogUmVzb3VyY2VbJ2ludGVyZmFjZSddO1xuXHRcdGRldGFpbHM6IERpY3Q8SnNvblZhbHVlPjtcblx0fVxuXG5cdGV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoR3JvdXAge1xuXHRcdHNvdXJjZTogUHJvbWlzYWJsZTx0eXBlb2YgV3JpdGFibGVTdG9yZU1hcCAmIFN0YXRpY1N0b3JlIHwgQXJyYXk8YW55Pj47XG5cdFx0dHJhbnNmb3JtKGdfdGhpbmc6IFJlc291cmNlWydpbnRlcmZhY2UnXSk6IE9taXQ8U2VhcmNoSXRlbSwgJ3JlZic+O1xuXHRcdGtleXM6IHN0cmluZ1tdO1xuXHR9XG48L3NjcmlwdD5cblxuPHNjcmlwdCB0eXBlPVwidHNcIj5cblx0aW1wb3J0IEZ1c2UgZnJvbSAnZnVzZS5qcyc7XG5cblx0aW1wb3J0IHtcblx0XHR5d19jYW5jZWxfc2VhcmNoLFxuXHRcdHl3X2hlYWRlcl9wcm9wcyxcblx0XHR5d19zZWFyY2gsXG5cdH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQge1xuXHRcdFNjcmVlbixcblx0XHRIZWFkZXIsXG5cdH0gZnJvbSAnIyMvc2NyZWVuL19zY3JlZW5zJztcblxuXHQvLyBpbXBvcnQgR2VuZXJpY1JvdyBmcm9tICcjL3VpL0dlbmVyaWNSb3cuc3ZlbHRlJztcblx0aW1wb3J0IHtBY2NvdW50c30gZnJvbSAnIy9zdG9yZS9hY2NvdW50cyc7XG5cdGltcG9ydCB7QWdlbnRzfSBmcm9tICcjL3N0b3JlL2FnZW50cyc7XG5cdGltcG9ydCB7QXBwc30gZnJvbSAnIy9zdG9yZS9hcHBzJztcblx0aW1wb3J0IHtDaGFpbnN9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHtFbnRpdGllc30gZnJvbSAnIy9zdG9yZS9lbnRpdGllcyc7XG5cdGltcG9ydCB7TWVkaWFzfSBmcm9tICcjL3N0b3JlL21lZGlhcyc7XG5cdGltcG9ydCB7TmV0d29ya3N9IGZyb20gJyMvc3RvcmUvbmV0d29ya3MnO1xuXHRpbXBvcnQge1BmcHN9IGZyb20gJyMvc3RvcmUvcGZwcyc7XG5cdGltcG9ydCB0eXBlIHtSZXNvdXJjZX0gZnJvbSAnIy9tZXRhL3Jlc291cmNlJztcblx0aW1wb3J0IHR5cGUge0FjY291bnQsIEFjY291bnRQYXRofSBmcm9tICcjL21ldGEvYWNjb3VudCc7XG5cdGltcG9ydCB7RGljdCwgSnNvbk9iamVjdCwgSnNvblZhbHVlLCBvZGUsIG9kZXJhYywgUHJvbWlzYWJsZSwgcHJvcGVyfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cdGltcG9ydCB0eXBlIHtTdGF0aWNTdG9yZSwgV3JpdGFibGVTdG9yZU1hcH0gZnJvbSAnIy9zdG9yZS9fYmFzZSc7XG5cdGltcG9ydCB0eXBlIHtBZ2VudCwgQWdlbnRQYXRoLCBDaGFpblBhdGh9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCBSb3cgZnJvbSAnIy9hcHAvdWkvUm93LnN2ZWx0ZSc7XG5cblx0bGV0IGRtX3Jlc3VsdHM6IEhUTUxFbGVtZW50O1xuXHRjb25zdCBhX3Jlc3VsdHM6IFNlYXJjaEl0ZW1bXSA9IFtdO1xuXG5cblx0Ly8gbGV0IHlfZnVzZTogRnVzZTxTZWFyY2hJdGVtPjtcblx0bGV0IGFfZnVzZXM6IEZ1c2U8U2VhcmNoSXRlbT5bXSA9IFtdO1xuXG5cdGNvbnN0IGZ1emV5ID0gKGFfaXRlbXM6IFNlYXJjaEl0ZW1bXSwgYV9rZXlzOiBzdHJpbmdbXSkgPT4gbmV3IEZ1c2UoYV9pdGVtcywge1xuXHRcdGluY2x1ZGVTY29yZTogdHJ1ZSxcblx0XHRpbmNsdWRlTWF0Y2hlczogdHJ1ZSxcblx0XHRrZXlzOiBbXG5cdFx0XHQnbGFiZWwnLFxuXHRcdFx0Li4uYV9rZXlzLm1hcChzID0+IGBkZXRhaWxzLiR7c31gKSxcblx0XHRdLFxuXHR9KTtcblxuXHQoYXN5bmMoKSA9PiB7XG5cdFx0Y29uc3QgaF9zdG9yZXMgPSB7fTtcblxuXHRcdGNvbnN0IGtzX2NoYWlucyA9IGF3YWl0IENoYWlucy5yZWFkKCk7XG5cblx0XHRhX2Z1c2VzID0gW1xuXHRcdFx0Ly8gY2hhaW5zXG5cdFx0XHQoKCkgPT4gZnV6ZXkoa3NfY2hhaW5zLmVudHJpZXMoKS5tYXAoKFtwX2NoYWluLCBnX2NoYWluXSkgPT4gKHtcblx0XHRcdFx0Y2xhc3M6IENsYXNzVHlwZS5DSEFJTixcblx0XHRcdFx0bmFtZTogZ19jaGFpbi5uYW1lLFxuXHRcdFx0XHRyZXNvdXJjZVBhdGg6IHBfY2hhaW4sXG5cdFx0XHRcdHJlc291cmNlOiBnX2NoYWluLFxuXHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0bmFtZTogZ19jaGFpbi5uYW1lLFxuXHRcdFx0XHRcdGlkOiBnX2NoYWluLmlkLFxuXHRcdFx0XHR9LFxuXHRcdFx0fSkpLCBbJ2lkJ10pKSgpLFxuXG5cdFx0XHQvLyBjb2luc1xuXHRcdFx0KCgpID0+IGZ1emV5KGtzX2NoYWlucy5lbnRyaWVzKCkuZmxhdE1hcCgoW3BfY2hhaW4sIGdfY2hhaW5dKSA9PiBvZGVyYWMoZ19jaGFpbi5jb2lucywgKHNpX2NvaW4sIGdfY29pbikgPT4gKHtcblx0XHRcdFx0Y2xhc3M6IENsYXNzVHlwZS5DT0lOLFxuXHRcdFx0XHRuYW1lOiBwcm9wZXIoZ19jb2luLmV4dHJhPy5jb2luZ2Vja29faWQgfHwgJ1Vua25vd24nKSxcblx0XHRcdFx0cG9zdG5hbWU6IHNpX2NvaW4sXG5cdFx0XHRcdHJlc291cmNlUGF0aDogYCR7cF9jaGFpbn0vY29pbi4ke3NpX2NvaW59YCxcblx0XHRcdFx0cmVzb3VyY2U6IHtcblx0XHRcdFx0XHRuYW1lOiBwcm9wZXIoZ19jb2luLmV4dHJhPy5jb2luZ2Vja29faWQgfHwgJ1Vua25vd24nKSxcblx0XHRcdFx0XHRwZnA6IGdfY2hhaW4ucGZwLFxuXHRcdFx0XHRcdC4uLmdfY29pbixcblx0XHRcdFx0fSxcblx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdHN5bWJvbDogc2lfY29pbixcblx0XHRcdFx0XHRkZW5vbTogZ19jb2luLmRlbm9tLFxuXHRcdFx0XHRcdGNvaW5nZWNrbzogZ19jb2luLmV4dHJhPy5jb2luZ2Vja29faWQgfHwgJycsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KSkpLCBbJ3N5bWJvbCcsICdkZW5vbSddKSkoKSxcblxuXHRcdFx0Li4uYXdhaXQgUHJvbWlzZS5hbGwoW1xuXHRcdFx0XHQvLyBhY2NvdW50c1xuXHRcdFx0XHQoYXN5bmMoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qga3NfYWNjb3VudHMgPSBhd2FpdCBBY2NvdW50cy5yZWFkKCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gZnV6ZXkoa3NfYWNjb3VudHMuZW50cmllcygpLm1hcCgoW3BfYWNjb3VudCwgZ19hY2NvdW50XSkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgYV9hZGRyczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFx0XHRcdGNvbnN0IGFzX2FkZHJzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cblx0XHRcdFx0XHRcdGZvcihjb25zdCBbLCBnX2NoYWluXSBvZiBrc19jaGFpbnMpIHtcblx0XHRcdFx0XHRcdFx0YXNfYWRkcnMuYWRkKENoYWlucy5hZGRyZXNzRm9yKGdfYWNjb3VudC5wdWJrZXksIGdfY2hhaW4pKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YV9hZGRycy5wdXNoKC4uLmFzX2FkZHJzKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6IENsYXNzVHlwZS5BQ0NPVU5ULFxuXHRcdFx0XHRcdFx0XHRuYW1lOiBnX2FjY291bnQubmFtZSxcblx0XHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoOiBwX2FjY291bnQsXG5cdFx0XHRcdFx0XHRcdHJlc291cmNlOiBnX2FjY291bnQsXG5cdFx0XHRcdFx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiBnX2FjY291bnQubmFtZSxcblx0XHRcdFx0XHRcdFx0XHRhZGRyZXNzZXM6IGFfYWRkcnMsXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pLCBbJ2FkZHJlc3NlcyddKTtcblx0XHRcdFx0fSkoKSxcblxuXHRcdFx0XHQvLyBjb250YWN0c1xuXHRcdFx0XHQoYXN5bmMoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qga3NfYWdlbnRzID0gYXdhaXQgQWdlbnRzLnJlYWQoKTtcblxuXHRcdFx0XHRcdHJldHVybiBmdXpleShbLi4ua3NfYWdlbnRzLmNvbnRhY3RzKCldLm1hcCgoW3BfY29udGFjdCwgZ19jb250YWN0XSkgPT4gKHtcblx0XHRcdFx0XHRcdGNsYXNzOiBDbGFzc1R5cGUuQ09OVEFDVCxcblx0XHRcdFx0XHRcdG5hbWU6IGdfY29udGFjdC5uYW1lLFxuXHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoOiBwX2NvbnRhY3QsXG5cdFx0XHRcdFx0XHRyZXNvdXJjZTogZ19jb250YWN0LFxuXHRcdFx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdFx0XHRuYW1lOiBnX2NvbnRhY3QubmFtZSxcblx0XHRcdFx0XHRcdFx0bm90ZXM6IGdfY29udGFjdC5ub3Rlcyxcblx0XHRcdFx0XHRcdFx0YWRkcmVzc2VzOiBbLi4ua3NfY2hhaW5zLmluRmFtaWx5KGdfY29udGFjdC5mYW1pbHkpXVxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoKFssIGdfY2hhaW5dKSA9PiBDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzLCBnX2NoYWluKSksXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0pKSwgWydub3RlcyddKTtcblx0XHRcdFx0fSkoKSxcblxuXHRcdFx0XHQvLyBhcHBzXG5cdFx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0XHRjb25zdCBrc19hcHBzID0gYXdhaXQgQXBwcy5yZWFkKCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gZnV6ZXkoa3NfYXBwcy5lbnRyaWVzKCkubWFwKChbcF9hcHAsIGdfYXBwXSkgPT4gKHtcblx0XHRcdFx0XHRcdGNsYXNzOiBDbGFzc1R5cGUuQVBQLFxuXHRcdFx0XHRcdFx0bmFtZTogZ19hcHAuaG9zdCxcblx0XHRcdFx0XHRcdHJlc291cmNlUGF0aDogcF9hcHAsXG5cdFx0XHRcdFx0XHRyZXNvdXJjZTogZ19hcHAsXG5cdFx0XHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0XHRcdGhvc3Q6IGdfYXBwLmhvc3QsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0pKSwgW10pO1xuXHRcdFx0XHR9KSgpLFxuXG5cdFx0XHRcdC8vIHRva2Vuc1xuXHRcdFx0XHQoYXN5bmMoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgYV90b2tlbnM6IFNlYXJjaEl0ZW1bXSA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yKGNvbnN0IFssIGdfY2hhaW5dIG9mIGtzX2NoYWlucy5lbnRyaWVzKCkpIHtcblx0XHRcdFx0XHRcdGZvcihjb25zdCBbc2lfc3BlYywgaF90b2tlbnNdIG9mIG9kZShhd2FpdCBFbnRpdGllcy5yZWFkRnVuZ2libGVUb2tlbnMoZ19jaGFpbikpKSB7XG5cdFx0XHRcdFx0XHRcdGZvcihjb25zdCBbcF90b2tlbiwgZ190b2tlbl0gb2Ygb2RlKGhfdG9rZW5zKSkge1xuXHRcdFx0XHRcdFx0XHRcdGFfdG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3M6IENsYXNzVHlwZS5UT0tFTixcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IGdfdG9rZW4ubmFtZSxcblx0XHRcdFx0XHRcdFx0XHRcdHJlc291cmNlUGF0aDogcF90b2tlbixcblx0XHRcdFx0XHRcdFx0XHRcdHJlc291cmNlOiBnX3Rva2VuLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzcGVjOiBzaV9zcGVjLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiBnX3Rva2VuLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN5bWJvbDogZ190b2tlbi5zeW1ib2wsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJlY2gzMjogZ190b2tlbi5iZWNoMzIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvZGVoYXNoOiBnX3Rva2VuLmhhc2gsXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGZ1emV5KGFfdG9rZW5zLCBbXG5cdFx0XHRcdFx0XHQnc3BlYycsXG5cdFx0XHRcdFx0XHQnc3ltYm9sJyxcblx0XHRcdFx0XHRcdCdiZWNoMzInLFxuXHRcdFx0XHRcdFx0J2NvZGVoYXNoJyxcblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fSkoKSxcblxuXHRcdFx0XHQvLyBFbnRpdGllcyxcblx0XHRcdFx0Ly8gTmV0d29ya3MsXG5cdFx0XHRdKSxcblx0XHRdO1xuXHR9KSgpO1xuXG5cdGZ1bmN0aW9uIHNlYXJjaChzX3NlYXJjaDogc3RyaW5nKSB7XG5cdFx0Y29uc3QgYV9ncm91cHM6IHt0b3A6bnVtYmVyLCBoaXRzOkZ1c2UuRnVzZVJlc3VsdDxTZWFyY2hJdGVtPltdfVtdID0gW107XG5cdFx0Y29uc3QgYV9oaXRzOiBGdXNlLkZ1c2VSZXN1bHQ8U2VhcmNoSXRlbT5bXSA9IFtdO1xuXHRcdGxldCBjX3RvdGFsID0gMDtcblxuXHRcdGZvcihjb25zdCB5X2Z1c2Ugb2YgYV9mdXNlcykge1xuXHRcdFx0Y29uc3QgYV9oaXRzX2xvY2FsID0geV9mdXNlLnNlYXJjaChzX3NlYXJjaCk7XG5cblx0XHRcdGlmKGFfaGl0c19sb2NhbC5sZW5ndGgpIHtcblx0XHRcdFx0Y190b3RhbCArPSBhX2hpdHMubGVuZ3RoO1xuXG5cdFx0XHRcdGFfaGl0cy5wdXNoKC4uLmFfaGl0c19sb2NhbCk7XG5cblx0XHRcdFx0YV9ncm91cHMucHVzaCh7XG5cdFx0XHRcdFx0dG9wOiBhX2hpdHNfbG9jYWxbMF0uc2NvcmUhLFxuXHRcdFx0XHRcdGhpdHM6IGFfaGl0c19sb2NhbCxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc29ydCBhbGwgaGl0c1xuXHRcdGFfaGl0cy5zb3J0KChnX2EsIGdfYikgPT4gZ19iLnNjb3JlISAtIGdfYS5zY29yZSEpO1xuXG5cdFx0Ly8gY2xlYXIgcmVzdWx0cyBsaXN0XG5cdFx0ZG1fcmVzdWx0cy5pbm5lckhUTUwgPSAnJztcblxuXHRcdGNvbnNvbGUubG9nKGFfaGl0cyk7XG5cblx0XG5cdFx0Zm9yKGNvbnN0IGdfaGl0IG9mIGFfaGl0cylcdHtcblx0XHRcdG5ldyBSb3coe1xuXHRcdFx0XHR0YXJnZXQ6IGRtX3Jlc3VsdHMsXG5cdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0Li4uZ19oaXQuaXRlbSxcblx0XHRcdFx0XHRwZnBEaW06IDMyLFxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0JDoge1xuXHRcdGlmKCR5d19zZWFyY2gpIHtcblx0XHRcdHNlYXJjaCgkeXdfc2VhcmNoKTtcblx0XHR9XG5cdH1cblxuXHQvLyBvbk1vdW50KCgpID0+IHtcblx0Ly8gXHRzZWFyY2goJHl3X3NlYXJjaCk7XG5cdC8vIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQuc2VhcmNoIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdHotaW5kZXg6IDEwMDA7XG5cblx0XHQucmVzdWx0cyB7XG5cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cblxuPGRpdiBjbGFzcz1cInNlYXJjaFwiIGNsYXNzOmRpc3BsYXlfbm9uZT17ISR5d19zZWFyY2h9PlxuXHQ8U2NyZWVuIGRlYnVnPSdTZWFyY2gnIHJvb3Q+XG5cdFx0PEhlYWRlciBuZXR3b3JrIGFjY291bnQgc2VhcmNoXG5cdFx0XHRpc1NlYXJjaFNjcmVlbiB7Li4uKCR5d19oZWFkZXJfcHJvcHMgfHwge30pfSBvbjpzZWFyY2g9e2RfZXZlbnQgPT4gc2VhcmNoKGRfZXZlbnQuZGV0YWlsKX1cblx0XHQvPlxuXG5cdFx0PHAgc3R5bGU9J2ZvbnQtc2l6ZToxMnB4Jz5cblx0XHRcdDxzcGFuIHN0eWxlPSdjb2xvcjp2YXIoLS10aGVtZS1jb2xvci1jYXV0aW9uKTsnPkRpc2NsYWltZXI6IDwvc3Bhbj5cblx0XHRcdFRoaXMgdGVtcG9yYXJ5IHNlYXJjaCBpbnRlcmZhY2UgZG9lcyBub3QgcmVwcmVzZW50IHRoZSBsb29rIGFuZCBmdW5jdGlvbiBvZiB0aGUgYWN0dWFsIHNlYXJjaCBpbnRlcmZhY2UgY3VycmVudGx5IHVuZGVyIGRldmVsb3BtZW50IGZvciBiZXRhLlxuXHRcdDwvcD5cblxuXHRcdDxkaXYgY2xhc3M9XCJyZXN1bHRzIG5vLW1hcmdpblwiIGJpbmQ6dGhpcz17ZG1fcmVzdWx0c30+XG5cdFx0XHR7I2tleSBhX3Jlc3VsdHN9XG5cdFx0XHRcdHsjZWFjaCBhX3Jlc3VsdHMgYXMgZ19yZXN1bHR9XG5cdFx0XHRcdFx0PEdlbmVyaWNSb3cgaXRlbT17Z19yZXN1bHR9IC8+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHsva2V5fVxuXHRcdDwvZGl2PlxuXHQ8L1NjcmVlbj5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cblx0aW1wb3J0IHsgeXdfcHJvZ3Jlc3MgfSBmcm9tICcjIy9tZW0nO1xuXG5cdCQ6IHhfd2lkdGhfcGN0X2JhciA9ICgkeXdfcHJvZ3Jlc3NbMF0gLyAkeXdfcHJvZ3Jlc3NbMV0pICogMTAwO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdC5wcm9ncmVzcyB7XG5cdFx0LS1iYXItaGVpZ2h0OiA0cHg7XG5cdFx0ei1pbmRleDogMTAwMTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0aGVpZ2h0OiB2YXIoLS1iYXItaGVpZ2h0KTtcblx0XHR0b3A6IGNhbGMoMHB4IC0gdmFyKC0tYmFyLWhlaWdodCkpO1xuXHRcdGxlZnQ6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0dHJhbnNpdGlvbjogdG9wIDAuMnMgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXG5cdFx0Ji52aXNpYmxlIHtcblx0XHRcdHRvcDogMDtcblx0XHR9XG5cblx0XHQ+LmJhciB7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdGhlaWdodDogMTAwJTtcblx0XHRcdHdpZHRoOiAwJTtcblx0XHRcdHRyYW5zaXRpb246IHdpZHRoIDFzIHZhcigtLWVhc2Utb3V0LWN1YmljKTtcblx0XHR9XG5cdH1cblxuXHQuc3RlcCB7XG5cdFx0LmZvbnQodGlueSk7XG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblxuXHRcdHotaW5kZXg6IDEwMDE7XG5cblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiBjYWxjKDBweCAtIHZhcigtLXVpLXBhZGRpbmcpKTtcblx0XHRsZWZ0OiAwO1xuXHRcdC8vIGxlZnQ6IGNhbGMoMHB4IC0gKHZhcigtLWFwcC13aW5kb3ctd2lkdGgpICogMC4yNSkpO1xuXHRcdFxuXHRcdG1hcmdpbi10b3A6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdG1hcmdpbi1sZWZ0OiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcblx0XHRvcGFjaXR5OiAwO1xuXHRcdHRyYW5zaXRpb246IGFsbCAwLjZzIHZhcigtLWVhc2Utb3V0LWN1YmljKTtcblx0XHR0cmFuc2l0aW9uLWRlbGF5OiAwLjRzO1xuXG5cdFx0Ji52aXNpYmxlIHtcblx0XHRcdC8vIGxlZnQ6IDA7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRvcGFjaXR5OiAxO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwicHJvZ3Jlc3NcIiBjbGFzczp2aXNpYmxlPXskeXdfcHJvZ3Jlc3NbMF0gPiAwfT5cblx0PGRpdiBjbGFzcz1cImJhclwiIHN0eWxlPVwid2lkdGg6IHt4X3dpZHRoX3BjdF9iYXJ9JTtcIj48L2Rpdj5cbjwvZGl2PlxuXG48ZGl2IGNsYXNzPVwic3RlcFwiIGNsYXNzOnZpc2libGU9eyR5d19wcm9ncmVzc1swXSA+IDB9PlxuXHRTdGVwIHskeXdfcHJvZ3Jlc3NbMF0gfHwgJHl3X3Byb2dyZXNzWzFdfSBvZiB7JHl3X3Byb2dyZXNzWzFdfVxuPC9kaXY+XG4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIm0xOCAxNiA0LTQtNC00djNoLTUuMDZBOC45NzQgOC45NzQgMCAwIDAgOCAzLjk1IDMuMDA1IDMuMDA1IDAgMCAwIDUgMUMzLjM0IDEgMiAyLjM0IDIgNHMxLjM0IDMgMyAzYy45NSAwIDEuNzgtLjQ1IDIuMzMtMS4xNEM5LjIzIDYuOSAxMC42IDguNzcgMTAuOTIgMTFoLTMuMUM3LjQgOS44NCA2LjMgOSA1IDljLTEuNjYgMC0zIDEuMzQtMyAzczEuMzQgMyAzIDNjMS4zIDAgMi40LS44NCAyLjgyLTJoMy4xYy0uMzIgMi4yMy0xLjY5IDQuMS0zLjU4IDUuMTRDNi43OCAxNy40NSA1Ljk1IDE3IDUgMTdjLTEuNjYgMC0zIDEuMzQtMyAzczEuMzQgMyAzIDNhMi45OSAyLjk5IDAgMCAwIDIuOTktMi45NUE4Ljk3NCA4Ljk3NCAwIDAgMCAxMi45MyAxM0gxOHYzelxcXCIvPlxcbjwvc3ZnPlwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnpNNy4wNyAxOC4yOGMuNDMtLjkgMy4wNS0xLjc4IDQuOTMtMS43OHM0LjUxLjg4IDQuOTMgMS43OEMxNS41NyAxOS4zNiAxMy44NiAyMCAxMiAyMHMtMy41Ny0uNjQtNC45My0xLjcyem0xMS4yOS0xLjQ1Yy0xLjQzLTEuNzQtNC45LTIuMzMtNi4zNi0yLjMzcy00LjkzLjU5LTYuMzYgMi4zM0E3Ljk1IDcuOTUgMCAwIDEgNCAxMmMwLTQuNDEgMy41OS04IDgtOHM4IDMuNTkgOCA4YzAgMS44Mi0uNjIgMy40OS0xLjY0IDQuODN6TTEyIDZjLTEuOTQgMC0zLjUgMS41Ni0zLjUgMy41UzEwLjA2IDEzIDEyIDEzczMuNS0xLjU2IDMuNS0zLjVTMTMuOTQgNiAxMiA2em0wIDVjLS44MyAwLTEuNS0uNjctMS41LTEuNVMxMS4xNyA4IDEyIDhzMS41LjY3IDEuNSAxLjVTMTIuODMgMTEgMTIgMTF6XFxcIi8+XFxuPC9zdmc+XCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIk0xOCA0djE2SDZWNGgxMm0wLTJINmMtMS4xIDAtMiAuOS0yIDJ2MThoMTZWNGMwLTEuMS0uOS0yLTItMnptLTIuNSA4LjVjLS44MyAwLTEuNS42Ny0xLjUgMS41cy42NyAxLjUgMS41IDEuNVMxNyAxMi44MyAxNyAxMnMtLjY3LTEuNS0xLjUtMS41elxcXCIvPlxcbjwvc3ZnPlwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgRl9OT09QLCB0aW1lb3V0IH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCB7XG5cdFx0eXdfbWVudV9leHBhbmRlZCwgeXdfbmF2aWdhdG9yLFxuXHR9IGZyb20gJyMvYXBwL21lbSc7XG5cblx0aW1wb3J0IFNYX0lDT05fQ09OVEFDVFMgZnJvbSAnIy9pY29uL3N1cGVydmlzb3JfYWNjb3VudC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ0hBSU5TIGZyb20gJyMvaWNvbi9tZWRpYXRpb24uc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0FDQ09VTlRTIGZyb20gJyMvaWNvbi9hY2NvdW50X2NpcmNsZS5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fVEFHUyBmcm9tICcjL2ljb24vYm9va21hcmtzLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9DT05ORUNUSU9OUyBmcm9tICcjL2ljb24vYWNjb3VudF90cmVlLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9TRVRUSU5HUyBmcm9tICcjL2ljb24vc2V0dGluZ3Muc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0xPR09VVCBmcm9tICcjL2ljb24vc2Vuc29yX2Rvb3Iuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NMT1NFIGZyb20gJyMvaWNvbi9jbG9zZS5zdmc/cmF3Jztcblx0aW1wb3J0IHsgVGhyZWFkSWQgfSBmcm9tICcjL2FwcC9kZWYnO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBQYWdlIH0gZnJvbSAnIyMvc2NyZWVuL19zY3JlZW5zJztcblx0aW1wb3J0IHsgbG9nb3V0IH0gZnJvbSAnIy9zaGFyZS9hdXRoJztcblxuXHRpbnRlcmZhY2UgSXRlbSB7XG5cdFx0Y2xpY2s6IFZvaWRGdW5jdGlvbjtcblx0XHRsYWJlbDogc3RyaW5nO1xuXHRcdC8vIGljb246IEljb247XG5cdFx0aWNvbjogc3RyaW5nO1xuXHR9XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGZ1bmN0aW9uIGFjdGl2YXRlKHNpX3RocmVhZDogVGhyZWFkSWQpIHtcblx0XHQkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlO1xuXG5cdFx0aWYoc2lfdGhyZWFkID09PSAkeXdfbmF2aWdhdG9yLmFjdGl2ZVRocmVhZC5pZCkge1xuXHRcdFx0JHl3X25hdmlnYXRvci5hY3RpdmVUaHJlYWQucmVzZXQoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2b2lkICR5d19uYXZpZ2F0b3IuYWN0aXZhdGVUaHJlYWQoc2lfdGhyZWFkKTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCBBX0lURU1TID0gW1xuXHRcdC8vIHtcblx0XHQvLyBcdGxhYmVsOiAnQ29udGFjdHMnLFxuXHRcdC8vIFx0Ly8gaWNvbjogSWNvbi5mcm9tSHRtbChTWF9JQ09OX0NPTlRBQ1RTKSxcblx0XHQvLyBcdGljb246IFNYX0lDT05fQ09OVEFDVFMsXG5cdFx0Ly8gXHRjbGljaygpIHtcblx0XHQvLyBcdFx0JHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZTtcblx0XHQvLyBcdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKFRocmVhZElkLkNPTlRBQ1RTKTtcblx0XHQvLyBcdH0sXG5cdFx0Ly8gfSxcblx0XHR7XG5cdFx0XHRsYWJlbDogJ0FjY291bnRzJyxcblx0XHRcdC8vIGljb246IEljb24uZnJvbUh0bWwoU1hfSUNPTl9BQ0NPVU5UUyksXG5cdFx0XHRpY29uOiBTWF9JQ09OX0FDQ09VTlRTLFxuXHRcdFx0Y2xpY2soKSB7XG5cdFx0XHRcdGFjdGl2YXRlKFRocmVhZElkLkFDQ09VTlRTKTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRsYWJlbDogJ05ldHdvcmtzJyxcblx0XHRcdC8vIGljb246IEljb24uZnJvbUh0bWwoU1hfSUNPTl9DSEFJTlMpLFxuXHRcdFx0aWNvbjogU1hfSUNPTl9DSEFJTlMsXG5cdFx0XHRjbGljaygpIHtcblx0XHRcdFx0YWN0aXZhdGUoVGhyZWFkSWQuTkVUV09SS1MpO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRcdC8vIHtcblx0XHQvLyBcdGxhYmVsOiAnVGFncycsXG5cdFx0Ly8gXHQvLyBpY29uOiBJY29uLmZyb21IdG1sKFNYX0lDT05fVEFHUyksXG5cdFx0Ly8gXHRpY29uOiBTWF9JQ09OX1RBR1MsXG5cdFx0Ly8gXHRjbGljaygpIHtcblx0XHQvLyBcdFx0JHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZTtcblx0XHQvLyBcdFx0Ly8ga19wYWdlLnB1c2goe1xuXHRcdC8vIFx0XHQvLyBcdGNyZWF0b3I6IERlYWRFbmQsXG5cdFx0Ly8gXHRcdC8vIH0pO1xuXHRcdC8vIFx0fSxcblx0XHQvLyB9LFxuXHRcdC8vIHtcblx0XHQvLyBcdGxhYmVsOiAnU2l0ZXMnLFxuXHRcdC8vIFx0Ly8gaWNvbjogSWNvbi5mcm9tSHRtbChTWF9JQ09OX0NPTk5FQ1RJT05TKSxcblx0XHQvLyBcdGljb246IFNYX0lDT05fQ09OTkVDVElPTlMsXG5cdFx0Ly8gXHRjbGljaygpIHtcblx0XHQvLyBcdFx0JHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZTtcblx0XHQvLyBcdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKFRocmVhZElkLlNJVEVTKTtcblx0XHQvLyBcdH0sXG5cdFx0Ly8gfSxcblx0XHQvLyB7XG5cdFx0Ly8gXHRsYWJlbDogJ1NldHRpbmdzJyxcblx0XHQvLyBcdC8vIGljb246IEljb24uZnJvbUh0bWwoU1hfSUNPTl9TRVRUSU5HUyksXG5cdFx0Ly8gXHRpY29uOiBTWF9JQ09OX1NFVFRJTkdTLFxuXHRcdC8vIFx0Y2xpY2s6ICgpID0+IHtcblx0XHQvLyBcdFx0JHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZTtcblx0XHQvLyBcdFx0a19wYWdlLnB1c2goe1xuXHRcdC8vIFx0XHRcdGNyZWF0b3I6IERlYWRFbmQsXG5cdFx0Ly8gXHRcdH0pO1xuXHRcdC8vIFx0fSxcblx0XHQvLyB9LFxuXHRdO1xuXG5cdGNvbnN0IEFfU0VTU0lPTl9JVEVNUyA9IFtcblx0XHR7XG5cdFx0XHRsYWJlbDogJ0xvZyBvdXQnLFxuXHRcdFx0aWNvbjogU1hfSUNPTl9MT0dPVVQsXG5cdFx0XHRhc3luYyBjbGljaygpIHtcblx0XHRcdFx0YXdhaXQgbG9nb3V0KCk7XG5cdFx0XHRcdGdsb2JhbFRoaXMuY2xvc2UoKTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vc2NyZWVuL19iYXNlLmxlc3MnO1xuXG5cdDpyb290IHtcblx0XHQtLWJhci13aWR0aDogNzguOCU7XG5cdFx0LS1hbmltYXRpb24tZHVyYXRpb246IDFzO1xuXHRcdC0tYW5pbWF0aW9uLWVhc2luZzogdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHR9XG5cblx0QGtleWZyYW1lcyBmYWRlIHtcblx0XHQwJSB7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHR9XG5cblx0XHQxMDAlIHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcblx0XHR9XG5cdH1cblxuXHRAa2V5ZnJhbWVzIHNsaWRlIHtcblx0XHQwJSB7XG5cdFx0XHRyaWdodDogY2FsYygwJSAtIHZhcigtLWJhci13aWR0aCkpO1xuXHRcdH1cblxuXHRcdDEwMCUge1xuXHRcdFx0cmlnaHQ6IDAlO1xuXHRcdH1cblx0fVxuXG5cdEBrZXlmcmFtZXMgb2Zmc2NyZWVuIHtcblx0XHQwJSB7XG5cdFx0XHR0b3A6IDA7XG5cdFx0fVxuXG5cdFx0MTAwJSB7XG5cdFx0XHR0b3A6IHZhcigtLWFwcC13aW5kb3ctaGVpZ2h0KTtcblx0XHR9XG5cdH1cblxuXHQuYWJzb2x1dGUoQGRpbXM6ICcnKSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXG5cdFx0d2lkdGg6IGlmKCcnID0gQGRpbXMsIHZhcigtLWFwcC13aW5kb3ctd2lkdGgpLCBAZGltcyk7XG5cdFx0aGVpZ2h0OiBpZignJyA9IEBkaW1zLCB2YXIoLS1hcHAtd2luZG93LWhlaWdodCksIEBkaW1zKTtcblx0fVxuXG5cdC5zaWRlLW1lbnUge1xuXHRcdC0taXRlbS1wYWRkaW5nOiAzMHB4O1xuXG5cdFx0LmFic29sdXRlKCk7XG5cdFx0LmZvbnQocmVndWxhcik7XG5cdFx0ei1pbmRleDogMTAwMTtcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdD4uYmFja2Ryb3Age1xuXHRcdFx0LmFic29sdXRlKDEwMCUpO1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuXHRcdFx0dHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciB2YXIoLS1hbmltYXRpb24tZHVyYXRpb24pIHZhcigtLWVhc2Utb3V0LWV4cG8pO1xuXHRcdH1cblxuXHRcdD4uYmFyIHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdHdpZHRoOiB2YXIoLS1iYXItd2lkdGgpO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0cmlnaHQ6IDAlO1xuXHRcdFx0dHJhbnNpdGlvbjogcmlnaHQgdmFyKC0tYW5pbWF0aW9uLWR1cmF0aW9uKSB2YXIoLS1hbmltYXRpb24tZWFzaW5nKTtcblxuXHRcdFx0Pi5tZW51IHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XG5cdFx0XHRcdGhlaWdodDogMTAwJTtcblxuXHRcdFx0XHR1bCB7XG5cdFx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG5cblx0XHRcdFx0XHQ+bGkge1xuXHRcdFx0XHRcdFx0bGlzdC1zdHlsZTogbm9uZTtcblx0XHRcdFx0XHRcdHBhZGRpbmc6IDEzcHggMDtcblx0XHRcdFx0XHRcdHBhZGRpbmctbGVmdDogdmFyKC0taXRlbS1wYWRkaW5nKTtcblx0XHRcdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblxuXHRcdFx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ+Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmctcmlnaHQ6IGNhbGModmFyKC0taXRlbS1wYWRkaW5nKSAvIDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCYuaXRlbXMge1xuXHRcdFx0XHRcdFx0Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCYuc2Vzc2lvbiB7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiBjYWxjKHZhcigtLWl0ZW0tcGFkZGluZykgLyAyKSAwO1xuXG5cdFx0XHRcdFx0XHQuaWNvbiB7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4ubWFpbiB7XG5cdFx0XHRcdFx0ZmxleDogMTtcblx0XHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcblx0XHRcdFx0XHRwYWRkaW5nLXRvcDogMTUlO1xuXHRcdFx0XHRcdHBhZGRpbmctYm90dG9tOiAxNSU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LmJvdHRvbSw+LnRvcCB7XG5cdFx0XHRcdFx0ZmxleDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4udG9wIHtcblx0XHRcdFx0XHRwYWRkaW5nLXRvcDogMTUlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ji5jb2xsYXBzZWQge1xuXHRcdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRhbmltYXRpb246IG9mZnNjcmVlbiB2YXIoLS1hbmltYXRpb24tZHVyYXRpb24pIHN0ZXBzKDIsIGp1bXAtbm9uZSkgYm90aDtcblx0XHRcdFxuXHRcdFx0Pi5iYWNrZHJvcCB7XG5cdFx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdD4uYmFyIHtcblx0XHRcdFx0cmlnaHQ6IGNhbGMoMCUgLSB2YXIoLS1iYXItd2lkdGgpKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGhyIHtcblx0XHRcdG1hcmdpbjogMCB2YXIoLS1pdGVtLXBhZGRpbmcpO1xuXHRcdFx0Ym9yZGVyOiBub25lO1xuXHRcdFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0fVxuXG5cdFx0LmNsb3NlIHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdHJpZ2h0OiAwO1xuXHRcdFx0bWFyZ2luOiAxMHB4O1xuXHRcdFx0cGFkZGluZzogMTJweDtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cblx0XHRcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0Ym9yZGVyLXJhZGl1czogMHB4O1xuXHRcdFx0dHJhbnNpdGlvbjogYm9yZGVyLXJhZGl1cyA2NTBtcyB2YXIoLS1lYXNlLW91dC1leHBvKTtcblx0XHRcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cblx0XHRcdCY6OmJlZm9yZSB7XG5cdFx0XHRcdC0tb2NjbHVzaW9uLXRoaWNrbmVzczogNHB4O1xuXG5cdFx0XHRcdGNvbnRlbnQ6ICcnO1xuXHRcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdHRvcDogY2FsYyh2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSAvIDIpO1xuXHRcdFx0XHRsZWZ0OiBjYWxjKHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIC8gMik7XG5cdFx0XHRcdHdpZHRoOiBjYWxjKDEwMCUgLSB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSk7XG5cdFx0XHRcdGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykpO1xuXHRcdFx0XHRvdXRsaW5lOiB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdFx0fVxuXG5cdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0Ym9yZGVyLXJhZGl1czogMjJweDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXZcblx0Y2xhc3M9XCJzaWRlLW1lbnVcIlxuXHRjbGFzczpjb2xsYXBzZWQ9eyEkeXdfbWVudV9leHBhbmRlZH1cbj5cblx0PGRpdiBjbGFzcz1cImJhY2tkcm9wXCJcblx0XHRvbjpjbGljaz17KCkgPT4gJHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZX1cblx0Lz5cblxuXHQ8ZGl2IGNsYXNzPVwiYmFyXCI+XG5cdFx0PGRpdiBjbGFzcz1cImNsb3NlIGljb25cIiBvbjpjbGljaz17KCkgPT4gJHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZX0+XG5cdFx0XHR7QGh0bWwgU1hfSUNPTl9DTE9TRX1cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJtZW51XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwidG9wXCI+XG5cdFx0XHRcdDx1bCBjbGFzcz1cInNlc3Npb25cIj5cblx0XHRcdFx0XHR7I2VhY2ggQV9TRVNTSU9OX0lURU1TIGFzIGdfaXRlbX1cblx0XHRcdFx0XHRcdDxsaSBvbjpjbGljaz17KCkgPT4gZ19pdGVtLmNsaWNrKCl9PlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgZ19pdGVtLmljb259XG5cdFx0XHRcdFx0XHRcdFx0PCEtLSA8UHV0IGVsZW1lbnQ9e2dfaXRlbS5pY29uLnJlbmRlcigpfSAvPiAtLT5cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0XHRcdFx0XHR7Z19pdGVtLmxhYmVsfVxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0PC91bD5cblxuXHRcdFx0XHQ8aHI+XG5cdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PGRpdiBjbGFzcz1cIm1haW5cIj5cblx0XHRcdFx0PHVsIGNsYXNzPVwiaXRlbXNcIj5cblx0XHRcdFx0XHR7I2VhY2ggQV9JVEVNUyBhcyBnX2l0ZW19XG5cdFx0XHRcdFx0XHQ8bGkgY2xhc3M9XCJcIiBvbjpjbGljaz17KCkgPT4gZ19pdGVtLmNsaWNrKCl9PlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgZ19pdGVtLmljb259XG5cdFx0XHRcdFx0XHRcdFx0PCEtLSA8UHV0IGVsZW1lbnQ9e2dfaXRlbS5pY29uLnJlbmRlcigpfSAvPiAtLT5cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0XHRcdFx0XHR7Z19pdGVtLmxhYmVsfVxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0PC91bD5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IEZfTk9PUCB9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXHRpbXBvcnQge1xuXHRcdHl3X21lbnVfZXhwYW5kZWQsXG5cdFx0eXdfbWVudV92ZW5kb3IsXG5cdFx0eXdfY2hhaW5fcmVmLFxuXHRcdHl3X2NoYWluLFxuXHRcdHl3X25ldHdvcmtfcmVmLFxuXHRcdHl3X25ldHdvcmssXG5cdH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgeyBnbG9iYWxfcmVjZWl2ZSB9IGZyb20gJyMvc2NyaXB0L21zZy1nbG9iYWwnO1xuXHRpbXBvcnQgeyBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnO1xuaW1wb3J0IHsgU0lfVkVSU0lPTiB9IGZyb20gJyMvc2hhcmUvY29uc3RhbnRzJztcblxuXHQvLyBpbXBvcnQge1xuXHQvLyBcdEljb24sXG5cdC8vIH0gZnJvbSAnIy9vYmplY3RzJztcblxuXHQvLyBpbXBvcnQge1xuXHQvLyBcdFB1dCxcblx0Ly8gIH0gZnJvbSAnIy91aSc7XG5cblx0Ly8gaW1wb3J0IFNYX0NPTlRBQ1RTIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL3N1cGVydmlzb3JfYWNjb3VudC5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0NIQUlOUyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9tZWRpYXRpb24uc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9BQ0NPVU5UUyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9hY2NvdW50X2NpcmNsZS5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX1RBR1MgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvYm9va21hcmtzLnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfQ09OTkVDVElPTlMgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvYWNjb3VudF90cmVlLnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfU0VUVElOR1MgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvc2V0dGluZ3Muc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9MT0dPVVQgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvc2Vuc29yX2Rvb3Iuc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9DTE9TRSBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9jbG9zZS5zdmc/cmF3JztcblxuXHQvLyBpbXBvcnQgU1hfVElUTEUgZnJvbSAnIy9hc3NldC92ZW5kb3Ivc3RhcnNoZWxsLXRpdGxlLnN2Zz9yYXcnO1xuXG5cdC8vICR5d19tZW51X2V4cGFuZGVkXG5cblx0aW50ZXJmYWNlIEl0ZW0ge1xuXHRcdGNsaWNrOiBWb2lkRnVuY3Rpb247XG5cdFx0bGFiZWw6IHN0cmluZztcblx0XHQvLyBpY29uOiBJY29uO1xuXHR9XG5cblx0Ly8gbGV0IHNfbGF0ZW5jeSA9ICcxMjBtcyc7XG5cblx0bGV0IHNfaGVpZ2h0ID0gJyc7XG5cdGxldCB4dF93aGVuID0gMDtcblx0bGV0IHh0X2F2Z19ibG9ja190aW1lID0gMDtcblxuXHRsZXQgc19uZXR3b3JrX3N0YXR1cyA9ICdMb2FkaW5nJztcblx0bGV0IHBfcHJvdmlkZXIgPSAnJztcblx0bGV0IHNpX2NoYWluID0gJyc7XG5cblx0bGV0IHNfZ3JwY3dfc3RhdHVzID0gJyc7XG5cdGxldCBzX3JwY19zdGF0dXMgPSAnJztcblxuXG5cdC8vIHdoZW4gdGhlIG5ldHdvcmsgaXMgY2hhbmdlZFxuXHQkOiBpZigkeXdfbmV0d29yaykge1xuXHRcdHNfaGVpZ2h0ID0gJ1suLi5dJztcblx0XHR4dF93aGVuID0gMDtcblx0XHR4dF9hdmdfYmxvY2tfdGltZSA9IDA7XG5cdFx0c19uZXR3b3JrX3N0YXR1cyA9ICdDb25uZWN0aW5nJztcblx0XHRwX3Byb3ZpZGVyID0gbmV3IFVSTCgkeXdfbmV0d29yay5ncnBjV2ViVXJsKS5ob3N0O1xuXHRcdHNpX2NoYWluID0gJyc7XG5cdH1cblxuXHRnbG9iYWxfcmVjZWl2ZSh7XG5cdFx0YmxvY2tJbmZvKGdfaW5mbykge1xuXHRcdFx0aWYoJHl3X2NoYWluX3JlZiA9PT0gZ19pbmZvLmNoYWluKSB7XG5cdFx0XHRcdHNfbmV0d29ya19zdGF0dXMgPSAnT25saW5lJztcblx0XHRcdFx0c2lfY2hhaW4gPSBnX2luZm8uaGVhZGVyLmNoYWluX2lkIGFzIHN0cmluZztcblxuXHRcdFx0XHRzX2hlaWdodCA9IGdfaW5mby5oZWFkZXIuaGVpZ2h0IGFzIHN0cmluZztcblx0XHRcdFx0eHRfd2hlbiA9IERhdGUubm93KCk7XG5cblx0XHRcdFx0Y29uc3QgYV9yZWNlbnRzID0gZ19pbmZvLnJlY2VudHM7XG5cdFx0XHRcdGlmKGFfcmVjZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0Y29uc3QgYV9nYXBzOiBudW1iZXJbXSA9IFtdO1xuXHRcdFx0XHRcdGZvcihsZXQgaV9lYWNoPTE7IGlfZWFjaDxhX3JlY2VudHMubGVuZ3RoOyBpX2VhY2grKykge1xuXHRcdFx0XHRcdFx0YV9nYXBzLnB1c2goYV9yZWNlbnRzW2lfZWFjaF0gLSBhX3JlY2VudHNbaV9lYWNoLTFdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR4dF9hdmdfYmxvY2tfdGltZSA9IGFfZ2Fwcy5yZWR1Y2UoKGNfb3V0LCB4X3ZhbHVlKSA9PiBjX291dCArIHhfdmFsdWUsIDApIC8gYV9nYXBzLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH0pO1xuXG5cdGxldCBzX2xvbmdfYWdvID0gJ1suLi5dJztcblx0Y29uc3QgaV9sb25nX2FnbyA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0aWYoeHRfd2hlbiA+IDApIHtcblx0XHRcdGNvbnN0IHh0X2FnbyA9IERhdGUubm93KCkgLSB4dF93aGVuO1xuXHRcdFx0c19sb25nX2FnbyA9IGAke01hdGgucm91bmQoeHRfYWdvIC8gMWUzKX0gc2Vjb25kcyBhZ29gO1xuXHRcdH1cblx0fSwgNTAwKTtcblx0XG5cdG9uRGVzdHJveSgoKSA9PiB7XG5cdFx0Y2xlYXJJbnRlcnZhbChpX2xvbmdfYWdvKTtcblx0fSk7XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHQ6cm9vdCB7XG5cdFx0LS1iYXItd2lkdGg6IDc4LjglO1xuXHRcdC0tYW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcblx0XHQtLWFuaW1hdGlvbi1lYXNpbmc6IHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0fVxuXG5cdEBrZXlmcmFtZXMgZmFkZSB7XG5cdFx0MCUge1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0fVxuXG5cdFx0MTAwJSB7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQGtleWZyYW1lcyBzbGlkZSB7XG5cdC8vIFx0MCUge1xuXHQvLyBcdFx0bGVmdDogY2FsYygwJSAtIHZhcigtLWJhci13aWR0aCkpO1xuXHQvLyBcdH1cblxuXHQvLyBcdDEwMCUge1xuXHQvLyBcdFx0bGVmdDogMCU7XG5cdC8vIFx0fVxuXHQvLyB9XHRcblxuXHRAa2V5ZnJhbWVzIG9wYWNpdHkge1xuXHRcdDAlIHtcblx0XHRcdG9wYWNpdHk6IDA7XG5cdFx0fVxuXG5cdFx0MTAwJSB7XG5cdFx0XHRvcGFjaXR5OiAxO1xuXHRcdH1cblx0fVxuXG5cblx0QGtleWZyYW1lcyBvZmZzY3JlZW4ge1xuXHRcdDAlIHtcblx0XHRcdHRvcDogMDtcblx0XHR9XG5cblx0XHQxMDAlIHtcblx0XHRcdHRvcDogdmFyKC0tYXBwLXdpbmRvdy1oZWlnaHQpO1xuXHRcdH1cblx0fVxuXG5cdC5hYnNvbHV0ZShAZGltczogJycpIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cblx0XHR3aWR0aDogaWYoJycgPSBAZGltcywgdmFyKC0tYXBwLXdpbmRvdy13aWR0aCksIEBkaW1zKTtcblx0XHRoZWlnaHQ6IGlmKCcnID0gQGRpbXMsIHZhcigtLWFwcC13aW5kb3ctaGVpZ2h0KSwgQGRpbXMpO1xuXHR9XG5cblx0LnZlbmRvci1tZW51IHtcblx0XHQtLWl0ZW0tcGFkZGluZzogMzBweDtcblxuXHRcdC5hYnNvbHV0ZSgpO1xuXHRcdC5mb250KHJlZ3VsYXIpO1xuXHRcdHotaW5kZXg6IDEwMDE7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0Ly8gY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJsYWNrKTtcblxuXHRcdD4uYmFja2Ryb3Age1xuXHRcdFx0LmFic29sdXRlKDEwMCUpO1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuXHRcdFx0dHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciB2YXIoLS1hbmltYXRpb24tZHVyYXRpb24pIHZhcigtLWVhc2Utb3V0LWV4cG8pO1xuXHRcdH1cblxuXHRcdD4uYmFyIHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdHdpZHRoOiB2YXIoLS1iYXItd2lkdGgpO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0Ly8gYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRsZWZ0OiAwJTtcblx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0XHR0cmFuc2l0aW9uOiBsZWZ0IHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgdmFyKC0tYW5pbWF0aW9uLWVhc2luZyksXG5cdFx0XHRcdG9wYWNpdHkgY2FsYyh2YXIoLS1hbmltYXRpb24tZHVyYXRpb24pIC8gMykgZWFzZS1vdXQ7XG5cblx0XHRcdD4ubWVudSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xuXHRcdFx0XHRoZWlnaHQ6IDEwMCU7XG5cblx0XHRcdFx0dWwge1xuXHRcdFx0XHRcdG1hcmdpbjogMDtcblx0XHRcdFx0XHRwYWRkaW5nOiAwO1xuXG5cdFx0XHRcdFx0PmxpIHtcblx0XHRcdFx0XHRcdGxpc3Qtc3R5bGU6IG5vbmU7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiAxM3B4IDA7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLWxlZnQ6IHZhcigtLWl0ZW0tcGFkZGluZyk7XG5cdFx0XHRcdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cblx0XHRcdFx0XHRcdD4qIHtcblx0XHRcdFx0XHRcdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Pi5pY29uIHtcblx0XHRcdFx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0XHRcdFx0XHRwYWRkaW5nOiAwO1xuXHRcdFx0XHRcdFx0XHRwYWRkaW5nLXJpZ2h0OiBjYWxjKHZhcigtLWl0ZW0tcGFkZGluZykgLyAyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmLml0ZW1zIHtcblx0XHRcdFx0XHRcdC5pY29uIHtcblx0XHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ibGFjayk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ji5zZXNzaW9uIHtcblx0XHRcdFx0XHRcdHBhZGRpbmc6IGNhbGModmFyKC0taXRlbS1wYWRkaW5nKSAvIDIpIDA7XG5cblx0XHRcdFx0XHRcdC5pY29uIHtcblx0XHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5tYWluIHtcblx0XHRcdFx0XHRmbGV4OiAxO1xuXHRcdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG5cdFx0XHRcdFx0Ly8gcGFkZGluZy10b3A6IDE1JTtcblxuXHRcdFx0XHRcdHBhZGRpbmctbGVmdDogMWVtO1xuXG5cdFx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pi5hcHAge1xuXHRcdFx0XHRcdFx0Ly8gbWFyZ2luLXRvcDogMjUlO1xuXHRcdFx0XHRcdFx0bWFyZ2luLXRvcDogMTBweDtcblx0XHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdFx0XHRcdHBhZGRpbmc6IDE2cHggMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+LmluZm8ge1xuXHRcdFx0XHRcdFx0cGFkZGluZzogMTZweCAwO1xuXG5cdFx0XHRcdFx0XHQubmFtZSB7XG5cdFx0XHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdFx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQudmFsdWUge1xuXHRcdFx0XHRcdFx0XHRwYWRkaW5nLXRvcDogNHB4O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4uYm90dG9tIHtcblx0XHRcdFx0XHRmbGV4OiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ji5jb2xsYXBzZWQge1xuXHRcdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRhbmltYXRpb246IG9mZnNjcmVlbiB2YXIoLS1hbmltYXRpb24tZHVyYXRpb24pIHN0ZXBzKDIsIGp1bXAtbm9uZSkgYm90aDtcblx0XHRcdFxuXHRcdFx0Pi5iYWNrZHJvcCB7XG5cdFx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XG5cdFx0XHR9XG5cblx0XHRcdD4uYmFyIHtcblx0XHRcdFx0bGVmdDogY2FsYygwJSAtIHZhcigtLWJhci13aWR0aCkpO1xuXHRcdFx0XHRvcGFjaXR5OiAwLjE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRociB7XG5cdFx0XHRtYXJnaW46IDAgdmFyKC0taXRlbS1wYWRkaW5nKTtcblx0XHRcdGJvcmRlcjogbm9uZTtcblx0XHRcdGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdH1cblxuXHRcdC8vIC5jbG9zZS1kYXJrIHtcblx0XHQvLyBcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHQvLyBcdHRvcDogMDtcblx0XHQvLyBcdHJpZ2h0OiAwO1xuXHRcdC8vIFx0bWFyZ2luOiAxMHB4O1xuXHRcdC8vIFx0cGFkZGluZzogMTJweDtcblx0XHQvLyBcdGN1cnNvcjogcG9pbnRlcjtcblx0XHQvLyBcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHQvLyBcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmxhY2spO1xuXG5cdFx0Ly8gXHRvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHQvLyBcdGJvcmRlci1yYWRpdXM6IDBweDtcblx0XHQvLyBcdHRyYW5zaXRpb246IGJvcmRlci1yYWRpdXMgNjUwbXMgdmFyKC0tZWFzZS1vdXQtZXhwbyk7XG5cdFx0Ly8gXHRwb2ludGVyLWV2ZW50czogYWxsO1xuXG5cdFx0Ly8gXHQmOjpiZWZvcmUge1xuXHRcdC8vIFx0XHQtLW9jY2x1c2lvbi10aGlja25lc3M6IDRweDtcblxuXHRcdC8vIFx0XHRjb250ZW50OiAnJztcblx0XHQvLyBcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdC8vIFx0XHR0b3A6IGNhbGModmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgLyAyKTtcblx0XHQvLyBcdFx0bGVmdDogY2FsYyh2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSAvIDIpO1xuXHRcdC8vIFx0XHR3aWR0aDogY2FsYygxMDAlIC0gdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykpO1xuXHRcdC8vIFx0XHRoZWlnaHQ6IGNhbGMoMTAwJSAtIHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpKTtcblx0XHQvLyBcdFx0b3V0bGluZTogdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0Ly8gXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0Ly8gXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdC8vIFx0fVxuXG5cdFx0Ly8gXHQmOmhvdmVyIHtcblx0XHQvLyBcdFx0Ym9yZGVyLXJhZGl1czogMjJweDtcblx0XHQvLyBcdH1cblx0XHQvLyB9XG5cblx0XHQuY2xvc2Uge1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0cmlnaHQ6IDA7XG5cdFx0XHRtYXJnaW46IDEwcHg7XG5cdFx0XHRwYWRkaW5nOiAxMnB4O1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblxuXHRcdFx0b3V0bGluZTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRib3JkZXItcmFkaXVzOiAwcHg7XG5cdFx0XHR0cmFuc2l0aW9uOiBib3JkZXItcmFkaXVzIDY1MG1zIHZhcigtLWVhc2Utb3V0LWV4cG8pO1xuXHRcdFx0cG9pbnRlci1ldmVudHM6IGFsbDtcblxuXHRcdFx0Jjo6YmVmb3JlIHtcblx0XHRcdFx0LS1vY2NsdXNpb24tdGhpY2tuZXNzOiA0cHg7XG5cblx0XHRcdFx0Y29udGVudDogJyc7XG5cdFx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdFx0dG9wOiBjYWxjKHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIC8gMik7XG5cdFx0XHRcdGxlZnQ6IGNhbGModmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgLyAyKTtcblx0XHRcdFx0d2lkdGg6IGNhbGMoMTAwJSAtIHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpKTtcblx0XHRcdFx0aGVpZ2h0OiBjYWxjKDEwMCUgLSB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSk7XG5cdFx0XHRcdG91dGxpbmU6IHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblx0XHRcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRcdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0XHR9XG5cblx0XHRcdCY6aG92ZXIge1xuXHRcdFx0XHRib3JkZXItcmFkaXVzOiAyMnB4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0fVxuPC9zdHlsZT5cblxuPGRpdlxuXHRjbGFzcz1cInZlbmRvci1tZW51XCJcblx0Y2xhc3M6Y29sbGFwc2VkPXshJHl3X21lbnVfdmVuZG9yfVxuPlxuXHQ8ZGl2IGNsYXNzPVwiYmFja2Ryb3BcIlxuXHRcdG9uOmNsaWNrPXsoKSA9PiAkeXdfbWVudV92ZW5kb3IgPSBmYWxzZX1cblx0Lz5cblxuXHQ8ZGl2IGNsYXNzPVwiYmFyXCI+XG5cdFx0PGRpdiBjbGFzcz1cImNsb3NlIGljb25cIiBvbjpjbGljaz17KCkgPT4gJHl3X21lbnVfdmVuZG9yID0gZmFsc2V9PlxuXHRcdFx0PCEtLSA8aW1nIGFsdD1cIkNsb3NlIGljb25cIiBzcmM9XCIvYXNzZXRzL21lZGlhL25hdi9jbG9zZS5zdmdcIj4gLS0+XG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwibWVudVwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cIm1haW5cIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImFwcFwiPlxuXHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHQ8IS0tIHtAaHRtbCBTWF9USVRMRX0gLS0+XG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0dntTSV9WRVJTSU9OfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8IS0tIDxkaXY+XG5cdFx0XHRcdFx0Q3VycmVudCBkQXBwXG5cdFx0XHRcdDwvZGl2PiAtLT5cblxuXHRcdFx0XHQ8IS0tIDxkaXY+XG5cdFx0XHRcdFx0ZG9tYWluOiBzZWNyZXRzd2FwLmlvXG5cdFx0XHRcdDwvZGl2PiAtLT5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHROZXR3b3JrIFN0YXR1c1xuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbHVlXCI+XG5cdFx0XHRcdFx0XHR7c19uZXR3b3JrX3N0YXR1c31cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0Q2hhaW4gSWRcblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJmb250LWZhbWlseV9tb25vXCI+XG5cdFx0XHRcdFx0XHRcdHtzaV9jaGFpbn1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0Q3VycmVudCBQcm92aWRlclxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbHVlXCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImZvbnQtZmFtaWx5X21vbm9cIj5cblx0XHRcdFx0XHRcdFx0e3BfcHJvdmlkZXJ9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdEN1cnJlbnQgQmxvY2sgSGVpZ2h0XG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsdWVcIj5cblx0XHRcdFx0XHRcdCN7c19oZWlnaHR9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdEF2ZXJhZ2UgQmxvY2sgVGltZVxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbHVlXCI+XG5cdFx0XHRcdFx0XHR7I2lmIHh0X2F2Z19ibG9ja190aW1lfVxuXHRcdFx0XHRcdFx0XHR7KHh0X2F2Z19ibG9ja190aW1lIC8gMWUzKS50b0ZpeGVkKDIpfSBzZWNvbmRzXG5cdFx0XHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0XHRcdFsuLi5dXG5cdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHRMYXN0IEJsb2NrIFNlZW5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0e3NfbG9uZ19hZ299XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDwhLS0gPGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0TmV4dCBibG9jayBpblxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbHVlXCI+XG5cdFx0XHRcdFx0XHQgc2Vjb25kc1xuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj4gLS0+XG5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvZGl2PlxuIiwiaW1wb3J0IHR5cGUgeyBQbGFpbk9iamVjdCB9IGZyb20gJyMvbWV0YS9iZWx0JztcbmltcG9ydCB0eXBlIHsgUGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yIH0gZnJvbSAnIy9tZXRhL3N2ZWx0ZSc7XG5pbXBvcnQge1xuXHREaWN0LCBvYmplY3RzX21pZ2h0X2RpZmZlciwgb2RlLCBQcm9taXNhYmxlLFxufSBmcm9tICcjL3V0aWwvYmVsdCc7XG5pbXBvcnQgeyBkZCB9IGZyb20gJyMvdXRpbC9kb20nO1xuaW1wb3J0IHR5cGUgeyBKdW1wQ29uZmlnLCBQb3BDb25maWcsIFRocmVhZCB9IGZyb20gJy4vdGhyZWFkJztcblxuZXhwb3J0IGludGVyZmFjZSBQYWdlQ29uZmlnPFxuXHRoX3Byb3BzIGV4dGVuZHMgRGljdDx1bmtub3duPj1EaWN0PHVua25vd24+LFxuXHRkY19jcmVhdG9yIGV4dGVuZHMgUGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yPGhfcHJvcHM+PVBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvcjxoX3Byb3BzPixcbj4ge1xuXHRjcmVhdG9yOiBkY19jcmVhdG9yO1xuXHRwcm9wcz86IGhfcHJvcHM7XG5cdGNvbnRleHQ/OiBQbGFpbk9iamVjdDtcblx0ZXZlbnRzPzogRGljdDwoZF9ldmVudDogQ3VzdG9tRXZlbnQ8dW5rbm93bj4pID0+IFByb21pc2FibGU8dm9pZD4+O1xuXHRwYXRoPzogc3RyaW5nO1xuXHRwYXR0ZXJuPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VFdmVudENvbmZpZyB7XG5cdC8qKlxuXHQgKiBGaXJlZCBhbnl0aW1lIGEgcGFnZSBsb3NlcyBmb2N1cyAoaW5jbHVkaW5nIG9uIHRocmVhZCBzd2l0Y2gpXG5cdCAqL1xuXHRibHVyPygpOiBQcm9taXNhYmxlPHZvaWQ+O1xuXG5cdC8qKlxuXHQgKiBGaXJlZCBhbnl0aW1lIGEgcGFnZSByZWNlaXZlcyBmb2N1cyAoaW5jbHVkaW5nIG9uIHRocmVhZCBzd2l0Y2gpXG5cdCAqL1xuXHRmb2N1cz8oKTogUHJvbWlzYWJsZTx2b2lkPjtcblxuXHQvKipcblx0ICogRmlyZWQgd2hlbiBhIHByZXZpb3VzbHkgZXhpc3RpbmcgcGFnZSBpcyByZXN0b3JlZCBmcm9tIGhpc3RvcnkgKGUuZy4sIHZpYSBwb3ApXG5cdCAqL1xuXHRyZXN0b3JlPygpOiBQcm9taXNhYmxlPHZvaWQ+O1xufVxuXG50eXBlIFBhZ2VFdmVudElkID0ga2V5b2YgUGFnZUV2ZW50Q29uZmlnO1xuXG5leHBvcnQgY2xhc3MgUGFnZTxcblx0aF9wcm9wcyBleHRlbmRzIERpY3Q8dW5rbm93bj49RGljdDx1bmtub3duPixcblx0ZGNfY3JlYXRvciBleHRlbmRzIFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvcjxoX3Byb3BzPj1QYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3I8aF9wcm9wcz4sXG5cdHljX2NvbXBvbmVudCBleHRlbmRzIEluc3RhbmNlVHlwZTxkY19jcmVhdG9yPj1JbnN0YW5jZVR5cGU8ZGNfY3JlYXRvcj4sXG4+IHtcblx0cHJvdGVjdGVkIF9kY19jcmVhdG9yOiBkY19jcmVhdG9yO1xuXHRwcm90ZWN0ZWQgX3ljX2NvbXBvbmVudDogeWNfY29tcG9uZW50O1xuXHRwcm90ZWN0ZWQgX2hfcHJvcHM6IGhfcHJvcHM7XG5cdHByb3RlY3RlZCBfaF9jb250ZXh0OiBQbGFpbk9iamVjdDtcblx0cHJvdGVjdGVkIF9kbV9wYWdlOiBIVE1MRWxlbWVudDtcblxuXHRwcm90ZWN0ZWQgX3NpX3BhZ2U6IHN0cmluZztcblx0cHJvdGVjdGVkIF9oX2V2ZW50czogUGFydGlhbDxSZWNvcmQ8UGFnZUV2ZW50SWQsIEFycmF5PCguLi5hX2FyZ3M6IGFueVtdKSA9PiBQcm9taXNhYmxlPHZvaWQ+Pj4+ID0ge307XG5cblx0cHJvdGVjdGVkIF9zcl9wYXRoOiBzdHJpbmc7XG5cdHByb3RlY3RlZCBfc3hfcGF0dGVybjogc3RyaW5nO1xuXG5cdGNvbnN0cnVjdG9yKGdjX3BhZ2U6IFBhZ2VDb25maWc8aF9wcm9wcywgZGNfY3JlYXRvcj4sIHByb3RlY3RlZCBfa3RfcGFyZW50OiBUaHJlYWQpIHtcblx0XHQoe1xuXHRcdFx0Y3JlYXRvcjogdGhpcy5fZGNfY3JlYXRvcixcblx0XHRcdHByb3BzOiB0aGlzLl9oX3Byb3BzPXt9IGFzIGhfcHJvcHMsXG5cdFx0XHRjb250ZXh0OiB0aGlzLl9oX2NvbnRleHQ9e30gYXMgUGxhaW5PYmplY3QsXG5cdFx0XHQvLyBwYXRoOiB0aGlzLl9zcl9wYXRoPScnLFxuXHRcdFx0Ly8gcGF0dGVybjogdGhpcy5fc3hfcGF0dGVybj0nJyxcblx0XHR9ID0gZ2NfcGFnZSBhcyBSZXF1aXJlZDx0eXBlb2YgZ2NfcGFnZT4pO1xuXG5cdFx0Ly8gc2V0IHVuaXF1ZSBwYWdlIGlkXG5cdFx0dGhpcy5fc2lfcGFnZSA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG5cblx0XHQvLyBjcmVhdGUgYnVmZmVyIGVsZW1lbnRcblx0XHRjb25zdCBkbV9idWZmZXIgPSBkZCgnZGl2Jyk7XG5cblx0XHRjb25zdCBobV9jb250ZXh0ID0gbmV3IE1hcChvZGUoe1xuXHRcdFx0Li4udGhpcy5faF9jb250ZXh0LFxuXHRcdFx0cGFnZTogdGhpcyxcblx0XHR9KSk7XG5cblx0XHQvLyBzcGF3biBjb21wb25lbnRcblx0XHR0aGlzLl95Y19jb21wb25lbnQgPSBuZXcgdGhpcy5fZGNfY3JlYXRvcih7XG5cdFx0XHR0YXJnZXQ6IGRtX2J1ZmZlcixcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdC4uLnRoaXMuX2hfcHJvcHMsXG5cdFx0XHRcdGtfcGFnZTogdGhpcyxcblx0XHRcdH0sXG5cdFx0XHRjb250ZXh0OiBobV9jb250ZXh0LFxuXHRcdH0pIGFzIHljX2NvbXBvbmVudDtcblxuXHRcdC8vIGJpbmQgZXZlbnRzXG5cdFx0aWYoZ2NfcGFnZS5ldmVudHMpIHtcblx0XHRcdGZvcihjb25zdCBbc2lfZXZlbnQsIGZfbGlzdGVuZXJdIG9mIG9kZShnY19wYWdlLmV2ZW50cykpIHtcblx0XHRcdFx0dGhpcy5feWNfY29tcG9uZW50LiRvbihzaV9ldmVudCwgZl9saXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gZmV0Y2ggZG9tXG5cdFx0Y29uc3QgZG1fc3RhdGUgPSBkbV9idWZmZXIuZmlyc3RFbGVtZW50Q2hpbGQgYXMgbnVsbCB8IEhUTUxFbGVtZW50O1xuXHRcdGlmKCFkbV9zdGF0ZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBObyBET00gZWxlbWVudCB3YXMgY3JlYXRlZCBkdXJpbmcgcGFnZSBjb21wb25lbnQgc3Bhd25pbmcgdXNpbmc6ICR7SlNPTi5zdHJpbmdpZnkoZ2NfcGFnZSl9YCk7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IGZpZWxkXG5cdFx0dGhpcy5fZG1fcGFnZSA9IGRtX3N0YXRlO1xuXHR9XG5cblx0Z2V0IGlkKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpX3BhZ2U7XG5cdH1cblxuXHRnZXQgaW5kZXgoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuaGlzdG9yeS5sZW5ndGg7XG5cdH1cblxuXHRnZXQgdGhyZWFkKCk6IFRocmVhZCB7XG5cdFx0cmV0dXJuIHRoaXMuX2t0X3BhcmVudDtcblx0fVxuXG5cdGdldCBjcmVhdG9yKCk6IGRjX2NyZWF0b3Ige1xuXHRcdHJldHVybiB0aGlzLl9kY19jcmVhdG9yO1xuXHR9XG5cblx0Z2V0IGNvbXBvbmVudCgpOiB5Y19jb21wb25lbnQge1xuXHRcdHJldHVybiB0aGlzLl95Y19jb21wb25lbnQ7XG5cdH1cblxuXHRnZXQgcHJvcHMoKTogaF9wcm9wcyB7XG5cdFx0cmV0dXJuIHRoaXMuX2hfcHJvcHM7XG5cdH1cblxuXHRnZXQgZG9tKCk6IEhUTUxFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fZG1fcGFnZTtcblx0fVxuXG5cdGVxdWl2YWxlbnQod19vdGhlcjogUGFnZSB8IFBhZ2VDb25maWcpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gd19vdGhlci5jcmVhdG9yID09PSB0aGlzLmNyZWF0b3Jcblx0XHRcdCYmICFvYmplY3RzX21pZ2h0X2RpZmZlcih3X290aGVyLnByb3BzIHx8IHt9LCB0aGlzLnByb3BzKTtcblx0fVxuXG5cdHBlYWsoKTogUGFnZSB7XG5cdFx0cmV0dXJuIHRoaXMuX2t0X3BhcmVudC5wZWFrKCk7XG5cdH1cblxuXHRwdXNoKGdjX3BhZ2U6IFBhZ2VDb25maWcpOiBQYWdlIHtcblx0XHRyZXR1cm4gdGhpcy5fa3RfcGFyZW50LnB1c2goZ2NfcGFnZSwgdGhpcyk7XG5cdH1cblxuXHRwb3AoZ2NfcG9wPzogUG9wQ29uZmlnKTogUGFnZSB7XG5cdFx0cmV0dXJuIHRoaXMuX2t0X3BhcmVudC5wb3AoZ2NfcG9wIHx8IHt9LCB0aGlzKTtcblx0fVxuXG5cdGp1bXAoZ2NfcGFnZTogUGFnZUNvbmZpZywgZ2NfanVtcD86IEp1bXBDb25maWcpOiBQYWdlIHtcblx0XHRyZXR1cm4gdGhpcy5fa3RfcGFyZW50Lmp1bXAoZ2NfcGFnZSwgZ2NfanVtcCB8fCB7fSwgdGhpcyk7XG5cdH1cblxuXHRvbihoX2V2ZW50czogUGFnZUV2ZW50Q29uZmlnKTogdm9pZCB7XG5cdFx0Zm9yKGNvbnN0IFtzaV9ldmVudCwgZl9saXN0ZW5lcl0gb2Ygb2RlKGhfZXZlbnRzKSkge1xuXHRcdFx0aWYoZl9saXN0ZW5lcikge1xuXHRcdFx0XHRjb25zdCBhX2xpc3RlbmVycyA9IHRoaXMuX2hfZXZlbnRzW3NpX2V2ZW50XSA9IHRoaXMuX2hfZXZlbnRzW3NpX2V2ZW50XSB8fCBbXTtcblx0XHRcdFx0YV9saXN0ZW5lcnMucHVzaChmX2xpc3RlbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRhc3luYyBmaXJlKHNpX2V2ZW50OiBQYWdlRXZlbnRJZCwgYV9hcmdzPzogYW55W10pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBhX2xpc3RlbmVycyA9IHRoaXMuX2hfZXZlbnRzW3NpX2V2ZW50XTtcblxuXHRcdGlmKGFfbGlzdGVuZXJzKSB7XG5cdFx0XHRhd2FpdCBQcm9taXNlLmFsbChhX2xpc3RlbmVycy5tYXAoZiA9PiBmKC4uLmFfYXJncyB8fCBbXSBhcyBjb25zdCkpKTtcblx0XHR9XG5cdH1cblxuXHRkZXN0cm95KCk6IHZvaWQge1xuXHRcdHRoaXMuX3ljX2NvbXBvbmVudC4kZGVzdHJveSgpO1xuXHR9XG5cblx0cmVzZXQoKTogdm9pZCB7XG5cdFx0dGhpcy5fa3RfcGFyZW50LnJlc2V0KCk7XG5cdH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yIH0gZnJvbSAnIy9tZXRhL3N2ZWx0ZSc7XG5pbXBvcnQgeyBEaWN0LCBGX05PT1AgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5pbXBvcnQgeyBkZCB9IGZyb20gJyMvdXRpbC9kb20nO1xuaW1wb3J0IHR5cGUge1RocmVhZElkfSBmcm9tICcuLi9kZWYnO1xuaW1wb3J0IHsgTmF2aWdhdG9yLCBzZXRfemluZGV4X3JlbGF0aXZlbHkgfSBmcm9tICcuL25hdmlnYXRvcic7XG5pbXBvcnQge1BhZ2UsIFBhZ2VDb25maWd9IGZyb20gJy4vcGFnZSc7XG5cblxuZXhwb3J0IGludGVyZmFjZSBSZXNldENvbmZpZyB7XG5cdGtlZXBUb3A/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBvcENvbmZpZyB7XG5cdGJ5cGFzc0FuaW1hdGlvbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSnVtcENvbmZpZyB7XG5cdGZvcmNlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIFRocmVhZCB7XG5cdHByb3RlY3RlZCBfZG1fdGhyZWFkOiBIVE1MRGl2RWxlbWVudDtcblxuXHRwcm90ZWN0ZWQgX2FfaGlzdG9yeTogUGFnZVtdID0gW107XG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIF9zaV90aHJlYWQ6IFRocmVhZElkLCBwcm90ZWN0ZWQgX2djX2RlZmF1bHQ6IFBhZ2VDb25maWcsIHByb3RlY3RlZCBfa19uYXZpZ2F0b3I6IE5hdmlnYXRvcikge1xuXHRcdHRoaXMuX2RtX3RocmVhZCA9IGRkKCdkaXYnLCB7XG5cdFx0XHQnY2xhc3MnOiAndGhyZWFkJyxcblx0XHRcdCdkYXRhLXRocmVhZC1pZCc6IHRoaXMuX3NpX3RocmVhZCxcblx0XHRcdCdzdHlsZSc6ICd6LWluZGV4OiAxMDA7Jyxcblx0XHR9KTtcblx0fVxuXG5cdGdldCBpZCgpOiBUaHJlYWRJZCB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpX3RocmVhZDtcblx0fVxuXG5cdGdldCBkZWZhdWx0KCk6IFBhZ2VDb25maWcge1xuXHRcdHJldHVybiB0aGlzLl9nY19kZWZhdWx0O1xuXHR9XG5cblx0Z2V0IGhpc3RvcnkoKTogUGFnZVtdIHtcblx0XHRyZXR1cm4gdGhpcy5fYV9oaXN0b3J5O1xuXHR9XG5cblx0Z2V0IHBhZ2UoKTogUGFnZSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FfaGlzdG9yeVswXTtcblx0fVxuXG5cdGdldCBkb20oKTogSFRNTEVsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl9kbV90aHJlYWQ7XG5cdH1cblxuXHQvLyBwbGFjZSBwYWdlXG5cdHByb3RlY3RlZCBfcGxhY2UoZ2NfcGFnZTogUGFnZUNvbmZpZyk6IFBhZ2Uge1xuXHRcdC8vIGNyZWF0ZSBuZXcgcGFnZVxuXHRcdGNvbnN0IGtwX25ldyA9IG5ldyBQYWdlKHtcblx0XHRcdC4uLmdjX3BhZ2UsXG5cdFx0XHRjb250ZXh0OiB7XG5cdFx0XHRcdC4uLnRoaXMuX2tfbmF2aWdhdG9yLmNvbnRleHQsXG5cdFx0XHRcdC4uLmdjX3BhZ2UuY29udGV4dCxcblx0XHRcdH0sXG5cdFx0fSwgdGhpcyk7XG5cblx0XHQvLyBhcHBlbmQgdG8gZG9tXG5cdFx0dGhpcy5fZG1fdGhyZWFkLmFwcGVuZENoaWxkKGtwX25ldy5kb20pO1xuXG5cdFx0Ly8gcHVzaCBzdGF0ZSB0byBmcm9udCBvZiBzdGFja1xuXHRcdHRoaXMuX2FfaGlzdG9yeS51bnNoaWZ0KGtwX25ldyk7XG5cblx0XHQvLyByZXR1cm4gbmV3IHBhZ2Vcblx0XHRyZXR1cm4ga3BfbmV3O1xuXHR9XG5cblxuXHRyZXNldChnY19wYWdlOiBQYWdlQ29uZmlnPXRoaXMuZGVmYXVsdCwgZ2NfcmVzZXQ/OiBSZXNldENvbmZpZyk6IFBhZ2Uge1xuXHRcdC8vIFxuXHRcdGNvbnN0IHtcblx0XHRcdGtlZXBUb3A6IGJfa2VlcF90b3AsXG5cdFx0fSA9IGdjX3Jlc2V0IHx8IHt9O1xuXG5cdFx0Ly8gcmVmIGhpc3Rvcnlcblx0XHRjb25zdCBhX2hpc3RvcnkgPSB0aGlzLl9hX2hpc3Rvcnk7XG5cblx0XHQvLyAvLyBrZWVwIHRvcCBpcyBlbmFibGVkOyBncmFiIHNyYyBzdHlsZVxuXHRcdC8vIGNvbnN0IGRfc3R5bGUgPSBiX2tlZXBfdG9wPyBhX2hpc3RvcnlbMF0uZG9tLnN0eWxlOiBudWxsO1xuXG5cdFx0Ly8gZHJvcCBhbGwgc3RhbGUgc3RhdGVzIGluIGhpc3Rvcnlcblx0XHRmb3IobGV0IGlfc3RhdGU9Yl9rZWVwX3RvcD8gMTogMDsgaV9zdGF0ZTxhX2hpc3RvcnkubGVuZ3RoOyBpX3N0YXRlKyspIHtcblx0XHRcdGFfaGlzdG9yeVtpX3N0YXRlXS5jb21wb25lbnQuJGRlc3Ryb3koKTtcblx0XHR9XG5cblx0XHQvLyByZXNldCBoaXN0b3J5XG5cdFx0YV9oaXN0b3J5Lmxlbmd0aCA9IDA7XG5cblx0XHQvLyBwbGFjZSBuZXcgcGFnZVxuXHRcdGNvbnN0IGtwX25ldyA9IHRoaXMuX3BsYWNlKGdjX3BhZ2UpO1xuXG5cdFx0Ly8gZmlyZSBjaGFuZ2Ugb24gbmV3IHBhZ2Vcblx0XHR2b2lkIHRoaXMuX2tfbmF2aWdhdG9yLmFmdGVyX3Jlc2V0KHRoaXMsIGtwX25ldywgZ2NfcmVzZXQgfHwge30pO1xuXG5cdFx0Ly8gLy8ga2VlcCB0b3AgaXMgZW5hYmxlZFxuXHRcdC8vIGlmKGRfc3R5bGUpIHtcblx0XHQvLyBcdC8vIHNldCBuZXcgc2NyZWVuIGJlbG93XG5cdFx0Ly8gXHRrc19uZXcuZG9tLnN0eWxlLnpJbmRleCA9ICgoK2Rfc3R5bGUuekluZGV4KSsxKSsnJztcblx0XHQvLyB9XG5cblx0XHRyZXR1cm4ga3BfbmV3O1xuXHR9XG5cblx0cGVhaygpOiBQYWdlIHwgdW5kZWZpbmVkIHtcblx0XHRyZXR1cm4gdGhpcy5fYV9oaXN0b3J5WzFdO1xuXHR9XG5cblx0cHVzaChnY19wYWdlOiBQYWdlQ29uZmlnLCBrcF9zcmM6IFBhZ2UpOiBQYWdlIHtcblx0XHQvLyBjYWxsZXIgaXMgcHJlc2VudCBidXQgaXQgaXMgbm90IHRoZSBhY3RpdmUgcGFnZVxuXHRcdGlmKGtwX3NyYyAhPT0gdGhpcy5wYWdlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZXZlbnRlZCBpbmFjdGl2ZSBwYWdlIGZyb20gcHVzaGluZyBuZXcgc2NyZWVuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IGFwcHJvdmFsIGZyb20gcGFyZW50XG5cdFx0aWYoIXRoaXMuX2tfbmF2aWdhdG9yLmJlZm9yZV9wdXNoKGdjX3BhZ2UsIGtwX3NyYywgdGhpcykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUHJldmVudGVkIGluYWN0aXZlIHRocmVhZCBmcm9tIHB1c2hpbmcgbmV3IHNjcmVlbicpO1xuXHRcdH1cblxuXHRcdC8vIHBsYWNlIHBhZ2Vcblx0XHRjb25zdCBrcF9uZXcgPSB0aGlzLl9wbGFjZShnY19wYWdlKTtcblxuXHRcdC8vIGNhbGwgaG9va3Mgb24gcGFyZW50XG5cdFx0dm9pZCB0aGlzLl9rX25hdmlnYXRvci5hZnRlcl9wdXNoKHRoaXMsIGtwX3NyYywga3BfbmV3KTtcblxuXHRcdC8vIHJldHVybiBuZXcgcGFnZVxuXHRcdHJldHVybiBrcF9uZXc7XG5cdH1cblxuXHRwb3AoZ2NfcG9wOiBQb3BDb25maWcsIGtwX3NyYzogUGFnZSk6IFBhZ2Uge1xuXHRcdC8vIGNhbGxlciBpcyBwcmVzZW50IGJ1dCBpdCBpcyBub3QgdGhlIGFjdGl2ZSBwYWdlXG5cdFx0aWYoa3Bfc3JjICE9PSB0aGlzLnBhZ2UpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUHJldmVudGVkIGluYWN0aXZlIHBhZ2UgZnJvbSBwb3BwaW5nIGFjdGl2ZSBzY3JlZW4nKTtcblx0XHR9XG5cblx0XHQvLyB0b28gc2hvcnRcblx0XHRpZih0aGlzLl9hX2hpc3RvcnkubGVuZ3RoIDwgMikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcG9wIGVtcHR5IGhpc3RvcnlgKTtcblx0XHR9XG5cblx0XHQvLyBnZXQgYXBwcm92YWwgZnJvbSBwYXJlbnRcblx0XHRpZighdGhpcy5fa19uYXZpZ2F0b3IuYmVmb3JlX3BvcChnY19wb3AsIHRoaXMuX2FfaGlzdG9yeVsxXSwga3Bfc3JjLCB0aGlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcmV2ZW50ZWQgaW5hY3RpdmUgdGhyZWFkIGZyb20gcG9wcGluZyBhY3RpdmUgc2NyZWVuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gc2hpZnQgaGlzdG9yeVxuXHRcdHRoaXMuX2FfaGlzdG9yeS5zaGlmdCgpO1xuXG5cdFx0Ly8gYWNxdWlyZSBkZXN0aW5hdGlvbiBwYWdlXG5cdFx0Y29uc3Qga3BfZHN0ID0gdGhpcy5wYWdlO1xuXG5cdFx0Ly8gY2FsbCBob29rcyBvbiBwYXJlbnRcblx0XHR2b2lkIHRoaXMuX2tfbmF2aWdhdG9yLmFmdGVyX3BvcCh0aGlzLCBrcF9zcmMsIGtwX2RzdCwgZ2NfcG9wKTtcblxuXHRcdC8vIHJldHVybiBkc3QgcGFnZVxuXHRcdHJldHVybiBrcF9kc3Q7XG5cdH1cblxuXHRqdW1wKGdjX3BhZ2U6IFBhZ2VDb25maWcsIGdjX2p1bXA6IEp1bXBDb25maWcsIGtwX3NyYzogUGFnZSk6IFBhZ2Uge1xuXHRcdC8vIGNhbGxlciBpcyBwcmVzZW50IGJ1dCBpdCBpcyBub3QgdGhlIGFjdGl2ZSBwYWdlXG5cdFx0aWYoa3Bfc3JjICE9PSB0aGlzLnBhZ2UpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUHJldmVudGVkIGluYWN0aXZlIHBhZ2UgZnJvbSBqdW1waW5nIHRvIHNjcmVlbicpO1xuXHRcdH1cblxuXHRcdC8vIGdldCBhcHByb3ZhbCBmcm9tIHBhcmVudFxuXHRcdGlmKCF0aGlzLl9rX25hdmlnYXRvci5iZWZvcmVfanVtcChnY19qdW1wLCBnY19wYWdlLCBrcF9zcmMsIHRoaXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZXZlbnRlZCBpbmFjdGl2ZSB0aHJlYWQgZnJvbSBqdW1waW5nIHRvIHNjcmVlbicpO1xuXHRcdH1cblxuXHRcdC8vIG5vdCBiZWluZyBmb3JjZWQgYW5kIHRoZSBwcmV2aW91cyBpdGVtIGluIGhpc3RvcnkgbWF0Y2hlcyB0aGUgdGFyZ2V0XG5cdFx0Y29uc3Qga3BfcHJldiA9IHRoaXMuX2FfaGlzdG9yeVsxXSBhcyBQYWdlIHwgdW5kZWZpbmVkO1xuXHRcdGlmKCFnY19qdW1wLmZvcmNlICYmIGtwX3ByZXY/LmVxdWl2YWxlbnQoZ2NfcGFnZSkpIHtcblx0XHRcdC8vIGRlZmVyIHRvIHBvcCBvcGVyYXRpb25cblx0XHRcdHJldHVybiB0aGlzLnBvcCh7fSwga3Bfc3JjKTtcblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgbmV3IHBhZ2Vcblx0XHRjb25zdCBrcF9kc3QgPSBuZXcgUGFnZShnY19wYWdlLCB0aGlzKTtcblxuXHRcdC8vIGRlc3Ryb3kgYWxsIGNvbXBvbmVudHMgZnVydGhlciBiYWNrIGluIHRoZSBzdGFja1xuXHRcdHRoaXMucmVzZXQoKTtcblxuXHRcdC8vIG1vdmUgZGVhZFxuXHRcdHNldF96aW5kZXhfcmVsYXRpdmVseShrcF9kc3QuZG9tLCBrcF9zcmMuZG9tLCArMSk7XG5cblx0XHQvLyB3YWl0IGZvciBjYWxsIGhvb2tzIHRvIHJlc29sdmVcblx0XHR2b2lkIHRoaXMuX2tfbmF2aWdhdG9yLmFmdGVyX2p1bXAodGhpcywga3Bfc3JjLCBrcF9kc3QsIGdjX2p1bXApLnRoZW4oKCkgPT4ge1xuXHRcdFx0Ly8gYXR0ZW1wdCB0byBkZXN0cm95IHNyYyBwYWdlXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRrcF9zcmMuZGVzdHJveSgpO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2goZV9kZXN0cm95KSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGRlc3Ryb3kgc3RhbGUgY29tcG9uZW50IGJlbG9uZ2luZyB0byBwYWdlOiAke2twX3NyYy5jcmVhdG9yLm5hbWUrJyd9YCk7XG5cblx0XHRcdFx0Ly8gYXR0ZW1wdCB0byBmb3JjaWJseSByZW1vdmUgdGhlIGRvbVxuXHRcdFx0XHRrcF9zcmMuZG9tLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gcmV0dXJuIG5ldyBwYWdlXG5cdFx0cmV0dXJuIGtwX2RzdDtcblx0fVxuXG5cdGhpZGUoKTogdm9pZCB7XG5cdFx0dGhpcy5fZG1fdGhyZWFkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdH1cblxuXHRzaG93KCk6IHZvaWQge1xuXHRcdHRoaXMuX2RtX3RocmVhZC5zdHlsZS5kaXNwbGF5ID0gJ2luaXRpYWwnO1xuXHR9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFBsYWluT2JqZWN0IH0gZnJvbSAnIy9tZXRhL2JlbHQnO1xuaW1wb3J0IHsgRGljdCwgb2JqZWN0c19taWdodF9kaWZmZXIsIFByb21pc2FibGUgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5pbXBvcnQgeyBkZCB9IGZyb20gJyMvdXRpbC9kb20nO1xuaW1wb3J0IHR5cGUgeyBNZXJnZSB9IGZyb20gJ3RzLXRvb2xiZWx0L291dC9PYmplY3QvTWVyZ2UnO1xuaW1wb3J0IHsgVGhyZWFkSWQgfSBmcm9tICcuLi9kZWYnO1xuaW1wb3J0IHsgUGFnZSwgUGFnZUNvbmZpZyB9IGZyb20gJy4vcGFnZSc7XG5pbXBvcnQgeyBKdW1wQ29uZmlnLCBQb3BDb25maWcsIFJlc2V0Q29uZmlnLCBUaHJlYWQgfSBmcm9tICcuL3RocmVhZCc7XG5cblxuaW50ZXJmYWNlIEhvb2tzIHtcblx0YmVmb3JlX2NoYW5nZT8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIHNfdHJhbnNpdGlvbjogc3RyaW5nLCBoX2V4dHJhPzogRGljdCk6IHZvaWQgfCBib29sZWFuO1xuXG5cdGJlZm9yZV9wdXNoPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwgZ2NfZHN0OiBQYWdlQ29uZmlnKTogdm9pZCB8IGJvb2xlYW47XG5cdGJlZm9yZV9wb3A/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBrcF9kc3Q6IFBhZ2UsIGdjX3BvcDogUG9wQ29uZmlnKTogdm9pZCB8IGJvb2xlYW47XG5cdGJlZm9yZV9qdW1wPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwgZ2NfcGFnZTogUGFnZUNvbmZpZywgZ2NfanVtcDogSnVtcENvbmZpZyk6IHZvaWQgfCBib29sZWFuO1xuXG5cdGFmdGVyX2NoYW5nZT8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UgfCBudWxsLCBrcF9kc3Q6IFBhZ2UsIHNfdHJhbnNpdGlvbjogc3RyaW5nLCBoX2V4dHJhPzogRGljdCk6IFByb21pc2FibGU8dm9pZD47XG5cblx0YWZ0ZXJfcHVzaD8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGtwX2RzdDogUGFnZSk6IFByb21pc2FibGU8dm9pZCB8IERpY3Q+O1xuXHRhZnRlcl9wb3A/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBrcF9kc3Q6IFBhZ2UsIGdjX3BvcDogUG9wQ29uZmlnKTogUHJvbWlzYWJsZTx2b2lkIHwgRGljdD47XG5cdGFmdGVyX2p1bXA/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBrcF9kc3Q6IFBhZ2UsIGdjX2p1bXA6IEp1bXBDb25maWcpOiBQcm9taXNhYmxlPHZvaWQgfCBEaWN0Pjtcblx0YWZ0ZXJfcmVzZXQ/KGt0X2NvbnRleHQ6IFRocmVhZCwga3BfZHN0OiBQYWdlLCBnY19qdW1wOiBSZXNldENvbmZpZyk6IFByb21pc2FibGU8dm9pZCB8IERpY3Q+O1xuXG5cdGJlZm9yZV9zd2l0Y2g/KGt0X3NyYzogVGhyZWFkLCBzaV90aHJlYWRfZHN0OiBUaHJlYWRJZCk6IFByb21pc2FibGU8dm9pZD47XG5cdGFmdGVyX3N3aXRjaD8oa3Rfc3JjOiBUaHJlYWQsIGt0X2RzdDogVGhyZWFkKTogUHJvbWlzYWJsZTx2b2lkPjtcbn1cblxuXG50eXBlIFRocmVhZFNwYXduZXIgPSAoaF9wYXJhbXM6IFBsYWluT2JqZWN0LCBoX2NvbnRleHQ/OiBQbGFpbk9iamVjdCkgPT4gUGFnZUNvbmZpZztcblxudHlwZSBUaHJlYWRzQ29uZmlnID0gTWVyZ2U8e1xuXHRkZWZhdWx0OiBUaHJlYWRTcGF3bmVyO1xufSwgUGFydGlhbDxSZWNvcmQ8VGhyZWFkSWQsIFRocmVhZFNwYXduZXI+Pj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdG9yQ29uZmlnIHtcblx0Y29udGFpbmVyOiBIVE1MRWxlbWVudDtcblx0aG9va3M6IEhvb2tzO1xuXHR0aHJlYWRzOiBUaHJlYWRzQ29uZmlnO1xuXG5cdGNvbnRleHQ6IFBsYWluT2JqZWN0IHwgbmV2ZXI7XG5cblx0Ly8gc2luZ2xlVGhyZWFkTW9kZT86IGJvb2xlYW47XG5cblx0Ly8gcm91dGVyOiBSb3V0ZXI7XG5cdC8vIHRocmVhZHM6IE1lcmdlPHtcblx0Ly8gXHRkZWZhdWx0OiBUaHJlYWRTcGF3bmVyO1xuXHQvLyB9LCBSZWNvcmQ8VGhyZWFkSWQsIFRocmVhZFNwYXduZXI+Pjtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2V0X3ppbmRleF9yZWxhdGl2ZWx5KGRtX3NyYzogSFRNTEVsZW1lbnQsIGRtX2RzdDogSFRNTEVsZW1lbnQsIG5fb3JkZXI6IG51bWJlcik6IHZvaWQge1xuXHRjb25zdCBpel9zcmMgPSArZG1fc3JjLnN0eWxlLnpJbmRleDtcblx0Y29uc3QgaXpfZHN0ID0gaXpfc3JjICsgbl9vcmRlcjtcblx0ZG1fc3JjLnN0eWxlLnpJbmRleCA9IGl6X3NyYysnJztcblx0ZG1fZHN0LnN0eWxlLnpJbmRleCA9IGl6X2RzdCsnJztcbn1cblxuZXhwb3J0IGNsYXNzIE5hdmlnYXRvciB7XG5cdHByb3RlY3RlZCBfaF90aHJlYWRzOiBQYXJ0aWFsPFJlY29yZDxUaHJlYWRJZCwgVGhyZWFkPj4gPSB7fTtcblx0cHJvdGVjdGVkIF9oX3RocmVhZF9zcGF3bmVyczogVGhyZWFkc0NvbmZpZztcblx0cHJvdGVjdGVkIF9kbV90aHJlYWRzOiBIVE1MRWxlbWVudDtcblx0Ly8gcHJvdGVjdGVkIF9iX21vZGVfc2luZ2xlX3RocmVhZD86IGJvb2xlYW4gPSBmYWxzZTtcblx0Ly8gcHJvdGVjdGVkIF9rX3JvdXRlcjogUjtcblxuXHQvLyBidWZmZXIgZWxlbWVudFxuXHRwcm90ZWN0ZWQgX2RtX2J1ZmZlciA9IGRkKCdkaXYnKTtcblxuXHQvLyBob29rc1xuXHRwcm90ZWN0ZWQgX2dfaG9va3M6IEhvb2tzO1xuXG5cdC8vIGNvbnRleHRzXG5cdHByb3RlY3RlZCBfaF9jb250ZXh0OiBQbGFpbk9iamVjdDtcblxuXHQvLyBjdXJyZW50bHkgYWN0aXZlIHRocmVhZCBpZFxuXHRwcm90ZWN0ZWQgX3NpX3RocmVhZDogVGhyZWFkSWQgPSBUaHJlYWRJZC5ERUZBVUxUO1xuXG5cdC8vIHJ1bm5pbmcgei1pbmRleCBjb3VudGVyIGZvciBuZXcgdGhyZWFkc1xuXHRwcm90ZWN0ZWQgX2NfdGhyZWFkX3ogPSAyMDA7XG5cblxuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX2djX25hdmlnYXRvcjogTmF2aWdhdG9yQ29uZmlnKSB7XG5cdFx0Ly8gdGhyZWFkIGNvbnRhaW5lciBkb21cblx0XHQoe1xuXHRcdFx0Y29udGFpbmVyOiB0aGlzLl9kbV90aHJlYWRzLFxuXHRcdFx0dGhyZWFkczogdGhpcy5faF90aHJlYWRfc3Bhd25lcnMsXG5cdFx0XHRob29rczogdGhpcy5fZ19ob29rcyxcblx0XHRcdGNvbnRleHQ6IHRoaXMuX2hfY29udGV4dD17fSxcblx0XHRcdC8vIHJvdXRlcjogdGhpcy5fa19yb3V0ZXIsXG5cdFx0XHQvLyBzaW5nbGVUaHJlYWRNb2RlOiB0aGlzLl9iX21vZGVfc2luZ2xlX3RocmVhZD1mYWxzZSxcblx0XHR9ID0gX2djX25hdmlnYXRvcik7XG5cblx0XHQvLyBjcmVhdGUgZGVmYXVsdCB0aHJlYWRcblx0XHR0aGlzLl9uZXdfdGhyZWFkKFRocmVhZElkLkRFRkFVTFQpO1xuXHR9XG5cblx0Z2V0IGNvbnRleHQoKTogUGxhaW5PYmplY3Qge1xuXHRcdHJldHVybiB0aGlzLl9oX2NvbnRleHQ7XG5cdH1cblxuXHRwcml2YXRlIF9uZXdfdGhyZWFkKHNpX3RocmVhZDogVGhyZWFkSWQsIGhfcHJvcHM6IERpY3Q8dW5rbm93bj49e30sIGhfY29udGV4dDogUGxhaW5PYmplY3Q9e30pOiBUaHJlYWQge1xuXHRcdC8vIG5vIHN1Y2ggdGhyZWFkIHNwYXduZXJcblx0XHRjb25zdCBmX3NwYXduZXIgPSB0aGlzLl9oX3RocmVhZF9zcGF3bmVyc1tzaV90aHJlYWRdO1xuXHRcdGlmKCFmX3NwYXduZXIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgTmF2aWdhdG9yIGhhcyBubyBzdWNoIHRocmVhZCByZWdpc3RlcmVkOiAnJHtzaV90aHJlYWR9J2ApO1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBuZXcgdGhyZWFkXG5cdFx0Y29uc3Qga3RfbmV3ID0gbmV3IFRocmVhZChzaV90aHJlYWQsIGZfc3Bhd25lcihoX3Byb3BzLCBoX2NvbnRleHQpLCB0aGlzKTtcblxuXHRcdC8vIHNhdmUgdG8gdGhyZWFkc1xuXHRcdHRoaXMuX2hfdGhyZWFkc1tzaV90aHJlYWRdID0ga3RfbmV3O1xuXG5cdFx0Ly8gYXBwZW5kIHRocmVhZCB0byBjb250YWluZXJcblx0XHR0aGlzLl9kbV90aHJlYWRzLmFwcGVuZENoaWxkKGt0X25ldy5kb20pO1xuXG5cdFx0Ly8gY3JlYXRlIG5ldyBkZWZhdWx0IHBhZ2UgYW5kIG1lcmdlIHByb3BzXG5cdFx0a3RfbmV3LnJlc2V0KHtcblx0XHRcdC4uLmt0X25ldy5kZWZhdWx0LFxuXHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0Li4ua3RfbmV3LmRlZmF1bHQucHJvcHMsXG5cdFx0XHRcdC4uLmhfcHJvcHMsXG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0Ly8gcmV0dXJuIG5ldyB0aHJlYWRcblx0XHRyZXR1cm4ga3RfbmV3O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnRseSBhY3RpdmUgdGhyZWFkLlxuXHQgKi9cblx0Z2V0IGFjdGl2ZVRocmVhZCgpOiBUaHJlYWQge1xuXHRcdHJldHVybiB0aGlzLl9oX3RocmVhZHNbdGhpcy5fc2lfdGhyZWFkXSE7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY3VycmVudGx5IGFjdGl2ZSBwYWdlLlxuXHQgKi9cblx0Z2V0IGFjdGl2ZVBhZ2UoKTogUGFnZSB7XG5cdFx0cmV0dXJuIHRoaXMuYWN0aXZlVGhyZWFkLnBhZ2U7XG5cdH1cblxuXHQvLyAvKipcblx0Ly8gICogUHVzaGVzIGEgbmV3IHBhZ2UgdG8gdGhlIGN1cnJlbnRseSBhY3RpdmUgdGhyZWFkLlxuXHQvLyAgKi9cblx0Ly8gcHVzaChnY19wYWdlOiBQYWdlQ29uZmlnKTogUGFnZSB7XG5cdC8vIFx0Ly8gcmVmIGN1cnJlbnQgKHNvb24gdG8gYmUgb2xkKSBwYWdlXG5cdC8vIFx0Y29uc3Qga3Bfb2xkID0gdGhpcy5hY3RpdmVQYWdlO1xuXG5cdC8vIFx0Ly8gY3JlYXRlIG5ldyBwYWdlXG5cdC8vIFx0Y29uc3Qga3BfbmV3ID0gdGhpcy5hY3RpdmVUaHJlYWQucHVzaChnY19wYWdlKTtcblxuXHQvLyBcdC8vIC8vIGNhbGwgaG9va3Ncblx0Ly8gXHQvLyB0aGlzLl9mX3B1c2goa3Bfb2xkLCBrcF9uZXcpO1xuXHQvLyBcdC8vIHRoaXMuX2Fycml2ZShrcF9vbGQsICcnLCAncHVzaCcpO1xuXG5cdC8vIFx0Ly8gcmV0dXJuIG5ldyBwYWdlXG5cdC8vIFx0cmV0dXJuIGtwX25ldztcblx0Ly8gfVxuXG5cdC8vIC8qKlxuXHQvLyAgKiBQb3BzIHRoZSBhY3RpdmUgcGFnZSBmcm9tIHRoZSBzdGFjay5cblx0Ly8gICovXG5cdC8vIHBvcChnY19wb3A/OiBQb3BDb25maWcpOiBQYWdlIHtcblx0Ly8gXHQvLyBkZXN0cnVjdHVyZSBvcHRpb25zXG5cdC8vIFx0Y29uc3Qge1xuXHQvLyBcdFx0YnlwYXNzQW5pbWF0aW9uOiBiX2J5cGFzc19hbmltYXRpb249ZmFsc2UsXG5cdC8vIFx0fSA9IGdjX3BvcCB8fCB7fTtcblxuXHQvLyBcdC8vIHRvbyBzaG9ydFxuXHQvLyBcdGlmKHRoaXMuYWN0aXZlVGhyZWFkLmhpc3RvcnkubGVuZ3RoIDwgMikge1xuXHQvLyBcdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcG9wIGVtcHR5IGhpc3RvcnlgKTtcblx0Ly8gXHR9XG5cblx0Ly8gXHQvLyBwb3AgZnJvbSBmcm9udCBvZiBzdGFja1xuXHQvLyBcdGNvbnN0IGtwX3NyYyA9IHRoaXMuYWN0aXZlVGhyZWFkLnBvcCgpO1xuXG5cdC8vIFx0Ly8gLy8gZW1wdHkgaGlzdG9yeVxuXHQvLyBcdC8vIGlmKCFrc19zcmMpIHtcblx0Ly8gXHQvLyBcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBvcCBlbXB0eSBoaXN0b3J5YCk7XG5cdC8vIFx0Ly8gfVxuXG5cdC8vIFx0Ly8gLy8gY2FsbCBob29rc1xuXHQvLyBcdC8vIHRoaXMuX2ZfcG9wKGtwX3NyYywgdGhpcy5zdGF0ZSwgYl9ieXBhc3NfYW5pbWF0aW9uKTtcblx0Ly8gXHQvLyB0aGlzLl9hcnJpdmUoa3Bfc3JjLCAnJywgYl9ieXBhc3NfYW5pbWF0aW9uPyAncG9wLmJ5cGFzcyc6ICdwb3AnKS50aGVuKCgpID0+IHtcblx0Ly8gXHQvLyBcdHRyeSB7XG5cdC8vIFx0Ly8gXHRcdGtwX3NyYy5jb21wb25lbnQuJGRlc3Ryb3koKTtcblx0Ly8gXHQvLyBcdH1cblx0Ly8gXHQvLyBcdGNhdGNoKGVfZGVzdHJveSkge1xuXHQvLyBcdC8vIFx0XHRjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZGVzdHJveSBzdGFsZSBjb21wb25lbnQgYmVsb25naW5nIHRvIFN0YXRlOiAke2twX3NyYy5wYXR0ZXJufWApO1xuXHQvLyBcdC8vIFx0fVxuXHQvLyBcdC8vIH0pO1xuXG5cdC8vIFx0Ly8gcmV0dXJuIG9sZCBwYWdlXG5cdC8vIFx0cmV0dXJuIGtwX3NyYztcblx0Ly8gfVxuXG5cblx0YmVmb3JlX3B1c2goZ2NfcGFnZTogUGFnZUNvbmZpZywga3Bfc3JjOiBQYWdlLCBrdF9jaGlsZDogVGhyZWFkKTogYm9vbGVhbiB7XG5cdFx0Ly8gbm90IGFjdGl2ZSB0aHJlYWQ7IGRlbnlcblx0XHRpZih0aGlzLmFjdGl2ZVRocmVhZCAhPT0ga3RfY2hpbGQpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vIGNhbGwgcHJlcHVzaCBob29rc1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9jaGFuZ2U/LihrdF9jaGlsZCwga3Bfc3JjLCAncHVzaCcpKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYoZmFsc2UgPT09IHRoaXMuX2dfaG9va3MuYmVmb3JlX3B1c2g/LihrdF9jaGlsZCwga3Bfc3JjLCBnY19wYWdlKSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Ly8gYXBwcm92ZWRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cblx0YmVmb3JlX3BvcChnY19wb3A6IFBvcENvbmZpZywga3BfZHN0OiBQYWdlLCBrcF9zcmM6IFBhZ2UsIGt0X2NoaWxkOiBUaHJlYWQpOiBib29sZWFuIHtcblx0XHQvLyBub3QgYWN0aXZlIHRocmVhZDsgZGVueVxuXHRcdGlmKHRoaXMuYWN0aXZlVGhyZWFkICE9PSBrdF9jaGlsZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Ly8gY2FsbCBwcmVwdXNoIGhvb2tzXG5cdFx0aWYoZmFsc2UgPT09IHRoaXMuX2dfaG9va3MuYmVmb3JlX2NoYW5nZT8uKGt0X2NoaWxkLCBrcF9zcmMsICdwb3AnKSkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9wb3A/LihrdF9jaGlsZCwga3Bfc3JjLCBrcF9kc3QsIGdjX3BvcCkpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vIGFwcHJvdmVkXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRiZWZvcmVfanVtcChnY19qdW1wOiBKdW1wQ29uZmlnLCBnY19wYWdlOiBQYWdlQ29uZmlnLCBrcF9zcmM6IFBhZ2UsIGt0X2NoaWxkOiBUaHJlYWQpOiBib29sZWFuIHtcblx0XHQvLyBub3QgYWN0aXZlIHRocmVhZDsgZGVueVxuXHRcdGlmKHRoaXMuYWN0aXZlVGhyZWFkICE9PSBrdF9jaGlsZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Ly8gY2FsbCBwcmVqdW1wIGhvb2tzXG5cdFx0aWYoZmFsc2UgPT09IHRoaXMuX2dfaG9va3MuYmVmb3JlX2NoYW5nZT8uKGt0X2NoaWxkLCBrcF9zcmMsICdqdW1wJykpIHJldHVybiBmYWxzZTtcblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfanVtcD8uKGt0X2NoaWxkLCBrcF9zcmMsIGdjX3BhZ2UsIGdjX2p1bXApKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBhcHByb3ZlZFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0YXN5bmMgYmVmb3JlX3N3aXRjaChrdF9zcmM6IFRocmVhZCwgc2lfdGhyZWFkOiBUaHJlYWRJZCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9jaGFuZ2U/LihrdF9zcmMsIGt0X3NyYy5wYWdlLCAnc3dpdGNoJykpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN0b3AgdGhyZWFkIHN3aXRjaCcpO1xuXG5cdFx0YXdhaXQgdGhpcy5fZ19ob29rcy5iZWZvcmVfc3dpdGNoPy4oa3Rfc3JjLCBzaV90aHJlYWQpO1xuXHR9XG5cblx0YXN5bmMgYWZ0ZXJfcHVzaChrdF9jaGlsZDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGtwX2RzdDogUGFnZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGhfZXh0cmEgPSBhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX3B1c2g/LihrdF9jaGlsZCwga3Bfc3JjLCBrcF9kc3QpO1xuXG5cdFx0YXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9jaGFuZ2U/LihrdF9jaGlsZCwga3Bfc3JjLCBrcF9kc3QsICdwdXNoJywgaF9leHRyYSB8fCB7fSk7XG5cdH1cblxuXHRhc3luYyBhZnRlcl9wb3Aoa3RfY2hpbGQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBrcF9kc3Q6IFBhZ2UsIGdjX3BvcDogUG9wQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgaF9leHRyYSA9IGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfcG9wPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0LCBnY19wb3ApO1xuXG5cdFx0YXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9jaGFuZ2U/LihrdF9jaGlsZCwga3Bfc3JjLCBrcF9kc3QsICdwb3AnLCBoX2V4dHJhIHx8IHt9KTtcblx0fVxuXG5cdGFzeW5jIGFmdGVyX2p1bXAoa3RfY2hpbGQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBrcF9kc3Q6IFBhZ2UsIGdjX2p1bXA6IEp1bXBDb25maWcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBoX2V4dHJhID0gYXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9qdW1wPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0LCBnY19qdW1wKTtcblxuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfY2hhbmdlPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0LCAnanVtcCcsIGhfZXh0cmEgfHwge30pO1xuXHR9XG5cblx0YXN5bmMgYWZ0ZXJfcmVzZXQoa3RfY2hpbGQ6IFRocmVhZCwga3BfZHN0OiBQYWdlLCBnY19yZXNldDogUmVzZXRDb25maWcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBoX2V4dHJhID0gYXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9yZXNldD8uKGt0X2NoaWxkLCBrcF9kc3QsIGdjX3Jlc2V0KTtcblxuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfY2hhbmdlPy4oa3RfY2hpbGQsIG51bGwsIGtwX2RzdCwgJ3Jlc2V0JywgaF9leHRyYSB8fCB7fSk7XG5cdH1cblxuXHRhc3luYyBhZnRlcl9zd2l0Y2goa3Rfc3JjOiBUaHJlYWQsIGt0X2RzdDogVGhyZWFkKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0YXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9zd2l0Y2g/LihrdF9zcmMsIGt0X2RzdCk7XG5cdH1cblxuXHQvKipcblx0ICogQWN0aXZhdGVzIGEgdGhyZWFkIGJ5IHRoZSBnaXZlbiB0aHJlYWQgaWQuXG5cdCAqL1xuXHRhc3luYyBhY3RpdmF0ZVRocmVhZChzaV90aHJlYWQ6IFRocmVhZElkLCBoX3Byb3BzOiBQbGFpbk9iamVjdD17fSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRcdC8vIHJlZiBjdXJyZW50IHRocmVhZFxuXHRcdGNvbnN0IGt0X3NyYyA9IHRoaXMuYWN0aXZlVGhyZWFkO1xuXG5cdFx0Ly8gcmVmIHByZXZpb3VzIHBhZ2Vcblx0XHRjb25zdCBrcF9zcmMgPSB0aGlzLmFjdGl2ZVBhZ2U7XG5cblx0XHQvLyBsb29rdXAgZXhpc3RpbmcgdGhyZWFkXG5cdFx0bGV0IGt0X2RzdCA9IHRoaXMuX2hfdGhyZWFkc1tzaV90aHJlYWRdO1xuXG5cdFx0Ly8gdGhyZWFkIGNoYW5nZVxuXHRcdGlmKHNpX3RocmVhZCAhPT0gdGhpcy5fc2lfdGhyZWFkKSB7XG5cdFx0XHQvLyAvLyBzaW5nbGUgdGhyZWFkIG1vZGU7IGFib3J0XG5cdFx0XHQvLyBpZih0aGlzLl9iX21vZGVfc2luZ2xlX3RocmVhZCkge1xuXHRcdFx0Ly8gXHR0aHJvdyBuZXcgRXJyb3IoYE5hdmlnYXRvciBvcGVyYXRpbmcgaW4gc2luZ2xlIHRocmVhZCBtb2RlIHJlZnVzaW5nIHRvIGFjdGl2YXRlIHRoZWFkICcke3NpX3RocmVhZH0nLmApO1xuXHRcdFx0Ly8gfVxuXG5cdFx0XHQvLyBjYWxsIHByZXN3aXRjaCBob29rc1xuXHRcdFx0YXdhaXQgdGhpcy5iZWZvcmVfc3dpdGNoKGt0X3NyYywgc2lfdGhyZWFkKTtcblxuXHRcdFx0Ly8gcHJldiB0aHJlYWRcblx0XHRcdGNvbnN0IHNpX3RocmVhZF9wcmV2ID0gdGhpcy5fc2lfdGhyZWFkO1xuXG5cdFx0XHQvLyBubyBleGlzdGluZyB0aHJlYWQ7IGNyZWF0ZSBuZXcgb25lXG5cdFx0XHRpZigha3RfZHN0KSB7XG5cdFx0XHRcdGt0X2RzdCA9IHRoaXMuX25ld190aHJlYWQoc2lfdGhyZWFkLCBoX3Byb3BzKTtcblx0XHRcdH1cblx0XHRcdC8vIHByb3BzIGRpZmZlclxuXHRcdFx0ZWxzZSBpZihvYmplY3RzX21pZ2h0X2RpZmZlcihrdF9kc3QuZGVmYXVsdC5wcm9wcyB8fCB7fSwgaF9wcm9wcykpIHtcblx0XHRcdFx0Ly8gY3JlYXRlIG5ldyBwYWdlXG5cdFx0XHRcdGNvbnN0IGtwX2RzdCA9IG5ldyBQYWdlKHtcblx0XHRcdFx0XHQuLi5rdF9kc3QuZGVmYXVsdCxcblx0XHRcdFx0XHRwcm9wczogaF9wcm9wcyxcblx0XHRcdFx0XHRjb250ZXh0OiB0aGlzLl9oX2NvbnRleHQsXG5cdFx0XHRcdH0sIGt0X2RzdCk7XG5cblx0XHRcdFx0Ly8gcmVzZXQgdGhyZWFkIGhpc3Rvcnlcblx0XHRcdFx0a3RfZHN0LnJlc2V0KGtwX2RzdCwge1xuXHRcdFx0XHRcdGtlZXBUb3A6IHRydWUsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIHBsYWNlIGluY29taW5nIHN0YXRlIGJlbG93XG5cdFx0XHRcdHNldF96aW5kZXhfcmVsYXRpdmVseShrcF9zcmMuZG9tLCBrcF9kc3QuZG9tLCAtMSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHVwZGF0ZSB0aHJlYWRcblx0XHRcdHRoaXMuX3NpX3RocmVhZCA9IHNpX3RocmVhZDtcblxuXHRcdFx0Ly8gcGxhY2UgdGhyZWFkIGluIGZyb250XG5cdFx0XHR0aGlzLmFjdGl2ZVRocmVhZC5zaG93KCk7XG5cdFx0XHR0aGlzLmFjdGl2ZVRocmVhZC5kb20uc3R5bGUuekluZGV4ID0gKHRoaXMuX2NfdGhyZWFkX3orKykrJyc7XG5cblx0XHRcdC8vIC8vIGFycml2ZVxuXHRcdFx0Ly8gdGhpcy5fYXJyaXZlKGtwX3NyYywgc2lfdGhyZWFkX3ByZXYsICd0aHJlYWQnKS50aGVuKCgpID0+IHtcblx0XHRcdC8vIFx0Ly8gLy8gaGlkZSBwcmV2aW91cyB0aHJlYWRcblx0XHRcdC8vIFx0Ly8gaWYoa3RfZHN0ICYmIGt0X3NyYyAmJiBrdF9zcmMgIT09IGt0X2RzdCkge1xuXHRcdFx0Ly8gXHQvLyBcdC8vIGRlYnVnZ2VyO1xuXHRcdFx0Ly8gXHQvLyBcdC8vIGt0X3NyYy5oaWRlKCk7XG5cdFx0XHQvLyBcdC8vIH1cblx0XHRcdC8vIH0pO1xuXG5cdFx0XHQvLyBjYWxsIHBvc3Rzd2l0Y2ggaG9va3Ncblx0XHRcdGF3YWl0IHRoaXMuYWZ0ZXJfc3dpdGNoKGt0X3NyYywga3RfZHN0KTtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdC8vIC8vIHNhbWUgdGhyZWFkXG5cdFx0Ly8gZWxzZSB7XG5cdFx0Ly8gXHQvLyB0aHJlYWQgZGVmYXVsdCBpcyBwcmV2aW91cyBpbiBoaXN0b3J5XG5cdFx0Ly8gXHRkZWJ1Z2dlcjtcblx0XHQvLyBcdGNvbnNvbGUuaW5mbyhrX3RocmVhZD8uZGVmYXVsdC5wYXRoKTtcblx0XHQvLyB9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7XG5cdFx0Z2V0QWxsQ29udGV4dHMsXG5cdFx0b25Nb3VudCxcblx0XHR0aWNrLFxuXHR9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IHR5cGUgeyBQbGFpbk9iamVjdCB9IGZyb20gJyMvbWV0YS9iZWx0Jztcblx0aW1wb3J0IHtcblx0XHRvZGUsXG5cdFx0b2Rlcm9tLFxuXHRcdHRpbWVvdXQsXG5cdH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCBPdmVyc2Nyb2xsU3ZlbHRlIGZyb20gJy4vc3lzdGVtL092ZXJzY3JvbGwuc3ZlbHRlJztcblx0aW1wb3J0IFBvcHVwU3ZlbHRlIGZyb20gJy4vc3lzdGVtL1BvcHVwLnN2ZWx0ZSc7XG5cdGltcG9ydCBOYXZTdmVsdGUgZnJvbSAnLi9zeXN0ZW0vTmF2LnN2ZWx0ZSc7XG5cdGltcG9ydCBTZWFyY2hTdmVsdGUgZnJvbSAnLi9zeXN0ZW0vU2VhcmNoLnN2ZWx0ZSc7XG5cdGltcG9ydCBQcm9ncmVzc1N2ZWx0ZSBmcm9tICcuL3N5c3RlbS9Qcm9ncmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgU2lkZU1lbnVTdmVsdGUgZnJvbSAnLi9zeXN0ZW0vU2lkZU1lbnUuc3ZlbHRlJztcblx0aW1wb3J0IFZlbmRvck1lbnVTdmVsdGUgZnJvbSAnLi9zeXN0ZW0vVmVuZG9yTWVudS5zdmVsdGUnO1xuXG5cdGltcG9ydCBCbGFua1N2ZWx0ZSBmcm9tICcjIy9zY3JlZW4vQmxhbmsuc3ZlbHRlJztcblxuXHRpbXBvcnQgdHlwZSB7IFBhZ2UsIFBhZ2VDb25maWcgfSBmcm9tICcjIy9uYXYvcGFnZSc7XG5cdGltcG9ydCB0eXBlIHsgUG9wQ29uZmlnLCBUaHJlYWQgfSBmcm9tICcjIy9uYXYvdGhyZWFkJztcblx0aW1wb3J0IHsgTmF2aWdhdG9yLCBOYXZpZ2F0b3JDb25maWcgfSBmcm9tICcjIy9uYXYvbmF2aWdhdG9yJztcblxuXHRpbXBvcnQgeyBIX1RIUkVBRFMgfSBmcm9tICcjIy9kZWYnO1xuXHRpbXBvcnQgeyB5d19hY2NvdW50LCB5d19hY2NvdW50X3JlZiwgeXdfY2hhaW4sIHl3X2NoYWluX3JlZiwgeXdfbmF2aWdhdG9yLCB5d19uYXZfdmlzaWJsZSwgeXdfbmV0d29yaywgeXdfbmV0d29ya19hY3RpdmUsIHl3X25ldHdvcmtfcmVmLCB5d19wYWdlLCB5d190aHJlYWQgfSBmcm9tICcjIy9tZW0nO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IEFjY291bnRzIH0gZnJvbSAnIy9zdG9yZS9hY2NvdW50cyc7XG5cdGltcG9ydCB7IG9uY2Vfc3RvcmVfdXBkYXRlcyB9IGZyb20gJy4uL3N2ZWx0ZSc7XG5cdGltcG9ydCB7IE5ldHdvcmtzIH0gZnJvbSAnIy9zdG9yZS9uZXR3b3Jrcyc7XG5cdGltcG9ydCB7IFZhdWx0IH0gZnJvbSAnIy9jcnlwdG8vdmF1bHQnO1xuXG5cdGV4cG9ydCBsZXQgcGFnZTogUGFnZUNvbmZpZztcblx0Y29uc3QgZ2NfcGFnZSA9IHBhZ2U7XG5cblx0ZXhwb3J0IGxldCBtb2RlOiAnYXBwJyB8ICdmbG93Jztcblx0Y29uc3QgYl9mbG93ID0gJ2Zsb3cnID09PSBtb2RlO1xuXHRjb25zdCBiX21haW4gPSAnYXBwJyA9PT0gbW9kZTtcblxuXHRsZXQgZG1fdmlld3BvcnQ6IEhUTUxFbGVtZW50O1xuXHRsZXQgZG1fdGhyZWFkczogSFRNTEVsZW1lbnQ7XG5cdGxldCBkbV9jb250ZW50OiBIVE1MRWxlbWVudDtcblx0bGV0IGRtX2V4aXR0aW5nOiBIVE1MRWxlbWVudDtcblxuXHQvLyBnZXQgYWxsIGNvbnRleHRzXG5cdGNvbnN0IGhfY29udGV4dF9hbGwgPSBPYmplY3QuZnJvbUVudHJpZXMoZ2V0QWxsQ29udGV4dHMoKS5lbnRyaWVzKCkpO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIHNsaWRlKGRtX3NsaWRlOiBIVE1MRWxlbWVudCwgYl9pbj1mYWxzZSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdC8vIHNtb290aGVyLCBhbGxvdyBmb3IgcHJldmlvdXMgbW9kcyB0byBtYWtlIGVsZW1lbnQgdmlzaWJsZVxuXHRcdGF3YWl0IHRpbWVvdXQoMCk7XG5cblx0XHQvLyBnbyBhc3luY1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgoZmtfcmVzb2x2ZSkgPT4ge1xuXHRcdFx0Ly8gd2FpdCBmb3IgdHJhbnNpdGlvbiB0byBjb21wbGV0ZVxuXHRcdFx0ZG1fc2xpZGUuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIHRyYW5zaXRpb25fZW5kKGRfZXZlbnQpIHtcblx0XHRcdFx0aWYoJ3RyYW5zZm9ybScgPT09IGRfZXZlbnQucHJvcGVydHlOYW1lKSB7XG5cdFx0XHRcdFx0Ly8gY2hhbmdlIGNsYXNzXG5cdFx0XHRcdFx0ZG1fc2xpZGUuY2xhc3NMaXN0LmFkZCgnc2xpZCcpO1xuXG5cdFx0XHRcdFx0ZmtfcmVzb2x2ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gYXBwbHkgdHJhbnNmb3JtXG5cdFx0XHRkbV9zbGlkZS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke2JfaW4/ICcwcHgnOiAndmFyKC0tYXBwLXdpbmRvdy13aWR0aCknfSlgO1xuXHRcdH0pO1xuXHR9XG5cblx0b25Nb3VudChhc3luYygpID0+IHtcblx0XHQvLyBuYXZpZ2F0b3IgY29uZmlnXG5cdFx0Y29uc3QgZ2NfbmF2aWdhdG9yOiBOYXZpZ2F0b3JDb25maWcgPSB7XG5cdFx0XHQvLyB0aHJlYWRzIGNvbnRhaW5lclxuXHRcdFx0Y29udGFpbmVyOiBkbV90aHJlYWRzLFxuXG5cdFx0XHQvLyBmb3J3YXJkIGFsbCBjb250ZXh0c1xuXHRcdFx0Y29udGV4dDogaF9jb250ZXh0X2FsbCxcblxuXHRcdFx0Ly8gZGVmYXVsdCB0aHJlYWRzIGNvbmZpZ1xuXHRcdFx0dGhyZWFkczoge1xuXHRcdFx0XHRkZWZhdWx0OiAoKSA9PiAoe1xuXHRcdFx0XHRcdGNyZWF0b3I6IEJsYW5rU3ZlbHRlLFxuXHRcdFx0XHR9KSxcblx0XHRcdH0sXG5cblx0XHRcdC8vIGRlZmF1bHQgaG9va3Ncblx0XHRcdGhvb2tzOiB7XG5cdFx0XHRcdGJlZm9yZV9jaGFuZ2Uoa3RfY29udGV4dCwga3Bfc3JjLCBrcF9kc3QpIHtcblx0XHRcdFx0XHQvLyBibHVyIG9uIHBhZ2Vcblx0XHRcdFx0XHR2b2lkIGtwX3NyYy5maXJlKCdibHVyJyk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gb25jZSBhIG5ldyBwYWdlIGhhcyBiZWVuIHB1c2hlZFxuXHRcdFx0XHRhZnRlcl9wdXNoKGt0X2NvbnRleHQsIGtwX3NyYywga3BfZHN0KSB7XG5cdFx0XHRcdFx0Ly8gLy8gcHVzaCBzdGF0ZSB0byBuYXZpZ2F0b3IgaGlzdG9yeVxuXHRcdFx0XHRcdC8vIGhpc3RvcnkucHVzaFN0YXRlKG51bGwsICcnLCAnI3BhZ2U6JytrcF9kc3QuaWQpO1xuXG5cdFx0XHRcdFx0Ly8gd2FpdCBmb3Igc3ZlbHRlIHRvIHJlbmRlciBjb21wb25lbnQgYmVmb3JlIHF1ZXJ5aW5nIGNvbnRhaW5lclxuXHRcdFx0XHRcdHZvaWQgdGljaygpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gcXVlcnkgY29udGFpbmVyIGZvciBsYXN0IGVsZW1lbnQgY2hpbGRcblx0XHRcdFx0XHRcdHZvaWQgc2xpZGUoa3BfZHN0LmRvbSwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gb25jZSBhIHBhZ2UgaGFzIGJlZW4gcG9wcGVkXG5cdFx0XHRcdGFmdGVyX3BvcChrdF9jb250ZXh0LCBrcF9zcmMsIGtwX2RzdCwgZ2NfcG9wKSB7XG5cdFx0XHRcdFx0Ly8gbm90aWZ5IGRzdCBwYWdlXG5cdFx0XHRcdFx0dm9pZCBrcF9kc3QuZmlyZSgncmVzdG9yZScpO1xuXG5cdFx0XHRcdFx0Ly8gZG8gbm90IGJ5cGFzcyBhbmltYXRpb25cblx0XHRcdFx0XHRpZighZ2NfcG9wLmJ5cGFzc0FuaW1hdGlvbikge1xuXHRcdFx0XHRcdFx0Ly8gYXBwbHkgdHJhbnNsYXRpb24gdHJhbnNmb3JtIHRvIHNyYyBwYWdlXG5cdFx0XHRcdFx0XHRrcF9zcmMuZG9tLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKHZhcigtLWFwcC13aW5kb3ctd2lkdGgpKWA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIHVwb24gYW55IHBhZ2UgY2hhbmdlXG5cdFx0XHRcdGFmdGVyX2NoYW5nZShrdF9jb250ZXh0LCBrcF9zcmMsIGtwX2RzdCwgc190cmFuc2l0aW9uLCBoX2V4dHJhPXt9KSB7XG5cdFx0XHRcdFx0Ly8gc2V0IGdsb2JhbCBwYWdlIGFuZCB0aHJlYWRcblx0XHRcdFx0XHQkeXdfcGFnZSA9IGtwX2RzdDtcblx0XHRcdFx0XHQkeXdfdGhyZWFkID0ga3RfY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIG5vdGlmeSBkc3QgcGFnZVxuXHRcdFx0XHRcdHZvaWQga3BfZHN0LmZpcmUoJ2ZvY3VzJyk7XG5cblx0XHRcdFx0XHQvLyAvLyBtYWludGFpbiBzY3JvbGxUb3Agb2YgdGhlIHNyYyBwYWdlXG5cdFx0XHRcdFx0Ly8gY29uc3QgeF9zY3JvbGxfdG9wID0ga3Bfc3JjLmRvbS5zY3JvbGxUb3A7XG5cblx0XHRcdFx0XHQvLyBkZWJ1Z2dlcjtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRhc3luYyBiZWZvcmVfc3dpdGNoKCkge1xuXHRcdFx0XHRcdC8vIGFsbG93IHRoZXNlIHRvIGZhaWwgaW4gb3JkZXIgdG8gcmVjb3ZlciBmcm9tIGRpc2FzdGVyc1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHQvLyBzZXQgZGVmYXVsdHNcblx0XHRcdFx0XHRcdGF3YWl0IFByb21pc2UuYWxsKFtcblx0XHRcdFx0XHRcdFx0Ly8gZGVmYXVsdCBjaGFpblxuXHRcdFx0XHRcdFx0XHQkeXdfY2hhaW4gfHwgb25jZV9zdG9yZV91cGRhdGVzKHl3X2NoYWluLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0Q2hhaW5zLnJlYWQoKS50aGVuKGtzID0+ICR5d19jaGFpbl9yZWYgPSBvZGUoa3MucmF3KVswXVswXSksXG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmYXVsdCBuZXR3b3JrXG5cdFx0XHRcdFx0XHRcdCR5d19uZXR3b3JrX2FjdGl2ZSB8fCBvbmNlX3N0b3JlX3VwZGF0ZXMoeXdfbmV0d29ya19hY3RpdmUsIHRydWUpLFxuXHRcdFx0XHRcdFx0XHROZXR3b3Jrcy5yZWFkKCkudGhlbihrcyA9PiAkeXdfbmV0d29ya19yZWYgPSBvZGUoa3MucmF3KVswXVswXSksXG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmYXVsdCBhY2NvdW50XG5cdFx0XHRcdFx0XHRcdCR5d19hY2NvdW50IHx8IG9uY2Vfc3RvcmVfdXBkYXRlcyh5d19hY2NvdW50LCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0QWNjb3VudHMucmVhZCgpLnRoZW4oa3MgPT4gJHl3X2FjY291bnRfcmVmID0gb2RlKGtzLnJhdylbMF1bMF0pLFxuXHRcdFx0XHRcdFx0XSk7XG5cblx0XHRcdFx0XHRcdC8vIG9ubHkgbmVlZHMgdG8gaGFwcGVuIG9uY2Vcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmJlZm9yZV9zd2l0Y2g7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoKGVfbG9hZF9kZWZhdWx0KSB7XG5cdFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyhlX2xvYWRfZGVmYXVsdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGFzeW5jIGFmdGVyX3N3aXRjaChrdF9zcmMsIGt0X2RzdCkge1xuXHRcdFx0XHRcdC8vIHNldCBnbG9iYWwgcGFnZSBhbmQgdGhyZWFkXG5cdFx0XHRcdFx0JHl3X3BhZ2UgPSBrdF9kc3QucGFnZTtcblx0XHRcdFx0XHQkeXdfdGhyZWFkID0ga3RfZHN0O1xuXG5cdFx0XHRcdFx0Ly8gZm9jdXMgb24gcGFnZVxuXHRcdFx0XHRcdHZvaWQga3RfZHN0LnBhZ2UuZmlyZSgnZm9jdXMnKTtcblxuXHRcdFx0XHRcdC8vIHdhaXQgZm9yIHN2ZWx0ZSB0byByZW5kZXIgY29tcG9uZW50IGJlZm9yZSBxdWVyeWluZyBjb250YWluZXJcblx0XHRcdFx0XHRhd2FpdCB0aWNrKCk7XG5cblx0XHRcdFx0XHQvLyBxdWVyeSBjb250YWluZXIgZm9yIGxhc3QgZWxlbWVudCBjaGlsZFxuXHRcdFx0XHRcdGF3YWl0IHNsaWRlKGt0X2RzdC5wYWdlLmRvbSwgdHJ1ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHQvLyBzcGVjaWZpYyBwYWdlIGdpdmVuXG5cdFx0aWYoYl9mbG93KSB7XG5cdFx0XHQvLyBvdmVycmlkZSB0aHJlYWRzIGNvbmZpZ1xuXHRcdFx0Z2NfbmF2aWdhdG9yLnRocmVhZHMgPSB7XG5cdFx0XHRcdGRlZmF1bHQ6ICgpID0+IGdjX3BhZ2UsXG5cdFx0XHR9O1xuXHRcdH1cblx0XHQvLyBtYWluIHN5c3RlbVxuXHRcdGVsc2UgaWYoYl9tYWluKSB7XG5cdFx0XHQvLyBvdmVycmlkZSB0aHJlYWRzIGNvbmZpZ1xuXHRcdFx0Z2NfbmF2aWdhdG9yLnRocmVhZHMgPSBvZGVyb20oSF9USFJFQURTLCAoc2lfdGhyZWFkLCBkY19zY3JlZW4pID0+IHtcblx0XHRcdFx0Ly8gLy8gbG9va3VwIHJvdXRlciBub2RlIGNvcnJlc3BvbmRpbmcgdG8gc2NyZWVuIGNsYXNzXG5cdFx0XHRcdC8vIGNvbnN0IGtfbm9kZSA9IEtfUk9VVEVSLmxvb2t1cF9zY3JlZW4oZGNfc2NyZWVuKTtcblxuXHRcdFx0XHQvLyAvLyByZWYgcGF0aCBwYXR0ZXJuXG5cdFx0XHRcdC8vIGNvbnN0IHN4X3BhdHRlcm4gPSBrX25vZGUucGF0aF9wYXR0ZXJuO1xuXG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0W3NpX3RocmVhZF06IChoX3Byb3BzOiBQbGFpbk9iamVjdCkgPT4gKHtcblx0XHRcdFx0XHRcdGNyZWF0b3I6IGRjX3NjcmVlbixcblx0XHRcdFx0XHRcdHByb3BzOiBoX3Byb3BzLFxuXHRcdFx0XHRcdFx0Ly8gcGF0aDoga19ub2RlLnJldmVyc2VfcmVzb2x2ZShoX3Byb3BzKSxcblx0XHRcdFx0XHRcdC8vIHBhdHRlcm46IHN4X3BhdHRlcm4sXG5cdFx0XHRcdFx0XHQvLyBzY3JlZW46IGRjX3NjcmVlbixcblx0XHRcdFx0XHR9KSxcblx0XHRcdFx0fSBhcyBSZWNvcmQ8dHlwZW9mIHNpX3RocmVhZCwgKGhfcHJvcHM6IFBsYWluT2JqZWN0KSA9PiBQYWdlQ29uZmlnPjtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBzZXQgaW5pdFxuXHRcdFx0Z2NfbmF2aWdhdG9yLnRocmVhZHMuaW5pdCA9IChoX3Byb3BzOiBQbGFpbk9iamVjdCwgaF9jb250ZXh0PzogUGxhaW5PYmplY3QpID0+ICh7XG5cdFx0XHRcdC4uLmdjX3BhZ2UsXG5cdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0Li4uZ2NfcGFnZS5wcm9wcyxcblx0XHRcdFx0XHQuLi5oX3Byb3BzLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb250ZXh0OiB7XG5cdFx0XHRcdFx0Li4uZ2NfcGFnZS5jb250ZXh0LFxuXHRcdFx0XHRcdC4uLmhfY29udGV4dCxcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGNvbnN0IGtfbmF2aWdhdG9yID0gbmV3IE5hdmlnYXRvcihnY19uYXZpZ2F0b3IpO1xuXHRcdCR5d19uYXZpZ2F0b3IgPSBrX25hdmlnYXRvcjtcblxuXG5cblx0XHQvLyBoYW5kbGUgcG9wIHN0YXRlXG5cdFx0Ly8gd2luZG93Lm9ucG9wc3RhdGUgPSBmdW5jdGlvbihkX2V2ZW50OiBQb3BTdGF0ZUV2ZW50KSB7XG5cdFx0Ly8gXHRrX25hdmlnYXRvci5hY3RpdmVQYWdlLnBvcCh7XG5cdFx0Ly8gXHRcdGV4dGVybmFsOiB0cnVlLFxuXHRcdC8vIFx0fSk7XG5cdFx0Ly8gfTtcblxuXHRcdC8vICR5d19leGl0dGluZ19kb20gPSBkbV9leGl0dGluZztcblxuXHRcdC8vIGNvbnN0IGtfc3RhdGVfcm9vdCA9IG5ldyBTdGF0ZSgnL2xvY2tlZCcsIG51bGwgYXMgdW5rbm93biBhcyBTdmVsdGVDb21wb25lbnQsICcvbG9ja2VkJyk7XG5cdFx0Ly8gY29uc3Qga190aHJlYWRfcm9vdCA9IG5ldyBTdGF0ZVRocmVhZChrX3N0YXRlX3Jvb3QpO1xuXG5cdC8vIFx0aW5pdGlhbGl6ZShuZXcgU3RhdGVNYW5hZ2VyKHtcblx0Ly8gXHRcdHJvdXRlcjogS19ST1VURVIsXG5cblx0Ly8gXHRcdGFycml2ZSh0aGlzOiBTdGF0ZU1hbmFnZXIsIGtzX3NyYzogU3RhdGUsIGtzX2RzdDogU3RhdGUsIHNpX3RocmVhZF9zcmM6IHN0cmluZywgc190cmFuc2l0aW9uPScnKTogUHJvbWlzZTx2b2lkPiB7XG5cdC8vIFx0XHRcdC8vIG1haW50YWluIHNjcm9sbFRvcFxuXHQvLyBcdFx0XHRjb25zdCB4X3Njcm9sbF90b3AgPSBrc19zcmMuZG9tLnNjcm9sbFRvcDtcblxuXHQvLyBcdFx0XHRjb25zb2xlLmxvZyh7XG5cdC8vIFx0XHRcdFx0dHlwZTogJ2Fycml2ZScsXG5cdC8vIFx0XHRcdFx0a3Nfc3JjLFxuXHQvLyBcdFx0XHRcdGtzX2RzdCxcblx0Ly8gXHRcdFx0XHRzaV90aHJlYWRfc3JjLFxuXHQvLyBcdFx0XHRcdHNfdHJhbnNpdGlvbixcblx0Ly8gXHRcdFx0fSk7XG5cblx0Ly8gXHRcdFx0Ly8gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG0pID0+IHtcblx0Ly8gXHRcdFx0Ly8gXHRkZWJ1Z2dlcjtcblx0Ly8gXHRcdFx0Ly8gfSkub2JzZXJ2ZShrc19zcmMuZG9tLCB7XG5cdC8vIFx0XHRcdC8vIFx0YXR0cmlidXRlczogdHJ1ZSxcblx0Ly8gXHRcdFx0Ly8gXHRjaGlsZExpc3Q6IHRydWUsXG5cdC8vIFx0XHRcdC8vIH0pO1xuXG5cdC8vIFx0XHRcdC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrc19zcmMuZG9tLCAnc2Nyb2xsVG9wJywge1xuXHQvLyBcdFx0XHQvLyBcdGdldCgpIHtcblx0Ly8gXHRcdFx0Ly8gXHRcdHJldHVybiB4X3Njcm9sbF90b3A7XG5cdC8vIFx0XHRcdC8vIFx0fSxcblx0Ly8gXHRcdFx0Ly8gXHRzZXQoeF90bzogbnVtYmVyKSB7XG5cdC8vIFx0XHRcdC8vIFx0XHRjb25zb2xlLmxvZyhgU0VUIFRPOiAke3hfdG99YCk7XG5cdC8vIFx0XHRcdC8vIFx0XHRkZWJ1Z2dlcjtcblx0Ly8gXHRcdFx0Ly8gXHR9LFxuXHQvLyBcdFx0XHQvLyB9KTtcblxuXHQvLyBcdFx0XHQvLyBuZXV0ZXIgc3JjIGZyYW1lXG5cdC8vIFx0XHRcdGtzX3NyYy5kb20uY2xhc3NMaXN0LmFkZCgnZnJvemVuJyk7XG5cblx0Ly8gXHRcdFx0Ly8gZW5zdXJlIGluY29taW5nIGZyYW1lIGlzIG5vdCBmcm96ZW5cblx0Ly8gXHRcdFx0a3NfZHN0LmRvbS5jbGFzc0xpc3QucmVtb3ZlKCdmcm96ZW4nKTtcblxuXHQvLyBcdFx0XHRjb25zdCBnY19wYXJhbXMgPSB5d19wYXJhbXMuZ2V0KCk7XG5cdC8vIFx0XHRcdC8vIGNvbnN0IGdjX3BhcmFtcyA9IHt9O1xuXG5cdC8vIFx0XHRcdCR5d19wYXRoID0ga3NfZHN0LnBhdGg7XG5cdC8vIFx0XHRcdCR5d19wYXR0ZXJuID0ga3NfZHN0LnBhdHRlcm47XG5cblx0Ly8gXHRcdFx0Y29uc3QgZ2NfcHJvcHMgPSBrc19kc3QucHJvcHM7XG5cblx0Ly8gXHRcdFx0JHl3X3BhcmFtcyA9IHtcblx0Ly8gXHRcdFx0XHRmYW1pbHlJZDogZ2NfcHJvcHMuZmFtaWx5SWQgYXMgc3RyaW5nIHx8IGdjX3BhcmFtcy5mYW1pbHlJZCxcblx0Ly8gXHRcdFx0XHRjaGFpbklkOiBnY19wcm9wcy5jaGFpbklkIGFzIHN0cmluZyB8fCBnY19wYXJhbXMuY2hhaW5JZCxcblx0Ly8gXHRcdFx0XHRhY2NvdW50SWQ6IGdjX3Byb3BzLmFjY291bnRJZCBhcyBzdHJpbmcgfHwgZ2NfcGFyYW1zLmFjY291bnRJZCxcblx0Ly8gXHRcdFx0fTtcblxuXHQvLyBcdFx0XHRpZihnY19wcm9wcy5mYW1pbHlJZCkge1xuXHQvLyBcdFx0XHRcdGNvbnN0IHBfZmFtaWx5ID0gRmFtaWx5LnJlZkZyb21JZChnY19wcm9wcy5mYW1pbHlJZCBhcyBzdHJpbmcpO1xuXHQvLyBcdFx0XHRcdGlmKCFIX0ZBTUlMSUVTW3BfZmFtaWx5XSkgZGVidWdnZXI7XG5cdC8vIFx0XHRcdFx0JHl3X2ZhbWlseSA9IEhfRkFNSUxJRVNbcF9mYW1pbHldO1xuXHQvLyBcdFx0XHR9XG5cblx0Ly8gXHRcdFx0Ly8gaWYoZ2NfcHJvcHMuY2hhaW5JZCkge1xuXHQvLyBcdFx0XHQvLyBcdGlmKCEkeXdfZmFtaWx5KSBkZWJ1Z2dlcjtcblx0Ly8gXHRcdFx0Ly8gXHRjb25zdCBwX2NoYWluID0gQ2hhaW4ucmVmRnJvbUZhbWlseUlkKCR5d19mYW1pbHkuZGVmLmlyaSwgZ2NfcHJvcHMuY2hhaW5JZCBhcyBzdHJpbmcpO1xuXHQvLyBcdFx0XHQvLyBcdCR5d19jaGFpbiA9IEhfQ0hBSU5TW3BfY2hhaW5dIHx8IG51bGw7XG5cdC8vIFx0XHRcdC8vIH1cblxuXHQvLyBcdFx0XHQvLyBpZihnY19wcm9wcy5hY2NvdW50SWQpIHtcblx0Ly8gXHRcdFx0Ly8gXHRjb25zb2xlLndhcm4oYDwkeyR5d19wYXRofT4gcHJvcHMgc2V0IGFjY291bnRJZCA9ICR7Z2NfcHJvcHMuYWNjb3VudElkfWApO1xuXHQvLyBcdFx0XHQvLyBcdCR5d19hY2NvdW50ID0gSF9BQ0NPVU5UU1tBY2NvdW50LnJlZkZyb21JZChnY19wcm9wcy5hY2NvdW50SWQgYXMgc3RyaW5nKV07XG5cdC8vIFx0XHRcdC8vIH1cblxuXHQvLyBcdFx0XHQkeXdfc2NyZWVuX2RvbSA9IGtzX2RzdC5kb207XG5cblx0Ly8gXHRcdFx0Ly8gdHJpZ2dlciBjb21wb25lbnQgc2V0dGluZ3Ncblx0Ly8gXHRcdFx0Y29uc3QgZmtfYXJyaXZlID0gaG1fYXJyaXZhbHMuZ2V0KGtzX2RzdC5kb20pO1xuXHQvLyBcdFx0XHRpZihma19hcnJpdmUpIGZrX2Fycml2ZSgpO1xuXG5cdC8vIFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuXHQvLyBcdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoYXN5bmMoZmtfcmVzb2x2ZSkgPT4ge1xuXHQvLyBcdFx0XHRcdC8vIHJlZiBzcmMgc3RhdGUncyBkb21cblx0Ly8gXHRcdFx0XHRsZXQgZG1fc3JjID0ga3Nfc3JjLmRvbTtcblxuXHQvLyBcdFx0XHRcdC8vIHJlZiBjbGFzc2xpc3Rcblx0Ly8gXHRcdFx0XHRjb25zdCBkX2NsYXNzX2xpc3QgPSBkbV9zcmMuY2xhc3NMaXN0O1xuXG5cdC8vIFx0XHRcdFx0Ly8gc2hvcnQgY2lyY3VpdCBleHBlbnNpdmUgY29tcHV0ZWQgc3R5bGUgY2FsbFxuXHQvLyBcdFx0XHRcdGxldCBiX3RyYW5zaXRpb25zID0gZmFsc2U7XG5cdC8vIFx0XHRcdFx0aWYoJ2dvdG8nID09PSBzX3RyYW5zaXRpb24pIHtcblx0Ly8gXHRcdFx0XHRcdGlmKGRfY2xhc3NfbGlzdC5jb250YWlucygnc2xpZGVzJykpIHtcblx0Ly8gXHRcdFx0XHRcdFx0Ly8gY2hhbmdpbmcgdGhyZWFkc1xuXHQvLyBcdFx0XHRcdFx0XHRpZihzaV90aHJlYWRfc3JjKSB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0ZG1fc3JjID0gZG1fc3JjLmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRWxlbWVudDtcblx0Ly8gXHRcdFx0XHRcdFx0XHRkbV9leGl0dGluZy5yZXBsYWNlQ2hpbGRyZW4oZG1fc3JjKTtcblx0Ly8gXHRcdFx0XHRcdFx0fVxuXG5cdC8vIFx0XHRcdFx0XHRcdGRtX3NyYy5zdHlsZS56SW5kZXggPSAnMTAwMSc7XG5cblx0Ly8gXHRcdFx0XHRcdFx0YXdhaXQgdGltZW91dCgwKTtcblxuXHQvLyBcdFx0XHRcdFx0XHQvLyBkbV9zcmMuc3R5bGUubGVmdCA9IGAtJHtYUF9BUFBfV0lEVEh9cHhgO1xuXHQvLyBcdFx0XHRcdFx0XHRkbV9zcmMuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgtJHtYUF9BUFBfV0lEVEh9cHgpYDtcblx0Ly8gXHRcdFx0XHRcdFx0Yl90cmFuc2l0aW9ucyA9IHRydWU7XG5cdC8vIFx0XHRcdFx0XHR9XG5cdC8vIFx0XHRcdFx0XHRlbHNlIHtcblx0Ly8gXHRcdFx0XHRcdFx0Y29uc3Qgc2lfZXhpdCA9IGRtX3NyYy5nZXRBdHRyaWJ1dGUoJ2RhdGEtczItZXhpdCcpIGFzIHN0cmluZztcblxuXHQvLyBcdFx0XHRcdFx0XHRzd2l0Y2goc2lfZXhpdCkge1xuXHQvLyBcdFx0XHRcdFx0XHRcdGNhc2UgJ3N3aXBlcyc6IHtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGRtX3NyYy5zdHlsZS5sZWZ0ID0gYC0ke1hQX0FQUF9XSURUSH1weGA7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRkbV9zcmMuc3R5bGUuekluZGV4ID0gJzEwMDEnO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0Yl90cmFuc2l0aW9ucyA9IHRydWU7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0Ly8gXHRcdFx0XHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHRjYXNlICdsZWF2ZXMnOiB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHQvLyBjaGFuZ2luZyB0aHJlYWRzXG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRpZihzaV90aHJlYWRfc3JjKSB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRcdGRtX3NyYyA9IGRtX3NyYy5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRcdGRtX2V4aXR0aW5nLnJlcGxhY2VDaGlsZHJlbihkbV9zcmMpO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRkbV9zcmMuc3R5bGUuekluZGV4ID0gJzEwMDEnO1xuXG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRhd2FpdCB0aW1lb3V0KDApO1xuXG5cdC8vIFx0XHRcdFx0XHRcdFx0XHQvLyBkbV9zcmMuc3R5bGUubGVmdCA9IGAtJHtYUF9BUFBfV0lEVEh9cHhgO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0ZG1fc3JjLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoLSR7WFBfQVBQX1dJRFRIfXB4KWA7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRiX3RyYW5zaXRpb25zID0gdHJ1ZTtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHQvLyBcdFx0XHRcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdFx0XHRcdGNhc2UgJ3JldmVhbHMnOiB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRkbV9zcmMuY2xhc3NMaXN0LmFkZCgncmV2ZWFsJyk7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRiX3RyYW5zaXRpb25zID0gdHJ1ZTtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHQvLyBcdFx0XHRcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IHtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBhdHRyaWJ1dGUgdmFsdWU6IFwiJHtzaV9leGl0ID8/ICcnfVwiYCk7XG5cdC8vIFx0XHRcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdFx0XHR9XG5cdC8vIFx0XHRcdFx0XHR9XG5cdC8vIFx0XHRcdFx0fVxuXG5cdC8vIFx0XHRcdFx0Ly8gbm90IGNoYW5naW5nIHRocmVhZHNcblx0Ly8gXHRcdFx0XHRpZighc2lfdGhyZWFkX3NyYykge1xuXHQvLyBcdFx0XHRcdFx0Ly8gLy8gc3JjIGxlYXZlc1xuXHQvLyBcdFx0XHRcdFx0Ly8gaWYoZF9jbGFzc19saXN0LmNvbnRhaW5zKCdsZWF2ZXMnKSkge1xuXHQvLyBcdFx0XHRcdFx0Ly8gXHRkbV9zcmMuc3R5bGUubGVmdCA9IGAtJHtYUF9BUFBfV0lEVEh9cHhgO1xuXHQvLyBcdFx0XHRcdFx0Ly8gXHRkbV9zcmMuc3R5bGUuekluZGV4ID0gJzEwMDEnO1xuXHQvLyBcdFx0XHRcdFx0Ly8gXHRiX3RyYW5zaXRpb25zID0gdHJ1ZTtcblx0Ly8gXHRcdFx0XHRcdC8vIH1cblxuXHQvLyBcdFx0XHRcdFx0Ly8gc3JjIHNsaWRlcyBvdXRcblx0Ly8gXHRcdFx0XHRcdGlmKGRfY2xhc3NfbGlzdC5jb250YWlucygnc2xpZGVzJykpIHtcblx0Ly8gXHRcdFx0XHRcdFx0Yl90cmFuc2l0aW9ucyA9IHRydWU7XG5cdC8vIFx0XHRcdFx0XHR9XG5cdC8vIFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdC8vIGNoYW5naW5nIHRocmVhZHNcblx0Ly8gXHRcdFx0XHRlbHNlIHtcblx0Ly8gXHRcdFx0XHRcdC8vIGdvaW5nIHRvIHNlYXJjaFxuXHQvLyBcdFx0XHRcdFx0aWYoJy9zZWFyY2gnID09PSBrc19kc3QucGF0dGVybikge1xuXHQvLyBcdFx0XHRcdFx0XHRkbV9zcmMuY2xhc3NMaXN0LmFkZCgnc3VibGltYXRlJyk7XG5cdC8vIFx0XHRcdFx0XHR9XG5cdC8vIFx0XHRcdFx0XHQvLyBsZWF2aW5nIHNlYXJjaFxuXHQvLyBcdFx0XHRcdFx0ZWxzZSBpZignL3NlYXJjaCcgPT09IGtzX3NyYy5wYXR0ZXJuKSB7XG5cdC8vIFx0XHRcdFx0XHRcdGtzX2RzdC5kb20uY2xhc3NMaXN0LnJlbW92ZSgnc3VibGltYXRlJyk7XG5cdC8vIFx0XHRcdFx0XHR9XG5cdC8vIFx0XHRcdFx0fVxuXG5cdC8vIFx0XHRcdFx0Ly8gXG5cdC8vIFx0XHRcdFx0YXdhaXQgbWljcm90YXNrKCk7XG5cblx0Ly8gXHRcdFx0XHQvLyBlbGVtZW50IGlzIHRyYW5zaXRpb25pbmdcblx0Ly8gXHRcdFx0XHRpZighc190cmFuc2l0aW9uLmVuZHNXaXRoKCcuYnlwYXNzJykpIHtcblx0Ly8gXHRcdFx0XHRcdGlmKGJfdHJhbnNpdGlvbnMgfHwgU1hfTk9fVFJBTlNJVElPTiAhPT0gZ2V0Q29tcHV0ZWRTdHlsZShkbV9zcmMpLnRyYW5zaXRpb24pIHtcblx0Ly8gXHRcdFx0XHRcdFx0Ly8gd2FpdCBmb3IgdHJhbnNpdGlvbiB0byBlbmRcblx0Ly8gXHRcdFx0XHRcdFx0ZG1fc3JjLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiB0cmFuc2l0aW9uX2VuZChkX2V2ZW50KSB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0Ly8gbm90IGEgcG9zaXRpb24gcHJvcGVydHlcblx0Ly8gXHRcdFx0XHRcdFx0XHRpZigndHJhbnNmb3JtJyAhPT0gZF9ldmVudC5wcm9wZXJ0eU5hbWUpIHJldHVybjtcblxuXHQvLyBcdFx0XHRcdFx0XHRcdC8vIHJlbW92ZSBzZWxmXG5cdC8vIFx0XHRcdFx0XHRcdFx0ZG1fc3JjLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0cmFuc2l0aW9uX2VuZCk7XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHQvLyByZXNvbHZlXG5cdC8vIFx0XHRcdFx0XHRcdFx0ZmtfcmVzb2x2ZSgpO1xuXHQvLyBcdFx0XHRcdFx0XHR9KTtcblxuXHQvLyBcdFx0XHRcdFx0XHQvLyB3YWl0IGZvciBjYWxsYmFja1xuXHQvLyBcdFx0XHRcdFx0XHRyZXR1cm47XG5cdC8vIFx0XHRcdFx0XHR9XG5cdC8vIFx0XHRcdFx0fVxuXG5cdC8vIFx0XHRcdFx0ZmtfcmVzb2x2ZSgpO1xuXHQvLyBcdFx0XHR9KTtcblx0Ly8gXHRcdH0sXG5cdC8vIFx0fSkpO1xuXHR9KTtcblx0XG48L3NjcmlwdD5cblxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHQuZnVsbChAdHlwZSkge1xuXHRcdHBvc2l0aW9uOiBAdHlwZTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cblxuXHQuZnVsbChhYnNvbHV0ZSkge1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHR9XG5cblx0LnZpZXdwb3J0IHtcblx0XHQuZnVsbChyZWxhdGl2ZSk7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblxuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cblx0XHQ+LmNvbnRlbnQge1xuXHRcdFx0LmZ1bGwocmVsYXRpdmUpO1xuXHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblxuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cblx0XHRcdCYuZXhpdHRpbmcge1xuXHRcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdHRvcDogMDtcblx0XHRcdFx0ei1pbmRleDogMTAwMTtcblx0XHRcdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0XHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdFx0fVxuXG5cdFx0XHQ+LnRocmVhZCB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdC5mdWxsKGFic29sdXRlKTtcblx0XHRcdFx0XHRwYWRkaW5nLWxlZnQ6IGNhbGMoNTB2dyAtICh2YXIoLS1hcHAtbWF4LXdpZHRoKSAvIDIpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIDpnbG9iYWwoJj5zZWN0aW9uKSB7XG5cdFx0XHQvLyBcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdC8vIFx0dG9wOiAwcHg7XG5cdFx0XHQvLyBcdHRyYW5zaXRpb246IGxlZnQgMC42cyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdFx0XHQvLyB9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48bWFpbiBjbGFzcz1cInZpZXdwb3J0XCIgYmluZDp0aGlzPXtkbV92aWV3cG9ydH0+XG5cdDxkaXYgY2xhc3M9XCJjb250ZW50IHRocmVhZHNcIiBiaW5kOnRoaXM9e2RtX3RocmVhZHN9IC8+XG5cdDxkaXYgY2xhc3M9XCJjb250ZW50IGV4aXR0aW5nXCIgYmluZDp0aGlzPXtkbV9leGl0dGluZ30gLz5cblx0PHNsb3Q+PC9zbG90PlxuXG5cdDxQcm9ncmVzc1N2ZWx0ZSAvPlxuXHRcblx0eyNpZiBiX21haW59XG5cdFx0eyNhd2FpdCBWYXVsdC5nZXRSb290S2V5KCkgdGhlbiBka19yb290fVxuXHRcdFx0eyNpZiBka19yb290fVxuXHRcdFx0XHQ8T3ZlcnNjcm9sbFN2ZWx0ZSAvPlxuXHRcdFx0XHQ8TmF2U3ZlbHRlIC8+XG5cdFx0XHRcdDxTZWFyY2hTdmVsdGUgLz5cblx0XHRcdFx0PFZlbmRvck1lbnVTdmVsdGUgLz5cblx0XHRcdFx0PFNpZGVNZW51U3ZlbHRlIC8+XG5cdFx0XHRcdDxQb3B1cFN2ZWx0ZSAvPlxuXHRcdFx0ey9pZn1cblx0XHR7L2F3YWl0fVxuXHR7L2lmfVxuPC9tYWluPlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IExvZywgeyBMb2dnZXIgfSBmcm9tICcjL2FwcC91aS9Mb2cuc3ZlbHRlJztcblxuXHRpbXBvcnQgeyBWYXVsdCB9IGZyb20gJyMvY3J5cHRvL3ZhdWx0Jztcblx0aW1wb3J0IHR5cGUgeyBDb21wbGV0ZWQgfSBmcm9tICcjL2VudHJ5L2Zsb3cnO1xuXG5cdGltcG9ydCB7XG5cdFx0QVRVOF9EVU1NWV9QSFJBU0UsXG5cdFx0QVRVOF9EVU1NWV9WRUNUT1IsXG5cdFx0bG9naW4sXG5cdFx0Q29ycnVwdGVkVmF1bHRFcnJvcixcblx0XHRJbnZhbGlkUGFzc3BocmFzZUVycm9yLFxuXHRcdFJlY292ZXJhYmxlVmF1bHRFcnJvcixcblx0XHRVbnJlZ2lzdGVyZWRFcnJvcixcblx0fSBmcm9tICcjL3NoYXJlL2F1dGgnO1xuXG5cdGltcG9ydCB7IFNjcmVlbiwgdHlwZSBQYWdlIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcjL2FwcC91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuXHRpbXBvcnQgRmllbGQgZnJvbSAnIy9hcHAvdWkvRmllbGQuc3ZlbHRlJztcblx0aW1wb3J0IHsgc2xpZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XG5cblx0Ly8gd2lsbCBiZSBzZXQgaWYgcGFydCBvZiBmbG93XG5cdGNvbnN0IGNvbXBsZXRlZCA9IGdldENvbnRleHQ8Q29tcGxldGVkIHwgdW5kZWZpbmVkPignY29tcGxldGVkJyk7XG5cblx0Ly8gcGFzc3dvcmQgdmFsdWUgYmluZGluZ1xuXHRsZXQgc2hfcGFzc3dvcmQgPSAnJztcblxuXHQvLyBwYXNzd29yZCBlcnJvclxuXHRsZXQgc19lcnJfcGFzc3dvcmQgPSAnJztcblxuXHQvLyBidXN5IGF0dGVtcHRpbmcgdW5sb2NrXG5cdGxldCBiX2J1c3kgPSBmYWxzZTtcblxuXG5cdGxldCB4dF9zdGFydCA9IDA7XG5cdGxldCBrX2xvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblx0ZnVuY3Rpb24gbG9nKHNfbXNnOiBzdHJpbmcpIHtcblx0XHRrX2xvZ2dlciA9IGtfbG9nZ2VyLmV2ZW50KHNfbXNnLCBEYXRlLm5vdygpIC0geHRfc3RhcnQpO1xuXHR9XG5cblx0YXN5bmMgZnVuY3Rpb24gYXR0ZW1wdF91bmxvY2soYl9yZWNvdmVyPWZhbHNlKTogUHJvbWlzZTwxPiB7XG5cdFx0Ly8gZG8gbm90IGludGVydXB0OyBsb2NrXG5cdFx0aWYoYl9idXN5KSByZXR1cm4gMTsgYl9idXN5ID0gdHJ1ZTtcblxuXHRcdC8vIHByZXAgZ3JhY2VmdWwgZXhpdFxuXHRcdGNvbnN0IGV4aXQgPSAoKTogMSA9PiAoYl9idXN5ID0gZmFsc2UsIDEpO1xuXG5cdFx0Ly8gcmVzZXQgZXJyb3Jcblx0XHRzX2Vycl9wYXNzd29yZCA9ICcnO1xuXG5cdFx0Ly8gc3RhcnQgdGltZXJcblx0XHR4dF9zdGFydCA9IERhdGUubm93KCk7XG5cblx0XHRsb2coJ0VzdGltYXRpbmcgdGltZSB0byBjb21wbGV0ZScpO1xuXG5cdFx0Ly8gZXN0aW1hdGUgdGltZSB0byBjb21wbGV0ZVxuXHRcdHtcblx0XHRcdGNvbnN0IHh0X3N0YXJ0X2VzdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdGF3YWl0IFZhdWx0LmRlcml2ZVJvb3RCaXRzKEFUVThfRFVNTVlfUEhSQVNFLCBBVFU4X0RVTU1ZX1ZFQ1RPUiwgMSAvIDUwKTtcblx0XHRcdGNvbnN0IHh0X2ZpbmlzaF9lc3QgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHRcdGNvbnN0IHh0X2VsYXBzZWQgPSB4dF9maW5pc2hfZXN0IC0geHRfc3RhcnRfZXN0O1xuXHRcdFx0Y29uc3QgeHRfZXN0aW1hdGUgPSAoMiAqICh4dF9lbGFwc2VkICogNTApKTtcblx0XHRcdGxvZyhgQWJvdXQgJHsoeHRfZXN0aW1hdGUgLyAxMDAwKS50b0ZpeGVkKDEpfSBzZWNvbmRzYCk7XG5cdFx0fVxuXG5cdFx0Ly8gYXR0ZW1wdCBsb2dpblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBsb2dpbihzaF9wYXNzd29yZCwgYl9yZWNvdmVyLCBsb2cpO1xuXHRcdH1cblx0XHQvLyBoYW5kbGUgZXJyb3Jcblx0XHRjYXRjaChlX2xvZ2luKSB7XG5cdFx0XHRpZihlX2xvZ2luIGluc3RhbmNlb2YgVW5yZWdpc3RlcmVkRXJyb3IpIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSAnTm8gYWNjb3VudHMgZGV0ZWN0ZWQnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihlX2xvZ2luIGluc3RhbmNlb2YgSW52YWxpZFBhc3NwaHJhc2VFcnJvcikge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9ICdJbnZhbGlkIHBhc3NwaHJhc2UnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihlX2xvZ2luIGluc3RhbmNlb2YgUmVjb3ZlcmFibGVWYXVsdEVycm9yKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gJ1ZhdWx0IGlzIHBhcnRpYWxseSBjb3JydXB0ZWQ7IGF0dGVtcHRpbmcgcmVjb3ZlcnkuLi4nO1xuXHRcdFx0XHRyZXR1cm4gYXdhaXQgYXR0ZW1wdF91bmxvY2sodHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGJfcmVjb3Zlcikge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9IGBSZWNvdmVyeSBmYWlsZWQuIFZhdWx0IG1heSBiZSBpcnJlcGFyYWJseSBjb3JydXB0ZWQuXFxuJHtlX2xvZ2luLm1lc3NhZ2UhfWA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGVfbG9naW4gaW5zdGFuY2VvZiBDb3JydXB0ZWRWYXVsdEVycm9yKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gYFZhdWx0IGFwcGVhcnMgdG8gYmUgaXJyZXBhcmFibHkgY29ycnVwdGVkLlxcbiR7ZV9sb2dpbi5tZXNzYWdlfWA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSBgVW5rbm93biBlcnJvciBvY2N1cnJlZDogJHtlX2xvZ2luLnN0YWNrIHx8IGVfbG9naW4ubWVzc2FnZX1gO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBleGl0XG5cdFx0XHRyZXR1cm4gZXhpdCgpO1xuXHRcdH1cblxuXHRcdC8vIHN1Y2Nlc3Ncblx0XHRpZihjb21wbGV0ZWQpIGNvbXBsZXRlZCh0cnVlKTtcblxuXHRcdC8vIGV4aXRcblx0XHRyZXR1cm4gZXhpdCgpO1xuXHR9XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHQud2VsY29tZSB7XG5cdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0XHRnYXA6IDIwcHg7XG5cdFx0XHRwYWRkaW5nLWxlZnQ6IDE2cHg7XG5cdFx0XHRwYWRkaW5nLXJpZ2h0OiAxNnB4O1xuXHRcdFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKCcvbWVkaWEvdmVuZG9yL29yYi0xLnN2ZycpO1xuXHRcdFx0YmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcblx0XHRcdGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciB0b3A7XG5cdFx0XHRiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xuXHRcdFx0cGFkZGluZy10b3A6IGNhbGMoNTB2aCAtIDIwMHB4KTtcblx0XHR9XG5cblx0XHQ+ZGl2IHtcblx0XHRcdCYubG9nbywmLnRpdGxlIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0bWFyZ2luLWxlZnQ6IGF1dG8gIWltcG9ydGFudDtcblx0XHRcdFx0XHRtYXJnaW4tcmlnaHQ6IGF1dG8gIWltcG9ydGFudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0LmxhcmdlIHtcblx0XHQuZm9udChiaWcpO1xuXHR9XG5cblx0cCB7XG5cdFx0LmZvbnQocmVndWxhcik7XG5cdFx0cGFkZGluZzogOHB4IDA7XG5cdH1cblxuXHQubGluZSB7XG5cdFx0d2lkdGg6IGNhbGMoMTAwJSAtIDQwcHgpO1xuXHRcdGhlaWdodDogMXB4O1xuXHRcdGJhY2tncm91bmQ6IHJhZGlhbC1ncmFkaWVudCg1MCUgNTAlIGF0IDUwJSA1MCUsICNGRkM3MDAgMCUsIHJnYmEoMjU1LCAxOTksIDAsIDApIDEwMCUpO1xuXHR9XG5cblx0LmFjdGlvbnMtbGluZSB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdH1cblxuXHQub2ZmLXNjcmVlbiB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogY2FsYyh2YXIoLS1hcHAtd2luZG93LXdpZHRoKSAqIDEwMCk7XG5cdH1cbjwvc3R5bGU+XG5cbnsjaWYgZmFsc2V9XG5cdDxzcGFuXG5cdFx0Y2xhc3M6d2VsY29tZT17dHJ1ZX1cblx0Lz5cbnsvaWZ9XG5cbjxTY3JlZW4gZGVidWc9J0F1dGhlbnRpY2F0ZScgY2xhc3NOYW1lcz0nd2VsY29tZSc+XG5cdDxkaXYgY2xhc3M9XCJsb2dvXCI+XG5cdFx0PGltZyB3aWR0aD1cIjk2XCIgc3JjPVwiL21lZGlhL3ZlbmRvci9sb2dvLTk2cHgucG5nXCIgc3Jjc2V0PVwiL21lZGlhL3ZlbmRvci9sb2dvLTk2cHgucG5nIDF4LCAvbWVkaWEvdmVuZG9yL2xvZ28tMTkycHgucG5nIDJ4XCIgYWx0PVwiU3RhclNoZWxsXCIgLz5cblx0PC9kaXY+XG5cblx0PGRpdiBjbGFzcz1cInRpdGxlXCI+XG5cdFx0PGltZyBzcmM9XCIvbWVkaWEvdmVuZG9yL3RpdGxlLnN2Z1wiIGFsdD1cIlwiIC8+XG5cdDwvZGl2PlxuXG5cdDxkaXYgY2xhc3M9XCJsaW5lXCI+Jm5ic3A7PC9kaXY+XG5cblx0PGRpdiBjbGFzcz1cImZvcm0gZmxleC1yb3dzXCI+XG5cdFx0PEZpZWxkIGtleT1cInBhc3N3b3JkXCIgbmFtZT1cIlwiPlxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdHR5cGU9XCJwYXNzd29yZFwiXG5cdFx0XHRcdG5hbWU9XCJwYXNzd29yZFwiXG5cdFx0XHRcdHBsYWNlaG9sZGVyPVwiUGFzc3dvcmRcIlxuXHRcdFx0XHRiaW5kOnZhbHVlPXtzaF9wYXNzd29yZH1cblx0XHRcdFx0Y2xhc3M6aW52YWxpZD17c19lcnJfcGFzc3dvcmR9XG5cdFx0XHQvPlxuXG5cdFx0XHR7I2lmIHNfZXJyX3Bhc3N3b3JkfVxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsaWRhdGlvbi1tZXNzYWdlXCIgdHJhbnNpdGlvbjpzbGlkZT17e2R1cmF0aW9uOjMwMH19PlxuXHRcdFx0XHRcdHtzX2Vycl9wYXNzd29yZH1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHR7L2lmfVxuXHRcdDwvRmllbGQ+XG5cdDwvZGl2PlxuXG5cdDxBY3Rpb25zTGluZSBjb25maXJtPXtbJ1VubG9jaycsIGF0dGVtcHRfdW5sb2NrXX0gLz5cblxuXHQ8TG9nIGJpbmQ6aXRlbXM9e2tfbG9nZ2VyLml0ZW1zfSBoaWRlIC8+XG5cbjwvU2NyZWVuPlxuIiwiaW1wb3J0IHsgZGQsIHFzIH0gZnJvbSAnIy91dGlsL2RvbSc7XG5cbi8vIHNlbGVjdCBkb20gbG9nIGVsZW1lbnRzXG5leHBvcnQgY29uc3QgZG1fbG9nID0gcXMoZG9jdW1lbnQsICdzZWN0aW9uI2RvbS1sb2cnKTtcbmV4cG9ydCBjb25zdCBkbV9sb2dfbGlzdCA9IHFzKGRvY3VtZW50LCAnI2RvbS1sb2ctbGlzdCcpO1xuXG4vKipcbiAqIExvZ3MgYSBtZXNzYWdlIHRvIHRoZSBjb25zb2xlIGFuZCB0byBET00gYXMgYSBmYWxsYmFjayBmb3IgdW5oYW5kbGVkIGVycm9yc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZG9tbG9nKHNpX21zZzogc3RyaW5nKTogdm9pZCB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdGNvbnNvbGUubG9nKHNpX21zZyk7XG5cblx0ZG1fbG9nX2xpc3Q/LmFwcGVuZChkZCgnbGknLCB7fSwgW1xuXHRcdGRkKCdwcmUnLCB7fSwgW3NpX21zZ10pLFxuXHRdKSk7XG59XG4iLCI8c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0Lmhvcml6b24ge1xuXHRcdHdpZHRoOiBjYWxjKDEwMCUgLSA0MHB4KTtcblx0XHRoZWlnaHQ6IDFweDtcblx0XHRiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoNTAlIDUwJSBhdCA1MCUgNTAlLCAjRkZDNzAwIDAlLCByZ2JhKDI1NSwgMTk5LCAwLCAwKSAxMDAlKTtcblxuXHRcdG1hcmdpbi1sZWZ0OiBhdXRvO1xuXHRcdG1hcmdpbi1yaWdodDogYXV0bztcblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cIm5vLW1hcmdpbiBob3Jpem9uXCI+e0BodG1sICcmbmJzcDsnfTwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgU2NyZWVuIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0aW1wb3J0IEFjdGlvbnNMaW5lIGZyb20gJy4uL3VpL0FjdGlvbnNMaW5lLnN2ZWx0ZSc7XG5cdGltcG9ydCBSZWdpc3RlciBmcm9tICcuL1JlZ2lzdGVyLnN2ZWx0ZSc7XG5cdGltcG9ydCBTdGFyU2hlbGxMb2dvIGZyb20gJy4uL3VpL1N0YXJTaGVsbExvZ28uc3ZlbHRlJztcblx0aW1wb3J0IFN0YXJTaGVsbFRpdGxlIGZyb20gJy4uL3VpL1N0YXJTaGVsbFRpdGxlLnN2ZWx0ZSc7XG5cdGltcG9ydCBIb3Jpem9uIGZyb20gJy4uL3VpL0hvcml6b24uc3ZlbHRlJztcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHQ6Z2xvYmFsKC5wcmVyZWdpc3Rlcikge1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdGdhcDogMjBweDtcblx0XHRwYWRkaW5nLWxlZnQ6IDE2cHg7XG5cdFx0cGFkZGluZy1yaWdodDogMTZweDtcblx0XHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy9tZWRpYS92ZW5kb3Ivb3JiLTEuc3ZnJyk7XG5cdFx0YmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcblx0XHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgdG9wO1xuXHRcdGJhY2tncm91bmQtc2l6ZTogY292ZXI7XG5cblx0XHRwYWRkaW5nLXRvcDogY2FsYyg1MHZoIC0gMTUwcHgpO1xuXHR9XG48L3N0eWxlPlxuXG48U2NyZWVuIHJvb3QgY2xhc3NOYW1lcz0ncHJlcmVnaXN0ZXInPlxuXHQ8U3RhclNoZWxsTG9nbyBkaW09ezk2fSAvPlxuXG5cdDxTdGFyU2hlbGxUaXRsZSAvPlxuXG5cdDxIb3Jpem9uIC8+XG5cblx0PGRpdiBjbGFzcz1cImxhcmdlXCI+XG5cdFx0PGRpdj5XZWxjb21lIHRvIHRoZSBiZXRhIHByb2dyYW0uPC9kaXY+XG5cdFx0PGRpdj5UaGFuayBmb3IgeW91IGJlaW5nIGEgdGVzdGVyITwvZGl2PlxuXHQ8L2Rpdj5cblxuXHQ8cD5cblx0XHRcblx0PC9wPlxuXG5cdDxBY3Rpb25zTGluZSBjb25maXJtPXtbJ0dldCBTdGFydGVkJ119IGNvbnRkPXt7Y3JlYXRvcjpSZWdpc3Rlcn19IC8+XG48L1NjcmVlbj5cbiJdLCJuYW1lcyI6WyJjcmVhdGVfaWZfYmxvY2siLCJjdHgiLCJjcmVhdGVfaWZfYmxvY2tfMyIsImNyZWF0ZV9pZl9ibG9ja180IiwiY3JlYXRlX2lmX2Jsb2NrXzUiLCJjcmVhdGVfaWZfYmxvY2tfMiIsImNyZWF0ZV9pZl9ibG9ja18xIiwic2VhcmNoIiwiY2xpY2tfaGFuZGxlciIsIlJlZ2lzdGVyV2Vha1Bhc3N3b3JkU3ZlbHRlIiwicmVnaXN0ZXIiLCJnX3Rva2VuIiwiU1hfSUNPTl9QRVJTT05BTCIsInNpX3ZlcnN1cyIsImFwcGVuZF8xIiwiYXBwZW5kIiwiZnVuY18xIiwiVGhyZWFkSWQiLCJCbGFua1N2ZWx0ZSIsIlJlZ2lzdGVyU3ZlbHRlIiwiSG9sZGluZ3NIb21lU3ZlbHRlIiwiQ29udGFjdHNIb21lU3ZlbHRlIiwiSGlzdG9yeUhvbWVTdmVsdGUiLCJOZXR3b3Jrc0hvbWVTdmVsdGUiLCJBY2NvdW50SG9tZVN2ZWx0ZSIsIlNpdGVzSG9tZVN2ZWx0ZSIsImlkIiwib2JqIiwicGF0aCIsIm5vcm0iLCJ2YWx1ZSIsInRleHQiLCJzY29yZSIsInBhdHRlcm4iLCJyZXN1bHQiLCJpdGVtIiwic2VhcmNoZXJzIiwicXVlcnkiLCJDbGFzc1R5cGUiLCJzbGlkZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGFBQWtDLFFBQUEsTUFBQSxNQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNvcEIvQixhQUVLLFFBQUEsS0FBQSxNQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUhELE1BQUEsV0FBQSxVQUFVLElBQU8sT0FBQUEsa0JBQUEsR0FBQTs7Ozs7Ozs7Ozs2REFqQlAsSUFBVSxLQUFBLGdCQUFBO21DQVFYLElBQU8sRUFBQTs0QkFJYixJQUFLLEVBQUE7O21DQVhELElBQUk7cUNBQ0YsSUFBSTtrQ0FDUCxJQUFLLEVBQUE7dUNBQ0EsSUFBUSxFQUFBOzBDQUNMLElBQVcsRUFBQTt3Q0FDYixLQUFLO21DQUNWLElBQVEsRUFBQTs7a0NBVlAsSUFBUSxFQUFBO0FBQUE7O0FB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
