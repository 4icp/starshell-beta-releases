var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { S as SvelteComponent, i as init, s as safe_not_equal, h as element, M as set_style, j as insert, x as noop, l as detach, N as create_slot, g as space, w as attr, O as toggle_class, Q as append, R as listen, T as update_slot_base, U as get_all_dirty_from_scope, Y as get_slot_changes, t as transition_in, Z as group_outros, a as transition_out, _ as check_outros, $ as run_all, b as component_subscribe, a0 as yw_nav_visible, a1 as yw_blur, a2 as compute_slots, a3 as getContext, a4 as createEventDispatcher, a5 as onMount, r as set_store_value, a6 as bubble, e as binding_callbacks, a7 as src_url_equal, v as text, a8 as set_data, a9 as create_out_transition, aa as yw_search, ab as yw_cancel_search, ac as yw_thread, ad as yw_menu_vendor, ae as yw_overlay_network, af as yw_chain, ag as yw_chain_ref, ah as yw_overlay_account, ai as yw_account, y as yw_account_ref, aj as empty, ak as assign, al as PfpDisplay, c as create_component, m as mount_component, am as get_spread_update, an as get_spread_object, d as destroy_component, f as bind, k as add_flush_callback, ao as Close, ap as set_input_value, D as qs, aq as handle_promise, ar as Chains, as as update_await_block_branch, u as Accounts, at as destroy_each, au as Row, A as ActionsLine, av as acceptable, aw as Field, ax as NL_PASSPHRASE_MINIMUM, ay as NL_PASSPHRASE_MAXIMUM, V as Vault, az as ATU8_DUMMY_PHRASE, aA as ATU8_DUMMY_VECTOR, J as register$1, aB as AlreadyRegisteredError, aC as InvalidPassphraseError, K as login, aD as add_render_callback, aE as create_bidirectional_transition, aF as slide, aG as yw_owner, aH as load_pfps, I as ode, aI as Entities, aJ as StarSelect, aK as yw_network_active, aL as BigNumber, aM as XT_MINUTES, aN as CoinGecko, aO as format_amount, aP as oderac, aQ as yw_family, aR as subscribe_store, aS as onDestroy, aT as Agents, aU as Address, aV as Select, H as yw_navigator, E as Events, aW as format_fiat, aX as SX_ICON_DROPDOWN, aY as fold, C as CheckboxField, aZ as Portrait, a_ as oderom, a$ as syserr, b0 as popup_receive, B as open_external_link, b1 as forever, b2 as Info, b3 as SubHeader, b4 as setContext, b5 as afterUpdate, b6 as writable, b7 as tick, b8 as Pfps, L as F_NOOP, b9 as ofe, ba as ContactAgentType, bb as R_BECH32, bc as InlineTags, bd as proper, be as SX_ICON_EDIT, bf as SX_ICON_DELETE, bg as quintOut, bh as Apps, bi as Networks, F as global_receive, bj as TxnList, bk as svg_element, bl as yw_overscroll_pct, bm as yw_popup, bn as yw_page, bo as yw_menu_expanded, bp as yw_notifications, bq as yw_nav_collapsed, br as HtmlTag, bs as yw_header_props, bt as yw_progress, bu as SX_ICON_CLOSE, bv as logout, z as SI_VERSION, bw as yw_network, bx as dd, by as objects_might_differ, bz as getAllContexts, bA as yw_network_ref, bB as once_store_updates, bC as timeout, bD as UnregisteredError, bE as RecoverableVaultError, bF as CorruptedVaultError } from "./web-resource-cache.58aa6c5e.js";
const p = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p();
var global = "";
function create_fragment$M(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      set_style(span, "display", "none");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
class Blank extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$M, safe_not_equal, {});
  }
}
const get_help_slot_changes = (dirty) => ({});
const get_help_slot_context = (ctx) => ({});
function create_if_block$j(ctx) {
  let div;
  let current;
  const help_slot_template = ctx[21].help;
  const help_slot = create_slot(help_slot_template, ctx, ctx[20], get_help_slot_context);
  return {
    c() {
      div = element("div");
      if (help_slot)
        help_slot.c();
      attr(div, "class", "display_none");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (help_slot) {
        help_slot.m(div, null);
      }
      ctx[23](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (help_slot) {
        if (help_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            help_slot,
            help_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(help_slot_template, ctx2[20], dirty, get_help_slot_changes),
            get_help_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(help_slot, local);
      current = true;
    },
    o(local) {
      transition_out(help_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (help_slot)
        help_slot.d(detaching);
      ctx[23](null);
    }
  };
}
function create_fragment$L(ctx) {
  let div;
  let form_1;
  let t;
  let form_1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[21].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
  let if_block = "help" in ctx[10] && create_if_block$j(ctx);
  return {
    c() {
      div = element("div");
      form_1 = element("form");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(form_1, "class", form_1_class_value = "screen " + ctx[1] + " svelte-re7ihy");
      attr(form_1, "data-s2-exit", ctx[9]);
      attr(form_1, "style", ctx[3]);
      attr(form_1, "autocomplete", "off");
      toggle_class(form_1, "flex", true);
      toggle_class(form_1, "scroll", true);
      toggle_class(form_1, "nav", ctx[7]);
      toggle_class(form_1, "progress", ctx[0]);
      toggle_class(form_1, "transparent", ctx[2]);
      toggle_class(form_1, "sublimate", false);
      toggle_class(form_1, "blur", ctx[6]);
      attr(div, "class", "bounds svelte-re7ihy");
      toggle_class(div, "slides", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form_1);
      if (default_slot) {
        default_slot.m(form_1, null);
      }
      append(form_1, t);
      if (if_block)
        if_block.m(form_1, null);
      ctx[24](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(form_1, "submit", submit_handler_1),
          listen(form_1, "submit", ctx[22])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null),
            null
          );
        }
      }
      if ("help" in ctx2[10]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$j(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(form_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 2 && form_1_class_value !== (form_1_class_value = "screen " + ctx2[1] + " svelte-re7ihy")) {
        attr(form_1, "class", form_1_class_value);
      }
      if (!current || dirty & 8) {
        attr(form_1, "style", ctx2[3]);
      }
      if (dirty & 2) {
        toggle_class(form_1, "flex", true);
      }
      if (dirty & 2) {
        toggle_class(form_1, "scroll", true);
      }
      if (dirty & 130) {
        toggle_class(form_1, "nav", ctx2[7]);
      }
      if (dirty & 3) {
        toggle_class(form_1, "progress", ctx2[0]);
      }
      if (dirty & 6) {
        toggle_class(form_1, "transparent", ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(form_1, "sublimate", false);
      }
      if (dirty & 66) {
        toggle_class(form_1, "blur", ctx2[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const submit_handler_1 = (d_event) => void d_event.preventDefault();
function instance$I($$self, $$props, $$invalidate) {
  let $yw_nav_visible;
  let $yw_blur;
  component_subscribe($$self, yw_nav_visible, ($$value) => $$invalidate(25, $yw_nav_visible = $$value));
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(6, $yw_blur = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { nav = false } = $$props;
  const b_nav = nav;
  let { debug = "" } = $$props;
  let { progress = null } = $$props;
  let { full = false } = $$props;
  let { keyed = false } = $$props;
  let { classNames = "" } = $$props;
  const k_page = getContext("page");
  let { leaves = false } = $$props;
  let { swipes = false } = $$props;
  let { root = 0 === k_page.index } = $$props;
  let { slides = !leaves && !swipes && !root } = $$props;
  const b_slides = slides;
  let { form = false } = $$props;
  let { transparent = false } = $$props;
  let dm_screen;
  let dm_help = null;
  const si_exit = leaves ? "leaves" : swipes ? "swipes" : "";
  createEventDispatcher();
  onMount(() => {
    if (!k_page) {
      console.warn(`${debug || "unknown"} Screen missing page context`);
    } else {
      k_page.on({
        focus() {
          set_store_value(yw_nav_visible, $yw_nav_visible = b_nav, $yw_nav_visible);
        }
      });
    }
    if (keyed) {
      let x_scroll_top = 0;
      new MutationObserver(async (a_mutations) => {
        if (a_mutations[0]?.addedNodes.length) {
          try {
            x_scroll_top = dm_screen.scrollTop;
          } catch (e_null) {
          }
        } else if (a_mutations[0]?.removedNodes.length) {
          if (dm_screen) {
            $$invalidate(4, dm_screen.scrollTop = x_scroll_top, dm_screen);
          }
        }
      }).observe(dm_screen, { childList: true });
    }
  });
  let { style = "" } = $$props;
  function submit_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_help = $$value;
      $$invalidate(5, dm_help);
    });
  }
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_screen = $$value;
      $$invalidate(4, dm_screen);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("nav" in $$props2)
      $$invalidate(11, nav = $$props2.nav);
    if ("debug" in $$props2)
      $$invalidate(12, debug = $$props2.debug);
    if ("progress" in $$props2)
      $$invalidate(0, progress = $$props2.progress);
    if ("full" in $$props2)
      $$invalidate(13, full = $$props2.full);
    if ("keyed" in $$props2)
      $$invalidate(14, keyed = $$props2.keyed);
    if ("classNames" in $$props2)
      $$invalidate(1, classNames = $$props2.classNames);
    if ("leaves" in $$props2)
      $$invalidate(15, leaves = $$props2.leaves);
    if ("swipes" in $$props2)
      $$invalidate(16, swipes = $$props2.swipes);
    if ("root" in $$props2)
      $$invalidate(17, root = $$props2.root);
    if ("slides" in $$props2)
      $$invalidate(18, slides = $$props2.slides);
    if ("form" in $$props2)
      $$invalidate(19, form = $$props2.form);
    if ("transparent" in $$props2)
      $$invalidate(2, transparent = $$props2.transparent);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  return [
    progress,
    classNames,
    transparent,
    style,
    dm_screen,
    dm_help,
    $yw_blur,
    b_nav,
    b_slides,
    si_exit,
    $$slots,
    nav,
    debug,
    full,
    keyed,
    leaves,
    swipes,
    root,
    slides,
    form,
    $$scope,
    slots,
    submit_handler2,
    div_binding,
    form_1_binding
  ];
}
class Screen extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$L, safe_not_equal, {
      nav: 11,
      debug: 12,
      progress: 0,
      full: 13,
      keyed: 14,
      classNames: 1,
      leaves: 15,
      swipes: 16,
      root: 17,
      slides: 18,
      form: 19,
      transparent: 2,
      style: 3
    });
  }
}
function create_fragment$K(ctx) {
  let picture;
  let source;
  let t;
  let img;
  let img_src_value;
  let mounted;
  let dispose;
  return {
    c() {
      picture = element("picture");
      source = element("source");
      t = space();
      img = element("img");
      attr(source, "srcset", ctx[3]);
      attr(source, "media", "(min-resolution: 2dppx)");
      attr(img, "alt", ctx[1]);
      if (!src_url_equal(img.src, img_src_value = ctx[2]))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-5d3u97");
      attr(picture, "class", "no-margin logo svelte-5d3u97");
      set_style(picture, "width", ctx[0] + "px");
      set_style(picture, "height", ctx[0] + "px");
    },
    m(target, anchor) {
      insert(target, picture, anchor);
      append(picture, source);
      append(picture, t);
      append(picture, img);
      if (!mounted) {
        dispose = listen(picture, "click", ctx[6]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(picture);
      mounted = false;
      dispose();
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let { dim } = $$props;
  const x_dim = dim;
  let { alt = "StarShell logo" } = $$props;
  const s_alt = alt;
  const f_src = (x) => `/media/vendor/logo-${x}px.png`;
  const sr_default = f_src(x_dim);
  const sr_double = f_src(x_dim * 2);
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("dim" in $$props2)
      $$invalidate(4, dim = $$props2.dim);
    if ("alt" in $$props2)
      $$invalidate(5, alt = $$props2.alt);
  };
  return [x_dim, s_alt, sr_default, sr_double, dim, alt, click_handler2];
}
class StarShellLogo extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$K, safe_not_equal, { dim: 4, alt: 5 });
  }
}
const get_rows_slot_changes = (dirty) => ({});
const get_rows_slot_context = (ctx) => ({});
function create_fragment$J(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t0;
  let t1;
  let div1;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  const rows_slot_template = ctx[4].rows;
  const rows_slot = create_slot(rows_slot_template, ctx, ctx[3], get_rows_slot_context);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(ctx[1]);
      t1 = space();
      div1 = element("div");
      if (rows_slot)
        rows_slot.c();
      attr(h3, "class", "svelte-1f5uzt4");
      attr(div0, "class", "top svelte-1f5uzt4");
      attr(div1, "class", "rows svelte-1f5uzt4");
      attr(div2, "class", "overlay select svelte-1f5uzt4");
      attr(div3, "class", "cancel svelte-1f5uzt4");
      toggle_class(div3, "showing", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(h3, t0);
      append(div2, t1);
      append(div2, div1);
      if (rows_slot) {
        rows_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div3, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 2)
        set_data(t0, ctx2[1]);
      if (rows_slot) {
        if (rows_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            rows_slot,
            rows_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(rows_slot_template, ctx2[3], dirty, get_rows_slot_changes),
            get_rows_slot_context
          );
        }
      }
      if (dirty & 4) {
        toggle_class(div3, "showing", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rows_slot, local);
      if (div2_outro)
        div2_outro.end(1);
      current = true;
    },
    o(local) {
      transition_out(rows_slot, local);
      div2_outro = create_out_transition(div2, pause, {});
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (rows_slot)
        rows_slot.d(detaching);
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function pause(dm, gc) {
  return { duration: 200 };
}
function instance$G($$self, $$props, $$invalidate) {
  let $yw_blur;
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(6, $yw_blur = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { open = true } = $$props;
  let b_showing = false;
  setTimeout(
    () => {
      $$invalidate(2, b_showing = true);
    },
    10
  );
  const click_handler2 = () => {
    $$invalidate(2, b_showing = false);
    $$invalidate(0, open = false);
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      set_store_value(yw_blur, $yw_blur = open, $yw_blur);
    }
  };
  return [open, title, b_showing, $$scope, slots, click_handler2];
}
class OverlaySelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$J, safe_not_equal, { title: 1, open: 0 });
  }
}
var SX_ICON_ARROW_LEFT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-arrow-left-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-arrow-left-fg" d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"/>\n</svg>\n';
var SX_ICON_SEARCH = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-search-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-search-fg" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n</svg>\n';
var SX_CHECKED = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">\n	<style type="text/css">\n		.s2r-checked-circle-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n		.s2r-checked-circle-bg {\n			fill: var(--svg-color-bg, black);\n		}\n	</style>\n	<circle class="s2r-checked-circle-bg" cx="10" cy="10" r="8" />\n	<path class="s2r-checked-circle-fg" d="M10.0003 1.6665C5.40033 1.6665 1.66699 5.39984 1.66699 9.99984C1.66699 14.5998 5.40033 18.3332 10.0003 18.3332C14.6003 18.3332 18.3337 14.5998 18.3337 9.99984C18.3337 5.39984 14.6003 1.6665 10.0003 1.6665ZM8.33366 14.1665L4.16699 9.99984L5.34199 8.82484L8.33366 11.8082L14.6587 5.48317L15.8337 6.6665L8.33366 14.1665Z" />\n</svg>\n';
function get_each_context$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i][0];
  child_ctx[51] = list[i][1];
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[55] = list[i][0];
  child_ctx[56] = list[i][1];
  return child_ctx;
}
function create_if_block_11(ctx) {
  let starshelllogo;
  let current;
  starshelllogo = new StarShellLogo({
    props: {
      dim: 48,
      alt: "Click to view general status"
    }
  });
  starshelllogo.$on("click", ctx[35]);
  return {
    c() {
      create_component(starshelllogo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starshelllogo, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starshelllogo, detaching);
    }
  };
}
function create_if_block_10(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "class", "back svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_ARROW_LEFT;
      if (!mounted) {
        dispose = listen(span, "click", ctx[34]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_8(ctx) {
  let span;
  let t1;
  let if_block_anchor;
  let if_block = ctx[18] && create_if_block_9(ctx);
  return {
    c() {
      span = element("span");
      span.textContent = `${ctx[17]}`;
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "name svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[18])
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_9(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `- ${ctx[18]}`;
      attr(span, "class", "symbol svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_5$1(ctx) {
  let span;
  let previous_key = ctx[6];
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block_1$1(ctx);
  let if_block = ctx[5] && create_if_block_6(ctx);
  return {
    c() {
      span = element("span");
      key_block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "network svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      key_block.m(span, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[36]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64 && safe_not_equal(previous_key, previous_key = ctx2[6])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_1$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(span, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      key_block.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block_1$1(ctx) {
  let pfpdisplay;
  let current;
  const pfpdisplay_spread_levels = [{ resource: ctx[6] }, ctx[21](false)];
  let pfpdisplay_props = {};
  for (let i = 0; i < pfpdisplay_spread_levels.length; i += 1) {
    pfpdisplay_props = assign(pfpdisplay_props, pfpdisplay_spread_levels[i]);
  }
  pfpdisplay = new PfpDisplay({ props: pfpdisplay_props });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = dirty[0] & 2097216 ? get_spread_update(pfpdisplay_spread_levels, [
        dirty[0] & 64 && { resource: ctx2[6] },
        dirty[0] & 2097152 && get_spread_object(ctx2[21](false))
      ]) : {};
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let overlayselect;
  let updating_open;
  let current;
  function overlayselect_open_binding(value) {
    ctx[38](value);
  }
  let overlayselect_props = {
    title: "Switch Network",
    $$slots: { rows: [create_rows_slot_1] },
    $$scope: { ctx }
  };
  if (ctx[5] !== void 0) {
    overlayselect_props.open = ctx[5];
  }
  overlayselect = new OverlaySelect({ props: overlayselect_props });
  binding_callbacks.push(() => bind(overlayselect, "open", overlayselect_open_binding));
  return {
    c() {
      create_component(overlayselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayselect_changes = {};
      if (dirty[0] & 160 | dirty[1] & 268435456) {
        overlayselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty[0] & 32) {
        updating_open = true;
        overlayselect_changes.open = ctx2[5];
        add_flush_callback(() => updating_open = false);
      }
      overlayselect.$set(overlayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayselect, detaching);
    }
  };
}
function create_catch_block_1$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[54].entries();
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 160) {
        each_value_1 = ctx2[54].entries();
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_7(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "overlay-select icon svelte-1fcz7ql");
      set_style(span, "--icon-color", "var(--theme-color-primary)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_CHECKED;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_right_slot_1(ctx) {
  let t;
  let if_block = ctx[7] === ctx[55] && create_if_block_7();
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[7] === ctx2[55]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_7();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block_1$3(ctx) {
  let row;
  let current;
  function click_handler_3() {
    return ctx[37](ctx[55]);
  }
  row = new Row({
    props: {
      resource: ctx[56],
      detail: "Default Provider",
      $$slots: { right: [create_right_slot_1] },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_3);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 128 | dirty[1] & 268435456) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_rows_slot_1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1$1,
    then: create_then_block_1$1,
    catch: create_catch_block_1$1,
    value: 54,
    blocks: [, , ,]
  };
  handle_promise(Chains.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block_2$5(ctx) {
  let span;
  let previous_key = ctx[9];
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block$3(ctx);
  let if_block = ctx[8] && create_if_block_3$2(ctx);
  return {
    c() {
      span = element("span");
      key_block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "account svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      key_block.m(span, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[39]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512 && safe_not_equal(previous_key, previous_key = ctx2[9])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$3(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(span, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      key_block.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block$3(ctx) {
  let pfpdisplay;
  let current;
  const pfpdisplay_spread_levels = [{ resource: ctx[9] }, ctx[21](true)];
  let pfpdisplay_props = {};
  for (let i = 0; i < pfpdisplay_spread_levels.length; i += 1) {
    pfpdisplay_props = assign(pfpdisplay_props, pfpdisplay_spread_levels[i]);
  }
  pfpdisplay = new PfpDisplay({ props: pfpdisplay_props });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = dirty[0] & 2097664 ? get_spread_update(pfpdisplay_spread_levels, [
        dirty[0] & 512 && { resource: ctx2[9] },
        dirty[0] & 2097152 && get_spread_object(ctx2[21](true))
      ]) : {};
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_3$2(ctx) {
  let overlayselect;
  let updating_open;
  let current;
  function overlayselect_open_binding_1(value) {
    ctx[41](value);
  }
  let overlayselect_props = {
    title: "Switch Account",
    $$slots: { rows: [create_rows_slot] },
    $$scope: { ctx }
  };
  if (ctx[8] !== void 0) {
    overlayselect_props.open = ctx[8];
  }
  overlayselect = new OverlaySelect({ props: overlayselect_props });
  binding_callbacks.push(() => bind(overlayselect, "open", overlayselect_open_binding_1));
  return {
    c() {
      create_component(overlayselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayselect_changes = {};
      if (dirty[0] & 1280 | dirty[1] & 268435456) {
        overlayselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty[0] & 256) {
        updating_open = true;
        overlayselect_changes.open = ctx2[8];
        add_flush_callback(() => updating_open = false);
      }
      overlayselect.$set(overlayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayselect, detaching);
    }
  };
}
function create_catch_block$c(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$c(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[49].entries();
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1280) {
        each_value = ctx2[49].entries();
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_4$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "overlay-select icon svelte-1fcz7ql");
      set_style(span, "--icon-color", "var(--theme-color-primary)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_CHECKED;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_right_slot(ctx) {
  let t;
  let if_block = ctx[10] === ctx[50] && create_if_block_4$1();
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[10] === ctx2[50]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$1();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_icon_slot(ctx) {
  let pfpdisplay;
  let t;
  let current;
  pfpdisplay = new PfpDisplay({
    props: { dim: 32, resource: ctx[51] }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$9(ctx) {
  let row;
  let current;
  function click_handler_5() {
    return ctx[40](ctx[50]);
  }
  row = new Row({
    props: {
      resource: ctx[51],
      resourcePath: ctx[50],
      detail: ctx[51].extra?.total_fiat_cache ?? "(?)",
      $$slots: {
        icon: [create_icon_slot],
        right: [create_right_slot]
      },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_5);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 1024 | dirty[1] & 268435456) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$c(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_rows_slot(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$c,
    then: create_then_block$c,
    catch: create_catch_block$c,
    value: 49,
    blocks: [, , ,]
  };
  handle_promise(Accounts.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block_1$a(ctx) {
  let close;
  let current;
  close = new Close({});
  close.$on("click", ctx[42]);
  return {
    c() {
      create_component(close.$$.fragment);
    },
    m(target, anchor) {
      mount_component(close, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(close, detaching);
    }
  };
}
function create_if_block$i(ctx) {
  let div;
  let input;
  let t;
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      span = element("span");
      attr(input, "type", "text");
      input.autofocus = ctx[0];
      attr(input, "placeholder", "Search anything: token, account, contact, txn...");
      attr(span, "class", "action svelte-1fcz7ql");
      attr(div, "class", "search svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[3]);
      ctx[44](input);
      append(div, t);
      append(div, span);
      span.innerHTML = SX_ICON_SEARCH;
      if (ctx[0])
        input.focus();
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[43]),
          listen(input, "input", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1) {
        input.autofocus = ctx2[0];
      }
      if (dirty[0] & 8 && input.value !== ctx2[3]) {
        set_input_value(input, ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[44](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$I(ctx) {
  let div3;
  let div2;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span0;
  let div0;
  let t1;
  let div1;
  let t3;
  let span2;
  let span1;
  let t4;
  let t5;
  let t6;
  let current;
  const if_block_creators = [create_if_block_10, create_if_block_11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[11])
      return 0;
    if (!ctx2[12] && !ctx2[13])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[17] && create_if_block_8(ctx);
  let if_block2 = ctx[15] && create_if_block_5$1(ctx);
  let if_block3 = ctx[14] && create_if_block_2$5(ctx);
  let if_block4 = ctx[12] && create_if_block_1$a(ctx);
  let if_block5 = ctx[16] && create_if_block$i(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span0 = element("span");
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      div1.textContent = `${ctx[19]}`;
      t3 = space();
      span2 = element("span");
      span1 = element("span");
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (if_block5)
        if_block5.c();
      attr(div0, "class", "title svelte-1fcz7ql");
      attr(div1, "class", "subtitle svelte-1fcz7ql");
      attr(span0, "class", "main svelte-1fcz7ql");
      attr(span1, "class", "cluster svelte-1fcz7ql");
      attr(span2, "class", "right svelte-1fcz7ql");
      toggle_class(span2, "heightless", !ctx[15] && ctx[12]);
      attr(div2, "class", "top svelte-1fcz7ql");
      attr(div3, "class", "header svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      append(div2, t0);
      append(div2, span0);
      append(span0, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append(span0, t1);
      append(span0, div1);
      append(div2, t3);
      append(div2, span2);
      append(span2, span1);
      if (if_block2)
        if_block2.m(span1, null);
      append(span1, t4);
      if (if_block3)
        if_block3.m(span1, null);
      append(span2, t5);
      if (if_block4)
        if_block4.m(span2, null);
      append(div3, t6);
      if (if_block5)
        if_block5.m(div3, null);
      ctx[45](div3);
      current = true;
    },
    p(ctx2, dirty) {
      if (if_block0)
        if_block0.p(ctx2, dirty);
      if (ctx2[17])
        if_block1.p(ctx2, dirty);
      if (ctx2[15])
        if_block2.p(ctx2, dirty);
      if (ctx2[14])
        if_block3.p(ctx2, dirty);
      if (ctx2[12])
        if_block4.p(ctx2, dirty);
      if (ctx2[16])
        if_block5.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      ctx[45](null);
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let $yw_search;
  let $yw_cancel_search;
  let $yw_thread;
  let $yw_menu_vendor;
  let $yw_overlay_network;
  let $yw_chain;
  let $yw_chain_ref;
  let $yw_overlay_account;
  let $yw_account;
  let $yw_account_ref;
  component_subscribe($$self, yw_search, ($$value) => $$invalidate(46, $yw_search = $$value));
  component_subscribe($$self, yw_cancel_search, ($$value) => $$invalidate(47, $yw_cancel_search = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(48, $yw_thread = $$value));
  component_subscribe($$self, yw_menu_vendor, ($$value) => $$invalidate(4, $yw_menu_vendor = $$value));
  component_subscribe($$self, yw_overlay_network, ($$value) => $$invalidate(5, $yw_overlay_network = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(6, $yw_chain = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(7, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_overlay_account, ($$value) => $$invalidate(8, $yw_overlay_account = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(9, $yw_account = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(10, $yw_account_ref = $$value));
  let { pops = false } = $$props;
  const b_pops = pops;
  let { exits = false } = $$props;
  const b_exits = exits;
  let { plain = false } = $$props;
  const b_plain = plain;
  let { account = false } = $$props;
  const b_account = account;
  let { network = false } = $$props;
  const b_network = network;
  let { search: search2 = false } = $$props;
  const b_search = search2;
  let { title = "" } = $$props;
  const s_title = title;
  let { symbol = "" } = $$props;
  const s_symbol = symbol;
  let { subtitle = "" } = $$props;
  const s_subtitle = subtitle;
  const dispatch = createEventDispatcher();
  const overlay_pfp_props = (b_mirror = false) => ({
    dim: 21,
    bg: "satin",
    genStyle: "font-size:21px; outline:none;",
    rootStyle: `
			padding: 5px 6px;
			border: 2px solid var(--theme-color-border);
			border-radius: ${b_mirror ? "0 4px 4px 0" : "4px 0 0 4px"};
		`.replace(/\s+/g, " ")
  });
  const k_page = getContext("page");
  let dm_header;
  let dm_search;
  let { isSearchScreen = false } = $$props;
  let { search_input = "" } = $$props;
  let s_search = $yw_search;
  yw_search.subscribe((s_value) => {
    if (isSearchScreen && s_value) {
      console.log("search screen and search text");
      $$invalidate(3, s_search = s_value);
      if (dm_search) {
        setTimeout(
          () => {
            dm_search.focus();
          },
          0
        );
      }
    } else if (!s_value) {
      $$invalidate(3, s_search = "");
    }
  });
  function update_search(d_event) {
    if (isSearchScreen) {
      if (!s_search) {
        set_store_value(yw_search, $yw_search = "", $yw_search);
        $yw_cancel_search();
      } else {
        dispatch("search", s_search);
      }
    } else if (s_search) {
      $yw_thread.id;
      const dm_focus = qs(dm_header, ":focus");
      if (dm_focus) {
        dm_focus.blur();
      }
      set_store_value(
        yw_cancel_search,
        $yw_cancel_search = () => {
          $$invalidate(3, s_search = "");
          console.log("stealing focus for cancel search");
          dm_search.focus();
        },
        $yw_cancel_search
      );
      set_store_value(yw_search, $yw_search = s_search, $yw_search);
    }
  }
  const click_handler2 = () => k_page.pop();
  const click_handler_1 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = true, $yw_menu_vendor);
  const click_handler_2 = (d_event) => {
    d_event.stopPropagation();
    set_store_value(yw_overlay_network, $yw_overlay_network = !$yw_overlay_network, $yw_overlay_network);
  };
  const click_handler_3 = (p_chain) => {
    set_store_value(yw_chain_ref, $yw_chain_ref = p_chain, $yw_chain_ref);
    set_store_value(yw_overlay_network, $yw_overlay_network = false, $yw_overlay_network);
  };
  function overlayselect_open_binding(value) {
    $yw_overlay_network = value;
    yw_overlay_network.set($yw_overlay_network);
  }
  const click_handler_4 = (d_event) => {
    d_event.stopPropagation();
    set_store_value(yw_overlay_account, $yw_overlay_account = !$yw_overlay_account, $yw_overlay_account);
  };
  const click_handler_5 = (p_account) => {
    set_store_value(yw_account_ref, $yw_account_ref = p_account, $yw_account_ref);
    set_store_value(yw_overlay_account, $yw_overlay_account = false, $yw_overlay_account);
  };
  function overlayselect_open_binding_1(value) {
    $yw_overlay_account = value;
    yw_overlay_account.set($yw_overlay_account);
  }
  const click_handler_6 = () => dispatch("close");
  function input_input_handler() {
    s_search = this.value;
    $$invalidate(3, s_search);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_search = $$value;
      $$invalidate(2, dm_search);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_header = $$value;
      $$invalidate(1, dm_header);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("pops" in $$props2)
      $$invalidate(24, pops = $$props2.pops);
    if ("exits" in $$props2)
      $$invalidate(25, exits = $$props2.exits);
    if ("plain" in $$props2)
      $$invalidate(26, plain = $$props2.plain);
    if ("account" in $$props2)
      $$invalidate(27, account = $$props2.account);
    if ("network" in $$props2)
      $$invalidate(28, network = $$props2.network);
    if ("search" in $$props2)
      $$invalidate(29, search2 = $$props2.search);
    if ("title" in $$props2)
      $$invalidate(30, title = $$props2.title);
    if ("symbol" in $$props2)
      $$invalidate(31, symbol = $$props2.symbol);
    if ("subtitle" in $$props2)
      $$invalidate(32, subtitle = $$props2.subtitle);
    if ("isSearchScreen" in $$props2)
      $$invalidate(0, isSearchScreen = $$props2.isSearchScreen);
    if ("search_input" in $$props2)
      $$invalidate(33, search_input = $$props2.search_input);
  };
  return [
    isSearchScreen,
    dm_header,
    dm_search,
    s_search,
    $yw_menu_vendor,
    $yw_overlay_network,
    $yw_chain,
    $yw_chain_ref,
    $yw_overlay_account,
    $yw_account,
    $yw_account_ref,
    b_pops,
    b_exits,
    b_plain,
    b_account,
    b_network,
    b_search,
    s_title,
    s_symbol,
    s_subtitle,
    dispatch,
    overlay_pfp_props,
    k_page,
    update_search,
    pops,
    exits,
    plain,
    account,
    network,
    search2,
    title,
    symbol,
    subtitle,
    search_input,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    overlayselect_open_binding,
    click_handler_4,
    click_handler_5,
    overlayselect_open_binding_1,
    click_handler_6,
    input_input_handler,
    input_binding,
    div3_binding
  ];
}
class Header extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$F,
      create_fragment$I,
      safe_not_equal,
      {
        pops: 24,
        exits: 25,
        plain: 26,
        account: 27,
        network: 28,
        search: 29,
        title: 30,
        symbol: 31,
        subtitle: 32,
        isSearchScreen: 0,
        search_input: 33
      },
      null,
      [-1, -1]
    );
  }
}
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_if_block_1$9(ctx) {
  let span2;
  let span0;
  let t0;
  let t1_value = format_ms(ctx[2].value.offset) + "";
  let t1;
  let t2;
  let t3;
  let span1;
  let t4_value = ctx[2].value.message + "";
  let t4;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = text("+");
      t1 = text(t1_value);
      t2 = text("ms:");
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      attr(span0, "class", "offset");
      attr(span1, "class", "message");
      attr(span2, "class", "event");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span0, t0);
      append(span0, t1);
      append(span0, t2);
      append(span2, t3);
      append(span2, span1);
      append(span1, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = format_ms(ctx2[2].value.offset) + ""))
        set_data(t1, t1_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx2[2].value.message + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(span2);
    }
  };
}
function create_if_block$h(ctx) {
  let span;
  let t_value = ctx[2].value + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "string");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[2].value + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$8(ctx) {
  let li;
  let t;
  function select_block_type(ctx2, dirty) {
    if ("string" === ctx2[2].type)
      return create_if_block$h;
    if ("event" === ctx2[2].type)
      return create_if_block_1$9;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      li = element("li");
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (if_block)
        if_block.m(li, null);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(li, t);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_fragment$H(ctx) {
  let div;
  let ol;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "log-container svelte-13jddbg");
      toggle_class(div, "display_none", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ol, null);
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ol, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        toggle_class(div, "display_none", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
class Logger {
  constructor() {
    this._a_items = [];
  }
  get items() {
    return this._a_items;
  }
  set items(a_items) {
    this._a_items = a_items;
  }
  event(s_msg, xt_offset) {
    this._a_items.push({
      type: "event",
      value: { message: s_msg, offset: xt_offset }
    });
    return this;
  }
}
function format_ms(n_ms) {
  return (n_ms / 1e3).toFixed(2).padStart(5, "0");
}
function instance$E($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { hide = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("hide" in $$props2)
      $$invalidate(1, hide = $$props2.hide);
  };
  return [items, hide];
}
class Log extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$H, safe_not_equal, { items: 0, hide: 1 });
  }
}
function create_fragment$G(ctx) {
  let div;
  let img;
  let img_src_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      attr(img, "alt", "StarShell title");
      if (!src_url_equal(img.src, img_src_value = "/media/vendor/title.svg"))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-1htd4i8");
      attr(div, "class", "no-margin title svelte-1htd4i8");
      set_style(div, "width", ctx[0] + "px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  let { width = 180 } = $$props;
  const x_width = width;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
  };
  return [x_width, width];
}
class StarShellTitle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$G, safe_not_equal, { width: 1 });
  }
}
function create_default_slot$j(ctx) {
  let h3;
  let t1;
  let p0;
  let t3;
  let p1;
  let t5;
  let p2;
  let t7;
  let actionsline;
  let current;
  actionsline = new ActionsLine({
    props: {
      cancel: "pop",
      confirm: ["Use anyway", ctx[0]],
      wait: 5e3
    }
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Weak Password Warning";
      t1 = space();
      p0 = element("p");
      p0.textContent = "The password you entered was found on a list of the top ten thousand most commonly used passwords.";
      t3 = space();
      p1 = element("p");
      p1.textContent = "In order to help prevent the loss of funds, you are encouraged to create a strong, unique password.";
      t5 = space();
      p2 = element("p");
      p2.textContent = "How do you want to proceed?";
      t7 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, p0, anchor);
      insert(target, t3, anchor);
      insert(target, p1, anchor);
      insert(target, t5, anchor);
      insert(target, p2, anchor);
      insert(target, t7, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t7);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$F(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 32) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let { attempt_register } = $$props;
  let { weakness } = $$props;
  const k_page = getContext("page");
  function use_anyway() {
    attempt_register();
    k_page.pop();
  }
  $$self.$$set = ($$props2) => {
    if ("attempt_register" in $$props2)
      $$invalidate(1, attempt_register = $$props2.attempt_register);
    if ("weakness" in $$props2)
      $$invalidate(2, weakness = $$props2.weakness);
  };
  return [use_anyway, attempt_register, weakness];
}
class RegisterWeakPassword extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$F, safe_not_equal, { attempt_register: 1, weakness: 2 });
  }
}
function create_if_block_2$4(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[4]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 16)
        set_data(t, ctx2[4]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_2$6(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && ctx[4] && create_if_block_2$4(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "autocomplete", "new-password");
      attr(input, "name", "password");
      attr(input, "placeholder", "Password");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", ctx[10]),
          listen(input, "input", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (!ctx2[2] && ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 20) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$8(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[5]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 32)
        set_data(t, ctx2[5]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_1$8(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && ctx[5] && create_if_block_1$8(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "autocomplete", "new-password");
      attr(input, "name", "verify");
      attr(input, "placeholder", "Password");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", ctx[12]),
          listen(input, "input", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      if (!ctx2[2] && ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 36) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$g(ctx) {
  let pre;
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(ctx[3]);
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_default_slot$i(ctx) {
  let center;
  let div0;
  let starshelllogo;
  let t0;
  let starshelltitle;
  let t1;
  let p2;
  let t3;
  let div1;
  let input;
  let t4;
  let field0;
  let t5;
  let field1;
  let t6;
  let log_1;
  let updating_items;
  let t7;
  let t8;
  let actionsline;
  let current;
  starshelllogo = new StarShellLogo({ props: { dim: 96 } });
  starshelltitle = new StarShellTitle({ props: { width: 150 } });
  field0 = new Field({
    props: {
      key: "password",
      name: "New password",
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      key: "verify-password",
      name: "Verify password",
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  function log_1_items_binding(value) {
    ctx[14](value);
  }
  let log_1_props = {};
  if (ctx[6].items !== void 0) {
    log_1_props.items = ctx[6].items;
  }
  log_1 = new Log({ props: log_1_props });
  binding_callbacks.push(() => bind(log_1, "items", log_1_items_binding));
  let if_block = ctx[3] && create_if_block$g(ctx);
  actionsline = new ActionsLine({
    props: { confirm: ctx[7] }
  });
  return {
    c() {
      center = element("center");
      div0 = element("div");
      create_component(starshelllogo.$$.fragment);
      t0 = space();
      create_component(starshelltitle.$$.fragment);
      t1 = space();
      p2 = element("p");
      p2.textContent = "Create a new password to protect your wallet's data.";
      t3 = space();
      div1 = element("div");
      input = element("input");
      t4 = space();
      create_component(field0.$$.fragment);
      t5 = space();
      create_component(field1.$$.fragment);
      t6 = space();
      create_component(log_1.$$.fragment);
      t7 = space();
      if (if_block)
        if_block.c();
      t8 = space();
      create_component(actionsline.$$.fragment);
      attr(div0, "class", "intro svelte-pdf2wg");
      attr(p2, "class", "narrow svelte-pdf2wg");
      input.hidden = true;
      attr(input, "type", "text");
      attr(input, "name", "username");
      attr(input, "autocomplete", "username");
      input.value = "StarShell Wallet User";
      attr(div1, "class", "form flex-rows");
    },
    m(target, anchor) {
      insert(target, center, anchor);
      append(center, div0);
      mount_component(starshelllogo, div0, null);
      append(div0, t0);
      mount_component(starshelltitle, div0, null);
      append(center, t1);
      append(center, p2);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      append(div1, input);
      append(div1, t4);
      mount_component(field0, div1, null);
      append(div1, t5);
      mount_component(field1, div1, null);
      insert(target, t6, anchor);
      mount_component(log_1, target, anchor);
      insert(target, t7, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t8, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 8388629) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 8388646) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const log_1_changes = {};
      if (!updating_items && dirty & 64) {
        updating_items = true;
        log_1_changes.items = ctx2[6].items;
        add_flush_callback(() => updating_items = false);
      }
      log_1.$set(log_1_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$g(ctx2);
          if_block.c();
          if_block.m(t8.parentNode, t8);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const actionsline_changes = {};
      if (dirty & 128)
        actionsline_changes.confirm = ctx2[7];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      transition_in(starshelltitle.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(log_1.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      transition_out(starshelltitle.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(log_1.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(center);
      destroy_component(starshelllogo);
      destroy_component(starshelltitle);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      destroy_component(field0);
      destroy_component(field1);
      if (detaching)
        detach(t6);
      destroy_component(log_1, detaching);
      if (detaching)
        detach(t7);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t8);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$E(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8388863) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let b_password_acceptable;
  let a_confirm_action;
  const k_page = getContext("page");
  const completed = getContext("completed");
  let sh_phrase = "";
  let sh_verify = "";
  let s_error = "";
  let s_err_password = "";
  let s_err_verify = "";
  let xt_start = 0;
  let k_logger = new Logger();
  function log(s_msg) {
    $$invalidate(6, k_logger = k_logger.event(s_msg, Date.now() - xt_start));
  }
  k_page.on({
    restore() {
      $$invalidate(0, sh_phrase = $$invalidate(1, sh_verify = ""));
    }
  });
  function check_password() {
    if (sh_phrase && !acceptable(sh_phrase)) {
      if (sh_phrase.length < NL_PASSPHRASE_MINIMUM) {
        $$invalidate(4, s_err_password = "Password must be at least 5 characters");
      } else if (sh_phrase.length > NL_PASSPHRASE_MAXIMUM) {
        $$invalidate(4, s_err_password = "Password must be 1024 characters or fewer");
      } else {
        $$invalidate(4, s_err_password = "Password is not acceptable");
      }
      return;
    }
    $$invalidate(4, s_err_password = "");
  }
  function check_verify() {
    if (sh_phrase && !s_err_password && sh_phrase !== sh_verify) {
      $$invalidate(5, s_err_verify = "Passwords do not match");
      return;
    }
    $$invalidate(5, s_err_verify = "");
  }
  const dp_passwords = (async () => {
    const d_res = await fetch("/data/passwords-top-10k.txt");
    const s_list = await d_res.text();
    return s_list.split("\n");
  })();
  async function prepare_register() {
    const a_passwords = await dp_passwords;
    if (a_passwords.includes(sh_phrase)) {
      k_page.push({
        creator: RegisterWeakPassword,
        props: { attempt_register }
      });
    } else {
      await attempt_register();
    }
  }
  let b_busy = false;
  async function attempt_register() {
    if (!b_password_acceptable)
      return 1;
    if (b_busy)
      return 1;
    b_busy = true;
    const exit = () => (b_busy = false, 1);
    $$invalidate(3, s_error = "");
    xt_start = Date.now();
    log("Estimating time to complete");
    {
      const xt_start_est = window.performance.now();
      await Vault.deriveRootBits(ATU8_DUMMY_PHRASE, ATU8_DUMMY_VECTOR, 1 / 50);
      const xt_finish_est = window.performance.now();
      const xt_elapsed_est = xt_finish_est - xt_start_est;
      const xt_estimate = 2 * (2 * (xt_elapsed_est * 50));
      log(`About ${(xt_estimate / 1e3).toFixed(1)} seconds`);
    }
    try {
      await register$1(sh_phrase, log);
    } catch (e_register) {
      if (e_register instanceof AlreadyRegisteredError) {
        $$invalidate(3, s_error = "A passphrase is already registered");
      } else if (e_register instanceof InvalidPassphraseError) {
        $$invalidate(3, s_error = "Invalid passphrase");
      } else {
        $$invalidate(3, s_error = `Unexpected error occurred while attempting to register:
${e_register.stack || e_register.message}`);
      }
      return exit();
    }
    log("Verifying passphrase");
    try {
      await login(sh_phrase, false, log);
    } catch (e_login) {
      $$invalidate(3, s_error = "Failed to verify passphrase immediately after registration");
      await Vault.eraseBase();
      return exit();
    }
    log("Done");
    $$invalidate(3, s_error = "Success");
    if (completed)
      completed(true);
    return exit();
  }
  const blur_handler = () => check_password();
  function input_input_handler() {
    sh_phrase = this.value;
    $$invalidate(0, sh_phrase);
  }
  const blur_handler_1 = () => check_verify();
  function input_input_handler_1() {
    sh_verify = this.value;
    $$invalidate(1, sh_verify);
  }
  function log_1_items_binding(value) {
    if ($$self.$$.not_equal(k_logger.items, value)) {
      k_logger.items = value;
      $$invalidate(6, k_logger);
    }
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $$invalidate(2, b_password_acceptable = !!sh_phrase && sh_phrase === sh_verify && acceptable(sh_phrase));
    }
    if ($$self.$$.dirty & 4) {
      $$invalidate(7, a_confirm_action = ["Continue", prepare_register, !b_password_acceptable]);
    }
  };
  return [
    sh_phrase,
    sh_verify,
    b_password_acceptable,
    s_error,
    s_err_password,
    s_err_verify,
    k_logger,
    a_confirm_action,
    check_password,
    check_verify,
    blur_handler,
    input_input_handler,
    blur_handler_1,
    input_input_handler_1,
    log_1_items_binding
  ];
}
class Register extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$E, safe_not_equal, {});
  }
}
var SX_ICON_CONTACTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M19 5v14H5V5h14m0-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 9c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm6 10H6v-1.53c0-2.5 3.97-3.58 6-3.58s6 1.08 6 3.58V18zm-9.69-2h7.38c-.69-.56-2.38-1.12-3.69-1.12s-3.01.56-3.69 1.12z"/>\n</svg>';
var SX_ICON_CONTRACT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-analytics-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-analytics-fg" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/>\n	<path class="s2r-analytics-fg" d="M7 12h2v5H7zm8-5h2v10h-2zm-4 7h2v3h-2zm0-4h2v2h-2z"/>\n</svg>';
var SX_ICON_LOADING = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M13 5.08A7 7 0 0 1 18.92 11h3.03c-.47-4.72-4.23-8.48-8.95-8.95v3.03zM18.92 13A7 7 0 0 1 13 18.92v3.03c4.72-.47 8.48-4.23 8.95-8.95h-3.03zM11 18.92c-3.39-.49-6-3.4-6-6.92s2.61-6.43 6-6.92V2.05c-5.05.5-9 4.76-9 9.95 0 5.19 3.95 9.45 9 9.95v-3.03z"/>\n</svg>';
function create_catch_block$b(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$b(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding(value) {
    ctx[4](value);
  }
  let starselect_props = {
    id: "asset-select",
    pfpMap: ctx[1],
    placeholder: "Select asset",
    items: ctx[8]
  };
  if (ctx[0] !== void 0) {
    starselect_props.value = ctx[0];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (dirty & 2)
        starselect_changes.pfpMap = ctx2[1];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        starselect_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block$b(ctx) {
  let t;
  return {
    c() {
      t = text("Loading assets...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$D(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$b,
    then: create_then_block$b,
    catch: create_catch_block$b,
    value: 8,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "asset");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let $yw_owner;
  let $yw_chain;
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(5, $yw_owner = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(6, $yw_chain = $$value));
  let { assetRef = "" } = $$props;
  $yw_chain?.id || "*";
  let h_asset_pfps = {};
  async function load_assets() {
    const a_items = [];
    $$invalidate(1, h_asset_pfps = await load_pfps($yw_chain.coins, { dim: 19 }));
    for (const [si_coin, g_coin] of ode($yw_chain.coins)) {
      a_items.push({
        value: Entities.holdingPathFor($yw_owner, si_coin),
        object: g_coin,
        primary: si_coin,
        secondary: g_coin.name,
        pfp: g_coin.pfp
      });
    }
    return a_items;
  }
  let g_item = {
    value: assetRef,
    object: null,
    primary: "",
    secondary: "",
    pfp: ""
  };
  function starselect_value_binding(value) {
    g_item = value;
    $$invalidate(0, g_item);
  }
  $$self.$$set = ($$props2) => {
    if ("assetRef" in $$props2)
      $$invalidate(3, assetRef = $$props2.assetRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        $$invalidate(3, assetRef = g_item?.value || "");
      }
    }
  };
  return [g_item, h_asset_pfps, load_assets, assetRef, starselect_value_binding];
}
class AssetSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$D, safe_not_equal, { assetRef: 3 });
  }
}
var SX_ICON_INCREMENT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14l-6-6z"/>\n</svg>';
var SX_ICON_DECREMENT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"/>\n</svg>';
function create_if_block_1$7(ctx) {
  let span6;
  let span2;
  let span0;
  let t0;
  let t1;
  let t2;
  let span1;
  let t4;
  let span5;
  let span3;
  let t5;
  let span4;
  let mounted;
  let dispose;
  return {
    c() {
      span6 = element("span");
      span2 = element("span");
      span0 = element("span");
      t0 = text("= ");
      t1 = text(ctx[5]);
      t2 = space();
      span1 = element("span");
      span1.textContent = "USD";
      t4 = space();
      span5 = element("span");
      span3 = element("span");
      t5 = space();
      span4 = element("span");
      attr(span0, "class", "amount svelte-18lggj7");
      attr(span1, "class", "fiat svelte-18lggj7");
      attr(span2, "class", "equivalent svelte-18lggj7");
      attr(span3, "class", "icon increment clickable svelte-18lggj7");
      attr(span4, "class", "icon decrement clickable svelte-18lggj7");
      attr(span5, "class", "adjust svelte-18lggj7");
      attr(span6, "class", "occupy svelte-18lggj7");
    },
    m(target, anchor) {
      insert(target, span6, anchor);
      append(span6, span2);
      append(span2, span0);
      append(span0, t0);
      append(span0, t1);
      append(span2, t2);
      append(span2, span1);
      append(span6, t4);
      append(span6, span5);
      append(span5, span3);
      span3.innerHTML = SX_ICON_INCREMENT;
      append(span5, t5);
      append(span5, span4);
      span4.innerHTML = SX_ICON_DECREMENT;
      if (!mounted) {
        dispose = [
          listen(span3, "click", ctx[16]),
          listen(span3, "mousedown", ctx[17]),
          listen(span4, "click", ctx[18]),
          listen(span4, "mousedown", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t1, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(span6);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$f(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$C(ctx) {
  let div;
  let input;
  let input_disabled_value;
  let input_max_value;
  let input_step_value;
  let t0;
  let t1;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_1$7(ctx);
  let if_block1 = ctx[1] && create_if_block$f(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      input.disabled = input_disabled_value = !ctx[2];
      attr(input, "type", "number");
      attr(input, "min", "0");
      attr(input, "max", input_max_value = ctx[4] + "" || "0");
      attr(input, "step", input_step_value = "0." + "0".repeat((ctx[3]?.decimals || 1) - 1) + "1");
      input.required = true;
      input.value = ctx[0];
      attr(input, "class", "svelte-18lggj7");
      toggle_class(input, "invalid", ctx[1]);
      attr(div, "class", "amount-input svelte-18lggj7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[15](input);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[14]),
          listen(input, "input", ctx[7]),
          listen(input, "invalid", invalid_handler)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && input_disabled_value !== (input_disabled_value = !ctx2[2])) {
        input.disabled = input_disabled_value;
      }
      if (dirty & 16 && input_max_value !== (input_max_value = ctx2[4] + "" || "0")) {
        attr(input, "max", input_max_value);
      }
      if (dirty & 8 && input_step_value !== (input_step_value = "0." + "0".repeat((ctx2[3]?.decimals || 1) - 1) + "1")) {
        attr(input, "step", input_step_value);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 2) {
        toggle_class(input, "invalid", ctx2[1]);
      }
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$7(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$f(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[15](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function long_press(f_action) {
  let i_ticker = 0;
  const i_buffer = window.setTimeout(
    () => {
      i_ticker = window.setInterval(f_action, 90);
    },
    1e3
  );
  window.addEventListener(
    "mouseup",
    () => {
      clearTimeout(i_buffer);
      clearInterval(i_ticker);
    },
    { once: true }
  );
}
const invalid_handler = (d) => d.preventDefault();
function instance$z($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_owner;
  let $yw_network_active;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(21, $yw_chain = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(22, $yw_owner = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(23, $yw_network_active = $$value));
  let { value = "" } = $$props;
  const YG_ZERO = new BigNumber(0);
  const YG_ONE = new BigNumber(1);
  let { assetRef = "" } = $$props;
  let { bufferMax = 0 } = $$props;
  let g_asset;
  let yg_max = YG_ZERO;
  let yg_step = YG_ZERO;
  let s_fiat_equivalent = "";
  let si_coingecko = "";
  async function reload_asset() {
    $$invalidate(5, s_fiat_equivalent = "[...]");
    const g_entity = Entities.parseEntityPath(assetRef);
    if ("holding" === g_entity?.type) {
      const si_coin = g_entity.coin;
      $$invalidate(3, g_asset = $yw_chain.coins[si_coin]);
      const g_cached = $yw_network_active.cachedBalance($yw_owner, si_coin);
      if (g_cached && g_cached.timestamp > Date.now() - 5 * XT_MINUTES) {
        $$invalidate(4, yg_max = new BigNumber(g_cached.data.amount).shiftedBy(-g_asset.decimals).minus(new BigNumber(bufferMax)));
      }
      const g_bundle = await $yw_network_active.bankBalance($yw_owner, si_coin);
      if (assetRef === g_bundle.holding) {
        const yg_amount = new BigNumber(g_bundle.balance.amount).shiftedBy(-g_asset.decimals).minus(new BigNumber(bufferMax));
        if (!yg_amount.eq(yg_max)) {
          $$invalidate(4, yg_max = yg_amount);
        }
        const g_coin = $yw_chain.coins[si_coin];
        $$invalidate(13, si_coingecko = g_coin?.extra?.coingecko_id || "");
      }
    } else if ("token" === g_entity?.type) {
      $$invalidate(3, g_asset = null);
    }
    if (g_asset) {
      yg_step = YG_ONE.shiftedBy(-g_asset.decimals);
    } else {
      yg_step = YG_ZERO;
      $$invalidate(4, yg_max = YG_ZERO);
    }
  }
  function capture_input(d_event) {
    $$invalidate(0, value = d_event.target.value);
  }
  function increment() {
    const yg_next = yg_step.plus(value || 0);
    if (yg_next.lte(yg_max)) {
      $$invalidate(0, value = yg_next + "");
    } else {
      $$invalidate(0, value = yg_max + "");
    }
    check_validity();
  }
  function decrement() {
    const yg_next = yg_step.negated().plus(value || 0);
    if (yg_next.gte(0)) {
      if (yg_next.gt(yg_max)) {
        $$invalidate(0, value = yg_max + "");
      } else {
        $$invalidate(0, value = yg_next + "");
      }
    } else {
      $$invalidate(0, value = "0");
    }
    check_validity();
  }
  let { error = "" } = $$props;
  let dm_input;
  function invalidate(s_msg) {
    dm_input.setCustomValidity(s_msg);
    $$invalidate(1, error = s_msg);
  }
  function check_validity() {
    if (!value) {
      return invalidate("Enter an amount");
    }
    let yg_input;
    try {
      yg_input = new BigNumber(value);
    } catch (e_parse) {
      return invalidate("Invalid number");
    }
    if (yg_input.lt(YG_ZERO)) {
      return invalidate("Value must be positive");
    }
    if (yg_input.gt(yg_max)) {
      return invalidate("Insufficient balance");
    }
    $$invalidate(1, error = "");
  }
  let { showValidation = 0 } = $$props;
  const change_handler = () => check_validity();
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_input = $$value;
      $$invalidate(6, dm_input);
    });
  }
  const click_handler2 = () => increment();
  const mousedown_handler = () => long_press(increment);
  const click_handler_1 = () => decrement();
  const mousedown_handler_1 = () => long_press(decrement);
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("assetRef" in $$props2)
      $$invalidate(2, assetRef = $$props2.assetRef);
    if ("bufferMax" in $$props2)
      $$invalidate(11, bufferMax = $$props2.bufferMax);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("showValidation" in $$props2)
      $$invalidate(12, showValidation = $$props2.showValidation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      {
        if (assetRef) {
          void reload_asset();
        } else {
          $$invalidate(3, g_asset = null);
        }
      }
    }
    if ($$self.$$.dirty & 8193) {
      {
        if (si_coingecko) {
          (async () => {
            const h_versus = await CoinGecko.coinsVersus([si_coingecko], "usd", 1 * XT_MINUTES);
            if (si_coingecko in h_versus) {
              $$invalidate(5, s_fiat_equivalent = format_amount(+value * +h_versus[si_coingecko], true));
            } else {
              $$invalidate(5, s_fiat_equivalent = "(?)");
            }
          })();
        } else {
          $$invalidate(5, s_fiat_equivalent = "");
        }
      }
    }
    if ($$self.$$.dirty & 4097) {
      {
        if (showValidation) {
          check_validity();
        } else if (!value) {
          $$invalidate(1, error = "");
        }
      }
    }
  };
  return [
    value,
    error,
    assetRef,
    g_asset,
    yg_max,
    s_fiat_equivalent,
    dm_input,
    capture_input,
    increment,
    decrement,
    check_validity,
    bufferMax,
    showValidation,
    si_coingecko,
    change_handler,
    input_binding,
    click_handler2,
    mousedown_handler,
    click_handler_1,
    mousedown_handler_1
  ];
}
class AmountInput extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$C, safe_not_equal, {
      value: 0,
      assetRef: 2,
      bufferMax: 11,
      error: 1,
      showValidation: 12
    });
  }
}
function create_catch_block$a(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$a(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding(value) {
    ctx[4](value);
  }
  let starselect_props = {
    id: "sender-select",
    placeholder: "Select account",
    secondaryClass: "balance",
    items: ctx[1]
  };
  if (ctx[0] !== void 0) {
    starselect_props.value = ctx[0];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (!updating_value && dirty & 1) {
        updating_value = true;
        starselect_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block$a(ctx) {
  let t;
  return {
    c() {
      t = text("Loading accounts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$B(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$a,
    then: create_then_block$a,
    catch: create_catch_block$a,
    value: 1,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "sender");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let $yw_account_ref;
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(5, $yw_account_ref = $$value));
  let { accountRef = $yw_account_ref } = $$props;
  const mk_account = (p_acc, g_acc) => ({
    value: p_acc,
    primary: g_acc.name,
    secondary: g_acc.extra?.total_fiat_cache || "(?)"
  });
  let g_selected;
  let a_options;
  async function load_accounts() {
    const ks_accounts = await Accounts.read();
    $$invalidate(1, a_options = oderac(ks_accounts.raw, mk_account));
    $$invalidate(0, g_selected = a_options.find((g) => accountRef === g.value));
    return a_options;
  }
  function starselect_value_binding(value) {
    g_selected = value;
    $$invalidate(0, g_selected);
  }
  $$self.$$set = ($$props2) => {
    if ("accountRef" in $$props2)
      $$invalidate(3, accountRef = $$props2.accountRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (g_selected) {
        $$invalidate(3, accountRef = g_selected.value);
      }
    }
  };
  return [g_selected, a_options, load_accounts, accountRef, starselect_value_binding];
}
class SenderSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$B, safe_not_equal, { accountRef: 3 });
  }
}
function create_else_block$6(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Failed to locate contact";
      attr(span, "class", "warning");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$3(ctx) {
  let span;
  let address_1;
  let current;
  address_1 = new Address({ props: { address: ctx[0] } });
  return {
    c() {
      span = element("span");
      create_component(address_1.$$.fragment);
      attr(span, "class", "manual");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(address_1, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const address_1_changes = {};
      if (dirty & 1)
        address_1_changes.address = ctx2[0];
      address_1.$set(address_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(address_1);
    }
  };
}
function create_if_block$e(ctx) {
  let div;
  let span0;
  let t0;
  let span2;
  let span1;
  let t1_value = ctx[1].name + "";
  let t1;
  let t2;
  let address_1;
  let current;
  let if_block = ctx[1] && create_if_block_1$6(ctx);
  address_1 = new Address({
    props: {
      address: Chains.bech32(ctx[1].address)
    }
  });
  return {
    c() {
      div = element("div");
      span0 = element("span");
      if (if_block)
        if_block.c();
      t0 = space();
      span2 = element("span");
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      create_component(address_1.$$.fragment);
      attr(span0, "class", "contact-pfp svelte-1ontxbe");
      attr(span1, "class", "name svelte-1ontxbe");
      attr(span2, "class", "info svelte-1ontxbe");
      attr(div, "class", "contact svelte-1ontxbe");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      if (if_block)
        if_block.m(span0, null);
      append(div, t0);
      append(div, span2);
      append(span2, span1);
      append(span1, t1);
      append(span2, t2);
      mount_component(address_1, span2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if ((!current || dirty & 2) && t1_value !== (t1_value = ctx2[1].name + ""))
        set_data(t1, t1_value);
      const address_1_changes = {};
      if (dirty & 2)
        address_1_changes.address = Chains.bech32(ctx2[1].address);
      address_1.$set(address_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(address_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(address_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_component(address_1);
    }
  };
}
function create_if_block_1$6(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 28,
      resource: ctx[1],
      genStyle: "font-size:18px;"
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = {};
      if (dirty & 2)
        pfpdisplay_changes.resource = ctx2[1];
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_fragment$A(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$e, create_if_block_2$3, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    if (ctx2[0])
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let $yw_family;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(3, $yw_family = $$value));
  let { contact = null } = $$props;
  let g_contact = contact;
  let { address = "" } = $$props;
  async function reload_contacts() {
    const ks_agents = await Agents.read();
    const di_contacts = ks_agents.contacts($yw_family);
    if (!g_contact && address) {
      for (const [, g_contact_each] of di_contacts) {
        if (address === Chains.bech32(g_contact_each.address)) {
          $$invalidate(1, g_contact = g_contact_each);
          break;
        }
      }
    }
  }
  void reload_contacts();
  const f_unsub_agents = subscribe_store("agents", reload_contacts);
  onDestroy(() => {
    f_unsub_agents();
  });
  $$self.$$set = ($$props2) => {
    if ("contact" in $$props2)
      $$invalidate(2, contact = $$props2.contact);
    if ("address" in $$props2)
      $$invalidate(0, address = $$props2.address);
  };
  return [address, g_contact, contact];
}
class InlineContactSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$A, safe_not_equal, { contact: 2, address: 0 });
  }
}
function create_fragment$z(ctx) {
  let div;
  let inlinecontactselection;
  let div_class_value;
  let current;
  inlinecontactselection = new InlineContactSelection({
    props: {
      contact: ctx[1].contact,
      address: ctx[1].value
    }
  });
  return {
    c() {
      div = element("div");
      create_component(inlinecontactselection.$$.fragment);
      attr(div, "class", div_class_value = "item " + ctx[2] + " svelte-pgx3pp");
      toggle_class(div, "display_none", ctx[0] || !ctx[1].value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inlinecontactselection, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const inlinecontactselection_changes = {};
      if (dirty & 2)
        inlinecontactselection_changes.contact = ctx2[1].contact;
      if (dirty & 2)
        inlinecontactselection_changes.address = ctx2[1].value;
      inlinecontactselection.$set(inlinecontactselection_changes);
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "item " + ctx2[2] + " svelte-pgx3pp")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & 7) {
        toggle_class(div, "display_none", ctx2[0] || !ctx2[1].value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinecontactselection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontactselection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inlinecontactselection);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let { isActive = false } = $$props;
  let { isFirst = false } = $$props;
  let { isHover = false } = $$props;
  let { isSelectable = false } = $$props;
  let { getOptionLabel = void 0 } = $$props;
  let { item } = $$props;
  let { filterText = "" } = $$props;
  let itemClasses = "";
  $$self.$$set = ($$props2) => {
    if ("isActive" in $$props2)
      $$invalidate(0, isActive = $$props2.isActive);
    if ("isFirst" in $$props2)
      $$invalidate(3, isFirst = $$props2.isFirst);
    if ("isHover" in $$props2)
      $$invalidate(4, isHover = $$props2.isHover);
    if ("isSelectable" in $$props2)
      $$invalidate(5, isSelectable = $$props2.isSelectable);
    if ("getOptionLabel" in $$props2)
      $$invalidate(6, getOptionLabel = $$props2.getOptionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("filterText" in $$props2)
      $$invalidate(7, filterText = $$props2.filterText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 57) {
      {
        const classes = [];
        if (isActive) {
          classes.push("active");
        }
        if (isFirst) {
          classes.push("first");
        }
        if (isHover) {
          classes.push("hover");
        }
        if (!isSelectable) {
          classes.push("notSelectable");
        }
        $$invalidate(2, itemClasses = classes.join(" "));
      }
    }
  };
  return [
    isActive,
    item,
    itemClasses,
    isFirst,
    isHover,
    isSelectable,
    getOptionLabel,
    filterText
  ];
}
class RecipientSelectItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$z, safe_not_equal, {
      isActive: 0,
      isFirst: 3,
      isHover: 4,
      isSelectable: 5,
      getOptionLabel: 6,
      item: 1,
      filterText: 7
    });
  }
}
function create_fragment$y(ctx) {
  let div;
  let inlinecontactselection;
  let current;
  inlinecontactselection = new InlineContactSelection({
    props: {
      contact: ctx[0].contact,
      address: ctx[0].value
    }
  });
  return {
    c() {
      div = element("div");
      create_component(inlinecontactselection.$$.fragment);
      attr(div, "class", "selection svelte-aitqlq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inlinecontactselection, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const inlinecontactselection_changes = {};
      if (dirty & 1)
        inlinecontactselection_changes.contact = ctx2[0].contact;
      if (dirty & 1)
        inlinecontactselection_changes.address = ctx2[0].value;
      inlinecontactselection.$set(inlinecontactselection_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinecontactselection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontactselection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inlinecontactselection);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let { getSelectionLabel } = $$props;
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("getSelectionLabel" in $$props2)
      $$invalidate(1, getSelectionLabel = $$props2.getSelectionLabel);
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item, getSelectionLabel];
}
class RecipientSelectSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$y, safe_not_equal, { getSelectionLabel: 1, item: 0 });
  }
}
function create_catch_block$9(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$9(ctx) {
  let select_1;
  let updating_filterText;
  let updating_listOpen;
  let current;
  function select_1_filterText_binding(value) {
    ctx[14](value);
  }
  function select_1_listOpen_binding(value) {
    ctx[15](value);
  }
  let select_1_props = {
    id: "recipient-select",
    placeholder: "Address or contact",
    listOffset: 1,
    isClearable: !!ctx[0],
    isCreatable: !!ctx[3],
    Item: RecipientSelectItem,
    Selection: RecipientSelectSelection,
    items: ctx[8],
    value: ctx[4],
    noOptionsMessage: "Stop typing in the address. \n Use copy/paste instead!",
    containerClasses: ctx[1] ? "invalid" : ""
  };
  if (ctx[2] !== void 0) {
    select_1_props.filterText = ctx[2];
  }
  if (ctx[6] !== void 0) {
    select_1_props.listOpen = ctx[6];
  }
  select_1 = new Select({ props: select_1_props });
  binding_callbacks.push(() => bind(select_1, "filterText", select_1_filterText_binding));
  binding_callbacks.push(() => bind(select_1, "listOpen", select_1_listOpen_binding));
  select_1.$on("select", ctx[10]);
  select_1.$on("clear", ctx[11]);
  return {
    c() {
      create_component(select_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_1_changes = {};
      if (dirty & 1)
        select_1_changes.isClearable = !!ctx2[0];
      if (dirty & 8)
        select_1_changes.isCreatable = !!ctx2[3];
      if (dirty & 16)
        select_1_changes.value = ctx2[4];
      if (dirty & 2)
        select_1_changes.containerClasses = ctx2[1] ? "invalid" : "";
      if (!updating_filterText && dirty & 4) {
        updating_filterText = true;
        select_1_changes.filterText = ctx2[2];
        add_flush_callback(() => updating_filterText = false);
      }
      if (!updating_listOpen && dirty & 64) {
        updating_listOpen = true;
        select_1_changes.listOpen = ctx2[6];
        add_flush_callback(() => updating_listOpen = false);
      }
      select_1.$set(select_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_1, detaching);
    }
  };
}
function create_pending_block$9(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contacts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$d(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$x(ctx) {
  let div;
  let t;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$9,
    then: create_then_block$9,
    catch: create_catch_block$9,
    value: 8,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  let if_block = ctx[1] && create_if_block$d(ctx);
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "sender svelte-1rmr362");
      toggle_class(div, "hide-cursor", ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[16](div);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (ctx[1]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$d(ctx);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32) {
        toggle_class(div, "hide-cursor", ctx[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      if (if_block)
        if_block.d();
      ctx[16](null);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_family;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(13, $yw_chain = $$value));
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(17, $yw_family = $$value));
  let { address = "" } = $$props;
  const sa_input = address;
  let { error = "" } = $$props;
  let s_manual_input;
  let g_item_select;
  let a_contacts;
  const contact_to_option = (g) => ({
    value: Chains.bech32(g.address),
    label: g.name,
    contact: g
  });
  async function load_contacts() {
    const ks_agents = await Agents.read();
    const a_options = [{ value: "", label: "", contact: null }];
    $$invalidate(8, a_contacts = [...ks_agents.contacts($yw_family)]);
    for (const [, g_contact] of a_contacts) {
      const g_option = contact_to_option(g_contact);
      const sa_contact = Chains.bech32(g_contact.address);
      if (sa_input && sa_contact === sa_input) {
        $$invalidate(4, g_item_select = g_option);
      }
      a_options.push(g_option);
    }
    return a_options;
  }
  function select(d_event) {
    $$invalidate(0, address = d_event.detail.value);
    $$invalidate(1, error = "");
  }
  function clear() {
    $$invalidate(0, address = "");
  }
  let s_accepted_input = "";
  let b_hide_cursor = false;
  let b_list_open = false;
  function check_manual_input() {
    $$invalidate(3, s_accepted_input = "");
    if (!$yw_chain) {
      $$invalidate(1, error = "No chain set");
    } else if (!Chains.isValidAddressFor($yw_chain, s_manual_input, "acc")) {
      $$invalidate(1, error = "Invalid address for this chain");
    } else {
      $$invalidate(1, error = "");
      for (const [, g_contact] of a_contacts) {
        if (s_manual_input === Chains.bech32(g_contact.address)) {
          $$invalidate(2, s_manual_input = "");
          $$invalidate(4, g_item_select = contact_to_option(g_contact));
          $$invalidate(6, b_list_open = false);
          $$invalidate(5, b_hide_cursor = true);
          return;
        }
      }
      $$invalidate(3, s_accepted_input = s_manual_input);
      setTimeout(
        () => {
          qs(dm_sender, ".manual>.address").click();
          $$invalidate(6, b_list_open = false);
        },
        0
      );
    }
  }
  let dm_sender;
  let { showValidation = 0 } = $$props;
  function select_1_filterText_binding(value) {
    s_manual_input = value;
    $$invalidate(2, s_manual_input);
  }
  function select_1_listOpen_binding(value) {
    b_list_open = value;
    $$invalidate(6, b_list_open);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_sender = $$value;
      $$invalidate(7, dm_sender);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("address" in $$props2)
      $$invalidate(0, address = $$props2.address);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("showValidation" in $$props2)
      $$invalidate(12, showValidation = $$props2.showValidation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      {
        $$invalidate(5, b_hide_cursor = false);
        if (s_manual_input) {
          check_manual_input();
        } else {
          $$invalidate(5, b_hide_cursor = !!s_accepted_input);
          $$invalidate(3, s_accepted_input = "");
        }
      }
    }
    if ($$self.$$.dirty & 12293) {
      {
        if (showValidation) {
          if (!address) {
            if (s_manual_input) {
              check_manual_input();
            } else {
              $$invalidate(1, error = "Enter a recipient");
            }
          } else if (!Chains.isValidAddressFor($yw_chain, address, "acc")) {
            $$invalidate(1, error = "Invalid address for this chain");
          } else {
            $$invalidate(1, error = "");
          }
        } else if (!address) {
          $$invalidate(1, error = "");
        }
      }
    }
  };
  return [
    address,
    error,
    s_manual_input,
    s_accepted_input,
    g_item_select,
    b_hide_cursor,
    b_list_open,
    dm_sender,
    a_contacts,
    load_contacts,
    select,
    clear,
    showValidation,
    $yw_chain,
    select_1_filterText_binding,
    select_1_listOpen_binding,
    div_binding
  ];
}
class RecipientSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$x, safe_not_equal, { address: 0, error: 1, showValidation: 12 });
  }
}
function create_default_slot_6$3(ctx) {
  let div0;
  let t0_value = (ctx[1]?.name || "[...]") + "";
  let t0;
  let t1;
  let div1;
  let t2_value = (ctx[1]?.extra?.total_fiat_cache || "(?)") + "";
  let t2;
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = (ctx2[1]?.name || "[...]") + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = (ctx2[1]?.extra?.total_fiat_cache || "(?)") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
    }
  };
}
function create_default_slot_5$4(ctx) {
  let div0;
  let t0_value = (ctx[2] || "[...]") + "";
  let t0;
  let t1;
  let div1;
  let address;
  let current;
  address = new Address({
    props: { address: ctx[9] }
  });
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      create_component(address.$$.fragment);
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      mount_component(address, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 4) && t0_value !== (t0_value = (ctx2[2] || "[...]") + ""))
        set_data(t0, t0_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_component(address);
    }
  };
}
function create_else_block_3(ctx) {
  let t;
  return {
    c() {
      t = text("=[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$1(ctx) {
  let t_value = format_fiat(new BigNumber(ctx[8]).times(ctx[3]).toNumber()) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = format_fiat(new BigNumber(ctx2[8]).times(ctx2[3]).toNumber()) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$4(ctx) {
  let div0;
  let t3;
  let div1;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_3$1;
    return create_else_block_3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${ctx[8]}  ${ctx[7]}`;
      t3 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_else_block_2(ctx) {
  let t;
  return {
    c() {
      t = text("=[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$2(ctx) {
  let t_value = format_fiat(new BigNumber(ctx[10]).times(ctx[3]).toNumber()) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = format_fiat(new BigNumber(ctx2[10]).times(ctx2[3]).toNumber()) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$5(ctx) {
  let div0;
  let t3;
  let div1;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_2$2;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${ctx[10]}  ${ctx[7]}`;
      t3 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_else_block_1(ctx) {
  let t;
  return {
    c() {
      t = text("=[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$5(ctx) {
  let t_value = format_fiat(new BigNumber(ctx[4]).times(ctx[3]).toNumber()) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 24 && t_value !== (t_value = format_fiat(new BigNumber(ctx2[4]).times(ctx2[3]).toNumber()) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let div0;
  let t0_value = (ctx[4] || "[...]") + "";
  let t0;
  let t1;
  let t2;
  let t3;
  let div1;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_1$5;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(ctx[7]);
      t3 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      append(div0, t1);
      append(div0, t2);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t0_value !== (t0_value = (ctx2[4] || "[...]") + ""))
        set_data(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_else_block$5(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "(empty)";
      attr(span, "class", "empty-memo svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block$c(ctx) {
  let textarea;
  return {
    c() {
      textarea = element("textarea");
      textarea.disabled = true;
      textarea.value = ctx[0];
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        textarea.value = ctx2[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let if_block_anchor;
  function select_block_type_3(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block$c;
    return create_else_block$5;
  }
  let current_block_type = select_block_type_3(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot$h(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let hr0;
  let t2;
  let field1;
  let t3;
  let hr1;
  let t4;
  let field2;
  let t5;
  let hr2;
  let t6;
  let field3;
  let t7;
  let hr3;
  let t8;
  let field4;
  let t9;
  let hr4;
  let t10;
  let field5;
  let t11;
  let actionsline;
  let current;
  header = new Header({
    props: {
      pops: true,
      exits: true,
      title: "Sending",
      symbol: ctx[7],
      subtitle: ctx[5].name
    }
  });
  header.$on("close", ctx[17]);
  field0 = new Field({
    props: {
      short: true,
      key: "sender",
      name: "From",
      $$slots: { default: [create_default_slot_6$3] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      short: true,
      key: "recipient",
      name: "To",
      $$slots: { default: [create_default_slot_5$4] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      short: true,
      key: "amount",
      name: "Amount",
      $$slots: { default: [create_default_slot_4$4] },
      $$scope: { ctx }
    }
  });
  field3 = new Field({
    props: {
      short: true,
      key: "fee-review",
      name: "Fee",
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      short: true,
      key: "total",
      name: "Total",
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    }
  });
  field5 = new Field({
    props: {
      short: true,
      key: "memo",
      name: "Memo",
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      back: true,
      confirm: ["Approve", ctx[18]]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      hr0 = element("hr");
      t2 = space();
      create_component(field1.$$.fragment);
      t3 = space();
      hr1 = element("hr");
      t4 = space();
      create_component(field2.$$.fragment);
      t5 = space();
      hr2 = element("hr");
      t6 = space();
      create_component(field3.$$.fragment);
      t7 = space();
      hr3 = element("hr");
      t8 = space();
      create_component(field4.$$.fragment);
      t9 = space();
      hr4 = element("hr");
      t10 = space();
      create_component(field5.$$.fragment);
      t11 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      insert(target, hr0, anchor);
      insert(target, t2, anchor);
      mount_component(field1, target, anchor);
      insert(target, t3, anchor);
      insert(target, hr1, anchor);
      insert(target, t4, anchor);
      mount_component(field2, target, anchor);
      insert(target, t5, anchor);
      insert(target, hr2, anchor);
      insert(target, t6, anchor);
      mount_component(field3, target, anchor);
      insert(target, t7, anchor);
      insert(target, hr3, anchor);
      insert(target, t8, anchor);
      mount_component(field4, target, anchor);
      insert(target, t9, anchor);
      insert(target, hr4, anchor);
      insert(target, t10, anchor);
      mount_component(field5, target, anchor);
      insert(target, t11, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & 32)
        header_changes.subtitle = ctx2[5].name;
      header.$set(header_changes);
      const field0_changes = {};
      if (dirty & 16777218) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 16777220) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 16777224) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const field3_changes = {};
      if (dirty & 16777224) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty & 16777240) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      const field5_changes = {};
      if (dirty & 16777217) {
        field5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field5.$set(field5_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(field5.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(field5.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(hr0);
      if (detaching)
        detach(t2);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(hr1);
      if (detaching)
        detach(t4);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(hr2);
      if (detaching)
        detach(t6);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(hr3);
      if (detaching)
        detach(t8);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t9);
      if (detaching)
        detach(hr4);
      if (detaching)
        detach(t10);
      destroy_component(field5, detaching);
      if (detaching)
        detach(t11);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$w(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "SendNative",
      slides: true,
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 16777279) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let s_total;
  let $yw_navigator;
  let $yw_network_active;
  let $yw_chain;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(21, $yw_navigator = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(22, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(5, $yw_chain = $$value));
  const k_page = getContext("page");
  let { coin } = $$props;
  const si_coin = coin;
  const g_coin = $yw_chain.coins[si_coin];
  let { accountRef } = $$props;
  let g_account;
  let sa_sender;
  let { amount } = $$props;
  const s_amount = amount;
  let { recipient } = $$props;
  const sa_recipient = recipient;
  let s_recipient_title = "";
  let g_contact;
  let { fee } = $$props;
  const s_fee = fee;
  let { memo } = $$props;
  let x_worth = 0;
  (async (fk_resolve) => {
    const si_coingecko = g_coin.extra?.coingecko_id || "";
    if (si_coingecko) {
      const h_versus = await CoinGecko.coinsVersus([si_coingecko], "usd", 0);
      $$invalidate(3, x_worth = h_versus[si_coingecko]);
    }
  })();
  (async () => {
    const ks_accounts = await Accounts.read();
    $$invalidate(1, g_account = ks_accounts.at(accountRef));
    sa_sender = Chains.addressFor(g_account.pubkey);
    const p_contact = Agents.pathForContact(sa_recipient);
    g_contact = await Agents.getContact(p_contact);
    $$invalidate(2, s_recipient_title = g_contact?.name || "");
  })();
  async function approve() {
    const xg_amount = BigInt(new BigNumber(s_amount).shiftedBy(g_coin.decimals).toString());
    const g_attempt = await $yw_network_active.bankSend(sa_sender, sa_recipient, si_coin, xg_amount, memo);
    await Events.insert({
      type: "pending",
      time: Date.now(),
      data: g_attempt
    });
    k_page.reset();
    void $yw_navigator.activateThread(ThreadId.HISTORY);
  }
  const close_handler = () => k_page.reset();
  const func = () => approve();
  $$self.$$set = ($$props2) => {
    if ("coin" in $$props2)
      $$invalidate(12, coin = $$props2.coin);
    if ("accountRef" in $$props2)
      $$invalidate(13, accountRef = $$props2.accountRef);
    if ("amount" in $$props2)
      $$invalidate(14, amount = $$props2.amount);
    if ("recipient" in $$props2)
      $$invalidate(15, recipient = $$props2.recipient);
    if ("fee" in $$props2)
      $$invalidate(16, fee = $$props2.fee);
    if ("memo" in $$props2)
      $$invalidate(0, memo = $$props2.memo);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 65536) {
      $$invalidate(4, s_total = new BigNumber(s_amount).plus(fee).toString());
    }
  };
  return [
    memo,
    g_account,
    s_recipient_title,
    x_worth,
    s_total,
    $yw_chain,
    k_page,
    si_coin,
    s_amount,
    sa_recipient,
    s_fee,
    approve,
    coin,
    accountRef,
    amount,
    recipient,
    fee,
    close_handler,
    func
  ];
}
class SendNative extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$w, safe_not_equal, {
      coin: 12,
      accountRef: 13,
      amount: 14,
      recipient: 15,
      fee: 16,
      memo: 0
    });
  }
}
function create_default_slot_9(ctx) {
  let senderselect;
  let updating_accountRef;
  let current;
  function senderselect_accountRef_binding(value) {
    ctx[38](value);
  }
  let senderselect_props = {};
  if (ctx[13] !== void 0) {
    senderselect_props.accountRef = ctx[13];
  }
  senderselect = new SenderSelect({ props: senderselect_props });
  binding_callbacks.push(() => bind(senderselect, "accountRef", senderselect_accountRef_binding));
  return {
    c() {
      create_component(senderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(senderselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const senderselect_changes = {};
      if (!updating_accountRef && dirty[0] & 8192) {
        updating_accountRef = true;
        senderselect_changes.accountRef = ctx2[13];
        add_flush_callback(() => updating_accountRef = false);
      }
      senderselect.$set(senderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(senderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(senderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(senderselect, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let recipientselect;
  let updating_error;
  let updating_address;
  let current;
  function recipientselect_error_binding(value) {
    ctx[39](value);
  }
  function recipientselect_address_binding(value) {
    ctx[40](value);
  }
  let recipientselect_props = {
    showValidation: ctx[4]
  };
  if (ctx[6] !== void 0) {
    recipientselect_props.error = ctx[6];
  }
  if (ctx[0] !== void 0) {
    recipientselect_props.address = ctx[0];
  }
  recipientselect = new RecipientSelect({ props: recipientselect_props });
  binding_callbacks.push(() => bind(recipientselect, "error", recipientselect_error_binding));
  binding_callbacks.push(() => bind(recipientselect, "address", recipientselect_address_binding));
  return {
    c() {
      create_component(recipientselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipientselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recipientselect_changes = {};
      if (dirty[0] & 16)
        recipientselect_changes.showValidation = ctx2[4];
      if (!updating_error && dirty[0] & 64) {
        updating_error = true;
        recipientselect_changes.error = ctx2[6];
        add_flush_callback(() => updating_error = false);
      }
      if (!updating_address && dirty[0] & 1) {
        updating_address = true;
        recipientselect_changes.address = ctx2[0];
        add_flush_callback(() => updating_address = false);
      }
      recipientselect.$set(recipientselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipientselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipientselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipientselect, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let div;
  let checkboxfield;
  let updating_checked;
  let current;
  function checkboxfield_checked_binding(value) {
    ctx[41](value);
  }
  let checkboxfield_props = {
    id: "save-contact",
    $$slots: { default: [create_default_slot_7$1] },
    $$scope: { ctx }
  };
  if (ctx[5] !== void 0) {
    checkboxfield_props.checked = ctx[5];
  }
  checkboxfield = new CheckboxField({ props: checkboxfield_props });
  binding_callbacks.push(() => bind(checkboxfield, "checked", checkboxfield_checked_binding));
  return {
    c() {
      div = element("div");
      create_component(checkboxfield.$$.fragment);
      attr(div, "class", "new-address svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkboxfield, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const checkboxfield_changes = {};
      if (dirty[1] & 134217728) {
        checkboxfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_checked && dirty[0] & 32) {
        updating_checked = true;
        checkboxfield_changes.checked = ctx2[5];
        add_flush_callback(() => updating_checked = false);
      }
      checkboxfield.$set(checkboxfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkboxfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(checkboxfield);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let t;
  return {
    c() {
      t = text("Save to contacts");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$2(ctx) {
  let span2;
  let span0;
  let raw_value = ctx[17].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[17].text + "";
  let t1;
  let span2_class_value;
  let t2;
  let if_block_anchor;
  let current;
  let if_block = ctx[9] && create_if_block_5(ctx);
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span0, "class", "icon svelte-ipiv9p");
      attr(span1, "class", "text svelte-ipiv9p");
      attr(span2, "class", span2_class_value = "status " + ctx[3] + " svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      span0.innerHTML = raw_value;
      append(span2, t0);
      append(span2, span1);
      append(span1, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 131072) && raw_value !== (raw_value = ctx2[17].icon + ""))
        span0.innerHTML = raw_value;
      if ((!current || dirty[0] & 131072) && t1_value !== (t1_value = ctx2[17].text + ""))
        set_data(t1, t1_value);
      if (!current || dirty[0] & 8 && span2_class_value !== (span2_class_value = "status " + ctx2[3] + " svelte-ipiv9p")) {
        attr(span2, "class", span2_class_value);
      }
      if (ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let field;
  let current;
  field = new Field({
    props: {
      short: true,
      slides: true,
      key: "new-contact-name",
      name: "Contact Name",
      $$slots: { default: [create_default_slot_5$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty[0] & 256 | dirty[1] & 134217728) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[8]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256)
        set_data(t, ctx2[8]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_5$3(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[8] && create_if_block_4(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "id", "new-contact-name-value");
      attr(input, "type", "text");
      toggle_class(input, "invalid", ctx[8]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[24]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256) {
        toggle_class(input, "invalid", ctx2[8]);
      }
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_4$3(ctx) {
  let assetselect;
  let updating_assetRef;
  let current;
  function assetselect_assetRef_binding(value) {
    ctx[42](value);
  }
  let assetselect_props = {};
  if (ctx[1] !== void 0) {
    assetselect_props.assetRef = ctx[1];
  }
  assetselect = new AssetSelect({ props: assetselect_props });
  binding_callbacks.push(() => bind(assetselect, "assetRef", assetselect_assetRef_binding));
  return {
    c() {
      create_component(assetselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(assetselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const assetselect_changes = {};
      if (!updating_assetRef && dirty[0] & 2) {
        updating_assetRef = true;
        assetselect_changes.assetRef = ctx2[1];
        add_flush_callback(() => updating_assetRef = false);
      }
      assetselect.$set(assetselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(assetselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(assetselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(assetselect, detaching);
    }
  };
}
function create_default_slot_3$4(ctx) {
  let amountinput;
  let updating_error;
  let updating_value;
  let current;
  function amountinput_error_binding(value) {
    ctx[43](value);
  }
  function amountinput_value_binding(value) {
    ctx[44](value);
  }
  let amountinput_props = {
    bufferMax: ctx[10] ? x_fee : 0,
    assetRef: ctx[1],
    showValidation: ctx[4]
  };
  if (ctx[7] !== void 0) {
    amountinput_props.error = ctx[7];
  }
  if (ctx[2] !== void 0) {
    amountinput_props.value = ctx[2];
  }
  amountinput = new AmountInput({ props: amountinput_props });
  binding_callbacks.push(() => bind(amountinput, "error", amountinput_error_binding));
  binding_callbacks.push(() => bind(amountinput, "value", amountinput_value_binding));
  return {
    c() {
      create_component(amountinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(amountinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const amountinput_changes = {};
      if (dirty[0] & 1024)
        amountinput_changes.bufferMax = ctx2[10] ? x_fee : 0;
      if (dirty[0] & 2)
        amountinput_changes.assetRef = ctx2[1];
      if (dirty[0] & 16)
        amountinput_changes.showValidation = ctx2[4];
      if (!updating_error && dirty[0] & 128) {
        updating_error = true;
        amountinput_changes.error = ctx2[7];
        add_flush_callback(() => updating_error = false);
      }
      if (!updating_value && dirty[0] & 4) {
        updating_value = true;
        amountinput_changes.value = ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      amountinput.$set(amountinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(amountinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(amountinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(amountinput, detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let span2;
  let span0;
  let t1;
  let span1;
  let t2;
  let t3;
  let t4;
  let t5;
  let span4;
  let span3;
  let mounted;
  let dispose;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      span0.textContent = "Balance";
      t1 = space();
      span1 = element("span");
      t2 = text(ctx[11]);
      t3 = space();
      t4 = text(ctx[20]);
      t5 = space();
      span4 = element("span");
      span3 = element("span");
      span3.textContent = "USE MAX";
      attr(span0, "class", "label svelte-ipiv9p");
      attr(span1, "class", "amount svelte-ipiv9p");
      attr(span2, "class", "balance svelte-ipiv9p");
      attr(span3, "class", "link svelte-ipiv9p");
      toggle_class(span3, "disabled", ctx[19]);
      attr(span4, "class", "use-max");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span2, t1);
      append(span2, span1);
      append(span1, t2);
      append(span1, t3);
      append(span1, t4);
      insert(target, t5, anchor);
      insert(target, span4, anchor);
      append(span4, span3);
      if (!mounted) {
        dispose = listen(span3, "click", ctx[45]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data(t2, ctx2[11]);
      if (dirty[0] & 1048576)
        set_data(t4, ctx2[20]);
      if (dirty[0] & 524288) {
        toggle_class(span3, "disabled", ctx2[19]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(span4);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$4(ctx) {
  let span;
  let if_block = ctx[1] && create_if_block_2$1(ctx);
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      attr(span, "class", "balance-line svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$1(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block)
        if_block.d();
    }
  };
}
function create_default_slot_1$6(ctx) {
  let div0;
  let t2;
  let div1;
  let t3;
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${x_fee} SCRT`;
      t2 = space();
      div1 = element("div");
      t3 = text(ctx[18]);
      attr(div0, "class", "fee-amount");
      attr(div1, "class", "fee-fiat svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 262144)
        set_data(t3, ctx2[18]);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
    }
  };
}
function create_post_slot(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "manual-fee svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$4(ctx) {
  let span;
  let span_transition;
  let current;
  return {
    c() {
      span = element("span");
      span.textContent = "Caution: Memos are NOT private";
      attr(span, "class", "disclaimer svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, slide, { duration: 350, delay: 400 }, true);
        span_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!span_transition)
        span_transition = create_bidirectional_transition(span, slide, { duration: 350, delay: 400 }, false);
      span_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_if_block$b(ctx) {
  let div;
  let textarea;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      attr(textarea, "class", "svelte-ipiv9p");
      attr(div, "class", "input");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      set_input_value(textarea, ctx[15]);
      current = true;
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[47]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32768) {
        set_input_value(textarea, ctx2[15]);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 350 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 350 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$g(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let field1;
  let t2;
  let field2;
  let t3;
  let t4;
  let hr0;
  let t5;
  let field3;
  let t6;
  let field4;
  let t7;
  let field5;
  let t8;
  let hr1;
  let t9;
  let field6;
  let t10;
  let hr2;
  let t11;
  let div1;
  let div0;
  let span0;
  let t12;
  let span1;
  let t14;
  let t15;
  let t16;
  let actionsline;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: {
      pops: true,
      title: ctx[21] ? "Transferring" : "Sending",
      symbol: ctx[21] ? ctx[21].symbol : "",
      subtitle: ctx[12]?.name || "?"
    }
  });
  field0 = new Field({
    props: {
      short: true,
      key: "sender-select",
      name: "From",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      short: true,
      key: "recipient-select",
      name: "To",
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      short: true,
      key: "recipient-status",
      name: "",
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[9] && ctx[5] && create_if_block_3(ctx);
  field3 = new Field({
    props: {
      short: true,
      key: "asset-select",
      name: "Asset",
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      short: true,
      key: "amount",
      name: "Amount",
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  field5 = new Field({
    props: {
      short: true,
      key: "balance",
      name: "",
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  field6 = new Field({
    props: {
      short: true,
      key: "fee",
      name: "Fee",
      $$slots: {
        post: [create_post_slot],
        default: [create_default_slot_1$6]
      },
      $$scope: { ctx }
    }
  });
  let if_block1 = ctx[14] && create_if_block_1$4();
  let if_block2 = ctx[14] && create_if_block$b(ctx);
  actionsline = new ActionsLine({
    props: {
      cancel: "pop",
      confirm: ["Next", ctx[48], !ctx[16]]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      create_component(field1.$$.fragment);
      t2 = space();
      create_component(field2.$$.fragment);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      hr0 = element("hr");
      t5 = space();
      create_component(field3.$$.fragment);
      t6 = space();
      create_component(field4.$$.fragment);
      t7 = space();
      create_component(field5.$$.fragment);
      t8 = space();
      hr1 = element("hr");
      t9 = space();
      create_component(field6.$$.fragment);
      t10 = space();
      hr2 = element("hr");
      t11 = space();
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t12 = space();
      span1 = element("span");
      span1.textContent = "Add memo";
      t14 = space();
      if (if_block1)
        if_block1.c();
      t15 = space();
      if (if_block2)
        if_block2.c();
      t16 = space();
      create_component(actionsline.$$.fragment);
      attr(span0, "class", "icon dropdown svelte-ipiv9p");
      attr(span1, "class", "text");
      attr(div0, "class", "title clickable svelte-ipiv9p");
      attr(div1, "class", "memo svelte-ipiv9p");
      toggle_class(div1, "expanded", ctx[14]);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      mount_component(field1, target, anchor);
      insert(target, t2, anchor);
      mount_component(field2, target, anchor);
      insert(target, t3, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t4, anchor);
      insert(target, hr0, anchor);
      insert(target, t5, anchor);
      mount_component(field3, target, anchor);
      insert(target, t6, anchor);
      mount_component(field4, target, anchor);
      insert(target, t7, anchor);
      mount_component(field5, target, anchor);
      insert(target, t8, anchor);
      insert(target, hr1, anchor);
      insert(target, t9, anchor);
      mount_component(field6, target, anchor);
      insert(target, t10, anchor);
      insert(target, hr2, anchor);
      insert(target, t11, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span0);
      span0.innerHTML = SX_ICON_DROPDOWN;
      append(div0, t12);
      append(div0, span1);
      append(div0, t14);
      if (if_block1)
        if_block1.m(div0, null);
      append(div1, t15);
      if (if_block2)
        if_block2.m(div1, null);
      insert(target, t16, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[46]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty[0] & 4096)
        header_changes.subtitle = ctx2[12]?.name || "?";
      header.$set(header_changes);
      const field0_changes = {};
      if (dirty[0] & 8192 | dirty[1] & 134217728) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty[0] & 81 | dirty[1] & 134217728) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty[0] & 131624 | dirty[1] & 134217728) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      if (ctx2[9] && ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 544) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t4.parentNode, t4);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const field3_changes = {};
      if (dirty[0] & 2 | dirty[1] & 134217728) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty[0] & 1174 | dirty[1] & 134217728) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      const field5_changes = {};
      if (dirty[0] & 1574914 | dirty[1] & 134217728) {
        field5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field5.$set(field5_changes);
      const field6_changes = {};
      if (dirty[0] & 262144 | dirty[1] & 134217728) {
        field6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field6.$set(field6_changes);
      if (ctx2[14]) {
        if (if_block1) {
          if (dirty[0] & 16384) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$4();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[14]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 16384) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$b(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty[0] & 16384) {
        toggle_class(div1, "expanded", ctx2[14]);
      }
      const actionsline_changes = {};
      if (dirty[0] & 65536)
        actionsline_changes.confirm = ["Next", ctx2[48], !ctx2[16]];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(if_block0);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(field5.$$.fragment, local);
      transition_in(field6.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(if_block0);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(field5.$$.fragment, local);
      transition_out(field6.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t3);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(hr0);
      if (detaching)
        detach(t5);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t6);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t7);
      destroy_component(field5, detaching);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(hr1);
      if (detaching)
        detach(t9);
      destroy_component(field6, detaching);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(hr2);
      if (detaching)
        detach(t11);
      if (detaching)
        detach(div1);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach(t16);
      destroy_component(actionsline, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$v(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      form: true,
      slides: true,
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  screen.$on("submit", submit_handler);
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const screen_changes = {};
      if (dirty[0] & 2097151 | dirty[1] & 134217728) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
const si_versus = "usd";
let x_fee = 0.01;
const R_CONTACT_NAME = /^\S.{0,1023}$/;
const submit_handler = (d_submit) => {
  d_submit.preventDefault();
};
function instance$s($$self, $$props, $$invalidate) {
  let g_coin;
  let p_token;
  let s_symbol;
  let s_balance;
  let b_using_max;
  let si_coingecko;
  let s_fee_fiat;
  let g_address_type;
  let b_new_address;
  let s_err_new_contact;
  let b_form_valid;
  let $yw_network_active;
  let $yw_owner;
  let $yw_account;
  let $yw_chain;
  let $yw_account_ref;
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(35, $yw_network_active = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(36, $yw_owner = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(37, $yw_account = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(12, $yw_chain = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(53, $yw_account_ref = $$value));
  const k_page = getContext("page");
  let { sender = $yw_account } = $$props;
  let p_account = $yw_account_ref;
  let { native = Object.keys($yw_chain.coins)[0] } = $$props;
  let si_native = native;
  let { token = null } = $$props;
  let g_token2 = token;
  let { recipient = "" } = $$props;
  let sa_recipient = recipient;
  let p_asset = si_native ? Entities.holdingPathFor($yw_owner, si_native) : "";
  let h_addr_to_contact;
  let b_busy_agents = false;
  async function reload_agents(b_init = false) {
    if (b_busy_agents)
      return;
    b_busy_agents = true;
    const ks_agents = await Agents.read();
    const a_contacts = [...ks_agents.contacts()];
    $$invalidate(29, h_addr_to_contact = fold(a_contacts, ([p_contact, g_contact]) => ({
      [Chains.bech32(g_contact.address)]: p_contact
    })));
    b_busy_agents = false;
  }
  {
    const f_unsub_agents = subscribe_store("agents", reload_agents);
    const f_unsub_chain = yw_chain.subscribe(reload_agents);
    onDestroy(() => {
      f_unsub_agents();
      f_unsub_chain();
    });
  }
  let yg_balance = null;
  let s_amount = "";
  function use_max() {
    $$invalidate(2, s_amount = s_balance);
    if (g_coin) {
      $$invalidate(2, s_amount = new BigNumber(s_amount).minus(x_fee).toString());
    }
    $$invalidate(4, c_show_validations++, c_show_validations);
  }
  let x_worth = null;
  const H_ADDRESS_TYPES = {
    none: { icon: "<svg></svg>", text: "" },
    unknown: {
      icon: SX_ICON_LOADING,
      text: "Determining address type..."
    },
    personal: {
      icon: SX_ICON_CONTACTS,
      text: "Personal address"
    },
    contract: {
      icon: SX_ICON_CONTRACT,
      text: "Contract address"
    }
  };
  let si_address_type = "none";
  let b_memo_expanded = false;
  let s_memo = "";
  let b_submitted = false;
  function submit() {
    if (!b_form_valid) {
      $$invalidate(4, c_show_validations++, c_show_validations);
      return;
    } else {
      if (b_submitted)
        return false;
      b_submitted = true;
      if (si_native) {
        k_page.push({
          creator: SendNative,
          props: {
            accountRef: p_account,
            coin: si_native,
            recipient: sa_recipient,
            amount: s_amount,
            memo: s_memo,
            fee: x_fee + ""
          }
        });
      }
    }
  }
  let c_show_validations = 0;
  let b_checked_save_contact = false;
  let s_err_recipient = "";
  let s_err_amount = "";
  let s_new_contact = "";
  function input_new_contact(d_event) {
    $$invalidate(32, s_new_contact = d_event.target.value);
  }
  function senderselect_accountRef_binding(value) {
    p_account = value;
    $$invalidate(13, p_account);
  }
  function recipientselect_error_binding(value) {
    s_err_recipient = value;
    $$invalidate(6, s_err_recipient);
  }
  function recipientselect_address_binding(value) {
    sa_recipient = value;
    $$invalidate(0, sa_recipient);
  }
  function checkboxfield_checked_binding(value) {
    b_checked_save_contact = value;
    $$invalidate(5, b_checked_save_contact);
  }
  function assetselect_assetRef_binding(value) {
    p_asset = value;
    $$invalidate(1, p_asset);
  }
  function amountinput_error_binding(value) {
    s_err_amount = value;
    $$invalidate(7, s_err_amount);
  }
  function amountinput_value_binding(value) {
    s_amount = value;
    $$invalidate(2, s_amount);
  }
  const click_handler2 = () => use_max();
  const click_handler_1 = () => $$invalidate(14, b_memo_expanded = !b_memo_expanded);
  function textarea_input_handler() {
    s_memo = this.value;
    $$invalidate(15, s_memo);
  }
  const func = () => submit();
  $$self.$$set = ($$props2) => {
    if ("sender" in $$props2)
      $$invalidate(25, sender = $$props2.sender);
    if ("native" in $$props2)
      $$invalidate(26, native = $$props2.native);
    if ("token" in $$props2)
      $$invalidate(27, token = $$props2.token);
    if ("recipient" in $$props2)
      $$invalidate(28, recipient = $$props2.recipient);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4098) {
      $$invalidate(10, g_coin = p_asset && "holding" === Entities.parseEntityPath(p_asset)?.type && si_native ? $yw_chain.coins?.[si_native] : null);
    }
    if ($$self.$$.dirty[0] & 2) {
      $$invalidate(34, p_token = p_asset && "token" === Entities.parseEntityPath(p_asset)?.type && g_token2 ? Entities.pathFrom(g_token2) : "");
    }
    if ($$self.$$.dirty[0] & 1026 | $$self.$$.dirty[1] & 8) {
      {
        console.log({
          si_native,
          g_coin,
          p_asset,
          p_token,
          g_token: g_token2
        });
      }
    }
    if ($$self.$$.dirty[0] & 2 | $$self.$$.dirty[1] & 112) {
      {
        if ($yw_account && p_asset) {
          $$invalidate(30, yg_balance = null);
          queueMicrotask(async () => {
            $$invalidate(11, s_balance = "[...]");
            const g_cached = $yw_network_active.cachedBalance($yw_owner, si_native);
            if (g_cached && g_cached.timestamp > Date.now() - 5 * XT_MINUTES) {
              $$invalidate(30, yg_balance = new BigNumber(g_cached.data.amount));
            }
            const g_bundle = await $yw_network_active.bankBalance($yw_owner, si_native);
            if (g_bundle) {
              $$invalidate(30, yg_balance = new BigNumber(g_bundle.balance.amount));
            }
          });
        }
      }
    }
    if ($$self.$$.dirty[0] & 1073742848) {
      $$invalidate(11, s_balance = yg_balance ? format_amount(yg_balance.shiftedBy(-(g_coin || g_token2).decimals).toNumber()) : "");
    }
    if ($$self.$$.dirty[0] & 2052) {
      $$invalidate(19, b_using_max = s_amount === s_balance);
    }
    if ($$self.$$.dirty[0] & 1024) {
      $$invalidate(33, si_coingecko = (g_token2 || g_coin)?.extra?.coingecko_id || "");
    }
    if ($$self.$$.dirty[1] & 5) {
      {
        if (si_coingecko) {
          (async () => {
            const h_versus = await CoinGecko.coinsVersus([si_coingecko], si_versus);
            $$invalidate(31, x_worth = h_versus[si_coingecko]);
            if ("number" === typeof x_worth) {
              format_fiat(x_worth, si_versus);
            }
          })();
        }
      }
    }
    if ($$self.$$.dirty[1] & 1) {
      $$invalidate(18, s_fee_fiat = "number" === typeof x_worth ? format_fiat(x_fee * x_worth, "usd") : "");
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 16) {
      {
        if (!sa_recipient) {
          $$invalidate(3, si_address_type = "none");
        } else {
          $$invalidate(3, si_address_type = "unknown");
          (async () => {
            if (await $yw_network_active.isContract(sa_recipient)) {
              $$invalidate(3, si_address_type = "contract");
            } else {
              $$invalidate(3, si_address_type = "personal");
            }
          })();
        }
      }
    }
    if ($$self.$$.dirty[0] & 8) {
      $$invalidate(17, g_address_type = H_ADDRESS_TYPES[si_address_type]);
    }
    if ($$self.$$.dirty[0] & 536870913) {
      $$invalidate(9, b_new_address = sa_recipient && h_addr_to_contact && !(sa_recipient in h_addr_to_contact));
    }
    if ($$self.$$.dirty[0] & 48 | $$self.$$.dirty[1] & 2) {
      $$invalidate(8, s_err_new_contact = b_checked_save_contact && (c_show_validations || true) ? s_new_contact ? R_CONTACT_NAME.test(s_new_contact) ? "" : s_new_contact.length > 1024 ? "That name is way too long" : "Cannot begin with space" : "Enter a contact name to save new address" : "");
    }
    if ($$self.$$.dirty[0] & 48) {
      {
        if (b_checked_save_contact && !c_show_validations) {
          $$invalidate(8, s_err_new_contact = "");
        }
      }
    }
    if ($$self.$$.dirty[0] & 997 | $$self.$$.dirty[1] & 2) {
      $$invalidate(16, b_form_valid = sa_recipient && s_amount && !s_err_recipient && !s_err_amount && (!b_new_address || !b_checked_save_contact || s_new_contact && !s_err_new_contact) || false);
    }
    if ($$self.$$.dirty[0] & 197) {
      {
        console.log({
          to: sa_recipient,
          s_amount,
          s_err_recipient,
          s_err_amount
        });
      }
    }
  };
  $$invalidate(20, s_symbol = si_native || g_token2?.symbol || "");
  return [
    sa_recipient,
    p_asset,
    s_amount,
    si_address_type,
    c_show_validations,
    b_checked_save_contact,
    s_err_recipient,
    s_err_amount,
    s_err_new_contact,
    b_new_address,
    g_coin,
    s_balance,
    $yw_chain,
    p_account,
    b_memo_expanded,
    s_memo,
    b_form_valid,
    g_address_type,
    s_fee_fiat,
    b_using_max,
    s_symbol,
    g_token2,
    use_max,
    submit,
    input_new_contact,
    sender,
    native,
    token,
    recipient,
    h_addr_to_contact,
    yg_balance,
    x_worth,
    s_new_contact,
    si_coingecko,
    p_token,
    $yw_network_active,
    $yw_owner,
    $yw_account,
    senderselect_accountRef_binding,
    recipientselect_error_binding,
    recipientselect_address_binding,
    checkboxfield_checked_binding,
    assetselect_assetRef_binding,
    amountinput_error_binding,
    amountinput_value_binding,
    click_handler2,
    click_handler_1,
    textarea_input_handler,
    func
  ];
}
class Send extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$s,
      create_fragment$v,
      safe_not_equal,
      {
        sender: 25,
        native: 26,
        token: 27,
        recipient: 28
      },
      null,
      [-1, -1]
    );
  }
}
function create_fragment$u(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "\xA0";
      attr(div, "class", "gap no-margin svelte-1rn5flx");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class Gap extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$u, safe_not_equal, {});
  }
}
function as_amount(g_balance, g_coin) {
  const s_norm = g_balance.amount.padStart(g_coin.decimals + 2, "0");
  return s_norm.slice(0, -g_coin.decimals).replace(/^0+/, "0") + "." + s_norm.slice(-g_coin.decimals);
}
async function to_fiat(g_balance, g_coin, si_versus2 = "usd") {
  if ("0" === g_balance.amount)
    return new BigNumber(0);
  const si_gecko = g_coin.extra.coingecko_id;
  const g_versus = await CoinGecko.coinsVersus([si_gecko], si_versus2);
  return new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals).times(g_versus[si_gecko]);
}
async function coin_formats(g_balance, g_coin, si_versus2 = "usd") {
  const si_gecko = g_coin.extra.coingecko_id;
  const g_versus = await CoinGecko.coinsVersus([si_gecko], si_versus2);
  const x_worth = g_versus[si_gecko];
  const yg_balance = new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals).times(x_worth);
  return {
    versus: si_versus2,
    balance: yg_balance,
    fiat: yg_balance.times(x_worth).toNumber(),
    worth: x_worth
  };
}
function create_default_slot$f(ctx) {
  let header;
  let t0;
  let portrait;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      pops: true,
      account: true,
      network: true,
      title: ctx[3],
      subtitle: ctx[4]
    }
  });
  portrait = new Portrait({
    props: {
      pfp: ctx[2],
      resource: ctx[1] || g_token || null,
      resourcePath: ctx[8],
      title: ctx[5] ? `${format_amount(ctx[5].toNumber())} ${ctx[3]}` : "...",
      subtitle: `${ctx[6]} (${ctx[7]} per ${ctx[0]})`,
      actions: ctx[9],
      circular: true
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(portrait.$$.fragment);
      t1 = space();
      div = element("div");
      attr(div, "class", "txns no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(portrait, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & 8)
        header_changes.title = ctx2[3];
      if (dirty & 16)
        header_changes.subtitle = ctx2[4];
      header.$set(header_changes);
      const portrait_changes = {};
      if (dirty & 4)
        portrait_changes.pfp = ctx2[2];
      if (dirty & 2)
        portrait_changes.resource = ctx2[1] || g_token || null;
      if (dirty & 40)
        portrait_changes.title = ctx2[5] ? `${format_amount(ctx2[5].toNumber())} ${ctx2[3]}` : "...";
      if (dirty & 193)
        portrait_changes.subtitle = `${ctx2[6]} (${ctx2[7]} per ${ctx2[0]})`;
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$t(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "HoldingView",
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 262399) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
let g_token = null;
function instance$r($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_network_active;
  let $yw_chain_ref;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(13, $yw_chain = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(14, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(15, $yw_chain_ref = $$value));
  const k_page = getContext("page");
  let { entityRef } = $$props;
  const p_entity = entityRef;
  let si_type = "";
  let si_coin = "";
  let g_coin = null;
  let p_pfp = "";
  let s_symbol = "";
  let s_name = "";
  let yg_amount = null;
  let s_fiat = "";
  let s_worth = "";
  async function load_entity() {
    await Entities.read();
    const g_info = Entities.parseEntityPath(p_entity);
    if (!g_info) {
      throw new Error(`Attempted to load holding view on non-entity path "${p_entity}"`);
    }
    switch (g_info.type) {
      case "holding": {
        $$invalidate(0, si_type = "coin");
        ({ coin: si_coin } = g_info);
        const p_chain = g_info.chainRef;
        const g_chain = p_chain === $yw_chain_ref ? $yw_chain : await Chains.at(p_chain);
        $$invalidate(1, g_coin = g_chain.coins[si_coin]);
        $$invalidate(3, s_symbol = si_coin);
        $$invalidate(4, s_name = g_coin.name);
        $$invalidate(2, p_pfp = g_coin.pfp);
        const g_cached = $yw_network_active.cachedBalance(g_info.bech32, si_coin);
        let g_balance;
        if (g_cached && g_cached.timestamp >= Date.now() - 2 * XT_MINUTES) {
          g_balance = g_cached.data;
        } else {
          ({ balance: g_balance } = await $yw_network_active.bankBalance(g_info.bech32, si_coin));
        }
        $$invalidate(5, yg_amount = new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals));
        void coin_formats(g_balance, g_coin).then((g_formats) => {
          $$invalidate(6, s_fiat = format_fiat(g_formats.fiat, g_formats.versus));
          $$invalidate(7, s_worth = format_fiat(g_formats.worth, g_formats.versus));
        });
        break;
      }
      case "token": {
        $$invalidate(0, si_type = "token");
        const ks_entites = await Entities.read();
        ks_entites.tokens(g_info.entityRef, Entities.fungibleInterfacesFor($yw_chain));
        debugger;
        break;
      }
      default: {
        throw new Error(`Unhandled entity type: "${g_info.type}"`);
      }
    }
  }
  load_entity();
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: si_coin ? { native: si_coin } : {}
        });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("entityRef" in $$props2)
      $$invalidate(10, entityRef = $$props2.entityRef);
  };
  return [
    si_type,
    g_coin,
    p_pfp,
    s_symbol,
    s_name,
    yg_amount,
    s_fiat,
    s_worth,
    p_entity,
    gc_actions,
    entityRef
  ];
}
class HoldingView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$t, safe_not_equal, { entityRef: 10 });
  }
}
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i][0];
  child_ctx[24] = list[i][1];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i][0];
  child_ctx[33] = list[i][1];
  child_ctx[34] = list[i][2];
  child_ctx[35] = list[i][3];
  const constants_0 = Entities.holdingPathFor(child_ctx[3], child_ctx[27]);
  child_ctx[29] = constants_0;
  const constants_1 = {
    name: child_ctx[27],
    pfp: child_ctx[0].pfp
  };
  child_ctx[36] = constants_1;
  const constants_2 = child_ctx[35](to_fiat(child_ctx[34], child_ctx[33]));
  child_ctx[37] = constants_2;
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i][0];
  child_ctx[28] = list[i][1];
  const constants_0 = Entities.holdingPathFor(child_ctx[3], child_ctx[27]);
  child_ctx[29] = constants_0;
  return child_ctx;
}
function create_if_block_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "TESTNET";
      attr(div, "class", "testnet-reminder no-margin svelte-8v4b7t");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$a(ctx) {
  let div2;
  let div0;
  let span;
  let t1;
  let t2_value = ctx[0].testnet ? "testnet " : "";
  let t2;
  let t3_value = ctx[1].join(" or ") + "";
  let t3;
  let t4;
  let t5;
  let div1;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].testnet)
      return create_if_block_1$3;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span = element("span");
      span.textContent = "Warning:";
      t1 = text(" you don't have any ");
      t2 = text(t2_value);
      t3 = text(t3_value);
      t4 = text(" to pay gas fees.");
      t5 = space();
      div1 = element("div");
      if_block.c();
      attr(span, "class", "warning");
      attr(div0, "class", "message svelte-8v4b7t");
      attr(div1, "class", "buttons");
      attr(div2, "class", "no-gas text-align_center subinfo svelte-8v4b7t");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span);
      append(div0, t1);
      append(div0, t2);
      append(div0, t3);
      append(div0, t4);
      append(div2, t5);
      append(div2, div1);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t2_value !== (t2_value = ctx2[0].testnet ? "testnet " : ""))
        set_data(t2, t2_value);
      if (dirty[0] & 2 && t3_value !== (t3_value = ctx2[1].join(" or ") + ""))
        set_data(t3, t3_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_block.d();
    }
  };
}
function create_else_block$4(ctx) {
  let button;
  let t0;
  let t1_value = ctx[1].join(" or ") + "";
  let t1;
  return {
    c() {
      button = element("button");
      t0 = text("Buy ");
      t1 = text(t1_value);
      attr(button, "class", "pill");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t1_value !== (t1_value = ctx2[1].join(" or ") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
    }
  };
}
function create_if_block_1$3(ctx) {
  let button;
  let t0;
  let t1_value = ctx[1].join(" or ") + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text("Get ");
      t1 = text(t1_value);
      t2 = text(" from faucet");
      attr(button, "class", "pill");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", ctx[14]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t1_value !== (t1_value = ctx2[1].join(" or ") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block_1(ctx) {
  let t;
  let div;
  let address;
  let current;
  let if_block = ctx[1].length && create_if_block$a(ctx);
  address = new Address({
    props: {
      address: ctx[3],
      copyable: "icon"
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      create_component(address.$$.fragment);
      attr(div, "class", "owner-address subinfo svelte-8v4b7t");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      mount_component(address, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$a(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const address_changes = {};
      if (dirty[0] & 8)
        address_changes.address = ctx2[3];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      destroy_component(address);
    }
  };
}
function create_catch_block_1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ctx[32];
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 777) {
        each_value_2 = ctx2[32];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_2(ctx) {
  let row;
  let current;
  function click_handler_2() {
    return ctx[17](ctx[29]);
  }
  row = new Row({
    props: {
      lockIcon: true,
      detail: "Native Coin",
      resourcePath: ctx[29],
      resource: ctx[36],
      amount: as_amount(ctx[34], ctx[33]),
      fiat: ctx[37].then(ctx[16])
    }
  });
  row.$on("click", click_handler_2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 8)
        row_changes.resourcePath = ctx[29];
      if (dirty[0] & 1)
        row_changes.resource = ctx[36];
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ode(ctx[0].coins);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 265) {
        each_value_1 = ode(ctx2[0].coins);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_1$2(ctx) {
  let row;
  let current;
  function click_handler_1() {
    return ctx[15](ctx[29]);
  }
  row = new Row({
    props: {
      lockIcon: true,
      detail: "Native Coin",
      name: ctx[27],
      pfp: ctx[0].pfp,
      amount: forever()
    }
  });
  row.$on("click", click_handler_1);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 1)
        row_changes.name = ctx[27];
      if (dirty[0] & 1)
        row_changes.pfp = ctx[0].pfp;
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_catch_block$8(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$8(ctx) {
  let each_1_anchor;
  let each_value = ode(ctx[7](ctx[22]));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 129) {
        each_value = ode(ctx2[7](ctx2[22]));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$7(ctx) {
  let t_value = ctx[24].spec + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t_value !== (t_value = ctx2[24].spec + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block$8(ctx) {
  let t;
  return {
    c() {
      t = text("Loading tokens...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_key_block$2(ctx) {
  let div;
  let t;
  let promise_1;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 32,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  let info_1 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$8,
    then: create_then_block$8,
    catch: create_catch_block$8,
    value: 22
  };
  handle_promise(promise_1 = Entities.readFungibleTokens(ctx[0]), info_1);
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      info_1.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      info_1.block.m(div, info_1.anchor = null);
      info_1.mount = () => div;
      info_1.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      info_1.ctx = ctx;
      if (dirty[0] & 1 && promise_1 !== (promise_1 = Entities.readFungibleTokens(ctx[0])) && handle_promise(promise_1, info_1))
        ;
      else {
        update_await_block_branch(info_1, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      info_1.block.d();
      info_1.token = null;
      info_1 = null;
    }
  };
}
function create_default_slot$e(ctx) {
  let header;
  let t0;
  let t1;
  let portrait;
  let t2;
  let previous_key = ctx[0];
  let t3;
  let gap;
  let t4;
  let previous_key_1 = ctx[4];
  let key_block1_anchor;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  let if_block = ctx[0].testnet && create_if_block_2();
  portrait = new Portrait({
    props: {
      noPfp: true,
      title: ctx[2],
      subtitle: ctx[5].name,
      resource: ctx[5],
      resourcePath: ctx[6],
      actions: {
        send: { label: "Send", trigger: ctx[12] },
        recv: {
          label: "Receive",
          trigger: ctx[13]
        }
      }
    }
  });
  let key_block0 = create_key_block_1(ctx);
  gap = new Gap({});
  let key_block1 = create_key_block$2(ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(portrait.$$.fragment);
      t2 = space();
      key_block0.c();
      t3 = space();
      create_component(gap.$$.fragment);
      t4 = space();
      key_block1.c();
      key_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(portrait, target, anchor);
      insert(target, t2, anchor);
      key_block0.m(target, anchor);
      insert(target, t3, anchor);
      mount_component(gap, target, anchor);
      insert(target, t4, anchor);
      key_block1.m(target, anchor);
      insert(target, key_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0].testnet) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_2();
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const portrait_changes = {};
      if (dirty[0] & 4)
        portrait_changes.title = ctx2[2];
      if (dirty[0] & 32)
        portrait_changes.subtitle = ctx2[5].name;
      if (dirty[0] & 32)
        portrait_changes.resource = ctx2[5];
      if (dirty[0] & 64)
        portrait_changes.resourcePath = ctx2[6];
      if (dirty[0] & 96)
        portrait_changes.actions = {
          send: { label: "Send", trigger: ctx2[12] },
          recv: {
            label: "Receive",
            trigger: ctx2[13]
          }
        };
      portrait.$set(portrait_changes);
      if (dirty[0] & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block0, 1, 1, noop);
        check_outros();
        key_block0 = create_key_block_1(ctx2);
        key_block0.c();
        transition_in(key_block0, 1);
        key_block0.m(t3.parentNode, t3);
      } else {
        key_block0.p(ctx2, dirty);
      }
      if (dirty[0] & 16 && safe_not_equal(previous_key_1, previous_key_1 = ctx2[4])) {
        group_outros();
        transition_out(key_block1, 1, 1, noop);
        check_outros();
        key_block1 = create_key_block$2(ctx2);
        key_block1.c();
        transition_in(key_block1, 1);
        key_block1.m(key_block1_anchor.parentNode, key_block1_anchor);
      } else {
        key_block1.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(portrait.$$.fragment, local);
      transition_in(key_block0);
      transition_in(gap.$$.fragment, local);
      transition_in(key_block1);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(portrait.$$.fragment, local);
      transition_out(key_block0);
      transition_out(gap.$$.fragment, local);
      transition_out(key_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t2);
      key_block0.d(detaching);
      if (detaching)
        detach(t3);
      destroy_component(gap, detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(key_block1_anchor);
      key_block1.d(detaching);
    }
  };
}
function create_fragment$s(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "HoldingsHome",
      nav: true,
      root: true,
      keyed: true,
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const screen_changes = {};
      if (dirty[0] & 127 | dirty[1] & 512) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_owner;
  let $yw_network_active;
  let $yw_account;
  let $yw_account_ref;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(0, $yw_chain = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(3, $yw_owner = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(4, $yw_network_active = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(5, $yw_account = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(6, $yw_account_ref = $$value));
  const merge_fungible_tokens = (h_fungibles) => oderom(h_fungibles, (_, h) => h);
  const k_page = getContext("page");
  let yg_total = new BigNumber(0);
  let c_balances = 0;
  let a_no_gas = [];
  let fk_resolve_total;
  let dp_total = new Promise((fk_resolve) => {
    fk_resolve_total = fk_resolve;
  });
  let g_chain_cached = $yw_chain;
  function check_total() {
    c_balances -= 1;
    if (!c_balances) {
      const s_total = format_fiat(yg_total.toNumber(), "usd");
      fk_resolve_total(s_total);
      const g_account = $yw_account;
      void Accounts.open((ks) => ks.put({
        ...g_account,
        extra: { total_fiat_cache: s_total }
      }));
    }
  }
  async function load_native_balances() {
    let h_balances;
    try {
      h_balances = await $yw_network_active.bankBalances($yw_owner);
    } catch (e_network) {
      syserr({ error: e_network, text: "Network error" });
      return [];
    }
    const a_outs = [];
    for (const [si_coin, g_coin] of ode($yw_chain.coins)) {
      const g_bundle = h_balances[si_coin];
      if (!g_bundle || "0" === g_bundle.balance.amount) {
        a_no_gas.push(si_coin);
      }
      c_balances += 1;
      a_outs.push([
        si_coin,
        $yw_chain.coins[si_coin],
        g_bundle?.balance || { amount: "0", denom: g_coin.denom },
        async (z_out) => {
          const yg_balance = await z_out;
          yg_total = yg_total.plus(yg_balance);
          check_total();
          return yg_balance;
        }
      ]);
    }
    if (!a_outs.length) {
      c_balances += 1;
      check_total();
    }
    $$invalidate(1, a_no_gas), $$invalidate(0, $yw_chain), $$invalidate(11, g_chain_cached);
    return a_outs;
  }
  const H_FAUCETS = {
    "theta-testnet-001": "https://discord.com/channels/669268347736686612/953697793476821092",
    "pulsar-2": "https://faucet.secrettestnet.io/"
  };
  const func = function() {
    k_page.push({
      creator: Send,
      props: { from: $yw_account }
    });
  };
  const func_12 = function() {
    popup_receive($yw_account_ref);
  };
  const click_handler2 = () => open_external_link(H_FAUCETS[$yw_chain.id]);
  const click_handler_1 = (p_entity) => {
    k_page.push({
      creator: HoldingView,
      props: { entityRef: p_entity }
    });
  };
  const func_2 = (yg) => format_fiat(yg.toNumber(), "usd");
  const click_handler_2 = (p_entity) => {
    k_page.push({
      creator: HoldingView,
      props: { entityRef: p_entity }
    });
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2049) {
      {
        if ($yw_chain !== g_chain_cached) {
          $$invalidate(11, g_chain_cached = $yw_chain);
          yg_total = new BigNumber(0);
          c_balances = 0;
          $$invalidate(2, dp_total = new Promise((fk_resolve) => {
            fk_resolve_total = fk_resolve;
          }));
          $$invalidate(1, a_no_gas = []);
        }
      }
    }
  };
  return [
    $yw_chain,
    a_no_gas,
    dp_total,
    $yw_owner,
    $yw_network_active,
    $yw_account,
    $yw_account_ref,
    merge_fungible_tokens,
    k_page,
    load_native_balances,
    H_FAUCETS,
    g_chain_cached,
    func,
    func_12,
    click_handler2,
    click_handler_1,
    func_2,
    click_handler_2
  ];
}
class HoldingsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$s, safe_not_equal, {}, null, [-1, -1]);
  }
}
function create_catch_block$7(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$7(ctx) {
  let field0;
  let t0;
  let field1;
  let t1;
  let field2;
  let t2;
  let actionsline;
  let current;
  field0 = new Field({
    props: {
      key: "profile-icon",
      name: "Profile icon"
    }
  });
  field1 = new Field({
    props: {
      key: "account-name",
      name: "Name",
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      key: "account-address",
      name: "Public address",
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      cancel: !ctx[4],
      back: true,
      confirm: ["Finish", ctx[6], !ctx[3]]
    }
  });
  return {
    c() {
      create_component(field0.$$.fragment);
      t0 = space();
      create_component(field1.$$.fragment);
      t1 = space();
      create_component(field2.$$.fragment);
      t2 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t0, anchor);
      mount_component(field1, target, anchor);
      insert(target, t1, anchor);
      mount_component(field2, target, anchor);
      insert(target, t2, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field1_changes = {};
      if (dirty & 8194) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 8196) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const actionsline_changes = {};
      if (dirty & 8)
        actionsline_changes.confirm = ["Finish", ctx2[6], !ctx2[3]];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "id", "account-name");
      attr(input, "type", "text");
      attr(input, "placeholder", "Satoshi");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$3(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: ctx[2]
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 4)
        address_changes.address = ctx2[2];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_default_slot_1$5(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      address: true,
      key: "account-address",
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 8196) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_pending_block$7(ctx) {
  let t;
  return {
    c() {
      t = text("Loading accounts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$d(ctx) {
  let h3;
  let t0_value = ctx[0] ? "Edit" : "New";
  let t0;
  let t1;
  let t2;
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$7,
    then: create_then_block$7,
    catch: create_catch_block$7,
    blocks: [, , ,]
  };
  handle_promise(ctx[5](), info);
  return {
    c() {
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" account");
      t2 = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, t1);
      insert(target, t2, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[0] ? "Edit" : "New"))
        set_data(t0, t0_value);
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$r(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8207) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let b_form_valid;
  let $yw_account_ref;
  let $yw_chain;
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(10, $yw_account_ref = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(8, $yw_chain = $$value));
  let { account } = $$props;
  const p_account = account;
  let g_account;
  let s_name = "";
  let sa_account;
  const completed = getContext("completed");
  const k_page = getContext("page");
  async function load_account() {
    const ks_accounts = await Accounts.read();
    $$invalidate(7, g_account = ks_accounts.at(p_account));
    $$invalidate(1, s_name = g_account.name);
  }
  async function save_account() {
    Object.assign(g_account, { name: s_name });
    await Accounts.open((ks_accounts) => ks_accounts.put(g_account));
    if (p_account === $yw_account_ref) {
      set_store_value(yw_account_ref, $yw_account_ref = p_account, $yw_account_ref);
    }
    if (completed) {
      completed(true);
    } else {
      k_page.reset();
    }
  }
  function input_input_handler() {
    s_name = this.value;
    $$invalidate(1, s_name);
  }
  $$self.$$set = ($$props2) => {
    if ("account" in $$props2)
      $$invalidate(0, account = $$props2.account);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$invalidate(3, b_form_valid = !!s_name);
    }
    if ($$self.$$.dirty & 384) {
      $$invalidate(2, sa_account = g_account ? Chains.addressFor(g_account.pubkey, $yw_chain) : "");
    }
  };
  return [
    account,
    s_name,
    sa_account,
    b_form_valid,
    completed,
    load_account,
    save_account,
    g_account,
    $yw_chain,
    input_input_handler
  ];
}
class AccountEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$r, safe_not_equal, { account: 0 });
  }
}
function create_catch_block$6(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$6(ctx) {
  let portrait;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[1],
      actions: ctx[3],
      $$slots: { subtitle: [create_subtitle_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portrait.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 65) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
    }
  };
}
function create_subtitle_slot$2(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: Chains.addressFor(ctx[0].pubkey)
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = Chains.addressFor(ctx2[0].pubkey);
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_pending_block$6(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$c(ctx) {
  let header;
  let t;
  let await_block_anchor;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      title: "Account"
    }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$6,
    then: create_then_block$6,
    catch: create_catch_block$6,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$q(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 65) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let { accountRef } = $$props;
  const p_account = accountRef;
  let g_account;
  const k_page = getContext("page");
  async function load_account() {
    const ks_accounts = await Accounts.read();
    return $$invalidate(0, g_account = ks_accounts.at(p_account));
  }
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: {
            from: Chains.addressFor(g_account.pubkey)
          }
        });
      }
    },
    recv: {
      label: "Receive",
      trigger() {
        popup_receive(p_account);
      }
    },
    edit: {
      label: "Edit",
      trigger() {
        k_page.push({
          creator: AccountEdit,
          props: { account: p_account }
        });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("accountRef" in $$props2)
      $$invalidate(4, accountRef = $$props2.accountRef);
  };
  return [g_account, p_account, load_account, gc_actions, accountRef];
}
class AccountView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$q, safe_not_equal, { accountRef: 4 });
  }
}
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i][0];
  child_ctx[6] = list[i][1];
  const constants_0 = Chains.addressFor(child_ctx[6].pubkey);
  child_ctx[7] = constants_0;
  return child_ctx;
}
function create_catch_block$5(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$5(ctx) {
  let previous_key = ctx[1];
  let key_block_anchor;
  let current;
  let key_block = create_key_block$1(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2 && safe_not_equal(previous_key, previous_key = ctx2[1])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_detail_slot$1(ctx) {
  let div;
  let t1;
  let address;
  let t2;
  let current;
  address = new Address({ props: { address: ctx[7] } });
  return {
    c() {
      div = element("div");
      div.textContent = "StarShell - - m/44'/118'/0'/0/??";
      t1 = space();
      create_component(address.$$.fragment);
      t2 = space();
      attr(div, "class", "hd-path");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
      mount_component(address, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = ctx2[7];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      destroy_component(address, detaching);
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$6(ctx) {
  let row;
  let current;
  function click_handler2() {
    return ctx[4](ctx[5]);
  }
  row = new Row({
    props: {
      resource: ctx[6],
      resourcePath: ctx[5],
      address: ctx[7],
      iconClass: "square pfp",
      $$slots: { detail: [create_detail_slot$1] },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1)
        row_changes.resource = ctx[6];
      if (dirty & 1)
        row_changes.resourcePath = ctx[5];
      if (dirty & 1)
        row_changes.address = ctx[7];
      if (dirty & 1025) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_key_block$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_pending_block$5(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$b(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "Accounts" } });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$5,
    then: create_then_block$5,
    catch: create_catch_block$5,
    blocks: [, , ,]
  };
  handle_promise(ctx[3](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$p(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Accounts",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1027) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let $yw_chain;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(1, $yw_chain = $$value));
  const k_page = getContext("page");
  let a_accounts;
  async function load_accounts() {
    const ks_accounts = await Accounts.read();
    return $$invalidate(0, a_accounts = ks_accounts.entries());
  }
  const click_handler2 = (p_account) => k_page.push({
    creator: AccountView,
    props: { accountRef: p_account }
  });
  return [a_accounts, $yw_chain, k_page, load_accounts, click_handler2];
}
class AccountsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$p, safe_not_equal, {});
  }
}
let id = 1;
function getId() {
  return `svelte-tabs-${id++}`;
}
function create_fragment$o(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-tabs");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "keydown", ctx[1]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
const TABS = {};
function removeAndUpdateSelected(arr, item, selectedStore) {
  const index = arr.indexOf(item);
  arr.splice(index, 1);
  selectedStore.update((selected) => selected === item ? arr[index] || arr[arr.length - 1] : selected);
}
function instance$m($$self, $$props, $$invalidate) {
  let $selectedTab;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { initialSelectedIndex = 0 } = $$props;
  const tabElements = [];
  const tabs = [];
  const panels = [];
  const controls = writable({});
  const labeledBy = writable({});
  const selectedTab = writable(null);
  component_subscribe($$self, selectedTab, (value) => $$invalidate(5, $selectedTab = value));
  const selectedPanel = writable(null);
  function registerItem(arr, item, selectedStore) {
    arr.push(item);
    selectedStore.update((selected) => selected || item);
    onDestroy(() => removeAndUpdateSelected(arr, item, selectedStore));
  }
  function selectTab(tab) {
    const index = tabs.indexOf(tab);
    selectedTab.set(tab);
    selectedPanel.set(panels[index]);
  }
  setContext(TABS, {
    registerTab(tab) {
      registerItem(tabs, tab, selectedTab);
    },
    registerTabElement(tabElement) {
      tabElements.push(tabElement);
    },
    registerPanel(panel) {
      registerItem(panels, panel, selectedPanel);
    },
    selectTab,
    selectedTab,
    selectedPanel,
    controls,
    labeledBy
  });
  onMount(() => {
    selectTab(tabs[initialSelectedIndex]);
  });
  afterUpdate(() => {
    for (let i = 0; i < tabs.length; i++) {
      controls.update((controlsData) => ({
        ...controlsData,
        [tabs[i].id]: panels[i].id
      }));
      labeledBy.update((labeledByData) => ({
        ...labeledByData,
        [panels[i].id]: tabs[i].id
      }));
    }
  });
  async function handleKeyDown(event) {
    if (event.target.classList.contains("svelte-tabs__tab")) {
      let selectedIndex = tabs.indexOf($selectedTab);
      switch (event.key) {
        case "ArrowRight":
          selectedIndex += 1;
          if (selectedIndex > tabs.length - 1) {
            selectedIndex = 0;
          }
          selectTab(tabs[selectedIndex]);
          tabElements[selectedIndex].focus();
          break;
        case "ArrowLeft":
          selectedIndex -= 1;
          if (selectedIndex < 0) {
            selectedIndex = tabs.length - 1;
          }
          selectTab(tabs[selectedIndex]);
          tabElements[selectedIndex].focus();
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("initialSelectedIndex" in $$props2)
      $$invalidate(2, initialSelectedIndex = $$props2.initialSelectedIndex);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [selectedTab, handleKeyDown, initialSelectedIndex, $$scope, slots];
}
class Tabs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$o, safe_not_equal, { initialSelectedIndex: 2 });
  }
}
function create_fragment$n(ctx) {
  let li;
  let li_aria_controls_value;
  let li_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  return {
    c() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      attr(li, "role", "tab");
      attr(li, "id", ctx[3].id);
      attr(li, "aria-controls", li_aria_controls_value = ctx[2][ctx[3].id]);
      attr(li, "aria-selected", ctx[1]);
      attr(li, "tabindex", li_tabindex_value = ctx[1] ? 0 : -1);
      attr(li, "class", "svelte-tabs__tab svelte-1fbofsd");
      toggle_class(li, "svelte-tabs__selected", ctx[1]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[10](li);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4 && li_aria_controls_value !== (li_aria_controls_value = ctx2[2][ctx2[3].id])) {
        attr(li, "aria-controls", li_aria_controls_value);
      }
      if (!current || dirty & 2) {
        attr(li, "aria-selected", ctx2[1]);
      }
      if (!current || dirty & 2 && li_tabindex_value !== (li_tabindex_value = ctx2[1] ? 0 : -1)) {
        attr(li, "tabindex", li_tabindex_value);
      }
      if (dirty & 2) {
        toggle_class(li, "svelte-tabs__selected", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let $selectedTab;
  let $controls;
  let { $$slots: slots = {}, $$scope } = $$props;
  let tabEl;
  const tab = { id: getId() };
  const { registerTab, registerTabElement, selectTab, selectedTab, controls } = getContext(TABS);
  component_subscribe($$self, selectedTab, (value) => $$invalidate(7, $selectedTab = value));
  component_subscribe($$self, controls, (value) => $$invalidate(2, $controls = value));
  let isSelected;
  registerTab(tab);
  onMount(async () => {
    await tick();
    registerTabElement(tabEl);
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tabEl = $$value;
      $$invalidate(0, tabEl);
    });
  }
  const click_handler2 = () => selectTab(tab);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(1, isSelected = $selectedTab === tab);
    }
  };
  return [
    tabEl,
    isSelected,
    $controls,
    tab,
    selectTab,
    selectedTab,
    controls,
    $selectedTab,
    $$scope,
    slots,
    li_binding,
    click_handler2
  ];
}
class Tab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$n, safe_not_equal, {});
  }
}
function create_fragment$m(ctx) {
  let ul;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr(ul, "role", "tablist");
      attr(ul, "class", "svelte-tabs__tab-list svelte-12yby2a");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TabList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$m, safe_not_equal, {});
  }
}
function create_if_block$9(ctx) {
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let div;
  let div_aria_labelledby_value;
  let current;
  let if_block = ctx[1] === ctx[2] && create_if_block$9(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "id", ctx[2].id);
      attr(div, "aria-labelledby", div_aria_labelledby_value = ctx[0][ctx[2].id]);
      attr(div, "class", "svelte-tabs__tab-panel svelte-epfyet");
      attr(div, "role", "tabpanel");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1] === ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 1 && div_aria_labelledby_value !== (div_aria_labelledby_value = ctx2[0][ctx2[2].id])) {
        attr(div, "aria-labelledby", div_aria_labelledby_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let $labeledBy;
  let $selectedPanel;
  let { $$slots: slots = {}, $$scope } = $$props;
  const panel = { id: getId() };
  const { registerPanel, selectedPanel, labeledBy } = getContext(TABS);
  component_subscribe($$self, selectedPanel, (value) => $$invalidate(1, $selectedPanel = value));
  component_subscribe($$self, labeledBy, (value) => $$invalidate(0, $labeledBy = value));
  registerPanel(panel);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [$labeledBy, $selectedPanel, panel, selectedPanel, labeledBy, $$scope, slots];
}
class TabPanel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$l, safe_not_equal, {});
  }
}
var SX_ICON_ASTRONAUT = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M64 224h13.5c24.7 56.5 80.9 96 146.5 96s121.8-39.5 146.5-96H384c8.8 0 16-7.2 16-16v-96c0-8.8-7.2-16-16-16h-13.5C345.8 39.5 289.6 0 224 0S102.2 39.5 77.5 96H64c-8.8 0-16 7.2-16 16v96c0 8.8 7.2 16 16 16zm40-88c0-22.1 21.5-40 48-40h144c26.5 0 48 17.9 48 40v24c0 53-43 96-96 96h-48c-53 0-96-43-96-96v-24zm72 72l12-36 36-12-36-12-12-36-12 36-36 12 36 12 12 36zm151.6 113.4C297.7 340.7 262.2 352 224 352s-73.7-11.3-103.6-30.6C52.9 328.5 0 385 0 454.4v9.6c0 26.5 21.5 48 48 48h80v-64c0-17.7 14.3-32 32-32h128c17.7 0 32 14.3 32 32v64h80c26.5 0 48-21.5 48-48v-9.6c0-69.4-52.9-125.9-120.4-133zM272 448c-8.8 0-16 7.2-16 16s7.2 16 16 16 16-7.2 16-16-7.2-16-16-16zm-96 0c-8.8 0-16 7.2-16 16v48h32v-48c0-8.8-7.2-16-16-16z"/></svg>';
function create_default_slot$a(ctx) {
  let header;
  let t0;
  let h3;
  let t2;
  let p0;
  let t4;
  let p1;
  let t6;
  let center;
  let span;
  let t7;
  let div;
  let button;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: { pops: true, title: "Not yet available" }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      h3 = element("h3");
      h3.textContent = "Nothing to see here!";
      t2 = space();
      p0 = element("p");
      p0.textContent = "This screen has not yet been implemented.";
      t4 = space();
      p1 = element("p");
      p1.textContent = "Please continue exploring the beta.";
      t6 = space();
      center = element("center");
      span = element("span");
      t7 = space();
      div = element("div");
      button = element("button");
      button.textContent = "Continue";
      attr(span, "class", "icon svelte-o7n71o");
      attr(button, "class", "primary");
      attr(div, "class", "action-line");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, h3, anchor);
      insert(target, t2, anchor);
      insert(target, p0, anchor);
      insert(target, t4, anchor);
      insert(target, p1, anchor);
      insert(target, t6, anchor);
      insert(target, center, anchor);
      append(center, span);
      span.innerHTML = SX_ICON_ASTRONAUT;
      insert(target, t7, anchor);
      insert(target, div, anchor);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(center);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$k(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 64) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let $yw_navigator;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(3, $yw_navigator = $$value));
  let { reset = false } = $$props;
  const b_reset = reset;
  const k_page = getContext("page");
  function cont() {
    if (b_reset) {
      k_page.reset();
      void $yw_navigator.activateThread(ThreadId.TOKENS);
    } else {
      k_page.pop();
    }
  }
  const click_handler2 = () => cont();
  $$self.$$set = ($$props2) => {
    if ("reset" in $$props2)
      $$invalidate(1, reset = $$props2.reset);
  };
  return [cont, reset, click_handler2];
}
class DeadEnd extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$k, safe_not_equal, { reset: 1 });
  }
}
function create_else_block$3(ctx) {
  let portrait;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[1],
      actions: ctx[2],
      $$slots: {
        subtitle: [create_subtitle_slot$1],
        default: [create_default_slot_1$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portrait.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 65) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
    }
  };
}
function create_if_block$8(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contact...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let t;
  return {
    c() {
      t = text("address");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_subtitle_slot$1(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: Chains.bech32(ctx[0].address)
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = Chains.bech32(ctx2[0].address);
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_default_slot$9(ctx) {
  let header;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      account: true
    }
  });
  const if_block_creators = [create_if_block$8, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$j(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 65) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let { contactRef } = $$props;
  const p_contact = contactRef;
  let g_contact;
  void Agents.getContact(p_contact).then((g) => $$invalidate(0, g_contact = g));
  const k_page = getContext("page");
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: { to: Chains.bech32(g_contact.address) }
        });
      }
    },
    edit: {
      label: "Edit",
      trigger() {
        k_page.push({
          creator: ContactEdit,
          props: { contactRef: p_contact }
        });
      }
    },
    delete: {
      label: "Delete",
      trigger() {
        k_page.push({ creator: DeadEnd });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("contactRef" in $$props2)
      $$invalidate(3, contactRef = $$props2.contactRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      g_contact ? Chains.bech32(g_contact.address) : "";
    }
  };
  return [g_contact, p_contact, gc_actions, contactRef];
}
class ContactView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$j, safe_not_equal, { contactRef: 3 });
  }
}
var SX_ICON_IMAGE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/>\n</svg>';
function create_if_block$7(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 48,
      ref: ctx[0],
      name: ctx[1]
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let div4;
  let div3;
  let span0;
  let t0;
  let span5;
  let div0;
  let t4;
  let div2;
  let div1;
  let span3;
  let t5;
  let span4;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] && create_if_block$7(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      span0 = element("span");
      if (if_block)
        if_block.c();
      t0 = space();
      span5 = element("span");
      div0 = element("div");
      div0.innerHTML = `<span class="warning svelte-1i7pjsy">Notice:</span> 
				<span class="info">Uploaded icons will be resized to be square. Only JPG &amp; PNG files less than 1MB allowed.</span>`;
      t4 = space();
      div2 = element("div");
      div1 = element("div");
      span3 = element("span");
      t5 = space();
      span4 = element("span");
      span4.textContent = "Upload Icon";
      attr(span0, "class", "left svelte-1i7pjsy");
      attr(div0, "class", "disclaimer svelte-1i7pjsy");
      attr(span3, "class", "icon svelte-1i7pjsy");
      attr(span4, "class", "text svelte-1i7pjsy");
      attr(div1, "class", "upload svelte-1i7pjsy");
      attr(div2, "class", "actions svelte-1i7pjsy");
      attr(span5, "class", "right svelte-1i7pjsy");
      attr(div3, "class", "row svelte-1i7pjsy");
      attr(div4, "class", "area svelte-1i7pjsy");
      toggle_class(div4, "intent-person", "person" === ctx[2]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, span0);
      if (if_block)
        if_block.m(span0, null);
      append(div3, t0);
      append(div3, span5);
      append(span5, div0);
      append(span5, t4);
      append(span5, div2);
      append(div2, div1);
      append(div1, span3);
      span3.innerHTML = SX_ICON_IMAGE;
      append(div1, t5);
      append(div1, span4);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[0])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { pfpRef } = $$props;
  const p_pfp = pfpRef || "";
  let { name = "" } = $$props;
  const s_name = name;
  let { intent = "token" } = $$props;
  const si_intent = intent;
  (async () => {
    if (p_pfp) {
      await Pfps.at(p_pfp);
    }
  })();
  const click_handler2 = () => F_NOOP;
  $$self.$$set = ($$props2) => {
    if ("pfpRef" in $$props2)
      $$invalidate(3, pfpRef = $$props2.pfpRef);
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("intent" in $$props2)
      $$invalidate(5, intent = $$props2.intent);
  };
  return [p_pfp, s_name, si_intent, pfpRef, name, intent, click_handler2];
}
class IconEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$i, safe_not_equal, { pfpRef: 3, name: 4, intent: 5 });
  }
}
function create_default_slot_6$1(ctx) {
  let iconeditor;
  let updating_name;
  let current;
  function iconeditor_name_binding(value) {
    ctx[17](value);
  }
  let iconeditor_props = {
    intent: "person",
    pfpRef: ctx[0]?.pfp
  };
  if (ctx[1] !== void 0) {
    iconeditor_props.name = ctx[1];
  }
  iconeditor = new IconEditor({ props: iconeditor_props });
  binding_callbacks.push(() => bind(iconeditor, "name", iconeditor_name_binding));
  return {
    c() {
      create_component(iconeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const iconeditor_changes = {};
      if (dirty & 1)
        iconeditor_changes.pfpRef = ctx2[0]?.pfp;
      if (!updating_name && dirty & 2) {
        updating_name = true;
        iconeditor_changes.name = ctx2[1];
        add_flush_callback(() => updating_name = false);
      }
      iconeditor.$set(iconeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconeditor, detaching);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let style;
  let t1;
  let span0;
  let t2_value = proper(ctx[9]) + "";
  let t2;
  let t3;
  let span1;
  let t4;
  let t5_value = ode(ctx[3]).filter(ctx[18]).map(func_1).join(", ") + "";
  let t5;
  let t6;
  return {
    c() {
      style = element("style");
      style.textContent = ".font-family_mono {\n  font-family: 'PT Mono';\n  white-space: pre;\n}\n.hide-scrollbar {\n  scrollbar-width: none;\n}\n.hide-scrollbar::-webkit-scrollbar {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-track {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-thumb {\n  background-color: rgba(0, 0, 0, 0.2);\n}\n.title {\n  font-family: Poppins;\n  font-weight: 400;\n  font-size: 14px;\n  color: var(--theme-color-text-light);\n}\n.examples {\n  margin-left: 0.5em;\n}";
      t1 = space();
      span0 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span1 = element("span");
      t4 = text("(");
      t5 = text(t5_value);
      t6 = text(")");
      attr(style, "lang", "less");
      attr(span0, "class", "title");
      attr(span1, "class", "examples");
    },
    m(target, anchor) {
      insert(target, style, anchor);
      insert(target, t1, anchor);
      insert(target, span0, anchor);
      append(span0, t2);
      insert(target, t3, anchor);
      insert(target, span1, anchor);
      append(span1, t4);
      append(span1, t5);
      append(span1, t6);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t2_value !== (t2_value = proper(ctx2[9]) + ""))
        set_data(t2, t2_value);
      if (dirty & 520 && t5_value !== (t5_value = ode(ctx2[3]).filter(ctx2[18]).map(func_1).join(", ") + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching)
        detach(style);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(span1);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "chain-family",
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 268435976) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_if_block_1$2(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[4]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[4] && create_if_block_1$2(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Enter a name");
      toggle_class(input, "invalid", ctx[4]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      if (dirty & 16) {
        toggle_class(input, "invalid", ctx2[4]);
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$6(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[5]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let input;
  let input_placeholder_value;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[5] && create_if_block$6(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "text");
      attr(input, "class", "address");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", input_placeholder_value = ctx[10].bech32s.acc + "1...");
      toggle_class(input, "invalid", ctx[5]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[2]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && input_placeholder_value !== (input_placeholder_value = ctx2[10].bech32s.acc + "1...")) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
      if (dirty & 32) {
        toggle_class(input, "invalid", ctx2[5]);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$3(ctx) {
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "placeholder", "");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(textarea, ctx[7]);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[21]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 128) {
        set_input_value(textarea, ctx2[7]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$8(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let field1;
  let t2;
  let field2;
  let t3;
  let field3;
  let t4;
  let field4;
  let t5;
  let hr;
  let t6;
  let h3;
  let t9;
  let inlinetags;
  let t10;
  let div;
  let button0;
  let t12;
  let button1;
  let t13_value = ctx[12] ? "Save" : "Add";
  let t13;
  let button1_readonly_value;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: {
      plain: true,
      pops: true,
      title: (ctx[12] ? "Edit" : "Add New") + " Contact"
    }
  });
  field0 = new Field({
    props: {
      key: "contact-pfp",
      name: "Profile Icon",
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      key: "chain-family",
      name: "Chain Family",
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      key: "contact-name",
      name: "Name",
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  field3 = new Field({
    props: {
      key: "contact-address",
      name: "Address",
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      key: "contact-notes",
      name: "Secure Notes",
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  inlinetags = new InlineTags({
    props: {
      editable: true,
      resourcePath: ctx[12]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      create_component(field1.$$.fragment);
      t2 = space();
      create_component(field2.$$.fragment);
      t3 = space();
      create_component(field3.$$.fragment);
      t4 = space();
      create_component(field4.$$.fragment);
      t5 = space();
      hr = element("hr");
      t6 = space();
      h3 = element("h3");
      h3.textContent = `${ctx[12] ? "Edit" : "Add"} Tags`;
      t9 = space();
      create_component(inlinetags.$$.fragment);
      t10 = space();
      div = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t12 = space();
      button1 = element("button");
      t13 = text(t13_value);
      attr(button1, "class", "primary");
      attr(button1, "readonly", button1_readonly_value = !ctx[8]);
      attr(div, "class", "action-line");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      mount_component(field1, target, anchor);
      insert(target, t2, anchor);
      mount_component(field2, target, anchor);
      insert(target, t3, anchor);
      mount_component(field3, target, anchor);
      insert(target, t4, anchor);
      mount_component(field4, target, anchor);
      insert(target, t5, anchor);
      insert(target, hr, anchor);
      insert(target, t6, anchor);
      insert(target, h3, anchor);
      insert(target, t9, anchor);
      mount_component(inlinetags, target, anchor);
      insert(target, t10, anchor);
      insert(target, div, anchor);
      append(div, button0);
      append(div, t12);
      append(div, button1);
      append(button1, t13);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[22]),
          listen(button1, "click", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 268435459) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 268435976) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 268435474) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const field3_changes = {};
      if (dirty & 268436516) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty & 268435584) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      if (!current || dirty & 256 && button1_readonly_value !== (button1_readonly_value = !ctx2[8])) {
        attr(button1, "readonly", button1_readonly_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t3);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t4);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(hr);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t9);
      destroy_component(inlinetags, detaching);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$h(ctx) {
  let screen;
  let current;
  let screen_props = {
    leaves: true,
    $$slots: { default: [create_default_slot$8] },
    $$scope: { ctx }
  };
  screen = new Screen({ props: screen_props });
  ctx[24](screen);
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 268437439) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[24](null);
      destroy_component(screen, detaching);
    }
  };
}
const func_1 = ([, g]) => g.bech32s.acc.hrp;
function instance$f($$self, $$props, $$invalidate) {
  let s_name;
  let s_addr;
  let sa_bech32;
  let s_notes;
  let si_agent_type;
  let b_form_valid;
  let $yw_family;
  let $yw_chain;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(9, $yw_family = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(10, $yw_chain = $$value));
  const k_page = getContext("page");
  let { contactRef = "" } = $$props;
  const p_contact = contactRef || "";
  let g_contact;
  if (p_contact)
    void Agents.getContact(p_contact).then((g) => $$invalidate(0, g_contact = g));
  let h_chains = {};
  (async function load_chains() {
    $$invalidate(3, h_chains = ofe((await Chains.read()).entries()));
  })();
  let s_err_name = "";
  let s_err_address = "";
  function pubkey_from_addr(sa_address, b_show_err = false) {
    const m_bech = R_BECH32.exec(sa_address);
    if (!m_bech) {
      if (b_show_err) {
        $$invalidate(5, s_err_address = "Invalid Bech32 address");
      }
      return "";
    }
    const [, s_chain, s_pubkey_local] = m_bech;
    let k_chain_match = null;
    for (const [, k_chain] of ode(H_CHAINS)) {
      if (k_chain.def.bechPrefix === s_chain) {
        k_chain_match = k_chain;
        break;
      }
    }
    if (b_show_err) {
      if (!k_chain_match) {
        $$invalidate(5, s_err_address = `No Cosmos SDK chains matched '${s_chain}'`);
      } else {
        $$invalidate(5, s_err_address = "");
      }
    }
    return $$invalidate(16, s_addr = s_pubkey_local);
  }
  let c_show_validations = 0;
  let y_screen;
  async function save() {
    if (!b_form_valid) {
      $$invalidate(15, c_show_validations++, c_show_validations);
      return;
    } else if (p_contact) {
      Object.assign(g_contact, {
        name: s_name,
        address: s_addr,
        pfp: g_contact.pfp,
        agentType: si_agent_type,
        notes: s_notes
      });
      k_page.reset();
    } else {
      $$invalidate(0, g_contact = {
        name: s_name,
        family: $yw_family,
        address: s_addr,
        pfp: g_contact.pfp,
        agentType: si_agent_type,
        notes: s_notes,
        space: "acc",
        origin: "user",
        chains: {}
      });
    }
    try {
      await Agents.open(async (ks_agents) => {
        await ks_agents.putContact(g_contact);
      });
      k_page.reset();
      k_page.push({
        creator: ContactView,
        props: { contactRef: p_contact }
      });
    } catch (e_write) {
    }
  }
  function iconeditor_name_binding(value) {
    s_name = value;
    $$invalidate(1, s_name), $$invalidate(0, g_contact);
  }
  const func = ([, g]) => $yw_family === g.family;
  function input_input_handler() {
    s_name = this.value;
    $$invalidate(1, s_name), $$invalidate(0, g_contact);
  }
  function input_input_handler_1() {
    sa_bech32 = this.value;
    $$invalidate(2, sa_bech32), $$invalidate(16, s_addr), $$invalidate(0, g_contact);
  }
  function textarea_input_handler() {
    s_notes = this.value;
    $$invalidate(7, s_notes), $$invalidate(0, g_contact);
  }
  const click_handler2 = () => k_page.pop();
  const click_handler_1 = () => save();
  function screen_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      y_screen = $$value;
      $$invalidate(6, y_screen);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("contactRef" in $$props2)
      $$invalidate(14, contactRef = $$props2.contactRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, s_name = g_contact?.name || "");
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(16, s_addr = g_contact?.address || "");
    }
    if ($$self.$$.dirty & 65536) {
      $$invalidate(2, sa_bech32 = s_addr ? Chains.bech32(s_addr) : "");
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(7, s_notes = g_contact?.notes || "");
    }
    if ($$self.$$.dirty & 1) {
      si_agent_type = g_contact?.agentType || ContactAgentType.PERSON;
    }
    if ($$self.$$.dirty & 6) {
      $$invalidate(8, b_form_valid = !!(s_name && pubkey_from_addr(sa_bech32)));
    }
    if ($$self.$$.dirty & 32774) {
      {
        if (c_show_validations) {
          $$invalidate(4, s_err_name = s_name ? "" : "Name must not be empty");
          pubkey_from_addr(sa_bech32, true);
        }
      }
    }
  };
  return [
    g_contact,
    s_name,
    sa_bech32,
    h_chains,
    s_err_name,
    s_err_address,
    y_screen,
    s_notes,
    b_form_valid,
    $yw_family,
    $yw_chain,
    k_page,
    p_contact,
    save,
    contactRef,
    c_show_validations,
    s_addr,
    iconeditor_name_binding,
    func,
    input_input_handler,
    input_input_handler_1,
    textarea_input_handler,
    click_handler2,
    click_handler_1,
    screen_binding
  ];
}
class ContactEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$h, safe_not_equal, { contactRef: 14 });
  }
}
var SX_ICON_DOTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-more-vert-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-more-vert-fg" d="M12 8C13.1 8 14 7.1 14 6C14 4.9 13.1 4 12 4C10.9 4 10 4.9 10 6C10 7.1 10.9 8 12 8ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10ZM12 16C10.9 16 10 16.9 10 18C10 19.1 10.9 20 12 20C13.1 20 14 19.1 14 18C14 16.9 13.1 16 12 16Z" fill="#FFB61A"/>\n</svg>\n';
var SX_ICON_SEND = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M9 16h6v-6h4l-7-7-7 7h4v6zm3-10.17L14.17 8H13v6h-2V8H9.83L12 5.83zM5 18h14v2H5z"/>\n</svg>';
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i][0];
  child_ctx[14] = list[i][1];
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_catch_block$4(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$4(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[12];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 63) {
        each_value = ctx2[12];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_detail_slot(ctx) {
  let address;
  let t;
  let current;
  address = new Address({
    props: {
      address: Chains.bech32(ctx[14].address + "")
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_prefix_slot(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "icon contact-type svelte-1l93agm");
      attr(span, "slot", "prefix");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_CONTACTS;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_tags_slot(ctx) {
  let inlinetags;
  let t;
  let current;
  inlinetags = new InlineTags({
    props: {
      collapsed: true,
      rootStyle: "margin: 0px;",
      resourcePath: ctx[13],
      $$slots: { prefix: [create_prefix_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inlinetags.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(inlinetags, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinetags_changes = {};
      if (dirty & 1048576) {
        inlinetags_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inlinetags.$set(inlinetags_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetags, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$5(ctx) {
  let span;
  let span_transition;
  let current;
  let each_value_1 = ctx[5];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(span, "class", "overlay");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span, null);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 36) {
        each_value_1 = ctx[5];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, slide, { duration: 300, easing: quintOut }, true);
        span_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!span_transition)
        span_transition = create_bidirectional_transition(span, slide, { duration: 300, easing: quintOut }, false);
      span_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_each(each_blocks, detaching);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_each_block_1$1(ctx) {
  let div;
  let span0;
  let raw_value = ctx[17].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[17].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler2(...args) {
    return ctx[9](ctx[17], ctx[14], ...args);
  }
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon");
      attr(span1, "class", "text");
      attr(div, "class", "action");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      span0.innerHTML = raw_value;
      append(div, t0);
      append(div, span1);
      append(span1, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(div, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_status_slot(ctx) {
  let span;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] === ctx[13] && create_if_block$5(ctx);
  return {
    c() {
      span = element("span");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      attr(span, "class", "icon more-menu");
      toggle_class(span, "active", ctx[0] === ctx[13]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_DOTS;
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[4](ctx[13], ctx[14]));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 5) {
        toggle_class(span, "active", ctx[0] === ctx[13]);
      }
      if (ctx[0] === ctx[13]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$5(ctx) {
  let row;
  let current;
  function click_handler_1(...args) {
    return ctx[10](ctx[14], ...args);
  }
  row = new Row({
    props: {
      resource: ctx[14],
      resourcePath: ctx[13],
      $$slots: {
        status: [create_status_slot],
        tags: [create_tags_slot],
        detail: [create_detail_slot]
      },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_1);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1048577) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contacts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$g(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block$4,
    value: 12,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "rows svelte-1l93agm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let $yw_family;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(11, $yw_family = $$value));
  const k_page = getContext("page");
  let { filter = (g) => true } = $$props;
  let { sort = (g_a, g_b) => g_a.name < g_b.name ? -1 : 1 } = $$props;
  let { append: append2 = [] } = $$props;
  async function load_contacts() {
    const ks_agents = await Agents.read();
    return [...ks_agents.contacts($yw_family)];
  }
  const hm_events = /* @__PURE__ */ new WeakMap();
  let si_overlay = "";
  function activate_overlay(p_contact, g_contact) {
    return (d_event) => {
      d_event.stopImmediatePropagation();
      const si_set = p_contact;
      if (hm_events.get(d_event)?.cancelMenu === si_set) {
        $$invalidate(0, si_overlay = "");
        return;
      }
      $$invalidate(0, si_overlay = si_set);
      window.addEventListener(
        "click",
        () => {
          hm_events.set(d_event, { cancelMenu: si_overlay });
          $$invalidate(0, si_overlay = "");
        },
        { capture: true, once: true }
      );
    };
  }
  const a_overlay_actions = [
    {
      label: "Edit",
      icon: SX_ICON_EDIT,
      click(g_contact) {
        k_page.push({
          creator: ContactEdit,
          props: { contact: g_contact }
        });
      }
    },
    {
      label: "Send",
      icon: SX_ICON_SEND,
      click(g_contact) {
        k_page.push({
          creator: Send,
          props: {
            recipient: Chains.bech32(g_contact.address)
          }
        });
      }
    },
    {
      label: "Delete",
      icon: SX_ICON_DELETE,
      click(g_contact) {
        k_page.push({ creator: DeadEnd, props: {} });
      }
    }
  ];
  const click_handler2 = (g_action, g_contact, d_event) => {
    d_event.stopPropagation();
    g_action.click(g_contact);
  };
  const click_handler_1 = (g_contact, d_event) => {
    if (!hm_events.get(d_event)?.cancelMenu) {
      k_page.push({
        creator: ContactView,
        props: { contact: g_contact }
      });
    }
  };
  $$self.$$set = ($$props2) => {
    if ("filter" in $$props2)
      $$invalidate(6, filter = $$props2.filter);
    if ("sort" in $$props2)
      $$invalidate(7, sort = $$props2.sort);
    if ("append" in $$props2)
      $$invalidate(8, append2 = $$props2.append);
  };
  return [
    si_overlay,
    k_page,
    load_contacts,
    hm_events,
    activate_overlay,
    a_overlay_actions,
    filter,
    sort,
    append2,
    click_handler2,
    click_handler_1
  ];
}
class ContactList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$g, safe_not_equal, { filter: 6, sort: 7, append: 8 });
  }
}
function create_default_slot_8(ctx) {
  let t;
  return {
    c() {
      t = text("All");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7(ctx) {
  let t;
  return {
    c() {
      t = text("Humans");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6(ctx) {
  let t;
  return {
    c() {
      t = text("Contracts");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let tab0;
  let t0;
  let tab1;
  let t1;
  let tab2;
  let current;
  tab0 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  tab1 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  tab2 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tab0.$$.fragment);
      t0 = space();
      create_component(tab1.$$.fragment);
      t1 = space();
      create_component(tab2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tab0, target, anchor);
      insert(target, t0, anchor);
      mount_component(tab1, target, anchor);
      insert(target, t1, anchor);
      mount_component(tab2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tab0_changes = {};
      if (dirty & 8) {
        tab0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab0.$set(tab0_changes);
      const tab1_changes = {};
      if (dirty & 8) {
        tab1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab1.$set(tab1_changes);
      const tab2_changes = {};
      if (dirty & 8) {
        tab2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab2.$set(tab2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tab0.$$.fragment, local);
      transition_in(tab1.$$.fragment, local);
      transition_in(tab2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tab0.$$.fragment, local);
      transition_out(tab1.$$.fragment, local);
      transition_out(tab2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tab0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(tab1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tab2, detaching);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({});
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_3$1(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({ props: { filter: ctx[0] } });
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({ props: { filter: ctx[1] } });
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_1$2(ctx) {
  let tablist;
  let t0;
  let tabpanel0;
  let t1;
  let tabpanel1;
  let t2;
  let tabpanel2;
  let current;
  tablist = new TabList({
    props: {
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  tabpanel0 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  tabpanel1 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  tabpanel2 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablist.$$.fragment);
      t0 = space();
      create_component(tabpanel0.$$.fragment);
      t1 = space();
      create_component(tabpanel1.$$.fragment);
      t2 = space();
      create_component(tabpanel2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablist, target, anchor);
      insert(target, t0, anchor);
      mount_component(tabpanel0, target, anchor);
      insert(target, t1, anchor);
      mount_component(tabpanel1, target, anchor);
      insert(target, t2, anchor);
      mount_component(tabpanel2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablist_changes = {};
      if (dirty & 8) {
        tablist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablist.$set(tablist_changes);
      const tabpanel0_changes = {};
      if (dirty & 8) {
        tabpanel0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel0.$set(tabpanel0_changes);
      const tabpanel1_changes = {};
      if (dirty & 8) {
        tabpanel1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel1.$set(tabpanel1_changes);
      const tabpanel2_changes = {};
      if (dirty & 8) {
        tabpanel2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel2.$set(tabpanel2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablist.$$.fragment, local);
      transition_in(tabpanel0.$$.fragment, local);
      transition_in(tabpanel1.$$.fragment, local);
      transition_in(tabpanel2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablist.$$.fragment, local);
      transition_out(tabpanel0.$$.fragment, local);
      transition_out(tabpanel1.$$.fragment, local);
      transition_out(tabpanel2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablist, detaching);
      if (detaching)
        detach(t0);
      destroy_component(tabpanel0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tabpanel1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(tabpanel2, detaching);
    }
  };
}
function create_default_slot$7(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let tabs;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "Contacts" } });
  tabs = new Tabs({
    props: {
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      create_component(tabs.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      mount_component(tabs, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_changes = {};
      if (dirty & 8) {
        tabs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabs.$set(tabs_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tabs, detaching);
    }
  };
}
function create_fragment$f(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      root: true,
      classNames: "contacts",
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$d($$self) {
  getContext("page");
  const func = (g_contact) => ContactAgentType.PERSON === g_contact.agentType;
  const func_12 = (g_contact) => ContactAgentType.CONTRACT === g_contact.agentType;
  return [func, func_12];
}
class ContactsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$f, safe_not_equal, {});
  }
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i][0];
  child_ctx[5] = list[i][1];
  return child_ctx;
}
function create_catch_block$3(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$4(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      pfp: ctx[5].pfp,
      name: ctx[5].host,
      resourcePath: ctx[4],
      iconClass: "square pfp"
    }
  });
  row.$on("click", ctx[2]);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$3(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$6(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({
    props: { bare: true, title: "Sites / Apps" }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    value: 3,
    blocks: [, , ,]
  };
  handle_promise(ctx[1](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$e(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "SitesHome",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 256) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$c($$self) {
  const k_page = getContext("page");
  async function load_apps() {
    const ks_apps = await Apps.read();
    return ks_apps.entries();
  }
  const click_handler2 = () => {
    k_page.push({});
  };
  return [k_page, load_apps, click_handler2];
}
class SitesHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$e, safe_not_equal, {});
  }
}
function create_else_block$2(ctx) {
  let portrait;
  let t0;
  let field;
  let t1;
  let if_block_anchor;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[2],
      actions: ctx[3],
      $$slots: {
        subtitle: [create_subtitle_slot],
        default: [create_default_slot_5]
      },
      $$scope: { ctx }
    }
  });
  field = new Field({
    props: {
      name: "gRPC-web URL",
      key: "grpc-web",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[0].rpcHost && create_if_block_1$1(ctx);
  return {
    c() {
      create_component(portrait.$$.fragment);
      t0 = space();
      create_component(field.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      insert(target, t0, anchor);
      mount_component(field, target, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 130) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
      const field_changes = {};
      if (dirty & 129) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
      if (ctx2[0].rpcHost) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      transition_in(field.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      transition_out(field.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field, detaching);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading network...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5(ctx) {
  let t;
  return {
    c() {
      t = text("address");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_subtitle_slot(ctx) {
  let span;
  let t0_value = ctx[1].name + "";
  let t0;
  let t1;
  let t2_value = ctx[1].id + "";
  let t2;
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" (");
      t2 = text(t2_value);
      t3 = text(")");
      attr(span, "class", "font-family_mono svelte-yy3tbl");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].name + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = ctx2[1].id + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_4(ctx) {
  let t_value = ctx[0].grpcWebUrl + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].grpcWebUrl + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "grpc-web-value",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 129) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let field;
  let current;
  field = new Field({
    props: {
      name: "RPC Host",
      key: "rpc",
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 129) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let t_value = ctx[0].rpcHost + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].rpcHost + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "rpc-value",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 129) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let header;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let gap;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      account: true
    }
  });
  const if_block_creators = [create_if_block$4, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  gap = new Gap({});
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      if_block.c();
      t1 = space();
      create_component(gap.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t1, anchor);
      mount_component(gap, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t1.parentNode, t1);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      transition_in(gap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      transition_out(gap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t1);
      destroy_component(gap, detaching);
    }
  };
}
function create_fragment$d(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 131) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let p_chain;
  let { networkRef } = $$props;
  const p_network = networkRef;
  let g_network;
  void Networks.at(p_network).then((g) => $$invalidate(0, g_network = g));
  let g_chain;
  getContext("page");
  const gc_actions = {};
  $$self.$$set = ($$props2) => {
    if ("networkRef" in $$props2)
      $$invalidate(4, networkRef = $$props2.networkRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(5, p_chain = g_network?.chain);
    }
    if ($$self.$$.dirty & 32) {
      if (p_chain) {
        void Chains.at(p_chain).then((g) => $$invalidate(1, g_chain = g));
      }
    }
  };
  return [g_network, g_chain, p_network, gc_actions, networkRef, p_chain];
}
class NetworkView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$d, safe_not_equal, { networkRef: 4 });
  }
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i][0];
  child_ctx[7] = list[i][1];
  const constants_0 = child_ctx[0].at(child_ctx[7].chain);
  child_ctx[8] = constants_0;
  return child_ctx;
}
function create_catch_block$2(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[5];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 7) {
        each_value = ctx2[5];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$3(ctx) {
  let row;
  let current;
  function click_handler2() {
    return ctx[3](ctx[6]);
  }
  row = new Row({
    props: {
      resource: ctx[7],
      resourcePath: ctx[6],
      iconClass: "square pfp",
      detail: `${ctx[8]?.name} (${ctx[8]?.id})`
    }
  });
  row.$on("click", click_handler2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1)
        row_changes.detail = `${ctx[8]?.name} (${ctx[8]?.id})`;
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$2(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$4(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { bare: true, title: "Networks" } });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2,
    value: 5,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$c(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "NetworksHome",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 2049) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  const k_page = getContext("page");
  let ks_chains;
  let ks_networks;
  async function load_networks() {
    $$invalidate(0, [ks_chains, ks_networks] = await Promise.all([Chains.read(), Networks.read()]), ks_chains);
    return ks_networks.entries();
  }
  const click_handler2 = (p_network) => {
    k_page.push({
      creator: NetworkView,
      props: { networkRef: p_network }
    });
  };
  return [ks_chains, k_page, load_networks, click_handler2];
}
class NetworksHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$c, safe_not_equal, {});
  }
}
function get_then_context(ctx) {
  const constants_0 = ctx[2].raw;
  ctx[3] = constants_0;
}
function create_catch_block$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$1(ctx) {
  get_then_context(ctx);
  let txnlist;
  let current;
  txnlist = new TxnList({ props: { events: ctx[3] } });
  return {
    c() {
      create_component(txnlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(txnlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      get_then_context(ctx2);
    },
    i(local) {
      if (current)
        return;
      transition_in(txnlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(txnlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(txnlist, detaching);
    }
  };
}
function create_pending_block$1(ctx) {
  let t;
  return {
    c() {
      t = text("Loading history...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_key_block(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    value: 2,
    blocks: [, , ,]
  };
  handle_promise(Events.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_default_slot$3(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let previous_key = ctx[0];
  let key_block_anchor;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "History", bare: true } });
  let key_block = create_key_block(ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_fragment$b(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 17) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let c_reloads = 1;
  const f_unsubscribe = global_receive({
    updateStore({ key: si_store }) {
      if ("events" === si_store) {
        $$invalidate(0, c_reloads++, c_reloads);
      }
    }
  });
  onDestroy(() => {
    f_unsubscribe();
  });
  return [c_reloads];
}
class HistoryHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$b, safe_not_equal, {});
  }
}
var ThreadId = /* @__PURE__ */ ((ThreadId2) => {
  ThreadId2["DEFAULT"] = "default";
  ThreadId2["INIT"] = "init";
  ThreadId2["SEARCH"] = "search";
  ThreadId2["TOKENS"] = "tokens";
  ThreadId2["NFTS"] = "nfts";
  ThreadId2["CONTACTS"] = "contacts";
  ThreadId2["HISTORY"] = "history";
  ThreadId2["NETWORKS"] = "networks";
  ThreadId2["ACCOUNTS"] = "accounts";
  ThreadId2["TAGS"] = "tags";
  ThreadId2["SITES"] = "sites";
  return ThreadId2;
})(ThreadId || {});
const H_THREADS = {
  ["default"]: Blank,
  ["init"]: Register,
  ["tokens"]: HoldingsHome,
  ["contacts"]: ContactsHome,
  ["history"]: HistoryHome,
  ["networks"]: NetworksHome,
  ["accounts"]: AccountsHome,
  ["sites"]: SitesHome
};
var Overscroll_svelte_svelte_type_style_lang = "";
function create_fragment$a(ctx) {
  let svg;
  let style;
  let t;
  let circle0;
  let circle1;
  let circle2;
  return {
    c() {
      svg = svg_element("svg");
      style = svg_element("style");
      t = text(".overscroll .bg {\n  fill: var(--theme-color-text-light);\n}\n.overscroll .ring {\n  fill: transparent;\n  stroke: #c4c4c4;\n}\n.overscroll .progress {\n  fill: transparent;\n  stroke: black;\n}\n");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      attr(style, "lang", "less");
      attr(circle0, "cx", "16");
      attr(circle0, "cy", "16");
      attr(circle0, "r", "16");
      attr(circle0, "class", "bg");
      attr(circle1, "cx", "16");
      attr(circle1, "cy", "16");
      attr(circle1, "r", "10");
      attr(circle1, "class", "ring");
      attr(circle1, "stroke-width", "3");
      set_style(circle1, "opacity", "0.2");
      attr(circle2, "cx", "16");
      attr(circle2, "cy", "16");
      attr(circle2, "r", "10");
      attr(circle2, "class", "progress svelte-1u2i3kk");
      attr(circle2, "stroke-width", "3");
      set_style(circle2, "stroke-dashoffset", 62 - ctx[1] * 62);
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "class", "overscroll svelte-1u2i3kk");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, style);
      append(style, t);
      append(svg, circle0);
      append(svg, circle1);
      append(svg, circle2);
      ctx[2](circle2);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        set_style(circle2, "stroke-dashoffset", 62 - ctx2[1] * 62);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      ctx[2](null);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $yw_overscroll_pct;
  component_subscribe($$self, yw_overscroll_pct, ($$value) => $$invalidate(1, $yw_overscroll_pct = $$value));
  let dm_progress;
  function circle2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_progress = $$value;
      $$invalidate(0, dm_progress);
    });
  }
  return [dm_progress, $yw_overscroll_pct, circle2_binding];
}
class Overscroll extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$a, safe_not_equal, {});
  }
}
var Popup_svelte_svelte_type_style_lang = "";
function create_fragment$9(ctx) {
  let div;
  let section;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[0];
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
  }
  return {
    c() {
      div = element("div");
      section = element("section");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(section, "class", "screen content svelte-rtd9ps");
      attr(div, "class", "popup svelte-rtd9ps");
      toggle_class(div, "showing", null !== ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, section);
      if (switch_instance) {
        mount_component(switch_instance, section, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(section, "click", click_handler),
          listen(div, "click", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (switch_value !== (switch_value = ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, section, null);
        } else {
          switch_instance = null;
        }
      }
      if (dirty & 1) {
        toggle_class(div, "showing", null !== ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
}
const click_handler = (d_event) => d_event.stopPropagation();
function instance$7($$self, $$props, $$invalidate) {
  let $yw_popup;
  component_subscribe($$self, yw_popup, ($$value) => $$invalidate(0, $yw_popup = $$value));
  const click_handler_1 = () => set_store_value(yw_popup, $yw_popup = null, $yw_popup);
  return [$yw_popup, click_handler_1];
}
class Popup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$9, safe_not_equal, {});
  }
}
var SX_ICON_EXPAND = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M12 16L18 10L16.59 8.59L12 13.17L7.41 8.59L6 10L12 16Z" />\n</svg>\n';
var SX_ICON_TOKENS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-tokens-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-tokens-fg" d="M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8Zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6ZM3 12a5.99 5.99 0 0 1 4-5.65V4.26C3.55 5.15 1 8.27 1 12c0 3.73 2.55 6.85 6 7.74v-2.09A5.99 5.99 0 0 1 3 12Z" />\n</svg>\n';
var SX_ICON_HISTORY = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M13 3a9 9 0 0 0-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42A8.954 8.954 0 0 0 13 21a9 9 0 0 0 0-18Zm-1 5v5l4.25 2.52.77-1.28-3.52-2.09V8H12Z" />\n</svg>\n';
var SX_ICON_MENU = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-menu-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-menu-fg" d="M4 19h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1Zm0-6h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1ZM3 6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1Z" />\n</svg>\n';
var Nav_svelte_svelte_type_style_lang = "";
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i][0];
  child_ctx[18] = list[i][1];
  return child_ctx;
}
function create_else_block$1(ctx) {
  let li;
  let div0;
  let html_tag;
  let raw_value = ctx[18].svg + "";
  let t0;
  let span;
  let t1;
  let div1;
  let t2_value = ctx[18].label + "";
  let t2;
  let t3;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[9](ctx[17]);
  }
  return {
    c() {
      li = element("li");
      div0 = element("div");
      html_tag = new HtmlTag(false);
      t0 = space();
      span = element("span");
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      html_tag.a = t0;
      attr(span, "class", "notification svelte-1ylq4j5");
      toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      attr(div0, "class", "icon svelte-1ylq4j5");
      attr(div1, "class", "label svelte-1ylq4j5");
      attr(li, "class", "button " + ctx[17] + " svelte-1ylq4j5");
      toggle_class(li, "active", ctx[0] === ctx[17]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      html_tag.m(raw_value, div0);
      append(div0, t0);
      append(div0, span);
      append(li, t1);
      append(li, div1);
      append(div1, t2);
      append(li, t3);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 18) {
        toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      }
      if (dirty & 17) {
        toggle_class(li, "active", ctx[0] === ctx[17]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$3(ctx) {
  let li;
  let div0;
  let html_tag;
  let raw_value = ctx[18].svg + "";
  let t0;
  let span;
  let t1;
  let div1;
  let t2_value = ctx[18].label + "";
  let t2;
  let t3;
  return {
    c() {
      li = element("li");
      div0 = element("div");
      html_tag = new HtmlTag(false);
      t0 = space();
      span = element("span");
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      html_tag.a = t0;
      attr(span, "class", "notification svelte-1ylq4j5");
      toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      attr(div0, "class", "icon svelte-1ylq4j5");
      attr(div1, "class", "label svelte-1ylq4j5");
      attr(li, "class", "button " + ctx[17] + " svelte-1ylq4j5");
      set_style(li, "opacity", "0.5");
      toggle_class(li, "active", ctx[0] === ctx[17]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      html_tag.m(raw_value, div0);
      append(div0, t0);
      append(div0, span);
      append(li, t1);
      append(li, div1);
      append(div1, t2);
      append(li, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 18) {
        toggle_class(span, "display_none", !ctx2[1].includes(ctx2[17]));
      }
      if (dirty & 17) {
        toggle_class(li, "active", ctx2[0] === ctx2[17]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_each_block$2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[18].disabled)
      return create_if_block$3;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$8(ctx) {
  let nav;
  let div;
  let t;
  let ul;
  let mounted;
  let dispose;
  let each_value = ode(ctx[4]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  return {
    c() {
      nav = element("nav");
      div = element("div");
      t = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "collapse icon svelte-1ylq4j5");
      attr(ul, "class", "bar svelte-1ylq4j5");
      attr(nav, "class", "svelte-1ylq4j5");
      toggle_class(nav, "collapsed", ctx[2]);
      toggle_class(nav, "visible", ctx[3]);
    },
    m(target, anchor) {
      insert(target, nav, anchor);
      append(nav, div);
      div.innerHTML = SX_ICON_EXPAND;
      append(nav, t);
      append(nav, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      if (!mounted) {
        dispose = listen(div, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 83) {
        each_value = ode(ctx2[4]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 4) {
        toggle_class(nav, "collapsed", ctx2[2]);
      }
      if (dirty & 8) {
        toggle_class(nav, "visible", ctx2[3]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(nav);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_thread;
  let $yw_page;
  let $yw_menu_expanded;
  let $yw_overlay_account;
  let $yw_overlay_network;
  let $yw_blur;
  let $yw_notifications;
  let $yw_nav_collapsed;
  let $yw_nav_visible;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(10, $yw_navigator = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(11, $yw_thread = $$value));
  component_subscribe($$self, yw_page, ($$value) => $$invalidate(7, $yw_page = $$value));
  component_subscribe($$self, yw_menu_expanded, ($$value) => $$invalidate(12, $yw_menu_expanded = $$value));
  component_subscribe($$self, yw_overlay_account, ($$value) => $$invalidate(13, $yw_overlay_account = $$value));
  component_subscribe($$self, yw_overlay_network, ($$value) => $$invalidate(14, $yw_overlay_network = $$value));
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(15, $yw_blur = $$value));
  component_subscribe($$self, yw_notifications, ($$value) => $$invalidate(1, $yw_notifications = $$value));
  component_subscribe($$self, yw_nav_collapsed, ($$value) => $$invalidate(2, $yw_nav_collapsed = $$value));
  component_subscribe($$self, yw_nav_visible, ($$value) => $$invalidate(3, $yw_nav_visible = $$value));
  const H_BUTTONS = {
    [ThreadId.TOKENS]: { svg: SX_ICON_TOKENS, label: "Tokens" },
    [ThreadId.CONTACTS]: {
      svg: SX_ICON_CONTACTS,
      label: "Contacts",
      disabled: true
    },
    [ThreadId.HISTORY]: { svg: SX_ICON_HISTORY, label: "History" },
    menu: { svg: SX_ICON_MENU, label: "Menu" }
  };
  const HM_HOMESCREENS = new Map(oderac(H_THREADS, (si_thread, dc_creator) => [dc_creator, si_thread]));
  let si_thread_head = "";
  function toggle_collapsed() {
    set_store_value(yw_nav_collapsed, $yw_nav_collapsed = !$yw_nav_collapsed, $yw_nav_collapsed);
  }
  function nav_click(si_button) {
    set_store_value(yw_notifications, $yw_notifications = $yw_notifications.filter((si) => si_button !== si), $yw_notifications);
    if ($yw_blur) {
      set_store_value(yw_blur, $yw_blur = false, $yw_blur);
    }
    if ($yw_overlay_network) {
      set_store_value(yw_overlay_network, $yw_overlay_network = false, $yw_overlay_network);
    }
    if ($yw_overlay_account) {
      set_store_value(yw_overlay_account, $yw_overlay_account = false, $yw_overlay_account);
    }
    switch (si_button) {
      case "menu": {
        set_store_value(yw_menu_expanded, $yw_menu_expanded = true, $yw_menu_expanded);
        break;
      }
      case si_thread_head: {
        $yw_navigator.activePage.dom.scrollTo({ top: 0, left: 0, behavior: "smooth" });
        break;
      }
      case $yw_thread.id: {
        const k_previous = $yw_page.peak();
        if (k_previous && HM_HOMESCREENS.get(k_previous.creator) === $yw_thread.id) {
          $yw_page.pop();
        } else {
          $yw_page.reset();
        }
        break;
      }
      default: {
        void $yw_navigator.activateThread(si_button);
        break;
      }
    }
  }
  const click_handler2 = () => toggle_collapsed();
  const click_handler_1 = (si_button) => nav_click(si_button);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(0, si_thread_head = $yw_page ? HM_HOMESCREENS.get($yw_page.creator) || "" : "");
    }
  };
  return [
    si_thread_head,
    $yw_notifications,
    $yw_nav_collapsed,
    $yw_nav_visible,
    H_BUTTONS,
    toggle_collapsed,
    nav_click,
    $yw_page,
    click_handler2,
    click_handler_1
  ];
}
class Nav extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$8, safe_not_equal, {});
  }
}
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
const PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
const MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
const BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
const FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
const AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}
var Search_svelte_svelte_type_style_lang = "";
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_each_block$1(ctx) {
  let genericrow;
  let current;
  genericrow = new GenericRow({ props: { item: ctx[9] } });
  return {
    c() {
      create_component(genericrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(genericrow, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(genericrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(genericrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(genericrow, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let header;
  let t0;
  let p2;
  let t3;
  let div;
  let each_1_anchor;
  let current;
  const header_spread_levels = [
    { network: true },
    { account: true },
    { search: true },
    { isSearchScreen: true },
    ctx[2] || {}
  ];
  let header_props = {};
  for (let i = 0; i < header_spread_levels.length; i += 1) {
    header_props = assign(header_props, header_spread_levels[i]);
  }
  header = new Header({ props: header_props });
  header.$on("search", ctx[5]);
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.innerHTML = `<span style="color:var(--theme-color-caution);">Disclaimer:</span>
			This temporary search interface does not represent the look and function of the actual search interface currently under development for beta.`;
      t3 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      set_style(p2, "font-size", "12px");
      attr(div, "class", "results no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append(div, each_1_anchor);
      ctx[6](div);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = dirty & 4 ? get_spread_update(header_spread_levels, [
        header_spread_levels[0],
        header_spread_levels[1],
        header_spread_levels[2],
        header_spread_levels[3],
        get_spread_object(ctx2[2] || {})
      ]) : {};
      header.$set(header_changes);
      if (dirty & 8) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      ctx[6](null);
    }
  };
}
function create_fragment$7(ctx) {
  let div;
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Search",
      root: true,
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(screen.$$.fragment);
      attr(div, "class", "search svelte-5f3tva");
      toggle_class(div, "display_none", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(screen, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 4102) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
      if (dirty & 1) {
        toggle_class(div, "display_none", !ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(screen);
    }
  };
}
var ClassType;
(function(ClassType2) {
  ClassType2["UNKNOWN"] = "unknown";
  ClassType2["FAMILY"] = "family";
  ClassType2["CHAIN"] = "chain";
  ClassType2["NETWORK"] = "network";
  ClassType2["ACCOUNT"] = "account";
  ClassType2["CONTACT"] = "contact";
  ClassType2["CONTRACT"] = "contract";
  ClassType2["TOKEN"] = "token";
  ClassType2["HOLDING"] = "holding";
  ClassType2["APP"] = "app";
  ClassType2["COIN"] = "coin";
  ClassType2["TAG"] = "tag";
  ClassType2["ICON"] = "icon";
  ClassType2["IBCT"] = "ibct";
  ClassType2["SNIP721"] = "snip721";
  ClassType2["TXN"] = "txn";
  ClassType2["OTHER"] = "other";
})(ClassType || (ClassType = {}));
function instance$5($$self, $$props, $$invalidate) {
  let $yw_search;
  let $yw_header_props;
  component_subscribe($$self, yw_search, ($$value) => $$invalidate(0, $yw_search = $$value));
  component_subscribe($$self, yw_header_props, ($$value) => $$invalidate(2, $yw_header_props = $$value));
  let dm_results;
  const a_results = [];
  let a_fuses = [];
  const fuzey = (a_items, a_keys) => new Fuse(
    a_items,
    {
      includeScore: true,
      includeMatches: true,
      keys: ["label", ...a_keys.map((s) => `details.${s}`)]
    }
  );
  (async () => {
    const ks_chains = await Chains.read();
    a_fuses = [
      (() => fuzey(
        ks_chains.entries().map(([p_chain, g_chain]) => ({
          class: ClassType.CHAIN,
          name: g_chain.name,
          resourcePath: p_chain,
          resource: g_chain,
          details: { name: g_chain.name, id: g_chain.id }
        })),
        ["id"]
      ))(),
      (() => fuzey(
        ks_chains.entries().flatMap(([p_chain, g_chain]) => oderac(g_chain.coins, (si_coin, g_coin) => ({
          class: ClassType.COIN,
          name: proper(g_coin.extra?.coingecko_id || "Unknown"),
          postname: si_coin,
          resourcePath: `${p_chain}/coin.${si_coin}`,
          resource: {
            name: proper(g_coin.extra?.coingecko_id || "Unknown"),
            pfp: g_chain.pfp,
            ...g_coin
          },
          details: {
            symbol: si_coin,
            denom: g_coin.denom,
            coingecko: g_coin.extra?.coingecko_id || ""
          }
        }))),
        ["symbol", "denom"]
      ))(),
      ...await Promise.all([
        (async () => {
          const ks_accounts = await Accounts.read();
          return fuzey(
            ks_accounts.entries().map(([p_account, g_account]) => {
              const a_addrs = [];
              const as_addrs = /* @__PURE__ */ new Set();
              for (const [, g_chain] of ks_chains) {
                as_addrs.add(Chains.addressFor(g_account.pubkey, g_chain));
              }
              a_addrs.push(...as_addrs);
              return {
                class: ClassType.ACCOUNT,
                name: g_account.name,
                resourcePath: p_account,
                resource: g_account,
                details: { name: g_account.name, addresses: a_addrs }
              };
            }),
            ["addresses"]
          );
        })(),
        (async () => {
          const ks_agents = await Agents.read();
          return fuzey(
            [...ks_agents.contacts()].map(([p_contact, g_contact]) => ({
              class: ClassType.CONTACT,
              name: g_contact.name,
              resourcePath: p_contact,
              resource: g_contact,
              details: {
                name: g_contact.name,
                notes: g_contact.notes,
                addresses: [...ks_chains.inFamily(g_contact.family)].map(([, g_chain]) => Chains.bech32(g_contact.address, g_chain))
              }
            })),
            ["notes"]
          );
        })(),
        (async () => {
          const ks_apps = await Apps.read();
          return fuzey(
            ks_apps.entries().map(([p_app, g_app]) => ({
              class: ClassType.APP,
              name: g_app.host,
              resourcePath: p_app,
              resource: g_app,
              details: { host: g_app.host }
            })),
            []
          );
        })(),
        (async () => {
          const a_tokens = [];
          for (const [, g_chain] of ks_chains.entries()) {
            for (const [si_spec, h_tokens] of ode(await Entities.readFungibleTokens(g_chain))) {
              for (const [p_token, g_token2] of ode(h_tokens)) {
                a_tokens.push({
                  class: ClassType.TOKEN,
                  name: g_token2.name,
                  resourcePath: p_token,
                  resource: g_token2,
                  details: {
                    spec: si_spec,
                    name: g_token2.name,
                    symbol: g_token2.symbol,
                    bech32: g_token2.bech32,
                    codehash: g_token2.hash
                  }
                });
              }
            }
          }
          return fuzey(a_tokens, ["spec", "symbol", "bech32", "codehash"]);
        })()
      ])
    ];
  })();
  function search2(s_search) {
    const a_groups = [];
    const a_hits = [];
    let c_total = 0;
    for (const y_fuse of a_fuses) {
      const a_hits_local = y_fuse.search(s_search);
      if (a_hits_local.length) {
        c_total += a_hits.length;
        a_hits.push(...a_hits_local);
        a_groups.push({
          top: a_hits_local[0].score,
          hits: a_hits_local
        });
      }
    }
    a_hits.sort((g_a, g_b) => g_b.score - g_a.score);
    $$invalidate(1, dm_results.innerHTML = "", dm_results);
    console.log(a_hits);
    for (const g_hit of a_hits) {
      new Row({
        target: dm_results,
        props: { ...g_hit.item, pfpDim: 32 }
      });
    }
  }
  const search_handler = (d_event) => search2(d_event.detail);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_results = $$value;
      $$invalidate(1, dm_results);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        if ($yw_search) {
          search2($yw_search);
        }
      }
    }
  };
  return [
    $yw_search,
    dm_results,
    $yw_header_props,
    a_results,
    search2,
    search_handler,
    div_binding
  ];
}
class Search extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$7, safe_not_equal, {});
  }
}
var Progress_svelte_svelte_type_style_lang = "";
function create_fragment$6(ctx) {
  let div1;
  let div0;
  let t0;
  let div2;
  let t1;
  let t2_value = (ctx[0][0] || ctx[0][1]) + "";
  let t2;
  let t3;
  let t4_value = ctx[0][1] + "";
  let t4;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      t1 = text("Step ");
      t2 = text(t2_value);
      t3 = text(" of ");
      t4 = text(t4_value);
      attr(div0, "class", "bar svelte-1hwu1hf");
      set_style(div0, "width", ctx[1] + "%");
      attr(div1, "class", "progress svelte-1hwu1hf");
      toggle_class(div1, "visible", ctx[0][0] > 0);
      attr(div2, "class", "step svelte-1hwu1hf");
      toggle_class(div2, "visible", ctx[0][0] > 0);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      append(div2, t1);
      append(div2, t2);
      append(div2, t3);
      append(div2, t4);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        set_style(div0, "width", ctx2[1] + "%");
      }
      if (dirty & 1) {
        toggle_class(div1, "visible", ctx2[0][0] > 0);
      }
      if (dirty & 1 && t2_value !== (t2_value = (ctx2[0][0] || ctx2[0][1]) + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx2[0][1] + ""))
        set_data(t4, t4_value);
      if (dirty & 1) {
        toggle_class(div2, "visible", ctx2[0][0] > 0);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div2);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let x_width_pct_bar;
  let $yw_progress;
  component_subscribe($$self, yw_progress, ($$value) => $$invalidate(0, $yw_progress = $$value));
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, x_width_pct_bar = $yw_progress[0] / $yw_progress[1] * 100);
    }
  };
  return [$yw_progress, x_width_pct_bar];
}
class Progress extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$6, safe_not_equal, {});
  }
}
var SX_ICON_CHAINS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="m18 16 4-4-4-4v3h-5.06A8.974 8.974 0 0 0 8 3.95 3.005 3.005 0 0 0 5 1C3.34 1 2 2.34 2 4s1.34 3 3 3c.95 0 1.78-.45 2.33-1.14C9.23 6.9 10.6 8.77 10.92 11h-3.1C7.4 9.84 6.3 9 5 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c1.3 0 2.4-.84 2.82-2h3.1c-.32 2.23-1.69 4.1-3.58 5.14C6.78 17.45 5.95 17 5 17c-1.66 0-3 1.34-3 3s1.34 3 3 3a2.99 2.99 0 0 0 2.99-2.95A8.974 8.974 0 0 0 12.93 13H18v3z"/>\n</svg>';
var SX_ICON_ACCOUNTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM7.07 18.28c.43-.9 3.05-1.78 4.93-1.78s4.51.88 4.93 1.78C15.57 19.36 13.86 20 12 20s-3.57-.64-4.93-1.72zm11.29-1.45c-1.43-1.74-4.9-2.33-6.36-2.33s-4.93.59-6.36 2.33A7.95 7.95 0 0 1 4 12c0-4.41 3.59-8 8-8s8 3.59 8 8c0 1.82-.62 3.49-1.64 4.83zM12 6c-1.94 0-3.5 1.56-3.5 3.5S10.06 13 12 13s3.5-1.56 3.5-3.5S13.94 6 12 6zm0 5c-.83 0-1.5-.67-1.5-1.5S11.17 8 12 8s1.5.67 1.5 1.5S12.83 11 12 11z"/>\n</svg>';
var SX_ICON_LOGOUT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M18 4v16H6V4h12m0-2H6c-1.1 0-2 .9-2 2v18h16V4c0-1.1-.9-2-2-2zm-2.5 8.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5S17 12.83 17 12s-.67-1.5-1.5-1.5z"/>\n</svg>';
var SideMenu_svelte_svelte_type_style_lang = "";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let li;
  let span0;
  let raw_value = ctx[10].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[10].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler_2() {
    return ctx[5](ctx[10]);
  }
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon svelte-fhv297");
      attr(span1, "class", "text svelte-fhv297");
      attr(li, "class", "svelte-fhv297");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span0);
      span0.innerHTML = raw_value;
      append(li, t0);
      append(li, span1);
      append(span1, t1);
      append(li, t2);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let li;
  let span0;
  let raw_value = ctx[10].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[10].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler_3() {
    return ctx[6](ctx[10]);
  }
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon svelte-fhv297");
      attr(span1, "class", "text svelte-fhv297");
      attr(li, "class", " svelte-fhv297");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span0);
      span0.innerHTML = raw_value;
      append(li, t0);
      append(li, span1);
      append(span1, t1);
      append(li, t2);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_3);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5(ctx) {
  let div6;
  let div0;
  let t0;
  let div5;
  let div1;
  let t1;
  let div4;
  let div2;
  let ul0;
  let t2;
  let hr;
  let t3;
  let div3;
  let ul1;
  let mounted;
  let dispose;
  let each_value_1 = ctx[2];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div6 = element("div");
      div0 = element("div");
      t0 = space();
      div5 = element("div");
      div1 = element("div");
      t1 = space();
      div4 = element("div");
      div2 = element("div");
      ul0 = element("ul");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      hr = element("hr");
      t3 = space();
      div3 = element("div");
      ul1 = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "backdrop svelte-fhv297");
      attr(div1, "class", "close icon svelte-fhv297");
      attr(ul0, "class", "session svelte-fhv297");
      attr(hr, "class", "svelte-fhv297");
      attr(div2, "class", "top svelte-fhv297");
      attr(ul1, "class", "items svelte-fhv297");
      attr(div3, "class", "main svelte-fhv297");
      attr(div4, "class", "menu svelte-fhv297");
      attr(div5, "class", "bar svelte-fhv297");
      attr(div6, "class", "side-menu svelte-fhv297");
      toggle_class(div6, "collapsed", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      append(div6, t0);
      append(div6, div5);
      append(div5, div1);
      div1.innerHTML = SX_ICON_CLOSE;
      append(div5, t1);
      append(div5, div4);
      append(div4, div2);
      append(div2, ul0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(ul0, null);
      }
      append(div2, t2);
      append(div2, hr);
      append(div4, t3);
      append(div4, div3);
      append(div3, ul1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul1, null);
      }
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[3]),
          listen(div1, "click", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value_1 = ctx2[2];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(ul0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & 2) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 1) {
        toggle_class(div6, "collapsed", !ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_menu_expanded;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(7, $yw_navigator = $$value));
  component_subscribe($$self, yw_menu_expanded, ($$value) => $$invalidate(0, $yw_menu_expanded = $$value));
  getContext("page");
  function activate(si_thread) {
    set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
    if (si_thread === $yw_navigator.activeThread.id) {
      $yw_navigator.activeThread.reset();
    } else {
      void $yw_navigator.activateThread(si_thread);
    }
  }
  const A_ITEMS = [
    {
      label: "Accounts",
      icon: SX_ICON_ACCOUNTS,
      click() {
        activate(ThreadId.ACCOUNTS);
      }
    },
    {
      label: "Networks",
      icon: SX_ICON_CHAINS,
      click() {
        activate(ThreadId.NETWORKS);
      }
    }
  ];
  const A_SESSION_ITEMS = [
    {
      label: "Log out",
      icon: SX_ICON_LOGOUT,
      async click() {
        await logout();
        globalThis.close();
      }
    }
  ];
  const click_handler2 = () => set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
  const click_handler_1 = () => set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
  const click_handler_2 = (g_item) => g_item.click();
  const click_handler_3 = (g_item) => g_item.click();
  return [
    $yw_menu_expanded,
    A_ITEMS,
    A_SESSION_ITEMS,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class SideMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$5, safe_not_equal, {});
  }
}
var VendorMenu_svelte_svelte_type_style_lang = "";
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text("[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$2(ctx) {
  let t0_value = (ctx[1] / 1e3).toFixed(2) + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" seconds");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = (ctx2[1] / 1e3).toFixed(2) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_fragment$4(ctx) {
  let div26;
  let div0;
  let t0;
  let div25;
  let div1;
  let t1;
  let div24;
  let div23;
  let div4;
  let div2;
  let t2;
  let div3;
  let t5;
  let div7;
  let div5;
  let t7;
  let div6;
  let t8;
  let t9;
  let div10;
  let div8;
  let t11;
  let div9;
  let span0;
  let t12;
  let t13;
  let div13;
  let div11;
  let t15;
  let div12;
  let span1;
  let t16;
  let t17;
  let div16;
  let div14;
  let t19;
  let div15;
  let t20;
  let t21;
  let t22;
  let div19;
  let div17;
  let t24;
  let div18;
  let t25;
  let div22;
  let div20;
  let t27;
  let div21;
  let t28;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block$2;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div26 = element("div");
      div0 = element("div");
      t0 = space();
      div25 = element("div");
      div1 = element("div");
      t1 = space();
      div24 = element("div");
      div23 = element("div");
      div4 = element("div");
      div2 = element("div");
      t2 = space();
      div3 = element("div");
      div3.textContent = `v${SI_VERSION}`;
      t5 = space();
      div7 = element("div");
      div5 = element("div");
      div5.textContent = "Network Status";
      t7 = space();
      div6 = element("div");
      t8 = text(ctx[2]);
      t9 = space();
      div10 = element("div");
      div8 = element("div");
      div8.textContent = "Chain Id";
      t11 = space();
      div9 = element("div");
      span0 = element("span");
      t12 = text(ctx[4]);
      t13 = space();
      div13 = element("div");
      div11 = element("div");
      div11.textContent = "Current Provider";
      t15 = space();
      div12 = element("div");
      span1 = element("span");
      t16 = text(ctx[3]);
      t17 = space();
      div16 = element("div");
      div14 = element("div");
      div14.textContent = "Current Block Height";
      t19 = space();
      div15 = element("div");
      t20 = text("#");
      t21 = text(ctx[0]);
      t22 = space();
      div19 = element("div");
      div17 = element("div");
      div17.textContent = "Average Block Time";
      t24 = space();
      div18 = element("div");
      if_block.c();
      t25 = space();
      div22 = element("div");
      div20 = element("div");
      div20.textContent = "Last Block Seen";
      t27 = space();
      div21 = element("div");
      t28 = text(ctx[5]);
      attr(div0, "class", "backdrop svelte-1y4wjl5");
      attr(div1, "class", "close icon svelte-1y4wjl5");
      attr(div4, "class", "app svelte-1y4wjl5");
      attr(div5, "class", "name svelte-1y4wjl5");
      attr(div6, "class", "value svelte-1y4wjl5");
      attr(div7, "class", "info svelte-1y4wjl5");
      attr(div8, "class", "name svelte-1y4wjl5");
      attr(span0, "class", "font-family_mono svelte-1y4wjl5");
      attr(div9, "class", "value svelte-1y4wjl5");
      attr(div10, "class", "info svelte-1y4wjl5");
      attr(div11, "class", "name svelte-1y4wjl5");
      attr(span1, "class", "font-family_mono svelte-1y4wjl5");
      attr(div12, "class", "value svelte-1y4wjl5");
      attr(div13, "class", "info svelte-1y4wjl5");
      attr(div14, "class", "name svelte-1y4wjl5");
      attr(div15, "class", "value svelte-1y4wjl5");
      attr(div16, "class", "info svelte-1y4wjl5");
      attr(div17, "class", "name svelte-1y4wjl5");
      attr(div18, "class", "value svelte-1y4wjl5");
      attr(div19, "class", "info svelte-1y4wjl5");
      attr(div20, "class", "name svelte-1y4wjl5");
      attr(div21, "class", "value svelte-1y4wjl5");
      attr(div22, "class", "info svelte-1y4wjl5");
      attr(div23, "class", "main svelte-1y4wjl5");
      attr(div24, "class", "menu svelte-1y4wjl5");
      attr(div25, "class", "bar svelte-1y4wjl5");
      attr(div26, "class", "vendor-menu svelte-1y4wjl5");
      toggle_class(div26, "collapsed", !ctx[6]);
    },
    m(target, anchor) {
      insert(target, div26, anchor);
      append(div26, div0);
      append(div26, t0);
      append(div26, div25);
      append(div25, div1);
      append(div25, t1);
      append(div25, div24);
      append(div24, div23);
      append(div23, div4);
      append(div4, div2);
      append(div4, t2);
      append(div4, div3);
      append(div23, t5);
      append(div23, div7);
      append(div7, div5);
      append(div7, t7);
      append(div7, div6);
      append(div6, t8);
      append(div23, t9);
      append(div23, div10);
      append(div10, div8);
      append(div10, t11);
      append(div10, div9);
      append(div9, span0);
      append(span0, t12);
      append(div23, t13);
      append(div23, div13);
      append(div13, div11);
      append(div13, t15);
      append(div13, div12);
      append(div12, span1);
      append(span1, t16);
      append(div23, t17);
      append(div23, div16);
      append(div16, div14);
      append(div16, t19);
      append(div16, div15);
      append(div15, t20);
      append(div15, t21);
      append(div23, t22);
      append(div23, div19);
      append(div19, div17);
      append(div19, t24);
      append(div19, div18);
      if_block.m(div18, null);
      append(div23, t25);
      append(div23, div22);
      append(div22, div20);
      append(div22, t27);
      append(div22, div21);
      append(div21, t28);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[8]),
          listen(div1, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4)
        set_data(t8, ctx2[2]);
      if (dirty & 16)
        set_data(t12, ctx2[4]);
      if (dirty & 8)
        set_data(t16, ctx2[3]);
      if (dirty & 1)
        set_data(t21, ctx2[0]);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div18, null);
        }
      }
      if (dirty & 32)
        set_data(t28, ctx2[5]);
      if (dirty & 64) {
        toggle_class(div26, "collapsed", !ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div26);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $yw_chain_ref;
  let $yw_network;
  let $yw_menu_vendor;
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(11, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_network, ($$value) => $$invalidate(7, $yw_network = $$value));
  component_subscribe($$self, yw_menu_vendor, ($$value) => $$invalidate(6, $yw_menu_vendor = $$value));
  let s_height = "";
  let xt_when = 0;
  let xt_avg_block_time = 0;
  let s_network_status = "Loading";
  let p_provider = "";
  let si_chain = "";
  global_receive({
    blockInfo(g_info) {
      if ($yw_chain_ref === g_info.chain) {
        $$invalidate(2, s_network_status = "Online");
        $$invalidate(4, si_chain = g_info.header.chain_id);
        $$invalidate(0, s_height = g_info.header.height);
        xt_when = Date.now();
        const a_recents = g_info.recents;
        if (a_recents.length > 1) {
          const a_gaps = [];
          for (let i_each = 1; i_each < a_recents.length; i_each++) {
            a_gaps.push(a_recents[i_each] - a_recents[i_each - 1]);
          }
          $$invalidate(1, xt_avg_block_time = a_gaps.reduce((c_out, x_value) => c_out + x_value, 0) / a_gaps.length);
        }
      }
    }
  });
  let s_long_ago = "[...]";
  const i_long_ago = window.setInterval(
    () => {
      if (xt_when > 0) {
        const xt_ago = Date.now() - xt_when;
        $$invalidate(5, s_long_ago = `${Math.round(xt_ago / 1e3)} seconds ago`);
      }
    },
    500
  );
  onDestroy(() => {
    clearInterval(i_long_ago);
  });
  const click_handler2 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = false, $yw_menu_vendor);
  const click_handler_1 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = false, $yw_menu_vendor);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      if ($yw_network) {
        $$invalidate(0, s_height = "[...]");
        xt_when = 0;
        $$invalidate(1, xt_avg_block_time = 0);
        $$invalidate(2, s_network_status = "Connecting");
        $$invalidate(3, p_provider = new URL($yw_network.grpcWebUrl).host);
        $$invalidate(4, si_chain = "");
      }
    }
  };
  return [
    s_height,
    xt_avg_block_time,
    s_network_status,
    p_provider,
    si_chain,
    s_long_ago,
    $yw_menu_vendor,
    $yw_network,
    click_handler2,
    click_handler_1
  ];
}
class VendorMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$4, safe_not_equal, {});
  }
}
class Page {
  constructor(gc_page, _kt_parent) {
    __publicField(this, "_dc_creator");
    __publicField(this, "_yc_component");
    __publicField(this, "_h_props");
    __publicField(this, "_h_context");
    __publicField(this, "_dm_page");
    __publicField(this, "_si_page");
    __publicField(this, "_h_events", {});
    __publicField(this, "_sr_path");
    __publicField(this, "_sx_pattern");
    this._kt_parent = _kt_parent;
    ({
      creator: this._dc_creator,
      props: this._h_props = {},
      context: this._h_context = {}
    } = gc_page);
    this._si_page = crypto.randomUUID();
    const dm_buffer = dd("div");
    const hm_context = new Map(ode({
      ...this._h_context,
      page: this
    }));
    this._yc_component = new this._dc_creator({
      target: dm_buffer,
      props: {
        ...this._h_props,
        k_page: this
      },
      context: hm_context
    });
    if (gc_page.events) {
      for (const [si_event, f_listener] of ode(gc_page.events)) {
        this._yc_component.$on(si_event, f_listener);
      }
    }
    const dm_state = dm_buffer.firstElementChild;
    if (!dm_state) {
      throw new Error(`No DOM element was created during page component spawning using: ${JSON.stringify(gc_page)}`);
    }
    this._dm_page = dm_state;
  }
  get id() {
    return this._si_page;
  }
  get index() {
    return this.thread.history.length;
  }
  get thread() {
    return this._kt_parent;
  }
  get creator() {
    return this._dc_creator;
  }
  get component() {
    return this._yc_component;
  }
  get props() {
    return this._h_props;
  }
  get dom() {
    return this._dm_page;
  }
  equivalent(w_other) {
    return w_other.creator === this.creator && !objects_might_differ(w_other.props || {}, this.props);
  }
  peak() {
    return this._kt_parent.peak();
  }
  push(gc_page) {
    return this._kt_parent.push(gc_page, this);
  }
  pop(gc_pop) {
    return this._kt_parent.pop(gc_pop || {}, this);
  }
  jump(gc_page, gc_jump) {
    return this._kt_parent.jump(gc_page, gc_jump || {}, this);
  }
  on(h_events) {
    for (const [si_event, f_listener] of ode(h_events)) {
      if (f_listener) {
        const a_listeners = this._h_events[si_event] = this._h_events[si_event] || [];
        a_listeners.push(f_listener);
      }
    }
  }
  async fire(si_event, a_args) {
    const a_listeners = this._h_events[si_event];
    if (a_listeners) {
      await Promise.all(a_listeners.map((f) => f(...a_args || [])));
    }
  }
  destroy() {
    this._yc_component.$destroy();
  }
  reset() {
    this._kt_parent.reset();
  }
}
class Thread {
  constructor(_si_thread, _gc_default, _k_navigator) {
    __publicField(this, "_dm_thread");
    __publicField(this, "_a_history", []);
    this._si_thread = _si_thread;
    this._gc_default = _gc_default;
    this._k_navigator = _k_navigator;
    this._dm_thread = dd("div", {
      "class": "thread",
      "data-thread-id": this._si_thread,
      "style": "z-index: 100;"
    });
  }
  get id() {
    return this._si_thread;
  }
  get default() {
    return this._gc_default;
  }
  get history() {
    return this._a_history;
  }
  get page() {
    return this._a_history[0];
  }
  get dom() {
    return this._dm_thread;
  }
  _place(gc_page) {
    const kp_new = new Page({
      ...gc_page,
      context: {
        ...this._k_navigator.context,
        ...gc_page.context
      }
    }, this);
    this._dm_thread.appendChild(kp_new.dom);
    this._a_history.unshift(kp_new);
    return kp_new;
  }
  reset(gc_page = this.default, gc_reset) {
    const {
      keepTop: b_keep_top
    } = gc_reset || {};
    const a_history = this._a_history;
    for (let i_state = b_keep_top ? 1 : 0; i_state < a_history.length; i_state++) {
      a_history[i_state].component.$destroy();
    }
    a_history.length = 0;
    const kp_new = this._place(gc_page);
    void this._k_navigator.after_reset(this, kp_new, gc_reset || {});
    return kp_new;
  }
  peak() {
    return this._a_history[1];
  }
  push(gc_page, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from pushing new screen");
    }
    if (!this._k_navigator.before_push(gc_page, kp_src, this)) {
      throw new Error("Prevented inactive thread from pushing new screen");
    }
    const kp_new = this._place(gc_page);
    void this._k_navigator.after_push(this, kp_src, kp_new);
    return kp_new;
  }
  pop(gc_pop, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from popping active screen");
    }
    if (this._a_history.length < 2) {
      throw new Error(`Failed to pop empty history`);
    }
    if (!this._k_navigator.before_pop(gc_pop, this._a_history[1], kp_src, this)) {
      throw new Error("Prevented inactive thread from popping active screen");
    }
    this._a_history.shift();
    const kp_dst = this.page;
    void this._k_navigator.after_pop(this, kp_src, kp_dst, gc_pop);
    return kp_dst;
  }
  jump(gc_page, gc_jump, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from jumping to screen");
    }
    if (!this._k_navigator.before_jump(gc_jump, gc_page, kp_src, this)) {
      throw new Error("Prevented inactive thread from jumping to screen");
    }
    const kp_prev = this._a_history[1];
    if (!gc_jump.force && kp_prev?.equivalent(gc_page)) {
      return this.pop({}, kp_src);
    }
    const kp_dst = new Page(gc_page, this);
    this.reset();
    set_zindex_relatively(kp_dst.dom, kp_src.dom, 1);
    void this._k_navigator.after_jump(this, kp_src, kp_dst, gc_jump).then(() => {
      try {
        kp_src.destroy();
      } catch (e_destroy) {
        console.warn(`Failed to destroy stale component belonging to page: ${kp_src.creator.name + ""}`);
        kp_src.dom.remove();
      }
    });
    return kp_dst;
  }
  hide() {
    this._dm_thread.style.display = "none";
  }
  show() {
    this._dm_thread.style.display = "initial";
  }
}
function set_zindex_relatively(dm_src, dm_dst, n_order) {
  const iz_src = +dm_src.style.zIndex;
  const iz_dst = iz_src + n_order;
  dm_src.style.zIndex = iz_src + "";
  dm_dst.style.zIndex = iz_dst + "";
}
class Navigator {
  constructor(_gc_navigator) {
    __publicField(this, "_h_threads", {});
    __publicField(this, "_h_thread_spawners");
    __publicField(this, "_dm_threads");
    __publicField(this, "_dm_buffer", dd("div"));
    __publicField(this, "_g_hooks");
    __publicField(this, "_h_context");
    __publicField(this, "_si_thread", ThreadId.DEFAULT);
    __publicField(this, "_c_thread_z", 200);
    this._gc_navigator = _gc_navigator;
    ({
      container: this._dm_threads,
      threads: this._h_thread_spawners,
      hooks: this._g_hooks,
      context: this._h_context = {}
    } = _gc_navigator);
    this._new_thread(ThreadId.DEFAULT);
  }
  get context() {
    return this._h_context;
  }
  _new_thread(si_thread, h_props = {}, h_context = {}) {
    const f_spawner = this._h_thread_spawners[si_thread];
    if (!f_spawner) {
      throw new Error(`Navigator has no such thread registered: '${si_thread}'`);
    }
    const kt_new = new Thread(si_thread, f_spawner(h_props, h_context), this);
    this._h_threads[si_thread] = kt_new;
    this._dm_threads.appendChild(kt_new.dom);
    kt_new.reset({
      ...kt_new.default,
      props: {
        ...kt_new.default.props,
        ...h_props
      }
    });
    return kt_new;
  }
  get activeThread() {
    return this._h_threads[this._si_thread];
  }
  get activePage() {
    return this.activeThread.page;
  }
  before_push(gc_page, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (false === this._g_hooks.before_change?.(kt_child, kp_src, "push"))
      return false;
    if (false === this._g_hooks.before_push?.(kt_child, kp_src, gc_page))
      return false;
    return true;
  }
  before_pop(gc_pop, kp_dst, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (false === this._g_hooks.before_change?.(kt_child, kp_src, "pop"))
      return false;
    if (false === this._g_hooks.before_pop?.(kt_child, kp_src, kp_dst, gc_pop))
      return false;
    return true;
  }
  before_jump(gc_jump, gc_page, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (false === this._g_hooks.before_change?.(kt_child, kp_src, "jump"))
      return false;
    if (false === this._g_hooks.before_jump?.(kt_child, kp_src, gc_page, gc_jump))
      return false;
    return true;
  }
  async before_switch(kt_src, si_thread) {
    if (false === this._g_hooks.before_change?.(kt_src, kt_src.page, "switch"))
      throw new Error("Cannot stop thread switch");
    await this._g_hooks.before_switch?.(kt_src, si_thread);
  }
  async after_push(kt_child, kp_src, kp_dst) {
    const h_extra = await this._g_hooks.after_push?.(kt_child, kp_src, kp_dst);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "push", h_extra || {});
  }
  async after_pop(kt_child, kp_src, kp_dst, gc_pop) {
    const h_extra = await this._g_hooks.after_pop?.(kt_child, kp_src, kp_dst, gc_pop);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "pop", h_extra || {});
  }
  async after_jump(kt_child, kp_src, kp_dst, gc_jump) {
    const h_extra = await this._g_hooks.after_jump?.(kt_child, kp_src, kp_dst, gc_jump);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "jump", h_extra || {});
  }
  async after_reset(kt_child, kp_dst, gc_reset) {
    const h_extra = await this._g_hooks.after_reset?.(kt_child, kp_dst, gc_reset);
    await this._g_hooks.after_change?.(kt_child, null, kp_dst, "reset", h_extra || {});
  }
  async after_switch(kt_src, kt_dst) {
    await this._g_hooks.after_switch?.(kt_src, kt_dst);
  }
  async activateThread(si_thread, h_props = {}) {
    const kt_src = this.activeThread;
    const kp_src = this.activePage;
    let kt_dst = this._h_threads[si_thread];
    if (si_thread !== this._si_thread) {
      await this.before_switch(kt_src, si_thread);
      this._si_thread;
      if (!kt_dst) {
        kt_dst = this._new_thread(si_thread, h_props);
      } else if (objects_might_differ(kt_dst.default.props || {}, h_props)) {
        const kp_dst = new Page({
          ...kt_dst.default,
          props: h_props,
          context: this._h_context
        }, kt_dst);
        kt_dst.reset(kp_dst, {
          keepTop: true
        });
        set_zindex_relatively(kp_src.dom, kp_dst.dom, -1);
      }
      this._si_thread = si_thread;
      this.activeThread.show();
      this.activeThread.dom.style.zIndex = this._c_thread_z++ + "";
      await this.after_switch(kt_src, kt_dst);
      return true;
    }
    return false;
  }
}
var System_svelte_svelte_type_style_lang = "";
function create_if_block$1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 25,
    blocks: [, , ,]
  };
  handle_promise(Vault.getRootKey(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[25] && create_if_block_1();
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1(ctx) {
  let overscrollsvelte;
  let t0;
  let navsvelte;
  let t1;
  let searchsvelte;
  let t2;
  let vendormenusvelte;
  let t3;
  let sidemenusvelte;
  let t4;
  let popupsvelte;
  let current;
  overscrollsvelte = new Overscroll({});
  navsvelte = new Nav({});
  searchsvelte = new Search({});
  vendormenusvelte = new VendorMenu({});
  sidemenusvelte = new SideMenu({});
  popupsvelte = new Popup({});
  return {
    c() {
      create_component(overscrollsvelte.$$.fragment);
      t0 = space();
      create_component(navsvelte.$$.fragment);
      t1 = space();
      create_component(searchsvelte.$$.fragment);
      t2 = space();
      create_component(vendormenusvelte.$$.fragment);
      t3 = space();
      create_component(sidemenusvelte.$$.fragment);
      t4 = space();
      create_component(popupsvelte.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overscrollsvelte, target, anchor);
      insert(target, t0, anchor);
      mount_component(navsvelte, target, anchor);
      insert(target, t1, anchor);
      mount_component(searchsvelte, target, anchor);
      insert(target, t2, anchor);
      mount_component(vendormenusvelte, target, anchor);
      insert(target, t3, anchor);
      mount_component(sidemenusvelte, target, anchor);
      insert(target, t4, anchor);
      mount_component(popupsvelte, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(overscrollsvelte.$$.fragment, local);
      transition_in(navsvelte.$$.fragment, local);
      transition_in(searchsvelte.$$.fragment, local);
      transition_in(vendormenusvelte.$$.fragment, local);
      transition_in(sidemenusvelte.$$.fragment, local);
      transition_in(popupsvelte.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overscrollsvelte.$$.fragment, local);
      transition_out(navsvelte.$$.fragment, local);
      transition_out(searchsvelte.$$.fragment, local);
      transition_out(vendormenusvelte.$$.fragment, local);
      transition_out(sidemenusvelte.$$.fragment, local);
      transition_out(popupsvelte.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overscrollsvelte, detaching);
      if (detaching)
        detach(t0);
      destroy_component(navsvelte, detaching);
      if (detaching)
        detach(t1);
      destroy_component(searchsvelte, detaching);
      if (detaching)
        detach(t2);
      destroy_component(vendormenusvelte, detaching);
      if (detaching)
        detach(t3);
      destroy_component(sidemenusvelte, detaching);
      if (detaching)
        detach(t4);
      destroy_component(popupsvelte, detaching);
    }
  };
}
function create_pending_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$3(ctx) {
  let main;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2;
  let progresssvelte;
  let t3;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  progresssvelte = new Progress({});
  let if_block = ctx[3] && create_if_block$1(ctx);
  return {
    c() {
      main = element("main");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(progresssvelte.$$.fragment);
      t3 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "content threads svelte-m1b0zj");
      attr(div1, "class", "content exitting svelte-m1b0zj");
      attr(main, "class", "viewport svelte-m1b0zj");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div0);
      ctx[8](div0);
      append(main, t0);
      append(main, div1);
      ctx[9](div1);
      append(main, t1);
      if (default_slot) {
        default_slot.m(main, null);
      }
      append(main, t2);
      mount_component(progresssvelte, main, null);
      append(main, t3);
      if (if_block)
        if_block.m(main, null);
      ctx[10](main);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (ctx2[3])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(progresssvelte.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(progresssvelte.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      ctx[8](null);
      ctx[9](null);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(progresssvelte);
      if (if_block)
        if_block.d();
      ctx[10](null);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_thread;
  let $yw_page;
  let $yw_account_ref;
  let $yw_account;
  let $yw_network_ref;
  let $yw_network_active;
  let $yw_chain_ref;
  let $yw_chain;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(11, $yw_navigator = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(12, $yw_thread = $$value));
  component_subscribe($$self, yw_page, ($$value) => $$invalidate(13, $yw_page = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(14, $yw_account_ref = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(15, $yw_account = $$value));
  component_subscribe($$self, yw_network_ref, ($$value) => $$invalidate(16, $yw_network_ref = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(17, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(18, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(19, $yw_chain = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { page } = $$props;
  const gc_page = page;
  let { mode } = $$props;
  const b_flow = "flow" === mode;
  const b_main = "app" === mode;
  let dm_viewport;
  let dm_threads;
  let dm_exitting;
  const h_context_all = Object.fromEntries(getAllContexts().entries());
  async function slide2(dm_slide, b_in = false) {
    await timeout(0);
    return new Promise((fk_resolve) => {
      dm_slide.addEventListener("transitionend", function transition_end(d_event) {
        if ("transform" === d_event.propertyName) {
          dm_slide.classList.add("slid");
          fk_resolve();
        }
      });
      dm_slide.style.transform = `translateX(${b_in ? "0px" : "var(--app-window-width)"})`;
    });
  }
  onMount(async () => {
    const gc_navigator = {
      container: dm_threads,
      context: h_context_all,
      threads: {
        default: () => ({ creator: Blank })
      },
      hooks: {
        before_change(kt_context, kp_src, kp_dst) {
          void kp_src.fire("blur");
        },
        after_push(kt_context, kp_src, kp_dst) {
          void tick().then(() => {
            void slide2(kp_dst.dom, true);
          });
        },
        after_pop(kt_context, kp_src, kp_dst, gc_pop) {
          void kp_dst.fire("restore");
          if (!gc_pop.bypassAnimation) {
            kp_src.dom.style.transform = `translateX(var(--app-window-width))`;
          }
        },
        after_change(kt_context, kp_src, kp_dst, s_transition, h_extra = {}) {
          set_store_value(yw_page, $yw_page = kp_dst, $yw_page);
          set_store_value(yw_thread, $yw_thread = kt_context, $yw_thread);
          void kp_dst.fire("focus");
        },
        async before_switch() {
          try {
            await Promise.all([
              $yw_chain || once_store_updates(yw_chain, true),
              Chains.read().then((ks) => set_store_value(yw_chain_ref, $yw_chain_ref = ode(ks.raw)[0][0], $yw_chain_ref)),
              $yw_network_active || once_store_updates(yw_network_active, true),
              Networks.read().then((ks) => set_store_value(yw_network_ref, $yw_network_ref = ode(ks.raw)[0][0], $yw_network_ref)),
              $yw_account || once_store_updates(yw_account, true),
              Accounts.read().then((ks) => set_store_value(yw_account_ref, $yw_account_ref = ode(ks.raw)[0][0], $yw_account_ref))
            ]);
            delete this.before_switch;
          } catch (e_load_default) {
          }
        },
        async after_switch(kt_src, kt_dst) {
          set_store_value(yw_page, $yw_page = kt_dst.page, $yw_page);
          set_store_value(yw_thread, $yw_thread = kt_dst, $yw_thread);
          void kt_dst.page.fire("focus");
          await tick();
          await slide2(kt_dst.page.dom, true);
        }
      }
    };
    if (b_flow) {
      gc_navigator.threads = { default: () => gc_page };
    } else if (b_main) {
      gc_navigator.threads = oderom(H_THREADS, (si_thread, dc_screen) => {
        return {
          [si_thread]: (h_props) => ({ creator: dc_screen, props: h_props })
        };
      });
      gc_navigator.threads.init = (h_props, h_context) => ({
        ...gc_page,
        props: { ...gc_page.props, ...h_props },
        context: { ...gc_page.context, ...h_context }
      });
    }
    const k_navigator = new Navigator(gc_navigator);
    set_store_value(yw_navigator, $yw_navigator = k_navigator, $yw_navigator);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_threads = $$value;
      $$invalidate(1, dm_threads);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_exitting = $$value;
      $$invalidate(2, dm_exitting);
    });
  }
  function main_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_viewport = $$value;
      $$invalidate(0, dm_viewport);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("page" in $$props2)
      $$invalidate(4, page = $$props2.page);
    if ("mode" in $$props2)
      $$invalidate(5, mode = $$props2.mode);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    dm_viewport,
    dm_threads,
    dm_exitting,
    b_main,
    page,
    mode,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    main_binding
  ];
}
class System extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$3, safe_not_equal, { page: 4, mode: 5 });
  }
}
var Authenticate_svelte_svelte_type_style_lang = "";
function create_if_block(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 2)
        set_data(t, ctx2[1]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_1(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "name", "password");
      attr(input, "placeholder", "Password");
      toggle_class(input, "invalid", ctx[1]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (dirty & 2) {
        toggle_class(input, "invalid", ctx2[1]);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$1(ctx) {
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t3;
  let div3;
  let field;
  let t4;
  let actionsline;
  let t5;
  let log_1;
  let updating_items;
  let current;
  field = new Field({
    props: {
      key: "password",
      name: "",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      confirm: ["Unlock", ctx[3]]
    }
  });
  function log_1_items_binding(value) {
    ctx[5](value);
  }
  let log_1_props = { hide: true };
  if (ctx[2].items !== void 0) {
    log_1_props.items = ctx[2].items;
  }
  log_1 = new Log({ props: log_1_props });
  binding_callbacks.push(() => bind(log_1, "items", log_1_items_binding));
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<img width="96" src="/media/vendor/logo-96px.png" srcset="/media/vendor/logo-96px.png 1x, /media/vendor/logo-192px.png 2x" alt="StarShell"/>`;
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<img src="/media/vendor/title.svg" alt=""/>`;
      t1 = space();
      div2 = element("div");
      div2.textContent = "\xA0";
      t3 = space();
      div3 = element("div");
      create_component(field.$$.fragment);
      t4 = space();
      create_component(actionsline.$$.fragment);
      t5 = space();
      create_component(log_1.$$.fragment);
      attr(div0, "class", "logo");
      attr(div1, "class", "title");
      attr(div2, "class", "line svelte-wsweyo");
      attr(div3, "class", "form flex-rows");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      insert(target, t3, anchor);
      insert(target, div3, anchor);
      mount_component(field, div3, null);
      insert(target, t4, anchor);
      mount_component(actionsline, target, anchor);
      insert(target, t5, anchor);
      mount_component(log_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 1027) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
      const log_1_changes = {};
      if (!updating_items && dirty & 4) {
        updating_items = true;
        log_1_changes.items = ctx2[2].items;
        add_flush_callback(() => updating_items = false);
      }
      log_1.$set(log_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      transition_in(log_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      transition_out(log_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div3);
      destroy_component(field);
      if (detaching)
        detach(t4);
      destroy_component(actionsline, detaching);
      if (detaching)
        detach(t5);
      destroy_component(log_1, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let t;
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Authenticate",
      classNames: "welcome",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1031) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(screen, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const completed = getContext("completed");
  let sh_password = "";
  let s_err_password = "";
  let b_busy = false;
  let xt_start = 0;
  let k_logger = new Logger();
  function log(s_msg) {
    $$invalidate(2, k_logger = k_logger.event(s_msg, Date.now() - xt_start));
  }
  async function attempt_unlock(b_recover = false) {
    if (b_busy)
      return 1;
    b_busy = true;
    const exit = () => (b_busy = false, 1);
    $$invalidate(1, s_err_password = "");
    xt_start = Date.now();
    log("Estimating time to complete");
    {
      const xt_start_est = window.performance.now();
      await Vault.deriveRootBits(ATU8_DUMMY_PHRASE, ATU8_DUMMY_VECTOR, 1 / 50);
      const xt_finish_est = window.performance.now();
      const xt_elapsed = xt_finish_est - xt_start_est;
      const xt_estimate = 2 * (xt_elapsed * 50);
      log(`About ${(xt_estimate / 1e3).toFixed(1)} seconds`);
    }
    try {
      await login(sh_password, b_recover, log);
    } catch (e_login) {
      if (e_login instanceof UnregisteredError) {
        $$invalidate(1, s_err_password = "No accounts detected");
      } else if (e_login instanceof InvalidPassphraseError) {
        $$invalidate(1, s_err_password = "Invalid passphrase");
      } else if (e_login instanceof RecoverableVaultError) {
        $$invalidate(1, s_err_password = "Vault is partially corrupted; attempting recovery...");
        return await attempt_unlock(true);
      } else if (b_recover) {
        $$invalidate(1, s_err_password = `Recovery failed. Vault may be irreparably corrupted.
${e_login.message}`);
      } else if (e_login instanceof CorruptedVaultError) {
        $$invalidate(1, s_err_password = `Vault appears to be irreparably corrupted.
${e_login.message}`);
      } else {
        $$invalidate(1, s_err_password = `Unknown error occurred: ${e_login.stack || e_login.message}`);
      }
      return exit();
    }
    if (completed)
      completed(true);
    return exit();
  }
  function input_input_handler() {
    sh_password = this.value;
    $$invalidate(0, sh_password);
  }
  function log_1_items_binding(value) {
    if ($$self.$$.not_equal(k_logger.items, value)) {
      k_logger.items = value;
      $$invalidate(2, k_logger);
    }
  }
  return [
    sh_password,
    s_err_password,
    k_logger,
    attempt_unlock,
    input_input_handler,
    log_1_items_binding
  ];
}
class Authenticate extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment$2, safe_not_equal, {});
  }
}
const dm_log = qs(document, "section#dom-log");
const dm_log_list = qs(document, "#dom-log-list");
function domlog(si_msg) {
  console.log(si_msg);
  dm_log_list?.append(dd("li", {}, [
    dd("pre", {}, [si_msg])
  ]));
}
var Horizon_svelte_svelte_type_style_lang = "";
function create_fragment$1(ctx) {
  let div;
  let raw_value = "&nbsp;";
  return {
    c() {
      div = element("div");
      attr(div, "class", "no-margin horizon svelte-12kmiz9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class Horizon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1, safe_not_equal, {});
  }
}
var PreRegister_svelte_svelte_type_style_lang = "";
function create_default_slot(ctx) {
  let starshelllogo;
  let t0;
  let starshelltitle;
  let t1;
  let horizon;
  let t2;
  let div2;
  let t6;
  let p2;
  let t7;
  let actionsline;
  let current;
  starshelllogo = new StarShellLogo({ props: { dim: 96 } });
  starshelltitle = new StarShellTitle({});
  horizon = new Horizon({});
  actionsline = new ActionsLine({
    props: {
      confirm: ["Get Started"],
      contd: { creator: Register }
    }
  });
  return {
    c() {
      create_component(starshelllogo.$$.fragment);
      t0 = space();
      create_component(starshelltitle.$$.fragment);
      t1 = space();
      create_component(horizon.$$.fragment);
      t2 = space();
      div2 = element("div");
      div2.innerHTML = `<div>Welcome to the beta program.</div> 
		<div>Thank for you being a tester!</div>`;
      t6 = space();
      p2 = element("p");
      t7 = space();
      create_component(actionsline.$$.fragment);
      attr(div2, "class", "large");
    },
    m(target, anchor) {
      mount_component(starshelllogo, target, anchor);
      insert(target, t0, anchor);
      mount_component(starshelltitle, target, anchor);
      insert(target, t1, anchor);
      mount_component(horizon, target, anchor);
      insert(target, t2, anchor);
      insert(target, div2, anchor);
      insert(target, t6, anchor);
      insert(target, p2, anchor);
      insert(target, t7, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      transition_in(starshelltitle.$$.fragment, local);
      transition_in(horizon.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      transition_out(starshelltitle.$$.fragment, local);
      transition_out(horizon.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starshelllogo, detaching);
      if (detaching)
        detach(t0);
      destroy_component(starshelltitle, detaching);
      if (detaching)
        detach(t1);
      destroy_component(horizon, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t7);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      root: true,
      classNames: "preregister",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
class PreRegister extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}
export { AccountEdit as A, Blank as B, Header as H, PreRegister as P, Screen as S, ThreadId as T, StarShellLogo as a, StarShellTitle as b, Horizon as c, dm_log as d, System as e, domlog as f, Authenticate as g };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJlUmVnaXN0ZXIuNGNmYTUyYWEuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3ZpdGUvbW9kdWxlcHJlbG9hZC1wb2x5ZmlsbCIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0JsYW5rLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL1NjcmVlbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3VpL1N0YXJTaGVsbExvZ28uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9PdmVybGF5U2VsZWN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL2Fycm93LWxlZnQuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3NlYXJjaC5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vY2hlY2tlZC1jaXJjbGUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvSGVhZGVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvTG9nLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvU3RhclNoZWxsVGl0bGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vUmVnaXN0ZXJXZWFrUGFzc3dvcmQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vUmVnaXN0ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vYWNjb3VudF9ib3guc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2FuYWx5dGljcy5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vZG9udXRfbGFyZ2Uuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvQXNzZXRTZWxlY3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vZXhwYW5kX2xlc3Muc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2V4cGFuZF9tb3JlLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL3VpL0Ftb3VudElucHV0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvU2VuZGVyU2VsZWN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvSW5saW5lQ29udGFjdFNlbGVjdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3VpL1JlY2lwaWVudFNlbGVjdEl0ZW0uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9SZWNpcGllbnRTZWxlY3RTZWxlY3Rpb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9SZWNpcGllbnRTZWxlY3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vU2VuZE5hdGl2ZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9TZW5kLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvR2FwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jaGFpbi9jb2luLnRzIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSG9sZGluZ1ZpZXcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSG9sZGluZ3NIb21lLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRFZGl0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRWaWV3LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRzSG9tZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRhYnMvc3JjL2lkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10YWJzL3NyYy9UYWJzLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGFicy9zcmMvVGFiLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGFicy9zcmMvVGFiTGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRhYnMvc3JjL1RhYlBhbmVsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL3VzZXItYXN0cm9uYXV0LnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9EZWFkRW5kLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0NvbnRhY3RWaWV3LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL2ltYWdlLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL3VpL0ljb25FZGl0b3Iuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vQ29udGFjdEVkaXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vbW9yZS12ZXJ0LnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvaWNvbi91cGxvYWQuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvQ29udGFjdExpc3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vQ29udGFjdHNIb21lLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL1NpdGVzSG9tZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9OZXR3b3JrVmlldy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9OZXR3b3Jrc0hvbWUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSGlzdG9yeUhvbWUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9kZWYudHMiLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vT3ZlcnNjcm9sbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vUG9wdXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vZXhwYW5kLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvaWNvbi90b2tlbnMuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2hpc3Rvcnkuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL21lbnUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL3N5c3RlbS9OYXYuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Z1c2UuanMvZGlzdC9mdXNlLmVzbS5qcyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL3N5c3RlbS9TZWFyY2guc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9jb250YWluZXIvc3lzdGVtL1Byb2dyZXNzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL21lZGlhdGlvbi5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vYWNjb3VudF9jaXJjbGUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3NlbnNvcl9kb29yLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vU2lkZU1lbnUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9jb250YWluZXIvc3lzdGVtL1ZlbmRvck1lbnUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9uYXYvcGFnZS50cyIsIi4uLy4uLy4uL3NyYy9hcHAvbmF2L3RocmVhZC50cyIsIi4uLy4uLy4uL3NyYy9hcHAvbmF2L25hdmlnYXRvci50cyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL1N5c3RlbS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9BdXRoZW50aWNhdGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2VudHJ5L2ZhbGxiYWNrLnRzIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9Ib3Jpem9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL1ByZVJlZ2lzdGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwID0gZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgY29uc3QgcmVsTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKS5yZWxMaXN0O1xuICAgIGlmIChyZWxMaXN0ICYmIHJlbExpc3Quc3VwcG9ydHMgJiYgcmVsTGlzdC5zdXBwb3J0cygnbW9kdWxlcHJlbG9hZCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsaW5rIG9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbcmVsPVwibW9kdWxlcHJlbG9hZFwiXScpKSB7XG4gICAgICAgIHByb2Nlc3NQcmVsb2FkKGxpbmspO1xuICAgIH1cbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRpb24udHlwZSAhPT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBtdXRhdGlvbi5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ0xJTksnICYmIG5vZGUucmVsID09PSAnbW9kdWxlcHJlbG9hZCcpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NQcmVsb2FkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkub2JzZXJ2ZShkb2N1bWVudCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgZnVuY3Rpb24gZ2V0RmV0Y2hPcHRzKHNjcmlwdCkge1xuICAgICAgICBjb25zdCBmZXRjaE9wdHMgPSB7fTtcbiAgICAgICAgaWYgKHNjcmlwdC5pbnRlZ3JpdHkpXG4gICAgICAgICAgICBmZXRjaE9wdHMuaW50ZWdyaXR5ID0gc2NyaXB0LmludGVncml0eTtcbiAgICAgICAgaWYgKHNjcmlwdC5yZWZlcnJlcnBvbGljeSlcbiAgICAgICAgICAgIGZldGNoT3B0cy5yZWZlcnJlclBvbGljeSA9IHNjcmlwdC5yZWZlcnJlcnBvbGljeTtcbiAgICAgICAgaWYgKHNjcmlwdC5jcm9zc29yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycpXG4gICAgICAgICAgICBmZXRjaE9wdHMuY3JlZGVudGlhbHMgPSAnaW5jbHVkZSc7XG4gICAgICAgIGVsc2UgaWYgKHNjcmlwdC5jcm9zc29yaWdpbiA9PT0gJ2Fub255bW91cycpXG4gICAgICAgICAgICBmZXRjaE9wdHMuY3JlZGVudGlhbHMgPSAnb21pdCc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZldGNoT3B0cy5jcmVkZW50aWFscyA9ICdzYW1lLW9yaWdpbic7XG4gICAgICAgIHJldHVybiBmZXRjaE9wdHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQcmVsb2FkKGxpbmspIHtcbiAgICAgICAgaWYgKGxpbmsuZXApXG4gICAgICAgICAgICAvLyBlcCBtYXJrZXIgPSBwcm9jZXNzZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGluay5lcCA9IHRydWU7XG4gICAgICAgIC8vIHByZXBvcHVsYXRlIHRoZSBsb2FkIHJlY29yZFxuICAgICAgICBjb25zdCBmZXRjaE9wdHMgPSBnZXRGZXRjaE9wdHMobGluayk7XG4gICAgICAgIGZldGNoKGxpbmsuaHJlZiwgZmV0Y2hPcHRzKTtcbiAgICB9XG59O19fVklURV9JU19NT0RFUk5fXyYmcCgpOyIsIjxzcGFuIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPjwvc3Bhbj5cbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiIGxhbmc9XCJ0c1wiPlxuXHRsZXQgY19zY3JlZW5zID0gMDtcbjwvc2NyaXB0PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBhcnJpdmFsLCB5d19ibHVyLCB5d19oZWxwLCB5d19uYXZfY29sbGFwc2VkLCB5d19uYXZfdmlzaWJsZSwgeXdfb3ZlcnNjcm9sbF9wY3QsIHl3X3Byb2dyZXNzIH0gZnJvbSAnIy9hcHAvbWVtJztcblxuXHRpbXBvcnQgdHlwZSB7IFBhZ2UgfSBmcm9tICcuLi9zY3JlZW4vX3NjcmVlbnMnO1xuXG5cdGltcG9ydCB7IHRpbWVvdXQgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cdGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgZ2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBuYXYgPSBmYWxzZTtcblx0Y29uc3QgYl9uYXYgPSBuYXY7XG5cblx0ZXhwb3J0IGxldCBkZWJ1ZyA9ICcnO1xuXHRleHBvcnQgbGV0IHByb2dyZXNzOiBudWxsIHwgW251bWJlciwgbnVtYmVyXSA9IG51bGw7XG5cdGV4cG9ydCBsZXQgZnVsbCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGtleWVkID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgY2xhc3NOYW1lcyA9ICcnO1xuXG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGV4cG9ydCBsZXQgbGVhdmVzID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgc3dpcGVzID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgcm9vdCA9IDAgPT09IGtfcGFnZS5pbmRleDtcblx0ZXhwb3J0IGxldCBzbGlkZXMgPSAhbGVhdmVzICYmICFzd2lwZXMgJiYgIXJvb3Q7XG5cdGNvbnN0IGJfc2xpZGVzID0gc2xpZGVzO1xuXG5cdGV4cG9ydCBsZXQgZm9ybSA9IGZhbHNlO1xuXHRjb25zdCBiX2Zvcm0gPSAhIWZvcm07XG5cblx0ZXhwb3J0IGxldCB0cmFuc3BhcmVudCA9IGZhbHNlO1xuXG5cdGxldCBkbV9zY3JlZW46IEhUTUxFbGVtZW50O1xuXG5cdC8vIEBtdnBcblx0bGV0IGRtX2hlbHA6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cblx0Y29uc3Qgc2lfZXhpdCA9IGxlYXZlcz8gJ2xlYXZlcyc6IHN3aXBlcz8gJ3N3aXBlcyc6ICcnO1xuXG5cdGNvbnN0IGRpc3BhdGNoRXZlbnQgPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0aWYoIWtfcGFnZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKGAke2RlYnVnIHx8ICd1bmtub3duJ30gU2NyZWVuIG1pc3NpbmcgcGFnZSBjb250ZXh0YCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gbGlzdGVuIGZvciBwYWdlIGV2ZW50c1xuXHRcdFx0a19wYWdlLm9uKHtcblx0XHRcdFx0Ly8gb24gcGFnZSBmb2N1c1xuXHRcdFx0XHRmb2N1cygpIHtcblx0XHRcdFx0XHQvLyBzZXQgbmF2IHZpc2liaWxpdHlcblx0XHRcdFx0XHQkeXdfbmF2X3Zpc2libGUgPSBiX25hdjtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIC8vIHNjcm9sbGluZ1xuXHRcdC8vIGRtX3NjcmVlbi5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChkZV93aGVlbCkgPT4ge1xuXHRcdC8vIFx0Ly8gb3ZlcnNjcm9sbFxuXHRcdC8vIFx0aWYoMCA9PT0gZG1fc2NyZWVuLnNjcm9sbFRvcCkge1xuXHRcdC8vIFx0XHRpZihkZV93aGVlbC5ET01fREVMVEFfUElYRUwgPT09IGRlX3doZWVsLmRlbHRhTW9kZSkge1xuXHRcdC8vIFx0XHRcdC8vIGNvbnN0IHhfZGVsdGFfeSA9IGRlX3doZWVsLmRlbHRhWTtcblx0XHQvLyBcdFx0XHQvLyBjb25zdCB4X3BjdCA9IE1hdGgubWluKE1hdGguYWJzKHhfZGVsdGFfeSksIDUwKSAvIDUwO1xuXHRcdC8vIFx0XHRcdC8vICR5d19vdmVyc2Nyb2xsX3BjdCA9IHhfcGN0O1xuXHRcdC8vIFx0XHRcdC8vIGNvbnNvbGUubG9nKCh4X3BjdCAqIDEwMCkudG9GaXhlZCgyKSk7XG5cblx0XHQvLyBcdFx0XHQvLyBjb25zb2xlLmxvZyh7XG5cdFx0Ly8gXHRcdFx0Ly8gXHRkZWx0YVk6IGRlX3doZWVsLmRlbHRhWSxcblx0XHQvLyBcdFx0XHQvLyBcdC8vIHdoZWVsRGVsdGFZOiBkZV93aGVlbC53aGVlbERlbHRhWSxcblx0XHQvLyBcdFx0XHQvLyBcdHNjcmVlblk6IGRlX3doZWVsLnNjcmVlblksXG5cdFx0Ly8gXHRcdFx0Ly8gXHRtb2RlOiBkZV93aGVlbC5kZWx0YU1vZGUsXG5cdFx0Ly8gXHRcdFx0Ly8gfSk7XG5cdFx0Ly8gXHRcdH1cblx0XHQvLyBcdH1cblx0XHQvLyB9KTtcblxuXHRcdC8vIGFycml2YWwoZG1fc2NyZWVuLCAoKSA9PiB7XG5cdFx0Ly8gXHRjb25zb2xlLmxvZygnYXJyaXZlZCB0byBzY3JlZW4nKTtcblx0XHQvLyBcdCR5d19uYXZfdmlzaWJsZSA9IG5hdjtcblx0XHQvLyBcdC8vICR5d19uYXZfY29sbGFwc2VkID0gIW5hdjtcblxuXHRcdC8vIFx0Ly8gaWYobmF2KSB7XG5cdFx0Ly8gXHQvLyBcdCR5d19uYXZfdmlzaWJsZSA9IHRydWU7XG5cdFx0Ly8gXHQvLyB9XG5cblx0XHQvLyBcdGlmKHByb2dyZXNzKSB7XG5cdFx0Ly8gXHRcdCR5d19wcm9ncmVzcyA9IHByb2dyZXNzO1xuXHRcdC8vIFx0fVxuXG5cdFx0Ly8gXHQkeXdfaGVscCA9IGRtX2hlbHBcblx0XHQvLyBcdFx0PyBBcnJheS5mcm9tKGRtX2hlbHAuY2xvbmVOb2RlKHRydWUpLmNoaWxkTm9kZXMpIGFzIEhUTUxFbGVtZW50W11cblx0XHQvLyBcdFx0OiBbXTtcblxuXHRcdC8vIFx0ZGlzcGF0Y2hFdmVudCgnYXJyaXZlJyk7XG5cdFx0Ly8gfSk7XG5cblx0XHQvLyBpZiBzY3JlZW4gaGFzIGtleWVkIHN2ZWx0ZSBjb21wb25lbnRzXG5cdFx0aWYoa2V5ZWQpIHtcblx0XHRcdGxldCB4X3Njcm9sbF90b3AgPSAwO1xuXG5cdFx0XHQvLyBzdmVsdGUgd2lsbCByZXBsYWNlIHRob3NlIGVsZW1lbnRzIHdoZW4gY2hhbmdpbmcgc2NyZWVuc1xuXHRcdFx0KG5ldyBNdXRhdGlvbk9ic2VydmVyKGFzeW5jKGFfbXV0YXRpb25zKSA9PiB7XG5cdFx0XHRcdC8vIGtleWVkIGNvbXBvbmVudCB3YXMgcmVtb3ZlZFxuXHRcdFx0XHRpZihhX211dGF0aW9uc1swXT8uYWRkZWROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0eF9zY3JvbGxfdG9wID0gZG1fc2NyZWVuLnNjcm9sbFRvcDtcblx0XHRcdFx0XHR9IGNhdGNoKGVfbnVsbCkge31cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBrZXllZCBjb21wb25lbnQgd2FzIHJlc3RvcmVkXG5cdFx0XHRcdGVsc2UgaWYoYV9tdXRhdGlvbnNbMF0/LnJlbW92ZWROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZihkbV9zY3JlZW4pIHtcblx0XHRcdFx0XHRcdGRtX3NjcmVlbi5zY3JvbGxUb3AgPSB4X3Njcm9sbF90b3A7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KSkub2JzZXJ2ZShkbV9zY3JlZW4sIHtcblx0XHRcdFx0Y2hpbGRMaXN0OiB0cnVlLFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblxuXHRleHBvcnQgbGV0IHN0eWxlID0gJyc7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0ZGl2LmJvdW5kcyB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRwYWRkaW5nLWxlZnQ6IGNhbGMoNTB2dyAtICh2YXIoLS1hcHAtbWF4LXdpZHRoKSAvIDIpKTtcblx0fVxuXG5cdC5zbGlkZXMge1xuXHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlWChjYWxjKHZhcigtLWFwcC13aW5kb3ctd2lkdGgpIC8gMikpO1xuXHRcdHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjZzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0fVxuXG5cdEBtZWRpYShwcmVmZXJzLXJlZHVjZWQtbW90aW9uKSB7XG5cdFx0LnNsaWRlcyB7XG5cdFx0XHR0cmFuc2l0aW9uOiBub25lIDBzIGxpbmVhcjtcblx0XHR9XG5cdH1cblxuXHRzZWN0aW9uLnNjcmVlbixmb3JtLnNjcmVlbiB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdG1heC13aWR0aDogdmFyKC0tYXBwLW1heC13aWR0aCk7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXG5cdFx0LmZvbnQocmVndWxhcik7XG5cblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cblx0XHRvcGFjaXR5OiAxO1xuXHRcdGZpbHRlcjogYmx1cigwKTtcblxuXHRcdC8vIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjZzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblxuXHRcdCYudHJhbnNwYXJlbnQge1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0fVxuXG5cdFx0Ji5wcm9ncmVzcyB7XG5cdFx0XHRwYWRkaW5nLXRvcDogMjJweDtcblx0XHR9XG5cblx0XHQmLm5hdiB7XG5cdFx0XHRwYWRkaW5nLWJvdHRvbTogNzFweDtcblx0XHR9XG5cblx0XHQmLmZsZXgge1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRhbGlnbi1pdGVtczogc3RyZXRjaDtcblx0XHRcdGdhcDogdmFyKC0tZ2FwLCB2YXIoLS11aS1wYWRkaW5nKSk7XG5cblx0XHRcdD46Zmlyc3QtY2hpbGQ6bm90KC5uby1tYXJnaW4pIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0bWFyZ2luLXRvcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Jj4qIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0ZmxleDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdDpnbG9iYWwoJjpub3QoLm5vLW1hcmdpbikpIHtcblx0XHRcdFx0XHRtYXJnaW46IDAgdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdCYuc2Nyb2xsIHtcblx0XHRcdG92ZXJmbG93LXk6IHNjcm9sbDtcblx0XHRcdG92ZXJzY3JvbGwtYmVoYXZpb3IteTogY29udGFpbjtcblx0XHRcdC5oaWRlLXNjcm9sbGJhcigpO1xuXHRcdH1cblxuXHRcdC8vICYuc2xpZGVzIHtcblx0XHQvLyBcdHRyYW5zZm9ybTogdHJhbnNsYXRlWChjYWxjKHZhcigtLWFwcC13aW5kb3ctd2lkdGgpIC8gMikpO1xuXHRcdC8vIFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuNnMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdC8vIH1cblxuXHRcdCYuc2xpZCB7XG5cdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC41cyB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cdFx0fVxuXG5cdFx0JltkYXRhLXMyLWV4aXRdOm5vdChbZGF0YS1zMi1leGl0PScnXSkge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC8vIGxlZnQ6IDA7XG5cdFx0XHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwcHgpO1xuXHRcdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC41cyB2YXIoLS1lYXNlLW91dC1xdWludCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0QGtleWZyYW1lcyBmYWRlLWF3YXkge1xuXHRcdFx0MCUge1xuXHRcdFx0XHRvcGFjaXR5OiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQ3NSUge1xuXHRcdFx0XHRvcGFjaXR5OiAwO1xuXHRcdFx0fVxuXG5cdFx0XHQxMDAlIHtcblx0XHRcdFx0b3BhY2l0eTogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRAa2V5ZnJhbWVzIGJsdXItYXdheSB7XG5cdFx0XHQwJSB7XG5cdFx0XHRcdGZpbHRlcjogYmx1cigwKTtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdGZpbHRlcjogYmx1cigxNHB4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRAa2V5ZnJhbWVzIHNjYWxlLXVwIHtcblx0XHRcdDAlIHtcblx0XHRcdFx0dHJhbnNmb3JtOiBzY2FsZSgxKTtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogc2NhbGUoMS43NSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQGtleWZyYW1lcyBzdWJsaW1hdGUge1xuXHRcdC8vIFx0MCUge1xuXHRcdC8vIFx0XHRvcGFjaXR5OiAxO1xuXHRcdC8vIFx0XHR0cmFuc2Zvcm06IHNjYWxlKDEpO1xuXHRcdC8vIFx0XHRmaWx0ZXI6IGJsdXIoMCk7XG5cdFx0Ly8gXHR9XG5cblx0XHQvLyBcdDI1JSB7XG5cdFx0Ly8gXHRcdGZpbHRlcjogYmx1cigxNHB4KTtcblx0XHQvLyBcdH1cblxuXHRcdC8vIFx0ODAlIHtcblx0XHQvLyBcdFx0b3BhY2l0eTogMDtcblx0XHQvLyBcdH1cblxuXHRcdC8vIFx0MTAwJSB7XG5cdFx0Ly8gXHRcdHRyYW5zZm9ybTogc2NhbGUoMS43NSlcblx0XHQvLyBcdH1cblx0XHQvLyB9XG5cblx0XHRAa2V5ZnJhbWVzIHR1cm4tYXdheSB7XG5cdFx0XHQwJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMHB4KSByb3RhdGVZKDBkZWcpO1xuXHRcdFx0fVxuXG5cdFx0XHQxJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMTUwMHB4KSByb3RhdGVZKDBkZWcpO1xuXHRcdFx0fVxuXG5cdFx0XHQxMDAlIHtcblx0XHRcdFx0dHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxNTAwcHgpIHJvdGF0ZVkoLTgwZGVnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRAa2V5ZnJhbWVzIGZhZGUtb3V0IHtcblx0XHRcdDAlIHtcblx0XHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdH1cblxuXHRcdFx0MTAlIHtcblx0XHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdH1cblxuXHRcdFx0ODAlIHtcblx0XHRcdFx0b3BhY2l0eTogMDtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ji5zdWJsaW1hdGUge1xuXHRcdFx0Ly8gYW5pbWF0aW9uOiBcblx0XHRcdC8vIFx0c2NhbGUtdXAgMTAwMG1zIHZhcigtLWVhc2Utb3V0LWN1YmljKSBmb3J3YXJkcyxcblx0XHRcdC8vIFx0ZmFkZS1hd2F5IDEwMDBtcyB2YXIoLS1lYXNlLW91dC1xdWFkKSBmb3J3YXJkcyxcblx0XHRcdC8vIFx0Ymx1ci1hd2F5IDIwMG1zIHZhcigtLWVhc2Utb3V0LXF1YWQpIGZvcndhcmRzO1xuXG5cdFx0XHQvLyAtLW1pbWljOiAxMDAwbXMgdmFyKC0tZWFzZS1vdXQtcXVpbnQpIGZvcndhcmRzO1xuXHRcdFx0Ly8gYW5pbWF0aW9uOiB0dXJuLWF3YXkgdmFyKC0tbWltaWMpLFxuXHRcdFx0Ly8gXHRmYWRlLW91dCB2YXIoLS1taW1pYyk7XG5cdFx0XHQvLyB0cmFuc2Zvcm0tb3JpZ2luOiAxMjAlO1xuXG5cdFx0XHR0cmFuc2l0aW9uOiBvcGFjaXR5IDQwMG1zIHZhcigtLWVhc2Utb3V0LXF1YWQpO1xuXHRcdFx0b3BhY2l0eTogMDtcblx0XHR9XG5cblx0XHQmLm1hdGVyaWFsaXplIHtcblxuXHRcdH1cblxuXHRcdD4qOm5vdCguaGVhZGVyKSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0dHJhbnNpdGlvbjogZmlsdGVyIDQwMG1zIHZhcigtLWVhc2Utb3V0LWN1YmljKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQmLmJsdXIge1xuXHRcdFx0Pio6bm90KC5oZWFkZXIpIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0ZmlsdGVyOiBibHVyKDJweCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblxuXG5cdFx0Lypcblx0XHRcdENvcGllZCBmcm9tIHNjcmVlbi5sZXNzXG5cdFx0Ki9cblx0XHQqIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRcdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnRleHQ6bm90KGJ1dHRvbiAudGV4dCk6bm90KC5yb3cgLnRleHQpIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR1c2VyLXNlbGVjdDogdGV4dDtcblx0XHRcdFx0Y3Vyc29yOiBkZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlucHV0LHRleHRhcmVhIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR1c2VyLXNlbGVjdDogaW5pdGlhbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQudmFsaWRhdGlvbi1tZXNzYWdlIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pO1xuXHRcdFx0XHR0ZXh0LWFsaWduOiByaWdodDtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cblx0XHRcdFx0cGFkZGluZy10b3A6IDNweDtcblx0XHRcdFx0bWFyZ2luLWxlZnQ6IC05cHg7XG5cdFx0XHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQudXNlci1zZWxlY3RfYWxsIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR1c2VyLXNlbGVjdDogYWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5hY3Rpb25zLXdhbGwsIC5hY3Rpb25zLWxpbmUge1xuXHRcdFx0YnV0dG9uIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0bWluLWhlaWdodDogdmFyKC0tdWktcm93LWhlaWdodCk7XG5cdFx0XHRcdFx0bWF4LWhlaWdodDogdmFyKC0tdWktcm93LWhlaWdodCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cblx0XHRcdFx0XHRib3JkZXItcmFkaXVzOiB2YXIoLS11aS1ib3JkZXItcmFkaXVzKTtcblxuXHRcdFx0XHRcdHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMXMgdmFyKC0tZWFzZS1vdXQtZXhwbyksXG5cdFx0XHRcdFx0XHRjb2xvciAycyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQmLnByaW1hcnkge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtZGFyayk7XG5cdFx0XHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmOmRpc2FibGVkLCZbcmVhZG9ubHk9XCJ0cnVlXCJdIHtcblx0XHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0XHRcdFx0XHRjdXJzb3I6IG5vdC1hbGxvd2VkO1xuXHRcdFx0XHRcdFx0XHRvcGFjaXR5OiAwLjQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YnV0dG9uIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdH1cblxuXHRcdFx0Ji5waWxsIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0LmZvbnQocmVndWxhciwgQHNpemU6IDExcHgsIEB3ZWlnaHQ6IDUwMCk7XG5cdFx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0XHRcdHBhZGRpbmc6IDAuNGVtIDFlbTtcblx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0Ym9yZGVyLXJhZGl1czogNDAwZW07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRoMyB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0Zm9udC13ZWlnaHQ6IDUwMDtcblx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5hY3Rpb24td2FsbCB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XG5cdFx0XHRcdGdhcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHR9XG5cblx0XHRcdCY+YnV0dG9uIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0ZmxleDogMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHAge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC5mb250KHJlZ3VsYXIsIEB3ZWlnaHQ6IDMwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmZvcm0tZW50cnkoKSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRcdGhlaWdodDogdmFyKC0tdWktcm93LWhlaWdodCk7XG5cdFx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRcdHBhZGRpbmctbGVmdDogdmFyKC0tdWktcGFkZGluZyk7XG5cblx0XHRcdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0tdWktYm9yZGVyLXJhZGl1cyk7XG5cdFx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cblx0XHRcdFx0Zm9udC13ZWlnaHQ6IDMwMDtcblx0XHRcdH1cblxuXHRcdFx0Jjo6cGxhY2Vob2xkZXIge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRmb250LXdlaWdodDogMzAwO1xuXHRcdFx0XHRcdC8vIGNvbG9yOiByZ2IoMTE3LDExNywxMTcpO1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdFx0b3BhY2l0eTogMC43O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCY6Zm9jdXMge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpbnB1dCB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0Zm9udC1zaXplOiBpbmhlcml0O1xuXHRcdFx0fVxuXG5cdFx0XHQmW3R5cGU9XCJ0ZXh0XCJdLCZbdHlwZT1cInBhc3N3b3JkXCJdLCZbdHlwZT1cIm51bWJlclwiXSB7XG5cdFx0XHRcdC5mb3JtLWVudHJ5KCk7XG5cdFx0XHR9XG5cblx0XHRcdCYuaW52YWxpZDpub3QoOmZvY3VzKSB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pICFpbXBvcnRhbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ji5hZGRyZXNzIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0LmZvbnQobW9uby10aW55KTtcblx0XHRcdFx0XHRsZXR0ZXItc3BhY2luZzogMC4yNXB4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnNlbGVjdENvbnRhaW5lci5pbnZhbGlkIHtcblx0XHRcdGlucHV0IHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItY2F1dGlvbikgIWltcG9ydGFudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRleHRhcmVhIHtcblx0XHRcdC5mb3JtLWVudHJ5KCk7XG5cblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udChyZWd1bGFyKTtcblxuXHRcdFx0XHRwYWRkaW5nOiAxZXggMmV4O1xuXHRcdFx0XHRoZWlnaHQ6IDEwLjc1ZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHQuZmxleC1yb3dzIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRhbGlnbi1pdGVtczogc3RyZXRjaDtcblx0XHRcdFx0Z2FwOiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdH1cblxuXHRcdFx0Jj4qIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0ZmxleDogMDtcblx0XHRcdFx0XHRtYXJnaW4tdG9wOiAwO1xuXHRcdFx0XHRcdG1hcmdpbi1ib3R0b206IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQuZm9udC12YXJpYW50X21vbm8ge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC5mb250KG1vbm8pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5mb250LXZhcmlhbnRfbW9uby10aW55IHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udChtb25vLXRpbnkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5jb2xvci1pY29uLXNlbmQge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci1vcmFuZ2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5jb2xvci1pY29uLXJlY3Yge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci1zbGltZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Lmxpbmsge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0fVxuXG5cdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQuc3ZlbHRlLXRhYnMge1xuXHRcdFx0PnVsLnN2ZWx0ZS10YWJzX190YWItbGlzdCB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xuXG5cdFx0XHRcdFx0bWFyZ2luLWxlZnQ6IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHRcdFx0XHRcdG1hcmdpbi1yaWdodDogY2FsYygwcHggLSB2YXIoLS11aS1wYWRkaW5nKSk7XG5cdFx0XHRcdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+bGkuc3ZlbHRlLXRhYnNfX3RhYiB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRmbGV4OiAxO1xuXHRcdFx0XHRcdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXG5cdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItZ3JheW1lZCk7XG5cdFx0XHRcdFx0XHRib3JkZXItYm90dG9tOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiAxMnB4IDAuNzVlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmLnN2ZWx0ZS10YWJzX19zZWxlY3RlZCB7XG5cdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdFx0XHRib3JkZXItYm90dG9tOiAycHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdD5kaXYuc3ZlbHRlLXRhYnNfX3RhYi1wYW5lbCB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1hcmdpbi10b3A6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbjwvc3R5bGU+XG48IS0tIGNsYXNzOnNsaWRlcz17c2xpZGVzfSAtLT5cblxuPGRpdiBjbGFzcz1cImJvdW5kc1wiXG5cdGNsYXNzOnNsaWRlcz17Yl9zbGlkZXN9XG4+XG5cdDxmb3JtXG5cdFx0Y2xhc3M9XCJzY3JlZW4ge2NsYXNzTmFtZXN9XCJcblx0XHRjbGFzczpmbGV4PXt0cnVlfVxuXHRcdGNsYXNzOnNjcm9sbD17dHJ1ZX1cblx0XHRjbGFzczpuYXY9e2JfbmF2fVxuXHRcdGNsYXNzOnByb2dyZXNzPXtwcm9ncmVzc31cblx0XHRjbGFzczp0cmFuc3BhcmVudD17dHJhbnNwYXJlbnR9XG5cdFx0Y2xhc3M6c3VibGltYXRlPXtmYWxzZX1cblx0XHRjbGFzczpibHVyPXskeXdfYmx1cn1cblx0XHRkYXRhLXMyLWV4aXQ9e3NpX2V4aXR9XG5cdFx0YmluZDp0aGlzPXtkbV9zY3JlZW59XG5cdFx0b246c3VibWl0PXtkX2V2ZW50ID0+IHZvaWQgZF9ldmVudC5wcmV2ZW50RGVmYXVsdCgpfVxuXHRcdG9uOnN1Ym1pdFxuXHRcdHN0eWxlPVwie3N0eWxlfVwiXG5cdFx0YXV0b2NvbXBsZXRlPVwib2ZmXCJcblx0PlxuXHRcdDxzbG90Pjwvc2xvdD5cblxuXHRcdHsjaWYgJ2hlbHAnIGluICQkc2xvdHN9XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiZGlzcGxheV9ub25lXCIgYmluZDp0aGlzPXtkbV9oZWxwfT5cblx0XHRcdFx0PHNsb3QgbmFtZT1cImhlbHBcIiAvPlxuXHRcdFx0PC9kaXY+XG5cdFx0ey9pZn1cblx0PC9mb3JtPlxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBGX05PT1AgfSBmcm9tIFwiIy91dGlsL2JlbHRcIjtcblxuXHQvKipcblx0ICogdGFyZ2V0IGRpbWVuc2lub3Ncblx0ICovXG5cdGV4cG9ydCBsZXQgZGltOiAzMiB8IDQ4IHwgNjQgfCA5NiB8IDEyODtcblx0Y29uc3QgeF9kaW0gPSBkaW07XG5cblx0LyoqXG5cdCAqIGFsdGVybmF0aXZlIHRleHRcblx0ICovXG5cdGV4cG9ydCBsZXQgYWx0ID0gJ1N0YXJTaGVsbCBsb2dvJztcblx0Y29uc3Qgc19hbHQgPSBhbHQ7XG5cblx0Y29uc3QgZl9zcmMgPSAoeDogbnVtYmVyKSA9PiBgL21lZGlhL3ZlbmRvci9sb2dvLSR7eH1weC5wbmdgO1xuXG5cdGNvbnN0IHNyX2RlZmF1bHQgPSBmX3NyYyh4X2RpbSk7XG5cdGNvbnN0IHNyX2RvdWJsZSA9IGZfc3JjKHhfZGltICogMik7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5sb2dvIHtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRib3JkZXI6IDA7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cblx0XHRtYXJnaW4tbGVmdDogYXV0bztcblx0XHRtYXJnaW4tcmlnaHQ6IGF1dG87XG5cblx0XHRpbWcge1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48cGljdHVyZSBjbGFzcz1cIm5vLW1hcmdpbiBsb2dvXCIgc3R5bGU9XCJ3aWR0aDp7eF9kaW19cHg7IGhlaWdodDp7eF9kaW19cHg7XCIgb246Y2xpY2s+XG5cdDxzb3VyY2Ugc3Jjc2V0PVwie3NyX2RvdWJsZX1cIiBtZWRpYT1cIihtaW4tcmVzb2x1dGlvbjogMmRwcHgpXCI+XG5cdDxpbWcgYWx0PXtzX2FsdH0gc3JjPVwie3NyX2RlZmF1bHR9XCIgLz5cbjwvcGljdHVyZT5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7eXdfYmx1cn0gZnJvbSAnIyMvbWVtJztcblx0aW1wb3J0IFNYX0lDT05fQUREX1NNQUxMIGZyb20gJyMvaWNvbi9hZGQtc21hbGwuc3ZnP3Jhdyc7XG5cdFxuXHRleHBvcnQgbGV0IHRpdGxlOiBzdHJpbmc7XG5cdGV4cG9ydCBsZXQgb3BlbiA9IHRydWU7XG5cblx0JDogJHl3X2JsdXIgPSBvcGVuO1xuXG5cdGxldCBiX3Nob3dpbmcgPSBmYWxzZTtcblx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0Yl9zaG93aW5nID0gdHJ1ZTtcblx0fSwgMTApO1xuXG5cdGZ1bmN0aW9uIHBhdXNlKGRtOiBIVE1MRWxlbWVudCwgZ2M6IGFueSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkdXJhdGlvbjogMjAwLFxuXHRcdH07XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQuY2FuY2VsIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdHotaW5kZXg6IDUwMDA7XG5cblx0XHQmLnNob3dpbmcge1xuXHRcdFx0Pi5vdmVybGF5IHtcblx0XHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdFx0Ly8gaGVpZ2h0OiBhdXRvO1xuXHRcdFx0XHRoZWlnaHQ6IDMyMHB4O1xuXG5cdFx0XHRcdG1heC1oZWlnaHQ6IDMyMHB4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5vdmVybGF5IHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogNGVtO1xuXHRcdFx0cmlnaHQ6IDIwcHg7XG5cdFx0XHR6LWluZGV4OiAxMDAwO1xuXHRcdFx0d2lkdGg6IDMwMHB4O1xuXHRcdFx0cGFkZGluZy1sZWZ0OiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdHBhZGRpbmctcmlnaHQ6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0cGFkZGluZy1ib3R0b206IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOTUpO1xuXHRcdFx0Ym9yZGVyLXJhZGl1czogOHB4O1xuXHRcdFx0bWF4LWhlaWdodDogMzIwcHg7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdG92ZXJzY3JvbGwtYmVoYXZpb3I6IGNvbnRhaW47XG5cdFx0XHRvdmVyZmxvdzogc2Nyb2xsO1xuXHRcdFx0LmhpZGUtc2Nyb2xsYmFyKCk7XG5cblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRvcGFjaXR5OiAwLjI1O1xuXHRcdFx0dHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcyBsaW5lYXIsIGhlaWdodCAyNTBtcyB2YXIoLS1lYXNlLW91dC1leHBvKTtcblx0XHRcdGhlaWdodDogMDtcblxuXHRcdFx0Pi50b3Age1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cblx0XHRcdFx0PmgzIHtcblx0XHRcdFx0XHRtYXJnaW46IDE2cHggMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4uYWRkLW5ldyB7XG5cdFx0XHRcdFx0Pi5pY29uIHtcblx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogOHB4O1xuXHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Pi5yb3dzIHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0LS1yb3ctcGFkZGluZzogMTJweDtcblxuXG5cdFx0XHRcdC5vdmVybGF5LXNlbGVjdC5pY29uIHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjBweDtcblx0XHRcdFx0XHRcdGFsaWduLXNlbGY6IGNlbnRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LnJvdyB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLXRvcDogdmFyKC0tcm93LXBhZGRpbmcpICFpbXBvcnRhbnQ7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLWxlZnQ6IDAgIWltcG9ydGFudDtcblx0XHRcdFx0XHRcdHBhZGRpbmctcmlnaHQ6IHZhcigtLXJvdy1wYWRkaW5nKSAhaW1wb3J0YW50O1xuXHRcdFx0XHRcdFx0cGFkZGluZy1ib3R0b206IHZhcigtLXJvdy1wYWRkaW5nKSAhaW1wb3J0YW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImNhbmNlbFwiXG5cdGNsYXNzOnNob3dpbmc9e2Jfc2hvd2luZ31cblx0b246Y2xpY2s9eygpID0+IHtcblx0XHRiX3Nob3dpbmcgPSBmYWxzZTtcblx0XHRvcGVuID0gZmFsc2U7XG5cdH19XG4+XG5cdDxkaXYgY2xhc3M9XCJvdmVybGF5IHNlbGVjdFwiIG91dDpwYXVzZT5cblx0XHQ8ZGl2IGNsYXNzPVwidG9wXCI+XG5cdFx0XHQ8aDM+XG5cdFx0XHRcdHt0aXRsZX1cblx0XHRcdDwvaDM+XG48IS0tIFxuXHRcdFx0PGJ1dHRvbiBjbGFzcz1cInBpbGwgYWRkLW5ld1wiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9BRERfU01BTEx9XG5cdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0XHRBZGQgTmV3XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvYnV0dG9uPiAtLT5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJyb3dzXCI+XG5cdFx0XHQ8c2xvdCBuYW1lPVwicm93c1wiPjwvc2xvdD5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLWFycm93LWxlZnQtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0PC9zdHlsZT5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLWFycm93LWxlZnQtZmdcXFwiIGQ9XFxcIk0yMCwxMVYxM0g4TDEzLjUsMTguNUwxMi4wOCwxOS45Mkw0LjE2LDEyTDEyLjA4LDQuMDhMMTMuNSw1LjVMOCwxMUgyMFpcXFwiLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItc2VhcmNoLWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1zZWFyY2gtZmdcXFwiIGQ9XFxcIk0xNS41IDE0aC0uNzlsLS4yOC0uMjdBNi40NzEgNi40NzEgMCAwIDAgMTYgOS41IDYuNSA2LjUgMCAxIDAgOS41IDE2YzEuNjEgMCAzLjA5LS41OSA0LjIzLTEuNTdsLjI3LjI4di43OWw1IDQuOTlMMjAuNDkgMTlsLTQuOTktNXptLTYgMEM3LjAxIDE0IDUgMTEuOTkgNSA5LjVTNy4wMSA1IDkuNSA1IDE0IDcuMDEgMTQgOS41IDExLjk5IDE0IDkuNSAxNHpcXFwiLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItY2hlY2tlZC1jaXJjbGUtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0XFx0LnMyci1jaGVja2VkLWNpcmNsZS1iZyB7XFxuXFx0XFx0XFx0ZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWJnLCBibGFjayk7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PGNpcmNsZSBjbGFzcz1cXFwiczJyLWNoZWNrZWQtY2lyY2xlLWJnXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOFxcXCIgLz5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLWNoZWNrZWQtY2lyY2xlLWZnXFxcIiBkPVxcXCJNMTAuMDAwMyAxLjY2NjVDNS40MDAzMyAxLjY2NjUgMS42NjY5OSA1LjM5OTg0IDEuNjY2OTkgOS45OTk4NEMxLjY2Njk5IDE0LjU5OTggNS40MDAzMyAxOC4zMzMyIDEwLjAwMDMgMTguMzMzMkMxNC42MDAzIDE4LjMzMzIgMTguMzMzNyAxNC41OTk4IDE4LjMzMzcgOS45OTk4NEMxOC4zMzM3IDUuMzk5ODQgMTQuNjAwMyAxLjY2NjUgMTAuMDAwMyAxLjY2NjVaTTguMzMzNjYgMTQuMTY2NUw0LjE2Njk5IDkuOTk5ODRMNS4zNDE5OSA4LjgyNDg0TDguMzMzNjYgMTEuODA4MkwxNC42NTg3IDUuNDgzMTdMMTUuODMzNyA2LjY2NjVMOC4zMzM2NiAxNC4xNjY1WlxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IFN0YXJTaGVsbExvZ28gZnJvbSAnLi9TdGFyU2hlbGxMb2dvLnN2ZWx0ZSc7XG5cdGltcG9ydCBPdmVybGF5U2VsZWN0IGZyb20gJy4vT3ZlcmxheVNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgUGZwRGlzcGxheSBmcm9tICcuL1BmcERpc3BsYXkuc3ZlbHRlJztcblx0aW1wb3J0IENsb3NlIGZyb20gJy4vQ2xvc2Uuc3ZlbHRlJztcblx0aW1wb3J0IFJvdyBmcm9tICcuL1Jvdy5zdmVsdGUnO1xuXG5cdGltcG9ydCBTWF9JQ09OX0FSUk9XX0xFRlQgZnJvbSAnIy9pY29uL2Fycm93LWxlZnQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX1NFQVJDSCBmcm9tICcjL2ljb24vc2VhcmNoLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfQ0hFQ0tFRCBmcm9tICcjL2ljb24vY2hlY2tlZC1jaXJjbGUuc3ZnP3Jhdyc7XG5cdFxuXHRpbXBvcnQge1xuXHRcdHl3X2FjY291bnQsXG5cdFx0eXdfYWNjb3VudF9yZWYsXG5cdFx0eXdfY2FuY2VsX3NlYXJjaCxcblx0XHR5d19jaGFpbixcblx0XHR5d19jaGFpbl9yZWYsXG5cdFx0eXdfbWVudV92ZW5kb3IsXG5cdFx0eXdfb3ZlcmxheV9hY2NvdW50LFxuXHRcdHl3X292ZXJsYXlfbmV0d29yayxcblx0XHR5d19zZWFyY2gsXG5cdFx0eXdfdGhyZWFkLFxuXHR9IGZyb20gJy4uL21lbSc7XG5cblx0aW1wb3J0IHR5cGUge1xuXHRcdFBhZ2UsXG5cdH0gZnJvbSAnIyMvc2NyZWVuL19zY3JlZW5zJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQgeyBxcyB9IGZyb20gJyMvdXRpbC9kb20nO1xuXHRcblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgaW5jbHVkZXMgYSBiYWNrIGJ1dHRvbiB0byBwb3AgdGhpcyBwYWdlIGZyb20gdGhlIHN0YWNrXG5cdCAqL1xuXHRleHBvcnQgbGV0IHBvcHMgPSBmYWxzZTtcblx0Y29uc3QgYl9wb3BzID0gcG9wcztcblxuXHQvKipcblx0ICogSWYgYHRydWVgLCBpbmNsdWRlcyBhbiBleGl0IGJ1dHRvbiB0byByZXNldCB0aGUgc3RhY2tcblx0ICovXG5cdGV4cG9ydCBsZXQgZXhpdHMgPSBmYWxzZTtcblx0Y29uc3QgYl9leGl0cyA9IGV4aXRzO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIGRvZXMgbm90IGRpc3BsYXkgdGhlIGxvZ28gaW4gY2FzZXMgd2hlcmUgdGhlIGxvZ28gd291bGQgZGlzcGxheVxuXHQgKi9cblx0ZXhwb3J0IGxldCBwbGFpbiA9IGZhbHNlO1xuXHRjb25zdCBiX3BsYWluID0gcGxhaW47XG5cblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgYWxsb3dzIHRoZSBhY2NvdW50IHRvIGJlIHN3aXRjaGVkXG5cdCAqL1xuXHRleHBvcnQgbGV0IGFjY291bnQgPSBmYWxzZTtcblx0Y29uc3QgYl9hY2NvdW50ID0gYWNjb3VudDtcblxuXHQvKipcblx0ICogSWYgYHRydWVgLCBhbGxvd3MgdGhlIG5ldHdvcmsgdG8gYmUgc3dpdGNoZWRcblx0ICovXG5cdGV4cG9ydCBsZXQgbmV0d29yayA9IGZhbHNlO1xuXHRjb25zdCBiX25ldHdvcmsgPSBuZXR3b3JrO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIGluY2x1ZGVzIGEgc2VhcmNoIGlucHV0IGJveFxuXHQgKi9cblx0ZXhwb3J0IGxldCBzZWFyY2ggPSBmYWxzZTtcblx0Y29uc3QgYl9zZWFyY2ggPSBzZWFyY2g7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmltYXJ5IHRpdGxlIHRvIGRpc3BsYXlcblx0ICovXG5cdGV4cG9ydCBsZXQgdGl0bGUgPSAnJztcblx0Y29uc3Qgc190aXRsZSA9IHRpdGxlO1xuXG5cdC8qKlxuXHQgKiBBIHNob3J0IHN0cmluZyB0byBkaXNwbGF5IGltbWVkaWF0ZWx5IGZvbGxvd2luZyB0aGUgdGl0bGVcblx0ICovXG5cdGV4cG9ydCBsZXQgc3ltYm9sID0gJyc7XG5cdGNvbnN0IHNfc3ltYm9sID0gc3ltYm9sO1xuXG5cdC8qKlxuXHQgKiBUaGUgc3Vic3RpdGxlIHRvIGRpc3BsYXkgdW5kZXIgdGhlIHByaW1hcnkgdGl0bGVcblx0ICovXG5cdGV4cG9ydCBsZXQgc3VidGl0bGUgPSAnJztcblx0Y29uc3Qgc19zdWJ0aXRsZSA9IHN1YnRpdGxlO1xuXG5cdC8vIGV2ZW50IGRpc3BhdGNoZXIgZm9yIHBhcmVudCBjb21wb25lbnRcblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuXHQvLyBkaW1lbnNpb24gb2YgdGhlIGFjY291bnQgYW5kIG5ldHdvcmsgaWNvbnNcblx0Y29uc3Qgb3ZlcmxheV9wZnBfcHJvcHMgPSAoYl9taXJyb3I9ZmFsc2UpID0+ICh7XG5cdFx0ZGltOiAyMSxcblx0XHRiZzogJ3NhdGluJyxcblx0XHRnZW5TdHlsZTogJ2ZvbnQtc2l6ZToyMXB4OyBvdXRsaW5lOm5vbmU7Jyxcblx0XHRyb290U3R5bGU6IGBcblx0XHRcdHBhZGRpbmc6IDVweCA2cHg7XG5cdFx0XHRib3JkZXI6IDJweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0Ym9yZGVyLXJhZGl1czogJHtiX21pcnJvcj8gJzAgNHB4IDRweCAwJzogJzRweCAwIDAgNHB4J307XG5cdFx0YC5yZXBsYWNlKC9cXHMrL2csICcgJyksXG5cdH0pIGFzIGNvbnN0O1xuXG5cdC8vIGdldCBwYWdlIGZyb20gY29udGV4dFxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0Ly8gJDogcF9hY2NvdW50X2ljb24gPSBiX2FjY291bnQ/ICR5d19hY2NvdW50Py5kZWY/Lmljb25SZWY6IG51bGw7XG5cblxuXHRsZXQgZG1faGVhZGVyOiBIVE1MRWxlbWVudDtcblxuXHRsZXQgZG1fc2VhcmNoOiBIVE1MRWxlbWVudDtcblxuXHQvLyBpbXBvcnQgU1hfU0VBUkNIIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL2ZpbGxlZC9zZWFyY2guc3ZnP3Jhdyc7XG5cblx0Ly8gaW1wb3J0IFNYX0xPR08gZnJvbSAnIy9hc3NldC92ZW5kb3IvbG9nby5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0RST1BfRE9XTiBmcm9tICcjL2Fzc2V0L25hdi9kcm9wLWRvd24uc3ZnP3Jhdyc7XG5cblx0Ly8gaW1wb3J0IFNYX0NIRUNLRUQgZnJvbSAnIy9hc3NldC9uYXYvY2hlY2tlZC1jaXJjbGUuc3ZnP3Jhdyc7XG5cblx0Ly8gaW1wb3J0IFB1dCBmcm9tICcuL1B1dC5zdmVsdGUnO1xuXHQvLyBpbXBvcnQgeyBmb3JtYXRfZmlhdCwgSF9BQ0NPVU5UUywgSF9DSEFJTlMsIEhfSE9MRElOR1MsIEhfSUNPTlMsIEhfVE9LRU5TLCBIX1ZFUlNVU19VU0QgfSBmcm9tICcjL3NpbS9kYXRhJztcblx0Ly8gaW1wb3J0IHsgbWljcm90YXNrLCBvZGUsIHRpbWVvdXQgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cdC8vIGltcG9ydCB7IHFzIH0gZnJvbSAnIy91dGlsL2RvbSc7XG5cdC8vIGltcG9ydCBDbG9zZSBmcm9tICcuL0Nsb3NlLnN2ZWx0ZSc7XG5cdC8vIGltcG9ydCBPdmVybGF5U2VsZWN0IGZyb20gJy4vT3ZlcmxheVNlbGVjdC5zdmVsdGUnO1xuXHQvLyBpbXBvcnQgUm93IGZyb20gJy4vUm93LnN2ZWx0ZSc7XG5cblx0Ly8gaW1wb3J0IHtcblx0Ly8gXHRBY2NvdW50LFxuXHQvLyBcdEljb24sXG5cdC8vIFx0SG9sZGluZyxcblx0Ly8gfSBmcm9tICcjL29iamVjdHMnO1xuXHQvLyBpbXBvcnQgUGZwIGZyb20gJy4vUGZwLnN2ZWx0ZSc7XG5cblxuXG5cdGV4cG9ydCBsZXQgaXNTZWFyY2hTY3JlZW4gPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBzZWFyY2hfaW5wdXQgPSAnJztcblxuXHRsZXQgc19zZWFyY2ggPSAkeXdfc2VhcmNoO1xuXG5cblx0Ly8gb25Nb3VudCgoKSA9PiB7XG5cdC8vIFx0aWYoJHl3X3NlYXJjaCkge1xuXHQvLyBcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdC8vIFx0XHRcdGNvbnNvbGUubG9nKCdzdGVhbGluZyBmb2N1cyBmb3IgZW50cnkgc2VhcmNoJyk7XG5cdC8vIFx0XHRcdGRtX3NlYXJjaC5mb2N1cygpO1xuXHQvLyBcdFx0fSwgMCk7XG5cdC8vIFx0fVxuXHQvLyB9KTtcblxuXHR5d19zZWFyY2guc3Vic2NyaWJlKChzX3ZhbHVlKSA9PiB7XG5cdFx0aWYoaXNTZWFyY2hTY3JlZW4gJiYgc192YWx1ZSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ3NlYXJjaCBzY3JlZW4gYW5kIHNlYXJjaCB0ZXh0Jyk7XG5cdFx0XHRzX3NlYXJjaCA9IHNfdmFsdWU7XG5cdFx0XHRpZihkbV9zZWFyY2gpIHtcblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0ZG1fc2VhcmNoLmZvY3VzKCk7XG5cdFx0XHRcdH0sIDApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmKCFzX3ZhbHVlKSB7XG5cdFx0XHRzX3NlYXJjaCA9ICcnO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gdXBkYXRlX3NlYXJjaChkX2V2ZW50OiBFdmVudCkge1xuXHRcdC8vIGN1cnJlbnRseSBpbiBzZWFyY2ggdGhyZWFkXG5cdFx0aWYoaXNTZWFyY2hTY3JlZW4pIHtcblx0XHRcdC8vIHNlYXJjaCBpcyBiZWluZyBjYW5jZWxsZWRcblx0XHRcdGlmKCFzX3NlYXJjaCkge1xuXHRcdFx0XHQkeXdfc2VhcmNoID0gJyc7XG5cdFx0XHRcdCR5d19jYW5jZWxfc2VhcmNoKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZGlzcGF0Y2goJ3NlYXJjaCcsIHNfc2VhcmNoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gbm90IHNlYXJjaCBzY3JlZW4sIGJ1dCB1c2VyIHR5cGVkIHNvbWV0aGluZ1xuXHRcdGVsc2UgaWYoc19zZWFyY2gpIHtcblx0XHRcdGNvbnN0IHNpX2NhY2hlID0gJHl3X3RocmVhZC5pZDtcblxuXHRcdFx0Y29uc3QgZG1fZm9jdXMgPSBxcyhkbV9oZWFkZXIsICc6Zm9jdXMnKSBhcyBIVE1MRWxlbWVudDtcblx0XHRcdGlmKGRtX2ZvY3VzKSB7XG5cdFx0XHRcdGRtX2ZvY3VzLmJsdXIoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZG1faGVhZGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuXHRcdFx0Ly8gY29uc3QgZG1fY2xvbmUgPSAkeXdfc2NyZWVuX2RvbS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG5cdFx0XHQvLyAkeXdfZXhpdHRpbmdfZG9tLmFwcGVuZChkbV9jbG9uZSlcblxuXHRcdFx0Ly8gJHl3X2hlYWRlcl9wcm9wcyA9IHtcblx0XHRcdC8vIFx0cG9wcyxcblx0XHRcdC8vIFx0YWNjb3VudCxcblx0XHRcdC8vIFx0bmV0d29yayxcblx0XHRcdC8vIFx0c2VhcmNoLFxuXHRcdFx0Ly8gXHRuYW1lLFxuXHRcdFx0Ly8gXHRzeW1ib2wsXG5cdFx0XHQvLyBcdHN1Ym5hbWUsXG5cdFx0XHQvLyBcdHNlYXJjaF9pbnB1dDogJHl3X3NlYXJjaCxcblx0XHRcdC8vIH07XG5cblx0XHRcdCR5d19jYW5jZWxfc2VhcmNoID0gKCkgPT4ge1xuXHRcdFx0XHQvLyBkbV9oZWFkZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcblx0XHRcdFx0Ly8gJHl3X3NlYXJjaCA9ICcnO1xuXG5cdFx0XHRcdC8vICR5d190aHJlYWRfaWQgPSBzaV9jYWNoZTtcblxuXHRcdFx0XHRzX3NlYXJjaCA9ICcnO1xuXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdzdGVhbGluZyBmb2N1cyBmb3IgY2FuY2VsIHNlYXJjaCcpO1xuXHRcdFx0XHRkbV9zZWFyY2guZm9jdXMoKTtcblx0XHRcdH07XG5cblxuXHRcdFx0Ly8gc2F2ZSBzZWFyY2ggc3RyaW5nXG5cdFx0XHQkeXdfc2VhcmNoID0gc19zZWFyY2g7XG5cblx0XHRcdC8vIC8vIHNldCB0aHJlYWRcblx0XHRcdC8vICR5d190aHJlYWRfaWQgPSBUaHJlYWRJZC5TRUFSQ0g7XG5cdFx0fVxuXHR9XG5cblx0Ly8gYXN5bmMgZnVuY3Rpb24gc2VhcmNoX2lucHV0KCkge1xuXHQvLyBcdGF3YWl0IHRpY2soKTtcblx0Ly8gXHRkZWJ1Z2dlcjtcblx0Ly8gXHRpZihzX3NlYXJjaF9pbnB1dCkge1xuXHQvLyBcdFx0aWYoVGhyZWFkSWQuU0VBUkNIICE9PSAkeXdfdGhyZWFkX2lkKSB7XG5cdC8vIFx0XHRcdGRtX2hlYWRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdC8vIFx0XHRcdC8vIGNvbnN0IGRtX2Nsb25lID0gZG1faGVhZGVyLmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdFx0XG5cdC8vIFx0XHRcdCR5d190aHJlYWRfaWQgPSBUaHJlYWRJZC5TRUFSQ0g7XG5cdC8vIFx0XHR9XG5cdC8vIFx0fSBcblx0Ly8gfVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5oZWFkZXIge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRnYXA6IDE2cHg7XG5cblx0XHQmLmJsdXIge1xuXHRcdFx0Pio6bm90KC50b3ApIHtcblx0XHRcdFx0ZmlsdGVyOiBibHVyKDJweCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pio6bm90KC50b3ApIHtcblx0XHRcdHRyYW5zaXRpb246IGJsdXIgNDAwbXMgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdH1cblx0fVxuXG5cdC50b3Age1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cblx0XHQ+LmJhY2sge1xuXHRcdFx0ZmxleDogMTtcblx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdG1heC13aWR0aDogMjRweDtcblx0XHRcdG1hcmdpbi1yaWdodDogMjBweDtcblx0XHR9XG5cblx0XHQ+LmxvZ28uaWNvbiB7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDMycHg7XG5cdFx0XHR0cmFuc2Zvcm06IHNjYWxlKDEuNDI1KTtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHR9XG5cblx0XHQ+Lm1haW4ge1xuXHRcdFx0ZmxleDogMztcblx0XHRcdC8vIG1heC13aWR0aDogZml0LWNvbnRlbnQ7XG5cdFx0XHRjdXJzb3I6IGRlZmF1bHQ7XG5cdFx0XHRtYXJnaW4tcmlnaHQ6IDFlbTtcblx0XHRcdG1pbi13aWR0aDogMjUlO1xuXG5cdFx0XHQ+LnRpdGxlIHtcblx0XHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRcdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdFx0XHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cblx0XHRcdFx0Pi5uYW1lIHtcblx0XHRcdFx0XHRmb250LXdlaWdodDogNTAwO1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4uc3ltYm9sIHtcblx0XHRcdFx0XHRmb250LXdlaWdodDogNDAwO1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Pi5zdWJ0aXRsZSB7XG5cdFx0XHRcdGZvbnQtc2l6ZTogMTJweDtcblx0XHRcdFx0Zm9udC13ZWlnaHQ6IDUwMDtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQ+LnJpZ2h0IHtcblx0XHRcdGZsZXg6IDU7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0bWF4LXdpZHRoOiBtYXgtY29udGVudDtcblx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0XHRnYXA6IDFlbTtcblxuXHRcdFx0Ly8gLy8gZm9yIGFic29sdXRlLXBvc2l0aW9uZWQgb3ZlcmxheSBjaGlsZFxuXHRcdFx0Ly8gcG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdFx0XHQmLmhlaWdodGxlc3Mge1xuXHRcdFx0XHRoZWlnaHQ6IDA7XG5cdFx0XHR9XG5cblx0XHRcdC8vID4ubmV0d29yayB7XG5cdFx0XHQvLyBcdGZsZXg6IDM7XG5cdFx0XHQvLyBcdG1heC13aWR0aDogZml0LWNvbnRlbnQ7XG5cdFx0XHQvLyBcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdC8vIFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRcdC8vIFx0bWFyZ2luLXRvcDogLTE3cHg7XG5cblx0XHRcdC8vIFx0Pi5pY29uIHtcblx0XHRcdC8vIFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0Ly8gXHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdC8vIFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdFx0Ly8gXHRcdG1hcmdpbi1sZWZ0OiAtNHB4O1xuXHRcdFx0Ly8gXHR9XG5cdFx0XHQvLyB9XG5cblx0XHRcdD4uY2x1c3RlciB7XG5cdFx0XHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdFx0XHRAcmFkaXVzOiA1cHg7XG5cblx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY29sbGFwc2UgYWRqYWNlbnQgYm9yZGVyc1xuXHRcdFx0XHQ+Om50aC1jaGlsZChuKzEpIHtcblx0XHRcdFx0XHRtYXJnaW4tbGVmdDogLTJweDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vID5zcGFuLm5ldHdvcmsge1xuXHRcdFx0XHQvLyBcdC0taWNvbi1kaWFtZXRlcjogMjZweDtcblx0XHRcdFx0Ly8gXHQtLWJ1dHRvbi1kaWFtZXRlcjogMzJweDtcblx0XHRcdFx0Ly8gXHRtYXJnaW4tYm90dG9tOiAtMXB4O1xuXHRcdFx0XHQvLyB9XG5cblx0XHRcdFx0Ly8gPi5hY2NvdW50LD4ubmV0d29yayB7XG5cdFx0XHRcdC8vIFx0LS1pY29uLWRpYW1ldGVyOiAzMnB4O1xuXG5cdFx0XHRcdC8vIFx0ZmxleDogMTtcblx0XHRcdFx0Ly8gXHRtYXgtd2lkdGg6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHQvLyBcdG1pbi13aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdC8vIFx0bWFyZ2luLWJvdHRvbTogLTVweDtcblx0XHRcdFx0Ly8gXHRjdXJzb3I6IHBvaW50ZXI7XG5cblx0XHRcdFx0Ly8gXHQuZmFjZSB7XG5cdFx0XHRcdC8vIFx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG5cdFx0XHRcdC8vIFx0XHR3aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdC8vIFx0XHRoZWlnaHQ6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHQvLyBcdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdC8vIFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0Ly8gXHR9XG5cdFx0XHRcdC8vIH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQuc2VhcmNoIHtcblx0XHRmb250LXdlaWdodDogNDAwO1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuXHRcdD4uYWN0aW9uIHtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjBweDtcblx0XHRcdHdpZHRoOiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdGhlaWdodDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRmaWxsOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblxuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0cmlnaHQ6IDEycHg7XG5cdFx0XHR0b3A6IGNhbGMoNTAlIC0gKHZhcigtLWljb24tZGlhbWV0ZXIpIC8gMikpO1xuXG5cdFx0XHQ+c3ZnIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiaGVhZGVyXCIgYmluZDp0aGlzPXtkbV9oZWFkZXJ9PiAgPCEtLSBjbGFzczpibHVyPXskeXdfYmx1cn0gLS0+XG5cdDwhLS0gdG9wIHJvdyAtLT5cblx0PGRpdiBjbGFzcz1cInRvcFwiPlxuXHRcdDwhLS0gbGVmdG1vc3QgYWN0aW9uL2J1dHRvbiAtLT5cblx0XHR7I2lmIGJfcG9wc31cblx0XHRcdDxzcGFuIGNsYXNzPVwiYmFja1wiIG9uOmNsaWNrPXsoKSA9PiBrX3BhZ2UucG9wKCl9PlxuXHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9BUlJPV19MRUZUfVxuXHRcdFx0XHQ8IS0tIDxBcnJvd0JhY2tJY29uIHNpemU9JzI0cHgnIC8+IC0tPlxuXHRcdFx0XHQ8IS0tIDxpbWcgc3JjPVwiL21lZGlhL25hdi9hcnJvdy1sZWZ0LnN2Z1wiIGFsdD1cIkNsaWNrIHRvIGdvIGJhY2tcIiAvPiAtLT5cblx0XHRcdDwvc3Bhbj5cblx0XHR7OmVsc2UgaWYgIWJfZXhpdHMgJiYgIWJfcGxhaW59XG5cdFx0XHQ8U3RhclNoZWxsTG9nbyBkaW09ezQ4fSBhbHQ9XCJDbGljayB0byB2aWV3IGdlbmVyYWwgc3RhdHVzXCIgb246Y2xpY2s9eygpID0+ICR5d19tZW51X3ZlbmRvciA9IHRydWV9IC8+XG5cdFx0ey9pZn1cblxuXHRcdDwhLS0gbWFpbiB0aXRsZSBzZWN0aW9uIG9uIHRoZSBsZWZ0IC0tPlxuXHRcdDxzcGFuIGNsYXNzPVwibWFpblwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cInRpdGxlXCI+XG5cdFx0XHRcdHsjaWYgc190aXRsZX1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdHtzX3RpdGxlfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHR7I2lmIHNfc3ltYm9sfVxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJzeW1ib2xcIj5cblx0XHRcdFx0XHRcdFx0LSB7c19zeW1ib2x9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0ey9pZn1cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IGNsYXNzPVwic3VidGl0bGVcIj5cblx0XHRcdFx0e3Nfc3VidGl0bGV9XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L3NwYW4+XG5cblx0XHQ8IS0tIGFsbCB0b3AgYWN0aW9ucyB0aGF0IGFwcGVhciBvbiB0aGUgcmlnaHQgc2lkZSAtLT5cblx0XHQ8c3BhbiBjbGFzcz1cInJpZ2h0XCIgY2xhc3M6aGVpZ2h0bGVzcz17IWJfbmV0d29yayAmJiBiX2V4aXRzfT5cblx0XHRcdDwhLS0gYWNjb3VudC9uZXR3b3JrIHN3aXRjaCBjbHVzdGVyIC0tPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJjbHVzdGVyXCI+XG5cdFx0XHRcdDwhLS0gbmV0d29yayBzd2l0Y2hlciAtLT5cblx0XHRcdFx0eyNpZiBiX25ldHdvcmt9XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJuZXR3b3JrXCIgb246Y2xpY2s9eyhkX2V2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRkX2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0JHl3X292ZXJsYXlfbmV0d29yayA9ICEkeXdfb3ZlcmxheV9uZXR3b3JrO1xuXHRcdFx0XHRcdH19PlxuXHRcdFx0XHRcdFx0eyNrZXkgJHl3X2NoYWlufVxuXHRcdFx0XHRcdFx0XHQ8UGZwRGlzcGxheVxuXHRcdFx0XHRcdFx0XHRcdHJlc291cmNlPXskeXdfY2hhaW59XG5cdFx0XHRcdFx0XHRcdFx0ey4uLm92ZXJsYXlfcGZwX3Byb3BzKGZhbHNlKX1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdHsva2V5fVxuXHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdHsjaWYgJHl3X292ZXJsYXlfbmV0d29ya31cblx0XHRcdFx0XHRcdDxPdmVybGF5U2VsZWN0XG5cdFx0XHRcdFx0XHRcdHRpdGxlPSdTd2l0Y2ggTmV0d29yaydcblx0XHRcdFx0XHRcdFx0YmluZDpvcGVuPXskeXdfb3ZlcmxheV9uZXR3b3JrfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJyb3dzXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyNhd2FpdCBDaGFpbnMucmVhZCgpfVxuXHRcdFx0XHRcdFx0XHRcdFx0Li4uXG5cdFx0XHRcdFx0XHRcdFx0ezp0aGVuIGtzX2NoYWluc30gXG5cdFx0XHRcdFx0XHRcdFx0XHR7I2VhY2gga3NfY2hhaW5zLmVudHJpZXMoKSBhcyBbcF9jaGFpbiwgZ19jaGFpbl19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZT17Z19jaGFpbn1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXRhaWw9J0RlZmF1bHQgUHJvdmlkZXInXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCR5d19jaGFpbl9yZWYgPSBwX2NoYWluO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHl3X292ZXJsYXlfbmV0d29yayA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJyaWdodFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyNpZiAkeXdfY2hhaW5fcmVmID09PSBwX2NoYWlufVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm92ZXJsYXktc2VsZWN0IGljb25cIiBzdHlsZT1cIi0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e0BodG1sIFNYX0NIRUNLRUR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvUm93PlxuXHRcdFx0XHRcdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHRcdFx0XHRcdHsvYXdhaXR9XG5cdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdFx0PC9PdmVybGF5U2VsZWN0PlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdHsvaWZ9XG5cblx0XHRcdFx0PCEtLSBhY2NvdW50IHN3aXRjaGVyIC0tPlxuXHRcdFx0XHR7I2lmIGJfYWNjb3VudH1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImFjY291bnRcIiBvbjpjbGljaz17KGRfZXZlbnQpID0+IHtcblx0XHRcdFx0XHRcdGRfZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHQkeXdfb3ZlcmxheV9hY2NvdW50ID0gISR5d19vdmVybGF5X2FjY291bnQ7XG5cdFx0XHRcdFx0fX0+XG5cdFx0XHRcdFx0XHR7I2tleSAkeXdfYWNjb3VudH1cblx0XHRcdFx0XHRcdFx0PFBmcERpc3BsYXlcblx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZT17JHl3X2FjY291bnR9XG5cdFx0XHRcdFx0XHRcdFx0ey4uLm92ZXJsYXlfcGZwX3Byb3BzKHRydWUpfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0ey9rZXl9XG5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHR7I2lmICR5d19vdmVybGF5X2FjY291bnR9XG5cdFx0XHRcdFx0XHQ8T3ZlcmxheVNlbGVjdFxuXHRcdFx0XHRcdFx0XHR0aXRsZT0nU3dpdGNoIEFjY291bnQnXG5cdFx0XHRcdFx0XHRcdGJpbmQ6b3Blbj17JHl3X292ZXJsYXlfYWNjb3VudH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicm93c1wiPlxuXHRcdFx0XHRcdFx0XHRcdHsjYXdhaXQgQWNjb3VudHMucmVhZCgpfVxuXHRcdFx0XHRcdFx0XHRcdFx0Li4uXG5cdFx0XHRcdFx0XHRcdFx0ezp0aGVuIGtzX2FjY291bnRzfVxuXHRcdFx0XHRcdFx0XHRcdFx0PCEtLSB7I2lmIGtzX2FjY291bnRzLmVudHJpZXMoKS5sZW5ndGggPiAyfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmFtZT1cIkFsbCBBY2NvdW50c1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGV0YWlsPXtmb3JtYXRfZmlhdChPYmplY3QudmFsdWVzKEhfQUNDT1VOVFMpLnJlZHVjZSgoY19zdW0sIGtfYWNjb3VudCkgPT4gY19zdW0gKyAoa19hY2NvdW50LmFnZ3JlZ2F0b3I/IDA6IEhvbGRpbmcudXNkU3VtKGtfYWNjb3VudC5ob2xkaW5ncyhIX0hPTERJTkdTLCAkeXdfY2hhaW4pLCBIX1RPS0VOUywgSF9WRVJTVVNfVVNEKSksIDApKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgcF9hY2NvdW50X2FsbCA9IEFjY291bnQucmVmRnJvbUlkKCcqJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfYWNjb3VudCA9IEhfQUNDT1VOVFNbcF9hY2NvdW50X2FsbF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfb3ZlcmxheV9hY2NvdW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInJpZ2h0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7I2lmICR5d19hY2NvdW50LmRlZi5pcmkgPT09IEFjY291bnQucmVmRnJvbUlkKCcqJyl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwib3ZlcmxheS1zZWxlY3QgaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBTWF9DSEVDS0VEfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJwZnAgc3F1YXJlIGljb24gYWdncmVnYXRvclwiIHN0eWxlPVwiZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6MzBweDsgbWFyZ2luLWxlZnQ6YXV0bzsgbWFyZ2luLXJpZ2h0OmF1dG87XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0XHRcdFx0XHQtLT5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PCEtLSB7I2VhY2gga3NfYWNjb3VudHMuZW50cmllcygpLmZpbHRlcigoWyxrXSkgPT4gIWsuYWdncmVnYXRvcikgYXMgW3BfYWNjb3VudCwga19hY2NvdW50XX0gLS0+XG5cdFx0XHRcdFx0XHRcdFx0XHR7I2VhY2gga3NfYWNjb3VudHMuZW50cmllcygpIGFzIFtwX2FjY291bnQsIGdfYWNjb3VudF19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZT17Z19hY2NvdW50fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc291cmNlUGF0aD17cF9hY2NvdW50fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRldGFpbD17Z19hY2NvdW50LmV4dHJhPy50b3RhbF9maWF0X2NhY2hlID8/ICcoPyknfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfYWNjb3VudF9yZWYgPSBwX2FjY291bnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfb3ZlcmxheV9hY2NvdW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInJpZ2h0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7I2lmICR5d19hY2NvdW50X3JlZiA9PT0gcF9hY2NvdW50fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm92ZXJsYXktc2VsZWN0IGljb25cIiBzdHlsZT1cIi0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e0BodG1sIFNYX0NIRUNLRUR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8UGZwRGlzcGxheSBkaW09ezMyfSByZXNvdXJjZT17Z19hY2NvdW50fSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHRcdFx0XHR7L2F3YWl0fVxuXHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0XHRcdDwvT3ZlcmxheVNlbGVjdD5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHR7L2lmfVxuXHRcdFx0PC9zcGFuPlxuXG5cdFx0XHQ8IS0tIGV4aXQgYnV0dG9uIC0tPlxuXHRcdFx0eyNpZiBiX2V4aXRzfVxuXHRcdFx0XHQ8Q2xvc2Ugb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdjbG9zZScpfSAvPlxuXHRcdFx0ey9pZn1cblx0XHQ8L3NwYW4+XG5cdDwvZGl2PlxuXHR7I2lmIGJfc2VhcmNofVxuXHRcdDxkaXYgY2xhc3M9XCJzZWFyY2hcIj5cblx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiXG5cdFx0XHRcdGF1dG9mb2N1cz17aXNTZWFyY2hTY3JlZW59XG5cdFx0XHRcdHBsYWNlaG9sZGVyPSdTZWFyY2ggYW55dGhpbmc6IHRva2VuLCBhY2NvdW50LCBjb250YWN0LCB0eG4uLi4nXG5cdFx0XHRcdGJpbmQ6dmFsdWU9e3Nfc2VhcmNofVxuXHRcdFx0XHRvbjppbnB1dD17dXBkYXRlX3NlYXJjaH1cblx0XHRcdFx0YmluZDp0aGlzPXtkbV9zZWFyY2h9XG5cdFx0XHQ+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImFjdGlvblwiPlxuXHRcdFx0XHQ8IS0tIDxpbWcgc3JjPVwiL2Fzc2V0cy9tZWRpYS9uYXYvc2VhcmNoLnN2Z1wiIGFsdD1cIlwiIC8+IC0tPlxuXHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9TRUFSQ0h9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9kaXY+XG5cdHsvaWZ9XG48L2Rpdj5cbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiIGxhbmc9XCJ0c1wiPlxuXHRleHBvcnQgbmFtZXNwYWNlIExvZ0l0ZW0ge1xuXHRcdGV4cG9ydCBpbnRlcmZhY2UgU3RyaW5nIHtcblx0XHRcdHR5cGU6ICdzdHJpbmcnO1xuXHRcdFx0dmFsdWU6IHN0cmluZztcblx0XHR9XG5cblx0XHRleHBvcnQgaW50ZXJmYWNlIEV2ZW50IHtcblx0XHRcdHR5cGU6ICdldmVudCc7XG5cdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRtZXNzYWdlOiBzdHJpbmc7XG5cdFx0XHRcdG9mZnNldDogbnVtYmVyO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRleHBvcnQgdHlwZSBBbnkgPSBTdHJpbmcgfCBFdmVudDtcblx0fVxuXG5cdGV4cG9ydCB0eXBlIExvZ0l0ZW0gPSBMb2dJdGVtLkFueTtcblxuXHRleHBvcnQgY2xhc3MgTG9nZ2VyIHtcblx0XHQvLyBwcml2YXRlIF9hX2l0ZW1zOiBMb2dJdGVtW10gPSBbXTtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0dGhpcy5fYV9pdGVtcyA9IFtdO1xuXHRcdH1cblxuXHRcdGdldCBpdGVtcygpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hX2l0ZW1zO1xuXHRcdH1cblxuXHRcdHNldCBpdGVtcyhhX2l0ZW1zOiBMb2dJdGVtW10pIHtcblx0XHRcdHRoaXMuX2FfaXRlbXMgPSBhX2l0ZW1zO1xuXHRcdH1cblxuXHRcdGV2ZW50KHNfbXNnOiBzdHJpbmcsIHh0X29mZnNldDogbnVtYmVyKTogdGhpcyB7XG5cdFx0XHR0aGlzLl9hX2l0ZW1zLnB1c2goe1xuXHRcdFx0XHR0eXBlOiAnZXZlbnQnLFxuXHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdG1lc3NhZ2U6IHNfbXNnLFxuXHRcdFx0XHRcdG9mZnNldDogeHRfb2Zmc2V0LFxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cblx0ZXhwb3J0IGxldCBpdGVtczogTG9nSXRlbVtdO1xuXG5cdGV4cG9ydCBsZXQgaGlkZSA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIGZvcm1hdF9tcyhuX21zOiBudW1iZXIpOiBzdHJpbmcge1xuXHRcdHJldHVybiAobl9tcyAvIDEwMDApLnRvRml4ZWQoMikucGFkU3RhcnQoNSwgJzAnKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQubG9nLWNvbnRhaW5lciB7XG5cdFx0Zm9udC1mYW1pbHk6ICdQVCBNb25vJywgbW9ub3NwYWNlO1xuXG5cdFx0Pm9sIHtcblx0XHRcdD5saSB7XG5cdFx0XHRcdD5zcGFuIHtcblx0XHRcdFx0XHQmLnN0cmluZyB7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmLmV2ZW50IHtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJsb2ctY29udGFpbmVyXCIgY2xhc3M6ZGlzcGxheV9ub25lPXtoaWRlfT5cblx0PG9sPlxuXHRcdHsjZWFjaCBpdGVtcyBhcyBnX2l0ZW19XG5cdFx0XHQ8bGk+XG5cdFx0XHRcdHsjaWYgJ3N0cmluZycgPT09IGdfaXRlbS50eXBlfVxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwic3RyaW5nXCI+e2dfaXRlbS52YWx1ZX08L3NwYW4+XG5cdFx0XHRcdHs6ZWxzZSBpZiAnZXZlbnQnID09PSBnX2l0ZW0udHlwZX1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImV2ZW50XCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm9mZnNldFwiPit7Zm9ybWF0X21zKGdfaXRlbS52YWx1ZS5vZmZzZXQpfW1zOiA8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm1lc3NhZ2VcIj57Z19pdGVtLnZhbHVlLm1lc3NhZ2V9PC9zcGFuPlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0ey9pZn1cblx0XHRcdDwvbGk+XG5cdFx0ey9lYWNofVxuXHQ8L29sPlxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHQvLyB0YXJnZXQgd2lkdGhcblx0ZXhwb3J0IGxldCB3aWR0aCA9IDE4MDtcblx0Y29uc3QgeF93aWR0aCA9IHdpZHRoO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQudGl0bGUge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdG1hcmdpbjogMDtcblx0XHRwYWRkaW5nOiAwO1xuXHRcdGJvcmRlcjogMDtcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdG1hcmdpbi1sZWZ0OiBhdXRvO1xuXHRcdG1hcmdpbi1yaWdodDogYXV0bztcblxuXHRcdGhlaWdodDogYXV0bztcblxuXHRcdGltZyB7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJuby1tYXJnaW4gdGl0bGVcIiBzdHlsZT1cIndpZHRoOnt4X3dpZHRofXB4O1wiPlxuXHQ8aW1nIGFsdD1cIlN0YXJTaGVsbCB0aXRsZVwiIHNyYz1cIi9tZWRpYS92ZW5kb3IvdGl0bGUuc3ZnXCIgLz5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtnZXRDb250ZXh0fSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcuLi91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuXHRpbXBvcnQge1NjcmVlbiwgdHlwZSBQYWdlfSBmcm9tICcuL19zY3JlZW5zJztcblxuXG5cdGV4cG9ydCBsZXQgYXR0ZW1wdF9yZWdpc3RlcjogVm9pZEZ1bmN0aW9uO1xuXHRleHBvcnQgbGV0IHdlYWtuZXNzOiBudW1iZXI7XG5cdGNvbnN0IGlfd2Vha25lc3MgPSB3ZWFrbmVzcztcblxuXHQvLyBnZXQgcGFnZSBmcm9tIGNvbnRleHRcblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGZ1bmN0aW9uIHVzZV9hbnl3YXkoKSB7XG5cdFx0YXR0ZW1wdF9yZWdpc3RlcigpO1xuXHRcdGtfcGFnZS5wb3AoKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxTY3JlZW4+XG5cdDxoMz5cblx0XHRXZWFrIFBhc3N3b3JkIFdhcm5pbmdcblx0PC9oMz5cblxuXHQ8cD5cblx0XHRUaGUgcGFzc3dvcmQgeW91IGVudGVyZWQgd2FzIGZvdW5kIG9uIGEgbGlzdCBvZiB0aGUgdG9wIHRlbiB0aG91c2FuZCBtb3N0IGNvbW1vbmx5IHVzZWQgcGFzc3dvcmRzLlxuXHQ8L3A+XG5cblx0PHA+XG5cdFx0SW4gb3JkZXIgdG8gaGVscCBwcmV2ZW50IHRoZSBsb3NzIG9mIGZ1bmRzLCB5b3UgYXJlIGVuY291cmFnZWQgdG8gY3JlYXRlIGEgc3Ryb25nLCB1bmlxdWUgcGFzc3dvcmQuXG5cdDwvcD5cblxuXHQ8cD5cblx0XHRIb3cgZG8geW91IHdhbnQgdG8gcHJvY2VlZD9cblx0PC9wPlxuXG5cdDxBY3Rpb25zTGluZSBjYW5jZWw9J3BvcCcgY29uZmlybT17WydVc2UgYW55d2F5JywgdXNlX2FueXdheV19IHdhaXQ9ezUwMDB9IC8+XG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBnZXRBbGxDb250ZXh0cywgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IFBhZ2UsIFNjcmVlbiB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGltcG9ydCBGaWVsZCBmcm9tICcjL2FwcC91aS9GaWVsZC5zdmVsdGUnO1xuXHRpbXBvcnQgTG9nLCB7IExvZ2dlciB9IGZyb20gJyMvYXBwL3VpL0xvZy5zdmVsdGUnO1xuXG5cdGltcG9ydCB7IFZhdWx0IH0gZnJvbSAnIy9jcnlwdG8vdmF1bHQnO1xuXHRpbXBvcnQge1xuXHRcdEFUVThfRFVNTVlfUEhSQVNFLFxuXHRcdEFUVThfRFVNTVlfVkVDVE9SLFxuXHRcdGFjY2VwdGFibGUsXG5cdFx0bG9naW4sXG5cdFx0cmVnaXN0ZXIsXG5cdFx0QWxyZWFkeVJlZ2lzdGVyZWRFcnJvcixcblx0XHRJbnZhbGlkUGFzc3BocmFzZUVycm9yLFxuXHRcdE5MX1BBU1NQSFJBU0VfTUlOSU1VTSxcblx0XHROTF9QQVNTUEhSQVNFX01BWElNVU0sXG5cdH0gZnJvbSAnIy9zaGFyZS9hdXRoJztcblxuXHRpbXBvcnQgdHlwZSB7IENvbXBsZXRlZCB9IGZyb20gJyMvZW50cnkvZmxvdyc7XG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcuLi91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuXHRpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblx0aW1wb3J0IFN0YXJTaGVsbExvZ28gZnJvbSAnLi4vdWkvU3RhclNoZWxsTG9nby5zdmVsdGUnO1xuXHRpbXBvcnQgU3RhclNoZWxsVGl0bGUgZnJvbSAnLi4vdWkvU3RhclNoZWxsVGl0bGUuc3ZlbHRlJztcblx0aW1wb3J0IFJlZ2lzdGVyV2Vha1Bhc3N3b3JkU3ZlbHRlIGZyb20gJy4vUmVnaXN0ZXJXZWFrUGFzc3dvcmQuc3ZlbHRlJztcblxuXHQvLyBnZXQgcGFnZSBmcm9tIGNvbnRleHRcblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8vIHdpbGwgYmUgc2V0IGlmIHRoaXMgaXMgcGFydCBvZiBhIGZsb3dcblx0Y29uc3QgY29tcGxldGVkID0gZ2V0Q29udGV4dDxDb21wbGV0ZWQgfCB1bmRlZmluZWQ+KCdjb21wbGV0ZWQnKTtcblxuXHQvLyBiaW5kaW5nc1xuXHRsZXQgc2hfcGhyYXNlID0gJyc7XG5cdGxldCBzaF92ZXJpZnkgPSAnJztcblx0bGV0IHNfZXJyb3IgPSAnJztcblxuXHRsZXQgc19lcnJfcGFzc3dvcmQgPSAnJztcblx0bGV0IHNfZXJyX3ZlcmlmeSA9ICcnO1xuXG5cdC8vIHRpbWUgc3RhcnRlZCByZWdpc3RyYXRpb25cblx0bGV0IHh0X3N0YXJ0ID0gMDtcblxuXHQvLyBsb2dnZXIgaW5zdGFjZVxuXHRsZXQga19sb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cblx0Ly8gbG9nIHRvIGxvZ2dlclxuXHRmdW5jdGlvbiBsb2coc19tc2c6IHN0cmluZykge1xuXHRcdGtfbG9nZ2VyID0ga19sb2dnZXIuZXZlbnQoc19tc2csIERhdGUubm93KCkgLSB4dF9zdGFydCk7XG5cdH1cblxuXG5cdC8vIGNvbnRpbnVvdXNseSBjaGVjayB0aGUgYWNjZXB0YWJpbGl0eSBvZiB0aGUgcGFzc3dvcmRcblx0JDogYl9wYXNzd29yZF9hY2NlcHRhYmxlID0gISFzaF9waHJhc2UgJiYgc2hfcGhyYXNlID09PSBzaF92ZXJpZnkgJiYgYWNjZXB0YWJsZShzaF9waHJhc2UpO1xuXG5cdC8vIHVwZGF0ZSB0aGUgY29uZmlybSBhY3Rpb25cblx0JDogYV9jb25maXJtX2FjdGlvbiA9IFsnQ29udGludWUnLCBwcmVwYXJlX3JlZ2lzdGVyLCAhYl9wYXNzd29yZF9hY2NlcHRhYmxlXSBhcyBjb25zdDtcblxuXG5cdC8vIGxpc3RlbiBmb3IgcGFnZSBldmVudCByZXN0b3JlXG5cdGtfcGFnZS5vbih7XG5cdFx0cmVzdG9yZSgpIHtcblx0XHRcdC8vIGNsZWFyIHBhc3N3b3Jkc1xuXHRcdFx0c2hfcGhyYXNlID0gc2hfdmVyaWZ5ID0gJyc7XG5cdFx0fSxcblx0fSk7XG5cblx0ZnVuY3Rpb24gY2hlY2tfcGFzc3dvcmQoKSB7XG5cdFx0aWYoc2hfcGhyYXNlICYmICFhY2NlcHRhYmxlKHNoX3BocmFzZSkpIHtcblx0XHRcdGlmKHNoX3BocmFzZS5sZW5ndGggPCBOTF9QQVNTUEhSQVNFX01JTklNVU0pIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSAnUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCA1IGNoYXJhY3RlcnMnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihzaF9waHJhc2UubGVuZ3RoID4gTkxfUEFTU1BIUkFTRV9NQVhJTVVNKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gJ1Bhc3N3b3JkIG11c3QgYmUgMTAyNCBjaGFyYWN0ZXJzIG9yIGZld2VyJztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9ICdQYXNzd29yZCBpcyBub3QgYWNjZXB0YWJsZSc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzX2Vycl9wYXNzd29yZCA9ICcnO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tfdmVyaWZ5KCkge1xuXHRcdGlmKHNoX3BocmFzZSAmJiAhc19lcnJfcGFzc3dvcmQgJiYgc2hfcGhyYXNlICE9PSBzaF92ZXJpZnkpIHtcblx0XHRcdHNfZXJyX3ZlcmlmeSA9ICdQYXNzd29yZHMgZG8gbm90IG1hdGNoJztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzX2Vycl92ZXJpZnkgPSAnJztcblx0fVxuXG5cdC8vIGRvd25sb2FkIHRvcCAxMGsgbGlzdCBhbmQgcGFyc2UgaXRcblx0Y29uc3QgZHBfcGFzc3dvcmRzID0gKGFzeW5jKCkgPT4ge1xuXHRcdGNvbnN0IGRfcmVzID0gYXdhaXQgZmV0Y2goJy9kYXRhL3Bhc3N3b3Jkcy10b3AtMTBrLnR4dCcpO1xuXHRcdGNvbnN0IHNfbGlzdCA9IGF3YWl0IGRfcmVzLnRleHQoKTtcblx0XHRyZXR1cm4gc19saXN0LnNwbGl0KCdcXG4nKTtcblx0fSkoKTtcblxuXHQvLyBwcmVwYXJlIHRvIHJlZ2lzdGVyXG5cdGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVfcmVnaXN0ZXIoKSB7XG5cdFx0Ly8gY2hlY2sgYWdhaW5zdCB0b3AgMTBrIGxpc3Rcblx0XHRjb25zdCBhX3Bhc3N3b3JkcyA9IGF3YWl0IGRwX3Bhc3N3b3JkcztcblxuXHRcdC8vIHBhc3N3b3JkIGZvdW5kIGluIGxpc3Rcblx0XHRpZihhX3Bhc3N3b3Jkcy5pbmNsdWRlcyhzaF9waHJhc2UpKSB7XG5cdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdGNyZWF0b3I6IFJlZ2lzdGVyV2Vha1Bhc3N3b3JkU3ZlbHRlLFxuXHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdGF0dGVtcHRfcmVnaXN0ZXIsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0Ly8gcGFzc3dvcmQgbm90IGluIGxpc3Rcblx0XHRlbHNlIHtcblx0XHRcdGF3YWl0IGF0dGVtcHRfcmVnaXN0ZXIoKTtcblx0XHR9XG5cdH1cblxuXHQvLyByZWdpc3RyYXRpb24gaXMgYnVzeVxuXHRsZXQgYl9idXN5ID0gZmFsc2U7XG5cdFxuXHQvLyBhdHRlbXB0IHRvIHJlZ2lzdGVyXG5cdGFzeW5jIGZ1bmN0aW9uIGF0dGVtcHRfcmVnaXN0ZXIoKTogUHJvbWlzZTwxPiB7XG5cdFx0Ly8gaW52YWxpZCBzdGF0ZVxuXHRcdGlmKCFiX3Bhc3N3b3JkX2FjY2VwdGFibGUpIHJldHVybiAxO1xuXG5cdFx0Ly8gZG8gbm90IGludGVydXB0OyBsb2NrXG5cdFx0aWYoYl9idXN5KSByZXR1cm4gMTsgYl9idXN5ID0gdHJ1ZTtcblxuXHRcdC8vIHByZXAgZ3JhY2VmdWwgZXhpdFxuXHRcdGNvbnN0IGV4aXQgPSAoKTogMSA9PiAoYl9idXN5ID0gZmFsc2UsIDEpO1xuXG5cdFx0Ly8gcmVzZXQgZXJyb3Jcblx0XHRzX2Vycm9yID0gJyc7XG5cblx0XHQvLyBzdGFydCB0aW1lclxuXHRcdHh0X3N0YXJ0ID0gRGF0ZS5ub3coKTtcblxuXHRcdGxvZygnRXN0aW1hdGluZyB0aW1lIHRvIGNvbXBsZXRlJyk7XG5cblx0XHQvLyBlc3RpbWF0ZSB0aW1lIHRvIGNvbXBsZXRlXG5cdFx0e1xuXHRcdFx0Y29uc3QgeHRfc3RhcnRfZXN0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0YXdhaXQgVmF1bHQuZGVyaXZlUm9vdEJpdHMoQVRVOF9EVU1NWV9QSFJBU0UsIEFUVThfRFVNTVlfVkVDVE9SLCAxIC8gNTApO1xuXHRcdFx0Y29uc3QgeHRfZmluaXNoX2VzdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdFx0Y29uc3QgeHRfZWxhcHNlZF9lc3QgPSB4dF9maW5pc2hfZXN0IC0geHRfc3RhcnRfZXN0O1xuXHRcdFx0Y29uc3QgeHRfZXN0aW1hdGUgPSAyICogKDIgKiAoeHRfZWxhcHNlZF9lc3QgKiA1MCkpO1xuXHRcdFx0bG9nKGBBYm91dCAkeyh4dF9lc3RpbWF0ZSAvIDEwMDApLnRvRml4ZWQoMSl9IHNlY29uZHNgKTtcblx0XHR9XG5cblx0XHQvLyBhdHRlbXB0IHRvIHJlZ2lzdGVyXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IHJlZ2lzdGVyKHNoX3BocmFzZSwgbG9nKTtcblx0XHR9XG5cdFx0Ly8gaGFuZGxlIGVycm9yXG5cdFx0Y2F0Y2goZV9yZWdpc3Rlcikge1xuXHRcdFx0aWYoZV9yZWdpc3RlciBpbnN0YW5jZW9mIEFscmVhZHlSZWdpc3RlcmVkRXJyb3IpIHtcblx0XHRcdFx0c19lcnJvciA9ICdBIHBhc3NwaHJhc2UgaXMgYWxyZWFkeSByZWdpc3RlcmVkJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZV9yZWdpc3RlciBpbnN0YW5jZW9mIEludmFsaWRQYXNzcGhyYXNlRXJyb3IpIHtcblx0XHRcdFx0c19lcnJvciA9ICdJbnZhbGlkIHBhc3NwaHJhc2UnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNfZXJyb3IgPSBgVW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCB3aGlsZSBhdHRlbXB0aW5nIHRvIHJlZ2lzdGVyOlxcbiR7ZV9yZWdpc3Rlci5zdGFjayB8fCBlX3JlZ2lzdGVyLm1lc3NhZ2V9YDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZXhpdFxuXHRcdFx0cmV0dXJuIGV4aXQoKTtcblx0XHR9XG5cblx0XHRsb2coJ1ZlcmlmeWluZyBwYXNzcGhyYXNlJyk7XG5cblx0XHQvLyBhdHRlbXB0IGxvZ2luXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGxvZ2luKHNoX3BocmFzZSwgZmFsc2UsIGxvZyk7XG5cdFx0fVxuXHRcdC8vIGZhaWxlZCB0byB2ZXJpZnlcblx0XHRjYXRjaChlX2xvZ2luKSB7XG5cdFx0XHRzX2Vycm9yID0gJ0ZhaWxlZCB0byB2ZXJpZnkgcGFzc3BocmFzZSBpbW1lZGlhdGVseSBhZnRlciByZWdpc3RyYXRpb24nO1xuXG5cdFx0XHQvLyByZXNldCB2YXVsdFxuXHRcdFx0YXdhaXQgVmF1bHQuZXJhc2VCYXNlKCk7XG5cblx0XHRcdC8vIGV4aXRcblx0XHRcdHJldHVybiBleGl0KCk7XG5cdFx0fVxuXG5cdFx0bG9nKCdEb25lJyk7XG5cblx0XHQvLyBwcm9jZWVkXG5cdFx0c19lcnJvciA9ICdTdWNjZXNzJztcblxuXHRcdC8vIGNvbXBsZXRlXG5cdFx0aWYoY29tcGxldGVkKSBjb21wbGV0ZWQodHJ1ZSk7XG5cblx0XHQvLyBkb25lXG5cdFx0cmV0dXJuIGV4aXQoKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdC5pbnRybyB7XG5cdFx0bWFyZ2luLXRvcDogMWVtO1xuXHRcdC8vIG1hcmdpbi1ib3R0b206IDRlbTtcblx0XHRtYXJnaW4tYm90dG9tOiAwO1xuXG5cdFx0LmxlYWQge1xuXHRcdFx0bWFyZ2luLXRvcDogMWVtO1xuXHRcdFx0bWFyZ2luLWJvdHRvbTogMDtcblx0XHR9XG5cblx0XHQudGl0bGUge1xuXHRcdFx0bGV0dGVyLXNwYWNpbmc6IDFweDtcblx0XHRcdGZvbnQtd2VpZ2h0OiAxMDA7XG5cdFx0XHRmb250LXNpemU6IDI3cHg7XG5cdFx0XHRjb2xvcjogI2QwZDBkMDtcblx0XHRcdG1hcmdpbjogMDtcblxuXHRcdFx0ZW0ge1xuXHRcdFx0XHRmb250LXNpemU6IDMycHg7XG5cdFx0XHRcdGZvbnQtc3R5bGU6IG5vcm1hbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQubG9nbyB7XG5cdFx0XHRoZWlnaHQ6IDM0dmg7XG5cdFx0XHR3aWR0aDogYXV0bztcblx0XHR9XG5cblx0XHQuaWNvbiB7XG5cdFx0XHQtLXN2Zy1jb2xvci1mZzogc2lsdmVyO1xuXHRcdFx0Ly8gLS1zdmctY29sb3ItYmc6ICNmNTI1MjU7XG5cdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gNjBweCk7XG5cdFx0XHRoZWlnaHQ6IGF1dG87XG5cblx0XHRcdC5ncmFwaGljKHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0d2lkdGg6IDE3MnB4O1xuXHRcdFx0XHRcdGhlaWdodDogMTM3cHg7XG5cdFx0XHRcdFx0bWFyZ2luOiAxMHB4IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQ+c3ZnIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHR9XG5cblx0Lm5hcnJvdyB7XG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRmb250LXdlaWdodDogMzAwO1xuXHRcdG1heC13aWR0aDogMThlbTtcblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbj5cblx0PGNlbnRlcj5cblx0XHQ8ZGl2IGNsYXNzPVwiaW50cm9cIj5cblx0XHRcdDxTdGFyU2hlbGxMb2dvIGRpbT17OTZ9IC8+XG5cblx0XHRcdDxTdGFyU2hlbGxUaXRsZSB3aWR0aD17MTUwfSAvPlxuXHRcdDwvZGl2PlxuXG5cdFx0PHAgY2xhc3M9XCJuYXJyb3dcIj5cblx0XHRcdENyZWF0ZSBhIG5ldyBwYXNzd29yZCB0byBwcm90ZWN0IHlvdXIgd2FsbGV0J3MgZGF0YS5cblx0XHQ8L3A+XG5cdDwvY2VudGVyPlxuXG5cdDxkaXYgY2xhc3M9XCJmb3JtIGZsZXgtcm93c1wiPlxuXHRcdDxpbnB1dCBoaWRkZW5cblx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdG5hbWU9XCJ1c2VybmFtZVwiXG5cdFx0XHRhdXRvY29tcGxldGU9XCJ1c2VybmFtZVwiXG5cdFx0XHR2YWx1ZT1cIlN0YXJTaGVsbCBXYWxsZXQgVXNlclwiPlxuXG5cdFx0PEZpZWxkIGtleT1cInBhc3N3b3JkXCIgbmFtZT1cIk5ldyBwYXNzd29yZFwiPlxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdHR5cGU9XCJwYXNzd29yZFwiXG5cdFx0XHRcdGF1dG9jb21wbGV0ZT1cIm5ldy1wYXNzd29yZFwiXG5cdFx0XHRcdG5hbWU9XCJwYXNzd29yZFwiXG5cdFx0XHRcdHBsYWNlaG9sZGVyPVwiUGFzc3dvcmRcIlxuXHRcdFx0XHRvbjpibHVyPXsoKSA9PiBjaGVja19wYXNzd29yZCgpfVxuXHRcdFx0XHRiaW5kOnZhbHVlPXtzaF9waHJhc2V9PlxuXG5cdFx0XHR7I2lmICFiX3Bhc3N3b3JkX2FjY2VwdGFibGUgJiYgc19lcnJfcGFzc3dvcmR9XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzAwfX0+XG5cdFx0XHRcdFx0e3NfZXJyX3Bhc3N3b3JkfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvaWZ9XG5cdFx0PC9GaWVsZD5cblxuXHRcdDxGaWVsZCBrZXk9XCJ2ZXJpZnktcGFzc3dvcmRcIiBuYW1lPVwiVmVyaWZ5IHBhc3N3b3JkXCI+XG5cdFx0XHQ8aW5wdXRcblx0XHRcdFx0dHlwZT1cInBhc3N3b3JkXCJcblx0XHRcdFx0YXV0b2NvbXBsZXRlPVwibmV3LXBhc3N3b3JkXCJcblx0XHRcdFx0bmFtZT1cInZlcmlmeVwiXG5cdFx0XHRcdHBsYWNlaG9sZGVyPVwiUGFzc3dvcmRcIlxuXHRcdFx0XHRvbjpibHVyPXsoKSA9PiBjaGVja192ZXJpZnkoKX1cblx0XHRcdFx0YmluZDp2YWx1ZT17c2hfdmVyaWZ5fT5cblxuXHRcdFx0eyNpZiAhYl9wYXNzd29yZF9hY2NlcHRhYmxlICYmIHNfZXJyX3ZlcmlmeX1cblx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiIHRyYW5zaXRpb246c2xpZGU9e3tkdXJhdGlvbjozMDB9fT5cblx0XHRcdFx0XHR7c19lcnJfdmVyaWZ5fVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvaWZ9XG5cdFx0PC9GaWVsZD5cblxuXHQ8L2Rpdj5cblxuXHQ8TG9nIGJpbmQ6aXRlbXM9e2tfbG9nZ2VyLml0ZW1zfSAvPlxuXG5cdHsjaWYgc19lcnJvcn1cblx0XHQ8cHJlPntzX2Vycm9yfTwvcHJlPlxuXHR7L2lmfVxuXG5cblx0PEFjdGlvbnNMaW5lIGNvbmZpcm09e2FfY29uZmlybV9hY3Rpb259IC8+XG48L1NjcmVlbj5cbiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTkgNXYxNEg1VjVoMTRtMC0ySDVhMiAyIDAgMCAwLTIgMnYxNGEyIDIgMCAwIDAgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bS03IDljLTEuNjUgMC0zLTEuMzUtMy0zczEuMzUtMyAzLTMgMyAxLjM1IDMgMy0xLjM1IDMtMyAzem0wLTRjLS41NSAwLTEgLjQ1LTEgMXMuNDUgMSAxIDEgMS0uNDUgMS0xLS40NS0xLTEtMXptNiAxMEg2di0xLjUzYzAtMi41IDMuOTctMy41OCA2LTMuNThzNiAxLjA4IDYgMy41OFYxOHptLTkuNjktMmg3LjM4Yy0uNjktLjU2LTIuMzgtMS4xMi0zLjY5LTEuMTJzLTMuMDEuNTYtMy42OSAxLjEyelxcXCIvPlxcbjwvc3ZnPlwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+XFxuXFx0XFx0LnMyci1hbmFseXRpY3MtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0PC9zdHlsZT5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLWFuYWx5dGljcy1mZ1xcXCIgZD1cXFwiTTE5IDNINWMtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDVWNWgxNHYxNHpcXFwiLz5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLWFuYWx5dGljcy1mZ1xcXCIgZD1cXFwiTTcgMTJoMnY1SDd6bTgtNWgydjEwaC0yem0tNCA3aDJ2M2gtMnptMC00aDJ2MmgtMnpcXFwiLz5cXG48L3N2Zz5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTMgNS4wOEE3IDcgMCAwIDEgMTguOTIgMTFoMy4wM2MtLjQ3LTQuNzItNC4yMy04LjQ4LTguOTUtOC45NXYzLjAzek0xOC45MiAxM0E3IDcgMCAwIDEgMTMgMTguOTJ2My4wM2M0LjcyLS40NyA4LjQ4LTQuMjMgOC45NS04Ljk1aC0zLjAzek0xMSAxOC45MmMtMy4zOS0uNDktNi0zLjQtNi02LjkyczIuNjEtNi40MyA2LTYuOTJWMi4wNWMtNS4wNS41LTkgNC43Ni05IDkuOTUgMCA1LjE5IDMuOTUgOS40NSA5IDkuOTV2LTMuMDN6XFxcIi8+XFxuPC9zdmc+XCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgU3RhclNlbGVjdCwgeyBTZWxlY3RPcHRpb24gfSBmcm9tICcuL1N0YXJTZWxlY3Quc3ZlbHRlJztcblxuXHRpbXBvcnQge29kZSwgb2RlcmFmfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IHt5d19hY2NvdW50LCB5d19jaGFpbiwgeXdfb3duZXJ9IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB0eXBlIHsgUmVzb3VyY2UgfSBmcm9tICcjL21ldGEvcmVzb3VyY2UnO1xuXHRpbXBvcnQgdHlwZSB7IFRva2VuLCBUb2tlblBhdGgsIFRva2VuU3BlY0tleSB9IGZyb20gJyMvbWV0YS90b2tlbic7XG5cdGltcG9ydCB7IEVudGl0aWVzIH0gZnJvbSAnIy9zdG9yZS9lbnRpdGllcyc7XG5cdGltcG9ydCB0eXBlIHsgRW50aXR5UGF0aCB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHR5cGUgeyBQZnBQYXRoIH0gZnJvbSAnIy9tZXRhL3BmcCc7XG5cdGltcG9ydCB7IGxvYWRfcGZwcyB9IGZyb20gJy4uL3N2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBhc3NldFJlZjogRW50aXR5UGF0aCB8ICcnID0gJyc7XG5cblx0Y29uc3Qgc2lfY2hhaW4gPSAkeXdfY2hhaW4/LmlkIHx8ICcqJztcblxuXHRsZXQgaF9hc3NldF9wZnBzOiBSZWNvcmQ8UGZwUGF0aCwgSFRNTEVsZW1lbnQ+ID0ge307XG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9hc3NldHMoKSB7XG5cdFx0Y29uc3QgYV9pdGVtczogU2VsZWN0T3B0aW9uW10gPSBbXTtcblxuXHRcdGhfYXNzZXRfcGZwcyA9IGF3YWl0IGxvYWRfcGZwcygkeXdfY2hhaW4uY29pbnMsIHtcblx0XHRcdGRpbTogMTksXG5cdFx0fSk7XG5cblx0XHRmb3IoY29uc3QgW3NpX2NvaW4sIGdfY29pbl0gb2Ygb2RlKCR5d19jaGFpbi5jb2lucykpIHtcblx0XHRcdGFfaXRlbXMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBFbnRpdGllcy5ob2xkaW5nUGF0aEZvcigkeXdfb3duZXIsIHNpX2NvaW4pLFxuXHRcdFx0XHRvYmplY3Q6IGdfY29pbixcblx0XHRcdFx0cHJpbWFyeTogc2lfY29pbixcblx0XHRcdFx0c2Vjb25kYXJ5OiBnX2NvaW4ubmFtZSxcblx0XHRcdFx0cGZwOiBnX2NvaW4ucGZwLFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFfaXRlbXM7XG5cdH1cblxuXHQvLyB0aGUgY3VycmVudCBpdGVtIHNlbGVjdGVkIGJ5IHVzZXJcblx0bGV0IGdfaXRlbTogU2VsZWN0T3B0aW9uPEVudGl0eVBhdGg+ID0ge1xuXHRcdHZhbHVlOiBhc3NldFJlZiBhcyBFbnRpdHlQYXRoLFxuXHRcdG9iamVjdDogbnVsbCEsXG5cdFx0cHJpbWFyeTogJycsXG5cdFx0c2Vjb25kYXJ5OiAnJyxcblx0XHRwZnA6ICcnIGFzIFBmcFBhdGgsXG5cdH07XG5cdCQ6IHtcblx0XHQvLyBwcm9wYWdhdGUgY2hhbmdlIGJhY2sgdG8gZXhwb3J0ZWQgYmluZGluZ1xuXHRcdGFzc2V0UmVmID0gZ19pdGVtPy52YWx1ZSB8fCAnJztcblx0fVxuXG5cdC8vIGFzeW5jIGZ1bmN0aW9uIGxvYWRfdG9rZW5zKCkge1xuXHQvLyBcdC8vIHByZXAgYW4gb3V0cHV0IGxpc3Qgb2Ygc2VsZWN0IGl0ZW1zXG5cdC8vIFx0Y29uc3QgYV9pdGVtcyA9IFtdO1xuXG5cdC8vIFx0Ly8gcmVhZCBhbGwgZnVuZ2libGUgdG9rZW5zIGZvciB0aGlzIGNoYWluXG5cdC8vIFx0Y29uc3QgaF9pbnRlcmZhY2VzID0gYXdhaXQgRW50aXRpZXMucmVhZEZ1bmdpYmxlVG9rZW5zKCR5d19jaGFpbik7XG5cblx0Ly8gXHQvLyBlYWNoIGludGVyZmFjZVxuXHQvLyBcdGZvcihjb25zdCBzaV9pbnRlcmZhY2UgaW4gaF9pbnRlcmZhY2VzKSB7XG5cdC8vIFx0XHQvLyByZWYgdG9rZW4gZGljdFxuXHQvLyBcdFx0Y29uc3QgaF90b2tlbnMgPSBoX2ludGVyZmFjZXNbc2lfaW50ZXJmYWNlIGFzIFRva2VuU3BlY0tleV07XG5cblx0Ly8gXHRcdC8vIGVhY2ggdG9rZW5cblx0Ly8gXHRcdGZvcihjb25zdCBwX3Rva2VuIGluIGhfdG9rZW5zKSB7XG5cdC8vIFx0XHRcdC8vIHJlZiB0b2tlblxuXHQvLyBcdFx0XHRjb25zdCBnX3Rva2VuID0gaF90b2tlbnNbcF90b2tlbiBhcyBUb2tlblBhdGhdO1xuXG5cdC8vIFx0XHRcdC8vIGFkZCB0byBzZWxlY3QgaXRlbXMgbGlzdFxuXHQvLyBcdFx0XHRhX2l0ZW1zLnB1c2goe1xuXHQvLyBcdFx0XHRcdHZhbHVlOiBwX3Rva2VuLFxuXHQvLyBcdFx0XHRcdGxhYmVsOiBgJHtnX3Rva2VuLmJlY2gzMn0gJHtnX3Rva2VuLnN5bWJvbH0gJHtnX3Rva2VuLm5hbWV9YCxcblx0Ly8gXHRcdFx0fSk7XG5cdC8vIFx0XHR9XG5cdC8vIFx0fVxuXHQvLyB9XG5cblx0Ly8gY29uc3QgYV90b2tlbnMgPSBvZGVyYWYoSF9UT0tFTlMsIChfLCBrX3Rva2VuKSA9PiB7XG5cdC8vIFx0Y29uc3Qga19jaGFpbiA9IEhfQ0hBSU5TW2tfdG9rZW4uZGVmLmNoYWluUmVmXTtcblxuXHQvLyBcdGlmKHNpX2NoYWluID09PSBrX2NoYWluLmRlZi5pZCkge1xuXHQvLyBcdFx0cmV0dXJuIFt7XG5cdC8vIFx0XHRcdHZhbHVlOiBrX3Rva2VuLmRlZi5pcmksXG5cdC8vIFx0XHRcdGxhYmVsOiBgJHtrX3Rva2VuLmRlZi5hZGRyZXNzfSAke2tfdG9rZW4uZGVmLnN5bWJvbH0gJHtrX3Rva2VuLmRlZi5sYWJlbH1gLFxuXHQvLyBcdFx0XHRwcmltYXJ5OiBrX3Rva2VuLmRlZi5zeW1ib2wsXG5cdC8vIFx0XHRcdHNlY29uZGFyeToga190b2tlbi5kZWYubGFiZWwsXG5cdC8vIFx0XHRcdHRva2VuOiBrX3Rva2VuLFxuXHQvLyBcdFx0fV07XG5cdC8vIFx0fVxuXG5cdC8vIFx0cmV0dXJuIFtdO1xuXHQvLyB9KTtcblxuXHQvLyBsZXQgZ190b2tlbl9zZWxlY3QgPSBrX3Rva2VuPyBhX3Rva2Vucy5maW5kKGcgPT4gZy52YWx1ZSA9PT0ga190b2tlbi5kZWYuaXJpKTogdm9pZCAwO1xuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiYXNzZXRcIj5cblx0eyNhd2FpdCBsb2FkX2Fzc2V0cygpfVxuXHRcdExvYWRpbmcgYXNzZXRzLi4uXG5cdHs6dGhlbiBhX2Fzc2V0c31cblx0XHQ8U3RhclNlbGVjdCBpZD1cImFzc2V0LXNlbGVjdFwiXG5cdFx0XHRwZnBNYXA9e2hfYXNzZXRfcGZwc31cblx0XHRcdHBsYWNlaG9sZGVyPVwiU2VsZWN0IGFzc2V0XCJcblx0XHRcdGl0ZW1zPXthX2Fzc2V0c31cblx0XHRcdGJpbmQ6dmFsdWU9e2dfaXRlbX1cblx0XHQvPlxuXHR7L2F3YWl0fVxuPC9kaXY+IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIm0xMiA4LTYgNiAxLjQxIDEuNDFMMTIgMTAuODNsNC41OSA0LjU4TDE4IDE0bC02LTZ6XFxcIi8+XFxuPC9zdmc+XCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTE2LjU5IDguNTkgMTIgMTMuMTcgNy40MSA4LjU5IDYgMTBsNiA2IDYtNi0xLjQxLTEuNDF6XFxcIi8+XFxuPC9zdmc+XCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cblx0Ly8gaW1wb3J0IHsgeXdfYXNzZXRfc2VuZCwgeXdfaG9sZGluZ19zZW5kIH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgU1hfSUNPTl9JTkNSRU1FTlQgZnJvbSAnIy9pY29uL2V4cGFuZF9sZXNzLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9ERUNSRU1FTlQgZnJvbSAnIy9pY29uL2V4cGFuZF9tb3JlLnN2Zz9yYXcnO1xuXHRpbXBvcnQgdHlwZSB7IEVudGl0eSwgRW50aXR5UGF0aCwgTmF0aXZlQ29pbiB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB7IEVudGl0aWVzIH0gZnJvbSAnIy9zdG9yZS9lbnRpdGllcyc7XG5cdGltcG9ydCB7IHl3X2FjY291bnQsIHl3X2NoYWluLCB5d19uZXR3b3JrX2FjdGl2ZSwgeXdfb3duZXIgfSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgeyBYVF9NSU5VVEVTIH0gZnJvbSAnIy9zaGFyZS9jb25zdGFudHMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IGZvcm1hdF9hbW91bnQgfSBmcm9tICcjL3V0aWwvZm9ybWF0Jztcblx0aW1wb3J0IHsgQ29pbkdlY2tvIH0gZnJvbSAnIy9zdG9yZS93ZWItYXBpcyc7XG5cblx0ZXhwb3J0IGxldCB2YWx1ZSA9ICcnO1xuXG5cdGNvbnN0IFlHX1pFUk8gPSBuZXcgQmlnTnVtYmVyKDApO1xuXHRjb25zdCBZR19PTkUgPSBuZXcgQmlnTnVtYmVyKDEpO1xuXG5cdGV4cG9ydCBsZXQgYXNzZXRSZWY6IEVudGl0eVBhdGggfCAnJyA9ICcnO1xuXG5cdC8qKlxuXHQgKiBMZWF2ZSBhIGJ1ZmZlciBmb3IgdGhlIG1heGltdW0gYW1vdW50IHRoYXQgY2FuIGJlIHVzZWRcblx0ICovXG5cdGV4cG9ydCBsZXQgYnVmZmVyTWF4OiBCaWdOdW1iZXIgfCBudW1iZXIgPSAwO1xuXG5cdGxldCBnX2Fzc2V0OiBOYXRpdmVDb2luIHwgbnVsbDtcblxuXHRsZXQgeWdfbWF4OiBCaWdOdW1iZXIgPSBZR19aRVJPO1xuXHRsZXQgeWdfc3RlcDogQmlnTnVtYmVyID0gWUdfWkVSTztcblx0bGV0IHNfZmlhdF9lcXVpdmFsZW50ID0gJyc7XG5cblx0JDoge1xuXHRcdGlmKGFzc2V0UmVmKSB7XG5cdFx0XHR2b2lkIHJlbG9hZF9hc3NldCgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGdfYXNzZXQgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGxldCBzaV9jb2luZ2Vja28gPSAnJztcblx0JDoge1xuXHRcdGlmKHNpX2NvaW5nZWNrbykge1xuXHRcdFx0KGFzeW5jKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBoX3ZlcnN1cyA9IGF3YWl0IENvaW5HZWNrby5jb2luc1ZlcnN1cyhbc2lfY29pbmdlY2tvXSwgJ3VzZCcsIDEqWFRfTUlOVVRFUyk7XG5cdFx0XHRcdGlmKHNpX2NvaW5nZWNrbyBpbiBoX3ZlcnN1cykge1xuXHRcdFx0XHRcdHNfZmlhdF9lcXVpdmFsZW50ID0gZm9ybWF0X2Ftb3VudCgrdmFsdWUgKiAraF92ZXJzdXNbc2lfY29pbmdlY2tvXSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c19maWF0X2VxdWl2YWxlbnQgPSAnKD8pJztcblx0XHRcdFx0fVxuXHRcdFx0fSkoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzX2ZpYXRfZXF1aXZhbGVudCA9ICcnO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGZ1bmN0aW9uIHJlbG9hZF9hc3NldCgpIHtcblx0XHRzX2ZpYXRfZXF1aXZhbGVudCA9ICdbLi4uXSc7XG5cblx0XHRjb25zdCBnX2VudGl0eSA9IEVudGl0aWVzLnBhcnNlRW50aXR5UGF0aChhc3NldFJlZiBhcyBFbnRpdHlQYXRoKTtcblx0XHRpZignaG9sZGluZycgPT09IGdfZW50aXR5Py50eXBlKSB7XG5cdFx0XHRjb25zdCBzaV9jb2luID0gZ19lbnRpdHkuY29pbjtcblxuXHRcdFx0Z19hc3NldCA9ICR5d19jaGFpbi5jb2luc1tzaV9jb2luXTtcblxuXHRcdFx0Y29uc3QgZ19jYWNoZWQgPSAkeXdfbmV0d29ya19hY3RpdmUuY2FjaGVkQmFsYW5jZSgkeXdfb3duZXIsIHNpX2NvaW4pO1xuXG5cdFx0XHRpZihnX2NhY2hlZCAmJiBnX2NhY2hlZC50aW1lc3RhbXAgPiBEYXRlLm5vdygpIC0gKDUgKiBYVF9NSU5VVEVTKSkge1xuXHRcdFx0XHR5Z19tYXggPSBuZXcgQmlnTnVtYmVyKGdfY2FjaGVkLmRhdGEuYW1vdW50KS5zaGlmdGVkQnkoLWdfYXNzZXQuZGVjaW1hbHMpLm1pbnVzKG5ldyBCaWdOdW1iZXIoYnVmZmVyTWF4KSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGdfYnVuZGxlID0gYXdhaXQgJHl3X25ldHdvcmtfYWN0aXZlLmJhbmtCYWxhbmNlKCR5d19vd25lciwgc2lfY29pbik7XG5cblx0XHRcdC8vIHN0aWxsIG9uIHNhbWUgY29pblxuXHRcdFx0aWYoYXNzZXRSZWYgPT09IGdfYnVuZGxlLmhvbGRpbmcpIHtcblx0XHRcdFx0Y29uc3QgeWdfYW1vdW50ID0gbmV3IEJpZ051bWJlcihnX2J1bmRsZS5iYWxhbmNlLmFtb3VudCkuc2hpZnRlZEJ5KC1nX2Fzc2V0LmRlY2ltYWxzKS5taW51cyhuZXcgQmlnTnVtYmVyKGJ1ZmZlck1heCkpO1xuXHRcdFx0XHRpZigheWdfYW1vdW50LmVxKHlnX21heCkpIHtcblx0XHRcdFx0XHR5Z19tYXggPSB5Z19hbW91bnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBnX2NvaW4gPSAkeXdfY2hhaW4uY29pbnNbc2lfY29pbl07XG5cblx0XHRcdFx0c2lfY29pbmdlY2tvID0gZ19jb2luPy5leHRyYT8uY29pbmdlY2tvX2lkIHx8ICcnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmKCd0b2tlbicgPT09IGdfZW50aXR5Py50eXBlKSB7XG5cdFx0XHQvLyBjb25zdCBoX2ludGVyZmFjZXMgPSBFbnRpdGllcy5pbmZvRm9yVG9rZW4oKTtcblx0XHRcdC8vIC4uLlxuXHRcdFx0Ly8gVE9ETzogaW1wbGVtZW50XG5cdFx0XHRnX2Fzc2V0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZihnX2Fzc2V0KSB7XG5cdFx0XHR5Z19zdGVwID0gWUdfT05FLnNoaWZ0ZWRCeSgtZ19hc3NldC5kZWNpbWFscyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0eWdfc3RlcCA9IFlHX1pFUk87XG5cdFx0XHR5Z19tYXggPSBZR19aRVJPO1xuXHRcdH1cblx0fVxuXG5cblx0Ly8gJDogeGdfYW1vdW50ID0gQmlnSW50KChuZXcgQmlnTnVtYmVyKHZhbHVlKSkuc2hpZnRlZEJ5KCR5d19hc3NldF9zZW5kPy5kZWYuZGVjaW1hbHMgfHwgMCkrJycpO1xuXG5cdC8vICQ6IHlnX3N0ZXAgPSBnX2Fzc2V0PyBZR19PTkUuc2hpZnRlZEJ5KC1nX2Fzc2V0LmRlY2ltYWxzKTogWUdfWkVSTztcblx0Ly8gJDogeWdfbWF4ID0gQ2hhaW5zLlxuXHQvLyBnX2Fzc2V0Py5hbW91bnQoSF9UT0tFTlMpIHx8IFlHX1pFUk87XG5cblx0Ly8gLy8gZml4IHN2ZWx0ZSdzIHN0dXBpZCBtaXN0YWtlIG9mIGNvZXJjaW5nIGlucHV0W3R5cGU9XCJudW1iZXJcIl0gdmFsdWVzIHRvIGVzIG51bWJlcnNcblx0Ly8gJDoge1xuXHQvLyBcdGlmKCdudW1iZXInID09PSB0eXBlb2YgdmFsdWUpIHtcblx0Ly8gXHRcdHZhbHVlID0gZG1faW5wdXQudmFsdWU7XG5cdC8vIFx0fVxuXHQvLyB9XG5cblx0ZnVuY3Rpb24gY2FwdHVyZV9pbnB1dChkX2V2ZW50OiBFdmVudCkge1xuXHRcdHZhbHVlID0gKGRfZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuXHRcdGNvbnN0IHlnX25leHQgPSB5Z19zdGVwLnBsdXModmFsdWUgfHwgMCk7XG5cblx0XHRpZih5Z19uZXh0Lmx0ZSh5Z19tYXgpKSB7XG5cdFx0XHR2YWx1ZSA9IHlnX25leHQrJyc7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFsdWUgPSB5Z19tYXgrJyc7XG5cdFx0fVxuXG5cdFx0Y2hlY2tfdmFsaWRpdHkoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY3JlbWVudCgpIHtcblx0XHRjb25zdCB5Z19uZXh0ID0geWdfc3RlcC5uZWdhdGVkKCkucGx1cyh2YWx1ZSB8fCAwKTtcblx0XHRpZih5Z19uZXh0Lmd0ZSgwKSkge1xuXHRcdFx0aWYoeWdfbmV4dC5ndCh5Z19tYXgpKSB7XG5cdFx0XHRcdHZhbHVlID0geWdfbWF4KycnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0geWdfbmV4dCsnJztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2YWx1ZSA9ICcwJztcblx0XHR9XG5cblx0XHRjaGVja192YWxpZGl0eSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9uZ19wcmVzcyhmX2FjdGlvbjogVm9pZEZ1bmN0aW9uKSB7XG5cdFx0bGV0IGlfdGlja2VyID0gMDtcblx0XHRjb25zdCBpX2J1ZmZlciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGlfdGlja2VyID0gd2luZG93LnNldEludGVydmFsKGZfYWN0aW9uLCA5MCk7XG5cdFx0fSwgMTAwMCk7XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHtcblx0XHRcdGNsZWFyVGltZW91dChpX2J1ZmZlcik7XG5cdFx0XHRjbGVhckludGVydmFsKGlfdGlja2VyKTtcblx0XHR9LCB7XG5cdFx0XHRvbmNlOiB0cnVlLFxuXHRcdH0pO1xuXHR9XG5cblx0ZXhwb3J0IGxldCBlcnJvciA9ICcnO1xuXHRsZXQgZG1faW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cblx0ZnVuY3Rpb24gaW52YWxpZGF0ZShzX21zZzogc3RyaW5nKSB7XG5cdFx0ZG1faW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoc19tc2cpO1xuXHRcdGVycm9yID0gc19tc2c7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja192YWxpZGl0eSgpIHtcblx0XHRpZighdmFsdWUpIHtcblx0XHRcdHJldHVybiBpbnZhbGlkYXRlKCdFbnRlciBhbiBhbW91bnQnKTtcblx0XHR9XG5cblx0XHRsZXQgeWdfaW5wdXQhOiBCaWdOdW1iZXI7XG5cdFx0dHJ5IHtcblx0XHRcdHlnX2lucHV0ID0gbmV3IEJpZ051bWJlcih2YWx1ZSk7XG5cdFx0fVxuXHRcdGNhdGNoKGVfcGFyc2UpIHtcblx0XHRcdHJldHVybiBpbnZhbGlkYXRlKCdJbnZhbGlkIG51bWJlcicpO1xuXHRcdH1cblxuXHRcdGlmKHlnX2lucHV0Lmx0KFlHX1pFUk8pKSB7XG5cdFx0XHRyZXR1cm4gaW52YWxpZGF0ZSgnVmFsdWUgbXVzdCBiZSBwb3NpdGl2ZScpO1xuXHRcdH1cblxuXHRcdGlmKHlnX2lucHV0Lmd0KHlnX21heCkpIHtcblx0XHRcdHJldHVybiBpbnZhbGlkYXRlKCdJbnN1ZmZpY2llbnQgYmFsYW5jZScpO1xuXHRcdH1cblxuXHRcdGVycm9yID0gJyc7XG5cdH1cblxuXHRleHBvcnQgbGV0IHNob3dWYWxpZGF0aW9uID0gMDtcblx0JDoge1xuXHRcdGlmKHNob3dWYWxpZGF0aW9uKSB7XG5cdFx0XHRjaGVja192YWxpZGl0eSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmKCF2YWx1ZSkge1xuXHRcdFx0ZXJyb3IgPSAnJztcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHRpbnB1dFt0eXBlPVwibnVtYmVyXCJdIHtcblx0XHRhcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XG5cblx0XHQmOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLCAmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcblx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcblx0XHR9XG5cdH1cblxuXHQuYW1vdW50LWlucHV0IHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdH1cblxuXHQub2NjdXB5IHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXHRcdGhlaWdodDogdmFyKC0tdWktcm93LWhlaWdodCk7XG5cblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cblx0XHQuYWRqdXN0IHtcblxuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRcdGdhcDogNHB4O1xuXHRcdFx0bWFyZ2luLXJpZ2h0OiA4cHg7XG5cblx0XHRcdC5pY29uIHtcblx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0XHRwYWRkaW5nOiAwcHggOHB4O1xuXHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDE2cHg7XG5cdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cblx0XHRcdFx0Omdsb2JhbChzdmcpIHtcblx0XHRcdFx0XHR3aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdFx0aGVpZ2h0OiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC5pbmNyZW1lbnQge1xuXHRcdFx0XHRcdHBhZGRpbmctdG9wOiA0cHg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQuZGVjcmVtZW50IHtcblx0XHRcdFx0XHRwYWRkaW5nLWJvdHRvbTogNHB4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmVxdWl2YWxlbnQge1xuXHRcdFx0LmZvbnQocmVndWxhciwgQHNpemU6IDEzcHgsIEB3ZWlnaHQ6IDMwMCk7XG5cblx0XHRcdC5hbW91bnQge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHQuZmlhdCB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJhbW91bnQtaW5wdXRcIj5cblx0PGlucHV0XG5cdFx0ZGlzYWJsZWQ9eyFhc3NldFJlZn1cblx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRtaW49XCIwXCJcblx0XHRtYXg9e3lnX21heCsnJyB8fCAnMCd9XG5cdFx0c3RlcD1cIjAueycwJy5yZXBlYXQoKGdfYXNzZXQ/LmRlY2ltYWxzIHx8IDEpIC0gMSl9MVwiXG5cdFx0cmVxdWlyZWRcblx0XHRvbjpjaGFuZ2U9eygpID0+IGNoZWNrX3ZhbGlkaXR5KCl9XG5cdFx0b246aW5wdXQ9e2NhcHR1cmVfaW5wdXR9XG5cdFx0e3ZhbHVlfVxuXHRcdGJpbmQ6dGhpcz17ZG1faW5wdXR9XG5cdFx0b246aW52YWxpZD17ZCA9PiBkLnByZXZlbnREZWZhdWx0KCl9XG5cdFx0Y2xhc3M6aW52YWxpZD17ZXJyb3J9XG5cdD5cblxuXHR7I2lmIGdfYXNzZXR9XG5cdFx0PHNwYW4gY2xhc3M9XCJvY2N1cHlcIj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiZXF1aXZhbGVudFwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImFtb3VudFwiPlxuXHRcdFx0XHRcdD0ge3NfZmlhdF9lcXVpdmFsZW50fVxuXHRcdFx0XHRcdDwhLS0gIGFtb3VudF90b19maWF0KCt2YWx1ZSwgJHl3X2Fzc2V0X3NlbmQsIHRydWUpIC0tPlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiZmlhdFwiPlxuXHRcdFx0XHRcdFVTRFxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L3NwYW4+XG5cblx0XHRcdDxzcGFuIGNsYXNzPVwiYWRqdXN0XCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvbiBpbmNyZW1lbnQgY2xpY2thYmxlXCJcblx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gaW5jcmVtZW50KCl9XG5cdFx0XHRcdFx0b246bW91c2Vkb3duPXsoKSA9PiBsb25nX3ByZXNzKGluY3JlbWVudCl9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9JTkNSRU1FTlR9XG5cdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb24gZGVjcmVtZW50IGNsaWNrYWJsZVwiXG5cdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IGRlY3JlbWVudCgpfVxuXHRcdFx0XHRcdG9uOm1vdXNlZG93bj17KCkgPT4gbG9uZ19wcmVzcyhkZWNyZW1lbnQpfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fREVDUkVNRU5UfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9zcGFuPlxuXHR7L2lmfVxuXG5cdHsjaWYgZXJyb3J9XG5cdFx0PHNwYW4gY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIj5cblx0XHRcdHtlcnJvcn1cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG48L2Rpdj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyB5d19hY2NvdW50X3JlZiwgeXdfY2hhaW59IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB0eXBlIHtBY2NvdW50LCBBY2NvdW50UGF0aH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQgeyBvZGUsIG9kZXJhYyB9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXG5cdGltcG9ydCBTdGFyU2VsZWN0LCB7IFNlbGVjdE9wdGlvbiB9IGZyb20gJy4vU3RhclNlbGVjdC5zdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgYWNjb3VudFJlZjogQWNjb3VudFBhdGggPSAkeXdfYWNjb3VudF9yZWY7XG5cdC8vIGNvbnN0IHBfYWNjb3VudCA9IGFjY291bnRSZWY7XG5cblxuXHRjb25zdCBta19hY2NvdW50ID0gKHBfYWNjOiBBY2NvdW50UGF0aCwgZ19hY2M6IEFjY291bnRbJ2ludGVyZmFjZSddKSA9PiAoe1xuXHRcdHZhbHVlOiBwX2FjYyxcblx0XHRwcmltYXJ5OiBnX2FjYy5uYW1lLFxuXHRcdHNlY29uZGFyeTogZ19hY2MuZXh0cmE/LnRvdGFsX2ZpYXRfY2FjaGUgfHwgJyg/KScsXG5cdFx0Ly8gc2Vjb25kYXJ5OiBmb3JtYXRfZmlhdChnX2FjYy5ob2xkaW5ncyhIX0hPTERJTkdTLCAkeXdfY2hhaW4pXG5cdFx0XHQvLyAucmVkdWNlKChjX3N1bSwga19ob2xkaW5nKSA9PiBjX3N1bSArIGtfaG9sZGluZy50b1VzZChIX1RPS0VOUywgSF9WRVJTVVNfVVNEKSwgMCkpLFxuXHR9KTtcblxuXHRsZXQgZ19zZWxlY3RlZDogU2VsZWN0T3B0aW9uPEFjY291bnRQYXRoPjsgIC8vID0gbWtfYWNjb3VudCgkeXdfYWNjb3VudF9yZWYsICR5d19hY2NvdW50KTtcblx0bGV0IGFfb3B0aW9uczogdHlwZW9mIGdfc2VsZWN0ZWRbXTtcblxuXHQvLyByZWFjdGl2ZWx5IHVwZGF0ZSB0aGUgZXhwb3J0ZWQgYWNjb3VudCByZWYgYmluZGluZ1xuXHQkOiBpZihnX3NlbGVjdGVkKSB7XG5cdFx0YWNjb3VudFJlZiA9IGdfc2VsZWN0ZWQudmFsdWU7XG5cdH1cblxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX2FjY291bnRzKCkge1xuXHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXG5cdFx0YV9vcHRpb25zID0gb2RlcmFjKGtzX2FjY291bnRzLnJhdywgbWtfYWNjb3VudCk7XG5cdFx0Z19zZWxlY3RlZCA9IGFfb3B0aW9ucy5maW5kKGcgPT4gYWNjb3VudFJlZiA9PT0gZy52YWx1ZSkhO1xuXG5cdFx0cmV0dXJuIGFfb3B0aW9ucztcblx0fVxuPC9zY3JpcHQ+XG5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJ19iYXNlLmxlc3MnO1xuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwic2VuZGVyXCI+XG5cdHsjYXdhaXQgbG9hZF9hY2NvdW50cygpfVxuXHRcdExvYWRpbmcgYWNjb3VudHMuLi5cblx0ezp0aGVuIGFfb3B0aW9uc31cblx0XHQ8U3RhclNlbGVjdCBpZD1cInNlbmRlci1zZWxlY3RcIlxuXHRcdFx0cGxhY2Vob2xkZXI9XCJTZWxlY3QgYWNjb3VudFwiXG5cdFx0XHRzZWNvbmRhcnlDbGFzcz0nYmFsYW5jZSdcblx0XHRcdGl0ZW1zPXthX29wdGlvbnN9XG5cdFx0XHRiaW5kOnZhbHVlPXtnX3NlbGVjdGVkfVxuXHRcdC8+XG5cdHsvYXdhaXR9XG48L2Rpdj4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIiBsYW5nPVwidHNcIj5cblx0ZXhwb3J0IGludGVyZmFjZSBDb250YWN0T3B0aW9uIHtcblx0XHR2YWx1ZTogQ2hhaW4uQmVjaDMyU3RyaW5nO1xuXHRcdGxhYmVsOiBzdHJpbmc7XG5cdFx0Y29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ107XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge3l3X2NoYWluLCB5d19mYW1pbHl9IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgdHlwZSB7IENvbnRhY3QsIENvbnRhY3RQYXRoIH0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXHRpbXBvcnQgeyBBZ2VudHMgfSBmcm9tICcjL3N0b3JlL2FnZW50cyc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgc3Vic2NyaWJlX3N0b3JlIH0gZnJvbSAnIy9zdG9yZS9fYmFzZSc7XG5cdGltcG9ydCB7IG9uRGVzdHJveSB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBQZnBEaXNwbGF5IGZyb20gJy4vUGZwRGlzcGxheS5zdmVsdGUnO1xuXG5cdC8qKlxuXHQgKiBSZXNvdXJjZSBwYXRoIHRvIHRoZSBjb250YWN0XG5cdCAqL1xuXHRleHBvcnQgbGV0IGNvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddIHwgbnVsbCA9IG51bGw7XG5cdGxldCBnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddID0gY29udGFjdCE7XG5cblx0LyoqXG5cdCAqIE1hbnVhbGx5IGVudGVyZWQgYWRkcmVzc1xuXHQgKi9cblx0ZXhwb3J0IGxldCBhZGRyZXNzOiBDaGFpbi5CZWNoMzJTdHJpbmcgPSAnJztcblxuXHQvLyAvLyByZXNvbHZlZCBjb250YWN0XG5cdC8vIGxldCBnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddO1xuXG5cdC8vIGxvYWQgY29udGFjdCBkZWYgZnJvbSBzdG9yZVxuXHRhc3luYyBmdW5jdGlvbiByZWxvYWRfY29udGFjdHMoKSB7XG5cdFx0Ly8gbG9hZCBhZ2VudHMgc3RvcmVcblx0XHRjb25zdCBrc19hZ2VudHMgPSBhd2FpdCBBZ2VudHMucmVhZCgpO1xuXG5cdFx0Ly8gY29udGFjdCBpdGVyYXRvclxuXHRcdGNvbnN0IGRpX2NvbnRhY3RzID0ga3NfYWdlbnRzLmNvbnRhY3RzKCR5d19mYW1pbHkpO1xuLy8gZGVidWdnZXI7XG4vLyBcdFx0Ly8gY29udGFjdCBpcyBwcmVzZW50XG4vLyBcdFx0aWYoZ19jb250YWN0KSB7XG4vLyBcdFx0XHQvLyBlYWNoIGNvbnRhY3Rcbi8vIFx0XHRcdGZvcihjb25zdCBbcF9jb250YWN0X2VhY2gsIGdfY29udGFjdF9lYWNoXSBvZiBkaV9jb250YWN0cykge1xuLy8gXHRcdFx0XHQvLyBmb3VuZCBtYXRjaFxuLy8gXHRcdFx0XHRpZihwX2NvbnRhY3QgPT09IHBfY29udGFjdF9lYWNoKSB7XG4vLyBcdFx0XHRcdFx0Z19jb250YWN0ID0gZ19jb250YWN0X2VhY2g7XG4vLyBcdFx0XHRcdFx0YnJlYWs7XG4vLyBcdFx0XHRcdH1cbi8vIFx0XHRcdH1cbi8vIFx0XHR9XG5cdFx0Ly8gb25seSBhZGRyZXNzIHdhcyBnaXZlblxuXHRcdGlmKCFnX2NvbnRhY3QgJiYgYWRkcmVzcykge1xuXHRcdFx0Ly8gZWFjaCBjb250YWN0XG5cdFx0XHRmb3IoY29uc3QgWywgZ19jb250YWN0X2VhY2hdIG9mIGRpX2NvbnRhY3RzKSB7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIGFkZHJlc3MgZXhpc3RzIGluIGNvbnRhY3RzLCBmb3VuZCBtYXRjaFxuXHRcdFx0XHRpZihhZGRyZXNzID09PSBDaGFpbnMuYmVjaDMyKGdfY29udGFjdF9lYWNoLmFkZHJlc3MpKSB7XG5cdFx0XHRcdFx0Z19jb250YWN0ID0gZ19jb250YWN0X2VhY2g7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2b2lkIHJlbG9hZF9jb250YWN0cygpO1xuXHRjb25zdCBmX3Vuc3ViX2FnZW50cyA9IHN1YnNjcmliZV9zdG9yZSgnYWdlbnRzJywgcmVsb2FkX2NvbnRhY3RzKTtcblx0b25EZXN0cm95KCgpID0+IHtcblx0XHRmX3Vuc3ViX2FnZW50cygpO1xuXHR9KTtcblxuXG5cdC8vIGV4cG9ydCBsZXQgZ19pdGVtOiB7XG5cdC8vIFx0Y29udGFjdDogQ29udGFjdDtcblx0Ly8gXHRpc0dyb3VwSGVhZGVyPzogYm9vbGVhbjtcblx0Ly8gXHRpc0dyb3VwSXRlbT86IGJvb2xlYW47XG5cdC8vIFx0aXNDcmVhdG9yPzogYm9vbGVhbjtcblx0Ly8gfSB8IHVuZGVmaW5lZCA9IHZvaWQgMDtcblxuXHQ8L3NjcmlwdD5cblx0XG5cdDxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcdEBpbXBvcnQgJ19iYXNlLmxlc3MnO1xuXHRcblx0XHQuY29udGFjdCB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1kaXJlY3Rpb246IHJvdztcblx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFxuXHRcdFx0Ly8gcGFkZGluZy10b3A6IDNweDtcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7O1xuXHRcblx0XHRcdD4uY29udGFjdC1wZnAge1xuXHRcdFx0XHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0XHRcdFx0LS1wcm94eS1pY29uLWRpYW1ldGVyOiAyNnB4O1xuXHRcdFx0XHRsaW5lLWhlaWdodDogMjZweDtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiA2cHg7XG5cdFxuXHRcdFx0XHQ+Lmljb24ge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0Ym9yZGVyLXJhZGl1czogMjAlO1xuXHRcdFx0XHRcdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0XHRcdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Lmljb24tZG9tIHtcblx0XHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHVuc2V0O1xuXHRcdFx0XHRcdFx0XHRmb250LXNpemU6IDE0cHg7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdD4uaW5mbyB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0XHRcdG1heC13aWR0aDogMTcycHg7XG5cdFxuXHRcdFx0XHQ+Lm5hbWUge1xuXHRcdFx0XHRcdGxpbmUtaGVpZ2h0OiAxLjJlbTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Pi5hZGRyZXNzIHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdC8vIC5mb250KG1vbm8tdGlueSk7XG5cdFx0XHRcdFx0XHRsaW5lLWhlaWdodDogMS4yZW07XG5cdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vID4qIHtcblx0XHRcdC8vIFx0Omdsb2JhbCgmKSB7XG5cdFx0XHQvLyBcdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHRcdC8vIFx0fVxuXHRcdFx0Ly8gfVxuXHRcdH1cblx0XG5cdFx0Lm1hbnVhbCB7XG5cdFx0XHQuYWRkcmVzcyB7XG5cdFx0XHRcdHdpZHRoOiBjYWxjKDEwMCUgLSAzLjVjaCk7XG5cdFx0XHR9XG5cdFx0fVxuXHQ8L3N0eWxlPlxuXHRcblx0eyNpZiBnX2NvbnRhY3R9XG5cdFx0PGRpdiBjbGFzcz1cImNvbnRhY3RcIj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiY29udGFjdC1wZnBcIj5cblx0XHRcdFx0eyNpZiBnX2NvbnRhY3R9XG5cdFx0XHRcdFx0PFBmcERpc3BsYXkgZGltPXsyOH0gcmVzb3VyY2U9e2dfY29udGFjdH0gZ2VuU3R5bGU9J2ZvbnQtc2l6ZToxOHB4OycgLz5cblx0XHRcdFx0ey9pZn1cblx0XHRcdDwvc3Bhbj5cblx0XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0e2dfY29udGFjdC5uYW1lfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFxuXHRcdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXtDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKX0gLz5cblx0XHRcdDwvc3Bhbj5cblx0XHQ8L2Rpdj5cblx0ezplbHNlIGlmIGFkZHJlc3N9XG5cdFx0PHNwYW4gY2xhc3M9XCJtYW51YWxcIj5cblx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9e2FkZHJlc3N9IC8+XG5cdFx0PC9zcGFuPlxuXHR7OmVsc2V9XG5cdFx0PHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+XG5cdFx0XHRGYWlsZWQgdG8gbG9jYXRlIGNvbnRhY3Rcblx0XHQ8L3NwYW4+XG5cdHsvaWZ9IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBDaGFpbiB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cblx0aW1wb3J0IHR5cGUgeyBDb250YWN0UGF0aH0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXG5cdGltcG9ydCBJbmxpbmVDb250YWN0U2VsZWN0aW9uLCB7IENvbnRhY3RPcHRpb24gfSBmcm9tICcuL0lubGluZUNvbnRhY3RTZWxlY3Rpb24uc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IGlzQWN0aXZlID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgaXNGaXJzdCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGlzSG92ZXIgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBpc1NlbGVjdGFibGUgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBnZXRPcHRpb25MYWJlbCA9IHZvaWQgMDtcblx0ZXhwb3J0IGxldCBpdGVtOiBDb250YWN0T3B0aW9uO1xuXHQvLyBcdGlzR3JvdXBIZWFkZXI/OiBib29sZWFuO1xuXHQvLyBcdGlzR3JvdXBJdGVtPzogYm9vbGVhbjtcblx0Ly8gfTtcblx0ZXhwb3J0IGxldCBmaWx0ZXJUZXh0ID0gJyc7XG5cblx0bGV0IGl0ZW1DbGFzc2VzID0gJyc7XG5cblx0JDoge1xuXHRcdGNvbnN0IGNsYXNzZXM6IHN0cmluZ1tdID0gW107XG5cdFx0aWYoaXNBY3RpdmUpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnYWN0aXZlJyk7XG5cdFx0fVxuXHRcblx0XHRpZihpc0ZpcnN0KSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZpcnN0Jyk7XG5cdFx0fVxuXHRcblx0XHRpZihpc0hvdmVyKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2hvdmVyJyk7XG5cdFx0fVxuXHRcblx0XHQvLyBpZihpdGVtLmlzR3JvdXBIZWFkZXIpIHtcblx0XHQvLyBcdGNsYXNzZXMucHVzaCgnZ3JvdXBIZWFkZXInKTtcblx0XHQvLyB9XG5cdFxuXHRcdC8vIGlmKGl0ZW0uaXNHcm91cEl0ZW0pIHtcblx0XHQvLyBcdGNsYXNzZXMucHVzaCgnZ3JvdXBJdGVtJyk7XG5cdFx0Ly8gfVxuXHRcblx0XHRpZighaXNTZWxlY3RhYmxlKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ25vdFNlbGVjdGFibGUnKTtcblx0XHR9XG5cdFxuXHRcdGl0ZW1DbGFzc2VzID0gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0Lml0ZW0ge1xuXHRcdGN1cnNvcjogZGVmYXVsdDtcblx0XHRoZWlnaHQ6IHZhcigtLWhlaWdodCwgNDJweCk7XG5cdFx0bGluZS1oZWlnaHQ6IHZhcigtLWhlaWdodCwgNDJweCk7XG5cdFx0cGFkZGluZzogdmFyKC0taXRlbVBhZGRpbmcsIDAgMjBweCk7XG5cdFx0Y29sb3I6IHZhcigtLWl0ZW1Db2xvciwgaW5oZXJpdCk7XG5cdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdHBhZGRpbmctbGVmdDogOHB4O1xuXHR9XG5cblx0Lmdyb3VwSGVhZGVyIHtcblx0XHR0ZXh0LXRyYW5zZm9ybTogdmFyKC0tZ3JvdXBUaXRsZVRleHRUcmFuc2Zvcm0sIHVwcGVyY2FzZSk7XG5cdH1cblxuXHQuZ3JvdXBJdGVtIHtcblx0XHRwYWRkaW5nLWxlZnQ6IHZhcigtLWdyb3VwSXRlbVBhZGRpbmdMZWZ0LCA0MHB4KTtcblx0fVxuXG5cdC5pdGVtOmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogdmFyKC0taXRlbUFjdGl2ZUJhY2tncm91bmQsICNiOWRhZmYpO1xuXHR9XG5cblx0Lml0ZW0uYWN0aXZlIHtcblx0XHRiYWNrZ3JvdW5kOiB2YXIoLS1pdGVtSXNBY3RpdmVCRywgIzAwN2FmZik7XG5cdFx0Y29sb3I6IHZhcigtLWl0ZW1Jc0FjdGl2ZUNvbG9yLCAjZmZmKTtcblx0fVxuXG5cdC5pdGVtLm5vdFNlbGVjdGFibGUge1xuXHRcdGNvbG9yOiB2YXIoLS1pdGVtSXNOb3RTZWxlY3RhYmxlQ29sb3IsICM5OTkpO1xuXHR9XG5cblx0Lml0ZW0uZmlyc3Qge1xuXHRcdGJvcmRlci1yYWRpdXM6IHZhcigtLWl0ZW1GaXJzdEJvcmRlclJhZGl1cywgNHB4IDRweCAwIDApO1xuXHR9XG5cblx0Lml0ZW0uaG92ZXI6bm90KC5hY3RpdmUpIHtcblx0XHRiYWNrZ3JvdW5kOiB2YXIoLS1pdGVtSG92ZXJCRywgI2U3ZjJmZik7XG5cdFx0Y29sb3I6IHZhcigtLWl0ZW1Ib3ZlckNvbG9yLCBpbmhlcml0KTtcblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwiaXRlbSB7aXRlbUNsYXNzZXN9XCIgY2xhc3M6ZGlzcGxheV9ub25lPXtpc0FjdGl2ZSB8fCAhaXRlbS52YWx1ZX0+XG5cdDxJbmxpbmVDb250YWN0U2VsZWN0aW9uIGNvbnRhY3Q9e2l0ZW0uY29udGFjdH0gYWRkcmVzcz17aXRlbS52YWx1ZX0gLz5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBDaGFpbiB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cblx0aW1wb3J0IHR5cGUgeyBDb250YWN0UGF0aH0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXG5cdGltcG9ydCBJbmxpbmVDb250YWN0U2VsZWN0aW9uLCB7IENvbnRhY3RPcHRpb24gfSBmcm9tICcuL0lubGluZUNvbnRhY3RTZWxlY3Rpb24uc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IGdldFNlbGVjdGlvbkxhYmVsO1xuXHRleHBvcnQgbGV0IGl0ZW06IENvbnRhY3RPcHRpb247XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5zZWxlY3Rpb24ge1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdG92ZXJmbG93LXg6IGhpZGRlbjtcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRwYWRkaW5nLWxlZnQ6IDhweDtcblxuXHRcdC5tYW51YWw+LmFkZHJlc3Mge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdHdpZHRoOiBjYWxjKDEwMCUgLSAzLjVjaCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG5cbjxkaXYgY2xhc3M9XCJzZWxlY3Rpb25cIj5cblx0PElubGluZUNvbnRhY3RTZWxlY3Rpb24gY29udGFjdD17aXRlbS5jb250YWN0fSBhZGRyZXNzPXtpdGVtLnZhbHVlfSAvPlxuPC9kaXY+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHt5d19hY2NvdW50LCB5d19jaGFpbiwgeXdfZmFtaWx5LCB5d19oZWxwfSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCBSZWNpcGllbnRTZWxlY3RJdGVtIGZyb20gJy4vUmVjaXBpZW50U2VsZWN0SXRlbS5zdmVsdGUnO1xuXG5cdGltcG9ydCBTZWxlY3QgZnJvbSAnc3ZlbHRlLXNlbGVjdCc7XG5cdGltcG9ydCBTWF9JQ09OX1NDQU4gZnJvbSAnIy9pY29uL3FyX2NvZGVfc2Nhbm5lci5zdmc/cmF3Jztcblx0aW1wb3J0IFJlY2lwaWVudFNlbGVjdFNlbGVjdGlvbiBmcm9tICcuL1JlY2lwaWVudFNlbGVjdFNlbGVjdGlvbi5zdmVsdGUnO1xuXHRpbXBvcnQge29kZXJhY30gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQge29uTW91bnR9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7ZGQsIHFzfSBmcm9tICcjL3V0aWwvZG9tJztcblx0aW1wb3J0IHR5cGUge0FnZW50UGF0aCwgQ2hhaW59IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdCB9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHsgQWdlbnRzIH0gZnJvbSAnIy9zdG9yZS9hZ2VudHMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdE9wdGlvbiB9IGZyb20gJy4vSW5saW5lQ29udGFjdFNlbGVjdGlvbi5zdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgYWRkcmVzczogQ2hhaW4uQmVjaDMyU3RyaW5nID0gJyc7XG5cdGNvbnN0IHNhX2lucHV0ID0gYWRkcmVzcztcblxuXHRleHBvcnQgbGV0IGVycm9yID0gJyc7XG5cblx0bGV0IHNfbWFudWFsX2lucHV0OiBzdHJpbmc7XG5cdGxldCBnX2l0ZW1fc2VsZWN0OiBDb250YWN0T3B0aW9uO1xuXG5cdGxldCBhX2NvbnRhY3RzOiBbQWdlbnRQYXRoLCBDb250YWN0WydpbnRlcmZhY2UnXV1bXTtcblxuXHRjb25zdCBjb250YWN0X3RvX29wdGlvbiA9IChnOiBDb250YWN0WydpbnRlcmZhY2UnXSk6IENvbnRhY3RPcHRpb24gPT4gKHtcblx0XHR2YWx1ZTogQ2hhaW5zLmJlY2gzMihnLmFkZHJlc3MpLFxuXHRcdGxhYmVsOiBnLm5hbWUsXG5cdFx0Y29udGFjdDogZyxcblx0fSk7XG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9jb250YWN0cygpOiBQcm9taXNlPENvbnRhY3RPcHRpb25bXT4ge1xuXHRcdGNvbnN0IGtzX2FnZW50cyA9IGF3YWl0IEFnZW50cy5yZWFkKCk7XG5cblx0XHRjb25zdCBhX29wdGlvbnM6IENvbnRhY3RPcHRpb25bXSA9IFt7XG5cdFx0XHR2YWx1ZTogJycsXG5cdFx0XHRsYWJlbDogJycsXG5cdFx0XHRjb250YWN0OiBudWxsISxcblx0XHR9XTtcblxuXHRcdGFfY29udGFjdHMgPSBbLi4ua3NfYWdlbnRzLmNvbnRhY3RzKCR5d19mYW1pbHkpXTtcblx0XHRmb3IoY29uc3QgWywgZ19jb250YWN0XSBvZiBhX2NvbnRhY3RzKSB7XG5cdFx0XHRjb25zdCBnX29wdGlvbiA9IGNvbnRhY3RfdG9fb3B0aW9uKGdfY29udGFjdCk7XG5cblx0XHRcdGNvbnN0IHNhX2NvbnRhY3QgPSBDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKTtcblx0XHRcdGlmKHNhX2lucHV0ICYmIHNhX2NvbnRhY3QgPT09IHNhX2lucHV0KSB7XG5cdFx0XHRcdGdfaXRlbV9zZWxlY3QgPSBnX29wdGlvbjtcblx0XHRcdH1cblxuXHRcdFx0YV9vcHRpb25zLnB1c2goZ19vcHRpb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhX29wdGlvbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBzZWxlY3QoZF9ldmVudDogQ3VzdG9tRXZlbnQ8Q29udGFjdE9wdGlvbj4pIHtcblx0XHRhZGRyZXNzID0gZF9ldmVudC5kZXRhaWwudmFsdWU7XG5cdFx0ZXJyb3IgPSAnJztcblx0fVxuXG5cdGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRcdGFkZHJlc3MgPSAnJztcblx0fVxuXG5cdGxldCBzX2FjY2VwdGVkX2lucHV0ID0gJyc7XG5cdGxldCBiX2hpZGVfY3Vyc29yID0gZmFsc2U7XG5cblx0bGV0IGJfbGlzdF9vcGVuID0gZmFsc2U7XG5cblx0JDoge1xuXHRcdGJfaGlkZV9jdXJzb3IgPSBmYWxzZTtcblxuXHRcdGlmKHNfbWFudWFsX2lucHV0KSB7XG5cdFx0XHRjaGVja19tYW51YWxfaW5wdXQoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRiX2hpZGVfY3Vyc29yID0gISFzX2FjY2VwdGVkX2lucHV0O1xuXHRcdFx0c19hY2NlcHRlZF9pbnB1dCA9ICcnO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrX21hbnVhbF9pbnB1dCgpIHtcblx0XHRzX2FjY2VwdGVkX2lucHV0ID0gJyc7XG5cblx0XHRpZighJHl3X2NoYWluKSB7XG5cdFx0XHQvLyBzaG91bGQgbm90IGJlIGFibGUgdG8gZ2V0IGhlcmUgd2l0aG91dCBiZWluZyBvbiBhIGNoYWluXG5cdFx0XHRlcnJvciA9ICdObyBjaGFpbiBzZXQnO1xuXHRcdH1cblx0XHRlbHNlIGlmKCFDaGFpbnMuaXNWYWxpZEFkZHJlc3NGb3IoJHl3X2NoYWluLCBzX21hbnVhbF9pbnB1dCwgJ2FjYycpKSB7XG5cdFx0XHRlcnJvciA9ICdJbnZhbGlkIGFkZHJlc3MgZm9yIHRoaXMgY2hhaW4nO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGVycm9yID0gJyc7XG5cblx0XHRcdC8vIHNlYXJjaCBmb3IgYWRkcmVzcyBpbiBjb250YWN0c1xuXHRcdFx0Zm9yKGNvbnN0IFssIGdfY29udGFjdF0gb2YgYV9jb250YWN0cykge1xuXHRcdFx0XHQvLyBjb250YWN0IGV4aXN0c1xuXHRcdFx0XHRpZihzX21hbnVhbF9pbnB1dCA9PT0gQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcykpIHtcblx0XHRcdFx0XHQvLyBjbGVhciBmaWx0ZXIgdGV4dFxuXHRcdFx0XHRcdHNfbWFudWFsX2lucHV0ID0gJyc7XG5cdFxuXHRcdFx0XHRcdC8vIHNlbGVjdCBjb250YWN0IGluc3RlYWQgb2YgdXNpbmcgcmF3IGFkZHJlc3Ncblx0XHRcdFx0XHRnX2l0ZW1fc2VsZWN0ID0gY29udGFjdF90b19vcHRpb24oZ19jb250YWN0KTtcblxuXHRcdFx0XHRcdC8vIGNsb3NlIGxpc3Rcblx0XHRcdFx0XHRiX2xpc3Rfb3BlbiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gaGlkZSBjdXJzb3Jcblx0XHRcdFx0XHRiX2hpZGVfY3Vyc29yID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c19hY2NlcHRlZF9pbnB1dCA9IHNfbWFudWFsX2lucHV0O1xuXG5cdFx0XHQvLyBzZWxlY3QgYWRkcmVzcyBpbW1lZGlhdGVseVxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdChxcyhkbV9zZW5kZXIsICcubWFudWFsPi5hZGRyZXNzJykgYXMgSFRNTEVsZW1lbnQpLmNsaWNrKCk7XG5cdFx0XHRcdGJfbGlzdF9vcGVuID0gZmFsc2U7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdH1cblxuXHRsZXQgZG1fc2VuZGVyOiBIVE1MRWxlbWVudDtcblx0XG5cdGV4cG9ydCBsZXQgc2hvd1ZhbGlkYXRpb24gPSAwO1xuXHQkOiB7XG5cdFx0aWYoc2hvd1ZhbGlkYXRpb24pIHtcblx0XHRcdGlmKCFhZGRyZXNzKSB7XG5cdFx0XHRcdGlmKHNfbWFudWFsX2lucHV0KSB7XG5cdFx0XHRcdFx0Y2hlY2tfbWFudWFsX2lucHV0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSAnRW50ZXIgYSByZWNpcGllbnQnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKCFDaGFpbnMuaXNWYWxpZEFkZHJlc3NGb3IoJHl3X2NoYWluLCBhZGRyZXNzLCAnYWNjJykpIHtcblx0XHRcdFx0ZXJyb3IgPSAnSW52YWxpZCBhZGRyZXNzIGZvciB0aGlzIGNoYWluJztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRlcnJvciA9ICcnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmKCFhZGRyZXNzKSB7XG5cdFx0XHRlcnJvciA9ICcnO1xuXHRcdH1cblx0fVxuPC9zY3JpcHQ+XG5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJ19iYXNlLmxlc3MnO1xuXG5cdC5zZW5kZXIge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuXHRcdC5zdHlsZS1zdmVsdGUtc2VsZWN0KCk7XG5cdFx0LmZvbnQocmVndWxhciwgNDAwLCAxM3B4KTtcblxuXHRcdC0taW5wdXRQYWRkaW5nOiAxNnB4O1xuXHRcdC0tcGFkZGluZzogMCA0cHg7XG5cdFx0LS1pdGVtUGFkZGluZzogMDtcblx0XHQtLXNlbGVjdGVkSXRlbVBhZGRpbmc6IDA7XG5cblx0XHQ+aW5wdXQge1xuXHRcdFx0Jjo6YWZ0ZXIge1xuXHRcdFx0XHRjb250ZW50OiAnJztcblx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHRyaWdodDogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQ+Lmljb24ge1xuXHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdHJpZ2h0OiAwO1xuXHRcdFx0cGFkZGluZzogMTJweDtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHR9XG5cblx0XHQubGlzdENvbnRhaW5lciAuZW1wdHkge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQmLmhpZGUtY3Vyc29yIHtcblx0XHRcdC5zZWxlY3RDb250YWluZXIgaW5wdXRbdHlwZT1cInRleHRcIl0ge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG5cbjxkaXYgY2xhc3M9XCJzZW5kZXJcIiBiaW5kOnRoaXM9e2RtX3NlbmRlcn0gY2xhc3M6aGlkZS1jdXJzb3I9e2JfaGlkZV9jdXJzb3J9PlxuXHR7I2F3YWl0IGxvYWRfY29udGFjdHMoKX1cblx0XHRMb2FkaW5nIGNvbnRhY3RzLi4uXG5cdHs6dGhlbiBhX2NvbnRhY3RzfVxuXHRcdDxTZWxlY3QgaWQ9XCJyZWNpcGllbnQtc2VsZWN0XCJcblx0XHRcdHBsYWNlaG9sZGVyPVwiQWRkcmVzcyBvciBjb250YWN0XCJcblx0XHRcdGxpc3RPZmZzZXQ9ezF9XG5cdFx0XHRpc0NsZWFyYWJsZT17ISFhZGRyZXNzfVxuXHRcdFx0aXNDcmVhdGFibGU9eyEhc19hY2NlcHRlZF9pbnB1dH1cblx0XHRcdEl0ZW09e1JlY2lwaWVudFNlbGVjdEl0ZW19XG5cdFx0XHRTZWxlY3Rpb249e1JlY2lwaWVudFNlbGVjdFNlbGVjdGlvbn1cblx0XHRcdGl0ZW1zPXthX2NvbnRhY3RzfVxuXHRcdFx0dmFsdWU9e2dfaXRlbV9zZWxlY3R9XG5cdFx0XHRub09wdGlvbnNNZXNzYWdlPXsnU3RvcCB0eXBpbmcgaW4gdGhlIGFkZHJlc3MuIFxcbiBVc2UgY29weS9wYXN0ZSBpbnN0ZWFkISd9XG5cdFx0XHRiaW5kOmZpbHRlclRleHQ9e3NfbWFudWFsX2lucHV0fVxuXHRcdFx0YmluZDpsaXN0T3Blbj17Yl9saXN0X29wZW59XG5cdFx0XHRvbjpzZWxlY3Q9e3NlbGVjdH1cblx0XHRcdG9uOmNsZWFyPXtjbGVhcn1cblx0XHRcdGNvbnRhaW5lckNsYXNzZXM9e2Vycm9yPyAnaW52YWxpZCc6ICcnfVxuXHRcdC8+XG5cdHsvYXdhaXR9XG5cblxuPCEtLSBcblx0PHNwYW4gY2xhc3M9XCJpY29uXCIgY2xhc3M6dmlzaWJpbGl0eV9oaWRkZW49eyEhYWRkcmVzc30gb246Y2xpY2s9eygpID0+IHtcblx0XHQkeXdfaGVscCA9IFtcblx0XHRcdGRkKCdicicpLFxuXHRcdFx0ZGQoJ3AnLCB7fSwgW2BObyBRUiBjb2RlIHNjYW5uZXIgaW4gTVZQLiBCdXQgeW91IGNhbiB0cnkgY29weWluZyB0aGUgYWRkcmVzcyB0ZXh0IGJ5IHVzaW5nIHlvdXIgZGV2aWNlJ3MgYnVpbHQtaW4gY2FtZXJhIGFwcC5gXSksXG5cdFx0XHRkZCgnYnInKSxcblx0XHRcdGRkKCdicicpLFxuXHRcdF07XG5cdH19PlxuXHRcdHtAaHRtbCBTWF9JQ09OX1NDQU59XG5cdDwvc3Bhbj4gLS0+XG5cblx0eyNpZiBlcnJvcn1cblx0XHQ8c3BhbiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiPlxuXHRcdFx0e2Vycm9yfVxuXHRcdDwvc3Bhbj5cblx0ey9pZn1cbjwvZGl2PiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiIGxhbmc9XCJ0c1wiPlxuXG48L3NjcmlwdD5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBBY2NvdW50LCBBY2NvdW50UGF0aCB9IGZyb20gXCIjL21ldGEvYWNjb3VudFwiO1xuXHRpbXBvcnQgdHlwZSB7IEJlY2gzMiB9IGZyb20gXCIjL21ldGEvY2hhaW5cIjtcblx0aW1wb3J0IHR5cGUgeyBDb250YWN0IH0gZnJvbSBcIiMvbWV0YS9jb250YWN0XCI7XG5cdGltcG9ydCB7IEFjY291bnRzIH0gZnJvbSBcIiMvc3RvcmUvYWNjb3VudHNcIjtcblx0aW1wb3J0IHsgQWdlbnRzIH0gZnJvbSBcIiMvc3RvcmUvYWdlbnRzXCI7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gXCIjL3N0b3JlL2NoYWluc1wiO1xuXHRpbXBvcnQgeyBFdmVudHMgfSBmcm9tIFwiIy9zdG9yZS9ldmVudHNcIjtcblx0aW1wb3J0IHsgQ29pbkdlY2tvIH0gZnJvbSBcIiMvc3RvcmUvd2ViLWFwaXNcIjtcblx0aW1wb3J0IHsgZm9ybWF0X2ZpYXQgfSBmcm9tIFwiIy91dGlsL2Zvcm1hdFwiO1xuXHRpbXBvcnQgQmlnTnVtYmVyIGZyb20gXCJiaWdudW1iZXIuanNcIjtcblxuXHRpbXBvcnQgeyBnZXRDb250ZXh0LCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyBUaHJlYWRJZCB9IGZyb20gXCIuLi9kZWZcIjtcblx0aW1wb3J0IHsgeXdfY2hhaW4sIHl3X25hdmlnYXRvciwgeXdfbmV0d29ya19hY3RpdmUgfSBmcm9tIFwiLi4vbWVtXCI7XG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tIFwiLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlXCI7XG5cdGltcG9ydCBBZGRyZXNzIGZyb20gXCIuLi91aS9BZGRyZXNzLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgRmllbGQgZnJvbSBcIi4uL3VpL0ZpZWxkLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyBTY3JlZW4sIEhlYWRlciwgdHlwZSBQYWdlIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8qKlxuXHQgKiBOYXRpdmUgY29pbiBpZFxuXHQgKi9cblx0ZXhwb3J0IGxldCBjb2luOiBzdHJpbmc7XG5cdGNvbnN0IHNpX2NvaW4gPSBjb2luO1xuXG5cdGNvbnN0IGdfY29pbiA9ICR5d19jaGFpbi5jb2luc1tzaV9jb2luXTtcblxuXHRleHBvcnQgbGV0IGFjY291bnRSZWY6IEFjY291bnRQYXRoO1xuXHRsZXQgZ19hY2NvdW50OiBBY2NvdW50WydpbnRlcmZhY2UnXTtcblx0bGV0IHNhX3NlbmRlcjogQmVjaDMyLlN0cmluZztcblxuXHRleHBvcnQgbGV0IGFtb3VudDogc3RyaW5nO1xuXHRjb25zdCBzX2Ftb3VudCA9IGFtb3VudDtcblxuXHRleHBvcnQgbGV0IHJlY2lwaWVudDogQmVjaDMyLlN0cmluZztcblx0Y29uc3Qgc2FfcmVjaXBpZW50ID0gcmVjaXBpZW50O1xuXG5cdGxldCBzX3JlY2lwaWVudF90aXRsZSA9ICcnO1xuXG5cdGxldCBnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddIHwgbnVsbDtcblxuXHRleHBvcnQgbGV0IGZlZTogc3RyaW5nO1xuXHRjb25zdCBzX2ZlZSA9IGZlZTtcblxuXHQkOiBzX3RvdGFsID0gbmV3IEJpZ051bWJlcihzX2Ftb3VudCkucGx1cyhmZWUpLnRvU3RyaW5nKCk7XG5cblx0ZXhwb3J0IGxldCBtZW1vOiBzdHJpbmc7XG5cblx0bGV0IHhfd29ydGggPSAwO1xuXG5cdChhc3luYyhma19yZXNvbHZlKSA9PiB7XG5cdFx0Y29uc3Qgc2lfY29pbmdlY2tvID0gZ19jb2luLmV4dHJhPy5jb2luZ2Vja29faWQgfHwgJyc7XG5cblx0XHRpZihzaV9jb2luZ2Vja28pIHtcblx0XHRcdGNvbnN0IGhfdmVyc3VzID0gYXdhaXQgQ29pbkdlY2tvLmNvaW5zVmVyc3VzKFtzaV9jb2luZ2Vja29dLCAndXNkJywgMCk7XG5cdFx0XHR4X3dvcnRoID0gaF92ZXJzdXNbc2lfY29pbmdlY2tvXTtcblx0XHR9XG5cdH0pKCk7XG5cblx0KGFzeW5jKCkgPT4ge1xuXHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXG5cdFx0Z19hY2NvdW50ID0ga3NfYWNjb3VudHMuYXQoYWNjb3VudFJlZikhO1xuXHRcdHNhX3NlbmRlciA9IENoYWlucy5hZGRyZXNzRm9yKGdfYWNjb3VudC5wdWJrZXkpO1xuXG5cdFx0Y29uc3QgcF9jb250YWN0ID0gQWdlbnRzLnBhdGhGb3JDb250YWN0KHNhX3JlY2lwaWVudCk7XG5cdFx0Z19jb250YWN0ID0gYXdhaXQgQWdlbnRzLmdldENvbnRhY3QocF9jb250YWN0KTtcblxuXHRcdHNfcmVjaXBpZW50X3RpdGxlID0gZ19jb250YWN0Py5uYW1lIHx8ICcnO1xuXHR9KSgpO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGFwcHJvdmUoKSB7XG5cdFx0Y29uc3QgeGdfYW1vdW50ID0gQmlnSW50KG5ldyBCaWdOdW1iZXIoc19hbW91bnQpLnNoaWZ0ZWRCeShnX2NvaW4uZGVjaW1hbHMpLnRvU3RyaW5nKCkpO1xuXG5cdFx0Y29uc3QgZ19hdHRlbXB0ID0gYXdhaXQgJHl3X25ldHdvcmtfYWN0aXZlLmJhbmtTZW5kKHNhX3NlbmRlciwgc2FfcmVjaXBpZW50LCBzaV9jb2luLCB4Z19hbW91bnQsIG1lbW8pO1xuXG5cdFx0Ly8gcHJlcGVuZCBwZW5kaW5nIGV2ZW50IHRvIGV2ZW50cyBzdG9yZVxuXHRcdGF3YWl0IEV2ZW50cy5pbnNlcnQoe1xuXHRcdFx0dHlwZTogJ3BlbmRpbmcnLFxuXHRcdFx0dGltZTogRGF0ZS5ub3coKSxcblx0XHRcdGRhdGE6IGdfYXR0ZW1wdCxcblx0XHR9KTtcblxuXHRcdC8vIHJlc2V0IHBhZ2Vcblx0XHRrX3BhZ2UucmVzZXQoKTtcblxuXHRcdC8vIGFjdGl2YXRlIGhpc3RvcnkgdGhyZWFkXG5cdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKFRocmVhZElkLkhJU1RPUlkpO1xuXHR9XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQudGl0bGUge1xuXG5cdH1cblxuXHQuc3VidGl0bGUge1xuXHRcdC5mb250KHRpbnkpO1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdH1cblxuXHQuZW1wdHktbWVtbyB7XG5cdFx0LmZvbnQodGlueSk7XG5cdFx0Zm9udC1zdHlsZTogaXRhbGljO1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdH1cbjwvc3R5bGU+XG5cbjxTY3JlZW4gZGVidWc9J1NlbmROYXRpdmUnIHNsaWRlcz5cblx0PEhlYWRlciBwb3BzIGV4aXRzXG5cdFx0b246Y2xvc2U9eygpID0+IGtfcGFnZS5yZXNldCgpfVxuXHRcdHRpdGxlPSdTZW5kaW5nJ1xuXHRcdHN5bWJvbD17c2lfY29pbn1cblx0XHRzdWJ0aXRsZT17JHl3X2NoYWluLm5hbWV9XG5cdC8+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdzZW5kZXInXG5cdFx0bmFtZT0nRnJvbSdcblx0PlxuXHRcdDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxuXHRcdFx0e2dfYWNjb3VudD8ubmFtZSB8fCAnWy4uLl0nfVxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0XHR7Z19hY2NvdW50Py5leHRyYT8udG90YWxfZmlhdF9jYWNoZSB8fCAnKD8pJ31cblx0XHQ8L2Rpdj5cblx0PC9GaWVsZD5cblxuXHQ8aHI+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdyZWNpcGllbnQnXG5cdFx0bmFtZT0nVG8nXG5cdD5cblx0XHQ8ZGl2IGNsYXNzPVwidGl0bGVcIj5cblx0XHRcdHtzX3JlY2lwaWVudF90aXRsZSB8fCAnWy4uLl0nfVxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXtzYV9yZWNpcGllbnR9IC8+XG5cdFx0PC9kaXY+XG5cdDwvRmllbGQ+XG5cblx0PGhyPlxuXG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0nYW1vdW50J1xuXHRcdG5hbWU9J0Ftb3VudCdcblx0PlxuXHRcdDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxuXHRcdFx0e3NfYW1vdW50fSB7c2lfY29pbn1cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0eyNpZiB4X3dvcnRofVxuXHRcdFx0XHR7Zm9ybWF0X2ZpYXQobmV3IEJpZ051bWJlcihzX2Ftb3VudCkudGltZXMoeF93b3J0aCkudG9OdW1iZXIoKSl9XG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdD1bLi4uXVxuXHRcdFx0ey9pZn1cblx0XHQ8L2Rpdj5cblx0PC9GaWVsZD5cblxuXHQ8aHI+XG5cdFxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2ZlZS1yZXZpZXcnXG5cdFx0bmFtZT0nRmVlJ1xuXHQ+XG5cdFx0PGRpdiBjbGFzcz1cInRpdGxlXCI+XG5cdFx0XHR7c19mZWV9IHtzaV9jb2lufVxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0XHR7I2lmIHhfd29ydGh9XG5cdFx0XHRcdHtmb3JtYXRfZmlhdChuZXcgQmlnTnVtYmVyKHNfZmVlKS50aW1lcyh4X3dvcnRoKS50b051bWJlcigpKX1cblx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0PVsuLi5dXG5cdFx0XHR7L2lmfVxuXHRcdDwvZGl2PlxuXHQ8L0ZpZWxkPlxuXG5cdDxocj5cblx0XG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0ndG90YWwnXG5cdFx0bmFtZT0nVG90YWwnXG5cdD5cblx0XHQ8ZGl2IGNsYXNzPVwidGl0bGVcIj5cblx0XHRcdHtzX3RvdGFsIHx8ICdbLi4uXSd9IHtzaV9jb2lufVxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0XHR7I2lmIHhfd29ydGh9XG5cdFx0XHRcdHtmb3JtYXRfZmlhdChuZXcgQmlnTnVtYmVyKHNfdG90YWwpLnRpbWVzKHhfd29ydGgpLnRvTnVtYmVyKCkpfVxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ9Wy4uLl1cblx0XHRcdHsvaWZ9XG5cdFx0PC9kaXY+XG5cdDwvRmllbGQ+XG5cblx0PGhyPlxuXHRcblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdtZW1vJ1xuXHRcdG5hbWU9J01lbW8nXG5cdD5cblx0XHR7I2lmIG1lbW99XG5cdFx0XHQ8dGV4dGFyZWEgZGlzYWJsZWQ+e21lbW99PC90ZXh0YXJlYT5cblx0XHR7OmVsc2V9XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImVtcHR5LW1lbW9cIj4oZW1wdHkpPC9zcGFuPlxuXHRcdHsvaWZ9XG5cdDwvRmllbGQ+XG5cblxuXHQ8QWN0aW9uc0xpbmUgYmFjayBjb25maXJtPXtbJ0FwcHJvdmUnLCAoKSA9PiBhcHByb3ZlKCldfSAvPlxuXG48L1NjcmVlbj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGdldENvbnRleHQsIG9uRGVzdHJveSB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IHNsaWRlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXG5cdGltcG9ydCB7XG5cdFx0eXdfYWNjb3VudCxcblx0XHR5d19hY2NvdW50X3JlZixcblx0XHR5d19jaGFpbixcblx0XHR5d19jaGFpbl9yZWYsXG5cdFx0eXdfbmV0d29ya19hY3RpdmUsXG5cdFx0eXdfb3duZXIsXG5cdFx0eXdfc2VuZF9hc3NldCxcblx0XHQvLyB5d19hc3NldF9zZW5kLFxuXHRcdC8vIHl3X2hvbGRpbmdfc2VuZCxcblx0fSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCBTWF9JQ09OX1BFUlNPTkFMIGZyb20gJyMvaWNvbi9hY2NvdW50X2JveC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ09OVFJBQ1QgZnJvbSAnIy9pY29uL2FuYWx5dGljcy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fTE9BRElORyBmcm9tICcjL2ljb24vZG9udXRfbGFyZ2Uuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0lORk8gZnJvbSAnIy9pY29uL2luZm8uc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0RST1BET1dOIGZyb20gJyMvaWNvbi9kcm9wLWRvd24uc3ZnP3Jhdyc7XG5cblx0aW1wb3J0IEFzc2V0U2VsZWN0IGZyb20gJyMjL3VpL0Fzc2V0U2VsZWN0LnN2ZWx0ZSc7XG5cdGltcG9ydCBBbW91bnRJbnB1dCBmcm9tICcjIy91aS9BbW91bnRJbnB1dC5zdmVsdGUnO1xuXHRpbXBvcnQgQ2hlY2tib3hGaWVsZCBmcm9tICcjIy91aS9DaGVja2JveEZpZWxkLnN2ZWx0ZSc7XG5cdGltcG9ydCBIZWFkZXIgZnJvbSAnIyMvdWkvSGVhZGVyLnN2ZWx0ZSc7XG5cdGltcG9ydCBGaWVsZCBmcm9tICcjIy91aS9GaWVsZC5zdmVsdGUnO1xuXG5cdC8vIGltcG9ydCBFeGVjdXRlIGZyb20gJy4vRXhlY3V0ZS5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IEFjY291bnQsIEFjY291bnRQYXRoIH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXG5cdGltcG9ydCB7IFNjcmVlbiwgdHlwZSBQYWdlIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cdGltcG9ydCB0eXBlIHsgVG9rZW4gfSBmcm9tICcjL21ldGEvdG9rZW4nO1xuXHRpbXBvcnQgeyBFbnRpdGllcyB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgU2VuZGVyU2VsZWN0IGZyb20gJy4uL3VpL1NlbmRlclNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgUmVjaXBpZW50U2VsZWN0IGZyb20gJy4uL3VpL1JlY2lwaWVudFNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IENoYWluLCBFbnRpdHlQYXRoLCBOYXRpdmVDb2luIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IHR5cGUgeyBDb250YWN0LCBDb250YWN0UGF0aCB9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHsgc3Vic2NyaWJlX3N0b3JlIH0gZnJvbSAnIy9zdG9yZS9fYmFzZSc7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHsgZm9sZCwgb2ZlIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IENvaW5HZWNrbyB9IGZyb20gJyMvc3RvcmUvd2ViLWFwaXMnO1xuXHRpbXBvcnQgeyBmb3JtYXRfYW1vdW50LCBmb3JtYXRfZmlhdCB9IGZyb20gJyMvdXRpbC9mb3JtYXQnO1xuXHRpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cdGltcG9ydCB7IFhUX01JTlVURVMgfSBmcm9tICcjL3NoYXJlL2NvbnN0YW50cyc7XG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcuLi91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuaW1wb3J0IFNlbmROYXRpdmUgZnJvbSAnLi9TZW5kTmF0aXZlLnN2ZWx0ZSc7XG5cblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0LyoqXG5cdCAqIFdoaWNoIGFjY291bnQgdG8gaW5pdGlhdGUgc2VuZCBmcm9tXG5cdCAqL1xuXHRleHBvcnQgbGV0IHNlbmRlcjogQWNjb3VudFsnaW50ZXJmYWNlJ10gPSAkeXdfYWNjb3VudDtcblx0bGV0IHBfYWNjb3VudDogQWNjb3VudFBhdGggPSAkeXdfYWNjb3VudF9yZWY7XG5cblx0LyoqXG5cdCAqIE5hdGl2ZSBjb2luIHN5bWJvbCB0byB1c2UgZm9yIHRoZSB0cmFuc2ZlclxuXHQgKi9cblx0ZXhwb3J0IGxldCBuYXRpdmU6IGtleW9mIHR5cGVvZiAkeXdfY2hhaW4uY29pbnMgPSBPYmplY3Qua2V5cygkeXdfY2hhaW4uY29pbnMpWzBdO1xuXHRsZXQgc2lfbmF0aXZlID0gbmF0aXZlO1xuXG5cdC8qKlxuXHQgKiBUb2tlbiB0byB1c2UgZm9yIHRyYW5zZmVyIChpbnN0ZWFkIG9mIG5hdGl2ZSBjb2luKVxuXHQgKi9cblx0ZXhwb3J0IGxldCB0b2tlbjogVG9rZW5bJ2ludGVyZmFjZSddIHwgbnVsbCA9IG51bGw7XG5cdGxldCBnX3Rva2VuID0gdG9rZW47XG5cblxuXHQvKipcblx0ICogQWRkcmVzcyBvZiBpbml0aWFsIHJlY2VpdmVyXG5cdCAqL1xuXHRleHBvcnQgbGV0IHJlY2lwaWVudCA9ICcnO1xuXHRsZXQgc2FfcmVjaXBpZW50ID0gcmVjaXBpZW50O1xuXG5cblx0bGV0IHBfYXNzZXQ6IEVudGl0eVBhdGggfCAnJyA9IHNpX25hdGl2ZVxuXHRcdD8gRW50aXRpZXMuaG9sZGluZ1BhdGhGb3IoJHl3X293bmVyLCBzaV9uYXRpdmUpXG5cdFx0OiAnJztcblx0XHQvLyA6IEVudGl0aWVzLnBhdGhGcm9tKGdfdG9rZW4pO1xuXG5cblx0Ly8gcmVhY3RpdmVseSBhc3NpZ24gdGhlIGNvaW4gc3RydWN0IGZvciB0aGUgbmF0aXZlIGFzc2V0XG5cdCQ6IGdfY29pbiA9IHBfYXNzZXQgJiYgJ2hvbGRpbmcnID09PSBFbnRpdGllcy5wYXJzZUVudGl0eVBhdGgocF9hc3NldCk/LnR5cGUgJiYgc2lfbmF0aXZlPyAkeXdfY2hhaW4uY29pbnM/LltzaV9uYXRpdmVdOiBudWxsO1xuXHRcblx0Ly8gcmVhY3RpdmVseSBhc3NpZ24gdGhlIHRva2VuJ3MgcGF0aFxuXHQkOiBwX3Rva2VuID0gcF9hc3NldCAmJiAndG9rZW4nID09PSBFbnRpdGllcy5wYXJzZUVudGl0eVBhdGgocF9hc3NldCk/LnR5cGUgJiYgZ190b2tlbj8gRW50aXRpZXMucGF0aEZyb20oZ190b2tlbik6ICcnO1xuXG5cblx0Ly8gY2FjaGUgb2YgY29udGFjdHNcblx0bGV0IGhfY29udGFjdHM6IFJlY29yZDxDb250YWN0UGF0aCwgQ29udGFjdFsnaW50ZXJmYWNlJ10+O1xuXG5cdC8vIGFkZHJlc3MgdG8gY29udGFjdCBsb29rdXAgY2FjaGVcblx0bGV0IGhfYWRkcl90b19jb250YWN0OiBSZWNvcmQ8Q2hhaW4uQmVjaDMyU3RyaW5nLCBDb250YWN0UGF0aD47XG5cblx0Ly8gYXNzZXQgc3ltYm9sXG5cdCQ6IHNfc3ltYm9sID0gc2lfbmF0aXZlIHx8IGdfdG9rZW4/LnN5bWJvbCB8fCAnJztcblxuXG5cblxuXHRsZXQgYl9idXN5X2FnZW50cyA9IGZhbHNlO1xuXHRhc3luYyBmdW5jdGlvbiByZWxvYWRfYWdlbnRzKGJfaW5pdD1mYWxzZSkge1xuXHRcdC8vIGFscmVhZHkgYnVzeSByZWxvYWRpbmdcblx0XHRpZihiX2J1c3lfYWdlbnRzKSByZXR1cm47XG5cblx0XHQvLyBub3cgaXQncyBidXN5XG5cdFx0Yl9idXN5X2FnZW50cyA9IHRydWU7XG5cblx0XHQvLyBsb2FkIGFnZW50cyBzdG9yZVxuXHRcdGNvbnN0IGtzX2FnZW50cyA9IGF3YWl0IEFnZW50cy5yZWFkKCk7XG5cblx0XHQvLyByZWFkIGNvbnRhY3QgZW50cmllc1xuXHRcdGNvbnN0IGFfY29udGFjdHMgPSBbLi4ua3NfYWdlbnRzLmNvbnRhY3RzKCldO1xuXG5cdFx0Ly8gcmVwbGFjZSBjYWNoZVxuXHRcdGhfY29udGFjdHMgPSBvZmUoYV9jb250YWN0cyk7XG5cblx0XHQvLyByZXBsYWNlIGFkZHJlc3MgbG9va3VwIGNhY2hlXG5cdFx0aF9hZGRyX3RvX2NvbnRhY3QgPSBmb2xkKGFfY29udGFjdHMsIChbcF9jb250YWN0LCBnX2NvbnRhY3RdKSA9PiAoe1xuXHRcdFx0W0NoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MpXTogcF9jb250YWN0LFxuXHRcdH0pKTtcblxuXHRcdC8vIG5vIGxvbmdlciBidXN5XG5cdFx0Yl9idXN5X2FnZW50cyA9IGZhbHNlO1xuXHR9XG5cblx0Ly8gc3Vic2NyaXB0aW9uc1xuXHR7XG5cdFx0Ly8gcmVsb2FkIGFnZW50cyB3aGVuIGFnZW50cyBzdG9yZSB1cGRhdGVzXG5cdFx0Y29uc3QgZl91bnN1Yl9hZ2VudHMgPSBzdWJzY3JpYmVfc3RvcmUoJ2FnZW50cycsIHJlbG9hZF9hZ2VudHMpO1xuXG5cdFx0Ly8gcmVsb2FkIGFnZW50cyB3aGVuIGNoYWluIGNoYW5nZXNcblx0XHRjb25zdCBmX3Vuc3ViX2NoYWluID0geXdfY2hhaW4uc3Vic2NyaWJlKHJlbG9hZF9hZ2VudHMgYXMgVm9pZEZ1bmN0aW9uKTtcblxuXHRcdC8vIHVuc3Vic2NyaWJlIHdoZW4gc2NyZWVuIGlzIGRlc3Ryb3llZFxuXHRcdG9uRGVzdHJveSgoKSA9PiB7XG5cdFx0XHRmX3Vuc3ViX2FnZW50cygpO1xuXHRcdFx0Zl91bnN1Yl9jaGFpbigpO1xuXHRcdH0pO1xuXHR9XG5cblx0JDoge1xuXHRcdGNvbnNvbGUubG9nKHtcblx0XHRcdHNpX25hdGl2ZSxcblx0XHRcdGdfY29pbixcblx0XHRcdHBfYXNzZXQsXG5cdFx0XHRwX3Rva2VuLFxuXHRcdFx0Z190b2tlbixcblx0XHR9KTtcblx0fVxuXG5cdC8vIHJlYWN0aXZlbHkgY29tcHV0ZSB0aGUgYmFsYW5jZSBvZiB0aGUgc2VsZWN0ZWQgYXNzZXRcblx0bGV0IHlnX2JhbGFuY2U6IEJpZ051bWJlciB8IG51bGwgPSBudWxsO1xuXHQkOiBzX2JhbGFuY2UgPSB5Z19iYWxhbmNlPyBmb3JtYXRfYW1vdW50KHlnX2JhbGFuY2Uuc2hpZnRlZEJ5KC0oZ19jb2luIHx8IGdfdG9rZW4pIS5kZWNpbWFscykudG9OdW1iZXIoKSk6ICcnO1xuXHQkOiB7XG5cdFx0Ly8gcmVhY3QgdG8gYWNjb3VudCBhbmQgYXNzZXQgY2hhbmdlc1xuXHRcdGlmKCR5d19hY2NvdW50ICYmIHBfYXNzZXQpIHtcblx0XHRcdHlnX2JhbGFuY2UgPSBudWxsO1xuXG5cdFx0XHQvLyBnbyBhc3luY1xuXHRcdFx0cXVldWVNaWNyb3Rhc2soYXN5bmMoKSA9PiB7XG5cdFx0XHRcdC8vIGluZGljYXRlIGxvYWRpbmcgc3RhdGVcblx0XHRcdFx0c19iYWxhbmNlID0gJ1suLi5dJztcblxuXHRcdFx0XHQvLyBzdGFydCB3aXRoIHRoZSBjYWNoZWQgYmFsYW5jZSBpZiBpdCBleGlzdHNcblx0XHRcdFx0Y29uc3QgZ19jYWNoZWQgPSAkeXdfbmV0d29ya19hY3RpdmUuY2FjaGVkQmFsYW5jZSgkeXdfb3duZXIsIHNpX25hdGl2ZSk7XG5cdFx0XHRcdGlmKGdfY2FjaGVkICYmIGdfY2FjaGVkLnRpbWVzdGFtcCA+IERhdGUubm93KCkgLSAoNSAqIFhUX01JTlVURVMpKSB7XG5cdFx0XHRcdFx0eWdfYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoZ19jYWNoZWQuZGF0YS5hbW91bnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZ2V0IHRoZSBsYXRlc3QgYmFsYW5jZVxuXHRcdFx0XHRjb25zdCBnX2J1bmRsZSA9IGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5iYW5rQmFsYW5jZSgkeXdfb3duZXIsIHNpX25hdGl2ZSk7XG5cdFx0XHRcdGlmKGdfYnVuZGxlKSB7XG5cdFx0XHRcdFx0eWdfYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoZ19idW5kbGUuYmFsYW5jZS5hbW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXG5cdC8vIGlucHV0IGFtb3VudCB1c2VyIGludGVuZHMgdG8gc2VuZFxuXHRsZXQgc19hbW91bnQgPSAnJztcblxuXHQvLyBhcHBseSB0aGUgbWF4aW11bSBhbW91bnQgdGhlIHVzZXIgY2FuIHBvc3NpYmx5IHNlbmRcblx0ZnVuY3Rpb24gdXNlX21heCgpIHtcblx0XHRzX2Ftb3VudCA9IHNfYmFsYW5jZTtcblxuXHRcdC8vIHRha2UgYXdheSBmcm9tIGdhcyBmZWVcblx0XHRpZihnX2NvaW4pIHtcblx0XHRcdHNfYW1vdW50ID0gbmV3IEJpZ051bWJlcihzX2Ftb3VudCkubWludXMoeF9mZWUpLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0Y19zaG93X3ZhbGlkYXRpb25zKys7XG5cdH1cblxuXHQvLyByZWFjdGl2ZWx5IGluZGljYXRlIHdoZXRoZXIgdGhlIG1heCBpcyBjdXJyZW50bHkgYmVpbmcgdXNlZFxuXHQkOiBiX3VzaW5nX21heCA9IHNfYW1vdW50ID09PSBzX2JhbGFuY2U7XG5cblx0Ly8gJDoge1xuXHQvLyBcdGlmKGdfdG9rZW4gJiYgRW50aXRpZXMucGF0aEZyb20oZ190bykgIT09IHBfZW50aXR5KSB7XG5cdC8vIFx0XHRzX2Ftb3VudCA9ICcnO1xuXHQvLyBcdFx0Y19zaG93X3ZhbGlkYXRpb25zID0gMDtcblx0Ly8gXHRcdHBfZW50aXR5ID0gZ190b2tlbi5pcmk7XG5cdC8vIFx0fVxuXHQvLyB9XG5cblxuXG5cdC8vIHJlYWN0aXZlbHkgYXNzaWduIHRoZSBjb2luZ2Vja28gaWQgZnJvbSB0aGUgYXNzZXQgc3RydWN0XG5cdCQ6IHNpX2NvaW5nZWNrbyA9IChnX3Rva2VuIHx8IGdfY29pbik/LmV4dHJhPy5jb2luZ2Vja29faWQgfHwgJyc7XG5cblx0Ly8gcmVhY3RpdmVseSBmZXRjaCB0aGUgd29ydGggb2YgdGhlIGFzc2V0XG5cdGxldCB4X3dvcnRoOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblx0bGV0IHNfd29ydGggPSAnJztcblx0Y29uc3Qgc2lfdmVyc3VzID0gJ3VzZCc7XG5cdCQ6IHtcblx0XHQvLyBjb2luZ2Vja28gaWQgaXMgc2V0XG5cdFx0aWYoc2lfY29pbmdlY2tvKSB7XG5cdFx0XHQvLyBpbmRpY2F0ZSBsb2FkaW5nIHN0YXRlXG5cdFx0XHRzX3dvcnRoID0gJ1suLi5dJztcblxuXHRcdFx0Ly8gZ28gYXN5bmNcblx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0Ly8gbG9hZCB0aGUgYXNzZXQncyB3b3J0aCBmcm9tIGNvaW5nZWNrb1xuXHRcdFx0XHRjb25zdCBoX3ZlcnN1cyA9IGF3YWl0IENvaW5HZWNrby5jb2luc1ZlcnN1cyhbc2lfY29pbmdlY2tvXSBhcyBzdHJpbmdbXSwgc2lfdmVyc3VzKTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgdGhlIGZpYXQgZGlzcGxheVxuXHRcdFx0XHR4X3dvcnRoID0gaF92ZXJzdXNbc2lfY29pbmdlY2tvXTtcblx0XHRcdFx0aWYoJ251bWJlcicgPT09IHR5cGVvZiB4X3dvcnRoKSB7XG5cdFx0XHRcdFx0c193b3J0aCA9IGZvcm1hdF9maWF0KHhfd29ydGgsIHNpX3ZlcnN1cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc2V0IGVycm9yIGluZGljYXRpb25cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c193b3J0aCA9ICcoPyknO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSgpO1xuXHRcdH1cblx0XHQvLyBkb24ndCBkaXNwbGF5IGFueXRoaW5nXG5cdFx0ZWxzZSB7XG5cdFx0XHRzX3dvcnRoID0gJyc7XG5cdFx0fVxuXHR9XG5cblxuXHRsZXQgeF9mZWUgPSAwLjAxO1xuXHRcblx0JDogc19mZWVfZmlhdCA9ICdudW1iZXInID09PSB0eXBlb2YgeF93b3J0aD8gZm9ybWF0X2ZpYXQoeF9mZWUgKiB4X3dvcnRoLCAndXNkJyk6ICcnO1xuXG5cdFxuXHRcblx0Ly8gLy8gXG5cdC8vIGlmKCR5d19hc3NldF9zZW5kKSB7XG5cdC8vIFx0JHl3X2NoYWluX3JlZiA9ICR5d19hc3NldF9zZW5kLmNoYWluUmVmO1xuXHQvLyB9XG5cblx0Y29uc3QgSF9BRERSRVNTX1RZUEVTID0ge1xuXHRcdG5vbmU6IHtcblx0XHRcdGljb246ICc8c3ZnPjwvc3ZnPicsXG5cdFx0XHR0ZXh0OiAnJyxcblx0XHR9LFxuXG5cdFx0dW5rbm93bjoge1xuXHRcdFx0aWNvbjogU1hfSUNPTl9MT0FESU5HLFxuXHRcdFx0dGV4dDogJ0RldGVybWluaW5nIGFkZHJlc3MgdHlwZS4uLicsXG5cdFx0fSxcblxuXHRcdHBlcnNvbmFsOiB7XG5cdFx0XHRpY29uOiBTWF9JQ09OX1BFUlNPTkFMLFxuXHRcdFx0dGV4dDogJ1BlcnNvbmFsIGFkZHJlc3MnLFxuXHRcdH0sXG5cblx0XHRjb250cmFjdDoge1xuXHRcdFx0aWNvbjogU1hfSUNPTl9DT05UUkFDVCxcblx0XHRcdHRleHQ6ICdDb250cmFjdCBhZGRyZXNzJyxcblx0XHR9LFxuXHR9IGFzIGNvbnN0O1xuXG5cdGxldCBzaV9hZGRyZXNzX3R5cGU6IGtleW9mIHR5cGVvZiBIX0FERFJFU1NfVFlQRVMgPSAnbm9uZSc7XG5cdCQ6IGdfYWRkcmVzc190eXBlID0gSF9BRERSRVNTX1RZUEVTW3NpX2FkZHJlc3NfdHlwZV07XG5cblxuXG5cdCQ6IHtcblx0XHRpZighc2FfcmVjaXBpZW50KSB7XG5cdFx0XHRzaV9hZGRyZXNzX3R5cGUgPSAnbm9uZSc7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2lfYWRkcmVzc190eXBlID0gJ3Vua25vd24nO1xuXG5cdFx0XHQoYXN5bmMoKSA9PiB7XG5cdFx0XHRcdGlmKGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5pc0NvbnRyYWN0KHNhX3JlY2lwaWVudCkpIHtcblx0XHRcdFx0XHRzaV9hZGRyZXNzX3R5cGUgPSAnY29udHJhY3QnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHNpX2FkZHJlc3NfdHlwZSA9ICdwZXJzb25hbCc7XG5cdFx0XHRcdH1cblx0XHRcdH0pKCk7XG5cdFx0fVxuXHR9XG5cblxuXG5cblx0bGV0IGJfbWVtb19leHBhbmRlZCA9IGZhbHNlO1xuXHRsZXQgc19tZW1vID0gJyc7XG5cblx0bGV0IGJfc3VibWl0dGVkID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gc3VibWl0KCkge1xuXHRcdGlmKCFiX2Zvcm1fdmFsaWQpIHtcblx0XHRcdGNfc2hvd192YWxpZGF0aW9ucysrO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmKGJfc3VibWl0dGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdGJfc3VibWl0dGVkID0gdHJ1ZTtcblxuXHRcdFx0aWYoc2lfbmF0aXZlKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBTZW5kTmF0aXZlLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRhY2NvdW50UmVmOiBwX2FjY291bnQsXG5cdFx0XHRcdFx0XHRjb2luOiBzaV9uYXRpdmUsXG5cdFx0XHRcdFx0XHRyZWNpcGllbnQ6IHNhX3JlY2lwaWVudCxcblx0XHRcdFx0XHRcdGFtb3VudDogc19hbW91bnQsXG5cdFx0XHRcdFx0XHRtZW1vOiBzX21lbW8sXG5cdFx0XHRcdFx0XHRmZWU6IHhfZmVlKycnLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIGtfcGFnZS5wdXN5d19zZW5kX2Fzc2V0XG5cdFx0XHRcdC8vIFx0Y3JlYXRvcjogRXhlY3V0ZSxcblx0XHRcdFx0Ly8gXHRwcm9wczoge1xuXHRcdFx0XHQvLyBcdFx0Y29udHJhY3Q6ICR5d19hc3NldF9zZW5kPy5hZGRyZXNzLFxuXHRcdFx0XHQvLyBcdFx0c25pcDIwOiB5d19zZW5kX2Fzc2V0XG5cdFx0XHRcdC8vIFx0XHRcdHRyYW5zZmVyOiB7XG5cdFx0XHRcdC8vIFx0XHRcdFx0cmVjaXBpZW50OiBzYV9yZWNlaXZlcixcblx0XHRcdFx0Ly8gXHRcdFx0XHRhbW91bnQ6ICR5d19hc3NldF9zZW5kPy5kZW5vbUZyb21TdHJpbmcoc19hbW91bnQpIHx8ICcwJyxcblx0XHRcdFx0Ly8gXHRcdFx0fSxcblx0XHRcdFx0Ly8gXHRcdH0sXG5cdFx0XHRcdC8vIFx0fSxcblx0XHRcdFx0Ly8gfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bGV0IGNfc2hvd192YWxpZGF0aW9ucyA9IDA7XG5cblx0bGV0IGJfY2hlY2tlZF9zYXZlX2NvbnRhY3QgPSBmYWxzZTtcblx0bGV0IGJfZGVhZCA9IGZhbHNlO1xuXG5cblx0bGV0IHNfZXJyX3JlY2lwaWVudCA9ICcnO1xuXHRsZXQgc19lcnJfYW1vdW50ID0gJyc7XG5cblx0JDogYl9uZXdfYWRkcmVzcyA9IHNhX3JlY2lwaWVudCAmJiBoX2FkZHJfdG9fY29udGFjdCAmJiAhKHNhX3JlY2lwaWVudCBpbiBoX2FkZHJfdG9fY29udGFjdCk7XG5cblxuXHRjb25zdCBSX0NPTlRBQ1RfTkFNRSA9IC9eXFxTLnswLDEwMjN9JC87XG5cdFxuXHRsZXQgc19uZXdfY29udGFjdCA9ICcnO1xuXHQkOiBzX2Vycl9uZXdfY29udGFjdCA9IGJfY2hlY2tlZF9zYXZlX2NvbnRhY3QgJiYgKGNfc2hvd192YWxpZGF0aW9ucyB8fCB0cnVlKVxuXHRcdD8gc19uZXdfY29udGFjdFxuXHRcdFx0PyBSX0NPTlRBQ1RfTkFNRS50ZXN0KHNfbmV3X2NvbnRhY3QpXG5cdFx0XHRcdD8gJydcblx0XHRcdFx0OiBzX25ld19jb250YWN0Lmxlbmd0aCA+IDEwMjRcblx0XHRcdFx0XHQ/ICdUaGF0IG5hbWUgaXMgd2F5IHRvbyBsb25nJ1xuXHRcdFx0XHRcdDogJ0Nhbm5vdCBiZWdpbiB3aXRoIHNwYWNlJ1xuXHRcdFx0OiAnRW50ZXIgYSBjb250YWN0IG5hbWUgdG8gc2F2ZSBuZXcgYWRkcmVzcydcblx0XHQ6ICcnO1xuXG5cdCQ6IHtcblx0XHRpZihiX2NoZWNrZWRfc2F2ZV9jb250YWN0ICYmICFjX3Nob3dfdmFsaWRhdGlvbnMpIHtcblx0XHRcdHNfZXJyX25ld19jb250YWN0ID0gJyc7XG5cdFx0fVxuXHR9XG5cblx0JDogYl9mb3JtX3ZhbGlkID0gKHNhX3JlY2lwaWVudFxuXHRcdCYmIHNfYW1vdW50XG5cdFx0JiYgIXNfZXJyX3JlY2lwaWVudFxuXHRcdCYmICFzX2Vycl9hbW91bnRcblx0XHQmJiAoIWJfbmV3X2FkZHJlc3MgfHwgIWJfY2hlY2tlZF9zYXZlX2NvbnRhY3QgfHwgKHNfbmV3X2NvbnRhY3QgJiYgIXNfZXJyX25ld19jb250YWN0KSlcblx0KSB8fCBmYWxzZTtcblxuXHQkOiB7XG5cdFx0Y29uc29sZS5sb2coe1xuXHRcdFx0dG86IHNhX3JlY2lwaWVudCxcblx0XHRcdHNfYW1vdW50LFxuXHRcdFx0c19lcnJfcmVjaXBpZW50LFxuXHRcdFx0c19lcnJfYW1vdW50LFxuXHRcdH0pO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBpbnB1dF9uZXdfY29udGFjdChkX2V2ZW50OiBFdmVudCkge1xuXHRcdHNfbmV3X2NvbnRhY3QgPSAoZF9ldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblxuXHRAa2V5ZnJhbWVzIHNwaW4ge1xuXHRcdGZyb20ge1xuXHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdFx0fVxuXHRcdHRvIHtcblx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG5cdFx0fVxuXHR9XG5cblx0I2ZpZWxkLXJlY2lwaWVudC1zdGF0dXMge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0bWFyZ2luLXRvcDogLTEycHg7XG5cdFx0XHRwYWRkaW5nLWxlZnQ6IDZweDtcblx0XHR9XG5cblx0XHQuc3RhdHVzIHtcblx0XHRcdDpnbG9iYWwoJi51bmtub3duPi5pY29uKSB7XG5cdFx0XHRcdGFuaW1hdGlvbjogc3BpbiAxcyBsaW5lYXIgaW5maW5pdGU7XG5cdFx0XHR9XG5cdFx0XHQ6Z2xvYmFsKCYuY29udHJhY3Q+Lmljb24pIHtcblx0XHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xuXHRcdFx0fVxuXHRcdFx0Omdsb2JhbCgmLmNvbnRyYWN0Pi5pY29uKSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQuc3RhdHVzIHtcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItZ3JheW1lZCk7XG5cblx0XHQ+KiB7XG5cdFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdH1cblxuXHRcdD4uaWNvbiB7XG5cdFx0XHQtLXByb3h5LWljb24tZGlhbWV0ZXI6IDIwcHg7XG5cdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWdyYXltZWQpO1xuXG5cdFx0XHQ6Z2xvYmFsKHN2Zykge1xuXHRcdFx0XHR3aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdGhlaWdodDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pi50ZXh0IHtcblx0XHRcdC5mb250KHRpbnkpO1xuXHRcdH1cblx0fVxuXG5cblx0I2ZpZWxkLWJhbGFuY2Uge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0bWFyZ2luLXRvcDogLTEycHg7XG5cdFx0fVxuXHR9XG5cblx0LmJhbGFuY2UtbGluZSB7XG5cdFx0LmZvbnQodGlueSwgQHNpemU6IDEycHgsIEB3ZWlnaHQ6IDMwMCk7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cblx0XHQ+LmJhbGFuY2Uge1xuXHRcdFx0Pi5sYWJlbCB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHR9XG5cblx0XHRcdD4uYW1vdW50IHtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC5mZWUtZmlhdCB7XG5cdFx0LmZvbnQodGlueSk7XG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0fVxuXG5cdCNmaWVsZC1mZWUge1xuXHRcdC5maWVsZC12YWx1ZSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZmxleDogMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQubWFudWFsLWZlZSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZmxleDogMjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQjZmllbGQtbWFudWFsLWZlZSB7XG5cdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRtYXJnaW4tdG9wOiAtMTJweDtcblx0XHR9XG5cdH1cblxuXHQubWFudWFsLWZlZSB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGdhcDogMC41ZW07XG5cblx0XHQ+Lmljb24uaW5mbyB7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDE4cHg7XG5cdFx0XHRwYWRkaW5nOiAycHg7XG5cdFx0fVxuXHR9XG5cblx0Lm1lbW8ge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRnYXA6IDAuNzVlbTtcblxuXHRcdC50aXRsZSB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0Z2FwOiA0cHg7XG5cdFx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0XHRcdC5pY29uIHtcblx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyMnB4O1xuXHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0fVxuXHRcblx0XHRcdD4uZGlzY2xhaW1lciB7XG5cdFx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItY2F1dGlvbik7XG5cdFx0XHRcdHJpZ2h0OiAwO1xuXHRcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdGJvdHRvbTogMC41ZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmRyb3Bkb3duLmljb24ge1xuXHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMzAwbXMgdmFyKC0tZWFzZS1vdXQtcXVhZCk7XG5cdFx0fVxuXG5cdFx0Ji5leHBhbmRlZCB7XG5cdFx0XHQuZHJvcGRvd24uaWNvbiB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKC0xODBkZWcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5pbnB1dCB7XG5cdFx0XHR0ZXh0YXJlYSB7XG5cdFx0XHRcdHJlc2l6ZTogdmVydGljYWw7XG5cdFx0XHRcdG1pbi1oZWlnaHQ6IDEwLjc1ZXg7XG5cdFx0XHRcdG1heC1oZWlnaHQ6IDQwZXg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Lm5ldy1hZGRyZXNzIHtcblx0XHRtYXJnaW4tdG9wOiAxMnB4O1xuXHR9XG5cblx0LmRpc2FibGVkLmxpbmsge1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0Zm9udC1zdHlsZTogaXRhbGljO1xuXHRcdHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xuXHR9XG48L3N0eWxlPlxuXG5cbjxTY3JlZW4gZm9ybSBzbGlkZXMgb246c3VibWl0PXsoZF9zdWJtaXQpID0+IHtcblx0ZF9zdWJtaXQucHJldmVudERlZmF1bHQoKTtcbn19PlxuXHQ8SGVhZGVyIHBvcHNcblx0XHR0aXRsZT17Z190b2tlbj8gJ1RyYW5zZmVycmluZyc6ICdTZW5kaW5nJ31cblx0XHRzeW1ib2w9e2dfdG9rZW4/IGdfdG9rZW4uc3ltYm9sOiAnJ31cblx0XHRzdWJ0aXRsZT17JHl3X2NoYWluPy5uYW1lIHx8ICc/J31cblx0Lz5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J3NlbmRlci1zZWxlY3QnXG5cdFx0bmFtZT0nRnJvbSdcblx0PlxuXHRcdDxTZW5kZXJTZWxlY3Rcblx0XHRcdGJpbmQ6YWNjb3VudFJlZj17cF9hY2NvdW50fVxuXHRcdFx0Lz5cblx0PC9GaWVsZD5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J3JlY2lwaWVudC1zZWxlY3QnXG5cdFx0bmFtZT0nVG8nXG5cdD5cblx0XHQ8UmVjaXBpZW50U2VsZWN0XG5cdFx0XHRiaW5kOmVycm9yPXtzX2Vycl9yZWNpcGllbnR9XG5cdFx0XHRiaW5kOmFkZHJlc3M9e3NhX3JlY2lwaWVudH1cblx0XHRcdHNob3dWYWxpZGF0aW9uPXtjX3Nob3dfdmFsaWRhdGlvbnN9XG5cdFx0Lz5cblx0PC9GaWVsZD5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J3JlY2lwaWVudC1zdGF0dXMnXG5cdFx0bmFtZT0nJ1xuXHQ+XG5cdFx0PHNwYW4gY2xhc3M9XCJzdGF0dXMge3NpX2FkZHJlc3NfdHlwZX1cIj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHR7QGh0bWwgZ19hZGRyZXNzX3R5cGUuaWNvbn1cblx0XHRcdDwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuXHRcdFx0XHR7Z19hZGRyZXNzX3R5cGUudGV4dH1cblx0XHRcdDwvc3Bhbj5cblx0XHQ8L3NwYW4+XG5cblx0XHR7I2lmIGJfbmV3X2FkZHJlc3N9XG5cdFx0XHQ8ZGl2IGNsYXNzPVwibmV3LWFkZHJlc3NcIj5cblx0XHRcdFx0PENoZWNrYm94RmllbGQgaWQ9XCJzYXZlLWNvbnRhY3RcIiBiaW5kOmNoZWNrZWQ9e2JfY2hlY2tlZF9zYXZlX2NvbnRhY3R9ID5cblx0XHRcdFx0XHRTYXZlIHRvIGNvbnRhY3RzXG5cdFx0XHRcdDwvQ2hlY2tib3hGaWVsZD5cblx0XHRcdDwvZGl2PlxuXHRcdHsvaWZ9XG5cdDwvRmllbGQ+XG5cblx0eyNpZiBiX25ld19hZGRyZXNzICYmIGJfY2hlY2tlZF9zYXZlX2NvbnRhY3R9XG5cdFx0PEZpZWxkIHNob3J0IHNsaWRlc1xuXHRcdFx0a2V5PSduZXctY29udGFjdC1uYW1lJ1xuXHRcdFx0bmFtZT0nQ29udGFjdCBOYW1lJ1xuXHRcdD5cblx0XHRcdDxpbnB1dCBpZD1cIm5ldy1jb250YWN0LW5hbWUtdmFsdWVcIiB0eXBlPVwidGV4dFwiIG9uOmlucHV0PXtpbnB1dF9uZXdfY29udGFjdH0gY2xhc3M6aW52YWxpZD17c19lcnJfbmV3X2NvbnRhY3R9PlxuXG5cdFx0XHR7I2lmIHNfZXJyX25ld19jb250YWN0fVxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiPlxuXHRcdFx0XHRcdHtzX2Vycl9uZXdfY29udGFjdH1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0ey9pZn1cblx0XHQ8L0ZpZWxkPlxuXHR7L2lmfVxuXG5cdDxocj5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2Fzc2V0LXNlbGVjdCdcblx0XHRuYW1lPSdBc3NldCdcblx0PlxuXHRcdDxBc3NldFNlbGVjdCBiaW5kOmFzc2V0UmVmPXtwX2Fzc2V0fSAvPlxuXHQ8L0ZpZWxkPlxuXG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0nYW1vdW50J1xuXHRcdG5hbWU9J0Ftb3VudCdcblx0PlxuXHRcdDxBbW91bnRJbnB1dFxuXHRcdFx0YnVmZmVyTWF4PXtnX2NvaW4/IHhfZmVlOiAwfVxuXHRcdFx0YXNzZXRSZWY9e3BfYXNzZXR9XG5cdFx0XHRiaW5kOmVycm9yPXtzX2Vycl9hbW91bnR9XG5cdFx0XHRiaW5kOnZhbHVlPXtzX2Ftb3VudH1cblx0XHRcdHNob3dWYWxpZGF0aW9uPXtjX3Nob3dfdmFsaWRhdGlvbnN9XG5cdFx0Lz5cblx0PC9GaWVsZD5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2JhbGFuY2UnXG5cdFx0bmFtZT0nJ1xuXHQ+XG5cdFx0PHNwYW4gY2xhc3M9XCJiYWxhbmNlLWxpbmVcIj5cblx0XHRcdHsjaWYgcF9hc3NldH1cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJiYWxhbmNlXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsYWJlbFwiPlxuXHRcdFx0XHRcdFx0QmFsYW5jZVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImFtb3VudFwiPlxuXHRcdFx0XHRcdFx0e3NfYmFsYW5jZX0ge3Nfc3ltYm9sfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwidXNlLW1heFwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibGlua1wiIGNsYXNzOmRpc2FibGVkPXtiX3VzaW5nX21heH0gb246Y2xpY2s9eygpID0+IHVzZV9tYXgoKX0+VVNFIE1BWDwvc3Bhbj5cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0ey9pZn1cblx0XHQ8L3NwYW4+XG5cdDwvRmllbGQ+XG5cblx0PGhyPlxuXG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0nZmVlJ1xuXHRcdG5hbWU9J0ZlZSdcblx0PlxuXHRcdDxkaXYgY2xhc3M9XCJmZWUtYW1vdW50XCI+XG5cdFx0XHR7eF9mZWV9IFNDUlRcblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJmZWUtZmlhdFwiPlxuXHRcdFx0e3NfZmVlX2ZpYXR9XG5cdFx0PC9kaXY+XG5cblx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJwb3N0XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwibWFudWFsLWZlZVwiPlxuPCEtLSBcblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsaW5rIGRpc2FibGVkXCI+U2V0IGZlZSBtYW51YWxseTwvc3Bhbj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGluZm9cIj5cblx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9JTkZPfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdCAtLT5cblx0XHRcdDwvZGl2PlxuXHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHQ8L0ZpZWxkPlxuXG5cdDxocj5cblxuXHQ8ZGl2IGNsYXNzPVwibWVtb1wiIGNsYXNzOmV4cGFuZGVkPXtiX21lbW9fZXhwYW5kZWR9PlxuXHRcdDxkaXYgY2xhc3M9XCJ0aXRsZSBjbGlja2FibGVcIiBvbjpjbGljaz17KCkgPT4gYl9tZW1vX2V4cGFuZGVkID0gIWJfbWVtb19leHBhbmRlZH0+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImljb24gZHJvcGRvd25cIj5cblx0XHRcdFx0e0BodG1sIFNYX0lDT05fRFJPUERPV059XG5cdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0QWRkIG1lbW9cblx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0eyNpZiBiX21lbW9fZXhwYW5kZWR9XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiZGlzY2xhaW1lclwiIHRyYW5zaXRpb246c2xpZGU9e3tkdXJhdGlvbjozNTAsIGRlbGF5OjQwMH19PlxuXHRcdFx0XHRcdENhdXRpb246IE1lbW9zIGFyZSBOT1QgcHJpdmF0ZVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHR7L2lmfVxuXHRcdDwvZGl2PlxuXG5cdFx0eyNpZiBiX21lbW9fZXhwYW5kZWR9XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiaW5wdXRcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzUwfX0+XG5cdFx0XHRcdDx0ZXh0YXJlYSBiaW5kOnZhbHVlPXtzX21lbW99PjwvdGV4dGFyZWE+XG5cdFx0XHQ8L2Rpdj5cblx0XHR7L2lmfVxuXHQ8L2Rpdj5cblxuXHQ8QWN0aW9uc0xpbmUgY2FuY2VsPSdwb3AnIGNvbmZpcm09e1snTmV4dCcsICgpID0+IHN1Ym1pdCgpLCAhYl9mb3JtX3ZhbGlkXX0gLz5cblxuPCEtLSBcblx0PGRpdiBjbGFzcz1cImFjdGlvbi1saW5lXCIgY2xhc3M6cG9pbnRlci1ldmVudHNfbm9uZT17Yl9kZWFkfT5cblx0XHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17KCkgPT4gKChiX2RlYWQgPSB0cnVlKSAmJiBrX3BhZ2UucG9wKCkpfT5cblx0XHRcdENhbmNlbFxuXHRcdDwvYnV0dG9uPiAtLT5cbjwhLS0gXG5cdFx0PGJ1dHRvbiBjbGFzcz1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gc3VibWl0KCl9IHJlYWRvbmx5PXshYl9mb3JtX3ZhbGlkfT5cblx0XHRcdE5leHRcblx0XHQ8L2J1dHRvbj4gLS0+XG5cdDwhLS0gPC9kaXY+IC0tPlxuPC9TY3JlZW4+IiwiPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5nYXAge1xuXHRcdGhlaWdodDogOHB4O1xuXHRcdGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xuXHRcdG1hcmdpbi1ib3R0b206IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiZ2FwIG5vLW1hcmdpblwiPiZuYnNwOzwvZGl2PiIsImltcG9ydCB0eXBlIHtOYXRpdmVDb2lufSBmcm9tICcjL21ldGEvY2hhaW4nO1xuaW1wb3J0IHR5cGUge0NvaW59IGZyb20gJ2Nvc21vcy1ncnBjL2Rpc3QvY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luJztcblxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHtDb2luR2Vja299IGZyb20gJyMvc3RvcmUvd2ViLWFwaXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXNfYW1vdW50KGdfYmFsYW5jZTogQ29pbiwgZ19jb2luOiBOYXRpdmVDb2luKTogc3RyaW5nIHtcblx0Y29uc3Qgc19ub3JtID0gZ19iYWxhbmNlLmFtb3VudC5wYWRTdGFydChnX2NvaW4uZGVjaW1hbHMgKyAyLCAnMCcpO1xuXG5cdHJldHVybiBzX25vcm0uc2xpY2UoMCwgLWdfY29pbi5kZWNpbWFscykucmVwbGFjZSgvXjArLywgJzAnKSsnLicrc19ub3JtLnNsaWNlKC1nX2NvaW4uZGVjaW1hbHMpO1xuXG5cdC8vIC8vIGdfY29pbi5kZWNpbWFsc1xuXHQvLyByZXR1cm4gZ19iYWxhbmNlLmFtb3VudDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvX2ZpYXQoZ19iYWxhbmNlOiBDb2luLCBnX2NvaW46IE5hdGl2ZUNvaW4sIHNpX3ZlcnN1cz0ndXNkJyk6IFByb21pc2U8QmlnTnVtYmVyPiB7XG5cdC8vIHplcm9cblx0aWYoJzAnID09PSBnX2JhbGFuY2UuYW1vdW50KSByZXR1cm4gbmV3IEJpZ051bWJlcigwKTtcblxuXHQvLyBsb29rdXAgcHJpY2Vcblx0Y29uc3Qgc2lfZ2Vja28gPSBnX2NvaW4uZXh0cmEhLmNvaW5nZWNrb19pZDtcblx0Y29uc3QgZ192ZXJzdXMgPSBhd2FpdCBDb2luR2Vja28uY29pbnNWZXJzdXMoW3NpX2dlY2tvXSwgc2lfdmVyc3VzKTtcblxuXHQvLyBwYXJzZSBiYWxhbmNlIGFuZCBtdWx0aXBseSBieSB2YWx1ZVxuXHRyZXR1cm4gbmV3IEJpZ051bWJlcihnX2JhbGFuY2UuYW1vdW50KS5zaGlmdGVkQnkoLWdfY29pbi5kZWNpbWFscykudGltZXMoZ192ZXJzdXNbc2lfZ2Vja29dKTtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENvaW5Gb3JtYXRzIHtcblx0LyoqXG5cdCAqIFRoZSBpZCBvZiB0aGUgZmlhdCB0aGlzIGNvaW4gaXMgdmVyc3VzXG5cdCAqL1xuXHR2ZXJzdXM6IHN0cmluZztcblxuXHQvKipcblx0ICogVGhlIGJhbGFuY2Ugb2YgdGhlIGhvbGRpbmdcblx0ICovXG5cdGJhbGFuY2U6IEJpZ051bWJlcjtcblxuXHQvKipcblx0ICogVGhlIHRvdGFsIFxuXHQgKi9cblx0ZmlhdDogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBUaGUgd29ydGggb2YgZXhhY3RseSAxIGNvaW4gdmVyc3VzIHRoZSBnaXZlbiBmaWF0XG5cdCAqL1xuXHR3b3J0aDogbnVtYmVyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29pbl9mb3JtYXRzKGdfYmFsYW5jZTogQ29pbiwgZ19jb2luOiBOYXRpdmVDb2luLCBzaV92ZXJzdXM9J3VzZCcpOiBQcm9taXNlPENvaW5Gb3JtYXRzPiB7XG5cdC8vIGxvb2t1cCBwcmljZVxuXHRjb25zdCBzaV9nZWNrbyA9IGdfY29pbi5leHRyYSEuY29pbmdlY2tvX2lkO1xuXHRjb25zdCBnX3ZlcnN1cyA9IGF3YWl0IENvaW5HZWNrby5jb2luc1ZlcnN1cyhbc2lfZ2Vja29dLCBzaV92ZXJzdXMpO1xuXG5cdGNvbnN0IHhfd29ydGggPSBnX3ZlcnN1c1tzaV9nZWNrb107XG5cblx0Y29uc3QgeWdfYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoZ19iYWxhbmNlLmFtb3VudCkuc2hpZnRlZEJ5KC1nX2NvaW4uZGVjaW1hbHMpLnRpbWVzKHhfd29ydGgpXG5cblx0Ly8gcGFyc2UgYmFsYW5jZSBhbmQgbXVsdGlwbHkgYnkgdmFsdWVcblx0cmV0dXJuIHtcblx0XHR2ZXJzdXM6IHNpX3ZlcnN1cyxcblx0XHRiYWxhbmNlOiB5Z19iYWxhbmNlLFxuXHRcdGZpYXQ6IHlnX2JhbGFuY2UudGltZXMoeF93b3J0aCkudG9OdW1iZXIoKSxcblx0XHR3b3J0aDogeF93b3J0aCxcblx0fTtcbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcblxuXHRpbXBvcnQgU1hfSUNPTl9TRU5EIGZyb20gJyMvaWNvbi9zZW5kLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9SRUNWIGZyb20gJyMvaWNvbi9yZWN2LnN2Zz9yYXcnO1xuXG5cdC8vIGltcG9ydCB7ZGVmaW5pdGlvbn0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZyZWUtc29saWQtc3ZnLWljb25zL2ZhUm9ib3QnO1xuXHQvLyBjb25zdCBTWFBfUk9CT1QgPSBkZWZpbml0aW9uLmljb25bNF07XG5cdGNvbnN0IFNYUF9ST0JPVCA9ICcnO1xuXG5cdC8vIGltcG9ydCBTWF9OT1JUSF9FQVNUIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL2ZpbGxlZC9ub3J0aF9lYXN0LnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfRURJVCBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9maWxsZWQvZWRpdC5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0lORk8gZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvaW5mby5zdmc/cmF3JztcblxuXHRpbXBvcnQgU1hfSUNPTl9QRVJTT05BTCBmcm9tICcjL2ljb24vYWNjb3VudF9ib3guc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NPTlRSQUNUIGZyb20gJyMvaWNvbi9hbmFseXRpY3Muc3ZnP3Jhdyc7XG5cdGltcG9ydCB7IEhlYWRlciwgU2NyZWVuLCB0eXBlIFBhZ2UgfSBmcm9tICcuL19zY3JlZW5zJztcblx0aW1wb3J0IFBvcnRyYWl0LCB7IEFjdGlvbnMgfSBmcm9tICcuLi91aS9Qb3J0cmFpdC5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IEVudGl0eVBhdGgsIE5hdGl2ZUNvaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgeyBFbnRpdGllcyB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgeyB5d19jaGFpbiwgeXdfY2hhaW5fcmVmLCB5d19uZXR3b3JrX2FjdGl2ZSB9IGZyb20gJy4uL21lbSc7XG5cdGltcG9ydCB7IFNJX1NUT1JFX0NIQUlOUywgWFRfTUlOVVRFUyB9IGZyb20gJyMvc2hhcmUvY29uc3RhbnRzJztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBTZW5kIGZyb20gJy4vU2VuZC5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IFRva2VuLCBUb2tlblBhdGggfSBmcm9tICcjL21ldGEvdG9rZW4nO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IGNvaW5fZm9ybWF0cywgdG9fZmlhdCB9IGZyb20gJyMvY2hhaW4vY29pbic7XG5cdGltcG9ydCB7IGZvcm1hdF9hbW91bnQsIGZvcm1hdF9maWF0IH0gZnJvbSAnIy91dGlsL2Zvcm1hdCc7XG5cdGltcG9ydCB0eXBlIHsgQ29pbiB9IGZyb20gJ2Nvc21vcy1ncnBjL2Rpc3QvY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luJztcblx0aW1wb3J0IHR5cGUgeyBQZnBQYXRoIH0gZnJvbSAnIy9tZXRhL3BmcCc7XG5pbXBvcnQgUGZwRGlzcGxheSBmcm9tICcuLi91aS9QZnBEaXNwbGF5LnN2ZWx0ZSc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8qKlxuXHQgKiBFbnRpdHkgcGF0aCBzaG91bGQgYmUgZWl0aGVyIGEgaG9sZGluZyBvciB0b2tlblxuXHQgKi9cblx0ZXhwb3J0IGxldCBlbnRpdHlSZWY6IEVudGl0eVBhdGg7XG5cdGNvbnN0IHBfZW50aXR5ID0gZW50aXR5UmVmO1xuXG5cblx0Ly8gZWl0aGVyIGEgbmF0aXZlIGNvaW4gb3IgYSBmdW5naWJsZSB0b2tlblxuXHRsZXQgc2lfdHlwZTogJ2NvaW4nIHwgJ3Rva2VuJyB8ICcnID0gJyc7XG5cblx0Ly8gdGhlIGNvaW4ncyBpZCBhbmQgb2JqZWN0IChpZiBpdHMgYSBjb2luKVxuXHRsZXQgc2lfY29pbiA9ICcnO1xuXHRsZXQgZ19jb2luOiBOYXRpdmVDb2luIHwgbnVsbCA9IG51bGw7XG5cblx0Ly8gdGhlIHRva2VuJ3MgcGF0aCBhbmQgb2JqZWN0IChpZiBpdCdzIGEgdG9rZW4pXG5cdGxldCBwX3Rva2VuOiBUb2tlblBhdGggfCAnJyA9ICcnO1xuXHRsZXQgZ190b2tlbjogVG9rZW5bJ2ludGVyZmFjZSddIHwgbnVsbCA9IG51bGw7XG5cblxuXHQvLyBpdHMgcGZwXG5cdGxldCBwX3BmcDogUGZwUGF0aCB8ICcnID0gJyc7XG5cblx0Ly8gaXRzIFNZTUJMXG5cdGxldCBzX3N5bWJvbCA9ICcnO1xuXG5cdC8vIGl0cyBuYW1lXG5cdGxldCBzX25hbWUgPSAnJztcblx0XG5cdC8vIHRoZSBhbW91bnQgdGhlIG93bmVyIGhvbGRzXG5cdGxldCB5Z19hbW91bnQ6IEJpZ051bWJlciB8IG51bGwgPSBudWxsO1xuXG5cdC8vIHRoZSBlcXVpdmFsZW50IGluIGZpYXRcblx0bGV0IHNfZmlhdCA9ICcnO1xuXG5cdC8vIHRoZSBmaWF0IHdvcnRoIG9mIGV4YWN0bHkgMSBjb2luL3Rva2VuXG5cdGxldCBzX3dvcnRoID0gJyc7XG5cblxuXHQvLyBjb25zdCB4X3ZlcnN1c191c2QgPSBIX1ZFUlNVU19VU0RbcF90b2tlbl0udmFsdWU7XG5cblxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX2VudGl0eSgpIHtcblx0XHRjb25zdCBrc19lbnRpdGllcyA9IGF3YWl0IEVudGl0aWVzLnJlYWQoKTtcblxuXHRcdGNvbnN0IGdfaW5mbyA9IEVudGl0aWVzLnBhcnNlRW50aXR5UGF0aChwX2VudGl0eSk7XG5cblx0XHRpZighZ19pbmZvKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2FkIGhvbGRpbmcgdmlldyBvbiBub24tZW50aXR5IHBhdGggXCIke3BfZW50aXR5fVwiYCk7XG5cdFx0fVxuXG5cdFx0c3dpdGNoKGdfaW5mby50eXBlKSB7XG5cdFx0XHQvLyBuYXRpdmUgY29pblxuXHRcdFx0Y2FzZSAnaG9sZGluZyc6IHtcblx0XHRcdFx0c2lfdHlwZSA9ICdjb2luJztcblxuXHRcdFx0XHQvLyBkZXN0cnVjdHVyZVxuXHRcdFx0XHQoe1xuXHRcdFx0XHRcdGNvaW46IHNpX2NvaW4sXG5cdFx0XHRcdH0gPSBnX2luZm8pO1xuXG5cdFx0XHRcdC8vIGxvb2t1cCBkZXRhaWxzIGZyb20gY2hhaW5cblx0XHRcdFx0Y29uc3QgcF9jaGFpbiA9IGdfaW5mby5jaGFpblJlZjtcblx0XHRcdFx0Y29uc3QgZ19jaGFpbiA9IHBfY2hhaW4gPT09ICR5d19jaGFpbl9yZWY/ICR5d19jaGFpbjogKGF3YWl0IENoYWlucy5hdChwX2NoYWluKSkhO1xuXHRcdFx0XHRnX2NvaW4gPSBnX2NoYWluLmNvaW5zW3NpX2NvaW5dO1xuXG5cdFx0XHRcdC8vIHNldCBkZXRhaWxzXG5cdFx0XHRcdHNfc3ltYm9sID0gc2lfY29pbjtcblx0XHRcdFx0c19uYW1lID0gZ19jb2luLm5hbWU7XG5cdFx0XHRcdHBfcGZwID0gZ19jb2luLnBmcDtcblxuXHRcdFx0XHQvLyByZWFkIGNhY2hlXG5cdFx0XHRcdGNvbnN0IGdfY2FjaGVkID0gJHl3X25ldHdvcmtfYWN0aXZlLmNhY2hlZEJhbGFuY2UoZ19pbmZvLmJlY2gzMiwgc2lfY29pbik7XG5cblx0XHRcdFx0bGV0IGdfYmFsYW5jZTogQ29pbjtcblxuXHRcdFx0XHQvLyBjYWNoZSBpcyB3aXRoaW4gYXNraW5nIHRpbWVcblx0XHRcdFx0aWYoZ19jYWNoZWQgJiYgZ19jYWNoZWQudGltZXN0YW1wID49IERhdGUubm93KCkgLSAoMiAqIFhUX01JTlVURVMpKSB7XG5cdFx0XHRcdFx0Z19iYWxhbmNlID0gZ19jYWNoZWQuZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBkZXN0cnVjdHVyZSBiYWxhbmNlXG5cdFx0XHRcdFx0KHtcblx0XHRcdFx0XHRcdGJhbGFuY2U6IGdfYmFsYW5jZSxcblx0XHRcdFx0XHR9ID0gYXdhaXQgJHl3X25ldHdvcmtfYWN0aXZlLmJhbmtCYWxhbmNlKGdfaW5mby5iZWNoMzIsIHNpX2NvaW4pKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNldCBhbW91bnRcblx0XHRcdFx0eWdfYW1vdW50ID0gbmV3IEJpZ051bWJlcihnX2JhbGFuY2UuYW1vdW50KS5zaGlmdGVkQnkoLWdfY29pbi5kZWNpbWFscyk7XG5cblx0XHRcdFx0Ly8gc2V0IGZpYXQgYW1vdW50IGFzeW5jaHJvbm91c2x5XG5cdFx0XHRcdHZvaWQgY29pbl9mb3JtYXRzKGdfYmFsYW5jZSwgZ19jb2luKS50aGVuKChnX2Zvcm1hdHMpID0+IHtcblx0XHRcdFx0XHRzX2ZpYXQgPSBmb3JtYXRfZmlhdChnX2Zvcm1hdHMuZmlhdCwgZ19mb3JtYXRzLnZlcnN1cyk7XG5cdFx0XHRcdFx0c193b3J0aCA9IGZvcm1hdF9maWF0KGdfZm9ybWF0cy53b3J0aCwgZ19mb3JtYXRzLnZlcnN1cyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0b2tlblxuXHRcdFx0Y2FzZSAndG9rZW4nOiB7XG5cdFx0XHRcdHNpX3R5cGUgPSAndG9rZW4nO1xuXG5cdFx0XHRcdC8vIHNldCB0b2tlbiBwYXRoXG5cdFx0XHRcdHBfdG9rZW4gPSBwX2VudGl0eSBhcyBUb2tlblBhdGg7XG5cblx0XHRcdFx0Ly8gcmVhZCB0b2tlbiBpbnRlcmZhY2VzXG5cdFx0XHRcdGNvbnN0IGtzX2VudGl0ZXMgPSBhd2FpdCBFbnRpdGllcy5yZWFkKCk7XG5cdFx0XHRcdGNvbnN0IGhfaWZhY2VzID0ga3NfZW50aXRlcy50b2tlbnMoZ19pbmZvLmVudGl0eVJlZiwgRW50aXRpZXMuZnVuZ2libGVJbnRlcmZhY2VzRm9yKCR5d19jaGFpbikpO1xuXHRcdFx0XHRkZWJ1Z2dlcjtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBlbnRpdHkgdHlwZTogXCIke2dfaW5mby50eXBlfVwiYCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bG9hZF9lbnRpdHkoKTtcblxuXHQvLyBleHBvcnQgY29uc3QgYWNjb3VudElkID0gT2JqZWN0LnZhbHVlcyhIX0FDQ09VTlRTKS5maW5kKChrKSA9PiBrLmFkZHJlc3Moa19jaGFpbikgPT09IGhvbGRpbmcuZGVmLmhvbGRlckFkZHIpPy5kZWYuaWQgfHwgJHl3X2NoYWluLmRlZi5pZDtcblxuXHQvLyBjb25zdCBrX2FjY291bnQgPSAkeXdfYWNjb3VudDtcblx0Ly8geXdfYWNjb3VudC5zdWJzY3JpYmUoKF9rX2FjY291bnQpID0+IHtcblx0Ly8gXHRpZigkeXdfcGF0dGVybi5lbmRzV2l0aCgnL3Rva2Vucy97dG9rZW5JZH0vaG9sZGluZ3Mve2FjY291bnRJZH0vdmlldycpICYmIGtfYWNjb3VudC5kZWYucHVia2V5ICE9PSBfa19hY2NvdW50LmRlZi5wdWJrZXkpIHtcblx0Ly8gXHRcdHJlc3RhcnQoKTtcblx0Ly8gXHR9XG5cdC8vIH0pO1xuXG5cdC8vIGNvbnN0IEhfVFhOX0lDT05TID0ge1xuXHQvLyBcdFtUeG4uVHlwZS5VTktOXTogSWNvbi5CTEFOSyxcblx0Ly8gXHRbVHhuLlR5cGUuU0VORF06IEljb24uZnJvbUh0bWwoU1hfSUNPTl9TRU5ELCB7Y2xhc3M6J2ljb24tMjAnfSksXG5cdC8vIFx0W1R4bi5UeXBlLlJFQ1ZdOiBJY29uLmZyb21IdG1sKFNYX0lDT05fUkVDViwge2NsYXNzOidpY29uLTIwJ30pLFxuXHQvLyBcdFtUeG4uVHlwZS5DT01QXTogSWNvbi5mcm9tSHRtbChgPHN2Zz48cGF0aCBkPVwiJHtTWFBfUk9CT1R9XCIvPjwvc3ZnPmAsIHtjbGFzczonaWNvbi0yMCd9KSxcblx0Ly8gXHRbVHhuLlR5cGUuU05JUDIwX1hGRVJdOiBJY29uLmZyb21IdG1sKFNYX0lDT05fUkVDViwge2NsYXNzOidpY29uLTIwJ30pLFxuXHQvLyB9IGFzIFJlY29yZDxUeG4uVHlwZSB8IFR4bi5CYW5raXNoVHlwZSwgSWNvbj47XG5cblx0Ly8gY29uc3QgSF9TVU1NQVJJWkVSUyA9IHtcblx0Ly8gXHRbVHhuLlR5cGUuVU5LTl06IChfKSA9PiAnVW5rbm93bicsXG5cdC8vIFx0W1R4bi5UeXBlLlNFTkRdOiAoaykgPT4gYFNlbmQgb24gJHtrLmRhdGUoKX1gLFxuXHQvLyBcdFtUeG4uVHlwZS5SRUNWXTogKGspID0+IGBSZWNlaXZlIG9uICR7ay5kYXRlKCl9YCxcblx0Ly8gXHRbVHhuLlR5cGUuQ09NUF06IChrKSA9PiBgQ29tcHV0ZSBvbiAke2suZGF0ZSgpfWAsXG5cdC8vIH0gYXMgUmVjb3JkPFR4bi5UeXBlIHwgVHhuLkJhbmtpc2hUeXBlLCAoa190eG46IFR4bikgPT4gc3RyaW5nPjtcblxuXHQvLyBjb25zdCBIX1RYTl9DTEFTU0VTID0ge1xuXHQvLyBcdFtUeG4uVHlwZS5TRU5EXTogJ2NvbG9yLWljb24tc2VuZCcsXG5cdC8vIFx0W1R4bi5UeXBlLlJFQ1ZdOiAnY29sb3ItaWNvbi1yZWN2Jyxcblx0Ly8gfSBhcyBSZWNvcmQ8VHhuLlR5cGUgfCBUeG4uQmFua2lzaFR5cGUsIHN0cmluZz47XG5cblx0Ly8gdGhlIHNldCBvZiBhY3Rpb25zIGF2YWlsYWJsZSBvbiB0aGlzIGFzc2V0XG5cdGNvbnN0IGdjX2FjdGlvbnM6IEFjdGlvbnMgPSB7XG5cdFx0c2VuZDoge1xuXHRcdFx0bGFiZWw6ICdTZW5kJyxcblx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBTZW5kLFxuXHRcdFx0XHRcdHByb3BzOiBnX3Rva2VuXG5cdFx0XHRcdFx0XHQ/IHtcblx0XHRcdFx0XHRcdFx0dG9rZW46IGdfdG9rZW4sXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQ6IHNpX2NvaW5cblx0XHRcdFx0XHRcdFx0PyB7XG5cdFx0XHRcdFx0XHRcdFx0bmF0aXZlOiBzaV9jb2luLFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdDoge30sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHR9O1xuXG5cdC8vIC8vIGhvbWUgdG9rZW5cblx0Ly8gY29uc3Qga19pYmN0X25hdGl2ZSA9IEhfSUJDVFNbSWJjdC5yZWZGcm9tSG9tZVRva2VuKGdkX3Rva2VuLmlyaSldO1xuXHQvLyBpZihrX2liY3RfbmF0aXZlKSB7XG5cdC8vIFx0Z2NfYWN0aW9ucy53cmFwID0ge1xuXHQvLyBcdFx0bGFiZWw6ICdXcmFwJyxcblx0Ly8gXHRcdHRyaWdnZXIoKSB7XG5cdC8vIFx0XHRcdHB1c2hfc2NyZWVuKERlYWRFbmQpO1xuXHQvLyBcdFx0fSxcblx0Ly8gXHR9O1xuXHQvLyB9XG5cblx0Ly8gLy8gY29sb255IHRva2VuXG5cdC8vIGlmKGtfdG9rZW4uaWJjdCkge1xuXHQvLyBcdGdjX2FjdGlvbnMudW53cmFwID0ge1xuXHQvLyBcdFx0bGFiZWw6ICdVbndyYXAnLFxuXHQvLyBcdFx0dHJpZ2dlcigpIHtcblx0Ly8gXHRcdFx0cHVzaF9zY3JlZW4oRGVhZEVuZCk7XG5cdC8vIFx0XHR9LFxuXHQvLyBcdH07XG5cdC8vIH1cblxuXHQvLyAvLyBub24tbmF0aXZlIHRva2VuXG5cdC8vIGlmKCFnZF90b2tlbi5uYXRpdmUpIHtcblx0Ly8gXHRPYmplY3QuYXNzaWduKGdjX2FjdGlvbnMsIHtcblx0Ly8gXHRcdGVkaXQ6IHtcblx0Ly8gXHRcdFx0bGFiZWw6ICdFZGl0Jyxcblx0Ly8gXHRcdFx0dHJpZ2dlcigpIHtcblx0Ly8gXHRcdFx0XHRwdXNoX3NjcmVlbihUb2tlbkVkaXQsIHtcblx0Ly8gXHRcdFx0XHRcdHRva2VuOiBrX3Rva2VuLFxuXHQvLyBcdFx0XHRcdH0pO1xuXHQvLyBcdFx0XHR9LFxuXHQvLyBcdFx0fSxcblx0Ly8gXHR9KTtcblx0Ly8gfVxuXG5cdC8vIGZ1bmN0aW9uIGRldGFpbF9iYW5raXNoKGdfYmFua2lzaD86IFR4bi5CYW5raXNoIHwgbnVsbCk6IHtwcmVmaXg6c3RyaW5nLCBuYW1lOnN0cmluZywgaWNvbjpzdHJpbmd9IHtcblx0Ly8gXHRpZighZ19iYW5raXNoKSByZXR1cm4ge3ByZWZpeDonJywgbmFtZTonJywgaWNvbjonJ307XG5cblx0Ly8gXHRjb25zdCBrX2NvbnRhY3QgPSBIX0FERFJfVE9fQ09OVEFDVFtnX2Jhbmtpc2guYWRkcmVzc107XG5cblx0Ly8gXHRyZXR1cm4ge1xuXHQvLyBcdFx0cHJlZml4OiAoVHhuLkJhbmtpc2hUeXBlLlNFTkQgPT09IGdfYmFua2lzaC50eXBlPyAndG8nOiAnZnInKSsnOicsXG5cdC8vIFx0XHRuYW1lOiBrX2NvbnRhY3Q/IGtfY29udGFjdC5kZWYubGFiZWw6ICcnLFxuXHQvLyBcdFx0aWNvbjoga19jb250YWN0XG5cdC8vIFx0XHRcdD8gQ29udGFjdC5UeXBlLlBFUlNPTiA9PT0ga19jb250YWN0LmRlZi50eXBlXG5cdC8vIFx0XHRcdFx0PyBTWF9JQ09OX1BFUlNPTkFMXG5cdC8vIFx0XHRcdFx0OiBTWF9JQ09OX0NPTlRSQUNUXG5cdC8vIFx0XHRcdDogJycsXG5cdC8vIFx0fTtcblx0Ly8gfVxuXG5cdFxuXHQvLyBjb25zdCBhX2FsbG93YW5jZXMgPSBnZF90b2tlbi5hbGxvd2FuY2VzLm1hcCgoZ19hbGxvd2FuY2UpID0+IHtcblx0Ly8gXHRjb25zdCBrX3NwZW5kZXIgPSBIX0FERFJfVE9fQ09OVFJBQ1RbZ19hbGxvd2FuY2Uuc3BlbmRlcl07XG5cdC8vIFx0aWYoIWtfc3BlbmRlcikge1xuXHQvLyBcdFx0ZGVidWdnZXI7XG5cdC8vIFx0fVxuXG5cdC8vIFx0bGV0IHNfYW1vdW50O1xuXHQvLyBcdGNvbnN0IHlnX2Ftb3VudCA9IG5ldyBCaWdOdW1iZXIoZ19hbGxvd2FuY2UuYW1vdW50KTtcblx0Ly8gXHRpZih5Z19hbW91bnQuaXNHcmVhdGVyVGhhbihuZXcgQmlnTnVtYmVyKCcxMDAwMDAwMDAwMDAwMDAwMDAwJykpKSB7XG5cdC8vIFx0XHRzX2Ftb3VudCA9ICdMaW1pdGxlc3MnO1xuXHQvLyBcdH1cblx0Ly8gXHRlbHNlIHtcblx0Ly8gXHRcdGZvcm1hdF9hbW91bnQoa190b2tlbi5hcHByb3goQmlnSW50KGdfYWxsb3dhbmNlLmFtb3VudCkpKTtcblx0Ly8gXHR9XG5cblx0Ly8gXHRsZXQgc19leHBpcnk7XG5cdC8vIFx0Y29uc3QgeF9leHBpcmVzID0gZ19hbGxvd2FuY2UuZXhwaXJhdGlvbjtcblx0Ly8gXHRpZih4X2V4cGlyZXMpIHtcblx0Ly8gXHRcdGNvbnN0IGR0X3doZW4gPSBuZXcgRGF0ZSh4X2V4cGlyZXMgKiAxZTMpO1xuXG5cdC8vIFx0XHRzX2V4cGlyeSA9IGR0X3doZW4udG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcblx0Ly8gXHRcdFx0bW9udGg6ICdzaG9ydCcsXG5cdC8vIFx0XHRcdGRheTogJ251bWVyaWMnLFxuXHQvLyBcdFx0XHR5ZWFyOiBkdF93aGVuLmdldEZ1bGxZZWFyKCkgIT09IChuZXcgRGF0ZSgpKS5nZXRGdWxsWWVhcigpPyAnbnVtZXJpYyc6IHZvaWQgMCxcblx0Ly8gXHRcdH0pO1xuXHQvLyBcdH1cblx0Ly8gXHRlbHNlIHtcblx0Ly8gXHRcdHNfZXhwaXJ5ID0gJ05ldmVyIGV4cGlyZXMnO1xuXHQvLyBcdH1cblxuXHQvLyBcdHJldHVybiB7XG5cdC8vIFx0XHQuLi5nX2FsbG93YW5jZSxcblx0Ly8gXHRcdGtfc3BlbmRlcixcblx0Ly8gXHRcdHNfYW1vdW50LFxuXHQvLyBcdFx0c19leHBpcnksXG5cdC8vIFx0fTtcblx0Ly8gfSk7XG5cblx0Ly8gaWYoVGFza3MuVkVSSUZZID09PSAkeXdfdGFzayAmJiAnQVRPTScgPT09IGdkX3Rva2VuLnN5bWJvbCAmJiBnZF90b2tlbi5uYXRpdmUgJiYgJzInID09PSAkeXdfYWNjb3VudC5kZWYuaWQpIHtcblx0Ly8gXHRzZXRUaW1lb3V0KCgpID0+IHtcblx0Ly8gXHRcdCR5d190YXNrID0gLSR5d190YXNrO1xuXHQvLyBcdH0sIDE0MDApO1xuXHQvLyB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LnR4bnMge1xuXHRcdC5yb3cgLmljb24ge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0Ym9yZGVyLXJhZGl1czogMzJweDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQuc2VjdGlvbiB7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdGJvcmRlci10b3A6IDZweCBzb2xpZCBibGFjaztcblx0XHRib3JkZXItYm90dG9tOiA2cHggc29saWQgYmxhY2s7XG5cblx0XHQuYmFyIHtcblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0cGFkZGluZzogdmFyKC0tdWktcGFkZGluZyk7XG5cblx0XHRcdC5sZWZ0IHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0Z2FwOiAwLjVleDtcblxuXHRcdFx0XHQ+LnRpdGxlIHtcblx0XHRcdFx0XHQuZm9udChyZWd1bGFyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4uaW5mbyB7XG5cdFx0XHRcdFx0LmZvbnQodGlueSk7XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQucmlnaHQge1xuXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LnR4bi10eXBlLmljb24ge1xuXHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdFx0LS1pY29uLWRpYW1ldGVyOiAxOHB4O1xuXHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHR9XG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdIb2xkaW5nVmlldycgbmF2IHNsaWRlcz5cblx0PEhlYWRlciBwb3BzIGFjY291bnQgbmV0d29ya1xuXHRcdHRpdGxlPXtzX3N5bWJvbH1cblx0XHRzdWJ0aXRsZT17c19uYW1lfVxuXHQ+XG5cdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwidGl0bGVcIj5cblxuXHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHQ8L0hlYWRlcj5cblxuXHQ8UG9ydHJhaXRcblx0XHRwZnA9e3BfcGZwfVxuXHRcdHJlc291cmNlPXtnX2NvaW4gfHwgZ190b2tlbiB8fCBudWxsfVxuXHRcdHJlc291cmNlUGF0aD17cF9lbnRpdHl9XG5cdFx0dGl0bGU9e3lnX2Ftb3VudD8gYCR7Zm9ybWF0X2Ftb3VudCh5Z19hbW91bnQudG9OdW1iZXIoKSl9ICR7c19zeW1ib2x9YDogJy4uLid9XG5cdFx0c3VidGl0bGU9e2Ake3NfZmlhdH0gKCR7c193b3J0aH0gcGVyICR7c2lfdHlwZX0pYH1cblx0XHRhY3Rpb25zPXtnY19hY3Rpb25zfVxuXHRcdGNpcmN1bGFyXG5cdC8+XG5cblx0PGRpdiBjbGFzcz1cInR4bnMgbm8tbWFyZ2luXCI+XG5cblx0XHQ8IS0tIHsjaWYga19pYmN0X25hdGl2ZX1cblx0XHRcdDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJiYXJcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImxlZnRcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJsYWJlbFwiPlxuXHRcdFx0XHRcdFx0XHRTdGFrZVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdFx0XHRFYXJuIHVwIHRvIDI0JSBwZXIgeWVhclxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwicmlnaHRcIj5cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJwaWxsXCI+XG5cdFx0XHRcdFx0XHRcdFN0YWtlIHtnZF90b2tlbi5zeW1ib2x9XG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQgLS0+XG5cdFx0PCEtLSB7OmVsc2UgaWYgJHl3X2NoYWluLmRlZi5pZC5zdGFydHNXaXRoKCdzZWNyZXQtJyl9IC0tPlxuPCEtLSBcblx0XHRcdDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJiYXJcIiBzdHlsZT17YV9hbGxvd2FuY2VzLmxlbmd0aD8gXCJib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcIjogJyd9PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibGVmdFwiPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxhYmVsXCI+XG5cdFx0XHRcdFx0XHRcdEFsbG93YW5jZXMgKHtnZF90b2tlbi5hbGxvd2FuY2VzLmxlbmd0aH0pXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0XHRcdEFjY291bnRzIGFsbG93ZWQgdG8gc3BlbmQgdGhpcyB0b2tlblxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwicmlnaHRcIj5cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJwaWxsXCIgb246Y2xpY2s9eygpID0+IHB1c2hfc2NyZWVuKERlYWRFbmQpfT5cblx0XHRcdFx0XHRcdFx0TWFuYWdlXG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdHsjZWFjaCBhX2FsbG93YW5jZXMgYXMgZ19hbGxvd2FuY2UsIGlfYWxsb3dhbmNlfVxuXHRcdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRcdG5hbWU9e2dfYWxsb3dhbmNlLmtfc3BlbmRlci5kZWYubGFiZWx9XG5cdFx0XHRcdFx0XHRhZGRyZXNzPXtnX2FsbG93YW5jZS5rX3NwZW5kZXIuZGVmLmFkZHJlc3N9XG5cdFx0XHRcdFx0XHRhbW91bnQ9e2dfYWxsb3dhbmNlLnNfYW1vdW50fVxuXHRcdFx0XHRcdFx0ZmlhdD17Z19hbGxvd2FuY2Uuc19leHBpcnl9XG5cdFx0XHRcdFx0XHRpY29uUmVmPXtnX2FsbG93YW5jZS5rX3NwZW5kZXIuZGVmLmljb25SZWZ9XG5cdFx0XHRcdFx0XHRpY29uQ2xhc3M9J3NpdGUnXG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gcHVzaF9zY3JlZW4oRGVhZEVuZCl9XG5cdFx0XHRcdFx0XHRyb290U3R5bGU9e2lfYWxsb3dhbmNlID09PSBhX2FsbG93YW5jZXMubGVuZ3RoLTE/ICdib3JkZXItYm90dG9tOiBub25lOyc6ICcnfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0ey9lYWNofVxuXHRcdFx0PC9kaXY+IC0tPlxuXG5cdFx0PCEtLSB7L2lmfSAtLT5cbjwhLS0gXG5cdFx0eyNlYWNoIGFfaGlzdG9yeSBhcyBrX3R4bn1cblx0XHRcdHtAY29uc3QgZ19iYW5raXNoID0ga190eG4uYmFua2lzaCgkeXdfYWNjb3VudC5hZGRyZXNzKCR5d19jaGFpbikpfVxuXHRcdFx0e0Bjb25zdCBnZF90eG4gPSBrX3R4bi5kZWZ9XG5cdFx0XHR7QGNvbnN0IGdfZGV0YWlsID0gZGV0YWlsX2Jhbmtpc2goZ19iYW5raXNoKX1cblxuXHRcdFx0eyNpZiBnX2Jhbmtpc2h9XG5cdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRpY29uPXtIX1RYTl9JQ09OU1tnX2Jhbmtpc2gudHlwZV19XG5cdFx0XHRcdFx0aWNvbkNsYXNzPXtIX1RYTl9DTEFTU0VTW2dfYmFua2lzaC50eXBlXSB8fCAnJ31cblx0XHRcdFx0XHRuYW1lPXtIX1NVTU1BUklaRVJTW2dfYmFua2lzaC50eXBlXShrX3R4bil9XG5cdFx0XHRcdFx0YWRkcmVzcz17Z19iYW5raXNoLmFkZHJlc3N9XG5cdFx0XHRcdFx0ZGV0YWlsPXtnX2RldGFpbC5uYW1lfVxuXHRcdFx0XHRcdHByZWZpeD17Z19kZXRhaWwucHJlZml4fVxuXHRcdFx0XHRcdGFtb3VudD17Zm9ybWF0X2Ftb3VudChrX3Rva2VuLmFwcHJveChnX2Jhbmtpc2guYW1vdW50KSl9XG5cdFx0XHRcdFx0ZmlhdD17YW1vdW50X3RvX2ZpYXQoa190b2tlbi5hcHByb3goZ19iYW5raXNoLmFtb3VudCksIGtfdG9rZW4pfVxuXHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiBwdXNoX3NjcmVlbihEZWFkRW5kKX1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cImRldGFpbFwiPlxuXHRcdFx0XHRcdFx0eyNpZiBnX2RldGFpbC5pY29ufVxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInR4bi10eXBlIGljb25cIj5cblx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgZ19kZXRhaWwuaWNvbn1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHRcdHsjaWYgZ19kZXRhaWwubmFtZX1cblx0XHRcdFx0XHRcdFx0e2dfZGV0YWlsLm5hbWV9XG5cdFx0XHRcdFx0XHR7OmVsc2UgaWYgZ19iYW5raXNoLmFkZHJlc3N9XG5cdFx0XHRcdFx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9e2dfYmFua2lzaC5hZGRyZXNzfSAvPlxuXHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0PC9Sb3c+XG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRpY29uPXtIX1RYTl9JQ09OU1tnZF90eG4udHlwZV19XG5cdFx0XHRcdFx0aWNvbkNsYXNzPXtIX1RYTl9DTEFTU0VTW2dkX3R4bi50eXBlXSB8fCAnJ31cblx0XHRcdFx0XHRuYW1lPXtIX1NVTU1BUklaRVJTW2dkX3R4bi50eXBlXShrX3R4bil9XG5cdFx0XHRcdFx0YWRkcmVzcz17Z2RfdHhuLmFkZHJlc3N9XG5cdFx0XHRcdFx0YW1vdW50PXtmb3JtYXRfYW1vdW50KGtfdG9rZW4uYXBwcm94KGdkX3R4bi5hbW91bnQpKX1cblx0XHRcdFx0XHRmaWF0PXthbW91bnRfdG9fZmlhdChrX3Rva2VuLmFwcHJveChnZF90eG4uYW1vdW50KSwga190b2tlbil9XG5cdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHB1c2hfc2NyZWVuKERlYWRFbmQpfVxuXHRcdFx0XHQvPlxuXHRcdFx0ey9pZn1cblx0XHR7L2VhY2h9IC0tPlxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgVG9rZW5TcGVjS2V5IH0gZnJvbSAnIy9tZXRhL3Rva2VuJztcblxuXHRpbXBvcnQgeyBFbnRpdGllcywgVG9rZW5EaWN0IH0gZnJvbSAnIy9zdG9yZS9lbnRpdGllcyc7XG5cdGltcG9ydCB7IERpY3QsIGZvcmV2ZXIsIG9kZSwgb2Rlcm9tLCBQcm9taXNhYmxlIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHsgeXdfYWNjb3VudCwgeXdfYWNjb3VudF9yZWYsIHl3X2NoYWluLCB5d19jaGFpbl9yZWYsIHl3X3BvcHVwLCB5d19jb250ZXh0X3BvcHVwLCBwb3B1cF9yZWNlaXZlLCB5d19uZXR3b3JrLCB5d19uZXR3b3JrX2FjdGl2ZSwgeXdfb3duZXIgfSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgUG9ydHJhaXQgZnJvbSAnLi4vdWkvUG9ydHJhaXQuc3ZlbHRlJztcblx0aW1wb3J0IFNlbmQgZnJvbSAnLi9TZW5kLnN2ZWx0ZSc7XG5cdGltcG9ydCBQb3B1cFJlY2VpdmUgZnJvbSAnLi4vdWkvUG9wdXBSZWNlaXZlLnN2ZWx0ZSc7XG5cdGltcG9ydCBSb3cgZnJvbSAnLi4vdWkvUm93LnN2ZWx0ZSc7XG5cdGltcG9ydCB7IEhlYWRlciwgU2NyZWVuLCB0eXBlIFBhZ2UgfSBmcm9tICcuL19zY3JlZW5zJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBDb2luR2Vja28gfSBmcm9tICcjL3N0b3JlL3dlYi1hcGlzJztcblx0aW1wb3J0IHsgZm9ybWF0X2Ftb3VudCwgZm9ybWF0X2ZpYXQgfSBmcm9tICcjL3V0aWwvZm9ybWF0Jztcblx0aW1wb3J0IHR5cGUgeyBDb2luIH0gZnJvbSAnY29zbW9zLWdycGMvZGlzdC9jb3Ntb3MvYmFzZS92MWJldGExL2NvaW4nO1xuXHRpbXBvcnQgdHlwZSB7IENoYWluLCBOYXRpdmVDb2luIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IHR5cGUgeyBWYWx1ZXMgfSBmcm9tICcjL21ldGEvYmVsdCc7XG5cdGltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi4vdWkvQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgR2FwIGZyb20gJy4uL3VpL0dhcC5zdmVsdGUnO1xuXHRpbXBvcnQgeyBvcGVuX2V4dGVybmFsX2xpbmsgfSBmcm9tICcjL3V0aWwvZG9tJztcblx0aW1wb3J0IFRva2Vuc0FkZCBmcm9tICcuL1Rva2Vuc0FkZC5zdmVsdGUnO1xuXHRpbXBvcnQgeyBhc19hbW91bnQsIHRvX2ZpYXQgfSBmcm9tICcjL2NoYWluL2NvaW4nO1xuXHRpbXBvcnQgSG9sZGluZ1ZpZXcgZnJvbSAnLi9Ib2xkaW5nVmlldy5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IEJhbGFuY2VCdW5kbGUgfSBmcm9tICcjL3N0b3JlL25ldHdvcmtzJztcblx0aW1wb3J0IHsgc3lzZXJyIH0gZnJvbSAnLi4vY29tbW9uJztcblx0aW1wb3J0IHsgQWNjb3VudHMgfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblxuXHQvLyAkOiBzYV9vd25lciA9IENoYWlucy5hZGRyZXNzRm9yKCR5d19hY2NvdW50LnB1YmtleSwgJHl3X2NoYWluKTtcblxuXHRjb25zdCBtZXJnZV9mdW5naWJsZV90b2tlbnMgPSAoaF9mdW5naWJsZXM6IFJlY29yZDxUb2tlblNwZWNLZXksIFRva2VuRGljdD4pID0+IG9kZXJvbShoX2Z1bmdpYmxlcywgKF8sIGgpID0+IGgpO1xuXG5cdC8vIGdldCBwYWdlIGZyb20gY29udGV4dFxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0bGV0IHlnX3RvdGFsID0gbmV3IEJpZ051bWJlcigwKTtcblx0bGV0IGNfYmFsYW5jZXMgPSAwO1xuXHRsZXQgYl9iYWxhbmNlc19yZWFkeSA9IHRydWU7XG5cdGxldCBhX25vX2dhczogc3RyaW5nW10gPSBbXTtcblxuXHRsZXQgZmtfcmVzb2x2ZV90b3RhbDogKHNfdG90YWw6IHN0cmluZykgPT4gdm9pZDtcblx0bGV0IGRwX3RvdGFsID0gbmV3IFByb21pc2U8c3RyaW5nPigoZmtfcmVzb2x2ZSkgPT4ge1xuXHRcdGZrX3Jlc29sdmVfdG90YWwgPSBma19yZXNvbHZlO1xuXHR9KTtcblxuXHRsZXQgZ19jaGFpbl9jYWNoZWQgPSAkeXdfY2hhaW47XG5cdCQ6IHtcblx0XHRpZigkeXdfY2hhaW4gIT09IGdfY2hhaW5fY2FjaGVkKSB7XG5cdFx0XHRnX2NoYWluX2NhY2hlZCA9ICR5d19jaGFpbjtcblx0XHRcdHlnX3RvdGFsID0gbmV3IEJpZ051bWJlcigwKTtcblx0XHRcdGNfYmFsYW5jZXMgPSAwO1xuXHRcdFx0ZHBfdG90YWwgPSBuZXcgUHJvbWlzZTxzdHJpbmc+KChma19yZXNvbHZlKSA9PiB7XG5cdFx0XHRcdGZrX3Jlc29sdmVfdG90YWwgPSBma19yZXNvbHZlO1xuXHRcdFx0fSk7XG5cdFx0XHRhX25vX2dhcyA9IFtdO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gY2hlY2tfdG90YWwoKSB7XG5cdFx0Y19iYWxhbmNlcyAtPSAxO1xuXHRcdGlmKGJfYmFsYW5jZXNfcmVhZHkgJiYgIWNfYmFsYW5jZXMpIHtcblx0XHRcdGNvbnN0IHNfdG90YWwgPSBmb3JtYXRfZmlhdCh5Z190b3RhbC50b051bWJlcigpLCAndXNkJyk7XG5cdFx0XHRma19yZXNvbHZlX3RvdGFsKHNfdG90YWwpO1xuXG5cdFx0XHQvLyBzYXZlIHRvIGNhY2hlXG5cdFx0XHRjb25zdCBnX2FjY291bnQgPSAkeXdfYWNjb3VudDtcblx0XHRcdHZvaWQgQWNjb3VudHMub3BlbihrcyA9PiBrcy5wdXQoe1xuXHRcdFx0XHQuLi5nX2FjY291bnQsXG5cdFx0XHRcdGV4dHJhOiB7XG5cdFx0XHRcdFx0dG90YWxfZmlhdF9jYWNoZTogc190b3RhbCxcblx0XHRcdFx0fSxcblx0XHRcdH0pKTtcblx0XHR9XG5cdH1cblxuXHR0eXBlIFN1Ym1pdHRlciA9ICh6X291dDogUHJvbWlzYWJsZTxCaWdOdW1iZXI+KSA9PiBQcm9taXNlPEJpZ051bWJlcj47XG5cblx0Ly8gYXN5bmMgZnVuY3Rpb24gd2l0aF9iYWxhbmNlPHdfdmFsdWU+KGRwX3RoaW5nOiBQcm9taXNhYmxlPHdfdmFsdWU+KTogUHJvbWlzZTxbd192YWx1ZSwgU3VibWl0dGVyXT4ge1xuXHQvLyBcdGNfYmFsYW5jZXMgKz0gMTtcblxuXHQvLyBcdGNvbnN0IHdfdmFsdWUgPSBhd2FpdCBkcF90aGluZztcblxuXHQvLyBcdHJldHVybiBbXG5cdC8vIFx0XHR3X3ZhbHVlLFxuXHQvLyBcdFx0YXN5bmMoel9vdXQ6IFByb21pc2FibGU8QmlnTnVtYmVyPik6IFByb21pc2U8QmlnTnVtYmVyPiA9PiB7XG5cdC8vIFx0XHRcdGNvbnN0IHlnX2JhbGFuY2UgPSBhd2FpdCB6X291dDtcblxuXHQvLyBcdFx0XHR5Z190b3RhbCA9IHlnX3RvdGFsLnBsdXMoeWdfYmFsYW5jZSk7XG5cblx0Ly8gXHRcdFx0Y2hlY2tfdG90YWwoKTtcblx0Ly8gXHRcdFx0cmV0dXJuIHlnX2JhbGFuY2U7XG5cdC8vIFx0XHR9LFxuXHQvLyBcdF07XG5cdC8vIH1cblxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX25hdGl2ZV9iYWxhbmNlcygpIHtcblx0XHRsZXQgaF9iYWxhbmNlczogRGljdDxCYWxhbmNlQnVuZGxlPjtcblx0XHR0cnkge1xuXHRcdFx0aF9iYWxhbmNlcyA9IGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5iYW5rQmFsYW5jZXMoJHl3X293bmVyKTtcblx0XHR9XG5cdFx0Y2F0Y2goZV9uZXR3b3JrKSB7XG5cdFx0XHRzeXNlcnIoe1xuXHRcdFx0XHRlcnJvcjogZV9uZXR3b3JrIGFzIEVycm9yLFxuXHRcdFx0XHR0ZXh0OiAnTmV0d29yayBlcnJvcicsXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHRjb25zdCBhX291dHM6IFtzdHJpbmcsIE5hdGl2ZUNvaW4sIENvaW4sIFN1Ym1pdHRlcl1bXSA9IFtdO1xuXG5cdFx0Zm9yKGNvbnN0IFtzaV9jb2luLCBnX2NvaW5dIG9mIG9kZSgkeXdfY2hhaW4uY29pbnMpKSB7XG5cdFx0XHRjb25zdCBnX2J1bmRsZSA9IGhfYmFsYW5jZXNbc2lfY29pbl07XG5cblx0XHRcdGlmKCFnX2J1bmRsZSB8fCAnMCcgPT09IGdfYnVuZGxlLmJhbGFuY2UuYW1vdW50KSB7XG5cdFx0XHRcdGFfbm9fZ2FzLnB1c2goc2lfY29pbik7XG5cdFx0XHR9XG5cblx0XHRcdGNfYmFsYW5jZXMgKz0gMTtcblxuXHRcdFx0YV9vdXRzLnB1c2goW1xuXHRcdFx0XHRzaV9jb2luLFxuXHRcdFx0XHQkeXdfY2hhaW4uY29pbnNbc2lfY29pbl0sXG5cdFx0XHRcdGdfYnVuZGxlPy5iYWxhbmNlIHx8IHthbW91bnQ6JzAnLCBkZW5vbTpnX2NvaW4uZGVub219LFxuXHRcdFx0XHRhc3luYyh6X291dDogUHJvbWlzYWJsZTxCaWdOdW1iZXI+KTogUHJvbWlzZTxCaWdOdW1iZXI+ID0+IHtcblx0XHRcdFx0XHRjb25zdCB5Z19iYWxhbmNlID0gYXdhaXQgel9vdXQ7XG5cblx0XHRcdFx0XHR5Z190b3RhbCA9IHlnX3RvdGFsLnBsdXMoeWdfYmFsYW5jZSk7XG5cblx0XHRcdFx0XHRjaGVja190b3RhbCgpO1xuXHRcdFx0XHRcdHJldHVybiB5Z19iYWxhbmNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0aWYoIWFfb3V0cy5sZW5ndGgpIHtcblx0XHRcdGNfYmFsYW5jZXMgKz0gMTtcblx0XHRcdGNoZWNrX3RvdGFsKCk7XG5cdFx0fVxuXG5cdFx0YV9ub19nYXMgPSBhX25vX2dhcztcblxuXHRcdHJldHVybiBhX291dHM7XG5cdH1cblxuXG5cdGNvbnN0IEhfRkFVQ0VUUyA9IHtcblx0XHQndGhldGEtdGVzdG5ldC0wMDEnOiAnaHR0cHM6Ly9kaXNjb3JkLmNvbS9jaGFubmVscy82NjkyNjgzNDc3MzY2ODY2MTIvOTUzNjk3NzkzNDc2ODIxMDkyJyxcblx0XHQncHVsc2FyLTInOiAnaHR0cHM6Ly9mYXVjZXQuc2VjcmV0dGVzdG5ldC5pby8nLFxuXHR9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdC50ZXN0bmV0LXJlbWluZGVyIHtcblx0XHQuZm9udCh0aW55KTtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHR0cmFuc2Zvcm06IHNjYWxlWCgxLjI1KTtcblx0XHRtYXJnaW4tYm90dG9tOiBjYWxjKDBweCAtIHZhcigtLXVpLXBhZGRpbmcpIC0gdmFyKC0taW5saW5lLXBhZGRpbmcpKTtcblx0fVxuXG5cdC5zdWJpbmZvIHtcblx0XHRib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRwYWRkaW5nLXRvcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdH1cblxuXHQubm8tZ2FzIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0Z2FwOiB2YXIoLS1pbmxpbmUtcGFkZGluZyk7XG5cdFx0Lm1lc3NhZ2Uge1xuXHRcdFx0LmZvbnQodGlueSk7XG5cdFx0fVxuXHR9XG5cblx0Lm93bmVyLWFkZHJlc3Mge1xuXHR9XG5cbjwvc3R5bGU+XG5cbjxTY3JlZW4gZGVidWc9J0hvbGRpbmdzSG9tZScgbmF2IHJvb3Qga2V5ZWQ+XG5cblx0PEhlYWRlciBzZWFyY2ggbmV0d29yayBhY2NvdW50ID5cblx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJ0aXRsZVwiPlxuXG5cdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdDwvSGVhZGVyPlxuXG5cdHsjaWYgJHl3X2NoYWluLnRlc3RuZXR9XG5cdFx0PGRpdiBjbGFzcz1cInRlc3RuZXQtcmVtaW5kZXIgbm8tbWFyZ2luXCI+XG5cdFx0XHRURVNUTkVUXG5cdFx0PC9kaXY+XG5cdHsvaWZ9XG5cblx0PCEtLSB0aXRsZT17Zm9ybWF0X2ZpYXQoeF91c2RfYmFsYW5jZSl9IC0tPlxuXHQ8UG9ydHJhaXRcblx0XHRub1BmcFxuXHRcdHRpdGxlPXtkcF90b3RhbH1cblx0XHRzdWJ0aXRsZT17JHl3X2FjY291bnQubmFtZX1cblx0XHRyZXNvdXJjZT17JHl3X2FjY291bnR9XG5cdFx0cmVzb3VyY2VQYXRoPXskeXdfYWNjb3VudF9yZWZ9XG5cdFx0YWN0aW9ucz17e1xuXHRcdFx0c2VuZDoge1xuXHRcdFx0XHRsYWJlbDogJ1NlbmQnLFxuXHRcdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRcdGNyZWF0b3I6IFNlbmQsXG5cdFx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0XHRmcm9tOiAkeXdfYWNjb3VudCxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdFx0cmVjdjoge1xuXHRcdFx0XHRsYWJlbDogJ1JlY2VpdmUnLFxuXHRcdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRcdHBvcHVwX3JlY2VpdmUoJHl3X2FjY291bnRfcmVmKTtcblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cdFx0XHQvLyBhZGQ6IHtcblx0XHRcdC8vIFx0bGFiZWw6ICdBZGQgVG9rZW4nLFxuXHRcdFx0Ly8gXHR0cmlnZ2VyKCkge1xuXHRcdFx0Ly8gXHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdC8vIFx0XHRcdGNyZWF0b3I6IFRva2Vuc0FkZCxcblx0XHRcdC8vIFx0XHR9KTtcblx0XHRcdC8vIFx0fSxcblx0XHRcdC8vIH0sXG5cdFx0fX1cblx0Lz5cblxuXHR7I2tleSAkeXdfY2hhaW59XG5cdFx0eyNpZiBhX25vX2dhcy5sZW5ndGh9XG5cdFx0XHQ8ZGl2IGNsYXNzPVwibm8tZ2FzIHRleHQtYWxpZ25fY2VudGVyIHN1YmluZm9cIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cIm1lc3NhZ2VcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5XYXJuaW5nOjwvc3Bhbj4geW91IGRvbid0IGhhdmUgYW55IHskeXdfY2hhaW4udGVzdG5ldD8gJ3Rlc3RuZXQgJzonJ317YV9ub19nYXMuam9pbignIG9yICcpfSB0byBwYXkgZ2FzIGZlZXMuXG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJidXR0b25zXCI+XG5cdFx0XHRcdFx0eyNpZiAkeXdfY2hhaW4udGVzdG5ldH1cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJwaWxsXCIgb246Y2xpY2s9eygpID0+IG9wZW5fZXh0ZXJuYWxfbGluayhIX0ZBVUNFVFNbJHl3X2NoYWluLmlkXSl9PkdldCB7YV9ub19nYXMuam9pbignIG9yICcpfSBmcm9tIGZhdWNldDwvYnV0dG9uPlxuXHRcdFx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJwaWxsXCI+QnV5IHthX25vX2dhcy5qb2luKCcgb3IgJyl9PC9idXR0b24+XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHR7L2lmfVxuXG5cdFx0PGRpdiBjbGFzcz1cIm93bmVyLWFkZHJlc3Mgc3ViaW5mb1wiPlxuXHRcdFx0PEFkZHJlc3MgYWRkcmVzcz17JHl3X293bmVyfSBjb3B5YWJsZT0naWNvbicgLz5cblx0XHQ8L2Rpdj5cblx0ey9rZXl9XG5cblxuXHQ8R2FwIC8+XG5cblx0PCEtLSB7I2tleSBhX2hvbGRpbmdzfVxuXHRcdDxIb2xkaW5nc0xpc3QgaG9sZGluZ3M9e2FfaG9sZGluZ3N9IC8+XG5cdHsva2V5fSAtLT5cblxuXHR7I2tleSAkeXdfbmV0d29ya19hY3RpdmV9XG5cdFx0PGRpdiBjbGFzcz1cInJvd3Mgbm8tbWFyZ2luXCI+XG5cdFx0XHQ8IS0tIG5hdGl2ZSBjb2luKHMpIC0tPlxuXHRcdFx0eyNhd2FpdCBsb2FkX25hdGl2ZV9iYWxhbmNlcygpfVxuXHRcdFx0XHR7I2VhY2ggb2RlKCR5d19jaGFpbi5jb2lucykgYXMgW3NpX2NvaW4sIGdfYnVuZGxlXX1cblx0XHRcdFx0XHR7QGNvbnN0IHBfZW50aXR5ID0gRW50aXRpZXMuaG9sZGluZ1BhdGhGb3IoJHl3X293bmVyLCBzaV9jb2luKX1cblx0XHRcdFx0XHQ8Um93IGxvY2tJY29uIGRldGFpbD0nTmF0aXZlIENvaW4nXG5cdFx0XHRcdFx0XHRuYW1lPXtzaV9jb2lufVxuXHRcdFx0XHRcdFx0cGZwPXskeXdfY2hhaW4ucGZwfVxuXHRcdFx0XHRcdFx0YW1vdW50PXtmb3JldmVyKCcnKX1cblx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRjcmVhdG9yOiBIb2xkaW5nVmlldyxcblx0XHRcdFx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW50aXR5UmVmOiBwX2VudGl0eSxcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0ey9lYWNofVxuXHRcdFx0ezp0aGVuIGFfYmFsYW5jZXN9XG5cdFx0XHRcdHsjZWFjaCBhX2JhbGFuY2VzIGFzIFtzaV9jb2luLCBnX2NvaW4sIGdfYmFsYW5jZSwgZl9zdWJtaXRdfVxuXHRcdFx0XHR7QGNvbnN0IHBfZW50aXR5ID0gRW50aXRpZXMuaG9sZGluZ1BhdGhGb3IoJHl3X293bmVyLCBzaV9jb2luKX1cblx0XHRcdFx0XHR7QGNvbnN0IGdfcmVzb3VyY2UgPSB7XG5cdFx0XHRcdFx0XHRuYW1lOiBzaV9jb2luLFxuXHRcdFx0XHRcdFx0cGZwOiAkeXdfY2hhaW4ucGZwLFxuXHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0e0Bjb25zdCBkcF93b3J0aCA9IGZfc3VibWl0KHRvX2ZpYXQoZ19iYWxhbmNlLCBnX2NvaW4pKX1cblx0XHRcdFx0XHQ8Um93IGxvY2tJY29uIGRldGFpbD0nTmF0aXZlIENvaW4nXG5cdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg9e3BfZW50aXR5fVxuXHRcdFx0XHRcdFx0cmVzb3VyY2U9e2dfcmVzb3VyY2V9XG5cdFx0XHRcdFx0XHRhbW91bnQ9e2FzX2Ftb3VudChnX2JhbGFuY2UsIGdfY29pbil9XG5cdFx0XHRcdFx0XHRmaWF0PXtkcF93b3J0aC50aGVuKHlnID0+IGZvcm1hdF9maWF0KHlnLnRvTnVtYmVyKCksICd1c2QnKSl9XG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0Y3JlYXRvcjogSG9sZGluZ1ZpZXcsXG5cdFx0XHRcdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGVudGl0eVJlZjogcF9lbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHsvYXdhaXR9XG5cblxuXHRcdFx0eyNhd2FpdCBFbnRpdGllcy5yZWFkRnVuZ2libGVUb2tlbnMoJHl3X2NoYWluKX1cblx0XHRcdFx0TG9hZGluZyB0b2tlbnMuLi5cblx0XHRcdHs6dGhlbiBoX2Z1bmdpYmxlc31cblx0XHRcdFx0eyNlYWNoIG9kZShtZXJnZV9mdW5naWJsZV90b2tlbnMoaF9mdW5naWJsZXMpKSBhcyBbcF90b2tlbiwgZ190b2tlbl19XG5cdFx0XHRcdFx0e2dfdG9rZW4uc3BlY31cblx0XHRcdFx0ey9lYWNofVxuXHRcdFx0ey9hd2FpdH1cblx0XHQ8L2Rpdj5cblx0ey9rZXl9XG48L1NjcmVlbj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCB0eXBlIHsgQ29tcGxldGVkIH0gZnJvbSAnIy9lbnRyeS9mbG93JztcblxuXHRpbXBvcnQgdHlwZSB7QWNjb3VudCwgQWNjb3VudFBhdGh9IGZyb20gJyMvbWV0YS9hY2NvdW50Jztcblx0aW1wb3J0IHR5cGUge0JlY2gzMn0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IHtBY2NvdW50c30gZnJvbSAnIy9zdG9yZS9hY2NvdW50cyc7XG5cdGltcG9ydCB7Q2hhaW5zfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7eXdfYWNjb3VudF9yZWYsIHl3X2NoYWlufSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi4vdWkvQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgRmllbGQgZnJvbSAnLi4vdWkvRmllbGQuc3ZlbHRlJztcblx0aW1wb3J0IElubGluZVRhZ3MgZnJvbSAnLi4vdWkvSW5saW5lVGFncy5zdmVsdGUnO1xuXHRpbXBvcnQgSW5mbyBmcm9tICcjIy91aS9JbmZvLnN2ZWx0ZSc7XG5cdGltcG9ydCB7U2NyZWVuLCB0eXBlIFBhZ2V9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cblx0ZXhwb3J0IGxldCBhY2NvdW50OiBBY2NvdW50UGF0aDtcblx0Y29uc3QgcF9hY2NvdW50ID0gYWNjb3VudDtcblxuXHRsZXQgZ19hY2NvdW50OiBBY2NvdW50WydpbnRlcmZhY2UnXTtcblxuXHRsZXQgc19uYW1lID0gJyc7XG5cdGxldCBzYV9hY2NvdW50OiBCZWNoMzIuU3RyaW5nO1xuXG5cdCQ6IGJfZm9ybV92YWxpZCA9ICEhc19uYW1lO1xuXG5cdCQ6IHNhX2FjY291bnQgPSBnX2FjY291bnQ/IENoYWlucy5hZGRyZXNzRm9yKGdfYWNjb3VudC5wdWJrZXksICR5d19jaGFpbik6ICcnO1xuXG5cdGNvbnN0IGNvbXBsZXRlZCA9IGdldENvbnRleHQ8Q29tcGxldGVkIHwgdW5kZWZpbmVkPignY29tcGxldGVkJyk7XG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX2FjY291bnQoKSB7XG5cdFx0Y29uc3Qga3NfYWNjb3VudHMgPSBhd2FpdCBBY2NvdW50cy5yZWFkKCk7XG5cdFx0Z19hY2NvdW50ID0ga3NfYWNjb3VudHMuYXQocF9hY2NvdW50KSE7XG5cdFx0c19uYW1lID0gZ19hY2NvdW50Lm5hbWU7XG5cdH1cblxuXHRhc3luYyBmdW5jdGlvbiBzYXZlX2FjY291bnQoKSB7XG5cdFx0T2JqZWN0LmFzc2lnbihnX2FjY291bnQsIHtcblx0XHRcdG5hbWU6IHNfbmFtZSxcblx0XHR9KTtcblxuXHRcdGF3YWl0IEFjY291bnRzLm9wZW4oa3NfYWNjb3VudHMgPT4ga3NfYWNjb3VudHMucHV0KGdfYWNjb3VudCkpO1xuXG5cdFx0Ly8gZWRpdHRlZCBhY3RpdmUgYWNjb3VudDsgcmVsb2FkXG5cdFx0aWYocF9hY2NvdW50ID09PSAkeXdfYWNjb3VudF9yZWYpIHtcblx0XHRcdCR5d19hY2NvdW50X3JlZiA9IHBfYWNjb3VudDtcblx0XHR9XG5cblx0XHRpZihjb21wbGV0ZWQpIHtcblx0XHRcdGNvbXBsZXRlZCh0cnVlKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRrX3BhZ2UucmVzZXQoKTtcblx0XHR9XG5cdH1cblxuXHQvLyBmdW5jdGlvbiBzYXZlKCkge1xuXHQvLyBcdGlmKCFiX2Zvcm1fdmFsaWQpIHJldHVybjtcblxuXHQvLyBcdGNvbnN0IGdfc2F2ZSA9IHtcblx0Ly8gXHRcdGxhYmVsOiBhY2NvdW50TmFtZSxcblx0Ly8gXHRcdHRhZ1JlZnM6IGFfdGFncy5tYXAoayA9PiBrLmRlZi5pcmkpLFxuXHQvLyBcdH07XG5cblx0Ly8gXHRpZihhY2NvdW50KSB7XG5cdC8vIFx0XHRPYmplY3QuYXNzaWduKGFjY291bnQuZGVmLCBnX3NhdmUpO1xuXG5cdC8vIFx0XHRyZXN0YXJ0KCk7XG5cblx0Ly8gXHRcdGlmKFRhc2tzLkFERF9UQUcgPT09ICR5d190YXNrKSB7XG5cdC8vIFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHQvLyBcdFx0XHRcdCR5d190YXNrID0gLSR5d190YXNrO1xuXHQvLyBcdFx0XHR9LCAxMjAwKTtcblx0Ly8gXHRcdH1cblx0Ly8gXHR9XG5cdC8vIFx0ZWxzZSB7XG5cdC8vIFx0XHRjb25zdCBnZF9hY2NvdW50ID0gQWNjb3VudC5EZWYuZnJvbUNvbmZpZyh7XG5cdC8vIFx0XHRcdC4uLmdfc2F2ZSxcblx0Ly8gXHRcdFx0cHVia2V5OiBzYV9hY2NvdW50LnJlcGxhY2UoL15cXHcrMS9nLCAnJyksXG5cdC8vIFx0XHRcdGljb25SZWY6IHBfaWNvbixcblx0Ly8gXHRcdH0pO1xuXG5cdC8vIFx0XHRjb25zdCBrX2FjY291bnQgPSBIX0FDQ09VTlRTW2dkX2FjY291bnQuaXJpXSA9IG5ldyBBY2NvdW50KGdkX2FjY291bnQpO1xuXG5cdC8vIFx0XHRyZXN0YXJ0KCk7XG5cblx0Ly8gXHRcdHB1c2hfc2NyZWVuKEFjY291bnRWaWV3LCB7XG5cdC8vIFx0XHRcdGFjY291bnQ6IGtfYWNjb3VudCxcblx0Ly8gXHRcdH0pO1xuXHQvLyBcdH1cblx0Ly8gfVxuXG48L3NjcmlwdD5cblxuPFNjcmVlbj5cblx0PGgzPlxuXHRcdHthY2NvdW50PyAnRWRpdCc6ICdOZXcnfSBhY2NvdW50XG5cdDwvaDM+XG5cblx0eyNhd2FpdCBsb2FkX2FjY291bnQoKX1cblx0XHRMb2FkaW5nIGFjY291bnRzLi4uXG5cdHs6dGhlbn1cblx0XHQ8RmllbGQga2V5PVwicHJvZmlsZS1pY29uXCIgbmFtZT1cIlByb2ZpbGUgaWNvblwiPlxuXHRcdFx0PCEtLSA8SWNvbkVkaXRvciBpbnRlbnQ9J3BlcnNvbicgaWNvblJlZj17cF9pY29ufSAvPiAtLT5cblx0XHQ8L0ZpZWxkPlxuXG5cdFx0PEZpZWxkIGtleT1cImFjY291bnQtbmFtZVwiIG5hbWU9XCJOYW1lXCI+XG5cdFx0XHQ8aW5wdXQgaWQ9XCJhY2NvdW50LW5hbWVcIiB0eXBlPVwidGV4dFwiIGJpbmQ6dmFsdWU9e3NfbmFtZX0gcGxhY2Vob2xkZXI9XCJTYXRvc2hpXCI+XG5cdFx0PC9GaWVsZD5cblxuXHRcdDwhLS0gPEZpZWxkIGtleT1cImFjY291bnQtcGF0aFwiIG5hbWU9XCJEZXJpdmF0aW9uIHBhdGhcIj5cblx0XHRcdDxJbmZvIGtleT1cImFjY291bnQtcGF0aFwiPlxuXHRcdFx0XHRtLzQ0Jy8xMTgnLzAnLzAve09iamVjdC52YWx1ZXMoSF9BQ0NPVU5UUykubGVuZ3RofVxuXHRcdFx0PC9JbmZvPlxuXHRcdDwvRmllbGQ+IC0tPlxuXG5cdFx0PEZpZWxkIGtleT1cImFjY291bnQtYWRkcmVzc1wiIG5hbWU9XCJQdWJsaWMgYWRkcmVzc1wiPlxuXHRcdFx0PEluZm8gYWRkcmVzcyBrZXk9XCJhY2NvdW50LWFkZHJlc3NcIj5cblx0XHRcdFx0PEFkZHJlc3MgY29weWFibGUgYWRkcmVzcz17c2FfYWNjb3VudH0gLz5cblx0XHRcdDwvSW5mbz5cblx0XHQ8L0ZpZWxkPlxuPCEtLSBcblx0XHQ8RmllbGQga2V5PVwiYWNjb3VudC10YWdzXCIgbmFtZT1cIkFkZCB0YWdzXCI+XG5cdFx0XHQ8SW5saW5lVGFncyBlZGl0YWJsZSByZXNvdXJjZVBhdGg9e3BfYWNjb3VudH0gLz5cblx0XHQ8L0ZpZWxkPiAtLT5cblxuXHRcdDxBY3Rpb25zTGluZSBjYW5jZWw9eyFjb21wbGV0ZWR9IGJhY2sgY29uZmlybT17WydGaW5pc2gnLCBzYXZlX2FjY291bnQsICFiX2Zvcm1fdmFsaWRdfSAvPlxuXG5cdFx0PCEtLSA8ZGl2IGNsYXNzPVwiYWN0aW9uLWxpbmUgY2xpY2thYmxlXCI+XG5cdFx0XHQ8YnV0dG9uIG9uOmNsaWNrPXsoKSA9PiBwb3AoKX0+XG5cdFx0XHRcdENhbmNlbFxuXHRcdFx0PC9idXR0b24+XG5cblx0XHRcdDxidXR0b24gY2xhc3M9XCJwcmltYXJ5XCIgcmVhZG9ubHk9eyFiX2Zvcm1fdmFsaWR9IG9uOmNsaWNrPXsoKSA9PiBzYXZlKCl9PlxuXHRcdFx0XHRGaW5pc2hcblx0XHRcdDwvYnV0dG9uPlxuXHRcdDwvZGl2PiAtLT5cblx0ey9hd2FpdH1cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHtBY2NvdW50LCBBY2NvdW50UGF0aH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXHRpbXBvcnQge0FjY291bnRzfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHtDaGFpbnN9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblxuXHRpbXBvcnQge2dldENvbnRleHR9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7cG9wdXBfcmVjZWl2ZX0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi4vdWkvQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgUG9ydHJhaXQgZnJvbSAnLi4vdWkvUG9ydHJhaXQuc3ZlbHRlJztcblx0aW1wb3J0IEFjY291bnRFZGl0IGZyb20gJy4vQWNjb3VudEVkaXQuc3ZlbHRlJztcblx0aW1wb3J0IFNlbmQgZnJvbSAnLi9TZW5kLnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHtcblx0XHRTY3JlZW4sXG5cdFx0SGVhZGVyLFxuXHRcdHR5cGUgUGFnZSxcblx0fSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRleHBvcnQgbGV0IGFjY291bnRSZWY6IEFjY291bnRQYXRoO1xuXHRjb25zdCBwX2FjY291bnQgPSBhY2NvdW50UmVmO1xuXG5cdGxldCBnX2FjY291bnQ6IEFjY291bnRbJ2ludGVyZmFjZSddO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYWNjb3VudCgpOiBQcm9taXNlPEFjY291bnRbJ2ludGVyZmFjZSddPiB7XG5cdFx0Y29uc3Qga3NfYWNjb3VudHMgPSBhd2FpdCBBY2NvdW50cy5yZWFkKCk7XG5cblx0XHRyZXR1cm4gZ19hY2NvdW50ID0ga3NfYWNjb3VudHMuYXQocF9hY2NvdW50KSE7XG5cdH1cblxuXHRjb25zdCBnY19hY3Rpb25zID0ge1xuXHRcdHNlbmQ6IHtcblx0XHRcdGxhYmVsOiAnU2VuZCcsXG5cdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogU2VuZCxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0ZnJvbTogQ2hhaW5zLmFkZHJlc3NGb3IoZ19hY2NvdW50LnB1YmtleSksXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0cmVjdjoge1xuXHRcdFx0bGFiZWw6ICdSZWNlaXZlJyxcblx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdHBvcHVwX3JlY2VpdmUocF9hY2NvdW50KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHRlZGl0OiB7XG5cdFx0XHRsYWJlbDogJ0VkaXQnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IEFjY291bnRFZGl0LFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRhY2NvdW50OiBwX2FjY291bnQsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdH07XG5cbjwvc2NyaXB0PlxuXG48IS0tIFxuPHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicGZwXCI+XG5cdHsjaWYgSF9JQ09OU1thY2NvdW50LmRlZi5pY29uUmVmXX1cblx0XHQ8UHV0IGVsZW1lbnQ9e0hfSUNPTlNbYWNjb3VudC5kZWYuaWNvblJlZl0ucmVuZGVyKCl9IC8+XG5cdHs6ZWxzZX1cblx0XHQ8c3BhbiBjbGFzcz1cInBmcC1nZW5cIj5cblx0XHRcdHthY2NvdW50LmRlZi5sYWJlbFswXX1cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG48L3N2ZWx0ZTpmcmFnbWVudD4gLS0+XG5cbjxTY3JlZW4gbmF2PlxuXHQ8SGVhZGVyIHBvcHMgc2VhcmNoIG5ldHdvcmtcblx0XHR0aXRsZT1cIkFjY291bnRcIlxuXHQ+PC9IZWFkZXI+XG5cblx0eyNhd2FpdCBsb2FkX2FjY291bnQoKX1cblx0XHRMb2FkaW5nLi4uXG5cdHs6dGhlbn1cblx0XHQ8UG9ydHJhaXRcblx0XHRcdHJlc291cmNlPXtnX2FjY291bnR9XG5cdFx0XHRyZXNvdXJjZVBhdGg9e3BfYWNjb3VudH1cblx0XHRcdGFjdGlvbnM9e2djX2FjdGlvbnN9XG5cdFx0PlxuXHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwic3VidGl0bGVcIj5cblx0XHRcdFx0PEFkZHJlc3MgY29weWFibGUgYWRkcmVzcz17Q2hhaW5zLmFkZHJlc3NGb3IoZ19hY2NvdW50LnB1YmtleSl9IC8+XG5cdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHQ8L1BvcnRyYWl0PlxuXHR7L2F3YWl0fVxuXG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgdHlwZSB7IEFjY291bnQsIEFjY291bnRQYXRoIH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IHl3X2NoYWluIH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi4vdWkvQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgUm93IGZyb20gJy4uL3VpL1Jvdy5zdmVsdGUnO1xuXHRpbXBvcnQgQWNjb3VudENyZWF0ZSBmcm9tICcuL0FjY291bnRDcmVhdGUuc3ZlbHRlJztcblx0aW1wb3J0IEFjY291bnRWaWV3IGZyb20gJy4vQWNjb3VudFZpZXcuc3ZlbHRlJztcblxuXHRpbXBvcnQge1xuXHRcdFNjcmVlbixcblx0XHRIZWFkZXIsXG5cdFx0U3ViSGVhZGVyLFxuXHRcdHR5cGUgUGFnZSxcblx0fSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0bGV0IGFfYWNjb3VudHM6IFtBY2NvdW50UGF0aCwgQWNjb3VudFsnaW50ZXJmYWNlJ11dW107XG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYWNjb3VudHMoKTogUHJvbWlzZTx0eXBlb2YgYV9hY2NvdW50cz4ge1xuXHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXG5cdFx0cmV0dXJuIGFfYWNjb3VudHMgPSBrc19hY2NvdW50cy5lbnRyaWVzKCk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQuaGQtcGF0aCB7XG5cdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdBY2NvdW50cycgbmF2IHJvb3Q+XG5cdDxIZWFkZXIgc2VhcmNoIG5ldHdvcmsgYWNjb3VudFxuXHQ+XG5cdDwvSGVhZGVyPlxuXG5cdDxTdWJIZWFkZXJcblx0XHR0aXRsZT1cIkFjY291bnRzXCJcblx0Lz5cblx0XHQ8IS0tIG9uOmFkZF9uZXc9eygpID0+IGtfcGFnZS5wdXNoKHtcblx0XHRcdGNyZWF0b3I6IEFjY291bnRDcmVhdGUsXG5cdFx0fSl9IC0tPlxuXG5cdDxkaXYgY2xhc3M9XCJyb3dzIG5vLW1hcmdpblwiPlxuXHRcdHsjYXdhaXQgbG9hZF9hY2NvdW50cygpfVxuXHRcdFx0TG9hZGluZy4uLlxuXHRcdHs6dGhlbn1cblx0XHRcdHsja2V5ICR5d19jaGFpbn1cblx0XHRcdFx0eyNlYWNoIGFfYWNjb3VudHMgYXMgW3BfYWNjb3VudCwgZ19hY2NvdW50XX1cblx0XHRcdFx0XHR7QGNvbnN0IHNhX293bmVyID0gQ2hhaW5zLmFkZHJlc3NGb3IoZ19hY2NvdW50LnB1YmtleSl9XG5cdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0cmVzb3VyY2U9e2dfYWNjb3VudH1cblx0XHRcdFx0XHRcdHJlc291cmNlUGF0aD17cF9hY2NvdW50fVxuXHRcdFx0XHRcdFx0YWRkcmVzcz17c2Ffb3duZXJ9XG5cdFx0XHRcdFx0XHRpY29uQ2xhc3M9eydzcXVhcmUgcGZwJ31cblx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiBrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdGNyZWF0b3I6IEFjY291bnRWaWV3LFxuXHRcdFx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0XHRcdGFjY291bnRSZWY6IHBfYWNjb3VudCxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH0pfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cImRldGFpbFwiPlxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaGQtcGF0aFwiPlxuXHRcdFx0XHRcdFx0XHRcdFN0YXJTaGVsbCAtIC0gbS80NCcvMTE4Jy8wJy8wLz8/XG5cdFx0XHRcdFx0XHRcdFx0PCEtLSBTdGFyU2hlbGwgLSBtLzQ0Jy8xMTgnLzAnLzAveytnX2FjY291bnQuaWQtMX0gLS0+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9e3NhX293bmVyfSAvPlxuXHRcdFx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdFx0XHRcdFx0PC9Sb3c+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHsva2V5fVxuXHRcdHsvYXdhaXR9XG5cdDwvZGl2PlxuPC9TY3JlZW4+IiwibGV0IGlkID0gMTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SWQoKSB7XG4gIHJldHVybiBgc3ZlbHRlLXRhYnMtJHtpZCsrfWA7XG59XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cbiAgZXhwb3J0IGNvbnN0IFRBQlMgPSB7fTtcbjwvc2NyaXB0PlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSwgc2V0Q29udGV4dCwgb25EZXN0cm95LCBvbk1vdW50LCB0aWNrIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuXG4gIGV4cG9ydCBsZXQgaW5pdGlhbFNlbGVjdGVkSW5kZXggPSAwO1xuXG4gIGNvbnN0IHRhYkVsZW1lbnRzID0gW107XG4gIGNvbnN0IHRhYnMgPSBbXTtcbiAgY29uc3QgcGFuZWxzID0gW107XG5cbiAgY29uc3QgY29udHJvbHMgPSB3cml0YWJsZSh7fSk7XG4gIGNvbnN0IGxhYmVsZWRCeSA9IHdyaXRhYmxlKHt9KTtcblxuICBjb25zdCBzZWxlY3RlZFRhYiA9IHdyaXRhYmxlKG51bGwpO1xuICBjb25zdCBzZWxlY3RlZFBhbmVsID0gd3JpdGFibGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kVXBkYXRlU2VsZWN0ZWQoYXJyLCBpdGVtLCBzZWxlY3RlZFN0b3JlKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBzZWxlY3RlZFN0b3JlLnVwZGF0ZShzZWxlY3RlZCA9PiBzZWxlY3RlZCA9PT0gaXRlbSA/IChhcnJbaW5kZXhdIHx8IGFyclthcnIubGVuZ3RoIC0gMV0pIDogc2VsZWN0ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJJdGVtKGFyciwgaXRlbSwgc2VsZWN0ZWRTdG9yZSkge1xuICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgIHNlbGVjdGVkU3RvcmUudXBkYXRlKHNlbGVjdGVkID0+IHNlbGVjdGVkIHx8IGl0ZW0pO1xuICAgIG9uRGVzdHJveSgoKSA9PiByZW1vdmVBbmRVcGRhdGVTZWxlY3RlZChhcnIsIGl0ZW0sIHNlbGVjdGVkU3RvcmUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdFRhYih0YWIpIHtcbiAgICBjb25zdCBpbmRleCA9IHRhYnMuaW5kZXhPZih0YWIpO1xuICAgIHNlbGVjdGVkVGFiLnNldCh0YWIpO1xuICAgIHNlbGVjdGVkUGFuZWwuc2V0KHBhbmVsc1tpbmRleF0pO1xuICB9XG5cbiAgc2V0Q29udGV4dChUQUJTLCB7XG4gICAgcmVnaXN0ZXJUYWIodGFiKSB7XG4gICAgICByZWdpc3Rlckl0ZW0odGFicywgdGFiLCBzZWxlY3RlZFRhYik7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyVGFiRWxlbWVudCh0YWJFbGVtZW50KSB7XG4gICAgICB0YWJFbGVtZW50cy5wdXNoKHRhYkVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICByZWdpc3RlclBhbmVsKHBhbmVsKSB7XG4gICAgICByZWdpc3Rlckl0ZW0ocGFuZWxzLCBwYW5lbCwgc2VsZWN0ZWRQYW5lbCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRhYixcblxuICAgIHNlbGVjdGVkVGFiLFxuICAgIHNlbGVjdGVkUGFuZWwsXG5cbiAgICBjb250cm9scyxcbiAgICBsYWJlbGVkQnlcbiAgfSk7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgc2VsZWN0VGFiKHRhYnNbaW5pdGlhbFNlbGVjdGVkSW5kZXhdKTtcbiAgfSk7XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgY29udHJvbHMudXBkYXRlKGNvbnRyb2xzRGF0YSA9PiAoey4uLmNvbnRyb2xzRGF0YSwgW3RhYnNbaV0uaWRdOiBwYW5lbHNbaV0uaWR9KSk7XG4gICAgICBsYWJlbGVkQnkudXBkYXRlKGxhYmVsZWRCeURhdGEgPT4gKHsuLi5sYWJlbGVkQnlEYXRhLCBbcGFuZWxzW2ldLmlkXTogdGFic1tpXS5pZH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnc3ZlbHRlLXRhYnNfX3RhYicpKSB7XG4gICAgICBsZXQgc2VsZWN0ZWRJbmRleCA9IHRhYnMuaW5kZXhPZigkc2VsZWN0ZWRUYWIpO1xuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlICdBcnJvd1JpZ2h0JzpcbiAgICAgICAgICBzZWxlY3RlZEluZGV4ICs9IDE7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPiB0YWJzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxlY3RUYWIodGFic1tzZWxlY3RlZEluZGV4XSk7XG4gICAgICAgICAgdGFiRWxlbWVudHNbc2VsZWN0ZWRJbmRleF0uZm9jdXMoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgIHNlbGVjdGVkSW5kZXggLT0gMTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSB0YWJzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGVjdFRhYih0YWJzW3NlbGVjdGVkSW5kZXhdKTtcbiAgICAgICAgICB0YWJFbGVtZW50c1tzZWxlY3RlZEluZGV4XS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJzdmVsdGUtdGFic1wiIG9uOmtleWRvd249e2hhbmRsZUtleURvd259PlxuICA8c2xvdD48L3Nsb3Q+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQsIG9uTW91bnQsIHRpY2sgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGltcG9ydCBnZXRJZCBmcm9tICcuL2lkJztcbiAgaW1wb3J0IHsgVEFCUyB9IGZyb20gJy4vVGFicy5zdmVsdGUnO1xuXG4gIGxldCB0YWJFbDtcblxuICBjb25zdCB0YWIgPSB7XG4gICAgaWQ6IGdldElkKClcbiAgfTtcbiAgY29uc3QgeyByZWdpc3RlclRhYiwgcmVnaXN0ZXJUYWJFbGVtZW50LCBzZWxlY3RUYWIsIHNlbGVjdGVkVGFiLCBjb250cm9scyB9ID0gZ2V0Q29udGV4dChUQUJTKTtcblxuICBsZXQgaXNTZWxlY3RlZDtcbiAgJDogaXNTZWxlY3RlZCA9ICRzZWxlY3RlZFRhYiA9PT0gdGFiO1xuXG4gIHJlZ2lzdGVyVGFiKHRhYik7XG5cbiAgb25Nb3VudChhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgdGljaygpO1xuICAgIHJlZ2lzdGVyVGFiRWxlbWVudCh0YWJFbCk7XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0LnN2ZWx0ZS10YWJzX190YWIge1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRib3JkZXItYm90dG9tOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0Y29sb3I6ICMwMDAwMDA7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgIHBhZGRpbmc6IDAuNWVtIDAuNzVlbTtcblx0fVxuXHRcbiAgLnN2ZWx0ZS10YWJzX190YWI6Zm9jdXMge1xuICAgIG91dGxpbmU6IHRoaW4gZG90dGVkO1xuICB9XG5cblx0LnN2ZWx0ZS10YWJzX19zZWxlY3RlZCB7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICM0RjgxRTU7XG4gICAgY29sb3I6ICM0RjgxRTU7XG5cdH1cbjwvc3R5bGU+XG5cbjxsaVxuICBiaW5kOnRoaXM9e3RhYkVsfVxuICByb2xlPVwidGFiXCJcbiAgaWQ9e3RhYi5pZH1cbiAgYXJpYS1jb250cm9scz17JGNvbnRyb2xzW3RhYi5pZF19XG4gIGFyaWEtc2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gIHRhYmluZGV4PVwie2lzU2VsZWN0ZWQgPyAwIDogLTF9XCJcbiAgY2xhc3M6c3ZlbHRlLXRhYnNfX3NlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICBjbGFzcz1cInN2ZWx0ZS10YWJzX190YWJcIlxuICBvbjpjbGljaz17KCkgPT4gc2VsZWN0VGFiKHRhYil9PlxuXHQ8c2xvdD48L3Nsb3Q+XG48L2xpPlxuIiwiPHN0eWxlPlxuXHQuc3ZlbHRlLXRhYnNfX3RhYi1saXN0IHtcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI0NDQ0NDQztcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcblx0fVxuPC9zdHlsZT5cblxuPHVsIHJvbGU9XCJ0YWJsaXN0XCIgY2xhc3M9XCJzdmVsdGUtdGFic19fdGFiLWxpc3RcIj5cbiAgPHNsb3Q+PC9zbG90PlxuPC91bD5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG4gIGltcG9ydCBnZXRJZCBmcm9tICcuL2lkJztcbiAgaW1wb3J0IHsgVEFCUyB9IGZyb20gJy4vVGFicy5zdmVsdGUnO1xuXG4gIGNvbnN0IHBhbmVsID0ge1xuICAgIGlkOiBnZXRJZCgpXG4gIH07XG4gIGNvbnN0IHsgcmVnaXN0ZXJQYW5lbCwgc2VsZWN0ZWRQYW5lbCwgbGFiZWxlZEJ5IH0gPSBnZXRDb250ZXh0KFRBQlMpO1xuXG4gIHJlZ2lzdGVyUGFuZWwocGFuZWwpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLnN2ZWx0ZS10YWJzX190YWItcGFuZWwge1xuICAgIG1hcmdpbi10b3A6IDAuNWVtO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2IFxuICBpZD17cGFuZWwuaWR9XG4gIGFyaWEtbGFiZWxsZWRieT17JGxhYmVsZWRCeVtwYW5lbC5pZF19XG4gIGNsYXNzPVwic3ZlbHRlLXRhYnNfX3RhYi1wYW5lbFwiXG4gIHJvbGU9XCJ0YWJwYW5lbFwiPlxuICB7I2lmICRzZWxlY3RlZFBhbmVsID09PSBwYW5lbH1cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIHsvaWZ9XG48L2Rpdj5cbiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCA0NDggNTEyXFxcIj48IS0tIEZvbnQgQXdlc29tZSBGcmVlIDUuMTUuNCBieSBAZm9udGF3ZXNvbWUgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbSBMaWNlbnNlIC0gaHR0cHM6Ly9mb250YXdlc29tZS5jb20vbGljZW5zZS9mcmVlIChJY29uczogQ0MgQlkgNC4wLCBGb250czogU0lMIE9GTCAxLjEsIENvZGU6IE1JVCBMaWNlbnNlKSAtLT48cGF0aCBkPVxcXCJNNjQgMjI0aDEzLjVjMjQuNyA1Ni41IDgwLjkgOTYgMTQ2LjUgOTZzMTIxLjgtMzkuNSAxNDYuNS05NkgzODRjOC44IDAgMTYtNy4yIDE2LTE2di05NmMwLTguOC03LjItMTYtMTYtMTZoLTEzLjVDMzQ1LjggMzkuNSAyODkuNiAwIDIyNCAwUzEwMi4yIDM5LjUgNzcuNSA5Nkg2NGMtOC44IDAtMTYgNy4yLTE2IDE2djk2YzAgOC44IDcuMiAxNiAxNiAxNnptNDAtODhjMC0yMi4xIDIxLjUtNDAgNDgtNDBoMTQ0YzI2LjUgMCA0OCAxNy45IDQ4IDQwdjI0YzAgNTMtNDMgOTYtOTYgOTZoLTQ4Yy01MyAwLTk2LTQzLTk2LTk2di0yNHptNzIgNzJsMTItMzYgMzYtMTItMzYtMTItMTItMzYtMTIgMzYtMzYgMTIgMzYgMTIgMTIgMzZ6bTE1MS42IDExMy40QzI5Ny43IDM0MC43IDI2Mi4yIDM1MiAyMjQgMzUycy03My43LTExLjMtMTAzLjYtMzAuNkM1Mi45IDMyOC41IDAgMzg1IDAgNDU0LjR2OS42YzAgMjYuNSAyMS41IDQ4IDQ4IDQ4aDgwdi02NGMwLTE3LjcgMTQuMy0zMiAzMi0zMmgxMjhjMTcuNyAwIDMyIDE0LjMgMzIgMzJ2NjRoODBjMjYuNSAwIDQ4LTIxLjUgNDgtNDh2LTkuNmMwLTY5LjQtNTIuOS0xMjUuOS0xMjAuNC0xMzN6TTI3MiA0NDhjLTguOCAwLTE2IDcuMi0xNiAxNnM3LjIgMTYgMTYgMTYgMTYtNy4yIDE2LTE2LTcuMi0xNi0xNi0xNnptLTk2IDBjLTguOCAwLTE2IDcuMi0xNiAxNnY0OGgzMnYtNDhjMC04LjgtNy4yLTE2LTE2LTE2elxcXCIvPjwvc3ZnPlwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblxuXHRpbXBvcnQgU1hfSUNPTl9BU1RST05BVVQgZnJvbSAnIy9pY29uL3VzZXItYXN0cm9uYXV0LnN2Zz9yYXcnO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHsgVGhyZWFkSWQgfSBmcm9tICcuLi9kZWYnO1xuXHRpbXBvcnQgeyB5d19uYXZpZ2F0b3IgfSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgdHlwZSB7IFBhZ2UgfSBmcm9tICcuLi9uYXYvcGFnZSc7XG5cdGltcG9ydCB7IFNjcmVlbiwgSGVhZGVyIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0ZXhwb3J0IGxldCByZXNldCA9IGZhbHNlO1xuXHRjb25zdCBiX3Jlc2V0ID0gcmVzZXQ7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGZ1bmN0aW9uIGNvbnQoKSB7XG5cdFx0aWYoYl9yZXNldCkge1xuXHRcdFx0a19wYWdlLnJlc2V0KCk7XG5cdFx0XHR2b2lkICR5d19uYXZpZ2F0b3IuYWN0aXZhdGVUaHJlYWQoVGhyZWFkSWQuVE9LRU5TKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRrX3BhZ2UucG9wKCk7XG5cdFx0fVxuXHR9XG5cdDwvc2NyaXB0PlxuXHRcblx0PHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdFx0Lmljb24ge1xuXHRcdFx0cGFkZGluZy10b3A6IDI1JTtcblx0XHR9XG5cdDwvc3R5bGU+XG5cdFxuXHQ8U2NyZWVuPlxuXHRcdDxIZWFkZXIgcG9wc1xuXHRcdFx0dGl0bGU9XCJOb3QgeWV0IGF2YWlsYWJsZVwiXG5cdFx0Lz5cblx0XG5cdFx0PGgzPlxuXHRcdFx0Tm90aGluZyB0byBzZWUgaGVyZSFcblx0XHQ8L2gzPlxuXHRcblx0XHQ8cD5cblx0XHRcdFRoaXMgc2NyZWVuIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuXG5cdFx0PC9wPlxuXHRcblx0XHQ8cD5cblx0XHRcdFBsZWFzZSBjb250aW51ZSBleHBsb3JpbmcgdGhlIGJldGEuXG5cdFx0PC9wPlxuXHRcblx0XHQ8Y2VudGVyPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdHtAaHRtbCBTWF9JQ09OX0FTVFJPTkFVVH1cblx0XHRcdDwvc3Bhbj5cblx0XHQ8L2NlbnRlcj5cblx0XG5cdFx0PGRpdiBjbGFzcz1cImFjdGlvbi1saW5lXCI+XG5cdFx0XHQ8YnV0dG9uIGNsYXNzPVwicHJpbWFyeVwiIG9uOmNsaWNrPXsoKSA9PiBjb250KCl9PlxuXHRcdFx0XHRDb250aW51ZVxuXHRcdFx0PC9idXR0b24+XG5cdFx0PC9kaXY+XG5cdDwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7eXdfYWNjb3VudCwgeXdfY2hhaW59IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdCwgQ29udGFjdFBhdGggfSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0XG5cdGltcG9ydCB7IEhlYWRlciwgdHlwZSBQYWdlLCBTY3JlZW4gfSBmcm9tICcuLi9zY3JlZW4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgQWRkcmVzcyBmcm9tICcjIy91aS9BZGRyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBQb3J0cmFpdCBmcm9tICcjIy91aS9Qb3J0cmFpdC5zdmVsdGUnO1xuXHRpbXBvcnQgU2VuZCBmcm9tICcjIy9zY3JlZW4vU2VuZC5zdmVsdGUnO1xuXHQvLyBpbXBvcnQgVHhuTGlzdCwgeyBUeG5Db250ZXh0IH0gZnJvbSAnIyMvdWkvVHhuTGlzdC5zdmVsdGUnO1xuXHRpbXBvcnQgQ29udGFjdEVkaXQgZnJvbSAnLi9Db250YWN0RWRpdC5zdmVsdGUnO1xuXHRpbXBvcnQgRGVhZEVuZCBmcm9tICcuL0RlYWRFbmQuc3ZlbHRlJztcblxuXG5cdGV4cG9ydCBsZXQgY29udGFjdFJlZjogQ29udGFjdFBhdGg7XG5cdGNvbnN0IHBfY29udGFjdCA9IGNvbnRhY3RSZWY7XG5cblx0bGV0IGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ107XG5cdHZvaWQgQWdlbnRzLmdldENvbnRhY3QocF9jb250YWN0KS50aGVuKGcgPT4gZ19jb250YWN0ID0gZyEpO1xuXG5cdCQ6IHNhX2NvbnRhY3QgPSBnX2NvbnRhY3Q/IENoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MpOiAnJztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0Y29uc3QgZ2NfYWN0aW9ucyA9IHtcblx0XHRzZW5kOiB7XG5cdFx0XHRsYWJlbDogJ1NlbmQnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IFNlbmQsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdHRvOiBDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHRlZGl0OiB7XG5cdFx0XHRsYWJlbDogJ0VkaXQnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IENvbnRhY3RFZGl0LFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRjb250YWN0UmVmOiBwX2NvbnRhY3QsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0ZGVsZXRlOiB7XG5cdFx0XHRsYWJlbDogJ0RlbGV0ZScsXG5cdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogRGVhZEVuZCxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdH07XG5cblx0Ly8gJDogYV90eG5zID0gQV9UWE5TLmZpbHRlcigoa190eG4pID0+IHtcblx0Ly8gXHRjb25zdCBnZF90eG4gPSBrX3R4bi5kZWY7XG5cblx0Ly8gXHRpZihzYV9jb250YWN0ID09PSBnZF90eG4uYWRkcmVzcykgcmV0dXJuIHRydWU7XG5cblx0Ly8gXHRjb25zdCBnX2Jhbmtpc2ggPSBrX3R4bi5iYW5raXNoKCR5d19hY2NvdW50LmFkZHJlc3MoJHl3X2NoYWluKSk7XG5cdC8vIFx0aWYoZ19iYW5raXNoKSB7XG5cdC8vIFx0XHRyZXR1cm4gc2FfY29udGFjdCA9PT0gZ19iYW5raXNoLmFkZHJlc3M7XG5cdC8vIFx0fVxuXG5cdC8vIFx0cmV0dXJuIGZhbHNlO1xuXHQvLyB9KTtcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblxuXG5cdC5wZnAtZ2VuIHtcblx0XHQuZm9udChodWdlLCBAc2l6ZTogMzBweCk7XG5cdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Ym9yZGVyLXJhZGl1czogMjAlO1xuXHRcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoZWxsaXBzZSBmYXJ0aGVzdC1zaWRlIGF0IGJvdHRvbSByaWdodCwgIzA3MDgwYSwgIzBmMTMxNyk7XG5cdH1cbjwvc3R5bGU+XG5cblxuPFNjcmVlbiBuYXYgc2xpZGVzPlxuXHQ8SGVhZGVyIHBvcHMgc2VhcmNoIG5ldHdvcmsgYWNjb3VudCAvPlxuXG5cdHsjaWYgIWdfY29udGFjdH1cblx0XHRMb2FkaW5nIGNvbnRhY3QuLi5cblx0ezplbHNlfVxuXHRcdDxQb3J0cmFpdFxuXHRcdFx0cmVzb3VyY2U9e2dfY29udGFjdH1cblx0XHRcdHJlc291cmNlUGF0aD17cF9jb250YWN0fVxuXHRcdFx0YWN0aW9ucz17Z2NfYWN0aW9uc31cblx0XHQ+XG5cdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0XHQ8QWRkcmVzcyBjb3B5YWJsZSBhZGRyZXNzPXtDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKX0gLz5cblx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PmFkZHJlc3Ncblx0XHQ8L1BvcnRyYWl0PlxuPCEtLSBcblx0XHQ8VHhuTGlzdFxuXHRcdFx0Y29udGV4dD17VHhuQ29udGV4dC5DT05UQUNUfVxuXHRcdFx0dHhucz17YV90eG5zfVxuXHRcdC8+IC0tPlxuXHQ8IS0tIFxuXHRcdDxkaXYgY2xhc3M9XCJ0eG5zIG5vLW1hcmdpblwiPlxuXHRcdFx0eyNpZiAhYV90eG5zLmxlbmd0aH1cblx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRObyB0cmFuc2FjdGlvbnMgeWV0XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9pZn1cblxuXHRcdFx0eyNlYWNoIGFfdHhucyBhcyBrX3R4bn1cblx0XHRcdFx0e0Bjb25zdCBnZF90eG4gPSBrX3R4bi5kZWZ9XG5cdFx0XHRcdHtAY29uc3Qga190b2tlbiA9IEhfQUREUkVTU19UT19UT0tFTltrX3R4bi5kZWYuYWRkcmVzc119XG5cdFx0XHRcdHtAY29uc3QgZ19iYW5raXNoID0ga190eG4uYmFua2lzaCgkeXdfYWNjb3VudC5hZGRyZXNzKCR5d19jaGFpbikpfVxuXHRcdFx0XHR7QGNvbnN0IGFfZGVidWcgPSBbZ19iYW5raXNoLCBrX3R4bl19XG5cdFx0XHRcdDwvIS0tIHtAZGVidWcgYV9kZWJ1Z30gLS0vPlxuXG5cdFx0XHRcdHsjaWYgVHhuLlR5cGUuUkVDViA9PT0gZ2RfdHhuLnR5cGV9XG5cdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0bmFtZT1cIlJlY2VpdmVkIFNDUlRcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0XHQ8LyEtLSBhcHByb3goZ2RfdHhuLmFtb3VudCkgLS0vPlxuXHRcdFx0XHR7OmVsc2UgaWYgVHhuLlR5cGUuU0VORCA9PT0gZ2RfdHhuLnR5cGV9XG5cdFx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdFx0bmFtZT1cIlNlbnQgU0NSVFwiXG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdDwvUm93PlxuXHRcdFx0XHR7L2lmfVxuXHRcdFx0ey9lYWNofVxuXHRcdDwvZGl2PiAtLT5cblx0ey9pZn1cblxuPC9TY3JlZW4+IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTkgNXYxNEg1VjVoMTRtMC0ySDVjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptLTQuODYgOC44Ni0zIDMuODdMOSAxMy4xNCA2IDE3aDEybC0zLjg2LTUuMTR6XFxcIi8+XFxuPC9zdmc+XCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgU1hfSUNPTl9JTUFHRSBmcm9tICcjL2ljb24vaW1hZ2Uuc3ZnP3Jhdyc7XG5cdGltcG9ydCB0eXBlIHsgUGZwLCBQZnBQYXRoIH0gZnJvbSAnIy9tZXRhL3BmcCc7XG5cdGltcG9ydCB7IFBmcHMgfSBmcm9tICcjL3N0b3JlL3BmcHMnO1xuXHRpbXBvcnQgeyBGX05PT1AgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IFBmcERpc3BsYXkgZnJvbSAnLi9QZnBEaXNwbGF5LnN2ZWx0ZSc7XG5cdFxuXHRleHBvcnQgbGV0IHBmcFJlZjogJycgfCBQZnBQYXRoO1xuXHRjb25zdCBwX3BmcCA9IHBmcFJlZiB8fCAnJztcblxuXHRleHBvcnQgbGV0IG5hbWUgPSAnJztcblx0Y29uc3Qgc19uYW1lID0gbmFtZTtcblxuXHRleHBvcnQgbGV0IGludGVudDogJ3Rva2VuJyB8ICdwZXJzb24nID0gJ3Rva2VuJztcblx0Y29uc3Qgc2lfaW50ZW50ID0gaW50ZW50O1xuXG5cdGxldCBnX3BmcDogUGZwWydpbnRlcmZhY2UnXTtcblxuXHQoYXN5bmMoKSA9PiB7XG5cdFx0aWYocF9wZnApIHtcblx0XHRcdGdfcGZwID0gKGF3YWl0IFBmcHMuYXQocF9wZnApKSE7XG5cdFx0fVxuXHR9KSgpO1xuXG5cdC8vIGNvbnN0IHBfaWNvbiA9IGljb25SZWYgfHwgSWNvbi5EZWYuQkxBTksuaXJpO1xuXG5cdC8vIGNvbnN0IGtfaWNvbiA9IHBfaWNvbj8gSF9JQ09OU1twX2ljb25dOiBJY29uLkJMQU5LO1xuPC9zY3JpcHQ+XG5cdFxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LmFyZWEge1xuXHRcdGJvcmRlcjogMXB4IGRhc2hlZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdGJvcmRlci1yYWRpdXM6IDRweDtcblxuXHRcdD4ucm93IHtcblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0XHRtYXJnaW46IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHQ+KiB7XG5cdFx0XHRcdGZsZXg6IGF1dG87XG5cdFx0XHR9XG5cblx0XHRcdD4ubGVmdCB7XG5cdFx0XHRcdGZsZXg6IDE7XG5cblx0XHRcdFx0Pi5pY29uLnBmcCB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHQtLWJ1dHRvbi1kaWFtZXRlcjogNjRweDtcblx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogNjRweDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Pi5yaWdodCB7XG5cdFx0XHRcdGZsZXg6IDM7XG5cdFx0XHRcdHBhZGRpbmc6IDAgY2FsYyh2YXIoLS11aS1wYWRkaW5nKSAvIDIpO1xuXHRcdFx0XHRtYXJnaW4tdG9wOiAtNHB4O1xuXHRcdFx0XHQvLyBwYWRkaW5nLXRvcDogY2FsYyh2YXIoLS11aS1wYWRkaW5nKSAvIDEuNSk7XG5cblx0XHRcdFx0Pi5kaXNjbGFpbWVyIHtcblx0XHRcdFx0XHQuZm9udCh0aW55KTtcblxuXHRcdFx0XHRcdD4ud2FybmluZyB7XG5cdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItY2F1dGlvbik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pi5pbmZvIHtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwYWRkaW5nLWJvdHRvbTogMjBweDtcblxuXHRcdFx0LmFjdGlvbnMge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdG1hcmdpbi10b3A6IDRweDtcblxuXHRcdFx0XHQvLyB3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdFx0XHQvLyBwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdC8vIG1hcmdpbi10b3A6IDRweDtcblx0XHRcdFx0Ly8gbWFyZ2luLWxlZnQ6IC00cHg7XG5cblx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblxuXHRcdFx0XHRcdCY6aG92ZXIge1xuXHRcdFx0XHRcdFx0Pi50ZXh0IHtcblx0XHRcdFx0XHRcdFx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+Lmljb24ge1xuXHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjBweDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJhcmVhXCIgY2xhc3M6aW50ZW50LXBlcnNvbj17J3BlcnNvbicgPT09IHNpX2ludGVudH0+XG5cdDxkaXYgY2xhc3M9XCJyb3dcIj5cblx0XHQ8c3BhbiBjbGFzcz1cImxlZnRcIj5cblx0XHRcdDwhLS0gPHNwYW4gY2xhc3M9XCJpY29uIHBmcFwiIGNsYXNzOnNxdWFyZT17J3BlcnNvbicgPT09IGludGVudH0+XG5cdFx0XHRcdDxQdXQgZWxlbWVudD17SF9JQ09OU1twX2ljb25dLnJlbmRlcigpfSAvPlxuXHRcdFx0PC9zcGFuPiAtLT5cblx0XHRcdHsjaWYgcF9wZnB9XG5cdFx0XHRcdDxQZnBEaXNwbGF5IGRpbT17NDh9IHJlZj17cF9wZnB9IG5hbWU9e3NfbmFtZX0gLz5cblx0XHRcdHsvaWZ9XG5cdFx0XHQ8IS0tIDxQZnBEaXNwbGF5IGJpbmQ6aWNvblJlZj17aWNvblJlZn0gYmluZDpuYW1lPXtuYW1lfSAvPiAtLT5cblx0XHQ8L3NwYW4+XG5cblx0XHQ8c3BhbiBjbGFzcz1cInJpZ2h0XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiZGlzY2xhaW1lclwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cIndhcm5pbmdcIj5cblx0XHRcdFx0XHROb3RpY2U6XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0VXBsb2FkZWQgaWNvbnMgd2lsbCBiZSByZXNpemVkIHRvIGJlIHNxdWFyZS4gT25seSBKUEcgJiBQTkcgZmlsZXMgbGVzcyB0aGFuIDFNQiBhbGxvd2VkLlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L2Rpdj5cblxuXHRcdFx0PGRpdiBjbGFzcz1cImFjdGlvbnNcIj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cInVwbG9hZFwiIG9uOmNsaWNrPXsoKSA9PiBGX05PT1B9PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fSU1BR0V9XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuXHRcdFx0XHRcdFx0VXBsb2FkIEljb25cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9zcGFuPlxuXHQ8L2Rpdj5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtnZXRDb250ZXh0LCBTdmVsdGVDb21wb25lbnR9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7bWljcm90YXNrLCBvZGUsIG9mZSwgcHJvcGVyfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IHsgQ29udGFjdCwgQ29udGFjdEFnZW50VHlwZSwgQ29udGFjdFBhdGggfSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHR5cGUgeyBQYWdlIH0gZnJvbSAnLi4vbmF2L3BhZ2UnO1xuXHRpbXBvcnQgeyB5d19jaGFpbiwgeXdfZmFtaWx5IH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBSX0JFQ0gzMiB9IGZyb20gJyMvc2hhcmUvY29uc3RhbnRzJztcblx0aW1wb3J0IHsgVGFncyB9IGZyb20gJyMvc3RvcmUvdGFncyc7XG5cdGltcG9ydCB7IEhlYWRlciwgU2NyZWVuIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cdGltcG9ydCBDb250YWN0VmlldyBmcm9tICcuL0NvbnRhY3RWaWV3LnN2ZWx0ZSc7XG5cdGltcG9ydCBGaWVsZCBmcm9tICcuLi91aS9GaWVsZC5zdmVsdGUnO1xuXHRpbXBvcnQgSW5mbyBmcm9tICcuLi91aS9JbmZvLnN2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4sIENoYWluUGF0aCB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCBJbmxpbmVUYWdzIGZyb20gJy4uL3VpL0lubGluZVRhZ3Muc3ZlbHRlJztcblx0aW1wb3J0IEljb25FZGl0b3IgZnJvbSAnLi4vdWkvSWNvbkVkaXRvci5zdmVsdGUnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHQvKipcblx0ICogQ29udGFjdCByZXNvdXJjZSBwYXRoXG5cdCAqL1xuXHRleHBvcnQgbGV0IGNvbnRhY3RSZWY6IENvbnRhY3RQYXRoIHwgJycgPSAnJztcblx0Y29uc3QgcF9jb250YWN0ID0gY29udGFjdFJlZiB8fCAnJztcblxuXHQvLyBwcmVwIG9iamVjdCBwbGFjZWhvbGRlclxuXHRsZXQgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXTtcblxuXHQvLyBwYXRoIHdhcyBnaXZlbjsgbG9hZCBjb250YWN0XG5cdGlmKHBfY29udGFjdCkgdm9pZCBBZ2VudHMuZ2V0Q29udGFjdChwX2NvbnRhY3QpLnRoZW4oZyA9PiBnX2NvbnRhY3QgPSBnISk7XG5cblx0Ly8gbG9hZCBhbGwgY2hhaW5zXG5cdGxldCBoX2NoYWluczogUmVjb3JkPENoYWluUGF0aCwgQ2hhaW5bJ2ludGVyZmFjZSddPiA9IHt9O1xuXHQoYXN5bmMgZnVuY3Rpb24gbG9hZF9jaGFpbnMoKSB7XG5cdFx0aF9jaGFpbnMgPSBvZmUoKGF3YWl0IENoYWlucy5yZWFkKCkpLmVudHJpZXMoKSk7XG5cdH0pKCk7XG5cblx0Ly8gcmVhY3RpdmVseSBkZXN0cnVjdHVyZSBjb250YWN0J3MgcHJvcGVydGllc1xuXHQkOiBzX25hbWUgPSBnX2NvbnRhY3Q/Lm5hbWUgfHwgJyc7XG5cdCQ6IHNfYWRkciA9IGdfY29udGFjdD8uYWRkcmVzcyB8fCAnJztcblx0JDogc2FfYmVjaDMyID0gc19hZGRyPyBDaGFpbnMuYmVjaDMyKHNfYWRkciBhcyBzdHJpbmcpOiAnJztcblx0JDogc19ub3RlcyA9IGdfY29udGFjdD8ubm90ZXMgfHwgJyc7XG5cdCQ6IHNpX2FnZW50X3R5cGUgPSBnX2NvbnRhY3Q/LmFnZW50VHlwZSB8fCBDb250YWN0QWdlbnRUeXBlLlBFUlNPTjtcblxuXHRsZXQgc19lcnJfbmFtZSA9ICcnO1xuXHRsZXQgc19lcnJfYWRkcmVzcyA9ICcnO1xuXG5cdGZ1bmN0aW9uIHB1YmtleV9mcm9tX2FkZHIoc2FfYWRkcmVzczogc3RyaW5nLCBiX3Nob3dfZXJyPWZhbHNlKTogc3RyaW5nIHtcblx0XHRjb25zdCBtX2JlY2ggPSBSX0JFQ0gzMi5leGVjKHNhX2FkZHJlc3MpO1xuXHRcdGlmKCFtX2JlY2gpIHtcblx0XHRcdGlmKGJfc2hvd19lcnIpIHtcblx0XHRcdFx0c19lcnJfYWRkcmVzcyA9ICdJbnZhbGlkIEJlY2gzMiBhZGRyZXNzJztcblx0XHRcdH1cblx0XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0Y29uc3QgWywgc19jaGFpbiwgc19wdWJrZXlfbG9jYWxdID0gbV9iZWNoO1xuXG5cdFx0bGV0IGtfY2hhaW5fbWF0Y2ggPSBudWxsO1xuXHRcdGZvcihjb25zdCBbLCBrX2NoYWluXSBvZiBvZGUoSF9DSEFJTlMpKSB7XG5cdFx0XHRpZihrX2NoYWluLmRlZi5iZWNoUHJlZml4ID09PSBzX2NoYWluKSB7XG5cdFx0XHRcdGtfY2hhaW5fbWF0Y2ggPSBrX2NoYWluO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihiX3Nob3dfZXJyKSB7XG5cdFx0XHRpZigha19jaGFpbl9tYXRjaCkge1xuXHRcdFx0XHRzX2Vycl9hZGRyZXNzID0gYE5vIENvc21vcyBTREsgY2hhaW5zIG1hdGNoZWQgJyR7c19jaGFpbn0nYDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzX2Vycl9hZGRyZXNzID0gJyc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNfYWRkciA9IHNfcHVia2V5X2xvY2FsO1xuXHR9XG5cblx0JDogYl9mb3JtX3ZhbGlkID0gISEoc19uYW1lICYmIHB1YmtleV9mcm9tX2FkZHIoc2FfYmVjaDMyKSk7XG5cdGxldCBjX3Nob3dfdmFsaWRhdGlvbnMgPSAwO1xuXG5cdCQ6IHtcblx0XHRpZihjX3Nob3dfdmFsaWRhdGlvbnMpIHtcblx0XHRcdHNfZXJyX25hbWUgPSBzX25hbWU/ICcnOiAnTmFtZSBtdXN0IG5vdCBiZSBlbXB0eSc7XG5cdFx0XHRwdWJrZXlfZnJvbV9hZGRyKHNhX2JlY2gzMiwgdHJ1ZSk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGJfYnVzeSA9IGZhbHNlO1xuXG5cdGxldCB5X3NjcmVlbjogU3ZlbHRlQ29tcG9uZW50O1xuXHRhc3luYyBmdW5jdGlvbiBzYXZlKCkge1xuXHRcdGlmKCFiX2Zvcm1fdmFsaWQpIHtcblx0XHRcdGNfc2hvd192YWxpZGF0aW9ucysrO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVsc2UgaWYocF9jb250YWN0KSB7XG5cdFx0XHRPYmplY3QuYXNzaWduKGdfY29udGFjdCwge1xuXHRcdFx0XHRuYW1lOiBzX25hbWUsXG5cdFx0XHRcdGFkZHJlc3M6IHNfYWRkcixcblx0XHRcdFx0cGZwOiBnX2NvbnRhY3QucGZwLFxuXHRcdFx0XHRhZ2VudFR5cGU6IHNpX2FnZW50X3R5cGUsXG5cdFx0XHRcdG5vdGVzOiBzX25vdGVzLFxuXHRcdFx0fSk7XG5cblx0XHRcdGtfcGFnZS5yZXNldCgpO1xuXHRcdFx0Ly8gc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHQvLyBcdHRyeSB7XG5cdFx0XHQvLyBcdFx0eV9zY3JlZW4uJGRlc3Ryb3koKTtcblx0XHRcdC8vIFx0fVxuXHRcdFx0Ly8gXHRjYXRjaChlKSB7fVxuXHRcblx0XHRcdC8vIFx0Y29udGFjdCA9IEhfQ09OVEFDVFNbY29udGFjdC5kZWYuaXJpXTtcblx0XHRcdC8vIFx0cHVzaF9zY3JlZW4oQ29udGFjdFZpZXcsIHtcblx0XHRcdC8vIFx0XHRjb250YWN0LFxuXHRcdFx0Ly8gXHR9KTtcblx0XHRcdC8vIH0sIDUpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGdfY29udGFjdCA9IHtcblx0XHRcdFx0bmFtZTogc19uYW1lLFxuXHRcdFx0XHRmYW1pbHk6ICR5d19mYW1pbHksXG5cdFx0XHRcdGFkZHJlc3M6IHNfYWRkcixcblx0XHRcdFx0cGZwOiBnX2NvbnRhY3QucGZwLFxuXHRcdFx0XHRhZ2VudFR5cGU6IHNpX2FnZW50X3R5cGUsXG5cdFx0XHRcdG5vdGVzOiBzX25vdGVzLFxuXHRcdFx0XHRzcGFjZTogJ2FjYycsXG5cdFx0XHRcdG9yaWdpbjogJ3VzZXInLFxuXHRcdFx0XHRjaGFpbnM6IHt9LFxuXHRcdFx0fTtcblx0XHR9XG5cblxuXHRcdGJfYnVzeSA9IHRydWU7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IEFnZW50cy5vcGVuKGFzeW5jKGtzX2FnZW50cykgPT4ge1xuXHRcdFx0XHRhd2FpdCBrc19hZ2VudHMucHV0Q29udGFjdChnX2NvbnRhY3QpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGtfcGFnZS5yZXNldCgpO1xuXG5cdFx0XHQvLyBpbW1lZGlhdGVseSBvcGVuIG5ldyBjb250YWN0XG5cdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdGNyZWF0b3I6IENvbnRhY3RWaWV3LFxuXHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdGNvbnRhY3RSZWY6IHBfY29udGFjdCxcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRjYXRjaChlX3dyaXRlKSB7XG5cdFx0XHRiX2J1c3kgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHQvLyBsZXQgcF9pY29uOiBJY29uLlJlZiA9IGNvbnRhY3Q/LmRlZi5pY29uUmVmIHx8ICcnIGFzIEljb24uUmVmO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdCNjaGFpbi1mYW1pbHkge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0ZmxleDogMTtcblx0XHRcdGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcblx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblxuXHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbiBiaW5kOnRoaXM9e3lfc2NyZWVufSBsZWF2ZXM+XG5cdDxIZWFkZXJcblx0XHRwbGFpbiBwb3BzXG5cdFx0dGl0bGU9XCJ7cF9jb250YWN0PyAnRWRpdCc6ICdBZGQgTmV3J30gQ29udGFjdFwiXG5cdC8+XG5cblx0PEZpZWxkXG5cdFx0a2V5PVwiY29udGFjdC1wZnBcIlxuXHRcdG5hbWU9XCJQcm9maWxlIEljb25cIlxuXHQ+XG5cdFx0PEljb25FZGl0b3IgaW50ZW50PSdwZXJzb24nIHBmcFJlZj17Z19jb250YWN0Py5wZnB9IGJpbmQ6bmFtZT17c19uYW1lfSAvPlxuXHQ8L0ZpZWxkPlxuXG5cdDxGaWVsZFxuXHRcdGtleT1cImNoYWluLWZhbWlseVwiXG5cdFx0bmFtZT1cIkNoYWluIEZhbWlseVwiXG5cdD5cblx0XHQ8SW5mbyBrZXk9XCJjaGFpbi1mYW1pbHlcIj5cblx0XHRcdDxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcdFx0XHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdFx0XHRcdC50aXRsZSB7XG5cdFx0XHRcdFx0LmZvbnQocmVndWxhcik7XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LmV4YW1wbGVzIHtcblx0XHRcdFx0XHRtYXJnaW4tbGVmdDogMC41ZW07XG5cdFx0XHRcdH1cblx0XHRcdDwvc3R5bGU+XG5cblx0XHRcdDxzcGFuIGNsYXNzPVwidGl0bGVcIj5cblx0XHRcdFx0e3Byb3BlcigkeXdfZmFtaWx5KX1cblx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0PHNwYW4gY2xhc3M9XCJleGFtcGxlc1wiPlxuXHRcdFx0XHQoe29kZShoX2NoYWlucykuZmlsdGVyKChbLCBnXSkgPT4gJHl3X2ZhbWlseSA9PT0gZy5mYW1pbHkpLm1hcCgoWywgZ10pID0+IGcuYmVjaDMycy5hY2MuaHJwKS5qb2luKCcsICcpfSlcblx0XHRcdDwvc3Bhbj5cblx0XHQ8L0luZm8+XG5cdDwvRmllbGQ+XG5cblxuXHQ8RmllbGRcblx0XHRrZXk9XCJjb250YWN0LW5hbWVcIlxuXHRcdG5hbWU9XCJOYW1lXCJcblx0PlxuXHRcdDxpbnB1dCBjbGFzczppbnZhbGlkPXtzX2Vycl9uYW1lfSB0eXBlPVwidGV4dFwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiIGJpbmQ6dmFsdWU9e3NfbmFtZX0gcGxhY2Vob2xkZXI9XCJFbnRlciBhIG5hbWVcIj5cblxuXHRcdHsjaWYgc19lcnJfbmFtZX1cblx0XHRcdDxzcGFuIGNsYXNzPVwidmFsaWRhdGlvbi1tZXNzYWdlXCI+XG5cdFx0XHRcdHtzX2Vycl9uYW1lfVxuXHRcdFx0PC9zcGFuPlxuXHRcdHsvaWZ9XG5cdDwvRmllbGQ+XG5cblx0PEZpZWxkXG5cdFx0a2V5PVwiY29udGFjdC1hZGRyZXNzXCJcblx0XHRuYW1lPVwiQWRkcmVzc1wiXG5cdD5cblx0XHQ8aW5wdXRcblx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdGNsYXNzPVwiYWRkcmVzc1wiXG5cdFx0XHRjbGFzczppbnZhbGlkPXtzX2Vycl9hZGRyZXNzfVxuXHRcdFx0c3BlbGxjaGVjaz1cImZhbHNlXCJcblx0XHRcdHBsYWNlaG9sZGVyPVwieyR5d19jaGFpbi5iZWNoMzJzLmFjY30xLi4uXCJcblx0XHRcdGJpbmQ6dmFsdWU9e3NhX2JlY2gzMn1cblx0XHQ+XG5cblx0XHR7I2lmIHNfZXJyX2FkZHJlc3N9XG5cdFx0XHQ8c3BhbiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiPlxuXHRcdFx0XHR7c19lcnJfYWRkcmVzc31cblx0XHRcdDwvc3Bhbj5cblx0XHR7L2lmfVxuXHQ8L0ZpZWxkPlxuXG5cdDxGaWVsZFxuXHRcdGtleT1cImNvbnRhY3Qtbm90ZXNcIlxuXHRcdG5hbWU9XCJTZWN1cmUgTm90ZXNcIlxuXHQ+XG5cdFx0PHRleHRhcmVhIGJpbmQ6dmFsdWU9e3Nfbm90ZXN9IHBsYWNlaG9sZGVyPVwiXCI+PC90ZXh0YXJlYT5cblx0PC9GaWVsZD5cblxuXHQ8aHI+XG5cblx0PGgzPlxuXHRcdHtwX2NvbnRhY3Q/ICdFZGl0JzogJ0FkZCd9IFRhZ3Ncblx0PC9oMz5cblxuXHQ8SW5saW5lVGFncyBlZGl0YWJsZSByZXNvdXJjZVBhdGg9e3BfY29udGFjdH0gLz5cblxuXHQ8ZGl2IGNsYXNzPVwiYWN0aW9uLWxpbmVcIj5cblx0XHQ8YnV0dG9uIG9uOmNsaWNrPXsoKSA9PiBrX3BhZ2UucG9wKCl9PlxuXHRcdFx0QmFja1xuXHRcdDwvYnV0dG9uPlxuXG5cdFx0PGJ1dHRvbiBjbGFzcz1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gc2F2ZSgpfSByZWFkb25seT17IWJfZm9ybV92YWxpZH0+XG5cdFx0XHR7cF9jb250YWN0PyAnU2F2ZSc6ICdBZGQnfVxuXHRcdDwvYnV0dG9uPlxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItbW9yZS12ZXJ0LWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1tb3JlLXZlcnQtZmdcXFwiIGQ9XFxcIk0xMiA4QzEzLjEgOCAxNCA3LjEgMTQgNkMxNCA0LjkgMTMuMSA0IDEyIDRDMTAuOSA0IDEwIDQuOSAxMCA2QzEwIDcuMSAxMC45IDggMTIgOFpNMTIgMTBDMTAuOSAxMCAxMCAxMC45IDEwIDEyQzEwIDEzLjEgMTAuOSAxNCAxMiAxNEMxMy4xIDE0IDE0IDEzLjEgMTQgMTJDMTQgMTAuOSAxMy4xIDEwIDEyIDEwWk0xMiAxNkMxMC45IDE2IDEwIDE2LjkgMTAgMThDMTAgMTkuMSAxMC45IDIwIDEyIDIwQzEzLjEgMjAgMTQgMTkuMSAxNCAxOEMxNCAxNi45IDEzLjEgMTYgMTIgMTZaXFxcIiBmaWxsPVxcXCIjRkZCNjFBXFxcIi8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTkgMTZoNnYtNmg0bC03LTctNyA3aDR2NnptMy0xMC4xN0wxNC4xNyA4SDEzdjZoLTJWOEg5LjgzTDEyIDUuODN6TTUgMThoMTR2Mkg1elxcXCIvPlxcbjwvc3ZnPlwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtxdWludE91dH0gZnJvbSAnc3ZlbHRlL2Vhc2luZyc7XG5cdGltcG9ydCB7eXdfZmFtaWx5fSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCBTWF9JQ09OX0RPVFMgZnJvbSAnIy9pY29uL21vcmUtdmVydC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fRURJVCBmcm9tICcjL2ljb24vZWRpdC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fU0VORCBmcm9tICcjL2ljb24vdXBsb2FkLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9ERUxFVEUgZnJvbSAnIy9pY29uL2RlbGV0ZS5zdmc/cmF3JztcblxuXHRpbXBvcnQgU1hfSUNPTl9QRVJTT05BTCBmcm9tICcjL2ljb24vYWNjb3VudF9ib3guc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NPTlRSQUNUIGZyb20gJyMvaWNvbi9hbmFseXRpY3Muc3ZnP3Jhdyc7XG5cblx0aW1wb3J0IHtzbGlkZX0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXHRpbXBvcnQgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3Muc3ZlbHRlJztcblx0aW1wb3J0IFJvdyBmcm9tICcuL1Jvdy5zdmVsdGUnO1xuXHRpbXBvcnQgUHV0IGZyb20gJy4vUHV0LnN2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHtEaWN0LCBKc29uUHJpbWl0aXZlfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IElubGluZVRhZ3MgZnJvbSAnLi9JbmxpbmVUYWdzLnN2ZWx0ZSc7XG5cblx0aW1wb3J0IENvbnRhY3RFZGl0IGZyb20gJyMjL3NjcmVlbi9Db250YWN0RWRpdC5zdmVsdGUnO1xuXHRpbXBvcnQgU2VuZCBmcm9tICcjIy9zY3JlZW4vU2VuZC5zdmVsdGUnO1xuXHRpbXBvcnQgRGVhZEVuZCBmcm9tICcjIy9zY3JlZW4vRGVhZEVuZC5zdmVsdGUnO1xuXHRpbXBvcnQgQ29udGFjdFZpZXcgZnJvbSAnIyMvc2NyZWVuL0NvbnRhY3RWaWV3LnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHR5cGUge0NvbnRhY3QsIENvbnRhY3RQYXRofSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cdGltcG9ydCB7QWdlbnRzfSBmcm9tICcjL3N0b3JlL2FnZW50cyc7XG5cdGltcG9ydCB7Q2hhaW5zfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cblx0aW1wb3J0IHR5cGUge1BhZ2V9IGZyb20gJy4uL3NjcmVlbi9fc2NyZWVucyc7XG5cdGltcG9ydCB7Z2V0Q29udGV4dH0gZnJvbSAnc3ZlbHRlJztcblxuXHQvLyBnZXQgcGFnZSBmcm9tIGNvbnRleHRcblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cblx0ZXhwb3J0IGxldCBmaWx0ZXI6IChnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddKSA9PiBib29sZWFuID0gZyA9PiB0cnVlO1xuXG5cdGV4cG9ydCBsZXQgc29ydDogKGdfYTogQ29udGFjdFsnaW50ZXJmYWNlJ10sIGdfYjogQ29udGFjdFsnaW50ZXJmYWNlJ10pID0+IG51bWJlciA9IChnX2EsIGdfYikgPT4gZ19hLm5hbWUgPCBnX2IubmFtZT8gLTE6IDE7XG5cblx0ZXhwb3J0IGxldCBhcHBlbmQ6IENvbnRhY3RbJ2ludGVyZmFjZSddW10gPSBbXTtcblxuXG5cdC8vIGxvYWQgYWxsIGNvbnRhY3RzIGZvciB0aGUgY3VycmVudCBjaGFpbidzIGZhbWlseSBhcyBhIGxpc3Rcblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9jb250YWN0cygpOiBQcm9taXNlPFtDb250YWN0UGF0aCwgQ29udGFjdFsnaW50ZXJmYWNlJ11dW10+IHtcblx0XHQvLyByZWFkIGZyb20gYWdlbnRzIHN0b3JlXG5cdFx0Y29uc3Qga3NfYWdlbnRzID0gYXdhaXQgQWdlbnRzLnJlYWQoKTtcblxuXHRcdC8vIHNwcmVhZCBpdGVyYXRvciBpbnRvIGFycmF5XG5cdFx0cmV0dXJuIFsuLi5rc19hZ2VudHMuY29udGFjdHMoJHl3X2ZhbWlseSldO1xuXHR9XG5cblx0Y29uc3QgaG1fZXZlbnRzID0gbmV3IFdlYWtNYXA8RXZlbnQsIERpY3Q8SnNvblByaW1pdGl2ZT4+KCk7XG5cblx0bGV0IHNpX292ZXJsYXkgPSAnJztcblx0ZnVuY3Rpb24gYWN0aXZhdGVfb3ZlcmxheShwX2NvbnRhY3Q6IHN0cmluZywgZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSk6IChkOiBNb3VzZUV2ZW50KSA9PiB2b2lkIHtcblx0XHRyZXR1cm4gKGRfZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcblx0XHRcdC8vIHByZXZlbnQgZXZlbnQgZnJvbSBidWJibGluZ1xuXHRcdFx0ZF9ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0Ly8gcmVmIGVudHJ5IGlkXG5cdFx0XHRjb25zdCBzaV9zZXQgPSBwX2NvbnRhY3Q7XG5cblx0XHRcdC8vIG92ZXJsYXkgYWxyZWFkeSBzZXQgdG8gdGhpcyBlbnRyeTsgaGlkZSBpdFxuXHRcdFx0aWYoaG1fZXZlbnRzLmdldChkX2V2ZW50KT8uY2FuY2VsTWVudSA9PT0gc2lfc2V0KSB7XG5cdFx0XHRcdHNpX292ZXJsYXkgPSAnJztcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgb3ZlcmxheSB0byB0aGlzIGVudHJ5XG5cdFx0XHRzaV9vdmVybGF5ID0gc2lfc2V0O1xuXG5cdFx0XHQvLyByZW1vdmUgb24gY2xpY2sgZXZlbnRcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcblx0XHRcdFx0aG1fZXZlbnRzLnNldChkX2V2ZW50LCB7XG5cdFx0XHRcdFx0Y2FuY2VsTWVudTogc2lfb3ZlcmxheSxcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNpX292ZXJsYXkgPSAnJztcblx0XHRcdH0sIHtcblx0XHRcdFx0Y2FwdHVyZTogdHJ1ZSxcblx0XHRcdFx0b25jZTogdHJ1ZSxcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblxuXHRjb25zdCBhX292ZXJsYXlfYWN0aW9uczoge1xuXHRcdGxhYmVsOiBzdHJpbmc7XG5cdFx0aWNvbjogc3RyaW5nO1xuXHRcdGNsaWNrKGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ10pOiB2b2lkO1xuXHR9W10gPSBbXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdFZGl0Jyxcblx0XHRcdGljb246IFNYX0lDT05fRURJVCxcblx0XHRcdGNsaWNrKGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ10pIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IENvbnRhY3RFZGl0LFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRjb250YWN0OiBnX2NvbnRhY3QsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdTZW5kJyxcblx0XHRcdGljb246IFNYX0lDT05fU0VORCxcblx0XHRcdGNsaWNrKGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ10pIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IFNlbmQsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdHJlY2lwaWVudDogQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcyksXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdEZWxldGUnLFxuXHRcdFx0aWNvbjogU1hfSUNPTl9ERUxFVEUsXG5cdFx0XHRjbGljayhnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddKSB7XG5cdFx0XHRcdC8vIFRPRE86XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBEZWFkRW5kLFxuXHRcdFx0XHRcdHByb3BzOiB7fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdF07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LnJvd3Mge1xuXHRcdG1hcmdpbi1sZWZ0OiBjYWxjKDBweCAtIHZhcigtLXVpLXBhZGRpbmcpKTtcblx0XHRtYXJnaW4tcmlnaHQ6IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXG5cdFx0LnJvdyB7XG5cdFx0XHQuc3RhdHVzIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Lmljb24ubW9yZS1tZW51IHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdHBhZGRpbmctdG9wOiA1MCU7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLWJvdHRvbTogNTAlO1xuXHRcdFx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHRcdG91dGxpbmU6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb246IDM1MG1zIG91dGxpbmUtY29sb3IgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdDpnbG9iYWwoJjpob3Zlcikge1xuXHRcdFx0XHRcdFx0b3V0bGluZS1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ6Z2xvYmFsKCY6YWN0aXZlKSwgOmdsb2JhbCgmLmFjdGl2ZSkge1xuXHRcdFx0XHRcdFx0b3V0bGluZS1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Lm92ZXJsYXkge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHRcdFx0cGFkZGluZzogMTBweCAxNHB4O1xuXHRcdFx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuXHRcdFx0XHRcdFx0Ym9yZGVyLXJhZGl1czogOHB4O1xuXHRcdFx0XHRcdFx0cmlnaHQ6IDI2cHg7XG5cdFx0XHRcdFx0XHR0b3A6IC0xOHB4O1xuXHRcdFx0XHRcdFx0bWluLXdpZHRoOiAxMjBweDtcblx0XHRcdFx0XHRcdHotaW5kZXg6IDEwMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+LmFjdGlvbiB7XG5cdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0XHRcdFx0cGFkZGluZzogMTBweCA4cHg7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdD4udGV4dCB7XG5cdFx0XHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0XHRcdHBhZGRpbmctbGVmdDogMTBweDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC5pY29uIHtcblx0XHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Lmljb24uY29udGFjdC10eXBlIHtcblx0XHQtLWljb24tZGlhbWV0ZXI6IDE2cHg7XG5cdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdH1cblxuXHQucGZwLWdlbiB7XG5cdFx0LmZvbnQoaHVnZSk7XG5cdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0Ym9yZGVyLXJhZGl1czogMjAlO1xuXHRcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoZWxsaXBzZSBmYXJ0aGVzdC1zaWRlIGF0IGJvdHRvbSByaWdodCwgIzA3MDgwYSwgIzBmMTMxNyk7XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJyb3dzXCI+XG5cdHsjYXdhaXQgbG9hZF9jb250YWN0cygpfVxuXHRcdExvYWRpbmcgY29udGFjdHMuLi5cblx0ezp0aGVuIGFfbGlzdH1cblx0XHR7I2VhY2ggYV9saXN0IGFzIFtwX2NvbnRhY3QsIGdfY29udGFjdF19XG5cdFx0XHQ8Um93XG5cdFx0XHRcdHJlc291cmNlPXtnX2NvbnRhY3R9XG5cdFx0XHRcdHJlc291cmNlUGF0aD17cF9jb250YWN0fVxuXHRcdFx0XHRvbjpjbGljaz17KGRfZXZlbnQpID0+IHtcblx0XHRcdFx0XHRpZighaG1fZXZlbnRzLmdldChkX2V2ZW50KT8uY2FuY2VsTWVudSkge1xuXHRcdFx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRjcmVhdG9yOiBDb250YWN0Vmlldyxcblx0XHRcdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdFx0XHRjb250YWN0OiBnX2NvbnRhY3QsXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH19XG5cdFx0XHQ+XG5cdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cImRldGFpbFwiPlxuXHRcdFx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9e0NoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MrJycpfSAvPlxuXHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblxuXHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJ0YWdzXCI+XG5cdFx0XHRcdFx0PElubGluZVRhZ3MgY29sbGFwc2VkIHJvb3RTdHlsZT0nbWFyZ2luOiAwcHg7J1xuXHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoPXtwX2NvbnRhY3R9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGNvbnRhY3QtdHlwZVwiIHNsb3Q9XCJwcmVmaXhcIj5cblx0XHRcdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fUEVSU09OQUx9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PC9JbmxpbmVUYWdzPlxuXHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblxuXHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdGF0dXNcIj5cblx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJpY29uIG1vcmUtbWVudVwiXG5cdFx0XHRcdFx0XHRjbGFzczphY3RpdmU9e3NpX292ZXJsYXkgPT09IHBfY29udGFjdH1cblx0XHRcdFx0XHRcdG9uOmNsaWNrPXthY3RpdmF0ZV9vdmVybGF5KHBfY29udGFjdCwgZ19jb250YWN0KX1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9ET1RTfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdHsjaWYgc2lfb3ZlcmxheSA9PT0gcF9jb250YWN0fVxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJvdmVybGF5XCIgdHJhbnNpdGlvbjpzbGlkZT17e2R1cmF0aW9uOjMwMCwgZWFzaW5nOnF1aW50T3V0fX0+XG5cdFx0XHRcdFx0XHRcdHsjZWFjaCBhX292ZXJsYXlfYWN0aW9ucyBhcyBnX2FjdGlvbn1cblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYWN0aW9uXCIgb246Y2xpY2s9eyhkX2V2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkX2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Z19hY3Rpb24uY2xpY2soZ19jb250YWN0KTtcblx0XHRcdFx0XHRcdFx0XHR9fT5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgZ19hY3Rpb24uaWNvbn1cblx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHtnX2FjdGlvbi5sYWJlbH1cblx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0PC9Sb3c+XG5cdFx0ey9lYWNofVxuXHR7L2F3YWl0fVxuPC9kaXY+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtnZXRDb250ZXh0fSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCB7XG5cdFx0VGFicyxcblx0XHRUYWIsXG5cdFx0VGFiTGlzdCxcblx0XHRUYWJQYW5lbCxcblx0fSBmcm9tICdzdmVsdGUtdGFicyc7XG5cblx0aW1wb3J0IHtcblx0XHRTY3JlZW4sXG5cdFx0SGVhZGVyLFxuXHRcdHR5cGUgUGFnZSxcblx0fSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRpbXBvcnQgQ29udGFjdEVkaXQgZnJvbSAnLi9Db250YWN0RWRpdC5zdmVsdGUnO1xuXHRpbXBvcnQgU3ViSGVhZGVyIGZyb20gJy4uL3VpL1N1YkhlYWRlci5zdmVsdGUnO1xuXHRpbXBvcnQgQ29udGFjdExpc3QgZnJvbSAnLi4vdWkvQ29udGFjdExpc3Quc3ZlbHRlJztcblx0aW1wb3J0IHtDb250YWN0QWdlbnRUeXBlfSBmcm9tICcjL21ldGEvY29udGFjdCc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LnNjcmVlbi5jb250YWN0cyBkaXYuc3ZlbHRlLXRhYnM+ZGl2LnN2ZWx0ZS10YWJzX190YWItcGFuZWwge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0bWFyZ2luLXRvcDogLTFweDtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxTY3JlZW4gbmF2IHJvb3QgY2xhc3NOYW1lcz0nY29udGFjdHMnPlxuXHQ8SGVhZGVyIHNlYXJjaCBuZXR3b3JrIGFjY291bnRcblx0PlxuXHQ8L0hlYWRlcj5cblxuXHQ8U3ViSGVhZGVyIHRpdGxlPVwiQ29udGFjdHNcIlxuXHQvPlxuXHQ8IS0tIGJ1dHRvbnM9e1snRXhwb3J0J119IC0tPlxuXHQ8IS0tIG9uOmFkZF9uZXc9eygpID0+IGtfcGFnZS5wdXNoKHtjcmVhdG9yOkNvbnRhY3RFZGl0fSl9IC0tPlxuXHRcblx0PFRhYnM+XG5cdFx0PFRhYkxpc3Q+XG5cdFx0XHQ8VGFiPlxuXHRcdFx0XHRBbGxcblx0XHRcdDwvVGFiPlxuXG5cdFx0XHQ8VGFiPlxuXHRcdFx0XHRIdW1hbnNcblx0XHRcdDwvVGFiPlxuXG5cdFx0XHQ8VGFiPlxuXHRcdFx0XHRDb250cmFjdHNcblx0XHRcdDwvVGFiPlxuXHRcdDwvVGFiTGlzdD5cblxuXG5cdFx0PCEtLSBBbGwgLS0+XG5cdFx0PFRhYlBhbmVsPlxuXHRcdFx0PENvbnRhY3RMaXN0IC8+XG5cdFx0PC9UYWJQYW5lbD5cblxuXG5cdFx0PCEtLSBIdW1hbnMgLS0+XG5cdFx0PFRhYlBhbmVsPlxuXHRcdFx0PENvbnRhY3RMaXN0XG5cdFx0XHRcdGZpbHRlcj17Z19jb250YWN0ID0+IENvbnRhY3RBZ2VudFR5cGUuUEVSU09OID09PSBnX2NvbnRhY3QuYWdlbnRUeXBlfVxuXHRcdFx0Lz5cblx0XHQ8L1RhYlBhbmVsPlxuXG5cdFx0XG5cdFx0PCEtLSBDb250cmFjdHMgLS0+XG5cdFx0PFRhYlBhbmVsPlxuXHRcdFx0PENvbnRhY3RMaXN0XG5cdFx0XHRcdGZpbHRlcj17Z19jb250YWN0ID0+IENvbnRhY3RBZ2VudFR5cGUuQ09OVFJBQ1QgPT09IGdfY29udGFjdC5hZ2VudFR5cGV9XG5cdFx0XHQvPlxuXHRcdDwvVGFiUGFuZWw+XG5cblx0PC9UYWJzPlxuXG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBBcHBzIH0gZnJvbSBcIiMvc3RvcmUvYXBwc1wiO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXHRpbXBvcnQgSGVhZGVyIGZyb20gXCIuLi91aS9IZWFkZXIuc3ZlbHRlXCI7XG5cdGltcG9ydCBSb3cgZnJvbSBcIi4uL3VpL1Jvdy5zdmVsdGVcIjtcblx0aW1wb3J0IHsgUGFnZSwgU2NyZWVuLCBTdWJIZWFkZXIgfSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9hcHBzKCkge1xuXHRcdGNvbnN0IGtzX2FwcHMgPSBhd2FpdCBBcHBzLnJlYWQoKTtcblxuXHRcdHJldHVybiBrc19hcHBzLmVudHJpZXMoKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcbjwvc3R5bGU+XG5cbjxTY3JlZW4gZGVidWc9J1NpdGVzSG9tZScgbmF2IHJvb3Q+XG5cdDxIZWFkZXIgc2VhcmNoIG5ldHdvcmsgYWNjb3VudCAvPlxuXG5cdDxTdWJIZWFkZXIgYmFyZVxuXHRcdHRpdGxlPSdTaXRlcyAvIEFwcHMnXG5cdC8+XG5cblx0PGRpdiBjbGFzcz1cInJvd3Mgbm8tbWFyZ2luXCI+XG5cdFx0eyNhd2FpdCBsb2FkX2FwcHMoKX1cblx0XHRcdExvYWRpbmcuLi5cblx0XHR7OnRoZW4gYV9hcHBzfSBcblx0XHRcdHsjZWFjaCBhX2FwcHMgYXMgW3BfYXBwLCBnX2FwcF19XG5cdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRwZnA9e2dfYXBwLnBmcH1cblx0XHRcdFx0XHRuYW1lPXtnX2FwcC5ob3N0fVxuXHRcdFx0XHRcdHJlc291cmNlUGF0aD17cF9hcHB9XG5cdFx0XHRcdFx0aWNvbkNsYXNzPXsnc3F1YXJlIHBmcCd9XG5cdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0Ly8gY3JlYXRvcjogU2l0ZVZpZXcsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9fVxuXHRcdFx0XHQ+XG5cdFx0XHRcdDwvUm93PlxuXHRcdFx0ey9lYWNofVxuXHRcdHsvYXdhaXR9XG5cdDwvZGl2PlxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHt5d19hY2NvdW50LCB5d19jaGFpbn0gZnJvbSAnIyMvbWVtJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0XG5cdGltcG9ydCB7IEhlYWRlciwgdHlwZSBQYWdlLCBTY3JlZW4gfSBmcm9tICcuLi9zY3JlZW4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgUG9ydHJhaXQgZnJvbSAnIyMvdWkvUG9ydHJhaXQuc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBOZXR3b3JrLCBOZXR3b3JrUGF0aCB9IGZyb20gJyMvbWV0YS9uZXR3b3JrJztcblx0aW1wb3J0IHsgTmV0d29ya3MgfSBmcm9tICcjL3N0b3JlL25ldHdvcmtzJztcblx0aW1wb3J0IHR5cGUgeyBDaGFpbiwgQ2hhaW5QYXRoIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcbmltcG9ydCBGaWVsZCBmcm9tICcuLi91aS9GaWVsZC5zdmVsdGUnO1xuaW1wb3J0IEluZm8gZnJvbSAnLi4vdWkvSW5mby5zdmVsdGUnO1xuaW1wb3J0IEdhcCBmcm9tICcuLi91aS9HYXAuc3ZlbHRlJztcblxuXG5cdGV4cG9ydCBsZXQgbmV0d29ya1JlZjogTmV0d29ya1BhdGg7XG5cdGNvbnN0IHBfbmV0d29yayA9IG5ldHdvcmtSZWY7XG5cblx0bGV0IGdfbmV0d29yazogTmV0d29ya1snaW50ZXJmYWNlJ107XG5cdHZvaWQgTmV0d29ya3MuYXQocF9uZXR3b3JrKS50aGVuKGcgPT4gZ19uZXR3b3JrID0gZyEpO1xuXG5cdCQ6IHBfY2hhaW4gPSBnX25ldHdvcms/LmNoYWluO1xuXG5cdGxldCBnX2NoYWluOiBDaGFpblsnaW50ZXJmYWNlJ107XG5cdCQ6IGlmKHBfY2hhaW4pIHtcblx0XHR2b2lkIENoYWlucy5hdChwX2NoYWluIGFzIENoYWluUGF0aCkudGhlbihnID0+IGdfY2hhaW4gPSBnISk7XG5cdH1cblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0Y29uc3QgZ2NfYWN0aW9ucyA9IHtcblx0XHQvLyBzZW5kOiB7XG5cdFx0Ly8gXHRsYWJlbDogJ1NlbmQnLFxuXHRcdC8vIFx0dHJpZ2dlcigpIHtcblx0XHQvLyBcdFx0a19wYWdlLnB1c2goe1xuXHRcdC8vIFx0XHRcdGNyZWF0b3I6IFNlbmQsXG5cdFx0Ly8gXHRcdFx0cHJvcHM6IHtcblx0XHQvLyBcdFx0XHRcdHRvOiBDaGFpbnMuYmVjaDMyKGdfbmV0d29yay5hZGRyZXNzKSxcblx0XHQvLyBcdFx0XHR9LFxuXHRcdC8vIFx0XHR9KTtcblx0XHQvLyBcdH0sXG5cdFx0Ly8gfSxcblx0XHQvLyBlZGl0OiB7XG5cdFx0Ly8gXHRsYWJlbDogJ0VkaXQnLFxuXHRcdC8vIFx0dHJpZ2dlcigpIHtcblx0XHQvLyBcdFx0a19wYWdlLnB1c2goe1xuXHRcdC8vIFx0XHRcdGNyZWF0b3I6IENvbnRhY3RFZGl0LFxuXHRcdC8vIFx0XHRcdHByb3BzOiB7XG5cdFx0Ly8gXHRcdFx0XHRjb250YWN0UmVmOiBwX25ldHdvcmssXG5cdFx0Ly8gXHRcdFx0fSxcblx0XHQvLyBcdFx0fSk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdFx0Ly8gZGVsZXRlOiB7XG5cdFx0Ly8gXHRsYWJlbDogJ0RlbGV0ZScsXG5cdFx0Ly8gXHR0cmlnZ2VyKCkge1xuXHRcdC8vIFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0Ly8gXHRcdFx0Y3JlYXRvcjogRGVhZEVuZCxcblx0XHQvLyBcdFx0fSk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdH07XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnX2Jhc2UubGVzcyc7XG5cblxuXHQucGZwLWdlbiB7XG5cdFx0LmZvbnQoaHVnZSwgQHNpemU6IDMwcHgpO1xuXHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJvcmRlci1yYWRpdXM6IDIwJTtcblx0XHRvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0YmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KGVsbGlwc2UgZmFydGhlc3Qtc2lkZSBhdCBib3R0b20gcmlnaHQsICMwNzA4MGEsICMwZjEzMTcpO1xuXHR9XG48L3N0eWxlPlxuXG5cbjxTY3JlZW4gbmF2IHNsaWRlcz5cblx0PEhlYWRlciBwb3BzIHNlYXJjaCBuZXR3b3JrIGFjY291bnQgLz5cblxuXHR7I2lmICFnX2NoYWlufVxuXHRcdExvYWRpbmcgbmV0d29yay4uLlxuXHR7OmVsc2V9XG5cdFx0PFBvcnRyYWl0XG5cdFx0XHRyZXNvdXJjZT17Z19uZXR3b3JrfVxuXHRcdFx0cmVzb3VyY2VQYXRoPXtwX25ldHdvcmt9XG5cdFx0XHRhY3Rpb25zPXtnY19hY3Rpb25zfVxuXHRcdD5cblx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInN1YnRpdGxlXCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiZm9udC1mYW1pbHlfbW9ub1wiPlxuXHRcdFx0XHRcdHtnX2NoYWluLm5hbWV9ICh7Z19jaGFpbi5pZH0pXG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PmFkZHJlc3Ncblx0XHQ8L1BvcnRyYWl0PlxuXG5cdFx0PEZpZWxkXG5cdFx0XHRuYW1lPSdnUlBDLXdlYiBVUkwnXG5cdFx0XHRrZXk9J2dycGMtd2ViJ1xuXHRcdD5cblx0XHRcdDxJbmZvIGtleT0nZ3JwYy13ZWItdmFsdWUnPlxuXHRcdFx0XHR7Z19uZXR3b3JrLmdycGNXZWJVcmx9XG5cdFx0XHQ8L0luZm8+XG5cdFx0PC9GaWVsZD5cblxuXHRcdHsjaWYgZ19uZXR3b3JrLnJwY0hvc3R9XG5cdFx0XHQ8RmllbGRcblx0XHRcdFx0bmFtZT0nUlBDIEhvc3QnXG5cdFx0XHRcdGtleT0ncnBjJ1xuXHRcdFx0PlxuXHRcdFx0XHQ8SW5mbyBrZXk9J3JwYy12YWx1ZSc+XG5cdFx0XHRcdFx0e2dfbmV0d29yay5ycGNIb3N0fVxuXHRcdFx0XHQ8L0luZm8+XG5cdFx0XHQ8L0ZpZWxkPlxuXHRcdHsvaWZ9XG5cdHsvaWZ9XG5cblx0PEdhcCAvPlxuXG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge0NoYWluc30gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQge05ldHdvcmtzfSBmcm9tICcjL3N0b3JlL25ldHdvcmtzJztcblx0aW1wb3J0IHtnZXRDb250ZXh0fSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgSGVhZGVyIGZyb20gJy4uL3VpL0hlYWRlci5zdmVsdGUnO1xuXHRpbXBvcnQgUm93IGZyb20gJy4uL3VpL1Jvdy5zdmVsdGUnO1xuXHRpbXBvcnQgTmV0d29ya1ZpZXcgZnJvbSAnLi9OZXR3b3JrVmlldy5zdmVsdGUnO1xuXHRpbXBvcnQge1BhZ2UsIFNjcmVlbiwgU3ViSGVhZGVyfSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0bGV0IGtzX2NoYWluczogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBDaGFpbnMucmVhZD4+O1xuXHRsZXQga3NfbmV0d29ya3M6IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgTmV0d29ya3MucmVhZD4+O1xuXHRhc3luYyBmdW5jdGlvbiBsb2FkX25ldHdvcmtzKCkge1xuXHRcdFtcblx0XHRcdGtzX2NoYWlucyxcblx0XHRcdGtzX25ldHdvcmtzLFxuXHRcdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG5cdFx0XHRDaGFpbnMucmVhZCgpLFxuXHRcdFx0TmV0d29ya3MucmVhZCgpLFxuXHRcdF0pO1xuXG5cdFx0cmV0dXJuIGtzX25ldHdvcmtzLmVudHJpZXMoKTtcblx0fVxuXG5cdC8vIGZ1bmN0aW9uIGFkZF9uZXdfbmV0d29yaygpIHtcblx0Ly8gXHRrX3BhZ2UucHVzaCh7XG5cdC8vIFx0XHRjcmVhdG9yOiBOZXR3b3JrQ3JlYXRlLFxuXHQvLyBcdH0pO1xuXHQvLyB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdFxuPC9zdHlsZT5cblxuPFNjcmVlbiBkZWJ1Zz0nTmV0d29ya3NIb21lJyBuYXYgcm9vdD5cblx0PEhlYWRlciBzZWFyY2ggbmV0d29yayBhY2NvdW50IC8+XG5cblx0PFN1YkhlYWRlciBiYXJlXG5cdFx0dGl0bGU9J05ldHdvcmtzJ1xuXHQvPlxuXHRcdDwhLS0gb246YWRkX25ldz17YWRkX25ld19uZXR3b3JrfSAtLT5cblxuXHQ8ZGl2IGNsYXNzPVwicm93cyBuby1tYXJnaW5cIj5cblx0XHR7I2F3YWl0IGxvYWRfbmV0d29ya3MoKX1cblx0XHRcdExvYWRpbmcuLi5cblx0XHR7OnRoZW4gYV9uZXR3b3Jrc30gXG5cdFx0XHR7I2VhY2ggYV9uZXR3b3JrcyBhcyBbcF9uZXR3b3JrLCBnX25ldHdvcmtdfVxuXHRcdFx0XHR7QGNvbnN0IGdfY2hhaW4gPSBrc19jaGFpbnMuYXQoZ19uZXR3b3JrLmNoYWluKX1cblx0XHRcdFx0PFJvd1xuXHRcdFx0XHRcdHJlc291cmNlPXtnX25ldHdvcmt9XG5cdFx0XHRcdFx0cmVzb3VyY2VQYXRoPXtwX25ldHdvcmt9XG5cdFx0XHRcdFx0aWNvbkNsYXNzPXsnc3F1YXJlIHBmcCd9XG5cdFx0XHRcdFx0ZGV0YWlsPXtgJHtnX2NoYWluPy5uYW1lfSAoJHtnX2NoYWluPy5pZH0pYH1cblx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRjcmVhdG9yOiBOZXR3b3JrVmlldyxcblx0XHRcdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdFx0XHRuZXR3b3JrUmVmOiBwX25ldHdvcmssXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9fVxuXHRcdFx0XHQ+XG5cdFx0XHRcdDwvUm93PlxuXHRcdFx0ey9lYWNofVxuXHRcdHsvYXdhaXR9XG5cdDwvZGl2PlxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgZ2xvYmFsX3JlY2VpdmUgfSBmcm9tICcjL3NjcmlwdC9tc2ctZ2xvYmFsJztcblxuXHRpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcjL3N0b3JlL2V2ZW50cyc7XG5cdGltcG9ydCB7IG9uRGVzdHJveSB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IG9uY2Vfc3RvcmVfdXBkYXRlcyB9IGZyb20gJy4uL3N2ZWx0ZSc7XG5cdGltcG9ydCBUeG5MaXN0IGZyb20gJy4uL3VpL1R4bkxpc3Quc3ZlbHRlJztcblxuXHRpbXBvcnQge1xuXHRcdFNjcmVlbixcblx0XHRIZWFkZXIsXG5cdFx0U3ViSGVhZGVyLFxuXHRcdHR5cGUgUGFnZSxcblx0fSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRsZXQgY19yZWxvYWRzID0gMTtcblx0Y29uc3QgZl91bnN1YnNjcmliZSA9IGdsb2JhbF9yZWNlaXZlKHtcblx0XHR1cGRhdGVTdG9yZSh7a2V5OnNpX3N0b3JlfSkge1xuXHRcdFx0aWYoJ2V2ZW50cycgPT09IHNpX3N0b3JlKSB7XG5cdFx0XHRcdGNfcmVsb2FkcysrO1xuXHRcdFx0fVxuXHRcdH0sXG5cdH0pO1xuXG5cdG9uRGVzdHJveSgoKSA9PiB7XG5cdFx0Zl91bnN1YnNjcmliZSgpO1xuXHR9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuPC9zdHlsZT5cblxuPFNjcmVlbiBuYXYgcm9vdFxuPlxuXHQ8SGVhZGVyIHNlYXJjaCBuZXR3b3JrIGFjY291bnRcblx0PlxuXHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInRpdGxlXCI+XG5cblx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0PC9IZWFkZXI+XG5cblx0PFN1YkhlYWRlclxuXHRcdHRpdGxlPSdIaXN0b3J5J1xuXHRcdGJhcmVcblx0PjwvU3ViSGVhZGVyPlxuXG5cdDwhLS0gXG5cdDxwIHN0eWxlPSdmb250LXNpemU6MTJweCc+XG5cdFx0PHNwYW4gc3R5bGU9J2NvbG9yOnZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pOyc+RGlzY2xhaW1lcjogPC9zcGFuPlxuXHRcdFRoaXMgdGVtcG9yYXJ5IGhpc3RvcnkgaW50ZXJmYWNlIGRvZXMgbm90IHJlcHJlc2VudCB0aGUgbG9vayBhbmQgZnVuY3Rpb24gb2YgdGhlIGFjdHVhbCBoaXN0b3J5IGludGVyZmFjZSBjdXJyZW50bHkgdW5kZXIgZGV2ZWxvcG1lbnQgZm9yIGJldGEuXG5cdDwvcD4gLS0+XG5cblx0eyNrZXkgY19yZWxvYWRzfVxuXHRcdHsjYXdhaXQgRXZlbnRzLnJlYWQoKX1cblx0XHRcdExvYWRpbmcgaGlzdG9yeS4uLlxuXHRcdHs6dGhlbiBrc19ldmVudHN9XG5cdFx0XHR7QGNvbnN0IGFfZXZlbnRzID0ga3NfZXZlbnRzLnJhd31cblxuXHRcdFx0PFR4bkxpc3Rcblx0XHRcdFx0ZXZlbnRzPXthX2V2ZW50c31cblx0XHRcdC8+XG5cdFx0ey9hd2FpdH1cblx0ey9rZXl9XG48L1NjcmVlbj5cbiIsImltcG9ydCBCbGFua1N2ZWx0ZSBmcm9tICcuL3NjcmVlbi9CbGFuay5zdmVsdGUnO1xuaW1wb3J0IFJlZ2lzdGVyU3ZlbHRlIGZyb20gJy4vc2NyZWVuL1JlZ2lzdGVyLnN2ZWx0ZSc7XG5pbXBvcnQgSG9sZGluZ3NIb21lU3ZlbHRlIGZyb20gJy4vc2NyZWVuL0hvbGRpbmdzSG9tZS5zdmVsdGUnO1xuaW1wb3J0IEFjY291bnRIb21lU3ZlbHRlIGZyb20gJy4vc2NyZWVuL0FjY291bnRzSG9tZS5zdmVsdGUnO1xuaW1wb3J0IENvbnRhY3RzSG9tZVN2ZWx0ZSBmcm9tICcuL3NjcmVlbi9Db250YWN0c0hvbWUuc3ZlbHRlJztcbmltcG9ydCBTaXRlc0hvbWVTdmVsdGUgZnJvbSAnLi9zY3JlZW4vU2l0ZXNIb21lLnN2ZWx0ZSc7XG5pbXBvcnQgTmV0d29ya3NIb21lU3ZlbHRlIGZyb20gJy4vc2NyZWVuL05ldHdvcmtzSG9tZS5zdmVsdGUnO1xuaW1wb3J0IEhpc3RvcnlIb21lU3ZlbHRlIGZyb20gJy4vc2NyZWVuL0hpc3RvcnlIb21lLnN2ZWx0ZSc7XG5cbmV4cG9ydCBlbnVtIFRocmVhZElkIHtcblx0REVGQVVMVD0nZGVmYXVsdCcsXG5cdElOSVQ9J2luaXQnLFxuXHRTRUFSQ0g9J3NlYXJjaCcsXG5cdFRPS0VOUz0ndG9rZW5zJyxcblx0TkZUUz0nbmZ0cycsXG5cdENPTlRBQ1RTPSdjb250YWN0cycsXG5cdEhJU1RPUlk9J2hpc3RvcnknLFxuXHRORVRXT1JLUz0nbmV0d29ya3MnLFxuXHRBQ0NPVU5UUz0nYWNjb3VudHMnLFxuXHRUQUdTPSd0YWdzJyxcblx0U0lURVM9J3NpdGVzJyxcbn1cblxuZXhwb3J0IGNvbnN0IEhfVEhSRUFEUyA9IHtcblx0W1RocmVhZElkLkRFRkFVTFRdOiBCbGFua1N2ZWx0ZSxcblx0W1RocmVhZElkLklOSVRdOiBSZWdpc3RlclN2ZWx0ZSxcblx0Ly8gW1RocmVhZElkLlNFQVJDSF06IFNlYXJjaCxcblx0W1RocmVhZElkLlRPS0VOU106IEhvbGRpbmdzSG9tZVN2ZWx0ZSxcblx0Ly8gW1RocmVhZElkLk5GVFNdOiBHYWxsZXJ5LFxuXHRbVGhyZWFkSWQuQ09OVEFDVFNdOiBDb250YWN0c0hvbWVTdmVsdGUsXG5cdFtUaHJlYWRJZC5ISVNUT1JZXTogSGlzdG9yeUhvbWVTdmVsdGUsXG5cdFtUaHJlYWRJZC5ORVRXT1JLU106IE5ldHdvcmtzSG9tZVN2ZWx0ZSxcblx0W1RocmVhZElkLkFDQ09VTlRTXTogQWNjb3VudEhvbWVTdmVsdGUsXG5cdC8vIC8vIFtUaHJlYWRJZC5UYWdzXTogVGFncyxcblx0W1RocmVhZElkLlNJVEVTXTogU2l0ZXNIb21lU3ZlbHRlLFxufSBhcyBjb25zdDtcbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7XG5cdFx0eXdfb3ZlcnNjcm9sbF9wY3QsXG5cdH0gZnJvbSAnIyMvbWVtJztcblxuXHRsZXQgZG1fcHJvZ3Jlc3M6IFNWR0NpcmNsZUVsZW1lbnQ7XG5cblx0Ly8gJDoge1xuXHQvLyBcdGRtX3Byb2dyZXNzLnN0eWxlLiR5d19vdmVyc2Nyb2xsX3BjdFxuXHQvLyB9XG48L3NjcmlwdD5cblxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0c3ZnIHtcblx0XHRkaXNwbGF5OiBub25lO1xuXHRcdHotaW5kZXg6IDIwMDAxO1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDEwcHg7XG5cdFx0bGVmdDogY2FsYyg1MCUgLSAxNnB4KTtcblxuXHRcdC5wcm9ncmVzcyB7XG5cdFx0XHRzdHJva2UtZGFzaGFycmF5OiA2Mjtcblx0XHRcdHN0cm9rZS1kYXNob2Zmc2V0OiA2Mjtcblx0XHRcdHN0cm9rZS1saW5lY2FwOiByb3VuZDtcblx0XHRcdHRyYW5zaXRpb246IHN0cm9rZS1kYXNoYXJyYXkgMTAwbXMgbGluZWFyO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuXG48c3ZnIHdpZHRoPVwiMzJcIiBoZWlnaHQ9XCIzMlwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgY2xhc3M9XCJvdmVyc2Nyb2xsXCI+XG5cdDxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcdC5vdmVyc2Nyb2xsIHtcblx0XHRcdC5iZyB7XG5cdFx0XHRcdGZpbGw6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQucmluZyB7XG5cdFx0XHRcdGZpbGw6IHRyYW5zcGFyZW50O1xuXHRcdFx0XHRzdHJva2U6ICNjNGM0YzQ7XG5cdFx0XHR9XG5cblx0XHRcdC5wcm9ncmVzcyB7XG5cdFx0XHRcdGZpbGw6IHRyYW5zcGFyZW50O1xuXHRcdFx0XHRzdHJva2U6IGJsYWNrO1xuXHRcdFx0fVxuXHRcdH1cblx0PC9zdHlsZT5cblxuXHQ8Y2lyY2xlIGN4PVwiMTZcIiBjeT1cIjE2XCIgcj1cIjE2XCIgY2xhc3M9XCJiZ1wiIC8+XG5cblx0PGNpcmNsZSBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxMFwiIGNsYXNzPVwicmluZ1wiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHlsZT1cIm9wYWNpdHk6MC4yO1wiIC8+XG5cblx0PGNpcmNsZSBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxMFwiIGNsYXNzPVwicHJvZ3Jlc3NcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3R5bGU9XCJzdHJva2UtZGFzaG9mZnNldDp7NjIgLSAoJHl3X292ZXJzY3JvbGxfcGN0ICogNjIpfVwiIGJpbmQ6dGhpcz17ZG1fcHJvZ3Jlc3N9IC8+XG5cdFxuXHQ8IS0tIDxwYXRoIGQ9XCJNMTYgMTYgQTE2IDYge3hhX3BjdH0ge3hhX3BjdH1cIiBjbGFzcz1cInMyci1vdmVyZmxvdy1mZ1wiIC8+IC0tPlxuPC9zdmc+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtcblx0XHR5d19wb3B1cCxcblx0fSBmcm9tICcjIy9tZW0nO1xuXG5cblx0XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0LnBvcHVwIHtcblx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IHZhcigtLWFwcC13aW5kb3ctaGVpZ2h0KTtcblx0XHRsZWZ0OiAwO1xuXHRcdHotaW5kZXg6IDExMDA7XG5cblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuXHRcdHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4zNXMgbGluZWFyO1xuXG5cdFx0Ji5zaG93aW5nIHtcblx0XHRcdHRvcDogMDtcblx0XHRcdHBvaW50ZXItZXZlbnRzOiBpbml0aWFsO1xuXHRcdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuXG5cdFx0XHQ+LmNvbnRlbnQge1xuXHRcdFx0XHQvLyB0b3A6IDI0cHg7XG5cdFx0XHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSgyNHB4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQ+LmNvbnRlbnQge1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0Ly8gdG9wOiB2YXIoLS1hcHAtd2luZG93LWhlaWdodCk7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRsZWZ0OiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdHdpZHRoOiBjYWxjKDEwMCUgLSB2YXIoLS11aS1wYWRkaW5nKSAtIHZhcigtLXVpLXBhZGRpbmcpKTtcblx0XHRcdGhlaWdodDogODclO1xuXHRcdFx0b3ZlcmZsb3cteTogc2Nyb2xsO1xuXHRcdFx0LmhpZGUtc2Nyb2xsYmFyKCk7XG5cblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblx0XHRcdGJvcmRlci1yYWRpdXM6IDhweDtcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRwYWRkaW5nOiB2YXIoLS11aS1wYWRkaW5nKTtcblxuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRnYXA6IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHQvLyB0cmFuc2l0aW9uOiB0b3AgNjc1bXMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDY3NW1zIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0XHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlWSh2YXIoLS1hcHAtd2luZG93LWhlaWdodCkpO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cInBvcHVwXCIgY2xhc3M6c2hvd2luZz17bnVsbCAhPT0gJHl3X3BvcHVwfSBvbjpjbGljaz17KCkgPT4gJHl3X3BvcHVwID0gbnVsbH0+XG5cdDxzZWN0aW9uIGNsYXNzPVwic2NyZWVuIGNvbnRlbnRcIiBvbjpjbGljaz17KGRfZXZlbnQpID0+IGRfZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9PlxuXHRcdDxzdmVsdGU6Y29tcG9uZW50IHRoaXM9eyR5d19wb3B1cH0+PC9zdmVsdGU6Y29tcG9uZW50PlxuXHQ8L3NlY3Rpb24+XG48L2Rpdj5cbiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTIgMTZMMTggMTBMMTYuNTkgOC41OUwxMiAxMy4xN0w3LjQxIDguNTlMNiAxMEwxMiAxNlpcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLXRva2Vucy1mZyB7XFxuXFx0XFx0XFx0ZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcblxcdFxcdH1cXG5cXHQ8L3N0eWxlPlxcblxcdDxwYXRoIGNsYXNzPVxcXCJzMnItdG9rZW5zLWZnXFxcIiBkPVxcXCJNMTUgNGMtNC40MiAwLTggMy41OC04IDhzMy41OCA4IDggOCA4LTMuNTggOC04LTMuNTgtOC04LThabTAgMTRjLTMuMzEgMC02LTIuNjktNi02czIuNjktNiA2LTYgNiAyLjY5IDYgNi0yLjY5IDYtNiA2Wk0zIDEyYTUuOTkgNS45OSAwIDAgMSA0LTUuNjVWNC4yNkMzLjU1IDUuMTUgMSA4LjI3IDEgMTJjMCAzLjczIDIuNTUgNi44NSA2IDcuNzR2LTIuMDlBNS45OSA1Ljk5IDAgMCAxIDMgMTJaXFxcIiAvPlxcbjwvc3ZnPlxcblwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIk0xMyAzYTkgOSAwIDAgMC05IDlIMWwzLjg5IDMuODkuMDcuMTRMOSAxMkg2YzAtMy44NyAzLjEzLTcgNy03czcgMy4xMyA3IDctMy4xMyA3LTcgN2MtMS45MyAwLTMuNjgtLjc5LTQuOTQtMi4wNmwtMS40MiAxLjQyQTguOTU0IDguOTU0IDAgMCAwIDEzIDIxYTkgOSAwIDAgMCAwLTE4Wm0tMSA1djVsNC4yNSAyLjUyLjc3LTEuMjgtMy41Mi0yLjA5VjhIMTJaXFxcIiAvPlxcbjwvc3ZnPlxcblwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+XFxuXFx0XFx0LnMyci1tZW51LWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1tZW51LWZnXFxcIiBkPVxcXCJNNCAxOWgxNmMuNTUgMCAxLS40NSAxLTFzLS40NS0xLTEtMUg0Yy0uNTUgMC0xIC40NS0xIDFzLjQ1IDEgMSAxWm0wLTZoMTZjLjU1IDAgMS0uNDUgMS0xcy0uNDUtMS0xLTFINGMtLjU1IDAtMSAuNDUtMSAxcy40NSAxIDEgMVpNMyA2YzAgLjU1LjQ1IDEgMSAxaDE2Yy41NSAwIDEtLjQ1IDEtMXMtLjQ1LTEtMS0xSDRjLS41NSAwLTEgLjQ1LTEgMVpcXFwiIC8+XFxuPC9zdmc+XFxuXCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBIX1RIUkVBRFMsIFRocmVhZElkIH0gZnJvbSAnIyMvZGVmJztcblx0aW1wb3J0IHtcblx0XHR5d19wYXR0ZXJuLFxuXHRcdHl3X25hdl9jb2xsYXBzZWQsXG5cdFx0Ly8geXdfdGhyZWFkX2lkLFxuXHRcdHl3X25hdl92aXNpYmxlLFxuXHRcdHl3X21lbnVfZXhwYW5kZWQsXG5cdFx0eXdfYmx1cixcblx0XHR5d19vdmVybGF5X25ldHdvcmssXG5cdFx0eXdfb3ZlcmxheV9hY2NvdW50LFxuXHRcdHl3X25vdGlmaWNhdGlvbnMsXG5cdFx0eXdfbmF2aWdhdG9yLFxuXHRcdHl3X3BhZ2UsXG5cdFx0eXdfdGhyZWFkLFxuXHR9IGZyb20gJyMjL21lbSc7XG5cblx0aW1wb3J0IHsgb2RlLCBvZGVyYWMsIG9kZXJvbSB9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXHRpbXBvcnQgU1hfSUNPTl9FWFBBTkQgZnJvbSAnIy9pY29uL2V4cGFuZC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fVE9LRU5TIGZyb20gJyMvaWNvbi90b2tlbnMuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NPTlRBQ1RTIGZyb20gJyMvaWNvbi9hY2NvdW50X2JveC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fSElTVE9SWSBmcm9tICcjL2ljb24vaGlzdG9yeS5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fTkZUIGZyb20gJyMvaWNvbi9uZnRzLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9NRU5VIGZyb20gJyMvaWNvbi9tZW51LnN2Zz9yYXcnO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBQYWdlIH0gZnJvbSAnIy9hcHAvbmF2L3BhZ2UnO1xuXHRpbXBvcnQgSG9sZGluZ3NIb21lIGZyb20gJyMvYXBwL3NjcmVlbi9Ib2xkaW5nc0hvbWUuc3ZlbHRlJztcblx0aW1wb3J0IHR5cGUgeyBQYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3IgfSBmcm9tICcjL21ldGEvc3ZlbHRlJztcblxuXHQvLyBuYXYgYmFyIGRlZmluaXRpb25cblx0Y29uc3QgSF9CVVRUT05TID0ge1xuXHRcdFtUaHJlYWRJZC5UT0tFTlNdOiB7XG5cdFx0XHRzdmc6IFNYX0lDT05fVE9LRU5TLFxuXHRcdFx0bGFiZWw6ICdUb2tlbnMnLFxuXHRcdH0sXG5cdFx0W1RocmVhZElkLkNPTlRBQ1RTXToge1xuXHRcdFx0c3ZnOiBTWF9JQ09OX0NPTlRBQ1RTLFxuXHRcdFx0bGFiZWw6ICdDb250YWN0cycsXG5cdFx0XHRkaXNhYmxlZDogdHJ1ZSxcblx0XHR9LFxuXHRcdC8vIFtUaHJlYWRJZC5ORlRTXToge1xuXHRcdC8vIFx0c3ZnOiBTWF9JQ09OX05GVCxcblx0XHQvLyBcdGxhYmVsOiAnTkZUcycsXG5cdFx0Ly8gfSxcblx0XHRbVGhyZWFkSWQuSElTVE9SWV06IHtcblx0XHRcdHN2ZzogU1hfSUNPTl9ISVNUT1JZLFxuXHRcdFx0bGFiZWw6ICdIaXN0b3J5Jyxcblx0XHRcdC8vIGRpc2FibGVkOiB0cnVlLFxuXHRcdH0sXG5cdFx0bWVudToge1xuXHRcdFx0c3ZnOiBTWF9JQ09OX01FTlUsXG5cdFx0XHRsYWJlbDogJ01lbnUnLFxuXHRcdH0sXG5cdH0gYXMgUmVjb3JkPHN0cmluZywge1xuXHRcdHN2Zzogc3RyaW5nO1xuXHRcdGxhYmVsOiBzdHJpbmc7XG5cdH0+O1xuXG5cdGNvbnN0IEhNX0hPTUVTQ1JFRU5TID0gbmV3IE1hcDxQYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3IsIFRocmVhZElkPihcblx0XHRvZGVyYWMoSF9USFJFQURTLCAoc2lfdGhyZWFkLCBkY19jcmVhdG9yKSA9PiBbZGNfY3JlYXRvciwgc2lfdGhyZWFkIGFzIFRocmVhZElkXSkpO1xuXG5cdGxldCBzaV90aHJlYWRfaGVhZDogJycgfCBUaHJlYWRJZCA9ICcnO1xuXHQkOiBzaV90aHJlYWRfaGVhZCA9ICR5d19wYWdlPyBITV9IT01FU0NSRUVOUy5nZXQoJHl3X3BhZ2UuY3JlYXRvcikgfHwgJyc6ICcnO1xuXG5cdFxuXHRmdW5jdGlvbiB0b2dnbGVfY29sbGFwc2VkKCkge1xuXHRcdCR5d19uYXZfY29sbGFwc2VkID0gISR5d19uYXZfY29sbGFwc2VkO1xuXHR9XG5cblx0ZnVuY3Rpb24gbmF2X2NsaWNrKHNpX2J1dHRvbjogc3RyaW5nKSB7XG5cdFx0Ly8gcmVtb3ZlIG5vdGlmaWNhdGlvblxuXHRcdCR5d19ub3RpZmljYXRpb25zID0gJHl3X25vdGlmaWNhdGlvbnMuZmlsdGVyKHNpID0+IHNpX2J1dHRvbiAhPT0gc2kpO1xuXG5cdFx0Ly8gYmx1ciBpcyBhY3RpdmVcblx0XHRpZigkeXdfYmx1cikge1xuXHRcdFx0Ly8gY2FuY2VsIGJsdXJcblx0XHRcdCR5d19ibHVyID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gbmV0d29yayBvdmVybGF5IGlzIGFjdGl2ZVxuXHRcdGlmKCR5d19vdmVybGF5X25ldHdvcmspIHtcblx0XHRcdCR5d19vdmVybGF5X25ldHdvcmsgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBhY2NvdW50IG92ZXJsYXkgaXMgYWN0aXZlXG5cdFx0aWYoJHl3X292ZXJsYXlfYWNjb3VudCkge1xuXHRcdFx0JHl3X292ZXJsYXlfYWNjb3VudCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGRlcGVuZGluZyBvbiBidXR0b24gY2xpY2tcblx0XHRzd2l0Y2goc2lfYnV0dG9uKSB7XG5cdFx0XHQvLyBtZW51XG5cdFx0XHRjYXNlICdtZW51Jzoge1xuXHRcdFx0XHQvLyBleHBhbmQgbWVudVxuXHRcdFx0XHQkeXdfbWVudV9leHBhbmRlZCA9IHRydWU7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGN1cnJlbnQgdGhyZWFkIGhlYWQgbG9hZGVkXG5cdFx0XHRjYXNlIHNpX3RocmVhZF9oZWFkOiB7XG5cdFx0XHRcdC8vIHNjcm9sbCB0byB0b3Agc21vb3RobHlcblx0XHRcdFx0JHl3X25hdmlnYXRvci5hY3RpdmVQYWdlLmRvbS5zY3JvbGxUbyh7XG5cdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0YmVoYXZpb3I6ICdzbW9vdGgnLFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Ly8gd2l0aGluIHRoaXMgdGhyZWFkXG5cdFx0XHRjYXNlICR5d190aHJlYWQuaWQ6IHtcblx0XHRcdFx0Ly8gcHJldmlvdXM7IHBvcFxuXHRcdFx0XHRjb25zdCBrX3ByZXZpb3VzID0gJHl3X3BhZ2UucGVhaygpO1xuXHRcdFx0XHRpZihrX3ByZXZpb3VzICYmIEhNX0hPTUVTQ1JFRU5TLmdldChrX3ByZXZpb3VzLmNyZWF0b3IpID09PSAkeXdfdGhyZWFkLmlkKSB7XG5cdFx0XHRcdFx0JHl3X3BhZ2UucG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY3VycmVudCB0aHJlYWQgd29uJ3QgY2F1c2UgdXBkYXRlXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdCR5d19wYWdlLnJlc2V0KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Ly8gc3dpdGNoIHRocmVhZFxuXHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHQvLyAkeXdfdGhyZWFkX2lkID0gc2lfYnV0dG9uIGFzIFRocmVhZElkO1xuXHRcdFx0XHR2b2lkICR5d19uYXZpZ2F0b3IuYWN0aXZhdGVUaHJlYWQoc2lfYnV0dG9uIGFzIFRocmVhZElkKTtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC8vIGNvbnN0IEhNX0hPTUVTQ1JFRU5TID0gbmV3IE1hcDxQYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3IsIFRocmVhZElkPihbXG5cdC8vIFx0W0hvbGRpbmdzLCBUaHJlYWRJZC5UT0tFTlNdLFxuXHQvLyBcdFtDb250YWN0TGlzdCwgVGhyZWFkSWQuQ09OVEFDVFNdLFxuXHQvLyBdKTtcblxuXHQvLyBjb25zdCBIX0hPTUVTOiBSZWNvcmQ8c3RyaW5nLCBUaHJlYWRJZD4gPSB7XG5cdC8vIFx0Jy9mYW1pbGllcy97ZmFtaWx5SWR9L2NoYWlucy97Y2hhaW5JZH0vaG9sZGluZ3Mve2FjY291bnRJZH0nOiBUaHJlYWRJZC5UT0tFTlMsXG5cdC8vIFx0Jy9mYW1pbGllcy97ZmFtaWx5SWR9L2NoYWlucy97Y2hhaW5JZH0vZ2FsbGVyeS97YWNjb3VudElkfSc6IFRocmVhZElkLk5GVFMsXG5cdC8vIFx0Jy9jb250YWN0cyc6IFRocmVhZElkLkNPTlRBQ1RTLFxuXHQvLyBcdC8vICcvbmV0d29ya3MnOiBUaHJlYWRJZC5ORVRXT1JLUyxcblx0Ly8gXHQnL2FjY291bnRzJzogVGhyZWFkSWQuQUNDT1VOVFMsXG5cdC8vIFx0Jy9oaXN0b3J5JzogVGhyZWFkSWQuSElTVE9SWSxcblx0Ly8gfTtcblxuXHQvLyBsZXQgc2lfdGhyZWFkX2hlYWQ6ICcnIHwgVGhyZWFkSWQgPSAnJztcblx0Ly8gJDoge1xuXHQvLyBcdCR5d19wYWdlXG5cdC8vIFx0JHl3X3RocmVhZFxuXHQvLyBcdC8vIGNvbnN0IHN4X3BhdHRlcm4gPSAkeXdfcGF0dGVybjtcblxuXHQvLyBcdHNpX3RocmVhZF9oZWFkID0gSF9IT01FU1tzeF9wYXR0ZXJuXSB8fCAnJztcblx0Ly8gfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdG5hdiB7XG5cdFx0LS1uYXYtaGVpZ2h0OiA3MnB4O1xuXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdGJvdHRvbTogMDtcblx0XHRoZWlnaHQ6IHZhcigtLW5hdi1oZWlnaHQpO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHR6LWluZGV4OiAxMDAwO1xuXG5cdFx0dHJhbnNpdGlvbjogYm90dG9tIDFzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblxuXHRcdGRpc3BsYXk6IG5vbmU7XG5cdFx0Ji52aXNpYmxlIHtcblx0XHRcdGRpc3BsYXk6IGluaXRpYWw7XG5cdFx0fVxuXG5cdFx0Ji5jb2xsYXBzZWQge1xuXHRcdFx0Ym90dG9tOiBjYWxjKDBweCAtIHZhcigtLW5hdi1oZWlnaHQpKTtcblxuXHRcdFx0Pi5jb2xsYXBzZS5pY29uPnN2ZyB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKC0xODBkZWcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pi5jb2xsYXBzZS5pY29uIHtcblx0XHRcdC0tYnV0dG9uLWRpYW1ldGVyOiAzMnB4O1xuXHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0LS1zdmctY29sb3ItZmc6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXG5cdFx0XHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHJpZ2h0OiAwO1xuXHRcdFx0dG9wOiBjYWxjKDBweCAtIHZhcigtLWJ1dHRvbi1kaWFtZXRlcikpO1xuXG5cdFx0XHRib3JkZXItcmFkaXVzOiAwO1xuXHRcdFx0Ym9yZGVyLWJvdHRvbS13aWR0aDogMDtcblx0XHRcdGJvcmRlci1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cblx0XHRcdD5zdmcge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHR0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcblx0XHRcdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMXMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHR9XG5cblx0XHQ+LmJhciB7XG5cdFx0XHRsaXN0LXN0eWxlOiBub25lO1xuXHRcdFx0cGFkZGluZzogMDtcblx0XHRcdG1hcmdpbjogMDtcblxuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblxuXHRcdFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cblx0XHRcdD4uYnV0dG9uIHtcblx0XHRcdFx0ZmxleDogMTtcblx0XHRcdFx0cGFkZGluZy10b3A6IDExcHg7XG5cdFx0XHRcdHBhZGRpbmctYm90dG9tOiAxMnB4O1xuXG5cdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdFx0LS1zdmctY29sb3ItZmc6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXG5cdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblxuXHRcdFx0XHQmLmFjdGl2ZSB7XG5cdFx0XHRcdFx0Ji50b2tlbnMge1xuXHRcdFx0XHRcdFx0LS1zdmctY29sb3ItZmc6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQmLmNvbnRhY3RzIHtcblx0XHRcdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ji5uZnRzIHtcblx0XHRcdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ji5oaXN0b3J5IHtcblx0XHRcdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+LmxhYmVsIHtcblx0XHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+Lmljb24ge1xuXHRcdFx0XHRcdC5pbmhlcml0KC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQubm90aWZpY2F0aW9uIHtcblx0XHRcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdFx0d2lkdGg6IDdweDtcblx0XHRcdFx0XHRoZWlnaHQ6IDdweDtcblx0XHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1za3kpO1xuXHRcdFx0XHRcdGJvcmRlci1yYWRpdXM6IDdweDtcblx0XHRcdFx0XHRtYXJnaW4tdG9wOiAxNXB4O1xuXHRcdFx0XHRcdGJvcmRlcjogMnB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblx0XHRcdFx0XHRtYXJnaW4tbGVmdDogLTlweDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4ubGFiZWwge1xuXHRcdFx0XHRcdGZvbnQtc2l6ZTogMTFweDtcblx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48bmF2IGNsYXNzOmNvbGxhcHNlZD17JHl3X25hdl9jb2xsYXBzZWR9IGNsYXNzOnZpc2libGU9eyR5d19uYXZfdmlzaWJsZX0+XG5cdDxkaXYgY2xhc3M9XCJjb2xsYXBzZSBpY29uXCIgb246Y2xpY2s9eygpID0+IHRvZ2dsZV9jb2xsYXBzZWQoKX0+XG5cdFx0e0BodG1sIFNYX0lDT05fRVhQQU5EfVxuXHQ8L2Rpdj5cblx0PHVsIGNsYXNzPVwiYmFyXCI+XG5cdFx0eyNlYWNoIG9kZShIX0JVVFRPTlMpIGFzIFtzaV9idXR0b24sIGdfYnV0dG9uXX1cblx0XHRcdHsjaWYgZ19idXR0b24uZGlzYWJsZWR9XG5cdFx0XHRcdDxsaSBjbGFzcz1cImJ1dHRvbiB7c2lfYnV0dG9ufVwiIGNsYXNzOmFjdGl2ZT17c2lfdGhyZWFkX2hlYWQgPT09IHNpX2J1dHRvbn0gc3R5bGU9XCJvcGFjaXR5OiAwLjU7XCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0XHRcdHtAaHRtbCBnX2J1dHRvbi5zdmd9XG5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibm90aWZpY2F0aW9uXCIgY2xhc3M6ZGlzcGxheV9ub25lPXshJHl3X25vdGlmaWNhdGlvbnMuaW5jbHVkZXMoc2lfYnV0dG9uKX0+PC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJsYWJlbFwiPlxuXHRcdFx0XHRcdFx0e2dfYnV0dG9uLmxhYmVsfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ8bGkgY2xhc3M9XCJidXR0b24ge3NpX2J1dHRvbn1cIiBjbGFzczphY3RpdmU9e3NpX3RocmVhZF9oZWFkID09PSBzaV9idXR0b259IG9uOmNsaWNrPXsoKSA9PiBuYXZfY2xpY2soc2lfYnV0dG9uKX0+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0XHRcdHtAaHRtbCBnX2J1dHRvbi5zdmd9XG5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibm90aWZpY2F0aW9uXCIgY2xhc3M6ZGlzcGxheV9ub25lPXshJHl3X25vdGlmaWNhdGlvbnMuaW5jbHVkZXMoc2lfYnV0dG9uKX0+PC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJsYWJlbFwiPlxuXHRcdFx0XHRcdFx0e2dfYnV0dG9uLmxhYmVsfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2xpPlxuXHRcdFx0ey9pZn1cblx0XHR7L2VhY2h9XG5cdFx0PC91bD5cbjwvbmF2PlxuIiwiLyoqXG4gKiBGdXNlLmpzIHY2LjYuMiAtIExpZ2h0d2VpZ2h0IGZ1enp5LXNlYXJjaCAoaHR0cDovL2Z1c2Vqcy5pbylcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjIgS2lybyBSaXNrIChodHRwOi8va2lyby5tZSlcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuIEFwYWNoZSBTb2Z0d2FyZSBMaWNlbnNlIDIuMFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICovXG5cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5XG4gICAgPyBnZXRUYWcodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbHVlKVxufVxuXG4vLyBBZGFwdGVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvbWFzdGVyLy5pbnRlcm5hbC9iYXNlVG9TdHJpbmcuanNcbmNvbnN0IElORklOSVRZID0gMSAvIDA7XG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIGxldCByZXN1bHQgPSB2YWx1ZSArICcnO1xuICByZXR1cm4gcmVzdWx0ID09ICcwJyAmJiAxIC8gdmFsdWUgPT0gLUlORklOSVRZID8gJy0wJyA6IHJlc3VsdFxufVxuXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKVxufVxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xufVxuXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vLyBBZGFwdGVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvbWFzdGVyL2lzQm9vbGVhbi5qc1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgPT09IHRydWUgfHxcbiAgICB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09ICdbb2JqZWN0IEJvb2xlYW5dJylcbiAgKVxufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG4vLyBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0JsYW5rKHZhbHVlKSB7XG4gIHJldHVybiAhdmFsdWUudHJpbSgpLmxlbmd0aFxufVxuXG4vLyBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4vLyBBZGFwdGVkIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvbWFzdGVyLy5pbnRlcm5hbC9nZXRUYWcuanNcbmZ1bmN0aW9uIGdldFRhZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbFxuICAgID8gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnW29iamVjdCBVbmRlZmluZWRdJ1xuICAgICAgOiAnW29iamVjdCBOdWxsXSdcbiAgICA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcbn1cblxuY29uc3QgRVhURU5ERURfU0VBUkNIX1VOQVZBSUxBQkxFID0gJ0V4dGVuZGVkIHNlYXJjaCBpcyBub3QgYXZhaWxhYmxlJztcblxuY29uc3QgSU5DT1JSRUNUX0lOREVYX1RZUEUgPSBcIkluY29ycmVjdCAnaW5kZXgnIHR5cGVcIjtcblxuY29uc3QgTE9HSUNBTF9TRUFSQ0hfSU5WQUxJRF9RVUVSWV9GT1JfS0VZID0gKGtleSkgPT5cbiAgYEludmFsaWQgdmFsdWUgZm9yIGtleSAke2tleX1gO1xuXG5jb25zdCBQQVRURVJOX0xFTkdUSF9UT09fTEFSR0UgPSAobWF4KSA9PlxuICBgUGF0dGVybiBsZW5ndGggZXhjZWVkcyBtYXggb2YgJHttYXh9LmA7XG5cbmNvbnN0IE1JU1NJTkdfS0VZX1BST1BFUlRZID0gKG5hbWUpID0+IGBNaXNzaW5nICR7bmFtZX0gcHJvcGVydHkgaW4ga2V5YDtcblxuY29uc3QgSU5WQUxJRF9LRVlfV0VJR0hUX1ZBTFVFID0gKGtleSkgPT5cbiAgYFByb3BlcnR5ICd3ZWlnaHQnIGluIGtleSAnJHtrZXl9JyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcmA7XG5cbmNvbnN0IGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmNsYXNzIEtleVN0b3JlIHtcbiAgY29uc3RydWN0b3Ioa2V5cykge1xuICAgIHRoaXMuX2tleXMgPSBbXTtcbiAgICB0aGlzLl9rZXlNYXAgPSB7fTtcblxuICAgIGxldCB0b3RhbFdlaWdodCA9IDA7XG5cbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbGV0IG9iaiA9IGNyZWF0ZUtleShrZXkpO1xuXG4gICAgICB0b3RhbFdlaWdodCArPSBvYmoud2VpZ2h0O1xuXG4gICAgICB0aGlzLl9rZXlzLnB1c2gob2JqKTtcbiAgICAgIHRoaXMuX2tleU1hcFtvYmouaWRdID0gb2JqO1xuXG4gICAgICB0b3RhbFdlaWdodCArPSBvYmoud2VpZ2h0O1xuICAgIH0pO1xuXG4gICAgLy8gTm9ybWFsaXplIHdlaWdodHMgc28gdGhhdCB0aGVpciBzdW0gaXMgZXF1YWwgdG8gMVxuICAgIHRoaXMuX2tleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBrZXkud2VpZ2h0IC89IHRvdGFsV2VpZ2h0O1xuICAgIH0pO1xuICB9XG4gIGdldChrZXlJZCkge1xuICAgIHJldHVybiB0aGlzLl9rZXlNYXBba2V5SWRdXG4gIH1cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5c1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5fa2V5cylcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXkoa2V5KSB7XG4gIGxldCBwYXRoID0gbnVsbDtcbiAgbGV0IGlkID0gbnVsbDtcbiAgbGV0IHNyYyA9IG51bGw7XG4gIGxldCB3ZWlnaHQgPSAxO1xuICBsZXQgZ2V0Rm4gPSBudWxsO1xuXG4gIGlmIChpc1N0cmluZyhrZXkpIHx8IGlzQXJyYXkoa2V5KSkge1xuICAgIHNyYyA9IGtleTtcbiAgICBwYXRoID0gY3JlYXRlS2V5UGF0aChrZXkpO1xuICAgIGlkID0gY3JlYXRlS2V5SWQoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKGtleSwgJ25hbWUnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfS0VZX1BST1BFUlRZKCduYW1lJykpXG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGtleS5uYW1lO1xuICAgIHNyYyA9IG5hbWU7XG5cbiAgICBpZiAoaGFzT3duLmNhbGwoa2V5LCAnd2VpZ2h0JykpIHtcbiAgICAgIHdlaWdodCA9IGtleS53ZWlnaHQ7XG5cbiAgICAgIGlmICh3ZWlnaHQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9LRVlfV0VJR0hUX1ZBTFVFKG5hbWUpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHBhdGggPSBjcmVhdGVLZXlQYXRoKG5hbWUpO1xuICAgIGlkID0gY3JlYXRlS2V5SWQobmFtZSk7XG4gICAgZ2V0Rm4gPSBrZXkuZ2V0Rm47XG4gIH1cblxuICByZXR1cm4geyBwYXRoLCBpZCwgd2VpZ2h0LCBzcmMsIGdldEZuIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5UGF0aChrZXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkoa2V5KSA/IGtleSA6IGtleS5zcGxpdCgnLicpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleUlkKGtleSkge1xuICByZXR1cm4gaXNBcnJheShrZXkpID8ga2V5LmpvaW4oJy4nKSA6IGtleVxufVxuXG5mdW5jdGlvbiBnZXQob2JqLCBwYXRoKSB7XG4gIGxldCBsaXN0ID0gW107XG4gIGxldCBhcnIgPSBmYWxzZTtcblxuICBjb25zdCBkZWVwR2V0ID0gKG9iaiwgcGF0aCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWlzRGVmaW5lZChvYmopKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFwYXRoW2luZGV4XSkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXRoIGxlZnQsIHdlJ3ZlIGFycml2ZWQgYXQgdGhlIG9iamVjdCB3ZSBjYXJlIGFib3V0LlxuICAgICAgbGlzdC5wdXNoKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBrZXkgPSBwYXRoW2luZGV4XTtcblxuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgbGFzdCB2YWx1ZSBpbiB0aGUgcGF0aCwgYW5kIGlmIGl0J3MgYSBzdHJpbmcvbnVtYmVyL2Jvb2wsXG4gICAgICAvLyBhZGQgaXQgdG8gdGhlIGxpc3RcbiAgICAgIGlmIChcbiAgICAgICAgaW5kZXggPT09IHBhdGgubGVuZ3RoIC0gMSAmJlxuICAgICAgICAoaXNTdHJpbmcodmFsdWUpIHx8IGlzTnVtYmVyKHZhbHVlKSB8fCBpc0Jvb2xlYW4odmFsdWUpKVxuICAgICAgKSB7XG4gICAgICAgIGxpc3QucHVzaCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhcnIgPSB0cnVlO1xuICAgICAgICAvLyBTZWFyY2ggZWFjaCBpdGVtIGluIHRoZSBhcnJheS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgZGVlcEdldCh2YWx1ZVtpXSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAvLyBBbiBvYmplY3QuIFJlY3Vyc2UgZnVydGhlci5cbiAgICAgICAgZGVlcEdldCh2YWx1ZSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKHNpbmNlIHBhdGggdXNlZCB0byBiZSBhIHN0cmluZylcbiAgZGVlcEdldChvYmosIGlzU3RyaW5nKHBhdGgpID8gcGF0aC5zcGxpdCgnLicpIDogcGF0aCwgMCk7XG5cbiAgcmV0dXJuIGFyciA/IGxpc3QgOiBsaXN0WzBdXG59XG5cbmNvbnN0IE1hdGNoT3B0aW9ucyA9IHtcbiAgLy8gV2hldGhlciB0aGUgbWF0Y2hlcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdCBzZXQuIFdoZW4gYHRydWVgLCBlYWNoIHJlY29yZCBpbiB0aGUgcmVzdWx0XG4gIC8vIHNldCB3aWxsIGluY2x1ZGUgdGhlIGluZGljZXMgb2YgdGhlIG1hdGNoZWQgY2hhcmFjdGVycy5cbiAgLy8gVGhlc2UgY2FuIGNvbnNlcXVlbnRseSBiZSB1c2VkIGZvciBoaWdobGlnaHRpbmcgcHVycG9zZXMuXG4gIGluY2x1ZGVNYXRjaGVzOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIHRvIHRoZSBlbmQgb2YgYSBzZWFyY2ggcGF0dGVybiBldmVuIGlmXG4gIC8vIGEgcGVyZmVjdCBtYXRjaCBoYXMgYWxyZWFkeSBiZWVuIGxvY2F0ZWQgaW4gdGhlIHN0cmluZy5cbiAgZmluZEFsbE1hdGNoZXM6IGZhbHNlLFxuICAvLyBNaW5pbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgbXVzdCBiZSBtYXRjaGVkIGJlZm9yZSBhIHJlc3VsdCBpcyBjb25zaWRlcmVkIGEgbWF0Y2hcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoOiAxXG59O1xuXG5jb25zdCBCYXNpY09wdGlvbnMgPSB7XG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgYWxnb3JpdGhtIGNvbnRpbnVlcyBzZWFyY2hpbmcgdG8gdGhlIGVuZCBvZiB0aGUgaW5wdXQgZXZlbiBpZiBhIHBlcmZlY3RcbiAgLy8gbWF0Y2ggaXMgZm91bmQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHNhbWUgaW5wdXQuXG4gIGlzQ2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gIC8vIFdoZW4gdHJ1ZSwgdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHdpbGwgY29udGludWUgdG8gdGhlIGVuZCBvZiBhIHNlYXJjaCBwYXR0ZXJuIGV2ZW4gaWZcbiAgaW5jbHVkZVNjb3JlOiBmYWxzZSxcbiAgLy8gTGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBzZWFyY2hlZC4gVGhpcyBhbHNvIHN1cHBvcnRzIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICBrZXlzOiBbXSxcbiAgLy8gV2hldGhlciB0byBzb3J0IHRoZSByZXN1bHQgbGlzdCwgYnkgc2NvcmVcbiAgc2hvdWxkU29ydDogdHJ1ZSxcbiAgLy8gRGVmYXVsdCBzb3J0IGZ1bmN0aW9uOiBzb3J0IGJ5IGFzY2VuZGluZyBzY29yZSwgYXNjZW5kaW5nIGluZGV4XG4gIHNvcnRGbjogKGEsIGIpID0+XG4gICAgYS5zY29yZSA9PT0gYi5zY29yZSA/IChhLmlkeCA8IGIuaWR4ID8gLTEgOiAxKSA6IGEuc2NvcmUgPCBiLnNjb3JlID8gLTEgOiAxXG59O1xuXG5jb25zdCBGdXp6eU9wdGlvbnMgPSB7XG4gIC8vIEFwcHJveGltYXRlbHkgd2hlcmUgaW4gdGhlIHRleHQgaXMgdGhlIHBhdHRlcm4gZXhwZWN0ZWQgdG8gYmUgZm91bmQ/XG4gIGxvY2F0aW9uOiAwLFxuICAvLyBBdCB3aGF0IHBvaW50IGRvZXMgdGhlIG1hdGNoIGFsZ29yaXRobSBnaXZlIHVwLiBBIHRocmVzaG9sZCBvZiAnMC4wJyByZXF1aXJlcyBhIHBlcmZlY3QgbWF0Y2hcbiAgLy8gKG9mIGJvdGggbGV0dGVycyBhbmQgbG9jYXRpb24pLCBhIHRocmVzaG9sZCBvZiAnMS4wJyB3b3VsZCBtYXRjaCBhbnl0aGluZy5cbiAgdGhyZXNob2xkOiAwLjYsXG4gIC8vIERldGVybWluZXMgaG93IGNsb3NlIHRoZSBtYXRjaCBtdXN0IGJlIHRvIHRoZSBmdXp6eSBsb2NhdGlvbiAoc3BlY2lmaWVkIGFib3ZlKS5cbiAgLy8gQW4gZXhhY3QgbGV0dGVyIG1hdGNoIHdoaWNoIGlzICdkaXN0YW5jZScgY2hhcmFjdGVycyBhd2F5IGZyb20gdGhlIGZ1enp5IGxvY2F0aW9uXG4gIC8vIHdvdWxkIHNjb3JlIGFzIGEgY29tcGxldGUgbWlzbWF0Y2guIEEgZGlzdGFuY2Ugb2YgJzAnIHJlcXVpcmVzIHRoZSBtYXRjaCBiZSBhdFxuICAvLyB0aGUgZXhhY3QgbG9jYXRpb24gc3BlY2lmaWVkLCBhIHRocmVzaG9sZCBvZiAnMTAwMCcgd291bGQgcmVxdWlyZSBhIHBlcmZlY3QgbWF0Y2hcbiAgLy8gdG8gYmUgd2l0aGluIDgwMCBjaGFyYWN0ZXJzIG9mIHRoZSBmdXp6eSBsb2NhdGlvbiB0byBiZSBmb3VuZCB1c2luZyBhIDAuOCB0aHJlc2hvbGQuXG4gIGRpc3RhbmNlOiAxMDBcbn07XG5cbmNvbnN0IEFkdmFuY2VkT3B0aW9ucyA9IHtcbiAgLy8gV2hlbiBgdHJ1ZWAsIGl0IGVuYWJsZXMgdGhlIHVzZSBvZiB1bml4LWxpa2Ugc2VhcmNoIGNvbW1hbmRzXG4gIHVzZUV4dGVuZGVkU2VhcmNoOiBmYWxzZSxcbiAgLy8gVGhlIGdldCBmdW5jdGlvbiB0byB1c2Ugd2hlbiBmZXRjaGluZyBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBUaGUgZGVmYXVsdCB3aWxsIHNlYXJjaCBuZXN0ZWQgcGF0aHMgKmllIGZvby5iYXIuYmF6KlxuICBnZXRGbjogZ2V0LFxuICAvLyBXaGVuIGB0cnVlYCwgc2VhcmNoIHdpbGwgaWdub3JlIGBsb2NhdGlvbmAgYW5kIGBkaXN0YW5jZWAsIHNvIGl0IHdvbid0IG1hdHRlclxuICAvLyB3aGVyZSBpbiB0aGUgc3RyaW5nIHRoZSBwYXR0ZXJuIGFwcGVhcnMuXG4gIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9mdXNlanMuaW8vY29uY2VwdHMvc2NvcmluZy10aGVvcnkuaHRtbCNmdXp6aW5lc3Mtc2NvcmVcbiAgaWdub3JlTG9jYXRpb246IGZhbHNlLFxuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGNhbGN1bGF0aW9uIGZvciB0aGUgcmVsZXZhbmNlIHNjb3JlICh1c2VkIGZvciBzb3J0aW5nKSB3aWxsXG4gIC8vIGlnbm9yZSB0aGUgZmllbGQtbGVuZ3RoIG5vcm0uXG4gIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9mdXNlanMuaW8vY29uY2VwdHMvc2NvcmluZy10aGVvcnkuaHRtbCNmaWVsZC1sZW5ndGgtbm9ybVxuICBpZ25vcmVGaWVsZE5vcm06IGZhbHNlLFxuICAvLyBUaGUgd2VpZ2h0IHRvIGRldGVybWluZSBob3cgbXVjaCBmaWVsZCBsZW5ndGggbm9ybSBlZmZlY3RzIHNjb3JpbmcuXG4gIGZpZWxkTm9ybVdlaWdodDogMVxufTtcblxudmFyIENvbmZpZyA9IHtcbiAgLi4uQmFzaWNPcHRpb25zLFxuICAuLi5NYXRjaE9wdGlvbnMsXG4gIC4uLkZ1enp5T3B0aW9ucyxcbiAgLi4uQWR2YW5jZWRPcHRpb25zXG59O1xuXG5jb25zdCBTUEFDRSA9IC9bXiBdKy9nO1xuXG4vLyBGaWVsZC1sZW5ndGggbm9ybTogdGhlIHNob3J0ZXIgdGhlIGZpZWxkLCB0aGUgaGlnaGVyIHRoZSB3ZWlnaHQuXG4vLyBTZXQgdG8gMyBkZWNpbWFscyB0byByZWR1Y2UgaW5kZXggc2l6ZS5cbmZ1bmN0aW9uIG5vcm0od2VpZ2h0ID0gMSwgbWFudGlzc2EgPSAzKSB7XG4gIGNvbnN0IGNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBtID0gTWF0aC5wb3coMTAsIG1hbnRpc3NhKTtcblxuICByZXR1cm4ge1xuICAgIGdldCh2YWx1ZSkge1xuICAgICAgY29uc3QgbnVtVG9rZW5zID0gdmFsdWUubWF0Y2goU1BBQ0UpLmxlbmd0aDtcblxuICAgICAgaWYgKGNhY2hlLmhhcyhudW1Ub2tlbnMpKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQobnVtVG9rZW5zKVxuICAgICAgfVxuXG4gICAgICAvLyBEZWZhdWx0IGZ1bmN0aW9uIGlzIDEvc3FydCh4KSwgd2VpZ2h0IG1ha2VzIHRoYXQgdmFyaWFibGVcbiAgICAgIGNvbnN0IG5vcm0gPSAxIC8gTWF0aC5wb3cobnVtVG9rZW5zLCAwLjUgKiB3ZWlnaHQpO1xuXG4gICAgICAvLyBJbiBwbGFjZSBvZiBgdG9GaXhlZChtYW50aXNzYSlgLCBmb3IgZmFzdGVyIGNvbXB1dGF0aW9uXG4gICAgICBjb25zdCBuID0gcGFyc2VGbG9hdChNYXRoLnJvdW5kKG5vcm0gKiBtKSAvIG0pO1xuXG4gICAgICBjYWNoZS5zZXQobnVtVG9rZW5zLCBuKTtcblxuICAgICAgcmV0dXJuIG5cbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRnVzZUluZGV4IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGdldEZuID0gQ29uZmlnLmdldEZuLFxuICAgIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHRcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5ub3JtID0gbm9ybShmaWVsZE5vcm1XZWlnaHQsIDMpO1xuICAgIHRoaXMuZ2V0Rm4gPSBnZXRGbjtcbiAgICB0aGlzLmlzQ3JlYXRlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zZXRJbmRleFJlY29yZHMoKTtcbiAgfVxuICBzZXRTb3VyY2VzKGRvY3MgPSBbXSkge1xuICAgIHRoaXMuZG9jcyA9IGRvY3M7XG4gIH1cbiAgc2V0SW5kZXhSZWNvcmRzKHJlY29yZHMgPSBbXSkge1xuICAgIHRoaXMucmVjb3JkcyA9IHJlY29yZHM7XG4gIH1cbiAgc2V0S2V5cyhrZXlzID0gW10pIHtcbiAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgIHRoaXMuX2tleXNNYXAgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSwgaWR4KSA9PiB7XG4gICAgICB0aGlzLl9rZXlzTWFwW2tleS5pZF0gPSBpZHg7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlKCkge1xuICAgIGlmICh0aGlzLmlzQ3JlYXRlZCB8fCAhdGhpcy5kb2NzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5pc0NyZWF0ZWQgPSB0cnVlO1xuXG4gICAgLy8gTGlzdCBpcyBBcnJheTxTdHJpbmc+XG4gICAgaWYgKGlzU3RyaW5nKHRoaXMuZG9jc1swXSkpIHtcbiAgICAgIHRoaXMuZG9jcy5mb3JFYWNoKChkb2MsIGRvY0luZGV4KSA9PiB7XG4gICAgICAgIHRoaXMuX2FkZFN0cmluZyhkb2MsIGRvY0luZGV4KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0IGlzIEFycmF5PE9iamVjdD5cbiAgICAgIHRoaXMuZG9jcy5mb3JFYWNoKChkb2MsIGRvY0luZGV4KSA9PiB7XG4gICAgICAgIHRoaXMuX2FkZE9iamVjdChkb2MsIGRvY0luZGV4KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMubm9ybS5jbGVhcigpO1xuICB9XG4gIC8vIEFkZHMgYSBkb2MgdG8gdGhlIGVuZCBvZiB0aGUgaW5kZXhcbiAgYWRkKGRvYykge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuc2l6ZSgpO1xuXG4gICAgaWYgKGlzU3RyaW5nKGRvYykpIHtcbiAgICAgIHRoaXMuX2FkZFN0cmluZyhkb2MsIGlkeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FkZE9iamVjdChkb2MsIGlkeCk7XG4gICAgfVxuICB9XG4gIC8vIFJlbW92ZXMgdGhlIGRvYyBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IG9mIHRoZSBpbmRleFxuICByZW1vdmVBdChpZHgpIHtcbiAgICB0aGlzLnJlY29yZHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAvLyBDaGFuZ2UgcmVmIGluZGV4IG9mIGV2ZXJ5IHN1YnNxdWVudCBkb2NcbiAgICBmb3IgKGxldCBpID0gaWR4LCBsZW4gPSB0aGlzLnNpemUoKTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnJlY29yZHNbaV0uaSAtPSAxO1xuICAgIH1cbiAgfVxuICBnZXRWYWx1ZUZvckl0ZW1BdEtleUlkKGl0ZW0sIGtleUlkKSB7XG4gICAgcmV0dXJuIGl0ZW1bdGhpcy5fa2V5c01hcFtrZXlJZF1dXG4gIH1cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvcmRzLmxlbmd0aFxuICB9XG4gIF9hZGRTdHJpbmcoZG9jLCBkb2NJbmRleCkge1xuICAgIGlmICghaXNEZWZpbmVkKGRvYykgfHwgaXNCbGFuayhkb2MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgcmVjb3JkID0ge1xuICAgICAgdjogZG9jLFxuICAgICAgaTogZG9jSW5kZXgsXG4gICAgICBuOiB0aGlzLm5vcm0uZ2V0KGRvYylcbiAgICB9O1xuXG4gICAgdGhpcy5yZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuICBfYWRkT2JqZWN0KGRvYywgZG9jSW5kZXgpIHtcbiAgICBsZXQgcmVjb3JkID0geyBpOiBkb2NJbmRleCwgJDoge30gfTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBrZXkgKGkuZSwgcGF0aCksIGFuZCBmZXRjaCB0aGUgdmFsdWUgYXQgdGhhdCBrZXlcbiAgICB0aGlzLmtleXMuZm9yRWFjaCgoa2V5LCBrZXlJbmRleCkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0ga2V5LmdldEZuID8ga2V5LmdldEZuKGRvYykgOiB0aGlzLmdldEZuKGRvYywga2V5LnBhdGgpO1xuXG4gICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBsZXQgc3ViUmVjb3JkcyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFjayA9IFt7IG5lc3RlZEFyckluZGV4OiAtMSwgdmFsdWUgfV07XG5cbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHsgbmVzdGVkQXJySW5kZXgsIHZhbHVlIH0gPSBzdGFjay5wb3AoKTtcblxuICAgICAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICAgICAgdjogdmFsdWUsXG4gICAgICAgICAgICAgIGk6IG5lc3RlZEFyckluZGV4LFxuICAgICAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3ViUmVjb3Jkcy5wdXNoKHN1YlJlY29yZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSwgaykgPT4ge1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBuZXN0ZWRBcnJJbmRleDogayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSA7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3JkLiRba2V5SW5kZXhdID0gc3ViUmVjb3JkcztcbiAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpICYmICFpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICBsZXQgc3ViUmVjb3JkID0ge1xuICAgICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAgIG46IHRoaXMubm9ybS5nZXQodmFsdWUpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVjb3JkLiRba2V5SW5kZXhdID0gc3ViUmVjb3JkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleXM6IHRoaXMua2V5cyxcbiAgICAgIHJlY29yZHM6IHRoaXMucmVjb3Jkc1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmRleChcbiAga2V5cyxcbiAgZG9jcyxcbiAgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiwgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodCB9ID0ge31cbikge1xuICBjb25zdCBteUluZGV4ID0gbmV3IEZ1c2VJbmRleCh7IGdldEZuLCBmaWVsZE5vcm1XZWlnaHQgfSk7XG4gIG15SW5kZXguc2V0S2V5cyhrZXlzLm1hcChjcmVhdGVLZXkpKTtcbiAgbXlJbmRleC5zZXRTb3VyY2VzKGRvY3MpO1xuICBteUluZGV4LmNyZWF0ZSgpO1xuICByZXR1cm4gbXlJbmRleFxufVxuXG5mdW5jdGlvbiBwYXJzZUluZGV4KFxuICBkYXRhLFxuICB7IGdldEZuID0gQ29uZmlnLmdldEZuLCBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0IH0gPSB7fVxuKSB7XG4gIGNvbnN0IHsga2V5cywgcmVjb3JkcyB9ID0gZGF0YTtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiwgZmllbGROb3JtV2VpZ2h0IH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cyk7XG4gIG15SW5kZXguc2V0SW5kZXhSZWNvcmRzKHJlY29yZHMpO1xuICByZXR1cm4gbXlJbmRleFxufVxuXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUkMShcbiAgcGF0dGVybixcbiAge1xuICAgIGVycm9ycyA9IDAsXG4gICAgY3VycmVudExvY2F0aW9uID0gMCxcbiAgICBleHBlY3RlZExvY2F0aW9uID0gMCxcbiAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICB9ID0ge31cbikge1xuICBjb25zdCBhY2N1cmFjeSA9IGVycm9ycyAvIHBhdHRlcm4ubGVuZ3RoO1xuXG4gIGlmIChpZ25vcmVMb2NhdGlvbikge1xuICAgIHJldHVybiBhY2N1cmFjeVxuICB9XG5cbiAgY29uc3QgcHJveGltaXR5ID0gTWF0aC5hYnMoZXhwZWN0ZWRMb2NhdGlvbiAtIGN1cnJlbnRMb2NhdGlvbik7XG5cbiAgaWYgKCFkaXN0YW5jZSkge1xuICAgIC8vIERvZGdlIGRpdmlkZSBieSB6ZXJvIGVycm9yLlxuICAgIHJldHVybiBwcm94aW1pdHkgPyAxLjAgOiBhY2N1cmFjeVxuICB9XG5cbiAgcmV0dXJuIGFjY3VyYWN5ICsgcHJveGltaXR5IC8gZGlzdGFuY2Vcbn1cblxuZnVuY3Rpb24gY29udmVydE1hc2tUb0luZGljZXMoXG4gIG1hdGNobWFzayA9IFtdLFxuICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoXG4pIHtcbiAgbGV0IGluZGljZXMgPSBbXTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAobGV0IGxlbiA9IG1hdGNobWFzay5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBtYXRjaCA9IG1hdGNobWFza1tpXTtcbiAgICBpZiAobWF0Y2ggJiYgc3RhcnQgPT09IC0xKSB7XG4gICAgICBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmICghbWF0Y2ggJiYgc3RhcnQgIT09IC0xKSB7XG4gICAgICBlbmQgPSBpIC0gMTtcbiAgICAgIGlmIChlbmQgLSBzdGFydCArIDEgPj0gbWluTWF0Y2hDaGFyTGVuZ3RoKSB7XG4gICAgICAgIGluZGljZXMucHVzaChbc3RhcnQsIGVuZF0pO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAtMTtcbiAgICB9XG4gIH1cblxuICAvLyAoaS0xIC0gc3RhcnQpICsgMSA9PiBpIC0gc3RhcnRcbiAgaWYgKG1hdGNobWFza1tpIC0gMV0gJiYgaSAtIHN0YXJ0ID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgIGluZGljZXMucHVzaChbc3RhcnQsIGkgLSAxXSk7XG4gIH1cblxuICByZXR1cm4gaW5kaWNlc1xufVxuXG4vLyBNYWNoaW5lIHdvcmQgc2l6ZVxuY29uc3QgTUFYX0JJVFMgPSAzMjtcblxuZnVuY3Rpb24gc2VhcmNoKFxuICB0ZXh0LFxuICBwYXR0ZXJuLFxuICBwYXR0ZXJuQWxwaGFiZXQsXG4gIHtcbiAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZSxcbiAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0JJVFMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFKE1BWF9CSVRTKSlcbiAgfVxuXG4gIGNvbnN0IHBhdHRlcm5MZW4gPSBwYXR0ZXJuLmxlbmd0aDtcbiAgLy8gU2V0IHN0YXJ0aW5nIGxvY2F0aW9uIGF0IGJlZ2lubmluZyB0ZXh0IGFuZCBpbml0aWFsaXplIHRoZSBhbHBoYWJldC5cbiAgY29uc3QgdGV4dExlbiA9IHRleHQubGVuZ3RoO1xuICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlbiBsb2NhdGlvbiA+IHRleHQubGVuZ3RoXG4gIGNvbnN0IGV4cGVjdGVkTG9jYXRpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsb2NhdGlvbiwgdGV4dExlbikpO1xuICAvLyBIaWdoZXN0IHNjb3JlIGJleW9uZCB3aGljaCB3ZSBnaXZlIHVwLlxuICBsZXQgY3VycmVudFRocmVzaG9sZCA9IHRocmVzaG9sZDtcbiAgLy8gSXMgdGhlcmUgYSBuZWFyYnkgZXhhY3QgbWF0Y2g/IChzcGVlZHVwKVxuICBsZXQgYmVzdExvY2F0aW9uID0gZXhwZWN0ZWRMb2NhdGlvbjtcblxuICAvLyBQZXJmb3JtYW5jZTogb25seSBjb21wdXRlciBtYXRjaGVzIHdoZW4gdGhlIG1pbk1hdGNoQ2hhckxlbmd0aCA+IDFcbiAgLy8gT1IgaWYgYGluY2x1ZGVNYXRjaGVzYCBpcyB0cnVlLlxuICBjb25zdCBjb21wdXRlTWF0Y2hlcyA9IG1pbk1hdGNoQ2hhckxlbmd0aCA+IDEgfHwgaW5jbHVkZU1hdGNoZXM7XG4gIC8vIEEgbWFzayBvZiB0aGUgbWF0Y2hlcywgdXNlZCBmb3IgYnVpbGRpbmcgdGhlIGluZGljZXNcbiAgY29uc3QgbWF0Y2hNYXNrID0gY29tcHV0ZU1hdGNoZXMgPyBBcnJheSh0ZXh0TGVuKSA6IFtdO1xuXG4gIGxldCBpbmRleDtcblxuICAvLyBHZXQgYWxsIGV4YWN0IG1hdGNoZXMsIGhlcmUgZm9yIHNwZWVkIHVwXG4gIHdoaWxlICgoaW5kZXggPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgYmVzdExvY2F0aW9uKSkgPiAtMSkge1xuICAgIGxldCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW5kZXgsXG4gICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuXG4gICAgY3VycmVudFRocmVzaG9sZCA9IE1hdGgubWluKHNjb3JlLCBjdXJyZW50VGhyZXNob2xkKTtcbiAgICBiZXN0TG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG5cbiAgICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgcGF0dGVybkxlbikge1xuICAgICAgICBtYXRjaE1hc2tbaW5kZXggKyBpXSA9IDE7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXNldCB0aGUgYmVzdCBsb2NhdGlvblxuICBiZXN0TG9jYXRpb24gPSAtMTtcblxuICBsZXQgbGFzdEJpdEFyciA9IFtdO1xuICBsZXQgZmluYWxTY29yZSA9IDE7XG4gIGxldCBiaW5NYXggPSBwYXR0ZXJuTGVuICsgdGV4dExlbjtcblxuICBjb25zdCBtYXNrID0gMSA8PCAocGF0dGVybkxlbiAtIDEpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSArPSAxKSB7XG4gICAgLy8gU2NhbiBmb3IgdGhlIGJlc3QgbWF0Y2g7IGVhY2ggaXRlcmF0aW9uIGFsbG93cyBmb3Igb25lIG1vcmUgZXJyb3IuXG4gICAgLy8gUnVuIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgaG93IGZhciBmcm9tIHRoZSBtYXRjaCBsb2NhdGlvbiB3ZSBjYW4gc3RyYXlcbiAgICAvLyBhdCB0aGlzIGVycm9yIGxldmVsLlxuICAgIGxldCBiaW5NaW4gPSAwO1xuICAgIGxldCBiaW5NaWQgPSBiaW5NYXg7XG5cbiAgICB3aGlsZSAoYmluTWluIDwgYmluTWlkKSB7XG4gICAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24gKyBiaW5NaWQsXG4gICAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzY29yZSA8PSBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICAgIGJpbk1pbiA9IGJpbk1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpbk1heCA9IGJpbk1pZDtcbiAgICAgIH1cblxuICAgICAgYmluTWlkID0gTWF0aC5mbG9vcigoYmluTWF4IC0gYmluTWluKSAvIDIgKyBiaW5NaW4pO1xuICAgIH1cblxuICAgIC8vIFVzZSB0aGUgcmVzdWx0IGZyb20gdGhpcyBpdGVyYXRpb24gYXMgdGhlIG1heGltdW0gZm9yIHRoZSBuZXh0LlxuICAgIGJpbk1heCA9IGJpbk1pZDtcblxuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGV4cGVjdGVkTG9jYXRpb24gLSBiaW5NaWQgKyAxKTtcbiAgICBsZXQgZmluaXNoID0gZmluZEFsbE1hdGNoZXNcbiAgICAgID8gdGV4dExlblxuICAgICAgOiBNYXRoLm1pbihleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLCB0ZXh0TGVuKSArIHBhdHRlcm5MZW47XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBiaXQgYXJyYXlcbiAgICBsZXQgYml0QXJyID0gQXJyYXkoZmluaXNoICsgMik7XG5cbiAgICBiaXRBcnJbZmluaXNoICsgMV0gPSAoMSA8PCBpKSAtIDE7XG5cbiAgICBmb3IgKGxldCBqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqIC09IDEpIHtcbiAgICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBqIC0gMTtcbiAgICAgIGxldCBjaGFyTWF0Y2ggPSBwYXR0ZXJuQWxwaGFiZXRbdGV4dC5jaGFyQXQoY3VycmVudExvY2F0aW9uKV07XG5cbiAgICAgIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgICAgICAvLyBTcGVlZCB1cDogcXVpY2sgYm9vbCB0byBpbnQgY29udmVyc2lvbiAoaS5lLCBgY2hhck1hdGNoID8gMSA6IDBgKVxuICAgICAgICBtYXRjaE1hc2tbY3VycmVudExvY2F0aW9uXSA9ICshIWNoYXJNYXRjaDtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QgcGFzczogZXhhY3QgbWF0Y2hcbiAgICAgIGJpdEFycltqXSA9ICgoYml0QXJyW2ogKyAxXSA8PCAxKSB8IDEpICYgY2hhck1hdGNoO1xuXG4gICAgICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2hcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGJpdEFycltqXSB8PVxuICAgICAgICAgICgobGFzdEJpdEFycltqICsgMV0gfCBsYXN0Qml0QXJyW2pdKSA8PCAxKSB8IDEgfCBsYXN0Qml0QXJyW2ogKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpdEFycltqXSAmIG1hc2spIHtcbiAgICAgICAgZmluYWxTY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgICAgICBlcnJvcnM6IGksXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVGhpcyBtYXRjaCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYmUgYmV0dGVyIHRoYW4gYW55IGV4aXN0aW5nIG1hdGNoLlxuICAgICAgICAvLyBCdXQgY2hlY2sgYW55d2F5LlxuICAgICAgICBpZiAoZmluYWxTY29yZSA8PSBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICAgICAgLy8gSW5kZWVkIGl0IGlzXG4gICAgICAgICAgY3VycmVudFRocmVzaG9sZCA9IGZpbmFsU2NvcmU7XG4gICAgICAgICAgYmVzdExvY2F0aW9uID0gY3VycmVudExvY2F0aW9uO1xuXG4gICAgICAgICAgLy8gQWxyZWFkeSBwYXNzZWQgYGxvY2AsIGRvd25oaWxsIGZyb20gaGVyZSBvbiBpbi5cbiAgICAgICAgICBpZiAoYmVzdExvY2F0aW9uIDw9IGV4cGVjdGVkTG9jYXRpb24pIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGBiZXN0TG9jYXRpb25gLCBkb24ndCBleGNlZWQgb3VyIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSBgZXhwZWN0ZWRMb2NhdGlvbmAuXG4gICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogZXhwZWN0ZWRMb2NhdGlvbiAtIGJlc3RMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBob3BlIGZvciBhIChiZXR0ZXIpIG1hdGNoIGF0IGdyZWF0ZXIgZXJyb3IgbGV2ZWxzLlxuICAgIGNvbnN0IHNjb3JlID0gY29tcHV0ZVNjb3JlJDEocGF0dGVybiwge1xuICAgICAgZXJyb3JzOiBpICsgMSxcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAoc2NvcmUgPiBjdXJyZW50VGhyZXNob2xkKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGxhc3RCaXRBcnIgPSBiaXRBcnI7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaXNNYXRjaDogYmVzdExvY2F0aW9uID49IDAsXG4gICAgLy8gQ291bnQgZXhhY3QgbWF0Y2hlcyAodGhvc2Ugd2l0aCBhIHNjb3JlIG9mIDApIHRvIGJlIFwiYWxtb3N0XCIgZXhhY3RcbiAgICBzY29yZTogTWF0aC5tYXgoMC4wMDEsIGZpbmFsU2NvcmUpXG4gIH07XG5cbiAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IGNvbnZlcnRNYXNrVG9JbmRpY2VzKG1hdGNoTWFzaywgbWluTWF0Y2hDaGFyTGVuZ3RoKTtcbiAgICBpZiAoIWluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQuaXNNYXRjaCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgIHJlc3VsdC5pbmRpY2VzID0gaW5kaWNlcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm5BbHBoYWJldChwYXR0ZXJuKSB7XG4gIGxldCBtYXNrID0ge307XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBjb25zdCBjaGFyID0gcGF0dGVybi5jaGFyQXQoaSk7XG4gICAgbWFza1tjaGFyXSA9IChtYXNrW2NoYXJdIHx8IDApIHwgKDEgPDwgKGxlbiAtIGkgLSAxKSk7XG4gIH1cblxuICByZXR1cm4gbWFza1xufVxuXG5jbGFzcyBCaXRhcFNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdHRlcm4sXG4gICAge1xuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfTtcblxuICAgIHRoaXMucGF0dGVybiA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB0aGlzLmNodW5rcyA9IFtdO1xuXG4gICAgaWYgKCF0aGlzLnBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhZGRDaHVuayA9IChwYXR0ZXJuLCBzdGFydEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmNodW5rcy5wdXNoKHtcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgYWxwaGFiZXQ6IGNyZWF0ZVBhdHRlcm5BbHBoYWJldChwYXR0ZXJuKSxcbiAgICAgICAgc3RhcnRJbmRleFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGxlbiA9IHRoaXMucGF0dGVybi5sZW5ndGg7XG5cbiAgICBpZiAobGVuID4gTUFYX0JJVFMpIHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGNvbnN0IHJlbWFpbmRlciA9IGxlbiAlIE1BWF9CSVRTO1xuICAgICAgY29uc3QgZW5kID0gbGVuIC0gcmVtYWluZGVyO1xuXG4gICAgICB3aGlsZSAoaSA8IGVuZCkge1xuICAgICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4uc3Vic3RyKGksIE1BWF9CSVRTKSwgaSk7XG4gICAgICAgIGkgKz0gTUFYX0JJVFM7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1haW5kZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IGxlbiAtIE1BWF9CSVRTO1xuICAgICAgICBhZGRDaHVuayh0aGlzLnBhdHRlcm4uc3Vic3RyKHN0YXJ0SW5kZXgpLCBzdGFydEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLCAwKTtcbiAgICB9XG4gIH1cblxuICBzZWFyY2hJbih0ZXh0KSB7XG4gICAgY29uc3QgeyBpc0Nhc2VTZW5zaXRpdmUsIGluY2x1ZGVNYXRjaGVzIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIWlzQ2FzZVNlbnNpdGl2ZSkge1xuICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBFeGFjdCBtYXRjaFxuICAgIGlmICh0aGlzLnBhdHRlcm4gPT09IHRleHQpIHtcbiAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgIGlzTWF0Y2g6IHRydWUsXG4gICAgICAgIHNjb3JlOiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgcmVzdWx0LmluZGljZXMgPSBbWzAsIHRleHQubGVuZ3RoIC0gMV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCB1c2UgQml0YXAgYWxnb3JpdGhtXG4gICAgY29uc3Qge1xuICAgICAgbG9jYXRpb24sXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgbGV0IGFsbEluZGljZXMgPSBbXTtcbiAgICBsZXQgdG90YWxTY29yZSA9IDA7XG4gICAgbGV0IGhhc01hdGNoZXMgPSBmYWxzZTtcblxuICAgIHRoaXMuY2h1bmtzLmZvckVhY2goKHsgcGF0dGVybiwgYWxwaGFiZXQsIHN0YXJ0SW5kZXggfSkgPT4ge1xuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoKHRleHQsIHBhdHRlcm4sIGFscGhhYmV0LCB7XG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbiArIHN0YXJ0SW5kZXgsXG4gICAgICAgIGRpc3RhbmNlLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgICBpZ25vcmVMb2NhdGlvblxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIGhhc01hdGNoZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0b3RhbFNjb3JlICs9IHNjb3JlO1xuXG4gICAgICBpZiAoaXNNYXRjaCAmJiBpbmRpY2VzKSB7XG4gICAgICAgIGFsbEluZGljZXMgPSBbLi4uYWxsSW5kaWNlcywgLi4uaW5kaWNlc107XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgaXNNYXRjaDogaGFzTWF0Y2hlcyxcbiAgICAgIHNjb3JlOiBoYXNNYXRjaGVzID8gdG90YWxTY29yZSAvIHRoaXMuY2h1bmtzLmxlbmd0aCA6IDFcbiAgICB9O1xuXG4gICAgaWYgKGhhc01hdGNoZXMgJiYgaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuY2xhc3MgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gIH1cbiAgc3RhdGljIGlzTXVsdGlNYXRjaChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGdldE1hdGNoKHBhdHRlcm4sIHRoaXMubXVsdGlSZWdleClcbiAgfVxuICBzdGF0aWMgaXNTaW5nbGVNYXRjaChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGdldE1hdGNoKHBhdHRlcm4sIHRoaXMuc2luZ2xlUmVnZXgpXG4gIH1cbiAgc2VhcmNoKC8qdGV4dCovKSB7fVxufVxuXG5mdW5jdGlvbiBnZXRNYXRjaChwYXR0ZXJuLCBleHApIHtcbiAgY29uc3QgbWF0Y2hlcyA9IHBhdHRlcm4ubWF0Y2goZXhwKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogbnVsbFxufVxuXG4vLyBUb2tlbjogJ2ZpbGVcblxuY2xhc3MgRXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdleGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9ePVwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXj0oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0ZXh0ID09PSB0aGlzLnBhdHRlcm47XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhZmlyZVxuXG5jbGFzcyBJbnZlcnNlRXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eISguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0ZXh0LmluZGV4T2YodGhpcy5wYXR0ZXJuKTtcbiAgICBjb25zdCBpc01hdGNoID0gaW5kZXggPT09IC0xO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46IF5maWxlXG5cbmNsYXNzIFByZWZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAncHJlZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cXF5cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL15cXF4oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0ZXh0LnN0YXJ0c1dpdGgodGhpcy5wYXR0ZXJuKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46ICFeZmlyZVxuXG5jbGFzcyBJbnZlcnNlUHJlZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLXByZWZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVxcXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcXF4oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSAhdGV4dC5zdGFydHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogLmZpbGUkXG5cbmNsYXNzIFN1ZmZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnc3VmZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIlxcJCQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopXFwkJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSB0ZXh0LmVuZHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbdGV4dC5sZW5ndGggLSB0aGlzLnBhdHRlcm4ubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhLmZpbGUkXG5cbmNsYXNzIEludmVyc2VTdWZmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2ludmVyc2Utc3VmZml4LWV4YWN0J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXCIoLiopXCJcXCQkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eISguKilcXCQkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgY29uc3QgaXNNYXRjaCA9ICF0ZXh0LmVuZHNXaXRoKHRoaXMucGF0dGVybik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgRnV6enlNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdHRlcm4sXG4gICAge1xuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvblxuICAgIH0gPSB7fVxuICApIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgICB0aGlzLl9iaXRhcFNlYXJjaCA9IG5ldyBCaXRhcFNlYXJjaChwYXR0ZXJuLCB7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnZnV6enknXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXlwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpdGFwU2VhcmNoLnNlYXJjaEluKHRleHQpXG4gIH1cbn1cblxuLy8gVG9rZW46ICdmaWxlXG5cbmNsYXNzIEluY2x1ZGVNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbmNsdWRlJ1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL14nXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eJyguKikkL1xuICB9XG4gIHNlYXJjaCh0ZXh0KSB7XG4gICAgbGV0IGxvY2F0aW9uID0gMDtcbiAgICBsZXQgaW5kZXg7XG5cbiAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgY29uc3QgcGF0dGVybkxlbiA9IHRoaXMucGF0dGVybi5sZW5ndGg7XG5cbiAgICAvLyBHZXQgYWxsIGV4YWN0IG1hdGNoZXNcbiAgICB3aGlsZSAoKGluZGV4ID0gdGV4dC5pbmRleE9mKHRoaXMucGF0dGVybiwgbG9jYXRpb24pKSA+IC0xKSB7XG4gICAgICBsb2NhdGlvbiA9IGluZGV4ICsgcGF0dGVybkxlbjtcbiAgICAgIGluZGljZXMucHVzaChbaW5kZXgsIGxvY2F0aW9uIC0gMV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlzTWF0Y2ggPSAhIWluZGljZXMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlc1xuICAgIH1cbiAgfVxufVxuXG4vLyDinZdPcmRlciBpcyBpbXBvcnRhbnQuIERPIE5PVCBDSEFOR0UuXG5jb25zdCBzZWFyY2hlcnMgPSBbXG4gIEV4YWN0TWF0Y2gsXG4gIEluY2x1ZGVNYXRjaCxcbiAgUHJlZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VTdWZmaXhFeGFjdE1hdGNoLFxuICBTdWZmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlRXhhY3RNYXRjaCxcbiAgRnV6enlNYXRjaFxuXTtcblxuY29uc3Qgc2VhcmNoZXJzTGVuID0gc2VhcmNoZXJzLmxlbmd0aDtcblxuLy8gUmVnZXggdG8gc3BsaXQgYnkgc3BhY2VzLCBidXQga2VlcCBhbnl0aGluZyBpbiBxdW90ZXMgdG9nZXRoZXJcbmNvbnN0IFNQQUNFX1JFID0gLyArKD89KD86W15cXFwiXSpcXFwiW15cXFwiXSpcXFwiKSpbXlxcXCJdKiQpLztcbmNvbnN0IE9SX1RPS0VOID0gJ3wnO1xuXG4vLyBSZXR1cm4gYSAyRCBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVlcnksIGZvciBzaW1wbGVyIHBhcnNpbmcuXG4vLyBFeGFtcGxlOlxuLy8gXCJeY29yZSBnbyQgfCByYiQgfCBweSQgeHkkXCIgPT4gW1tcIl5jb3JlXCIsIFwiZ28kXCJdLCBbXCJyYiRcIl0sIFtcInB5JFwiLCBcInh5JFwiXV1cbmZ1bmN0aW9uIHBhcnNlUXVlcnkocGF0dGVybiwgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBwYXR0ZXJuLnNwbGl0KE9SX1RPS0VOKS5tYXAoKGl0ZW0pID0+IHtcbiAgICBsZXQgcXVlcnkgPSBpdGVtXG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoU1BBQ0VfUkUpXG4gICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtICYmICEhaXRlbS50cmltKCkpO1xuXG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5SXRlbSA9IHF1ZXJ5W2ldO1xuXG4gICAgICAvLyAxLiBIYW5kbGUgbXVsdGlwbGUgcXVlcnkgbWF0Y2ggKGkuZSwgb25jZSB0aGF0IGFyZSBxdW90ZWQsIGxpa2UgYFwiaGVsbG8gd29ybGRcImApXG4gICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgIGxldCBpZHggPSAtMTtcbiAgICAgIHdoaWxlICghZm91bmQgJiYgKytpZHggPCBzZWFyY2hlcnNMZW4pIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoZXIgPSBzZWFyY2hlcnNbaWR4XTtcbiAgICAgICAgbGV0IHRva2VuID0gc2VhcmNoZXIuaXNNdWx0aU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEhhbmRsZSBzaW5nbGUgcXVlcnkgbWF0Y2hlcyAoaS5lLCBvbmNlIHRoYXQgYXJlICpub3QqIHF1b3RlZClcbiAgICAgIGlkeCA9IC0xO1xuICAgICAgd2hpbGUgKCsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzU2luZ2xlTWF0Y2gocXVlcnlJdGVtKTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBzZWFyY2hlcih0b2tlbiwgb3B0aW9ucykpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9KVxufVxuXG4vLyBUaGVzZSBleHRlbmRlZCBtYXRjaGVycyBjYW4gcmV0dXJuIGFuIGFycmF5IG9mIG1hdGNoZXMsIGFzIG9wcG9zZWRcbi8vIHRvIGEgc2luZ2wgbWF0Y2hcbmNvbnN0IE11bHRpTWF0Y2hTZXQgPSBuZXcgU2V0KFtGdXp6eU1hdGNoLnR5cGUsIEluY2x1ZGVNYXRjaC50eXBlXSk7XG5cbi8qKlxuICogQ29tbWFuZC1saWtlIHNlYXJjaGluZ1xuICogPT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEdpdmVuIG11bHRpcGxlIHNlYXJjaCB0ZXJtcyBkZWxpbWl0ZWQgYnkgc3BhY2VzLmUuZy4gYF5qc2NyaXB0IC5weXRob24kIHJ1YnkgIWphdmFgLFxuICogc2VhcmNoIGluIGEgZ2l2ZW4gdGV4dC5cbiAqXG4gKiBTZWFyY2ggc3ludGF4OlxuICpcbiAqIHwgVG9rZW4gICAgICAgfCBNYXRjaCB0eXBlICAgICAgICAgICAgICAgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAqIHwgYGpzY3JpcHRgICAgfCBmdXp6eS1tYXRjaCAgICAgICAgICAgICAgICB8IEl0ZW1zIHRoYXQgZnV6enkgbWF0Y2ggYGpzY3JpcHRgICAgICAgIHxcbiAqIHwgYD1zY2hlbWVgICAgfCBleGFjdC1tYXRjaCAgICAgICAgICAgICAgICB8IEl0ZW1zIHRoYXQgYXJlIGBzY2hlbWVgICAgICAgICAgICAgICAgIHxcbiAqIHwgYCdweXRob25gICAgfCBpbmNsdWRlLW1hdGNoICAgICAgICAgICAgICB8IEl0ZW1zIHRoYXQgaW5jbHVkZSBgcHl0aG9uYCAgICAgICAgICAgIHxcbiAqIHwgYCFydWJ5YCAgICAgfCBpbnZlcnNlLWV4YWN0LW1hdGNoICAgICAgICB8IEl0ZW1zIHRoYXQgZG8gbm90IGluY2x1ZGUgYHJ1YnlgICAgICAgIHxcbiAqIHwgYF5qYXZhYCAgICAgfCBwcmVmaXgtZXhhY3QtbWF0Y2ggICAgICAgICB8IEl0ZW1zIHRoYXQgc3RhcnQgd2l0aCBgamF2YWAgICAgICAgICAgIHxcbiAqIHwgYCFeZWFybGFuZ2AgfCBpbnZlcnNlLXByZWZpeC1leGFjdC1tYXRjaCB8IEl0ZW1zIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggYGVhcmxhbmdgIHxcbiAqIHwgYC5qcyRgICAgICAgfCBzdWZmaXgtZXhhY3QtbWF0Y2ggICAgICAgICB8IEl0ZW1zIHRoYXQgZW5kIHdpdGggYC5qc2AgICAgICAgICAgICAgIHxcbiAqIHwgYCEuZ28kYCAgICAgfCBpbnZlcnNlLXN1ZmZpeC1leGFjdC1tYXRjaCB8IEl0ZW1zIHRoYXQgZG8gbm90IGVuZCB3aXRoIGAuZ29gICAgICAgIHxcbiAqXG4gKiBBIHNpbmdsZSBwaXBlIGNoYXJhY3RlciBhY3RzIGFzIGFuIE9SIG9wZXJhdG9yLiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZ1xuICogcXVlcnkgbWF0Y2hlcyBlbnRyaWVzIHRoYXQgc3RhcnQgd2l0aCBgY29yZWAgYW5kIGVuZCB3aXRoIGVpdGhlcmBnb2AsIGByYmAsXG4gKiBvcmBweWAuXG4gKlxuICogYGBgXG4gKiBeY29yZSBnbyQgfCByYiQgfCBweSRcbiAqIGBgYFxuICovXG5jbGFzcyBFeHRlbmRlZFNlYXJjaCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdHRlcm4sXG4gICAge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlID0gQ29uZmlnLmlzQ2FzZVNlbnNpdGl2ZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uLFxuICAgICAgZmluZEFsbE1hdGNoZXMgPSBDb25maWcuZmluZEFsbE1hdGNoZXMsXG4gICAgICBsb2NhdGlvbiA9IENvbmZpZy5sb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCA9IENvbmZpZy50aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSA9IENvbmZpZy5kaXN0YW5jZVxuICAgIH0gPSB7fVxuICApIHtcbiAgICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGZpbmRBbGxNYXRjaGVzLFxuICAgICAgaWdub3JlTG9jYXRpb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlXG4gICAgfTtcblxuICAgIHRoaXMucGF0dGVybiA9IGlzQ2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5xdWVyeSA9IHBhcnNlUXVlcnkodGhpcy5wYXR0ZXJuLCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGNvbmRpdGlvbihfLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2hcbiAgfVxuXG4gIHNlYXJjaEluKHRleHQpIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnk7XG5cbiAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc01hdGNoOiBmYWxzZSxcbiAgICAgICAgc2NvcmU6IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IGluY2x1ZGVNYXRjaGVzLCBpc0Nhc2VTZW5zaXRpdmUgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIHRleHQgPSBpc0Nhc2VTZW5zaXRpdmUgPyB0ZXh0IDogdGV4dC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgbGV0IG51bU1hdGNoZXMgPSAwO1xuICAgIGxldCBhbGxJbmRpY2VzID0gW107XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuXG4gICAgLy8gT1JzXG4gICAgZm9yIChsZXQgaSA9IDAsIHFMZW4gPSBxdWVyeS5sZW5ndGg7IGkgPCBxTGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHNlYXJjaGVycyA9IHF1ZXJ5W2ldO1xuXG4gICAgICAvLyBSZXNldCBpbmRpY2VzXG4gICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICBudW1NYXRjaGVzID0gMDtcblxuICAgICAgLy8gQU5Ec1xuICAgICAgZm9yIChsZXQgaiA9IDAsIHBMZW4gPSBzZWFyY2hlcnMubGVuZ3RoOyBqIDwgcExlbjsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2pdO1xuICAgICAgICBjb25zdCB7IGlzTWF0Y2gsIGluZGljZXMsIHNjb3JlIH0gPSBzZWFyY2hlci5zZWFyY2godGV4dCk7XG5cbiAgICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgICBudW1NYXRjaGVzICs9IDE7XG4gICAgICAgICAgdG90YWxTY29yZSArPSBzY29yZTtcbiAgICAgICAgICBpZiAoaW5jbHVkZU1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBzZWFyY2hlci5jb25zdHJ1Y3Rvci50eXBlO1xuICAgICAgICAgICAgaWYgKE11bHRpTWF0Y2hTZXQuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICAgIGFsbEluZGljZXMgPSBbLi4uYWxsSW5kaWNlcywgLi4uaW5kaWNlc107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzLnB1c2goaW5kaWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvdGFsU2NvcmUgPSAwO1xuICAgICAgICAgIG51bU1hdGNoZXMgPSAwO1xuICAgICAgICAgIGFsbEluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9SIGNvbmRpdGlvbiwgc28gaWYgVFJVRSwgcmV0dXJuXG4gICAgICBpZiAobnVtTWF0Y2hlcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgIGlzTWF0Y2g6IHRydWUsXG4gICAgICAgICAgc2NvcmU6IHRvdGFsU2NvcmUgLyBudW1NYXRjaGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgcmVzdWx0LmluZGljZXMgPSBhbGxJbmRpY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vdGhpbmcgd2FzIG1hdGNoZWRcbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICBzY29yZTogMVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCByZWdpc3RlcmVkU2VhcmNoZXJzID0gW107XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKC4uLmFyZ3MpIHtcbiAgcmVnaXN0ZXJlZFNlYXJjaGVycy5wdXNoKC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSByZWdpc3RlcmVkU2VhcmNoZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgbGV0IHNlYXJjaGVyQ2xhc3MgPSByZWdpc3RlcmVkU2VhcmNoZXJzW2ldO1xuICAgIGlmIChzZWFyY2hlckNsYXNzLmNvbmRpdGlvbihwYXR0ZXJuLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG5ldyBzZWFyY2hlckNsYXNzKHBhdHRlcm4sIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBCaXRhcFNlYXJjaChwYXR0ZXJuLCBvcHRpb25zKVxufVxuXG5jb25zdCBMb2dpY2FsT3BlcmF0b3IgPSB7XG4gIEFORDogJyRhbmQnLFxuICBPUjogJyRvcidcbn07XG5cbmNvbnN0IEtleVR5cGUgPSB7XG4gIFBBVEg6ICckcGF0aCcsXG4gIFBBVFRFUk46ICckdmFsJ1xufTtcblxuY29uc3QgaXNFeHByZXNzaW9uID0gKHF1ZXJ5KSA9PlxuICAhIShxdWVyeVtMb2dpY2FsT3BlcmF0b3IuQU5EXSB8fCBxdWVyeVtMb2dpY2FsT3BlcmF0b3IuT1JdKTtcblxuY29uc3QgaXNQYXRoID0gKHF1ZXJ5KSA9PiAhIXF1ZXJ5W0tleVR5cGUuUEFUSF07XG5cbmNvbnN0IGlzTGVhZiA9IChxdWVyeSkgPT5cbiAgIWlzQXJyYXkocXVlcnkpICYmIGlzT2JqZWN0KHF1ZXJ5KSAmJiAhaXNFeHByZXNzaW9uKHF1ZXJ5KTtcblxuY29uc3QgY29udmVydFRvRXhwbGljaXQgPSAocXVlcnkpID0+ICh7XG4gIFtMb2dpY2FsT3BlcmF0b3IuQU5EXTogT2JqZWN0LmtleXMocXVlcnkpLm1hcCgoa2V5KSA9PiAoe1xuICAgIFtrZXldOiBxdWVyeVtrZXldXG4gIH0pKVxufSk7XG5cbi8vIFdoZW4gYGF1dG9gIGlzIGB0cnVlYCwgdGhlIHBhcnNlIGZ1bmN0aW9uIHdpbGwgaW5mZXIgYW5kIGluaXRpYWxpemUgYW5kIGFkZFxuLy8gdGhlIGFwcHJvcHJpYXRlIGBTZWFyY2hlcmAgaW5zdGFuY2VcbmZ1bmN0aW9uIHBhcnNlKHF1ZXJ5LCBvcHRpb25zLCB7IGF1dG8gPSB0cnVlIH0gPSB7fSkge1xuICBjb25zdCBuZXh0ID0gKHF1ZXJ5KSA9PiB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhxdWVyeSk7XG5cbiAgICBjb25zdCBpc1F1ZXJ5UGF0aCA9IGlzUGF0aChxdWVyeSk7XG5cbiAgICBpZiAoIWlzUXVlcnlQYXRoICYmIGtleXMubGVuZ3RoID4gMSAmJiAhaXNFeHByZXNzaW9uKHF1ZXJ5KSkge1xuICAgICAgcmV0dXJuIG5leHQoY29udmVydFRvRXhwbGljaXQocXVlcnkpKVxuICAgIH1cblxuICAgIGlmIChpc0xlYWYocXVlcnkpKSB7XG4gICAgICBjb25zdCBrZXkgPSBpc1F1ZXJ5UGF0aCA/IHF1ZXJ5W0tleVR5cGUuUEFUSF0gOiBrZXlzWzBdO1xuXG4gICAgICBjb25zdCBwYXR0ZXJuID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVFRFUk5dIDogcXVlcnlba2V5XTtcblxuICAgICAgaWYgKCFpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTE9HSUNBTF9TRUFSQ0hfSU5WQUxJRF9RVUVSWV9GT1JfS0VZKGtleSkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAga2V5SWQ6IGNyZWF0ZUtleUlkKGtleSksXG4gICAgICAgIHBhdHRlcm5cbiAgICAgIH07XG5cbiAgICAgIGlmIChhdXRvKSB7XG4gICAgICAgIG9iai5zZWFyY2hlciA9IGNyZWF0ZVNlYXJjaGVyKHBhdHRlcm4sIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBvcGVyYXRvcjoga2V5c1swXVxuICAgIH07XG5cbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVtrZXldO1xuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXh0KGl0ZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZVxuICB9O1xuXG4gIGlmICghaXNFeHByZXNzaW9uKHF1ZXJ5KSkge1xuICAgIHF1ZXJ5ID0gY29udmVydFRvRXhwbGljaXQocXVlcnkpO1xuICB9XG5cbiAgcmV0dXJuIG5leHQocXVlcnkpXG59XG5cbi8vIFByYWN0aWNhbCBzY29yaW5nIGZ1bmN0aW9uXG5mdW5jdGlvbiBjb21wdXRlU2NvcmUoXG4gIHJlc3VsdHMsXG4gIHsgaWdub3JlRmllbGROb3JtID0gQ29uZmlnLmlnbm9yZUZpZWxkTm9ybSB9XG4pIHtcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICBsZXQgdG90YWxTY29yZSA9IDE7XG5cbiAgICByZXN1bHQubWF0Y2hlcy5mb3JFYWNoKCh7IGtleSwgbm9ybSwgc2NvcmUgfSkgPT4ge1xuICAgICAgY29uc3Qgd2VpZ2h0ID0ga2V5ID8ga2V5LndlaWdodCA6IG51bGw7XG5cbiAgICAgIHRvdGFsU2NvcmUgKj0gTWF0aC5wb3coXG4gICAgICAgIHNjb3JlID09PSAwICYmIHdlaWdodCA/IE51bWJlci5FUFNJTE9OIDogc2NvcmUsXG4gICAgICAgICh3ZWlnaHQgfHwgMSkgKiAoaWdub3JlRmllbGROb3JtID8gMSA6IG5vcm0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmVzdWx0LnNjb3JlID0gdG90YWxTY29yZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdGNoZXMocmVzdWx0LCBkYXRhKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSByZXN1bHQubWF0Y2hlcztcbiAgZGF0YS5tYXRjaGVzID0gW107XG5cbiAgaWYgKCFpc0RlZmluZWQobWF0Y2hlcykpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIG1hdGNoZXMuZm9yRWFjaCgobWF0Y2gpID0+IHtcbiAgICBpZiAoIWlzRGVmaW5lZChtYXRjaC5pbmRpY2VzKSB8fCAhbWF0Y2guaW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgaW5kaWNlcywgdmFsdWUgfSA9IG1hdGNoO1xuXG4gICAgbGV0IG9iaiA9IHtcbiAgICAgIGluZGljZXMsXG4gICAgICB2YWx1ZVxuICAgIH07XG5cbiAgICBpZiAobWF0Y2gua2V5KSB7XG4gICAgICBvYmoua2V5ID0gbWF0Y2gua2V5LnNyYztcbiAgICB9XG5cbiAgICBpZiAobWF0Y2guaWR4ID4gLTEpIHtcbiAgICAgIG9iai5yZWZJbmRleCA9IG1hdGNoLmlkeDtcbiAgICB9XG5cbiAgICBkYXRhLm1hdGNoZXMucHVzaChvYmopO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU2NvcmUocmVzdWx0LCBkYXRhKSB7XG4gIGRhdGEuc2NvcmUgPSByZXN1bHQuc2NvcmU7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdChcbiAgcmVzdWx0cyxcbiAgZG9jcyxcbiAge1xuICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgIGluY2x1ZGVTY29yZSA9IENvbmZpZy5pbmNsdWRlU2NvcmVcbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgdHJhbnNmb3JtZXJzID0gW107XG5cbiAgaWYgKGluY2x1ZGVNYXRjaGVzKSB0cmFuc2Zvcm1lcnMucHVzaCh0cmFuc2Zvcm1NYXRjaGVzKTtcbiAgaWYgKGluY2x1ZGVTY29yZSkgdHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtU2NvcmUpO1xuXG4gIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgY29uc3QgeyBpZHggfSA9IHJlc3VsdDtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBpdGVtOiBkb2NzW2lkeF0sXG4gICAgICByZWZJbmRleDogaWR4XG4gICAgfTtcblxuICAgIGlmICh0cmFuc2Zvcm1lcnMubGVuZ3RoKSB7XG4gICAgICB0cmFuc2Zvcm1lcnMuZm9yRWFjaCgodHJhbnNmb3JtZXIpID0+IHtcbiAgICAgICAgdHJhbnNmb3JtZXIocmVzdWx0LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhXG4gIH0pXG59XG5cbmNsYXNzIEZ1c2Uge1xuICBjb25zdHJ1Y3Rvcihkb2NzLCBvcHRpb25zID0ge30sIGluZGV4KSB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi5Db25maWcsIC4uLm9wdGlvbnMgfTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy51c2VFeHRlbmRlZFNlYXJjaCAmJlxuICAgICAgIXRydWVcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihFWFRFTkRFRF9TRUFSQ0hfVU5BVkFJTEFCTEUpXG4gICAgfVxuXG4gICAgdGhpcy5fa2V5U3RvcmUgPSBuZXcgS2V5U3RvcmUodGhpcy5vcHRpb25zLmtleXMpO1xuXG4gICAgdGhpcy5zZXRDb2xsZWN0aW9uKGRvY3MsIGluZGV4KTtcbiAgfVxuXG4gIHNldENvbGxlY3Rpb24oZG9jcywgaW5kZXgpIHtcbiAgICB0aGlzLl9kb2NzID0gZG9jcztcblxuICAgIGlmIChpbmRleCAmJiAhKGluZGV4IGluc3RhbmNlb2YgRnVzZUluZGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKElOQ09SUkVDVF9JTkRFWF9UWVBFKVxuICAgIH1cblxuICAgIHRoaXMuX215SW5kZXggPVxuICAgICAgaW5kZXggfHxcbiAgICAgIGNyZWF0ZUluZGV4KHRoaXMub3B0aW9ucy5rZXlzLCB0aGlzLl9kb2NzLCB7XG4gICAgICAgIGdldEZuOiB0aGlzLm9wdGlvbnMuZ2V0Rm4sXG4gICAgICAgIGZpZWxkTm9ybVdlaWdodDogdGhpcy5vcHRpb25zLmZpZWxkTm9ybVdlaWdodFxuICAgICAgfSk7XG4gIH1cblxuICBhZGQoZG9jKSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fZG9jcy5wdXNoKGRvYyk7XG4gICAgdGhpcy5fbXlJbmRleC5hZGQoZG9jKTtcbiAgfVxuXG4gIHJlbW92ZShwcmVkaWNhdGUgPSAoLyogZG9jLCBpZHggKi8pID0+IGZhbHNlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2RvY3MubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMuX2RvY3NbaV07XG4gICAgICBpZiAocHJlZGljYXRlKGRvYywgaSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdChpKTtcbiAgICAgICAgaSAtPSAxO1xuICAgICAgICBsZW4gLT0gMTtcblxuICAgICAgICByZXN1bHRzLnB1c2goZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5fZG9jcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB0aGlzLl9teUluZGV4LnJlbW92ZUF0KGlkeCk7XG4gIH1cblxuICBnZXRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbXlJbmRleFxuICB9XG5cbiAgc2VhcmNoKHF1ZXJ5LCB7IGxpbWl0ID0gLTEgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBpbmNsdWRlU2NvcmUsXG4gICAgICBzaG91bGRTb3J0LFxuICAgICAgc29ydEZuLFxuICAgICAgaWdub3JlRmllbGROb3JtXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCByZXN1bHRzID0gaXNTdHJpbmcocXVlcnkpXG4gICAgICA/IGlzU3RyaW5nKHRoaXMuX2RvY3NbMF0pXG4gICAgICAgID8gdGhpcy5fc2VhcmNoU3RyaW5nTGlzdChxdWVyeSlcbiAgICAgICAgOiB0aGlzLl9zZWFyY2hPYmplY3RMaXN0KHF1ZXJ5KVxuICAgICAgOiB0aGlzLl9zZWFyY2hMb2dpY2FsKHF1ZXJ5KTtcblxuICAgIGNvbXB1dGVTY29yZShyZXN1bHRzLCB7IGlnbm9yZUZpZWxkTm9ybSB9KTtcblxuICAgIGlmIChzaG91bGRTb3J0KSB7XG4gICAgICByZXN1bHRzLnNvcnQoc29ydEZuKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIobGltaXQpICYmIGxpbWl0ID4gLTEpIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNsaWNlKDAsIGxpbWl0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0KHJlc3VsdHMsIHRoaXMuX2RvY3MsIHtcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgaW5jbHVkZVNjb3JlXG4gICAgfSlcbiAgfVxuXG4gIF9zZWFyY2hTdHJpbmdMaXN0KHF1ZXJ5KSB7XG4gICAgY29uc3Qgc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihxdWVyeSwgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCB7IHJlY29yZHMgfSA9IHRoaXMuX215SW5kZXg7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IHN0cmluZyBpbiB0aGUgaW5kZXhcbiAgICByZWNvcmRzLmZvckVhY2goKHsgdjogdGV4dCwgaTogaWR4LCBuOiBub3JtIH0pID0+IHtcbiAgICAgIGlmICghaXNEZWZpbmVkKHRleHQpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBpdGVtOiB0ZXh0LFxuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBtYXRjaGVzOiBbeyBzY29yZSwgdmFsdWU6IHRleHQsIG5vcm0sIGluZGljZXMgfV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgX3NlYXJjaExvZ2ljYWwocXVlcnkpIHtcblxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZShxdWVyeSwgdGhpcy5vcHRpb25zKTtcblxuICAgIGNvbnN0IGV2YWx1YXRlID0gKG5vZGUsIGl0ZW0sIGlkeCkgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHsga2V5SWQsIHNlYXJjaGVyIH0gPSBub2RlO1xuXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLl9maW5kTWF0Y2hlcyh7XG4gICAgICAgICAga2V5OiB0aGlzLl9rZXlTdG9yZS5nZXQoa2V5SWQpLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLl9teUluZGV4LmdldFZhbHVlRm9ySXRlbUF0S2V5SWQoaXRlbSwga2V5SWQpLFxuICAgICAgICAgIHNlYXJjaGVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICBtYXRjaGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBldmFsdWF0ZShjaGlsZCwgaXRlbSwgaWR4KTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICByZXMucHVzaCguLi5yZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUub3BlcmF0b3IgPT09IExvZ2ljYWxPcGVyYXRvci5BTkQpIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH07XG5cbiAgICBjb25zdCByZWNvcmRzID0gdGhpcy5fbXlJbmRleC5yZWNvcmRzO1xuICAgIGNvbnN0IHJlc3VsdE1hcCA9IHt9O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyAkOiBpdGVtLCBpOiBpZHggfSkgPT4ge1xuICAgICAgaWYgKGlzRGVmaW5lZChpdGVtKSkge1xuICAgICAgICBsZXQgZXhwUmVzdWx0cyA9IGV2YWx1YXRlKGV4cHJlc3Npb24sIGl0ZW0sIGlkeCk7XG5cbiAgICAgICAgaWYgKGV4cFJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRGVkdXBlIHdoZW4gYWRkaW5nXG4gICAgICAgICAgaWYgKCFyZXN1bHRNYXBbaWR4XSkge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2lkeF0gPSB7IGlkeCwgaXRlbSwgbWF0Y2hlczogW10gfTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHRNYXBbaWR4XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cFJlc3VsdHMuZm9yRWFjaCgoeyBtYXRjaGVzIH0pID0+IHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpZHhdLm1hdGNoZXMucHVzaCguLi5tYXRjaGVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIF9zZWFyY2hPYmplY3RMaXN0KHF1ZXJ5KSB7XG4gICAgY29uc3Qgc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihxdWVyeSwgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCB7IGtleXMsIHJlY29yZHMgfSA9IHRoaXMuX215SW5kZXg7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgLy8gTGlzdCBpcyBBcnJheTxPYmplY3Q+XG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7ICQ6IGl0ZW0sIGk6IGlkeCB9KSA9PiB7XG4gICAgICBpZiAoIWlzRGVmaW5lZChpdGVtKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGV0IG1hdGNoZXMgPSBbXTtcblxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGtleSAoaS5lLCBwYXRoKSwgYW5kIGZldGNoIHRoZSB2YWx1ZSBhdCB0aGF0IGtleVxuICAgICAga2V5cy5mb3JFYWNoKChrZXksIGtleUluZGV4KSA9PiB7XG4gICAgICAgIG1hdGNoZXMucHVzaChcbiAgICAgICAgICAuLi50aGlzLl9maW5kTWF0Y2hlcyh7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogaXRlbVtrZXlJbmRleF0sXG4gICAgICAgICAgICBzZWFyY2hlclxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgbWF0Y2hlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cbiAgX2ZpbmRNYXRjaGVzKHsga2V5LCB2YWx1ZSwgc2VhcmNoZXIgfSkge1xuICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgbGV0IG1hdGNoZXMgPSBbXTtcblxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoeyB2OiB0ZXh0LCBpOiBpZHgsIG46IG5vcm0gfSkgPT4ge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgIG5vcm0sXG4gICAgICAgICAgICBpbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHY6IHRleHQsIG46IG5vcm0gfSA9IHZhbHVlO1xuXG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHsgc2NvcmUsIGtleSwgdmFsdWU6IHRleHQsIG5vcm0sIGluZGljZXMgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXNcbiAgfVxufVxuXG5GdXNlLnZlcnNpb24gPSAnNi42LjInO1xuRnVzZS5jcmVhdGVJbmRleCA9IGNyZWF0ZUluZGV4O1xuRnVzZS5wYXJzZUluZGV4ID0gcGFyc2VJbmRleDtcbkZ1c2UuY29uZmlnID0gQ29uZmlnO1xuXG57XG4gIEZ1c2UucGFyc2VRdWVyeSA9IHBhcnNlO1xufVxuXG57XG4gIHJlZ2lzdGVyKEV4dGVuZGVkU2VhcmNoKTtcbn1cblxuZXhwb3J0IHsgRnVzZSBhcyBkZWZhdWx0IH07XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIiB0eXBlPVwidHNcIj5cdFxuXHRleHBvcnQgZW51bSBDbGFzc1R5cGUge1xuXHRcdFVOS05PV04gPSAndW5rbm93bicsXG5cblx0XHQvLyBzZXQgb2YgY2hhaW5zIHdoaWNoIHNoYXJlIGEgY29tbW9uIGFkZHJlc3Mgc3BhY2UsIHN1Y2ggdGhhdCB1c2VyIGFjY291bnRzIGFyZSB0cmFuc2xhdGFibGUgYWNyb3NzIG1lbWJlcnNcblx0XHRGQU1JTFkgPSAnZmFtaWx5JyxcblxuXHRcdC8vIHNwZWNpZmljIGJsb2NrY2hhaW5cblx0XHRDSEFJTiA9ICdjaGFpbicsXG5cblx0XHQvLyBjb25maWd1cmF0aW9uIGZvciBob3cgdG8gY29tbXVuaWNhdGUgd2l0aCBjaGFpblxuXHRcdE5FVFdPUksgPSAnbmV0d29yaycsXG5cblx0XHQvLyBcblx0XHRBQ0NPVU5UID0gJ2FjY291bnQnLFxuXG5cdFx0Ly8gcHVia2V5IGFzc29jaWF0ZWQgd2l0aCBkaXN0aW5jdCBmYW1pbHkgJ21lbWJlcidcblx0XHRDT05UQUNUID0gJ2NvbnRhY3QnLFxuXG5cdFx0Ly8gb24tY2hhaW4gcmVzb3VyY2UgdGhhdCBvbmx5IGV4aXN0cyB0aGlzIGNoYWluXG5cdFx0Q09OVFJBQ1QgPSAnY29udHJhY3QnLFxuXG5cdFx0Ly8gYWRkcmVzc2FibGUgYXNzZXQgYXNzb2NpYXRlZCB3aXRoIGRpc3RpbmN0IGNoYWluXG5cdFx0VE9LRU4gPSAndG9rZW4nLFxuXG5cdFx0Ly8gYXNzZXQgaG9sZGluZ3Ncblx0XHRIT0xESU5HID0gJ2hvbGRpbmcnLFxuXG5cdFx0Ly8gYXBwIGNvbm5lY3Rpb25cblx0XHRBUFAgPSAnYXBwJyxcblxuXHRcdC8vIG5hdGl2ZSBjb2luXG5cdFx0Q09JTiA9ICdjb2luJyxcblxuXHRcdFRBRyA9ICd0YWcnLFxuXHRcdElDT04gPSAnaWNvbicsXG5cblx0XHRJQkNUID0gJ2liY3QnLFxuXHRcdFNOSVA3MjEgPSAnc25pcDcyMScsXG5cdFx0VFhOID0gJ3R4bicsXG5cdFx0T1RIRVIgPSAnb3RoZXInLFxuXHR9XG5cblx0ZXhwb3J0IGludGVyZmFjZSBTZWFyY2hJdGVtIHtcblx0XHRjbGFzczogQ2xhc3NUeXBlO1xuXHRcdHJlc291cmNlUGF0aDogUmVzb3VyY2UuUGF0aDtcblx0XHRuYW1lOiBzdHJpbmc7XG5cdFx0cmVzb3VyY2U6IFJlc291cmNlWydpbnRlcmZhY2UnXTtcblx0XHRkZXRhaWxzOiBEaWN0PEpzb25WYWx1ZT47XG5cdH1cblxuXHRleHBvcnQgaW50ZXJmYWNlIFNlYXJjaEdyb3VwIHtcblx0XHRzb3VyY2U6IFByb21pc2FibGU8dHlwZW9mIFdyaXRhYmxlU3RvcmVNYXAgJiBTdGF0aWNTdG9yZSB8IEFycmF5PGFueT4+O1xuXHRcdHRyYW5zZm9ybShnX3RoaW5nOiBSZXNvdXJjZVsnaW50ZXJmYWNlJ10pOiBPbWl0PFNlYXJjaEl0ZW0sICdyZWYnPjtcblx0XHRrZXlzOiBzdHJpbmdbXTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQgdHlwZT1cInRzXCI+XG5cdGltcG9ydCBGdXNlIGZyb20gJ2Z1c2UuanMnO1xuXG5cdGltcG9ydCB7XG5cdFx0eXdfY2FuY2VsX3NlYXJjaCxcblx0XHR5d19oZWFkZXJfcHJvcHMsXG5cdFx0eXdfc2VhcmNoLFxuXHR9IGZyb20gJyMjL21lbSc7XG5cblx0aW1wb3J0IHtcblx0XHRTY3JlZW4sXG5cdFx0SGVhZGVyLFxuXHR9IGZyb20gJyMjL3NjcmVlbi9fc2NyZWVucyc7XG5cblx0Ly8gaW1wb3J0IEdlbmVyaWNSb3cgZnJvbSAnIy91aS9HZW5lcmljUm93LnN2ZWx0ZSc7XG5cdGltcG9ydCB7QWNjb3VudHN9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQge0FnZW50c30gZnJvbSAnIy9zdG9yZS9hZ2VudHMnO1xuXHRpbXBvcnQge0FwcHN9IGZyb20gJyMvc3RvcmUvYXBwcyc7XG5cdGltcG9ydCB7Q2hhaW5zfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7RW50aXRpZXN9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQge01lZGlhc30gZnJvbSAnIy9zdG9yZS9tZWRpYXMnO1xuXHRpbXBvcnQge05ldHdvcmtzfSBmcm9tICcjL3N0b3JlL25ldHdvcmtzJztcblx0aW1wb3J0IHtQZnBzfSBmcm9tICcjL3N0b3JlL3BmcHMnO1xuXHRpbXBvcnQgdHlwZSB7UmVzb3VyY2V9IGZyb20gJyMvbWV0YS9yZXNvdXJjZSc7XG5cdGltcG9ydCB0eXBlIHtBY2NvdW50LCBBY2NvdW50UGF0aH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXHRpbXBvcnQge0RpY3QsIEpzb25PYmplY3QsIEpzb25WYWx1ZSwgb2RlLCBvZGVyYWMsIFByb21pc2FibGUsIHByb3Blcn0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQgdHlwZSB7U3RhdGljU3RvcmUsIFdyaXRhYmxlU3RvcmVNYXB9IGZyb20gJyMvc3RvcmUvX2Jhc2UnO1xuXHRpbXBvcnQgdHlwZSB7QWdlbnQsIEFnZW50UGF0aCwgQ2hhaW5QYXRofSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgUm93IGZyb20gJyMvYXBwL3VpL1Jvdy5zdmVsdGUnO1xuXG5cdGxldCBkbV9yZXN1bHRzOiBIVE1MRWxlbWVudDtcblx0Y29uc3QgYV9yZXN1bHRzOiBTZWFyY2hJdGVtW10gPSBbXTtcblxuXG5cdC8vIGxldCB5X2Z1c2U6IEZ1c2U8U2VhcmNoSXRlbT47XG5cdGxldCBhX2Z1c2VzOiBGdXNlPFNlYXJjaEl0ZW0+W10gPSBbXTtcblxuXHRjb25zdCBmdXpleSA9IChhX2l0ZW1zOiBTZWFyY2hJdGVtW10sIGFfa2V5czogc3RyaW5nW10pID0+IG5ldyBGdXNlKGFfaXRlbXMsIHtcblx0XHRpbmNsdWRlU2NvcmU6IHRydWUsXG5cdFx0aW5jbHVkZU1hdGNoZXM6IHRydWUsXG5cdFx0a2V5czogW1xuXHRcdFx0J2xhYmVsJyxcblx0XHRcdC4uLmFfa2V5cy5tYXAocyA9PiBgZGV0YWlscy4ke3N9YCksXG5cdFx0XSxcblx0fSk7XG5cblx0KGFzeW5jKCkgPT4ge1xuXHRcdGNvbnN0IGhfc3RvcmVzID0ge307XG5cblx0XHRjb25zdCBrc19jaGFpbnMgPSBhd2FpdCBDaGFpbnMucmVhZCgpO1xuXG5cdFx0YV9mdXNlcyA9IFtcblx0XHRcdC8vIGNoYWluc1xuXHRcdFx0KCgpID0+IGZ1emV5KGtzX2NoYWlucy5lbnRyaWVzKCkubWFwKChbcF9jaGFpbiwgZ19jaGFpbl0pID0+ICh7XG5cdFx0XHRcdGNsYXNzOiBDbGFzc1R5cGUuQ0hBSU4sXG5cdFx0XHRcdG5hbWU6IGdfY2hhaW4ubmFtZSxcblx0XHRcdFx0cmVzb3VyY2VQYXRoOiBwX2NoYWluLFxuXHRcdFx0XHRyZXNvdXJjZTogZ19jaGFpbixcblx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdG5hbWU6IGdfY2hhaW4ubmFtZSxcblx0XHRcdFx0XHRpZDogZ19jaGFpbi5pZCxcblx0XHRcdFx0fSxcblx0XHRcdH0pKSwgWydpZCddKSkoKSxcblxuXHRcdFx0Ly8gY29pbnNcblx0XHRcdCgoKSA9PiBmdXpleShrc19jaGFpbnMuZW50cmllcygpLmZsYXRNYXAoKFtwX2NoYWluLCBnX2NoYWluXSkgPT4gb2RlcmFjKGdfY2hhaW4uY29pbnMsIChzaV9jb2luLCBnX2NvaW4pID0+ICh7XG5cdFx0XHRcdGNsYXNzOiBDbGFzc1R5cGUuQ09JTixcblx0XHRcdFx0bmFtZTogcHJvcGVyKGdfY29pbi5leHRyYT8uY29pbmdlY2tvX2lkIHx8ICdVbmtub3duJyksXG5cdFx0XHRcdHBvc3RuYW1lOiBzaV9jb2luLFxuXHRcdFx0XHRyZXNvdXJjZVBhdGg6IGAke3BfY2hhaW59L2NvaW4uJHtzaV9jb2lufWAsXG5cdFx0XHRcdHJlc291cmNlOiB7XG5cdFx0XHRcdFx0bmFtZTogcHJvcGVyKGdfY29pbi5leHRyYT8uY29pbmdlY2tvX2lkIHx8ICdVbmtub3duJyksXG5cdFx0XHRcdFx0cGZwOiBnX2NoYWluLnBmcCxcblx0XHRcdFx0XHQuLi5nX2NvaW4sXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0XHRzeW1ib2w6IHNpX2NvaW4sXG5cdFx0XHRcdFx0ZGVub206IGdfY29pbi5kZW5vbSxcblx0XHRcdFx0XHRjb2luZ2Vja286IGdfY29pbi5leHRyYT8uY29pbmdlY2tvX2lkIHx8ICcnLFxuXHRcdFx0XHR9LFxuXHRcdFx0fSkpKSwgWydzeW1ib2wnLCAnZGVub20nXSkpKCksXG5cblx0XHRcdC4uLmF3YWl0IFByb21pc2UuYWxsKFtcblx0XHRcdFx0Ly8gYWNjb3VudHNcblx0XHRcdFx0KGFzeW5jKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZ1emV5KGtzX2FjY291bnRzLmVudHJpZXMoKS5tYXAoKFtwX2FjY291bnQsIGdfYWNjb3VudF0pID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGFfYWRkcnM6IHN0cmluZ1tdID0gW107XG5cdFx0XHRcdFx0XHRjb25zdCBhc19hZGRycyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5cdFx0XHRcdFx0XHRmb3IoY29uc3QgWywgZ19jaGFpbl0gb2Yga3NfY2hhaW5zKSB7XG5cdFx0XHRcdFx0XHRcdGFzX2FkZHJzLmFkZChDaGFpbnMuYWRkcmVzc0ZvcihnX2FjY291bnQucHVia2V5LCBnX2NoYWluKSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGFfYWRkcnMucHVzaCguLi5hc19hZGRycyk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiBDbGFzc1R5cGUuQUNDT1VOVCxcblx0XHRcdFx0XHRcdFx0bmFtZTogZ19hY2NvdW50Lm5hbWUsXG5cdFx0XHRcdFx0XHRcdHJlc291cmNlUGF0aDogcF9hY2NvdW50LFxuXHRcdFx0XHRcdFx0XHRyZXNvdXJjZTogZ19hY2NvdW50LFxuXHRcdFx0XHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogZ19hY2NvdW50Lm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0YWRkcmVzc2VzOiBhX2FkZHJzLFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KSwgWydhZGRyZXNzZXMnXSk7XG5cdFx0XHRcdH0pKCksXG5cblx0XHRcdFx0Ly8gY29udGFjdHNcblx0XHRcdFx0KGFzeW5jKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGtzX2FnZW50cyA9IGF3YWl0IEFnZW50cy5yZWFkKCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gZnV6ZXkoWy4uLmtzX2FnZW50cy5jb250YWN0cygpXS5tYXAoKFtwX2NvbnRhY3QsIGdfY29udGFjdF0pID0+ICh7XG5cdFx0XHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLkNPTlRBQ1QsXG5cdFx0XHRcdFx0XHRuYW1lOiBnX2NvbnRhY3QubmFtZSxcblx0XHRcdFx0XHRcdHJlc291cmNlUGF0aDogcF9jb250YWN0LFxuXHRcdFx0XHRcdFx0cmVzb3VyY2U6IGdfY29udGFjdCxcblx0XHRcdFx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0XHRcdFx0bmFtZTogZ19jb250YWN0Lm5hbWUsXG5cdFx0XHRcdFx0XHRcdG5vdGVzOiBnX2NvbnRhY3Qubm90ZXMsXG5cdFx0XHRcdFx0XHRcdGFkZHJlc3NlczogWy4uLmtzX2NoYWlucy5pbkZhbWlseShnX2NvbnRhY3QuZmFtaWx5KV1cblx0XHRcdFx0XHRcdFx0XHQubWFwKChbLCBnX2NoYWluXSkgPT4gQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcywgZ19jaGFpbikpLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9KSksIFsnbm90ZXMnXSk7XG5cdFx0XHRcdH0pKCksXG5cblx0XHRcdFx0Ly8gYXBwc1xuXHRcdFx0XHQoYXN5bmMoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3Qga3NfYXBwcyA9IGF3YWl0IEFwcHMucmVhZCgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZ1emV5KGtzX2FwcHMuZW50cmllcygpLm1hcCgoW3BfYXBwLCBnX2FwcF0pID0+ICh7XG5cdFx0XHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLkFQUCxcblx0XHRcdFx0XHRcdG5hbWU6IGdfYXBwLmhvc3QsXG5cdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg6IHBfYXBwLFxuXHRcdFx0XHRcdFx0cmVzb3VyY2U6IGdfYXBwLFxuXHRcdFx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdFx0XHRob3N0OiBnX2FwcC5ob3N0LFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9KSksIFtdKTtcblx0XHRcdFx0fSkoKSxcblxuXHRcdFx0XHQvLyB0b2tlbnNcblx0XHRcdFx0KGFzeW5jKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGFfdG9rZW5zOiBTZWFyY2hJdGVtW10gPSBbXTtcblxuXHRcdFx0XHRcdGZvcihjb25zdCBbLCBnX2NoYWluXSBvZiBrc19jaGFpbnMuZW50cmllcygpKSB7XG5cdFx0XHRcdFx0XHRmb3IoY29uc3QgW3NpX3NwZWMsIGhfdG9rZW5zXSBvZiBvZGUoYXdhaXQgRW50aXRpZXMucmVhZEZ1bmdpYmxlVG9rZW5zKGdfY2hhaW4pKSkge1xuXHRcdFx0XHRcdFx0XHRmb3IoY29uc3QgW3BfdG9rZW4sIGdfdG9rZW5dIG9mIG9kZShoX3Rva2VucykpIHtcblx0XHRcdFx0XHRcdFx0XHRhX3Rva2Vucy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdGNsYXNzOiBDbGFzc1R5cGUuVE9LRU4sXG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiBnX3Rva2VuLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg6IHBfdG9rZW4sXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZTogZ190b2tlbixcblx0XHRcdFx0XHRcdFx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3BlYzogc2lfc3BlYyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmFtZTogZ190b2tlbi5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzeW1ib2w6IGdfdG9rZW4uc3ltYm9sLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRiZWNoMzI6IGdfdG9rZW4uYmVjaDMyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb2RlaGFzaDogZ190b2tlbi5oYXNoLFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBmdXpleShhX3Rva2VucywgW1xuXHRcdFx0XHRcdFx0J3NwZWMnLFxuXHRcdFx0XHRcdFx0J3N5bWJvbCcsXG5cdFx0XHRcdFx0XHQnYmVjaDMyJyxcblx0XHRcdFx0XHRcdCdjb2RlaGFzaCcsXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH0pKCksXG5cblx0XHRcdFx0Ly8gRW50aXRpZXMsXG5cdFx0XHRcdC8vIE5ldHdvcmtzLFxuXHRcdFx0XSksXG5cdFx0XTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBzZWFyY2goc19zZWFyY2g6IHN0cmluZykge1xuXHRcdGNvbnN0IGFfZ3JvdXBzOiB7dG9wOm51bWJlciwgaGl0czpGdXNlLkZ1c2VSZXN1bHQ8U2VhcmNoSXRlbT5bXX1bXSA9IFtdO1xuXHRcdGNvbnN0IGFfaGl0czogRnVzZS5GdXNlUmVzdWx0PFNlYXJjaEl0ZW0+W10gPSBbXTtcblx0XHRsZXQgY190b3RhbCA9IDA7XG5cblx0XHRmb3IoY29uc3QgeV9mdXNlIG9mIGFfZnVzZXMpIHtcblx0XHRcdGNvbnN0IGFfaGl0c19sb2NhbCA9IHlfZnVzZS5zZWFyY2goc19zZWFyY2gpO1xuXG5cdFx0XHRpZihhX2hpdHNfbG9jYWwubGVuZ3RoKSB7XG5cdFx0XHRcdGNfdG90YWwgKz0gYV9oaXRzLmxlbmd0aDtcblxuXHRcdFx0XHRhX2hpdHMucHVzaCguLi5hX2hpdHNfbG9jYWwpO1xuXG5cdFx0XHRcdGFfZ3JvdXBzLnB1c2goe1xuXHRcdFx0XHRcdHRvcDogYV9oaXRzX2xvY2FsWzBdLnNjb3JlISxcblx0XHRcdFx0XHRoaXRzOiBhX2hpdHNfbG9jYWwsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNvcnQgYWxsIGhpdHNcblx0XHRhX2hpdHMuc29ydCgoZ19hLCBnX2IpID0+IGdfYi5zY29yZSEgLSBnX2Euc2NvcmUhKTtcblxuXHRcdC8vIGNsZWFyIHJlc3VsdHMgbGlzdFxuXHRcdGRtX3Jlc3VsdHMuaW5uZXJIVE1MID0gJyc7XG5cblx0XHRjb25zb2xlLmxvZyhhX2hpdHMpO1xuXG5cdFxuXHRcdGZvcihjb25zdCBnX2hpdCBvZiBhX2hpdHMpXHR7XG5cdFx0XHRuZXcgUm93KHtcblx0XHRcdFx0dGFyZ2V0OiBkbV9yZXN1bHRzLFxuXHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdC4uLmdfaGl0Lml0ZW0sXG5cdFx0XHRcdFx0cGZwRGltOiAzMixcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdCQ6IHtcblx0XHRpZigkeXdfc2VhcmNoKSB7XG5cdFx0XHRzZWFyY2goJHl3X3NlYXJjaCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gb25Nb3VudCgoKSA9PiB7XG5cdC8vIFx0c2VhcmNoKCR5d19zZWFyY2gpO1xuXHQvLyB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0LnNlYXJjaCB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHR6LWluZGV4OiAxMDAwO1xuXG5cdFx0LnJlc3VsdHMge1xuXG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG5cbjxkaXYgY2xhc3M9XCJzZWFyY2hcIiBjbGFzczpkaXNwbGF5X25vbmU9eyEkeXdfc2VhcmNofT5cblx0PFNjcmVlbiBkZWJ1Zz0nU2VhcmNoJyByb290PlxuXHRcdDxIZWFkZXIgbmV0d29yayBhY2NvdW50IHNlYXJjaFxuXHRcdFx0aXNTZWFyY2hTY3JlZW4gey4uLigkeXdfaGVhZGVyX3Byb3BzIHx8IHt9KX0gb246c2VhcmNoPXtkX2V2ZW50ID0+IHNlYXJjaChkX2V2ZW50LmRldGFpbCl9XG5cdFx0Lz5cblxuXHRcdDxwIHN0eWxlPSdmb250LXNpemU6MTJweCc+XG5cdFx0XHQ8c3BhbiBzdHlsZT0nY29sb3I6dmFyKC0tdGhlbWUtY29sb3ItY2F1dGlvbik7Jz5EaXNjbGFpbWVyOiA8L3NwYW4+XG5cdFx0XHRUaGlzIHRlbXBvcmFyeSBzZWFyY2ggaW50ZXJmYWNlIGRvZXMgbm90IHJlcHJlc2VudCB0aGUgbG9vayBhbmQgZnVuY3Rpb24gb2YgdGhlIGFjdHVhbCBzZWFyY2ggaW50ZXJmYWNlIGN1cnJlbnRseSB1bmRlciBkZXZlbG9wbWVudCBmb3IgYmV0YS5cblx0XHQ8L3A+XG5cblx0XHQ8ZGl2IGNsYXNzPVwicmVzdWx0cyBuby1tYXJnaW5cIiBiaW5kOnRoaXM9e2RtX3Jlc3VsdHN9PlxuXHRcdFx0eyNrZXkgYV9yZXN1bHRzfVxuXHRcdFx0XHR7I2VhY2ggYV9yZXN1bHRzIGFzIGdfcmVzdWx0fVxuXHRcdFx0XHRcdDxHZW5lcmljUm93IGl0ZW09e2dfcmVzdWx0fSAvPlxuXHRcdFx0XHR7L2VhY2h9XG5cdFx0XHR7L2tleX1cblx0XHQ8L2Rpdj5cblx0PC9TY3JlZW4+XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IHl3X3Byb2dyZXNzIH0gZnJvbSAnIyMvbWVtJztcblxuXHQkOiB4X3dpZHRoX3BjdF9iYXIgPSAoJHl3X3Byb2dyZXNzWzBdIC8gJHl3X3Byb2dyZXNzWzFdKSAqIDEwMDtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHQucHJvZ3Jlc3Mge1xuXHRcdC0tYmFyLWhlaWdodDogNHB4O1xuXHRcdHotaW5kZXg6IDEwMDE7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdGhlaWdodDogdmFyKC0tYmFyLWhlaWdodCk7XG5cdFx0dG9wOiBjYWxjKDBweCAtIHZhcigtLWJhci1oZWlnaHQpKTtcblx0XHRsZWZ0OiAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdHRyYW5zaXRpb246IHRvcCAwLjJzIHZhcigtLWVhc2Utb3V0LWN1YmljKTtcblxuXHRcdCYudmlzaWJsZSB7XG5cdFx0XHR0b3A6IDA7XG5cdFx0fVxuXG5cdFx0Pi5iYXIge1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHR3aWR0aDogMCU7XG5cdFx0XHR0cmFuc2l0aW9uOiB3aWR0aCAxcyB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cdFx0fVxuXHR9XG5cblx0LnN0ZXAge1xuXHRcdC5mb250KHRpbnkpO1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cblx0XHR6LWluZGV4OiAxMDAxO1xuXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogY2FsYygwcHggLSB2YXIoLS11aS1wYWRkaW5nKSk7XG5cdFx0bGVmdDogMDtcblx0XHQvLyBsZWZ0OiBjYWxjKDBweCAtICh2YXIoLS1hcHAtd2luZG93LXdpZHRoKSAqIDAuMjUpKTtcblx0XHRcblx0XHRtYXJnaW4tdG9wOiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRtYXJnaW4tbGVmdDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XG5cdFx0b3BhY2l0eTogMDtcblx0XHR0cmFuc2l0aW9uOiBhbGwgMC42cyB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cdFx0dHJhbnNpdGlvbi1kZWxheTogMC40cztcblxuXHRcdCYudmlzaWJsZSB7XG5cdFx0XHQvLyBsZWZ0OiAwO1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0b3BhY2l0eTogMTtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cblxuPGRpdiBjbGFzcz1cInByb2dyZXNzXCIgY2xhc3M6dmlzaWJsZT17JHl3X3Byb2dyZXNzWzBdID4gMH0+XG5cdDxkaXYgY2xhc3M9XCJiYXJcIiBzdHlsZT1cIndpZHRoOiB7eF93aWR0aF9wY3RfYmFyfSU7XCI+PC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cInN0ZXBcIiBjbGFzczp2aXNpYmxlPXskeXdfcHJvZ3Jlc3NbMF0gPiAwfT5cblx0U3RlcCB7JHl3X3Byb2dyZXNzWzBdIHx8ICR5d19wcm9ncmVzc1sxXX0gb2YgeyR5d19wcm9ncmVzc1sxXX1cbjwvZGl2PlxuIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJtMTggMTYgNC00LTQtNHYzaC01LjA2QTguOTc0IDguOTc0IDAgMCAwIDggMy45NSAzLjAwNSAzLjAwNSAwIDAgMCA1IDFDMy4zNCAxIDIgMi4zNCAyIDRzMS4zNCAzIDMgM2MuOTUgMCAxLjc4LS40NSAyLjMzLTEuMTRDOS4yMyA2LjkgMTAuNiA4Ljc3IDEwLjkyIDExaC0zLjFDNy40IDkuODQgNi4zIDkgNSA5Yy0xLjY2IDAtMyAxLjM0LTMgM3MxLjM0IDMgMyAzYzEuMyAwIDIuNC0uODQgMi44Mi0yaDMuMWMtLjMyIDIuMjMtMS42OSA0LjEtMy41OCA1LjE0QzYuNzggMTcuNDUgNS45NSAxNyA1IDE3Yy0xLjY2IDAtMyAxLjM0LTMgM3MxLjM0IDMgMyAzYTIuOTkgMi45OSAwIDAgMCAyLjk5LTIuOTVBOC45NzQgOC45NzQgMCAwIDAgMTIuOTMgMTNIMTh2M3pcXFwiLz5cXG48L3N2Zz5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6TTcuMDcgMTguMjhjLjQzLS45IDMuMDUtMS43OCA0LjkzLTEuNzhzNC41MS44OCA0LjkzIDEuNzhDMTUuNTcgMTkuMzYgMTMuODYgMjAgMTIgMjBzLTMuNTctLjY0LTQuOTMtMS43MnptMTEuMjktMS40NWMtMS40My0xLjc0LTQuOS0yLjMzLTYuMzYtMi4zM3MtNC45My41OS02LjM2IDIuMzNBNy45NSA3Ljk1IDAgMCAxIDQgMTJjMC00LjQxIDMuNTktOCA4LThzOCAzLjU5IDggOGMwIDEuODItLjYyIDMuNDktMS42NCA0Ljgzek0xMiA2Yy0xLjk0IDAtMy41IDEuNTYtMy41IDMuNVMxMC4wNiAxMyAxMiAxM3MzLjUtMS41NiAzLjUtMy41UzEzLjk0IDYgMTIgNnptMCA1Yy0uODMgMC0xLjUtLjY3LTEuNS0xLjVTMTEuMTcgOCAxMiA4czEuNS42NyAxLjUgMS41UzEyLjgzIDExIDEyIDExelxcXCIvPlxcbjwvc3ZnPlwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTggNHYxNkg2VjRoMTJtMC0ySDZjLTEuMSAwLTIgLjktMiAydjE4aDE2VjRjMC0xLjEtLjktMi0yLTJ6bS0yLjUgOC41Yy0uODMgMC0xLjUuNjctMS41IDEuNXMuNjcgMS41IDEuNSAxLjVTMTcgMTIuODMgMTcgMTJzLS42Ny0xLjUtMS41LTEuNXpcXFwiLz5cXG48L3N2Zz5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IEZfTk9PUCwgdGltZW91dCB9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXHRpbXBvcnQge1xuXHRcdHl3X21lbnVfZXhwYW5kZWQsIHl3X25hdmlnYXRvcixcblx0fSBmcm9tICcjL2FwcC9tZW0nO1xuXG5cdGltcG9ydCBTWF9JQ09OX0NPTlRBQ1RTIGZyb20gJyMvaWNvbi9zdXBlcnZpc29yX2FjY291bnQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NIQUlOUyBmcm9tICcjL2ljb24vbWVkaWF0aW9uLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9BQ0NPVU5UUyBmcm9tICcjL2ljb24vYWNjb3VudF9jaXJjbGUuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX1RBR1MgZnJvbSAnIy9pY29uL2Jvb2ttYXJrcy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ09OTkVDVElPTlMgZnJvbSAnIy9pY29uL2FjY291bnRfdHJlZS5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fU0VUVElOR1MgZnJvbSAnIy9pY29uL3NldHRpbmdzLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9MT0dPVVQgZnJvbSAnIy9pY29uL3NlbnNvcl9kb29yLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9DTE9TRSBmcm9tICcjL2ljb24vY2xvc2Uuc3ZnP3Jhdyc7XG5cdGltcG9ydCB7IFRocmVhZElkIH0gZnJvbSAnIy9hcHAvZGVmJztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgUGFnZSB9IGZyb20gJyMjL3NjcmVlbi9fc2NyZWVucyc7XG5cdGltcG9ydCB7IGxvZ291dCB9IGZyb20gJyMvc2hhcmUvYXV0aCc7XG5cblx0aW50ZXJmYWNlIEl0ZW0ge1xuXHRcdGNsaWNrOiBWb2lkRnVuY3Rpb247XG5cdFx0bGFiZWw6IHN0cmluZztcblx0XHQvLyBpY29uOiBJY29uO1xuXHRcdGljb246IHN0cmluZztcblx0fVxuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRmdW5jdGlvbiBhY3RpdmF0ZShzaV90aHJlYWQ6IFRocmVhZElkKSB7XG5cdFx0JHl3X21lbnVfZXhwYW5kZWQgPSBmYWxzZTtcblxuXHRcdGlmKHNpX3RocmVhZCA9PT0gJHl3X25hdmlnYXRvci5hY3RpdmVUaHJlYWQuaWQpIHtcblx0XHRcdCR5d19uYXZpZ2F0b3IuYWN0aXZlVGhyZWFkLnJlc2V0KCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKHNpX3RocmVhZCk7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgQV9JVEVNUyA9IFtcblx0XHQvLyB7XG5cdFx0Ly8gXHRsYWJlbDogJ0NvbnRhY3RzJyxcblx0XHQvLyBcdC8vIGljb246IEljb24uZnJvbUh0bWwoU1hfSUNPTl9DT05UQUNUUyksXG5cdFx0Ly8gXHRpY29uOiBTWF9JQ09OX0NPTlRBQ1RTLFxuXHRcdC8vIFx0Y2xpY2soKSB7XG5cdFx0Ly8gXHRcdCR5d19tZW51X2V4cGFuZGVkID0gZmFsc2U7XG5cdFx0Ly8gXHRcdHZvaWQgJHl3X25hdmlnYXRvci5hY3RpdmF0ZVRocmVhZChUaHJlYWRJZC5DT05UQUNUUyk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdBY2NvdW50cycsXG5cdFx0XHQvLyBpY29uOiBJY29uLmZyb21IdG1sKFNYX0lDT05fQUNDT1VOVFMpLFxuXHRcdFx0aWNvbjogU1hfSUNPTl9BQ0NPVU5UUyxcblx0XHRcdGNsaWNrKCkge1xuXHRcdFx0XHRhY3RpdmF0ZShUaHJlYWRJZC5BQ0NPVU5UUyk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdOZXR3b3JrcycsXG5cdFx0XHQvLyBpY29uOiBJY29uLmZyb21IdG1sKFNYX0lDT05fQ0hBSU5TKSxcblx0XHRcdGljb246IFNYX0lDT05fQ0hBSU5TLFxuXHRcdFx0Y2xpY2soKSB7XG5cdFx0XHRcdGFjdGl2YXRlKFRocmVhZElkLk5FVFdPUktTKTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHQvLyB7XG5cdFx0Ly8gXHRsYWJlbDogJ1RhZ3MnLFxuXHRcdC8vIFx0Ly8gaWNvbjogSWNvbi5mcm9tSHRtbChTWF9JQ09OX1RBR1MpLFxuXHRcdC8vIFx0aWNvbjogU1hfSUNPTl9UQUdTLFxuXHRcdC8vIFx0Y2xpY2soKSB7XG5cdFx0Ly8gXHRcdCR5d19tZW51X2V4cGFuZGVkID0gZmFsc2U7XG5cdFx0Ly8gXHRcdC8vIGtfcGFnZS5wdXNoKHtcblx0XHQvLyBcdFx0Ly8gXHRjcmVhdG9yOiBEZWFkRW5kLFxuXHRcdC8vIFx0XHQvLyB9KTtcblx0XHQvLyBcdH0sXG5cdFx0Ly8gfSxcblx0XHQvLyB7XG5cdFx0Ly8gXHRsYWJlbDogJ1NpdGVzJyxcblx0XHQvLyBcdC8vIGljb246IEljb24uZnJvbUh0bWwoU1hfSUNPTl9DT05ORUNUSU9OUyksXG5cdFx0Ly8gXHRpY29uOiBTWF9JQ09OX0NPTk5FQ1RJT05TLFxuXHRcdC8vIFx0Y2xpY2soKSB7XG5cdFx0Ly8gXHRcdCR5d19tZW51X2V4cGFuZGVkID0gZmFsc2U7XG5cdFx0Ly8gXHRcdHZvaWQgJHl3X25hdmlnYXRvci5hY3RpdmF0ZVRocmVhZChUaHJlYWRJZC5TSVRFUyk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdFx0Ly8ge1xuXHRcdC8vIFx0bGFiZWw6ICdTZXR0aW5ncycsXG5cdFx0Ly8gXHQvLyBpY29uOiBJY29uLmZyb21IdG1sKFNYX0lDT05fU0VUVElOR1MpLFxuXHRcdC8vIFx0aWNvbjogU1hfSUNPTl9TRVRUSU5HUyxcblx0XHQvLyBcdGNsaWNrOiAoKSA9PiB7XG5cdFx0Ly8gXHRcdCR5d19tZW51X2V4cGFuZGVkID0gZmFsc2U7XG5cdFx0Ly8gXHRcdGtfcGFnZS5wdXNoKHtcblx0XHQvLyBcdFx0XHRjcmVhdG9yOiBEZWFkRW5kLFxuXHRcdC8vIFx0XHR9KTtcblx0XHQvLyBcdH0sXG5cdFx0Ly8gfSxcblx0XTtcblxuXHRjb25zdCBBX1NFU1NJT05fSVRFTVMgPSBbXG5cdFx0e1xuXHRcdFx0bGFiZWw6ICdMb2cgb3V0Jyxcblx0XHRcdGljb246IFNYX0lDT05fTE9HT1VULFxuXHRcdFx0YXN5bmMgY2xpY2soKSB7XG5cdFx0XHRcdGF3YWl0IGxvZ291dCgpO1xuXHRcdFx0XHRnbG9iYWxUaGlzLmNsb3NlKCk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdF07XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uL3NjcmVlbi9fYmFzZS5sZXNzJztcblxuXHQ6cm9vdCB7XG5cdFx0LS1iYXItd2lkdGg6IDc4LjglO1xuXHRcdC0tYW5pbWF0aW9uLWR1cmF0aW9uOiAxcztcblx0XHQtLWFuaW1hdGlvbi1lYXNpbmc6IHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0fVxuXG5cdEBrZXlmcmFtZXMgZmFkZSB7XG5cdFx0MCUge1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0fVxuXG5cdFx0MTAwJSB7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG5cdFx0fVxuXHR9XG5cblx0QGtleWZyYW1lcyBzbGlkZSB7XG5cdFx0MCUge1xuXHRcdFx0cmlnaHQ6IGNhbGMoMCUgLSB2YXIoLS1iYXItd2lkdGgpKTtcblx0XHR9XG5cblx0XHQxMDAlIHtcblx0XHRcdHJpZ2h0OiAwJTtcblx0XHR9XG5cdH1cblxuXHRAa2V5ZnJhbWVzIG9mZnNjcmVlbiB7XG5cdFx0MCUge1xuXHRcdFx0dG9wOiAwO1xuXHRcdH1cblxuXHRcdDEwMCUge1xuXHRcdFx0dG9wOiB2YXIoLS1hcHAtd2luZG93LWhlaWdodCk7XG5cdFx0fVxuXHR9XG5cblx0LmFic29sdXRlKEBkaW1zOiAnJykge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblxuXHRcdHdpZHRoOiBpZignJyA9IEBkaW1zLCB2YXIoLS1hcHAtd2luZG93LXdpZHRoKSwgQGRpbXMpO1xuXHRcdGhlaWdodDogaWYoJycgPSBAZGltcywgdmFyKC0tYXBwLXdpbmRvdy1oZWlnaHQpLCBAZGltcyk7XG5cdH1cblxuXHQuc2lkZS1tZW51IHtcblx0XHQtLWl0ZW0tcGFkZGluZzogMzBweDtcblxuXHRcdC5hYnNvbHV0ZSgpO1xuXHRcdC5mb250KHJlZ3VsYXIpO1xuXHRcdHotaW5kZXg6IDEwMDE7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cblx0XHQ+LmJhY2tkcm9wIHtcblx0XHRcdC5hYnNvbHV0ZSgxMDAlKTtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcblx0XHRcdHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgdmFyKC0tYW5pbWF0aW9uLWR1cmF0aW9uKSB2YXIoLS1lYXNlLW91dC1leHBvKTtcblx0XHR9XG5cblx0XHQ+LmJhciB7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHR3aWR0aDogdmFyKC0tYmFyLXdpZHRoKTtcblx0XHRcdGhlaWdodDogMTAwJTtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblx0XHRcdHJpZ2h0OiAwJTtcblx0XHRcdHRyYW5zaXRpb246IHJpZ2h0IHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgdmFyKC0tYW5pbWF0aW9uLWVhc2luZyk7XG5cblx0XHRcdD4ubWVudSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xuXHRcdFx0XHRoZWlnaHQ6IDEwMCU7XG5cblx0XHRcdFx0dWwge1xuXHRcdFx0XHRcdG1hcmdpbjogMDtcblx0XHRcdFx0XHRwYWRkaW5nOiAwO1xuXHRcdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xuXG5cdFx0XHRcdFx0PmxpIHtcblx0XHRcdFx0XHRcdGxpc3Qtc3R5bGU6IG5vbmU7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiAxM3B4IDA7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLWxlZnQ6IHZhcigtLWl0ZW0tcGFkZGluZyk7XG5cdFx0XHRcdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cblx0XHRcdFx0XHRcdD4qIHtcblx0XHRcdFx0XHRcdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Pi5pY29uIHtcblx0XHRcdFx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0XHRcdFx0XHRwYWRkaW5nOiAwO1xuXHRcdFx0XHRcdFx0XHRwYWRkaW5nLXJpZ2h0OiBjYWxjKHZhcigtLWl0ZW0tcGFkZGluZykgLyAyKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmLml0ZW1zIHtcblx0XHRcdFx0XHRcdC5pY29uIHtcblx0XHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmLnNlc3Npb24ge1xuXHRcdFx0XHRcdFx0cGFkZGluZzogY2FsYyh2YXIoLS1pdGVtLXBhZGRpbmcpIC8gMikgMDtcblxuXHRcdFx0XHRcdFx0Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+Lm1haW4ge1xuXHRcdFx0XHRcdGZsZXg6IDE7XG5cdFx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRcdGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG5cdFx0XHRcdFx0cGFkZGluZy10b3A6IDE1JTtcblx0XHRcdFx0XHRwYWRkaW5nLWJvdHRvbTogMTUlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5ib3R0b20sPi50b3Age1xuXHRcdFx0XHRcdGZsZXg6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LnRvcCB7XG5cdFx0XHRcdFx0cGFkZGluZy10b3A6IDE1JTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCYuY29sbGFwc2VkIHtcblx0XHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0YW5pbWF0aW9uOiBvZmZzY3JlZW4gdmFyKC0tYW5pbWF0aW9uLWR1cmF0aW9uKSBzdGVwcygyLCBqdW1wLW5vbmUpIGJvdGg7XG5cdFx0XHRcblx0XHRcdD4uYmFja2Ryb3Age1xuXHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuXHRcdFx0fVxuXG5cdFx0XHQ+LmJhciB7XG5cdFx0XHRcdHJpZ2h0OiBjYWxjKDAlIC0gdmFyKC0tYmFyLXdpZHRoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHRociB7XG5cdFx0XHRtYXJnaW46IDAgdmFyKC0taXRlbS1wYWRkaW5nKTtcblx0XHRcdGJvcmRlcjogbm9uZTtcblx0XHRcdGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdH1cblxuXHRcdC5jbG9zZSB7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRyaWdodDogMDtcblx0XHRcdG1hcmdpbjogMTBweDtcblx0XHRcdHBhZGRpbmc6IDEycHg7XG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXG5cdFx0XHRvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdGJvcmRlci1yYWRpdXM6IDBweDtcblx0XHRcdHRyYW5zaXRpb246IGJvcmRlci1yYWRpdXMgNjUwbXMgdmFyKC0tZWFzZS1vdXQtZXhwbyk7XG5cdFx0XHRwb2ludGVyLWV2ZW50czogYWxsO1xuXG5cdFx0XHQmOjpiZWZvcmUge1xuXHRcdFx0XHQtLW9jY2x1c2lvbi10aGlja25lc3M6IDRweDtcblxuXHRcdFx0XHRjb250ZW50OiAnJztcblx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHR0b3A6IGNhbGModmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgLyAyKTtcblx0XHRcdFx0bGVmdDogY2FsYyh2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSAvIDIpO1xuXHRcdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykpO1xuXHRcdFx0XHRoZWlnaHQ6IGNhbGMoMTAwJSAtIHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpKTtcblx0XHRcdFx0b3V0bGluZTogdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRcdH1cblxuXHRcdFx0Jjpob3ZlciB7XG5cdFx0XHRcdGJvcmRlci1yYWRpdXM6IDIycHg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2XG5cdGNsYXNzPVwic2lkZS1tZW51XCJcblx0Y2xhc3M6Y29sbGFwc2VkPXshJHl3X21lbnVfZXhwYW5kZWR9XG4+XG5cdDxkaXYgY2xhc3M9XCJiYWNrZHJvcFwiXG5cdFx0b246Y2xpY2s9eygpID0+ICR5d19tZW51X2V4cGFuZGVkID0gZmFsc2V9XG5cdC8+XG5cblx0PGRpdiBjbGFzcz1cImJhclwiPlxuXHRcdDxkaXYgY2xhc3M9XCJjbG9zZSBpY29uXCIgb246Y2xpY2s9eygpID0+ICR5d19tZW51X2V4cGFuZGVkID0gZmFsc2V9PlxuXHRcdFx0e0BodG1sIFNYX0lDT05fQ0xPU0V9XG5cdFx0PC9kaXY+XG5cblx0XHQ8ZGl2IGNsYXNzPVwibWVudVwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cInRvcFwiPlxuXHRcdFx0XHQ8dWwgY2xhc3M9XCJzZXNzaW9uXCI+XG5cdFx0XHRcdFx0eyNlYWNoIEFfU0VTU0lPTl9JVEVNUyBhcyBnX2l0ZW19XG5cdFx0XHRcdFx0XHQ8bGkgb246Y2xpY2s9eygpID0+IGdfaXRlbS5jbGljaygpfT5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0e0BodG1sIGdfaXRlbS5pY29ufVxuXHRcdFx0XHRcdFx0XHRcdDwhLS0gPFB1dCBlbGVtZW50PXtnX2l0ZW0uaWNvbi5yZW5kZXIoKX0gLz4gLS0+XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0e2dfaXRlbS5sYWJlbH1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdDwvdWw+XG5cblx0XHRcdFx0PGhyPlxuXHRcdFx0PC9kaXY+XG5cblx0XHRcdDxkaXYgY2xhc3M9XCJtYWluXCI+XG5cdFx0XHRcdDx1bCBjbGFzcz1cIml0ZW1zXCI+XG5cdFx0XHRcdFx0eyNlYWNoIEFfSVRFTVMgYXMgZ19pdGVtfVxuXHRcdFx0XHRcdFx0PGxpIGNsYXNzPVwiXCIgb246Y2xpY2s9eygpID0+IGdfaXRlbS5jbGljaygpfT5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0e0BodG1sIGdfaXRlbS5pY29ufVxuXHRcdFx0XHRcdFx0XHRcdDwhLS0gPFB1dCBlbGVtZW50PXtnX2l0ZW0uaWNvbi5yZW5kZXIoKX0gLz4gLS0+XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0e2dfaXRlbS5sYWJlbH1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdDwvdWw+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBGX05PT1AgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IHtcblx0XHR5d19tZW51X2V4cGFuZGVkLFxuXHRcdHl3X21lbnVfdmVuZG9yLFxuXHRcdHl3X2NoYWluX3JlZixcblx0XHR5d19jaGFpbixcblx0XHR5d19uZXR3b3JrX3JlZixcblx0XHR5d19uZXR3b3JrLFxuXHR9IGZyb20gJyMjL21lbSc7XG5cblx0aW1wb3J0IHsgZ2xvYmFsX3JlY2VpdmUgfSBmcm9tICcjL3NjcmlwdC9tc2ctZ2xvYmFsJztcblx0aW1wb3J0IHsgb25EZXN0cm95IH0gZnJvbSAnc3ZlbHRlJztcbmltcG9ydCB7IFNJX1ZFUlNJT04gfSBmcm9tICcjL3NoYXJlL2NvbnN0YW50cyc7XG5cblx0Ly8gaW1wb3J0IHtcblx0Ly8gXHRJY29uLFxuXHQvLyB9IGZyb20gJyMvb2JqZWN0cyc7XG5cblx0Ly8gaW1wb3J0IHtcblx0Ly8gXHRQdXQsXG5cdC8vICB9IGZyb20gJyMvdWknO1xuXG5cdC8vIGltcG9ydCBTWF9DT05UQUNUUyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9zdXBlcnZpc29yX2FjY291bnQuc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9DSEFJTlMgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvbWVkaWF0aW9uLnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfQUNDT1VOVFMgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvYWNjb3VudF9jaXJjbGUuc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9UQUdTIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL2Jvb2ttYXJrcy5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0NPTk5FQ1RJT05TIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL2FjY291bnRfdHJlZS5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX1NFVFRJTkdTIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL3NldHRpbmdzLnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfTE9HT1VUIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL3NlbnNvcl9kb29yLnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfQ0xPU0UgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvY2xvc2Uuc3ZnP3Jhdyc7XG5cblx0Ly8gaW1wb3J0IFNYX1RJVExFIGZyb20gJyMvYXNzZXQvdmVuZG9yL3N0YXJzaGVsbC10aXRsZS5zdmc/cmF3JztcblxuXHQvLyAkeXdfbWVudV9leHBhbmRlZFxuXG5cdGludGVyZmFjZSBJdGVtIHtcblx0XHRjbGljazogVm9pZEZ1bmN0aW9uO1xuXHRcdGxhYmVsOiBzdHJpbmc7XG5cdFx0Ly8gaWNvbjogSWNvbjtcblx0fVxuXG5cdC8vIGxldCBzX2xhdGVuY3kgPSAnMTIwbXMnO1xuXG5cdGxldCBzX2hlaWdodCA9ICcnO1xuXHRsZXQgeHRfd2hlbiA9IDA7XG5cdGxldCB4dF9hdmdfYmxvY2tfdGltZSA9IDA7XG5cblx0bGV0IHNfbmV0d29ya19zdGF0dXMgPSAnTG9hZGluZyc7XG5cdGxldCBwX3Byb3ZpZGVyID0gJyc7XG5cdGxldCBzaV9jaGFpbiA9ICcnO1xuXG5cdGxldCBzX2dycGN3X3N0YXR1cyA9ICcnO1xuXHRsZXQgc19ycGNfc3RhdHVzID0gJyc7XG5cblxuXHQvLyB3aGVuIHRoZSBuZXR3b3JrIGlzIGNoYW5nZWRcblx0JDogaWYoJHl3X25ldHdvcmspIHtcblx0XHRzX2hlaWdodCA9ICdbLi4uXSc7XG5cdFx0eHRfd2hlbiA9IDA7XG5cdFx0eHRfYXZnX2Jsb2NrX3RpbWUgPSAwO1xuXHRcdHNfbmV0d29ya19zdGF0dXMgPSAnQ29ubmVjdGluZyc7XG5cdFx0cF9wcm92aWRlciA9IG5ldyBVUkwoJHl3X25ldHdvcmsuZ3JwY1dlYlVybCkuaG9zdDtcblx0XHRzaV9jaGFpbiA9ICcnO1xuXHR9XG5cblx0Z2xvYmFsX3JlY2VpdmUoe1xuXHRcdGJsb2NrSW5mbyhnX2luZm8pIHtcblx0XHRcdGlmKCR5d19jaGFpbl9yZWYgPT09IGdfaW5mby5jaGFpbikge1xuXHRcdFx0XHRzX25ldHdvcmtfc3RhdHVzID0gJ09ubGluZSc7XG5cdFx0XHRcdHNpX2NoYWluID0gZ19pbmZvLmhlYWRlci5jaGFpbl9pZCBhcyBzdHJpbmc7XG5cblx0XHRcdFx0c19oZWlnaHQgPSBnX2luZm8uaGVhZGVyLmhlaWdodCBhcyBzdHJpbmc7XG5cdFx0XHRcdHh0X3doZW4gPSBEYXRlLm5vdygpO1xuXG5cdFx0XHRcdGNvbnN0IGFfcmVjZW50cyA9IGdfaW5mby5yZWNlbnRzO1xuXHRcdFx0XHRpZihhX3JlY2VudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdGNvbnN0IGFfZ2FwczogbnVtYmVyW10gPSBbXTtcblx0XHRcdFx0XHRmb3IobGV0IGlfZWFjaD0xOyBpX2VhY2g8YV9yZWNlbnRzLmxlbmd0aDsgaV9lYWNoKyspIHtcblx0XHRcdFx0XHRcdGFfZ2Fwcy5wdXNoKGFfcmVjZW50c1tpX2VhY2hdIC0gYV9yZWNlbnRzW2lfZWFjaC0xXSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0eHRfYXZnX2Jsb2NrX3RpbWUgPSBhX2dhcHMucmVkdWNlKChjX291dCwgeF92YWx1ZSkgPT4gY19vdXQgKyB4X3ZhbHVlLCAwKSAvIGFfZ2Fwcy5sZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHR9KTtcblxuXHRsZXQgc19sb25nX2FnbyA9ICdbLi4uXSc7XG5cdGNvbnN0IGlfbG9uZ19hZ28gPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuXHRcdGlmKHh0X3doZW4gPiAwKSB7XG5cdFx0XHRjb25zdCB4dF9hZ28gPSBEYXRlLm5vdygpIC0geHRfd2hlbjtcblx0XHRcdHNfbG9uZ19hZ28gPSBgJHtNYXRoLnJvdW5kKHh0X2FnbyAvIDFlMyl9IHNlY29uZHMgYWdvYDtcblx0XHR9XG5cdH0sIDUwMCk7XG5cdFxuXHRvbkRlc3Ryb3koKCkgPT4ge1xuXHRcdGNsZWFySW50ZXJ2YWwoaV9sb25nX2Fnbyk7XG5cdH0pO1xuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0OnJvb3Qge1xuXHRcdC0tYmFyLXdpZHRoOiA3OC44JTtcblx0XHQtLWFuaW1hdGlvbi1kdXJhdGlvbjogMXM7XG5cdFx0LS1hbmltYXRpb24tZWFzaW5nOiB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdH1cblxuXHRAa2V5ZnJhbWVzIGZhZGUge1xuXHRcdDAlIHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdH1cblxuXHRcdDEwMCUge1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEBrZXlmcmFtZXMgc2xpZGUge1xuXHQvLyBcdDAlIHtcblx0Ly8gXHRcdGxlZnQ6IGNhbGMoMCUgLSB2YXIoLS1iYXItd2lkdGgpKTtcblx0Ly8gXHR9XG5cblx0Ly8gXHQxMDAlIHtcblx0Ly8gXHRcdGxlZnQ6IDAlO1xuXHQvLyBcdH1cblx0Ly8gfVx0XG5cblx0QGtleWZyYW1lcyBvcGFjaXR5IHtcblx0XHQwJSB7XG5cdFx0XHRvcGFjaXR5OiAwO1xuXHRcdH1cblxuXHRcdDEwMCUge1xuXHRcdFx0b3BhY2l0eTogMTtcblx0XHR9XG5cdH1cblxuXG5cdEBrZXlmcmFtZXMgb2Zmc2NyZWVuIHtcblx0XHQwJSB7XG5cdFx0XHR0b3A6IDA7XG5cdFx0fVxuXG5cdFx0MTAwJSB7XG5cdFx0XHR0b3A6IHZhcigtLWFwcC13aW5kb3ctaGVpZ2h0KTtcblx0XHR9XG5cdH1cblxuXHQuYWJzb2x1dGUoQGRpbXM6ICcnKSB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXG5cdFx0d2lkdGg6IGlmKCcnID0gQGRpbXMsIHZhcigtLWFwcC13aW5kb3ctd2lkdGgpLCBAZGltcyk7XG5cdFx0aGVpZ2h0OiBpZignJyA9IEBkaW1zLCB2YXIoLS1hcHAtd2luZG93LWhlaWdodCksIEBkaW1zKTtcblx0fVxuXG5cdC52ZW5kb3ItbWVudSB7XG5cdFx0LS1pdGVtLXBhZGRpbmc6IDMwcHg7XG5cblx0XHQuYWJzb2x1dGUoKTtcblx0XHQuZm9udChyZWd1bGFyKTtcblx0XHR6LWluZGV4OiAxMDAxO1xuXHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHRcdC8vIGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ibGFjayk7XG5cblx0XHQ+LmJhY2tkcm9wIHtcblx0XHRcdC5hYnNvbHV0ZSgxMDAlKTtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcblx0XHRcdHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgdmFyKC0tYW5pbWF0aW9uLWR1cmF0aW9uKSB2YXIoLS1lYXNlLW91dC1leHBvKTtcblx0XHR9XG5cblx0XHQ+LmJhciB7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHR3aWR0aDogdmFyKC0tYmFyLXdpZHRoKTtcblx0XHRcdGhlaWdodDogMTAwJTtcblx0XHRcdC8vIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0bGVmdDogMCU7XG5cdFx0XHRvcGFjaXR5OiAxO1xuXHRcdFx0dHJhbnNpdGlvbjogbGVmdCB2YXIoLS1hbmltYXRpb24tZHVyYXRpb24pIHZhcigtLWFuaW1hdGlvbi1lYXNpbmcpLFxuXHRcdFx0XHRvcGFjaXR5IGNhbGModmFyKC0tYW5pbWF0aW9uLWR1cmF0aW9uKSAvIDMpIGVhc2Utb3V0O1xuXG5cdFx0XHQ+Lm1lbnUge1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWV2ZW5seTtcblx0XHRcdFx0aGVpZ2h0OiAxMDAlO1xuXG5cdFx0XHRcdHVsIHtcblx0XHRcdFx0XHRtYXJnaW46IDA7XG5cdFx0XHRcdFx0cGFkZGluZzogMDtcblxuXHRcdFx0XHRcdD5saSB7XG5cdFx0XHRcdFx0XHRsaXN0LXN0eWxlOiBub25lO1xuXHRcdFx0XHRcdFx0cGFkZGluZzogMTNweCAwO1xuXHRcdFx0XHRcdFx0cGFkZGluZy1sZWZ0OiB2YXIoLS1pdGVtLXBhZGRpbmcpO1xuXHRcdFx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXG5cdFx0XHRcdFx0XHQ+KiB7XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdD4uaWNvbiB7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdFx0XHRcdFx0cGFkZGluZzogMDtcblx0XHRcdFx0XHRcdFx0cGFkZGluZy1yaWdodDogY2FsYyh2YXIoLS1pdGVtLXBhZGRpbmcpIC8gMik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ji5pdGVtcyB7XG5cdFx0XHRcdFx0XHQuaWNvbiB7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmxhY2spO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCYuc2Vzc2lvbiB7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiBjYWxjKHZhcigtLWl0ZW0tcGFkZGluZykgLyAyKSAwO1xuXG5cdFx0XHRcdFx0XHQuaWNvbiB7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4ubWFpbiB7XG5cdFx0XHRcdFx0ZmxleDogMTtcblx0XHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuXHRcdFx0XHRcdC8vIHBhZGRpbmctdG9wOiAxNSU7XG5cblx0XHRcdFx0XHRwYWRkaW5nLWxlZnQ6IDFlbTtcblxuXHRcdFx0XHRcdD4qIHtcblx0XHRcdFx0XHRcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdD4uYXBwIHtcblx0XHRcdFx0XHRcdC8vIG1hcmdpbi10b3A6IDI1JTtcblx0XHRcdFx0XHRcdG1hcmdpbi10b3A6IDEwcHg7XG5cdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdFx0LmZvbnQodGlueSk7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiAxNnB4IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pi5pbmZvIHtcblx0XHRcdFx0XHRcdHBhZGRpbmc6IDE2cHggMDtcblxuXHRcdFx0XHRcdFx0Lm5hbWUge1xuXHRcdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LnZhbHVlIHtcblx0XHRcdFx0XHRcdFx0cGFkZGluZy10b3A6IDRweDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LmJvdHRvbSB7XG5cdFx0XHRcdFx0ZmxleDogMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCYuY29sbGFwc2VkIHtcblx0XHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0YW5pbWF0aW9uOiBvZmZzY3JlZW4gdmFyKC0tYW5pbWF0aW9uLWR1cmF0aW9uKSBzdGVwcygyLCBqdW1wLW5vbmUpIGJvdGg7XG5cdFx0XHRcblx0XHRcdD4uYmFja2Ryb3Age1xuXHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuXHRcdFx0fVxuXG5cdFx0XHQ+LmJhciB7XG5cdFx0XHRcdGxlZnQ6IGNhbGMoMCUgLSB2YXIoLS1iYXItd2lkdGgpKTtcblx0XHRcdFx0b3BhY2l0eTogMC4xO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0aHIge1xuXHRcdFx0bWFyZ2luOiAwIHZhcigtLWl0ZW0tcGFkZGluZyk7XG5cdFx0XHRib3JkZXI6IG5vbmU7XG5cdFx0XHRib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHR9XG5cblx0XHQvLyAuY2xvc2UtZGFyayB7XG5cdFx0Ly8gXHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0Ly8gXHR0b3A6IDA7XG5cdFx0Ly8gXHRyaWdodDogMDtcblx0XHQvLyBcdG1hcmdpbjogMTBweDtcblx0XHQvLyBcdHBhZGRpbmc6IDEycHg7XG5cdFx0Ly8gXHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0Ly8gXHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0Ly8gXHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJsYWNrKTtcblxuXHRcdC8vIFx0b3V0bGluZTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0Ly8gXHRib3JkZXItcmFkaXVzOiAwcHg7XG5cdFx0Ly8gXHR0cmFuc2l0aW9uOiBib3JkZXItcmFkaXVzIDY1MG1zIHZhcigtLWVhc2Utb3V0LWV4cG8pO1xuXHRcdC8vIFx0cG9pbnRlci1ldmVudHM6IGFsbDtcblxuXHRcdC8vIFx0Jjo6YmVmb3JlIHtcblx0XHQvLyBcdFx0LS1vY2NsdXNpb24tdGhpY2tuZXNzOiA0cHg7XG5cblx0XHQvLyBcdFx0Y29udGVudDogJyc7XG5cdFx0Ly8gXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHQvLyBcdFx0dG9wOiBjYWxjKHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIC8gMik7XG5cdFx0Ly8gXHRcdGxlZnQ6IGNhbGModmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgLyAyKTtcblx0XHQvLyBcdFx0d2lkdGg6IGNhbGMoMTAwJSAtIHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpKTtcblx0XHQvLyBcdFx0aGVpZ2h0OiBjYWxjKDEwMCUgLSB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSk7XG5cdFx0Ly8gXHRcdG91dGxpbmU6IHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdC8vIFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdC8vIFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHQvLyBcdH1cblxuXHRcdC8vIFx0Jjpob3ZlciB7XG5cdFx0Ly8gXHRcdGJvcmRlci1yYWRpdXM6IDIycHg7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gfVxuXG5cdFx0LmNsb3NlIHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdHJpZ2h0OiAwO1xuXHRcdFx0bWFyZ2luOiAxMHB4O1xuXHRcdFx0cGFkZGluZzogMTJweDtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cblx0XHRcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0Ym9yZGVyLXJhZGl1czogMHB4O1xuXHRcdFx0dHJhbnNpdGlvbjogYm9yZGVyLXJhZGl1cyA2NTBtcyB2YXIoLS1lYXNlLW91dC1leHBvKTtcblx0XHRcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cblx0XHRcdCY6OmJlZm9yZSB7XG5cdFx0XHRcdC0tb2NjbHVzaW9uLXRoaWNrbmVzczogNHB4O1xuXG5cdFx0XHRcdGNvbnRlbnQ6ICcnO1xuXHRcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdHRvcDogY2FsYyh2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSAvIDIpO1xuXHRcdFx0XHRsZWZ0OiBjYWxjKHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIC8gMik7XG5cdFx0XHRcdHdpZHRoOiBjYWxjKDEwMCUgLSB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSk7XG5cdFx0XHRcdGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykpO1xuXHRcdFx0XHRvdXRsaW5lOiB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xuXHRcdFx0fVxuXG5cdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0Ym9yZGVyLXJhZGl1czogMjJweDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXZcblx0Y2xhc3M9XCJ2ZW5kb3ItbWVudVwiXG5cdGNsYXNzOmNvbGxhcHNlZD17ISR5d19tZW51X3ZlbmRvcn1cbj5cblx0PGRpdiBjbGFzcz1cImJhY2tkcm9wXCJcblx0XHRvbjpjbGljaz17KCkgPT4gJHl3X21lbnVfdmVuZG9yID0gZmFsc2V9XG5cdC8+XG5cblx0PGRpdiBjbGFzcz1cImJhclwiPlxuXHRcdDxkaXYgY2xhc3M9XCJjbG9zZSBpY29uXCIgb246Y2xpY2s9eygpID0+ICR5d19tZW51X3ZlbmRvciA9IGZhbHNlfT5cblx0XHRcdDwhLS0gPGltZyBhbHQ9XCJDbG9zZSBpY29uXCIgc3JjPVwiL2Fzc2V0cy9tZWRpYS9uYXYvY2xvc2Uuc3ZnXCI+IC0tPlxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cIm1lbnVcIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJtYWluXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJhcHBcIj5cblx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0PCEtLSB7QGh0bWwgU1hfVElUTEV9IC0tPlxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRcdHZ7U0lfVkVSU0lPTn1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PCEtLSA8ZGl2PlxuXHRcdFx0XHRcdEN1cnJlbnQgZEFwcFxuXHRcdFx0XHQ8L2Rpdj4gLS0+XG5cblx0XHRcdFx0PCEtLSA8ZGl2PlxuXHRcdFx0XHRcdGRvbWFpbjogc2VjcmV0c3dhcC5pb1xuXHRcdFx0XHQ8L2Rpdj4gLS0+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0TmV0d29yayBTdGF0dXNcblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0e3NfbmV0d29ya19zdGF0dXN9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdENoYWluIElkXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsdWVcIj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiZm9udC1mYW1pbHlfbW9ub1wiPlxuXHRcdFx0XHRcdFx0XHR7c2lfY2hhaW59XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdEN1cnJlbnQgUHJvdmlkZXJcblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJmb250LWZhbWlseV9tb25vXCI+XG5cdFx0XHRcdFx0XHRcdHtwX3Byb3ZpZGVyfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHRDdXJyZW50IEJsb2NrIEhlaWdodFxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbHVlXCI+XG5cdFx0XHRcdFx0XHQje3NfaGVpZ2h0fVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHRBdmVyYWdlIEJsb2NrIFRpbWVcblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0eyNpZiB4dF9hdmdfYmxvY2tfdGltZX1cblx0XHRcdFx0XHRcdFx0eyh4dF9hdmdfYmxvY2tfdGltZSAvIDFlMykudG9GaXhlZCgyKX0gc2Vjb25kc1xuXHRcdFx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdFx0XHRbLi4uXVxuXHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0TGFzdCBCbG9jayBTZWVuXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsdWVcIj5cblx0XHRcdFx0XHRcdHtzX2xvbmdfYWdvfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8IS0tIDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdE5leHQgYmxvY2sgaW5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0IHNlY29uZHNcblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+IC0tPlxuXG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj5cbiIsImltcG9ydCB0eXBlIHsgUGxhaW5PYmplY3QgfSBmcm9tICcjL21ldGEvYmVsdCc7XG5pbXBvcnQgdHlwZSB7IFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvciB9IGZyb20gJyMvbWV0YS9zdmVsdGUnO1xuaW1wb3J0IHtcblx0RGljdCwgb2JqZWN0c19taWdodF9kaWZmZXIsIG9kZSwgUHJvbWlzYWJsZSxcbn0gZnJvbSAnIy91dGlsL2JlbHQnO1xuaW1wb3J0IHsgZGQgfSBmcm9tICcjL3V0aWwvZG9tJztcbmltcG9ydCB0eXBlIHsgSnVtcENvbmZpZywgUG9wQ29uZmlnLCBUaHJlYWQgfSBmcm9tICcuL3RocmVhZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZUNvbmZpZzxcblx0aF9wcm9wcyBleHRlbmRzIERpY3Q8dW5rbm93bj49RGljdDx1bmtub3duPixcblx0ZGNfY3JlYXRvciBleHRlbmRzIFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvcjxoX3Byb3BzPj1QYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3I8aF9wcm9wcz4sXG4+IHtcblx0Y3JlYXRvcjogZGNfY3JlYXRvcjtcblx0cHJvcHM/OiBoX3Byb3BzO1xuXHRjb250ZXh0PzogUGxhaW5PYmplY3Q7XG5cdGV2ZW50cz86IERpY3Q8KGRfZXZlbnQ6IEN1c3RvbUV2ZW50PHVua25vd24+KSA9PiBQcm9taXNhYmxlPHZvaWQ+Pjtcblx0cGF0aD86IHN0cmluZztcblx0cGF0dGVybj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdlRXZlbnRDb25maWcge1xuXHQvKipcblx0ICogRmlyZWQgYW55dGltZSBhIHBhZ2UgbG9zZXMgZm9jdXMgKGluY2x1ZGluZyBvbiB0aHJlYWQgc3dpdGNoKVxuXHQgKi9cblx0Ymx1cj8oKTogUHJvbWlzYWJsZTx2b2lkPjtcblxuXHQvKipcblx0ICogRmlyZWQgYW55dGltZSBhIHBhZ2UgcmVjZWl2ZXMgZm9jdXMgKGluY2x1ZGluZyBvbiB0aHJlYWQgc3dpdGNoKVxuXHQgKi9cblx0Zm9jdXM/KCk6IFByb21pc2FibGU8dm9pZD47XG5cblx0LyoqXG5cdCAqIEZpcmVkIHdoZW4gYSBwcmV2aW91c2x5IGV4aXN0aW5nIHBhZ2UgaXMgcmVzdG9yZWQgZnJvbSBoaXN0b3J5IChlLmcuLCB2aWEgcG9wKVxuXHQgKi9cblx0cmVzdG9yZT8oKTogUHJvbWlzYWJsZTx2b2lkPjtcbn1cblxudHlwZSBQYWdlRXZlbnRJZCA9IGtleW9mIFBhZ2VFdmVudENvbmZpZztcblxuZXhwb3J0IGNsYXNzIFBhZ2U8XG5cdGhfcHJvcHMgZXh0ZW5kcyBEaWN0PHVua25vd24+PURpY3Q8dW5rbm93bj4sXG5cdGRjX2NyZWF0b3IgZXh0ZW5kcyBQYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3I8aF9wcm9wcz49UGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yPGhfcHJvcHM+LFxuXHR5Y19jb21wb25lbnQgZXh0ZW5kcyBJbnN0YW5jZVR5cGU8ZGNfY3JlYXRvcj49SW5zdGFuY2VUeXBlPGRjX2NyZWF0b3I+LFxuPiB7XG5cdHByb3RlY3RlZCBfZGNfY3JlYXRvcjogZGNfY3JlYXRvcjtcblx0cHJvdGVjdGVkIF95Y19jb21wb25lbnQ6IHljX2NvbXBvbmVudDtcblx0cHJvdGVjdGVkIF9oX3Byb3BzOiBoX3Byb3BzO1xuXHRwcm90ZWN0ZWQgX2hfY29udGV4dDogUGxhaW5PYmplY3Q7XG5cdHByb3RlY3RlZCBfZG1fcGFnZTogSFRNTEVsZW1lbnQ7XG5cblx0cHJvdGVjdGVkIF9zaV9wYWdlOiBzdHJpbmc7XG5cdHByb3RlY3RlZCBfaF9ldmVudHM6IFBhcnRpYWw8UmVjb3JkPFBhZ2VFdmVudElkLCBBcnJheTwoLi4uYV9hcmdzOiBhbnlbXSkgPT4gUHJvbWlzYWJsZTx2b2lkPj4+PiA9IHt9O1xuXG5cdHByb3RlY3RlZCBfc3JfcGF0aDogc3RyaW5nO1xuXHRwcm90ZWN0ZWQgX3N4X3BhdHRlcm46IHN0cmluZztcblxuXHRjb25zdHJ1Y3RvcihnY19wYWdlOiBQYWdlQ29uZmlnPGhfcHJvcHMsIGRjX2NyZWF0b3I+LCBwcm90ZWN0ZWQgX2t0X3BhcmVudDogVGhyZWFkKSB7XG5cdFx0KHtcblx0XHRcdGNyZWF0b3I6IHRoaXMuX2RjX2NyZWF0b3IsXG5cdFx0XHRwcm9wczogdGhpcy5faF9wcm9wcz17fSBhcyBoX3Byb3BzLFxuXHRcdFx0Y29udGV4dDogdGhpcy5faF9jb250ZXh0PXt9IGFzIFBsYWluT2JqZWN0LFxuXHRcdFx0Ly8gcGF0aDogdGhpcy5fc3JfcGF0aD0nJyxcblx0XHRcdC8vIHBhdHRlcm46IHRoaXMuX3N4X3BhdHRlcm49JycsXG5cdFx0fSA9IGdjX3BhZ2UgYXMgUmVxdWlyZWQ8dHlwZW9mIGdjX3BhZ2U+KTtcblxuXHRcdC8vIHNldCB1bmlxdWUgcGFnZSBpZFxuXHRcdHRoaXMuX3NpX3BhZ2UgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuXG5cdFx0Ly8gY3JlYXRlIGJ1ZmZlciBlbGVtZW50XG5cdFx0Y29uc3QgZG1fYnVmZmVyID0gZGQoJ2RpdicpO1xuXG5cdFx0Y29uc3QgaG1fY29udGV4dCA9IG5ldyBNYXAob2RlKHtcblx0XHRcdC4uLnRoaXMuX2hfY29udGV4dCxcblx0XHRcdHBhZ2U6IHRoaXMsXG5cdFx0fSkpO1xuXG5cdFx0Ly8gc3Bhd24gY29tcG9uZW50XG5cdFx0dGhpcy5feWNfY29tcG9uZW50ID0gbmV3IHRoaXMuX2RjX2NyZWF0b3Ioe1xuXHRcdFx0dGFyZ2V0OiBkbV9idWZmZXIsXG5cdFx0XHRwcm9wczoge1xuXHRcdFx0XHQuLi50aGlzLl9oX3Byb3BzLFxuXHRcdFx0XHRrX3BhZ2U6IHRoaXMsXG5cdFx0XHR9LFxuXHRcdFx0Y29udGV4dDogaG1fY29udGV4dCxcblx0XHR9KSBhcyB5Y19jb21wb25lbnQ7XG5cblx0XHQvLyBiaW5kIGV2ZW50c1xuXHRcdGlmKGdjX3BhZ2UuZXZlbnRzKSB7XG5cdFx0XHRmb3IoY29uc3QgW3NpX2V2ZW50LCBmX2xpc3RlbmVyXSBvZiBvZGUoZ2NfcGFnZS5ldmVudHMpKSB7XG5cdFx0XHRcdHRoaXMuX3ljX2NvbXBvbmVudC4kb24oc2lfZXZlbnQsIGZfbGlzdGVuZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGZldGNoIGRvbVxuXHRcdGNvbnN0IGRtX3N0YXRlID0gZG1fYnVmZmVyLmZpcnN0RWxlbWVudENoaWxkIGFzIG51bGwgfCBIVE1MRWxlbWVudDtcblx0XHRpZighZG1fc3RhdGUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgTm8gRE9NIGVsZW1lbnQgd2FzIGNyZWF0ZWQgZHVyaW5nIHBhZ2UgY29tcG9uZW50IHNwYXduaW5nIHVzaW5nOiAke0pTT04uc3RyaW5naWZ5KGdjX3BhZ2UpfWApO1xuXHRcdH1cblxuXHRcdC8vIHNldCBmaWVsZFxuXHRcdHRoaXMuX2RtX3BhZ2UgPSBkbV9zdGF0ZTtcblx0fVxuXG5cdGdldCBpZCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9zaV9wYWdlO1xuXHR9XG5cblx0Z2V0IGluZGV4KCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmhpc3RvcnkubGVuZ3RoO1xuXHR9XG5cblx0Z2V0IHRocmVhZCgpOiBUaHJlYWQge1xuXHRcdHJldHVybiB0aGlzLl9rdF9wYXJlbnQ7XG5cdH1cblxuXHRnZXQgY3JlYXRvcigpOiBkY19jcmVhdG9yIHtcblx0XHRyZXR1cm4gdGhpcy5fZGNfY3JlYXRvcjtcblx0fVxuXG5cdGdldCBjb21wb25lbnQoKTogeWNfY29tcG9uZW50IHtcblx0XHRyZXR1cm4gdGhpcy5feWNfY29tcG9uZW50O1xuXHR9XG5cblx0Z2V0IHByb3BzKCk6IGhfcHJvcHMge1xuXHRcdHJldHVybiB0aGlzLl9oX3Byb3BzO1xuXHR9XG5cblx0Z2V0IGRvbSgpOiBIVE1MRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2RtX3BhZ2U7XG5cdH1cblxuXHRlcXVpdmFsZW50KHdfb3RoZXI6IFBhZ2UgfCBQYWdlQ29uZmlnKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHdfb3RoZXIuY3JlYXRvciA9PT0gdGhpcy5jcmVhdG9yXG5cdFx0XHQmJiAhb2JqZWN0c19taWdodF9kaWZmZXIod19vdGhlci5wcm9wcyB8fCB7fSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRwZWFrKCk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLl9rdF9wYXJlbnQucGVhaygpO1xuXHR9XG5cblx0cHVzaChnY19wYWdlOiBQYWdlQ29uZmlnKTogUGFnZSB7XG5cdFx0cmV0dXJuIHRoaXMuX2t0X3BhcmVudC5wdXNoKGdjX3BhZ2UsIHRoaXMpO1xuXHR9XG5cblx0cG9wKGdjX3BvcD86IFBvcENvbmZpZyk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLl9rdF9wYXJlbnQucG9wKGdjX3BvcCB8fCB7fSwgdGhpcyk7XG5cdH1cblxuXHRqdW1wKGdjX3BhZ2U6IFBhZ2VDb25maWcsIGdjX2p1bXA/OiBKdW1wQ29uZmlnKTogUGFnZSB7XG5cdFx0cmV0dXJuIHRoaXMuX2t0X3BhcmVudC5qdW1wKGdjX3BhZ2UsIGdjX2p1bXAgfHwge30sIHRoaXMpO1xuXHR9XG5cblx0b24oaF9ldmVudHM6IFBhZ2VFdmVudENvbmZpZyk6IHZvaWQge1xuXHRcdGZvcihjb25zdCBbc2lfZXZlbnQsIGZfbGlzdGVuZXJdIG9mIG9kZShoX2V2ZW50cykpIHtcblx0XHRcdGlmKGZfbGlzdGVuZXIpIHtcblx0XHRcdFx0Y29uc3QgYV9saXN0ZW5lcnMgPSB0aGlzLl9oX2V2ZW50c1tzaV9ldmVudF0gPSB0aGlzLl9oX2V2ZW50c1tzaV9ldmVudF0gfHwgW107XG5cdFx0XHRcdGFfbGlzdGVuZXJzLnB1c2goZl9saXN0ZW5lcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgZmlyZShzaV9ldmVudDogUGFnZUV2ZW50SWQsIGFfYXJncz86IGFueVtdKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgYV9saXN0ZW5lcnMgPSB0aGlzLl9oX2V2ZW50c1tzaV9ldmVudF07XG5cblx0XHRpZihhX2xpc3RlbmVycykge1xuXHRcdFx0YXdhaXQgUHJvbWlzZS5hbGwoYV9saXN0ZW5lcnMubWFwKGYgPT4gZiguLi5hX2FyZ3MgfHwgW10gYXMgY29uc3QpKSk7XG5cdFx0fVxuXHR9XG5cblx0ZGVzdHJveSgpOiB2b2lkIHtcblx0XHR0aGlzLl95Y19jb21wb25lbnQuJGRlc3Ryb3koKTtcblx0fVxuXG5cdHJlc2V0KCk6IHZvaWQge1xuXHRcdHRoaXMuX2t0X3BhcmVudC5yZXNldCgpO1xuXHR9XG59XG4iLCJpbXBvcnQgdHlwZSB7IFBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvciB9IGZyb20gJyMvbWV0YS9zdmVsdGUnO1xuaW1wb3J0IHsgRGljdCwgRl9OT09QIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuaW1wb3J0IHsgZGQgfSBmcm9tICcjL3V0aWwvZG9tJztcbmltcG9ydCB0eXBlIHtUaHJlYWRJZH0gZnJvbSAnLi4vZGVmJztcbmltcG9ydCB7IE5hdmlnYXRvciwgc2V0X3ppbmRleF9yZWxhdGl2ZWx5IH0gZnJvbSAnLi9uYXZpZ2F0b3InO1xuaW1wb3J0IHtQYWdlLCBQYWdlQ29uZmlnfSBmcm9tICcuL3BhZ2UnO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzZXRDb25maWcge1xuXHRrZWVwVG9wPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb3BDb25maWcge1xuXHRieXBhc3NBbmltYXRpb24/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEp1bXBDb25maWcge1xuXHRmb3JjZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBUaHJlYWQge1xuXHRwcm90ZWN0ZWQgX2RtX3RocmVhZDogSFRNTERpdkVsZW1lbnQ7XG5cblx0cHJvdGVjdGVkIF9hX2hpc3Rvcnk6IFBhZ2VbXSA9IFtdO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfc2lfdGhyZWFkOiBUaHJlYWRJZCwgcHJvdGVjdGVkIF9nY19kZWZhdWx0OiBQYWdlQ29uZmlnLCBwcm90ZWN0ZWQgX2tfbmF2aWdhdG9yOiBOYXZpZ2F0b3IpIHtcblx0XHR0aGlzLl9kbV90aHJlYWQgPSBkZCgnZGl2Jywge1xuXHRcdFx0J2NsYXNzJzogJ3RocmVhZCcsXG5cdFx0XHQnZGF0YS10aHJlYWQtaWQnOiB0aGlzLl9zaV90aHJlYWQsXG5cdFx0XHQnc3R5bGUnOiAnei1pbmRleDogMTAwOycsXG5cdFx0fSk7XG5cdH1cblxuXHRnZXQgaWQoKTogVGhyZWFkSWQge1xuXHRcdHJldHVybiB0aGlzLl9zaV90aHJlYWQ7XG5cdH1cblxuXHRnZXQgZGVmYXVsdCgpOiBQYWdlQ29uZmlnIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2NfZGVmYXVsdDtcblx0fVxuXG5cdGdldCBoaXN0b3J5KCk6IFBhZ2VbXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FfaGlzdG9yeTtcblx0fVxuXG5cdGdldCBwYWdlKCk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLl9hX2hpc3RvcnlbMF07XG5cdH1cblxuXHRnZXQgZG9tKCk6IEhUTUxFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fZG1fdGhyZWFkO1xuXHR9XG5cblx0Ly8gcGxhY2UgcGFnZVxuXHRwcm90ZWN0ZWQgX3BsYWNlKGdjX3BhZ2U6IFBhZ2VDb25maWcpOiBQYWdlIHtcblx0XHQvLyBjcmVhdGUgbmV3IHBhZ2Vcblx0XHRjb25zdCBrcF9uZXcgPSBuZXcgUGFnZSh7XG5cdFx0XHQuLi5nY19wYWdlLFxuXHRcdFx0Y29udGV4dDoge1xuXHRcdFx0XHQuLi50aGlzLl9rX25hdmlnYXRvci5jb250ZXh0LFxuXHRcdFx0XHQuLi5nY19wYWdlLmNvbnRleHQsXG5cdFx0XHR9LFxuXHRcdH0sIHRoaXMpO1xuXG5cdFx0Ly8gYXBwZW5kIHRvIGRvbVxuXHRcdHRoaXMuX2RtX3RocmVhZC5hcHBlbmRDaGlsZChrcF9uZXcuZG9tKTtcblxuXHRcdC8vIHB1c2ggc3RhdGUgdG8gZnJvbnQgb2Ygc3RhY2tcblx0XHR0aGlzLl9hX2hpc3RvcnkudW5zaGlmdChrcF9uZXcpO1xuXG5cdFx0Ly8gcmV0dXJuIG5ldyBwYWdlXG5cdFx0cmV0dXJuIGtwX25ldztcblx0fVxuXG5cblx0cmVzZXQoZ2NfcGFnZTogUGFnZUNvbmZpZz10aGlzLmRlZmF1bHQsIGdjX3Jlc2V0PzogUmVzZXRDb25maWcpOiBQYWdlIHtcblx0XHQvLyBcblx0XHRjb25zdCB7XG5cdFx0XHRrZWVwVG9wOiBiX2tlZXBfdG9wLFxuXHRcdH0gPSBnY19yZXNldCB8fCB7fTtcblxuXHRcdC8vIHJlZiBoaXN0b3J5XG5cdFx0Y29uc3QgYV9oaXN0b3J5ID0gdGhpcy5fYV9oaXN0b3J5O1xuXG5cdFx0Ly8gLy8ga2VlcCB0b3AgaXMgZW5hYmxlZDsgZ3JhYiBzcmMgc3R5bGVcblx0XHQvLyBjb25zdCBkX3N0eWxlID0gYl9rZWVwX3RvcD8gYV9oaXN0b3J5WzBdLmRvbS5zdHlsZTogbnVsbDtcblxuXHRcdC8vIGRyb3AgYWxsIHN0YWxlIHN0YXRlcyBpbiBoaXN0b3J5XG5cdFx0Zm9yKGxldCBpX3N0YXRlPWJfa2VlcF90b3A/IDE6IDA7IGlfc3RhdGU8YV9oaXN0b3J5Lmxlbmd0aDsgaV9zdGF0ZSsrKSB7XG5cdFx0XHRhX2hpc3RvcnlbaV9zdGF0ZV0uY29tcG9uZW50LiRkZXN0cm95KCk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVzZXQgaGlzdG9yeVxuXHRcdGFfaGlzdG9yeS5sZW5ndGggPSAwO1xuXG5cdFx0Ly8gcGxhY2UgbmV3IHBhZ2Vcblx0XHRjb25zdCBrcF9uZXcgPSB0aGlzLl9wbGFjZShnY19wYWdlKTtcblxuXHRcdC8vIGZpcmUgY2hhbmdlIG9uIG5ldyBwYWdlXG5cdFx0dm9pZCB0aGlzLl9rX25hdmlnYXRvci5hZnRlcl9yZXNldCh0aGlzLCBrcF9uZXcsIGdjX3Jlc2V0IHx8IHt9KTtcblxuXHRcdC8vIC8vIGtlZXAgdG9wIGlzIGVuYWJsZWRcblx0XHQvLyBpZihkX3N0eWxlKSB7XG5cdFx0Ly8gXHQvLyBzZXQgbmV3IHNjcmVlbiBiZWxvd1xuXHRcdC8vIFx0a3NfbmV3LmRvbS5zdHlsZS56SW5kZXggPSAoKCtkX3N0eWxlLnpJbmRleCkrMSkrJyc7XG5cdFx0Ly8gfVxuXG5cdFx0cmV0dXJuIGtwX25ldztcblx0fVxuXG5cdHBlYWsoKTogUGFnZSB8IHVuZGVmaW5lZCB7XG5cdFx0cmV0dXJuIHRoaXMuX2FfaGlzdG9yeVsxXTtcblx0fVxuXG5cdHB1c2goZ2NfcGFnZTogUGFnZUNvbmZpZywga3Bfc3JjOiBQYWdlKTogUGFnZSB7XG5cdFx0Ly8gY2FsbGVyIGlzIHByZXNlbnQgYnV0IGl0IGlzIG5vdCB0aGUgYWN0aXZlIHBhZ2Vcblx0XHRpZihrcF9zcmMgIT09IHRoaXMucGFnZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcmV2ZW50ZWQgaW5hY3RpdmUgcGFnZSBmcm9tIHB1c2hpbmcgbmV3IHNjcmVlbicpO1xuXHRcdH1cblxuXHRcdC8vIGdldCBhcHByb3ZhbCBmcm9tIHBhcmVudFxuXHRcdGlmKCF0aGlzLl9rX25hdmlnYXRvci5iZWZvcmVfcHVzaChnY19wYWdlLCBrcF9zcmMsIHRoaXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZXZlbnRlZCBpbmFjdGl2ZSB0aHJlYWQgZnJvbSBwdXNoaW5nIG5ldyBzY3JlZW4nKTtcblx0XHR9XG5cblx0XHQvLyBwbGFjZSBwYWdlXG5cdFx0Y29uc3Qga3BfbmV3ID0gdGhpcy5fcGxhY2UoZ2NfcGFnZSk7XG5cblx0XHQvLyBjYWxsIGhvb2tzIG9uIHBhcmVudFxuXHRcdHZvaWQgdGhpcy5fa19uYXZpZ2F0b3IuYWZ0ZXJfcHVzaCh0aGlzLCBrcF9zcmMsIGtwX25ldyk7XG5cblx0XHQvLyByZXR1cm4gbmV3IHBhZ2Vcblx0XHRyZXR1cm4ga3BfbmV3O1xuXHR9XG5cblx0cG9wKGdjX3BvcDogUG9wQ29uZmlnLCBrcF9zcmM6IFBhZ2UpOiBQYWdlIHtcblx0XHQvLyBjYWxsZXIgaXMgcHJlc2VudCBidXQgaXQgaXMgbm90IHRoZSBhY3RpdmUgcGFnZVxuXHRcdGlmKGtwX3NyYyAhPT0gdGhpcy5wYWdlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZXZlbnRlZCBpbmFjdGl2ZSBwYWdlIGZyb20gcG9wcGluZyBhY3RpdmUgc2NyZWVuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gdG9vIHNob3J0XG5cdFx0aWYodGhpcy5fYV9oaXN0b3J5Lmxlbmd0aCA8IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBvcCBlbXB0eSBoaXN0b3J5YCk7XG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IGFwcHJvdmFsIGZyb20gcGFyZW50XG5cdFx0aWYoIXRoaXMuX2tfbmF2aWdhdG9yLmJlZm9yZV9wb3AoZ2NfcG9wLCB0aGlzLl9hX2hpc3RvcnlbMV0sIGtwX3NyYywgdGhpcykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUHJldmVudGVkIGluYWN0aXZlIHRocmVhZCBmcm9tIHBvcHBpbmcgYWN0aXZlIHNjcmVlbicpO1xuXHRcdH1cblxuXHRcdC8vIHNoaWZ0IGhpc3Rvcnlcblx0XHR0aGlzLl9hX2hpc3Rvcnkuc2hpZnQoKTtcblxuXHRcdC8vIGFjcXVpcmUgZGVzdGluYXRpb24gcGFnZVxuXHRcdGNvbnN0IGtwX2RzdCA9IHRoaXMucGFnZTtcblxuXHRcdC8vIGNhbGwgaG9va3Mgb24gcGFyZW50XG5cdFx0dm9pZCB0aGlzLl9rX25hdmlnYXRvci5hZnRlcl9wb3AodGhpcywga3Bfc3JjLCBrcF9kc3QsIGdjX3BvcCk7XG5cblx0XHQvLyByZXR1cm4gZHN0IHBhZ2Vcblx0XHRyZXR1cm4ga3BfZHN0O1xuXHR9XG5cblx0anVtcChnY19wYWdlOiBQYWdlQ29uZmlnLCBnY19qdW1wOiBKdW1wQ29uZmlnLCBrcF9zcmM6IFBhZ2UpOiBQYWdlIHtcblx0XHQvLyBjYWxsZXIgaXMgcHJlc2VudCBidXQgaXQgaXMgbm90IHRoZSBhY3RpdmUgcGFnZVxuXHRcdGlmKGtwX3NyYyAhPT0gdGhpcy5wYWdlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZXZlbnRlZCBpbmFjdGl2ZSBwYWdlIGZyb20ganVtcGluZyB0byBzY3JlZW4nKTtcblx0XHR9XG5cblx0XHQvLyBnZXQgYXBwcm92YWwgZnJvbSBwYXJlbnRcblx0XHRpZighdGhpcy5fa19uYXZpZ2F0b3IuYmVmb3JlX2p1bXAoZ2NfanVtcCwgZ2NfcGFnZSwga3Bfc3JjLCB0aGlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcmV2ZW50ZWQgaW5hY3RpdmUgdGhyZWFkIGZyb20ganVtcGluZyB0byBzY3JlZW4nKTtcblx0XHR9XG5cblx0XHQvLyBub3QgYmVpbmcgZm9yY2VkIGFuZCB0aGUgcHJldmlvdXMgaXRlbSBpbiBoaXN0b3J5IG1hdGNoZXMgdGhlIHRhcmdldFxuXHRcdGNvbnN0IGtwX3ByZXYgPSB0aGlzLl9hX2hpc3RvcnlbMV0gYXMgUGFnZSB8IHVuZGVmaW5lZDtcblx0XHRpZighZ2NfanVtcC5mb3JjZSAmJiBrcF9wcmV2Py5lcXVpdmFsZW50KGdjX3BhZ2UpKSB7XG5cdFx0XHQvLyBkZWZlciB0byBwb3Agb3BlcmF0aW9uXG5cdFx0XHRyZXR1cm4gdGhpcy5wb3Aoe30sIGtwX3NyYyk7XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIG5ldyBwYWdlXG5cdFx0Y29uc3Qga3BfZHN0ID0gbmV3IFBhZ2UoZ2NfcGFnZSwgdGhpcyk7XG5cblx0XHQvLyBkZXN0cm95IGFsbCBjb21wb25lbnRzIGZ1cnRoZXIgYmFjayBpbiB0aGUgc3RhY2tcblx0XHR0aGlzLnJlc2V0KCk7XG5cblx0XHQvLyBtb3ZlIGRlYWRcblx0XHRzZXRfemluZGV4X3JlbGF0aXZlbHkoa3BfZHN0LmRvbSwga3Bfc3JjLmRvbSwgKzEpO1xuXG5cdFx0Ly8gd2FpdCBmb3IgY2FsbCBob29rcyB0byByZXNvbHZlXG5cdFx0dm9pZCB0aGlzLl9rX25hdmlnYXRvci5hZnRlcl9qdW1wKHRoaXMsIGtwX3NyYywga3BfZHN0LCBnY19qdW1wKS50aGVuKCgpID0+IHtcblx0XHRcdC8vIGF0dGVtcHQgdG8gZGVzdHJveSBzcmMgcGFnZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0a3Bfc3JjLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoKGVfZGVzdHJveSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oYEZhaWxlZCB0byBkZXN0cm95IHN0YWxlIGNvbXBvbmVudCBiZWxvbmdpbmcgdG8gcGFnZTogJHtrcF9zcmMuY3JlYXRvci5uYW1lKycnfWApO1xuXG5cdFx0XHRcdC8vIGF0dGVtcHQgdG8gZm9yY2libHkgcmVtb3ZlIHRoZSBkb21cblx0XHRcdFx0a3Bfc3JjLmRvbS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIHJldHVybiBuZXcgcGFnZVxuXHRcdHJldHVybiBrcF9kc3Q7XG5cdH1cblxuXHRoaWRlKCk6IHZvaWQge1xuXHRcdHRoaXMuX2RtX3RocmVhZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHR9XG5cblx0c2hvdygpOiB2b2lkIHtcblx0XHR0aGlzLl9kbV90aHJlYWQuc3R5bGUuZGlzcGxheSA9ICdpbml0aWFsJztcblx0fVxufVxuIiwiaW1wb3J0IHR5cGUgeyBQbGFpbk9iamVjdCB9IGZyb20gJyMvbWV0YS9iZWx0JztcbmltcG9ydCB7IERpY3QsIG9iamVjdHNfbWlnaHRfZGlmZmVyLCBQcm9taXNhYmxlIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuaW1wb3J0IHsgZGQgfSBmcm9tICcjL3V0aWwvZG9tJztcbmltcG9ydCB0eXBlIHsgTWVyZ2UgfSBmcm9tICd0cy10b29sYmVsdC9vdXQvT2JqZWN0L01lcmdlJztcbmltcG9ydCB7IFRocmVhZElkIH0gZnJvbSAnLi4vZGVmJztcbmltcG9ydCB7IFBhZ2UsIFBhZ2VDb25maWcgfSBmcm9tICcuL3BhZ2UnO1xuaW1wb3J0IHsgSnVtcENvbmZpZywgUG9wQ29uZmlnLCBSZXNldENvbmZpZywgVGhyZWFkIH0gZnJvbSAnLi90aHJlYWQnO1xuXG5cbmludGVyZmFjZSBIb29rcyB7XG5cdGJlZm9yZV9jaGFuZ2U/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBzX3RyYW5zaXRpb246IHN0cmluZywgaF9leHRyYT86IERpY3QpOiB2b2lkIHwgYm9vbGVhbjtcblxuXHRiZWZvcmVfcHVzaD8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGdjX2RzdDogUGFnZUNvbmZpZyk6IHZvaWQgfCBib29sZWFuO1xuXHRiZWZvcmVfcG9wPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19wb3A6IFBvcENvbmZpZyk6IHZvaWQgfCBib29sZWFuO1xuXHRiZWZvcmVfanVtcD8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGdjX3BhZ2U6IFBhZ2VDb25maWcsIGdjX2p1bXA6IEp1bXBDb25maWcpOiB2b2lkIHwgYm9vbGVhbjtcblxuXHRhZnRlcl9jaGFuZ2U/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlIHwgbnVsbCwga3BfZHN0OiBQYWdlLCBzX3RyYW5zaXRpb246IHN0cmluZywgaF9leHRyYT86IERpY3QpOiBQcm9taXNhYmxlPHZvaWQ+O1xuXG5cdGFmdGVyX3B1c2g/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBrcF9kc3Q6IFBhZ2UpOiBQcm9taXNhYmxlPHZvaWQgfCBEaWN0Pjtcblx0YWZ0ZXJfcG9wPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19wb3A6IFBvcENvbmZpZyk6IFByb21pc2FibGU8dm9pZCB8IERpY3Q+O1xuXHRhZnRlcl9qdW1wPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19qdW1wOiBKdW1wQ29uZmlnKTogUHJvbWlzYWJsZTx2b2lkIHwgRGljdD47XG5cdGFmdGVyX3Jlc2V0PyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX2RzdDogUGFnZSwgZ2NfanVtcDogUmVzZXRDb25maWcpOiBQcm9taXNhYmxlPHZvaWQgfCBEaWN0PjtcblxuXHRiZWZvcmVfc3dpdGNoPyhrdF9zcmM6IFRocmVhZCwgc2lfdGhyZWFkX2RzdDogVGhyZWFkSWQpOiBQcm9taXNhYmxlPHZvaWQ+O1xuXHRhZnRlcl9zd2l0Y2g/KGt0X3NyYzogVGhyZWFkLCBrdF9kc3Q6IFRocmVhZCk6IFByb21pc2FibGU8dm9pZD47XG59XG5cblxudHlwZSBUaHJlYWRTcGF3bmVyID0gKGhfcGFyYW1zOiBQbGFpbk9iamVjdCwgaF9jb250ZXh0PzogUGxhaW5PYmplY3QpID0+IFBhZ2VDb25maWc7XG5cbnR5cGUgVGhyZWFkc0NvbmZpZyA9IE1lcmdlPHtcblx0ZGVmYXVsdDogVGhyZWFkU3Bhd25lcjtcbn0sIFBhcnRpYWw8UmVjb3JkPFRocmVhZElkLCBUaHJlYWRTcGF3bmVyPj4+O1xuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRvckNvbmZpZyB7XG5cdGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG5cdGhvb2tzOiBIb29rcztcblx0dGhyZWFkczogVGhyZWFkc0NvbmZpZztcblxuXHRjb250ZXh0OiBQbGFpbk9iamVjdCB8IG5ldmVyO1xuXG5cdC8vIHNpbmdsZVRocmVhZE1vZGU/OiBib29sZWFuO1xuXG5cdC8vIHJvdXRlcjogUm91dGVyO1xuXHQvLyB0aHJlYWRzOiBNZXJnZTx7XG5cdC8vIFx0ZGVmYXVsdDogVGhyZWFkU3Bhd25lcjtcblx0Ly8gfSwgUmVjb3JkPFRocmVhZElkLCBUaHJlYWRTcGF3bmVyPj47XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNldF96aW5kZXhfcmVsYXRpdmVseShkbV9zcmM6IEhUTUxFbGVtZW50LCBkbV9kc3Q6IEhUTUxFbGVtZW50LCBuX29yZGVyOiBudW1iZXIpOiB2b2lkIHtcblx0Y29uc3QgaXpfc3JjID0gK2RtX3NyYy5zdHlsZS56SW5kZXg7XG5cdGNvbnN0IGl6X2RzdCA9IGl6X3NyYyArIG5fb3JkZXI7XG5cdGRtX3NyYy5zdHlsZS56SW5kZXggPSBpel9zcmMrJyc7XG5cdGRtX2RzdC5zdHlsZS56SW5kZXggPSBpel9kc3QrJyc7XG59XG5cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0b3Ige1xuXHRwcm90ZWN0ZWQgX2hfdGhyZWFkczogUGFydGlhbDxSZWNvcmQ8VGhyZWFkSWQsIFRocmVhZD4+ID0ge307XG5cdHByb3RlY3RlZCBfaF90aHJlYWRfc3Bhd25lcnM6IFRocmVhZHNDb25maWc7XG5cdHByb3RlY3RlZCBfZG1fdGhyZWFkczogSFRNTEVsZW1lbnQ7XG5cdC8vIHByb3RlY3RlZCBfYl9tb2RlX3NpbmdsZV90aHJlYWQ/OiBib29sZWFuID0gZmFsc2U7XG5cdC8vIHByb3RlY3RlZCBfa19yb3V0ZXI6IFI7XG5cblx0Ly8gYnVmZmVyIGVsZW1lbnRcblx0cHJvdGVjdGVkIF9kbV9idWZmZXIgPSBkZCgnZGl2Jyk7XG5cblx0Ly8gaG9va3Ncblx0cHJvdGVjdGVkIF9nX2hvb2tzOiBIb29rcztcblxuXHQvLyBjb250ZXh0c1xuXHRwcm90ZWN0ZWQgX2hfY29udGV4dDogUGxhaW5PYmplY3Q7XG5cblx0Ly8gY3VycmVudGx5IGFjdGl2ZSB0aHJlYWQgaWRcblx0cHJvdGVjdGVkIF9zaV90aHJlYWQ6IFRocmVhZElkID0gVGhyZWFkSWQuREVGQVVMVDtcblxuXHQvLyBydW5uaW5nIHotaW5kZXggY291bnRlciBmb3IgbmV3IHRocmVhZHNcblx0cHJvdGVjdGVkIF9jX3RocmVhZF96ID0gMjAwO1xuXG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIF9nY19uYXZpZ2F0b3I6IE5hdmlnYXRvckNvbmZpZykge1xuXHRcdC8vIHRocmVhZCBjb250YWluZXIgZG9tXG5cdFx0KHtcblx0XHRcdGNvbnRhaW5lcjogdGhpcy5fZG1fdGhyZWFkcyxcblx0XHRcdHRocmVhZHM6IHRoaXMuX2hfdGhyZWFkX3NwYXduZXJzLFxuXHRcdFx0aG9va3M6IHRoaXMuX2dfaG9va3MsXG5cdFx0XHRjb250ZXh0OiB0aGlzLl9oX2NvbnRleHQ9e30sXG5cdFx0XHQvLyByb3V0ZXI6IHRoaXMuX2tfcm91dGVyLFxuXHRcdFx0Ly8gc2luZ2xlVGhyZWFkTW9kZTogdGhpcy5fYl9tb2RlX3NpbmdsZV90aHJlYWQ9ZmFsc2UsXG5cdFx0fSA9IF9nY19uYXZpZ2F0b3IpO1xuXG5cdFx0Ly8gY3JlYXRlIGRlZmF1bHQgdGhyZWFkXG5cdFx0dGhpcy5fbmV3X3RocmVhZChUaHJlYWRJZC5ERUZBVUxUKTtcblx0fVxuXG5cdGdldCBjb250ZXh0KCk6IFBsYWluT2JqZWN0IHtcblx0XHRyZXR1cm4gdGhpcy5faF9jb250ZXh0O1xuXHR9XG5cblx0cHJpdmF0ZSBfbmV3X3RocmVhZChzaV90aHJlYWQ6IFRocmVhZElkLCBoX3Byb3BzOiBEaWN0PHVua25vd24+PXt9LCBoX2NvbnRleHQ6IFBsYWluT2JqZWN0PXt9KTogVGhyZWFkIHtcblx0XHQvLyBubyBzdWNoIHRocmVhZCBzcGF3bmVyXG5cdFx0Y29uc3QgZl9zcGF3bmVyID0gdGhpcy5faF90aHJlYWRfc3Bhd25lcnNbc2lfdGhyZWFkXTtcblx0XHRpZighZl9zcGF3bmVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYE5hdmlnYXRvciBoYXMgbm8gc3VjaCB0aHJlYWQgcmVnaXN0ZXJlZDogJyR7c2lfdGhyZWFkfSdgKTtcblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgbmV3IHRocmVhZFxuXHRcdGNvbnN0IGt0X25ldyA9IG5ldyBUaHJlYWQoc2lfdGhyZWFkLCBmX3NwYXduZXIoaF9wcm9wcywgaF9jb250ZXh0KSwgdGhpcyk7XG5cblx0XHQvLyBzYXZlIHRvIHRocmVhZHNcblx0XHR0aGlzLl9oX3RocmVhZHNbc2lfdGhyZWFkXSA9IGt0X25ldztcblxuXHRcdC8vIGFwcGVuZCB0aHJlYWQgdG8gY29udGFpbmVyXG5cdFx0dGhpcy5fZG1fdGhyZWFkcy5hcHBlbmRDaGlsZChrdF9uZXcuZG9tKTtcblxuXHRcdC8vIGNyZWF0ZSBuZXcgZGVmYXVsdCBwYWdlIGFuZCBtZXJnZSBwcm9wc1xuXHRcdGt0X25ldy5yZXNldCh7XG5cdFx0XHQuLi5rdF9uZXcuZGVmYXVsdCxcblx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdC4uLmt0X25ldy5kZWZhdWx0LnByb3BzLFxuXHRcdFx0XHQuLi5oX3Byb3BzLFxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdC8vIHJldHVybiBuZXcgdGhyZWFkXG5cdFx0cmV0dXJuIGt0X25ldztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRocmVhZC5cblx0ICovXG5cdGdldCBhY3RpdmVUaHJlYWQoKTogVGhyZWFkIHtcblx0XHRyZXR1cm4gdGhpcy5faF90aHJlYWRzW3RoaXMuX3NpX3RocmVhZF0hO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnRseSBhY3RpdmUgcGFnZS5cblx0ICovXG5cdGdldCBhY3RpdmVQYWdlKCk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLmFjdGl2ZVRocmVhZC5wYWdlO1xuXHR9XG5cblx0Ly8gLyoqXG5cdC8vICAqIFB1c2hlcyBhIG5ldyBwYWdlIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRocmVhZC5cblx0Ly8gICovXG5cdC8vIHB1c2goZ2NfcGFnZTogUGFnZUNvbmZpZyk6IFBhZ2Uge1xuXHQvLyBcdC8vIHJlZiBjdXJyZW50IChzb29uIHRvIGJlIG9sZCkgcGFnZVxuXHQvLyBcdGNvbnN0IGtwX29sZCA9IHRoaXMuYWN0aXZlUGFnZTtcblxuXHQvLyBcdC8vIGNyZWF0ZSBuZXcgcGFnZVxuXHQvLyBcdGNvbnN0IGtwX25ldyA9IHRoaXMuYWN0aXZlVGhyZWFkLnB1c2goZ2NfcGFnZSk7XG5cblx0Ly8gXHQvLyAvLyBjYWxsIGhvb2tzXG5cdC8vIFx0Ly8gdGhpcy5fZl9wdXNoKGtwX29sZCwga3BfbmV3KTtcblx0Ly8gXHQvLyB0aGlzLl9hcnJpdmUoa3Bfb2xkLCAnJywgJ3B1c2gnKTtcblxuXHQvLyBcdC8vIHJldHVybiBuZXcgcGFnZVxuXHQvLyBcdHJldHVybiBrcF9uZXc7XG5cdC8vIH1cblxuXHQvLyAvKipcblx0Ly8gICogUG9wcyB0aGUgYWN0aXZlIHBhZ2UgZnJvbSB0aGUgc3RhY2suXG5cdC8vICAqL1xuXHQvLyBwb3AoZ2NfcG9wPzogUG9wQ29uZmlnKTogUGFnZSB7XG5cdC8vIFx0Ly8gZGVzdHJ1Y3R1cmUgb3B0aW9uc1xuXHQvLyBcdGNvbnN0IHtcblx0Ly8gXHRcdGJ5cGFzc0FuaW1hdGlvbjogYl9ieXBhc3NfYW5pbWF0aW9uPWZhbHNlLFxuXHQvLyBcdH0gPSBnY19wb3AgfHwge307XG5cblx0Ly8gXHQvLyB0b28gc2hvcnRcblx0Ly8gXHRpZih0aGlzLmFjdGl2ZVRocmVhZC5oaXN0b3J5Lmxlbmd0aCA8IDIpIHtcblx0Ly8gXHRcdHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBvcCBlbXB0eSBoaXN0b3J5YCk7XG5cdC8vIFx0fVxuXG5cdC8vIFx0Ly8gcG9wIGZyb20gZnJvbnQgb2Ygc3RhY2tcblx0Ly8gXHRjb25zdCBrcF9zcmMgPSB0aGlzLmFjdGl2ZVRocmVhZC5wb3AoKTtcblxuXHQvLyBcdC8vIC8vIGVtcHR5IGhpc3Rvcnlcblx0Ly8gXHQvLyBpZigha3Nfc3JjKSB7XG5cdC8vIFx0Ly8gXHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwb3AgZW1wdHkgaGlzdG9yeWApO1xuXHQvLyBcdC8vIH1cblxuXHQvLyBcdC8vIC8vIGNhbGwgaG9va3Ncblx0Ly8gXHQvLyB0aGlzLl9mX3BvcChrcF9zcmMsIHRoaXMuc3RhdGUsIGJfYnlwYXNzX2FuaW1hdGlvbik7XG5cdC8vIFx0Ly8gdGhpcy5fYXJyaXZlKGtwX3NyYywgJycsIGJfYnlwYXNzX2FuaW1hdGlvbj8gJ3BvcC5ieXBhc3MnOiAncG9wJykudGhlbigoKSA9PiB7XG5cdC8vIFx0Ly8gXHR0cnkge1xuXHQvLyBcdC8vIFx0XHRrcF9zcmMuY29tcG9uZW50LiRkZXN0cm95KCk7XG5cdC8vIFx0Ly8gXHR9XG5cdC8vIFx0Ly8gXHRjYXRjaChlX2Rlc3Ryb3kpIHtcblx0Ly8gXHQvLyBcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGRlc3Ryb3kgc3RhbGUgY29tcG9uZW50IGJlbG9uZ2luZyB0byBTdGF0ZTogJHtrcF9zcmMucGF0dGVybn1gKTtcblx0Ly8gXHQvLyBcdH1cblx0Ly8gXHQvLyB9KTtcblxuXHQvLyBcdC8vIHJldHVybiBvbGQgcGFnZVxuXHQvLyBcdHJldHVybiBrcF9zcmM7XG5cdC8vIH1cblxuXG5cdGJlZm9yZV9wdXNoKGdjX3BhZ2U6IFBhZ2VDb25maWcsIGtwX3NyYzogUGFnZSwga3RfY2hpbGQ6IFRocmVhZCk6IGJvb2xlYW4ge1xuXHRcdC8vIG5vdCBhY3RpdmUgdGhyZWFkOyBkZW55XG5cdFx0aWYodGhpcy5hY3RpdmVUaHJlYWQgIT09IGt0X2NoaWxkKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBjYWxsIHByZXB1c2ggaG9va3Ncblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfY2hhbmdlPy4oa3RfY2hpbGQsIGtwX3NyYywgJ3B1c2gnKSkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9wdXNoPy4oa3RfY2hpbGQsIGtwX3NyYywgZ2NfcGFnZSkpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vIGFwcHJvdmVkXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXG5cdGJlZm9yZV9wb3AoZ2NfcG9wOiBQb3BDb25maWcsIGtwX2RzdDogUGFnZSwga3Bfc3JjOiBQYWdlLCBrdF9jaGlsZDogVGhyZWFkKTogYm9vbGVhbiB7XG5cdFx0Ly8gbm90IGFjdGl2ZSB0aHJlYWQ7IGRlbnlcblx0XHRpZih0aGlzLmFjdGl2ZVRocmVhZCAhPT0ga3RfY2hpbGQpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vIGNhbGwgcHJlcHVzaCBob29rc1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9jaGFuZ2U/LihrdF9jaGlsZCwga3Bfc3JjLCAncG9wJykpIHJldHVybiBmYWxzZTtcblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfcG9wPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0LCBnY19wb3ApKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBhcHByb3ZlZFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0YmVmb3JlX2p1bXAoZ2NfanVtcDogSnVtcENvbmZpZywgZ2NfcGFnZTogUGFnZUNvbmZpZywga3Bfc3JjOiBQYWdlLCBrdF9jaGlsZDogVGhyZWFkKTogYm9vbGVhbiB7XG5cdFx0Ly8gbm90IGFjdGl2ZSB0aHJlYWQ7IGRlbnlcblx0XHRpZih0aGlzLmFjdGl2ZVRocmVhZCAhPT0ga3RfY2hpbGQpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vIGNhbGwgcHJlanVtcCBob29rc1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9jaGFuZ2U/LihrdF9jaGlsZCwga3Bfc3JjLCAnanVtcCcpKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYoZmFsc2UgPT09IHRoaXMuX2dfaG9va3MuYmVmb3JlX2p1bXA/LihrdF9jaGlsZCwga3Bfc3JjLCBnY19wYWdlLCBnY19qdW1wKSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Ly8gYXBwcm92ZWRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jIGJlZm9yZV9zd2l0Y2goa3Rfc3JjOiBUaHJlYWQsIHNpX3RocmVhZDogVGhyZWFkSWQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfY2hhbmdlPy4oa3Rfc3JjLCBrdF9zcmMucGFnZSwgJ3N3aXRjaCcpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdG9wIHRocmVhZCBzd2l0Y2gnKTtcblxuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYmVmb3JlX3N3aXRjaD8uKGt0X3NyYywgc2lfdGhyZWFkKTtcblx0fVxuXG5cdGFzeW5jIGFmdGVyX3B1c2goa3RfY2hpbGQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBrcF9kc3Q6IFBhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBoX2V4dHJhID0gYXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9wdXNoPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0KTtcblxuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfY2hhbmdlPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0LCAncHVzaCcsIGhfZXh0cmEgfHwge30pO1xuXHR9XG5cblx0YXN5bmMgYWZ0ZXJfcG9wKGt0X2NoaWxkOiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19wb3A6IFBvcENvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGhfZXh0cmEgPSBhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX3BvcD8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCwgZ2NfcG9wKTtcblxuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfY2hhbmdlPy4oa3RfY2hpbGQsIGtwX3NyYywga3BfZHN0LCAncG9wJywgaF9leHRyYSB8fCB7fSk7XG5cdH1cblxuXHRhc3luYyBhZnRlcl9qdW1wKGt0X2NoaWxkOiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlLCBnY19qdW1wOiBKdW1wQ29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgaF9leHRyYSA9IGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfanVtcD8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCwgZ2NfanVtcCk7XG5cblx0XHRhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX2NoYW5nZT8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCwgJ2p1bXAnLCBoX2V4dHJhIHx8IHt9KTtcblx0fVxuXG5cdGFzeW5jIGFmdGVyX3Jlc2V0KGt0X2NoaWxkOiBUaHJlYWQsIGtwX2RzdDogUGFnZSwgZ2NfcmVzZXQ6IFJlc2V0Q29uZmlnKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgaF9leHRyYSA9IGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfcmVzZXQ/LihrdF9jaGlsZCwga3BfZHN0LCBnY19yZXNldCk7XG5cblx0XHRhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX2NoYW5nZT8uKGt0X2NoaWxkLCBudWxsLCBrcF9kc3QsICdyZXNldCcsIGhfZXh0cmEgfHwge30pO1xuXHR9XG5cblx0YXN5bmMgYWZ0ZXJfc3dpdGNoKGt0X3NyYzogVGhyZWFkLCBrdF9kc3Q6IFRocmVhZCk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfc3dpdGNoPy4oa3Rfc3JjLCBrdF9kc3QpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFjdGl2YXRlcyBhIHRocmVhZCBieSB0aGUgZ2l2ZW4gdGhyZWFkIGlkLlxuXHQgKi9cblx0YXN5bmMgYWN0aXZhdGVUaHJlYWQoc2lfdGhyZWFkOiBUaHJlYWRJZCwgaF9wcm9wczogUGxhaW5PYmplY3Q9e30pOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0XHQvLyByZWYgY3VycmVudCB0aHJlYWRcblx0XHRjb25zdCBrdF9zcmMgPSB0aGlzLmFjdGl2ZVRocmVhZDtcblxuXHRcdC8vIHJlZiBwcmV2aW91cyBwYWdlXG5cdFx0Y29uc3Qga3Bfc3JjID0gdGhpcy5hY3RpdmVQYWdlO1xuXG5cdFx0Ly8gbG9va3VwIGV4aXN0aW5nIHRocmVhZFxuXHRcdGxldCBrdF9kc3QgPSB0aGlzLl9oX3RocmVhZHNbc2lfdGhyZWFkXTtcblxuXHRcdC8vIHRocmVhZCBjaGFuZ2Vcblx0XHRpZihzaV90aHJlYWQgIT09IHRoaXMuX3NpX3RocmVhZCkge1xuXHRcdFx0Ly8gLy8gc2luZ2xlIHRocmVhZCBtb2RlOyBhYm9ydFxuXHRcdFx0Ly8gaWYodGhpcy5fYl9tb2RlX3NpbmdsZV90aHJlYWQpIHtcblx0XHRcdC8vIFx0dGhyb3cgbmV3IEVycm9yKGBOYXZpZ2F0b3Igb3BlcmF0aW5nIGluIHNpbmdsZSB0aHJlYWQgbW9kZSByZWZ1c2luZyB0byBhY3RpdmF0ZSB0aGVhZCAnJHtzaV90aHJlYWR9Jy5gKTtcblx0XHRcdC8vIH1cblxuXHRcdFx0Ly8gY2FsbCBwcmVzd2l0Y2ggaG9va3Ncblx0XHRcdGF3YWl0IHRoaXMuYmVmb3JlX3N3aXRjaChrdF9zcmMsIHNpX3RocmVhZCk7XG5cblx0XHRcdC8vIHByZXYgdGhyZWFkXG5cdFx0XHRjb25zdCBzaV90aHJlYWRfcHJldiA9IHRoaXMuX3NpX3RocmVhZDtcblxuXHRcdFx0Ly8gbm8gZXhpc3RpbmcgdGhyZWFkOyBjcmVhdGUgbmV3IG9uZVxuXHRcdFx0aWYoIWt0X2RzdCkge1xuXHRcdFx0XHRrdF9kc3QgPSB0aGlzLl9uZXdfdGhyZWFkKHNpX3RocmVhZCwgaF9wcm9wcyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBwcm9wcyBkaWZmZXJcblx0XHRcdGVsc2UgaWYob2JqZWN0c19taWdodF9kaWZmZXIoa3RfZHN0LmRlZmF1bHQucHJvcHMgfHwge30sIGhfcHJvcHMpKSB7XG5cdFx0XHRcdC8vIGNyZWF0ZSBuZXcgcGFnZVxuXHRcdFx0XHRjb25zdCBrcF9kc3QgPSBuZXcgUGFnZSh7XG5cdFx0XHRcdFx0Li4ua3RfZHN0LmRlZmF1bHQsXG5cdFx0XHRcdFx0cHJvcHM6IGhfcHJvcHMsXG5cdFx0XHRcdFx0Y29udGV4dDogdGhpcy5faF9jb250ZXh0LFxuXHRcdFx0XHR9LCBrdF9kc3QpO1xuXG5cdFx0XHRcdC8vIHJlc2V0IHRocmVhZCBoaXN0b3J5XG5cdFx0XHRcdGt0X2RzdC5yZXNldChrcF9kc3QsIHtcblx0XHRcdFx0XHRrZWVwVG9wOiB0cnVlLFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBwbGFjZSBpbmNvbWluZyBzdGF0ZSBiZWxvd1xuXHRcdFx0XHRzZXRfemluZGV4X3JlbGF0aXZlbHkoa3Bfc3JjLmRvbSwga3BfZHN0LmRvbSwgLTEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB1cGRhdGUgdGhyZWFkXG5cdFx0XHR0aGlzLl9zaV90aHJlYWQgPSBzaV90aHJlYWQ7XG5cblx0XHRcdC8vIHBsYWNlIHRocmVhZCBpbiBmcm9udFxuXHRcdFx0dGhpcy5hY3RpdmVUaHJlYWQuc2hvdygpO1xuXHRcdFx0dGhpcy5hY3RpdmVUaHJlYWQuZG9tLnN0eWxlLnpJbmRleCA9ICh0aGlzLl9jX3RocmVhZF96KyspKycnO1xuXG5cdFx0XHQvLyAvLyBhcnJpdmVcblx0XHRcdC8vIHRoaXMuX2Fycml2ZShrcF9zcmMsIHNpX3RocmVhZF9wcmV2LCAndGhyZWFkJykudGhlbigoKSA9PiB7XG5cdFx0XHQvLyBcdC8vIC8vIGhpZGUgcHJldmlvdXMgdGhyZWFkXG5cdFx0XHQvLyBcdC8vIGlmKGt0X2RzdCAmJiBrdF9zcmMgJiYga3Rfc3JjICE9PSBrdF9kc3QpIHtcblx0XHRcdC8vIFx0Ly8gXHQvLyBkZWJ1Z2dlcjtcblx0XHRcdC8vIFx0Ly8gXHQvLyBrdF9zcmMuaGlkZSgpO1xuXHRcdFx0Ly8gXHQvLyB9XG5cdFx0XHQvLyB9KTtcblxuXHRcdFx0Ly8gY2FsbCBwb3N0c3dpdGNoIGhvb2tzXG5cdFx0XHRhd2FpdCB0aGlzLmFmdGVyX3N3aXRjaChrdF9zcmMsIGt0X2RzdCk7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHQvLyAvLyBzYW1lIHRocmVhZFxuXHRcdC8vIGVsc2Uge1xuXHRcdC8vIFx0Ly8gdGhyZWFkIGRlZmF1bHQgaXMgcHJldmlvdXMgaW4gaGlzdG9yeVxuXHRcdC8vIFx0ZGVidWdnZXI7XG5cdFx0Ly8gXHRjb25zb2xlLmluZm8oa190aHJlYWQ/LmRlZmF1bHQucGF0aCk7XG5cdFx0Ly8gfVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge1xuXHRcdGdldEFsbENvbnRleHRzLFxuXHRcdG9uTW91bnQsXG5cdFx0dGljayxcblx0fSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCB0eXBlIHsgUGxhaW5PYmplY3QgfSBmcm9tICcjL21ldGEvYmVsdCc7XG5cdGltcG9ydCB7XG5cdFx0b2RlLFxuXHRcdG9kZXJvbSxcblx0XHR0aW1lb3V0LFxuXHR9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXHRpbXBvcnQgT3ZlcnNjcm9sbFN2ZWx0ZSBmcm9tICcuL3N5c3RlbS9PdmVyc2Nyb2xsLnN2ZWx0ZSc7XG5cdGltcG9ydCBQb3B1cFN2ZWx0ZSBmcm9tICcuL3N5c3RlbS9Qb3B1cC5zdmVsdGUnO1xuXHRpbXBvcnQgTmF2U3ZlbHRlIGZyb20gJy4vc3lzdGVtL05hdi5zdmVsdGUnO1xuXHRpbXBvcnQgU2VhcmNoU3ZlbHRlIGZyb20gJy4vc3lzdGVtL1NlYXJjaC5zdmVsdGUnO1xuXHRpbXBvcnQgUHJvZ3Jlc3NTdmVsdGUgZnJvbSAnLi9zeXN0ZW0vUHJvZ3Jlc3Muc3ZlbHRlJztcblx0aW1wb3J0IFNpZGVNZW51U3ZlbHRlIGZyb20gJy4vc3lzdGVtL1NpZGVNZW51LnN2ZWx0ZSc7XG5cdGltcG9ydCBWZW5kb3JNZW51U3ZlbHRlIGZyb20gJy4vc3lzdGVtL1ZlbmRvck1lbnUuc3ZlbHRlJztcblxuXHRpbXBvcnQgQmxhbmtTdmVsdGUgZnJvbSAnIyMvc2NyZWVuL0JsYW5rLnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHR5cGUgeyBQYWdlLCBQYWdlQ29uZmlnIH0gZnJvbSAnIyMvbmF2L3BhZ2UnO1xuXHRpbXBvcnQgdHlwZSB7IFBvcENvbmZpZywgVGhyZWFkIH0gZnJvbSAnIyMvbmF2L3RocmVhZCc7XG5cdGltcG9ydCB7IE5hdmlnYXRvciwgTmF2aWdhdG9yQ29uZmlnIH0gZnJvbSAnIyMvbmF2L25hdmlnYXRvcic7XG5cblx0aW1wb3J0IHsgSF9USFJFQURTIH0gZnJvbSAnIyMvZGVmJztcblx0aW1wb3J0IHsgeXdfYWNjb3VudCwgeXdfYWNjb3VudF9yZWYsIHl3X2NoYWluLCB5d19jaGFpbl9yZWYsIHl3X25hdmlnYXRvciwgeXdfbmF2X3Zpc2libGUsIHl3X25ldHdvcmssIHl3X25ldHdvcmtfYWN0aXZlLCB5d19uZXR3b3JrX3JlZiwgeXdfcGFnZSwgeXdfdGhyZWFkIH0gZnJvbSAnIyMvbWVtJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQgeyBvbmNlX3N0b3JlX3VwZGF0ZXMgfSBmcm9tICcuLi9zdmVsdGUnO1xuXHRpbXBvcnQgeyBOZXR3b3JrcyB9IGZyb20gJyMvc3RvcmUvbmV0d29ya3MnO1xuXHRpbXBvcnQgeyBWYXVsdCB9IGZyb20gJyMvY3J5cHRvL3ZhdWx0JztcblxuXHRleHBvcnQgbGV0IHBhZ2U6IFBhZ2VDb25maWc7XG5cdGNvbnN0IGdjX3BhZ2UgPSBwYWdlO1xuXG5cdGV4cG9ydCBsZXQgbW9kZTogJ2FwcCcgfCAnZmxvdyc7XG5cdGNvbnN0IGJfZmxvdyA9ICdmbG93JyA9PT0gbW9kZTtcblx0Y29uc3QgYl9tYWluID0gJ2FwcCcgPT09IG1vZGU7XG5cblx0bGV0IGRtX3ZpZXdwb3J0OiBIVE1MRWxlbWVudDtcblx0bGV0IGRtX3RocmVhZHM6IEhUTUxFbGVtZW50O1xuXHRsZXQgZG1fY29udGVudDogSFRNTEVsZW1lbnQ7XG5cdGxldCBkbV9leGl0dGluZzogSFRNTEVsZW1lbnQ7XG5cblx0Ly8gZ2V0IGFsbCBjb250ZXh0c1xuXHRjb25zdCBoX2NvbnRleHRfYWxsID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldEFsbENvbnRleHRzKCkuZW50cmllcygpKTtcblxuXHRhc3luYyBmdW5jdGlvbiBzbGlkZShkbV9zbGlkZTogSFRNTEVsZW1lbnQsIGJfaW49ZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHQvLyBzbW9vdGhlciwgYWxsb3cgZm9yIHByZXZpb3VzIG1vZHMgdG8gbWFrZSBlbGVtZW50IHZpc2libGVcblx0XHRhd2FpdCB0aW1lb3V0KDApO1xuXG5cdFx0Ly8gZ28gYXN5bmNcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKGZrX3Jlc29sdmUpID0+IHtcblx0XHRcdC8vIHdhaXQgZm9yIHRyYW5zaXRpb24gdG8gY29tcGxldGVcblx0XHRcdGRtX3NsaWRlLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiB0cmFuc2l0aW9uX2VuZChkX2V2ZW50KSB7XG5cdFx0XHRcdGlmKCd0cmFuc2Zvcm0nID09PSBkX2V2ZW50LnByb3BlcnR5TmFtZSkge1xuXHRcdFx0XHRcdC8vIGNoYW5nZSBjbGFzc1xuXHRcdFx0XHRcdGRtX3NsaWRlLmNsYXNzTGlzdC5hZGQoJ3NsaWQnKTtcblxuXHRcdFx0XHRcdGZrX3Jlc29sdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIGFwcGx5IHRyYW5zZm9ybVxuXHRcdFx0ZG1fc2xpZGUuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHtiX2luPyAnMHB4JzogJ3ZhcigtLWFwcC13aW5kb3ctd2lkdGgpJ30pYDtcblx0XHR9KTtcblx0fVxuXG5cdG9uTW91bnQoYXN5bmMoKSA9PiB7XG5cdFx0Ly8gbmF2aWdhdG9yIGNvbmZpZ1xuXHRcdGNvbnN0IGdjX25hdmlnYXRvcjogTmF2aWdhdG9yQ29uZmlnID0ge1xuXHRcdFx0Ly8gdGhyZWFkcyBjb250YWluZXJcblx0XHRcdGNvbnRhaW5lcjogZG1fdGhyZWFkcyxcblxuXHRcdFx0Ly8gZm9yd2FyZCBhbGwgY29udGV4dHNcblx0XHRcdGNvbnRleHQ6IGhfY29udGV4dF9hbGwsXG5cblx0XHRcdC8vIGRlZmF1bHQgdGhyZWFkcyBjb25maWdcblx0XHRcdHRocmVhZHM6IHtcblx0XHRcdFx0ZGVmYXVsdDogKCkgPT4gKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBCbGFua1N2ZWx0ZSxcblx0XHRcdFx0fSksXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBkZWZhdWx0IGhvb2tzXG5cdFx0XHRob29rczoge1xuXHRcdFx0XHRiZWZvcmVfY2hhbmdlKGt0X2NvbnRleHQsIGtwX3NyYywga3BfZHN0KSB7XG5cdFx0XHRcdFx0Ly8gYmx1ciBvbiBwYWdlXG5cdFx0XHRcdFx0dm9pZCBrcF9zcmMuZmlyZSgnYmx1cicpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIG9uY2UgYSBuZXcgcGFnZSBoYXMgYmVlbiBwdXNoZWRcblx0XHRcdFx0YWZ0ZXJfcHVzaChrdF9jb250ZXh0LCBrcF9zcmMsIGtwX2RzdCkge1xuXHRcdFx0XHRcdC8vIC8vIHB1c2ggc3RhdGUgdG8gbmF2aWdhdG9yIGhpc3Rvcnlcblx0XHRcdFx0XHQvLyBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCAnJywgJyNwYWdlOicra3BfZHN0LmlkKTtcblxuXHRcdFx0XHRcdC8vIHdhaXQgZm9yIHN2ZWx0ZSB0byByZW5kZXIgY29tcG9uZW50IGJlZm9yZSBxdWVyeWluZyBjb250YWluZXJcblx0XHRcdFx0XHR2b2lkIHRpY2soKS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRcdC8vIHF1ZXJ5IGNvbnRhaW5lciBmb3IgbGFzdCBlbGVtZW50IGNoaWxkXG5cdFx0XHRcdFx0XHR2b2lkIHNsaWRlKGtwX2RzdC5kb20sIHRydWUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIG9uY2UgYSBwYWdlIGhhcyBiZWVuIHBvcHBlZFxuXHRcdFx0XHRhZnRlcl9wb3Aoa3RfY29udGV4dCwga3Bfc3JjLCBrcF9kc3QsIGdjX3BvcCkge1xuXHRcdFx0XHRcdC8vIG5vdGlmeSBkc3QgcGFnZVxuXHRcdFx0XHRcdHZvaWQga3BfZHN0LmZpcmUoJ3Jlc3RvcmUnKTtcblxuXHRcdFx0XHRcdC8vIGRvIG5vdCBieXBhc3MgYW5pbWF0aW9uXG5cdFx0XHRcdFx0aWYoIWdjX3BvcC5ieXBhc3NBbmltYXRpb24pIHtcblx0XHRcdFx0XHRcdC8vIGFwcGx5IHRyYW5zbGF0aW9uIHRyYW5zZm9ybSB0byBzcmMgcGFnZVxuXHRcdFx0XHRcdFx0a3Bfc3JjLmRvbS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCh2YXIoLS1hcHAtd2luZG93LXdpZHRoKSlgO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyB1cG9uIGFueSBwYWdlIGNoYW5nZVxuXHRcdFx0XHRhZnRlcl9jaGFuZ2Uoa3RfY29udGV4dCwga3Bfc3JjLCBrcF9kc3QsIHNfdHJhbnNpdGlvbiwgaF9leHRyYT17fSkge1xuXHRcdFx0XHRcdC8vIHNldCBnbG9iYWwgcGFnZSBhbmQgdGhyZWFkXG5cdFx0XHRcdFx0JHl3X3BhZ2UgPSBrcF9kc3Q7XG5cdFx0XHRcdFx0JHl3X3RocmVhZCA9IGt0X2NvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBub3RpZnkgZHN0IHBhZ2Vcblx0XHRcdFx0XHR2b2lkIGtwX2RzdC5maXJlKCdmb2N1cycpO1xuXG5cdFx0XHRcdFx0Ly8gLy8gbWFpbnRhaW4gc2Nyb2xsVG9wIG9mIHRoZSBzcmMgcGFnZVxuXHRcdFx0XHRcdC8vIGNvbnN0IHhfc2Nyb2xsX3RvcCA9IGtwX3NyYy5kb20uc2Nyb2xsVG9wO1xuXG5cdFx0XHRcdFx0Ly8gZGVidWdnZXI7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0YXN5bmMgYmVmb3JlX3N3aXRjaCgpIHtcblx0XHRcdFx0XHQvLyBhbGxvdyB0aGVzZSB0byBmYWlsIGluIG9yZGVyIHRvIHJlY292ZXIgZnJvbSBkaXNhc3RlcnNcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Ly8gc2V0IGRlZmF1bHRzXG5cdFx0XHRcdFx0XHRhd2FpdCBQcm9taXNlLmFsbChbXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmF1bHQgY2hhaW5cblx0XHRcdFx0XHRcdFx0JHl3X2NoYWluIHx8IG9uY2Vfc3RvcmVfdXBkYXRlcyh5d19jaGFpbiwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdENoYWlucy5yZWFkKCkudGhlbihrcyA9PiAkeXdfY2hhaW5fcmVmID0gb2RlKGtzLnJhdylbMF1bMF0pLFxuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmF1bHQgbmV0d29ya1xuXHRcdFx0XHRcdFx0XHQkeXdfbmV0d29ya19hY3RpdmUgfHwgb25jZV9zdG9yZV91cGRhdGVzKHl3X25ldHdvcmtfYWN0aXZlLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0TmV0d29ya3MucmVhZCgpLnRoZW4oa3MgPT4gJHl3X25ldHdvcmtfcmVmID0gb2RlKGtzLnJhdylbMF1bMF0pLFxuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmF1bHQgYWNjb3VudFxuXHRcdFx0XHRcdFx0XHQkeXdfYWNjb3VudCB8fCBvbmNlX3N0b3JlX3VwZGF0ZXMoeXdfYWNjb3VudCwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdEFjY291bnRzLnJlYWQoKS50aGVuKGtzID0+ICR5d19hY2NvdW50X3JlZiA9IG9kZShrcy5yYXcpWzBdWzBdKSxcblx0XHRcdFx0XHRcdF0pO1xuXG5cdFx0XHRcdFx0XHQvLyBvbmx5IG5lZWRzIHRvIGhhcHBlbiBvbmNlXG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5iZWZvcmVfc3dpdGNoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaChlX2xvYWRfZGVmYXVsdCkge1xuXHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coZV9sb2FkX2RlZmF1bHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRhc3luYyBhZnRlcl9zd2l0Y2goa3Rfc3JjLCBrdF9kc3QpIHtcblx0XHRcdFx0XHQvLyBzZXQgZ2xvYmFsIHBhZ2UgYW5kIHRocmVhZFxuXHRcdFx0XHRcdCR5d19wYWdlID0ga3RfZHN0LnBhZ2U7XG5cdFx0XHRcdFx0JHl3X3RocmVhZCA9IGt0X2RzdDtcblxuXHRcdFx0XHRcdC8vIGZvY3VzIG9uIHBhZ2Vcblx0XHRcdFx0XHR2b2lkIGt0X2RzdC5wYWdlLmZpcmUoJ2ZvY3VzJyk7XG5cblx0XHRcdFx0XHQvLyB3YWl0IGZvciBzdmVsdGUgdG8gcmVuZGVyIGNvbXBvbmVudCBiZWZvcmUgcXVlcnlpbmcgY29udGFpbmVyXG5cdFx0XHRcdFx0YXdhaXQgdGljaygpO1xuXG5cdFx0XHRcdFx0Ly8gcXVlcnkgY29udGFpbmVyIGZvciBsYXN0IGVsZW1lbnQgY2hpbGRcblx0XHRcdFx0XHRhd2FpdCBzbGlkZShrdF9kc3QucGFnZS5kb20sIHRydWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0Ly8gc3BlY2lmaWMgcGFnZSBnaXZlblxuXHRcdGlmKGJfZmxvdykge1xuXHRcdFx0Ly8gb3ZlcnJpZGUgdGhyZWFkcyBjb25maWdcblx0XHRcdGdjX25hdmlnYXRvci50aHJlYWRzID0ge1xuXHRcdFx0XHRkZWZhdWx0OiAoKSA9PiBnY19wYWdlLFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0Ly8gbWFpbiBzeXN0ZW1cblx0XHRlbHNlIGlmKGJfbWFpbikge1xuXHRcdFx0Ly8gb3ZlcnJpZGUgdGhyZWFkcyBjb25maWdcblx0XHRcdGdjX25hdmlnYXRvci50aHJlYWRzID0gb2Rlcm9tKEhfVEhSRUFEUywgKHNpX3RocmVhZCwgZGNfc2NyZWVuKSA9PiB7XG5cdFx0XHRcdC8vIC8vIGxvb2t1cCByb3V0ZXIgbm9kZSBjb3JyZXNwb25kaW5nIHRvIHNjcmVlbiBjbGFzc1xuXHRcdFx0XHQvLyBjb25zdCBrX25vZGUgPSBLX1JPVVRFUi5sb29rdXBfc2NyZWVuKGRjX3NjcmVlbik7XG5cblx0XHRcdFx0Ly8gLy8gcmVmIHBhdGggcGF0dGVyblxuXHRcdFx0XHQvLyBjb25zdCBzeF9wYXR0ZXJuID0ga19ub2RlLnBhdGhfcGF0dGVybjtcblxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFtzaV90aHJlYWRdOiAoaF9wcm9wczogUGxhaW5PYmplY3QpID0+ICh7XG5cdFx0XHRcdFx0XHRjcmVhdG9yOiBkY19zY3JlZW4sXG5cdFx0XHRcdFx0XHRwcm9wczogaF9wcm9wcyxcblx0XHRcdFx0XHRcdC8vIHBhdGg6IGtfbm9kZS5yZXZlcnNlX3Jlc29sdmUoaF9wcm9wcyksXG5cdFx0XHRcdFx0XHQvLyBwYXR0ZXJuOiBzeF9wYXR0ZXJuLFxuXHRcdFx0XHRcdFx0Ly8gc2NyZWVuOiBkY19zY3JlZW4sXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdH0gYXMgUmVjb3JkPHR5cGVvZiBzaV90aHJlYWQsIChoX3Byb3BzOiBQbGFpbk9iamVjdCkgPT4gUGFnZUNvbmZpZz47XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gc2V0IGluaXRcblx0XHRcdGdjX25hdmlnYXRvci50aHJlYWRzLmluaXQgPSAoaF9wcm9wczogUGxhaW5PYmplY3QsIGhfY29udGV4dD86IFBsYWluT2JqZWN0KSA9PiAoe1xuXHRcdFx0XHQuLi5nY19wYWdlLFxuXHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdC4uLmdjX3BhZ2UucHJvcHMsXG5cdFx0XHRcdFx0Li4uaF9wcm9wcyxcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29udGV4dDoge1xuXHRcdFx0XHRcdC4uLmdjX3BhZ2UuY29udGV4dCxcblx0XHRcdFx0XHQuLi5oX2NvbnRleHQsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRjb25zdCBrX25hdmlnYXRvciA9IG5ldyBOYXZpZ2F0b3IoZ2NfbmF2aWdhdG9yKTtcblx0XHQkeXdfbmF2aWdhdG9yID0ga19uYXZpZ2F0b3I7XG5cblxuXG5cdFx0Ly8gaGFuZGxlIHBvcCBzdGF0ZVxuXHRcdC8vIHdpbmRvdy5vbnBvcHN0YXRlID0gZnVuY3Rpb24oZF9ldmVudDogUG9wU3RhdGVFdmVudCkge1xuXHRcdC8vIFx0a19uYXZpZ2F0b3IuYWN0aXZlUGFnZS5wb3Aoe1xuXHRcdC8vIFx0XHRleHRlcm5hbDogdHJ1ZSxcblx0XHQvLyBcdH0pO1xuXHRcdC8vIH07XG5cblx0XHQvLyAkeXdfZXhpdHRpbmdfZG9tID0gZG1fZXhpdHRpbmc7XG5cblx0XHQvLyBjb25zdCBrX3N0YXRlX3Jvb3QgPSBuZXcgU3RhdGUoJy9sb2NrZWQnLCBudWxsIGFzIHVua25vd24gYXMgU3ZlbHRlQ29tcG9uZW50LCAnL2xvY2tlZCcpO1xuXHRcdC8vIGNvbnN0IGtfdGhyZWFkX3Jvb3QgPSBuZXcgU3RhdGVUaHJlYWQoa19zdGF0ZV9yb290KTtcblxuXHQvLyBcdGluaXRpYWxpemUobmV3IFN0YXRlTWFuYWdlcih7XG5cdC8vIFx0XHRyb3V0ZXI6IEtfUk9VVEVSLFxuXG5cdC8vIFx0XHRhcnJpdmUodGhpczogU3RhdGVNYW5hZ2VyLCBrc19zcmM6IFN0YXRlLCBrc19kc3Q6IFN0YXRlLCBzaV90aHJlYWRfc3JjOiBzdHJpbmcsIHNfdHJhbnNpdGlvbj0nJyk6IFByb21pc2U8dm9pZD4ge1xuXHQvLyBcdFx0XHQvLyBtYWludGFpbiBzY3JvbGxUb3Bcblx0Ly8gXHRcdFx0Y29uc3QgeF9zY3JvbGxfdG9wID0ga3Nfc3JjLmRvbS5zY3JvbGxUb3A7XG5cblx0Ly8gXHRcdFx0Y29uc29sZS5sb2coe1xuXHQvLyBcdFx0XHRcdHR5cGU6ICdhcnJpdmUnLFxuXHQvLyBcdFx0XHRcdGtzX3NyYyxcblx0Ly8gXHRcdFx0XHRrc19kc3QsXG5cdC8vIFx0XHRcdFx0c2lfdGhyZWFkX3NyYyxcblx0Ly8gXHRcdFx0XHRzX3RyYW5zaXRpb24sXG5cdC8vIFx0XHRcdH0pO1xuXG5cdC8vIFx0XHRcdC8vIG5ldyBNdXRhdGlvbk9ic2VydmVyKChtKSA9PiB7XG5cdC8vIFx0XHRcdC8vIFx0ZGVidWdnZXI7XG5cdC8vIFx0XHRcdC8vIH0pLm9ic2VydmUoa3Nfc3JjLmRvbSwge1xuXHQvLyBcdFx0XHQvLyBcdGF0dHJpYnV0ZXM6IHRydWUsXG5cdC8vIFx0XHRcdC8vIFx0Y2hpbGRMaXN0OiB0cnVlLFxuXHQvLyBcdFx0XHQvLyB9KTtcblxuXHQvLyBcdFx0XHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoa3Nfc3JjLmRvbSwgJ3Njcm9sbFRvcCcsIHtcblx0Ly8gXHRcdFx0Ly8gXHRnZXQoKSB7XG5cdC8vIFx0XHRcdC8vIFx0XHRyZXR1cm4geF9zY3JvbGxfdG9wO1xuXHQvLyBcdFx0XHQvLyBcdH0sXG5cdC8vIFx0XHRcdC8vIFx0c2V0KHhfdG86IG51bWJlcikge1xuXHQvLyBcdFx0XHQvLyBcdFx0Y29uc29sZS5sb2coYFNFVCBUTzogJHt4X3RvfWApO1xuXHQvLyBcdFx0XHQvLyBcdFx0ZGVidWdnZXI7XG5cdC8vIFx0XHRcdC8vIFx0fSxcblx0Ly8gXHRcdFx0Ly8gfSk7XG5cblx0Ly8gXHRcdFx0Ly8gbmV1dGVyIHNyYyBmcmFtZVxuXHQvLyBcdFx0XHRrc19zcmMuZG9tLmNsYXNzTGlzdC5hZGQoJ2Zyb3plbicpO1xuXG5cdC8vIFx0XHRcdC8vIGVuc3VyZSBpbmNvbWluZyBmcmFtZSBpcyBub3QgZnJvemVuXG5cdC8vIFx0XHRcdGtzX2RzdC5kb20uY2xhc3NMaXN0LnJlbW92ZSgnZnJvemVuJyk7XG5cblx0Ly8gXHRcdFx0Y29uc3QgZ2NfcGFyYW1zID0geXdfcGFyYW1zLmdldCgpO1xuXHQvLyBcdFx0XHQvLyBjb25zdCBnY19wYXJhbXMgPSB7fTtcblxuXHQvLyBcdFx0XHQkeXdfcGF0aCA9IGtzX2RzdC5wYXRoO1xuXHQvLyBcdFx0XHQkeXdfcGF0dGVybiA9IGtzX2RzdC5wYXR0ZXJuO1xuXG5cdC8vIFx0XHRcdGNvbnN0IGdjX3Byb3BzID0ga3NfZHN0LnByb3BzO1xuXG5cdC8vIFx0XHRcdCR5d19wYXJhbXMgPSB7XG5cdC8vIFx0XHRcdFx0ZmFtaWx5SWQ6IGdjX3Byb3BzLmZhbWlseUlkIGFzIHN0cmluZyB8fCBnY19wYXJhbXMuZmFtaWx5SWQsXG5cdC8vIFx0XHRcdFx0Y2hhaW5JZDogZ2NfcHJvcHMuY2hhaW5JZCBhcyBzdHJpbmcgfHwgZ2NfcGFyYW1zLmNoYWluSWQsXG5cdC8vIFx0XHRcdFx0YWNjb3VudElkOiBnY19wcm9wcy5hY2NvdW50SWQgYXMgc3RyaW5nIHx8IGdjX3BhcmFtcy5hY2NvdW50SWQsXG5cdC8vIFx0XHRcdH07XG5cblx0Ly8gXHRcdFx0aWYoZ2NfcHJvcHMuZmFtaWx5SWQpIHtcblx0Ly8gXHRcdFx0XHRjb25zdCBwX2ZhbWlseSA9IEZhbWlseS5yZWZGcm9tSWQoZ2NfcHJvcHMuZmFtaWx5SWQgYXMgc3RyaW5nKTtcblx0Ly8gXHRcdFx0XHRpZighSF9GQU1JTElFU1twX2ZhbWlseV0pIGRlYnVnZ2VyO1xuXHQvLyBcdFx0XHRcdCR5d19mYW1pbHkgPSBIX0ZBTUlMSUVTW3BfZmFtaWx5XTtcblx0Ly8gXHRcdFx0fVxuXG5cdC8vIFx0XHRcdC8vIGlmKGdjX3Byb3BzLmNoYWluSWQpIHtcblx0Ly8gXHRcdFx0Ly8gXHRpZighJHl3X2ZhbWlseSkgZGVidWdnZXI7XG5cdC8vIFx0XHRcdC8vIFx0Y29uc3QgcF9jaGFpbiA9IENoYWluLnJlZkZyb21GYW1pbHlJZCgkeXdfZmFtaWx5LmRlZi5pcmksIGdjX3Byb3BzLmNoYWluSWQgYXMgc3RyaW5nKTtcblx0Ly8gXHRcdFx0Ly8gXHQkeXdfY2hhaW4gPSBIX0NIQUlOU1twX2NoYWluXSB8fCBudWxsO1xuXHQvLyBcdFx0XHQvLyB9XG5cblx0Ly8gXHRcdFx0Ly8gaWYoZ2NfcHJvcHMuYWNjb3VudElkKSB7XG5cdC8vIFx0XHRcdC8vIFx0Y29uc29sZS53YXJuKGA8JHskeXdfcGF0aH0+IHByb3BzIHNldCBhY2NvdW50SWQgPSAke2djX3Byb3BzLmFjY291bnRJZH1gKTtcblx0Ly8gXHRcdFx0Ly8gXHQkeXdfYWNjb3VudCA9IEhfQUNDT1VOVFNbQWNjb3VudC5yZWZGcm9tSWQoZ2NfcHJvcHMuYWNjb3VudElkIGFzIHN0cmluZyldO1xuXHQvLyBcdFx0XHQvLyB9XG5cblx0Ly8gXHRcdFx0JHl3X3NjcmVlbl9kb20gPSBrc19kc3QuZG9tO1xuXG5cdC8vIFx0XHRcdC8vIHRyaWdnZXIgY29tcG9uZW50IHNldHRpbmdzXG5cdC8vIFx0XHRcdGNvbnN0IGZrX2Fycml2ZSA9IGhtX2Fycml2YWxzLmdldChrc19kc3QuZG9tKTtcblx0Ly8gXHRcdFx0aWYoZmtfYXJyaXZlKSBma19hcnJpdmUoKTtcblxuXHQvLyBcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblx0Ly8gXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jKGZrX3Jlc29sdmUpID0+IHtcblx0Ly8gXHRcdFx0XHQvLyByZWYgc3JjIHN0YXRlJ3MgZG9tXG5cdC8vIFx0XHRcdFx0bGV0IGRtX3NyYyA9IGtzX3NyYy5kb207XG5cblx0Ly8gXHRcdFx0XHQvLyByZWYgY2xhc3NsaXN0XG5cdC8vIFx0XHRcdFx0Y29uc3QgZF9jbGFzc19saXN0ID0gZG1fc3JjLmNsYXNzTGlzdDtcblxuXHQvLyBcdFx0XHRcdC8vIHNob3J0IGNpcmN1aXQgZXhwZW5zaXZlIGNvbXB1dGVkIHN0eWxlIGNhbGxcblx0Ly8gXHRcdFx0XHRsZXQgYl90cmFuc2l0aW9ucyA9IGZhbHNlO1xuXHQvLyBcdFx0XHRcdGlmKCdnb3RvJyA9PT0gc190cmFuc2l0aW9uKSB7XG5cdC8vIFx0XHRcdFx0XHRpZihkX2NsYXNzX2xpc3QuY29udGFpbnMoJ3NsaWRlcycpKSB7XG5cdC8vIFx0XHRcdFx0XHRcdC8vIGNoYW5naW5nIHRocmVhZHNcblx0Ly8gXHRcdFx0XHRcdFx0aWYoc2lfdGhyZWFkX3NyYykge1xuXHQvLyBcdFx0XHRcdFx0XHRcdGRtX3NyYyA9IGRtX3NyYy5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG5cdC8vIFx0XHRcdFx0XHRcdFx0ZG1fZXhpdHRpbmcucmVwbGFjZUNoaWxkcmVuKGRtX3NyYyk7XG5cdC8vIFx0XHRcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdFx0XHRkbV9zcmMuc3R5bGUuekluZGV4ID0gJzEwMDEnO1xuXG5cdC8vIFx0XHRcdFx0XHRcdGF3YWl0IHRpbWVvdXQoMCk7XG5cblx0Ly8gXHRcdFx0XHRcdFx0Ly8gZG1fc3JjLnN0eWxlLmxlZnQgPSBgLSR7WFBfQVBQX1dJRFRIfXB4YDtcblx0Ly8gXHRcdFx0XHRcdFx0ZG1fc3JjLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoLSR7WFBfQVBQX1dJRFRIfXB4KWA7XG5cdC8vIFx0XHRcdFx0XHRcdGJfdHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdFx0ZWxzZSB7XG5cdC8vIFx0XHRcdFx0XHRcdGNvbnN0IHNpX2V4aXQgPSBkbV9zcmMuZ2V0QXR0cmlidXRlKCdkYXRhLXMyLWV4aXQnKSBhcyBzdHJpbmc7XG5cblx0Ly8gXHRcdFx0XHRcdFx0c3dpdGNoKHNpX2V4aXQpIHtcblx0Ly8gXHRcdFx0XHRcdFx0XHRjYXNlICdzd2lwZXMnOiB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRkbV9zcmMuc3R5bGUubGVmdCA9IGAtJHtYUF9BUFBfV0lEVEh9cHhgO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0ZG1fc3JjLnN0eWxlLnpJbmRleCA9ICcxMDAxJztcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGJfdHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdC8vIFx0XHRcdFx0XHRcdFx0fVxuXG5cdC8vIFx0XHRcdFx0XHRcdFx0Y2FzZSAnbGVhdmVzJzoge1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0Ly8gY2hhbmdpbmcgdGhyZWFkc1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0aWYoc2lfdGhyZWFkX3NyYykge1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0XHRkbV9zcmMgPSBkbV9zcmMuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50O1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0XHRkbV9leGl0dGluZy5yZXBsYWNlQ2hpbGRyZW4oZG1fc3JjKTtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdFx0XHRcdFx0ZG1fc3JjLnN0eWxlLnpJbmRleCA9ICcxMDAxJztcblxuXHQvLyBcdFx0XHRcdFx0XHRcdFx0YXdhaXQgdGltZW91dCgwKTtcblxuXHQvLyBcdFx0XHRcdFx0XHRcdFx0Ly8gZG1fc3JjLnN0eWxlLmxlZnQgPSBgLSR7WFBfQVBQX1dJRFRIfXB4YDtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGRtX3NyYy5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKC0ke1hQX0FQUF9XSURUSH1weClgO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0Yl90cmFuc2l0aW9ucyA9IHRydWU7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0Ly8gXHRcdFx0XHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHRjYXNlICdyZXZlYWxzJzoge1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0ZG1fc3JjLmNsYXNzTGlzdC5hZGQoJ3JldmVhbCcpO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0Yl90cmFuc2l0aW9ucyA9IHRydWU7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0Ly8gXHRcdFx0XHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgYXR0cmlidXRlIHZhbHVlOiBcIiR7c2lfZXhpdCA/PyAnJ31cImApO1xuXHQvLyBcdFx0XHRcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdC8vIG5vdCBjaGFuZ2luZyB0aHJlYWRzXG5cdC8vIFx0XHRcdFx0aWYoIXNpX3RocmVhZF9zcmMpIHtcblx0Ly8gXHRcdFx0XHRcdC8vIC8vIHNyYyBsZWF2ZXNcblx0Ly8gXHRcdFx0XHRcdC8vIGlmKGRfY2xhc3NfbGlzdC5jb250YWlucygnbGVhdmVzJykpIHtcblx0Ly8gXHRcdFx0XHRcdC8vIFx0ZG1fc3JjLnN0eWxlLmxlZnQgPSBgLSR7WFBfQVBQX1dJRFRIfXB4YDtcblx0Ly8gXHRcdFx0XHRcdC8vIFx0ZG1fc3JjLnN0eWxlLnpJbmRleCA9ICcxMDAxJztcblx0Ly8gXHRcdFx0XHRcdC8vIFx0Yl90cmFuc2l0aW9ucyA9IHRydWU7XG5cdC8vIFx0XHRcdFx0XHQvLyB9XG5cblx0Ly8gXHRcdFx0XHRcdC8vIHNyYyBzbGlkZXMgb3V0XG5cdC8vIFx0XHRcdFx0XHRpZihkX2NsYXNzX2xpc3QuY29udGFpbnMoJ3NsaWRlcycpKSB7XG5cdC8vIFx0XHRcdFx0XHRcdGJfdHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHQvLyBjaGFuZ2luZyB0aHJlYWRzXG5cdC8vIFx0XHRcdFx0ZWxzZSB7XG5cdC8vIFx0XHRcdFx0XHQvLyBnb2luZyB0byBzZWFyY2hcblx0Ly8gXHRcdFx0XHRcdGlmKCcvc2VhcmNoJyA9PT0ga3NfZHN0LnBhdHRlcm4pIHtcblx0Ly8gXHRcdFx0XHRcdFx0ZG1fc3JjLmNsYXNzTGlzdC5hZGQoJ3N1YmxpbWF0ZScpO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdFx0Ly8gbGVhdmluZyBzZWFyY2hcblx0Ly8gXHRcdFx0XHRcdGVsc2UgaWYoJy9zZWFyY2gnID09PSBrc19zcmMucGF0dGVybikge1xuXHQvLyBcdFx0XHRcdFx0XHRrc19kc3QuZG9tLmNsYXNzTGlzdC5yZW1vdmUoJ3N1YmxpbWF0ZScpO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdC8vIFxuXHQvLyBcdFx0XHRcdGF3YWl0IG1pY3JvdGFzaygpO1xuXG5cdC8vIFx0XHRcdFx0Ly8gZWxlbWVudCBpcyB0cmFuc2l0aW9uaW5nXG5cdC8vIFx0XHRcdFx0aWYoIXNfdHJhbnNpdGlvbi5lbmRzV2l0aCgnLmJ5cGFzcycpKSB7XG5cdC8vIFx0XHRcdFx0XHRpZihiX3RyYW5zaXRpb25zIHx8IFNYX05PX1RSQU5TSVRJT04gIT09IGdldENvbXB1dGVkU3R5bGUoZG1fc3JjKS50cmFuc2l0aW9uKSB7XG5cdC8vIFx0XHRcdFx0XHRcdC8vIHdhaXQgZm9yIHRyYW5zaXRpb24gdG8gZW5kXG5cdC8vIFx0XHRcdFx0XHRcdGRtX3NyYy5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gdHJhbnNpdGlvbl9lbmQoZF9ldmVudCkge1xuXHQvLyBcdFx0XHRcdFx0XHRcdC8vIG5vdCBhIHBvc2l0aW9uIHByb3BlcnR5XG5cdC8vIFx0XHRcdFx0XHRcdFx0aWYoJ3RyYW5zZm9ybScgIT09IGRfZXZlbnQucHJvcGVydHlOYW1lKSByZXR1cm47XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHQvLyByZW1vdmUgc2VsZlxuXHQvLyBcdFx0XHRcdFx0XHRcdGRtX3NyYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdHJhbnNpdGlvbl9lbmQpO1xuXG5cdC8vIFx0XHRcdFx0XHRcdFx0Ly8gcmVzb2x2ZVxuXHQvLyBcdFx0XHRcdFx0XHRcdGZrX3Jlc29sdmUoKTtcblx0Ly8gXHRcdFx0XHRcdFx0fSk7XG5cblx0Ly8gXHRcdFx0XHRcdFx0Ly8gd2FpdCBmb3IgY2FsbGJhY2tcblx0Ly8gXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHQvLyBcdFx0XHRcdFx0fVxuXHQvLyBcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdGZrX3Jlc29sdmUoKTtcblx0Ly8gXHRcdFx0fSk7XG5cdC8vIFx0XHR9LFxuXHQvLyBcdH0pKTtcblx0fSk7XG5cdFxuPC9zY3JpcHQ+XG5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0LmZ1bGwoQHR5cGUpIHtcblx0XHRwb3NpdGlvbjogQHR5cGU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG5cblx0LmZ1bGwoYWJzb2x1dGUpIHtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0fVxuXG5cdC52aWV3cG9ydCB7XG5cdFx0LmZ1bGwocmVsYXRpdmUpO1xuXHRcdG92ZXJmbG93OiBoaWRkZW47XG5cblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXG5cdFx0Pi5jb250ZW50IHtcblx0XHRcdC5mdWxsKHJlbGF0aXZlKTtcblx0XHRcdG92ZXJmbG93OiBoaWRkZW47XG5cblx0XHRcdHdpZHRoOiAxMDAlO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXG5cdFx0XHQmLmV4aXR0aW5nIHtcblx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHR0b3A6IDA7XG5cdFx0XHRcdHotaW5kZXg6IDEwMDE7XG5cdFx0XHRcdHVzZXItc2VsZWN0OiBub25lO1xuXHRcdFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRcdH1cblxuXHRcdFx0Pi50aHJlYWQge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHQuZnVsbChhYnNvbHV0ZSk7XG5cdFx0XHRcdFx0cGFkZGluZy1sZWZ0OiBjYWxjKDUwdncgLSAodmFyKC0tYXBwLW1heC13aWR0aCkgLyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyA6Z2xvYmFsKCY+c2VjdGlvbikge1xuXHRcdFx0Ly8gXHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHQvLyBcdHRvcDogMHB4O1xuXHRcdFx0Ly8gXHR0cmFuc2l0aW9uOiBsZWZ0IDAuNnMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdFx0Ly8gfVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPG1haW4gY2xhc3M9XCJ2aWV3cG9ydFwiIGJpbmQ6dGhpcz17ZG1fdmlld3BvcnR9PlxuXHQ8ZGl2IGNsYXNzPVwiY29udGVudCB0aHJlYWRzXCIgYmluZDp0aGlzPXtkbV90aHJlYWRzfSAvPlxuXHQ8ZGl2IGNsYXNzPVwiY29udGVudCBleGl0dGluZ1wiIGJpbmQ6dGhpcz17ZG1fZXhpdHRpbmd9IC8+XG5cdDxzbG90Pjwvc2xvdD5cblxuXHQ8UHJvZ3Jlc3NTdmVsdGUgLz5cblx0XG5cdHsjaWYgYl9tYWlufVxuXHRcdHsjYXdhaXQgVmF1bHQuZ2V0Um9vdEtleSgpIHRoZW4gZGtfcm9vdH1cblx0XHRcdHsjaWYgZGtfcm9vdH1cblx0XHRcdFx0PE92ZXJzY3JvbGxTdmVsdGUgLz5cblx0XHRcdFx0PE5hdlN2ZWx0ZSAvPlxuXHRcdFx0XHQ8U2VhcmNoU3ZlbHRlIC8+XG5cdFx0XHRcdDxWZW5kb3JNZW51U3ZlbHRlIC8+XG5cdFx0XHRcdDxTaWRlTWVudVN2ZWx0ZSAvPlxuXHRcdFx0XHQ8UG9wdXBTdmVsdGUgLz5cblx0XHRcdHsvaWZ9XG5cdFx0ey9hd2FpdH1cblx0ey9pZn1cbjwvbWFpbj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCBMb2csIHsgTG9nZ2VyIH0gZnJvbSAnIy9hcHAvdWkvTG9nLnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHsgVmF1bHQgfSBmcm9tICcjL2NyeXB0by92YXVsdCc7XG5cdGltcG9ydCB0eXBlIHsgQ29tcGxldGVkIH0gZnJvbSAnIy9lbnRyeS9mbG93JztcblxuXHRpbXBvcnQge1xuXHRcdEFUVThfRFVNTVlfUEhSQVNFLFxuXHRcdEFUVThfRFVNTVlfVkVDVE9SLFxuXHRcdGxvZ2luLFxuXHRcdENvcnJ1cHRlZFZhdWx0RXJyb3IsXG5cdFx0SW52YWxpZFBhc3NwaHJhc2VFcnJvcixcblx0XHRSZWNvdmVyYWJsZVZhdWx0RXJyb3IsXG5cdFx0VW5yZWdpc3RlcmVkRXJyb3IsXG5cdH0gZnJvbSAnIy9zaGFyZS9hdXRoJztcblxuXHRpbXBvcnQgeyBTY3JlZW4sIHR5cGUgUGFnZSB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnIy9hcHAvdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcblx0aW1wb3J0IEZpZWxkIGZyb20gJyMvYXBwL3VpL0ZpZWxkLnN2ZWx0ZSc7XG5cdGltcG9ydCB7IHNsaWRlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXG5cdC8vIHdpbGwgYmUgc2V0IGlmIHBhcnQgb2YgZmxvd1xuXHRjb25zdCBjb21wbGV0ZWQgPSBnZXRDb250ZXh0PENvbXBsZXRlZCB8IHVuZGVmaW5lZD4oJ2NvbXBsZXRlZCcpO1xuXG5cdC8vIHBhc3N3b3JkIHZhbHVlIGJpbmRpbmdcblx0bGV0IHNoX3Bhc3N3b3JkID0gJyc7XG5cblx0Ly8gcGFzc3dvcmQgZXJyb3Jcblx0bGV0IHNfZXJyX3Bhc3N3b3JkID0gJyc7XG5cblx0Ly8gYnVzeSBhdHRlbXB0aW5nIHVubG9ja1xuXHRsZXQgYl9idXN5ID0gZmFsc2U7XG5cblxuXHRsZXQgeHRfc3RhcnQgPSAwO1xuXHRsZXQga19sb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cdGZ1bmN0aW9uIGxvZyhzX21zZzogc3RyaW5nKSB7XG5cdFx0a19sb2dnZXIgPSBrX2xvZ2dlci5ldmVudChzX21zZywgRGF0ZS5ub3coKSAtIHh0X3N0YXJ0KTtcblx0fVxuXG5cdGFzeW5jIGZ1bmN0aW9uIGF0dGVtcHRfdW5sb2NrKGJfcmVjb3Zlcj1mYWxzZSk6IFByb21pc2U8MT4ge1xuXHRcdC8vIGRvIG5vdCBpbnRlcnVwdDsgbG9ja1xuXHRcdGlmKGJfYnVzeSkgcmV0dXJuIDE7IGJfYnVzeSA9IHRydWU7XG5cblx0XHQvLyBwcmVwIGdyYWNlZnVsIGV4aXRcblx0XHRjb25zdCBleGl0ID0gKCk6IDEgPT4gKGJfYnVzeSA9IGZhbHNlLCAxKTtcblxuXHRcdC8vIHJlc2V0IGVycm9yXG5cdFx0c19lcnJfcGFzc3dvcmQgPSAnJztcblxuXHRcdC8vIHN0YXJ0IHRpbWVyXG5cdFx0eHRfc3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0bG9nKCdFc3RpbWF0aW5nIHRpbWUgdG8gY29tcGxldGUnKTtcblxuXHRcdC8vIGVzdGltYXRlIHRpbWUgdG8gY29tcGxldGVcblx0XHR7XG5cdFx0XHRjb25zdCB4dF9zdGFydF9lc3QgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHRhd2FpdCBWYXVsdC5kZXJpdmVSb290Qml0cyhBVFU4X0RVTU1ZX1BIUkFTRSwgQVRVOF9EVU1NWV9WRUNUT1IsIDEgLyA1MCk7XG5cdFx0XHRjb25zdCB4dF9maW5pc2hfZXN0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0XHRjb25zdCB4dF9lbGFwc2VkID0geHRfZmluaXNoX2VzdCAtIHh0X3N0YXJ0X2VzdDtcblx0XHRcdGNvbnN0IHh0X2VzdGltYXRlID0gKDIgKiAoeHRfZWxhcHNlZCAqIDUwKSk7XG5cdFx0XHRsb2coYEFib3V0ICR7KHh0X2VzdGltYXRlIC8gMTAwMCkudG9GaXhlZCgxKX0gc2Vjb25kc2ApO1xuXHRcdH1cblxuXHRcdC8vIGF0dGVtcHQgbG9naW5cblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgbG9naW4oc2hfcGFzc3dvcmQsIGJfcmVjb3ZlciwgbG9nKTtcblx0XHR9XG5cdFx0Ly8gaGFuZGxlIGVycm9yXG5cdFx0Y2F0Y2goZV9sb2dpbikge1xuXHRcdFx0aWYoZV9sb2dpbiBpbnN0YW5jZW9mIFVucmVnaXN0ZXJlZEVycm9yKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gJ05vIGFjY291bnRzIGRldGVjdGVkJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZV9sb2dpbiBpbnN0YW5jZW9mIEludmFsaWRQYXNzcGhyYXNlRXJyb3IpIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSAnSW52YWxpZCBwYXNzcGhyYXNlJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZV9sb2dpbiBpbnN0YW5jZW9mIFJlY292ZXJhYmxlVmF1bHRFcnJvcikge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9ICdWYXVsdCBpcyBwYXJ0aWFsbHkgY29ycnVwdGVkOyBhdHRlbXB0aW5nIHJlY292ZXJ5Li4uJztcblx0XHRcdFx0cmV0dXJuIGF3YWl0IGF0dGVtcHRfdW5sb2NrKHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihiX3JlY292ZXIpIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSBgUmVjb3ZlcnkgZmFpbGVkLiBWYXVsdCBtYXkgYmUgaXJyZXBhcmFibHkgY29ycnVwdGVkLlxcbiR7ZV9sb2dpbi5tZXNzYWdlIX1gO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihlX2xvZ2luIGluc3RhbmNlb2YgQ29ycnVwdGVkVmF1bHRFcnJvcikge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9IGBWYXVsdCBhcHBlYXJzIHRvIGJlIGlycmVwYXJhYmx5IGNvcnJ1cHRlZC5cXG4ke2VfbG9naW4ubWVzc2FnZX1gO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gYFVua25vd24gZXJyb3Igb2NjdXJyZWQ6ICR7ZV9sb2dpbi5zdGFjayB8fCBlX2xvZ2luLm1lc3NhZ2V9YDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZXhpdFxuXHRcdFx0cmV0dXJuIGV4aXQoKTtcblx0XHR9XG5cblx0XHQvLyBzdWNjZXNzXG5cdFx0aWYoY29tcGxldGVkKSBjb21wbGV0ZWQodHJ1ZSk7XG5cblx0XHQvLyBleGl0XG5cdFx0cmV0dXJuIGV4aXQoKTtcblx0fVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0LndlbGNvbWUge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdFx0Z2FwOiAyMHB4O1xuXHRcdFx0cGFkZGluZy1sZWZ0OiAxNnB4O1xuXHRcdFx0cGFkZGluZy1yaWdodDogMTZweDtcblx0XHRcdGJhY2tncm91bmQtaW1hZ2U6IHVybCgnL21lZGlhL3ZlbmRvci9vcmItMS5zdmcnKTtcblx0XHRcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG5cdFx0XHRiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgdG9wO1xuXHRcdFx0YmFja2dyb3VuZC1zaXplOiBjb3Zlcjtcblx0XHRcdHBhZGRpbmctdG9wOiBjYWxjKDUwdmggLSAyMDBweCk7XG5cdFx0fVxuXG5cdFx0PmRpdiB7XG5cdFx0XHQmLmxvZ28sJi50aXRsZSB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1hcmdpbi1sZWZ0OiBhdXRvICFpbXBvcnRhbnQ7XG5cdFx0XHRcdFx0bWFyZ2luLXJpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXG5cdC5sYXJnZSB7XG5cdFx0LmZvbnQoYmlnKTtcblx0fVxuXG5cdHAge1xuXHRcdC5mb250KHJlZ3VsYXIpO1xuXHRcdHBhZGRpbmc6IDhweCAwO1xuXHR9XG5cblx0LmxpbmUge1xuXHRcdHdpZHRoOiBjYWxjKDEwMCUgLSA0MHB4KTtcblx0XHRoZWlnaHQ6IDFweDtcblx0XHRiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoNTAlIDUwJSBhdCA1MCUgNTAlLCAjRkZDNzAwIDAlLCByZ2JhKDI1NSwgMTk5LCAwLCAwKSAxMDAlKTtcblx0fVxuXG5cdC5hY3Rpb25zLWxpbmUge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHR9XG5cblx0Lm9mZi1zY3JlZW4ge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IGNhbGModmFyKC0tYXBwLXdpbmRvdy13aWR0aCkgKiAxMDApO1xuXHR9XG48L3N0eWxlPlxuXG57I2lmIGZhbHNlfVxuXHQ8c3BhblxuXHRcdGNsYXNzOndlbGNvbWU9e3RydWV9XG5cdC8+XG57L2lmfVxuXG48U2NyZWVuIGRlYnVnPSdBdXRoZW50aWNhdGUnIGNsYXNzTmFtZXM9J3dlbGNvbWUnPlxuXHQ8ZGl2IGNsYXNzPVwibG9nb1wiPlxuXHRcdDxpbWcgd2lkdGg9XCI5NlwiIHNyYz1cIi9tZWRpYS92ZW5kb3IvbG9nby05NnB4LnBuZ1wiIHNyY3NldD1cIi9tZWRpYS92ZW5kb3IvbG9nby05NnB4LnBuZyAxeCwgL21lZGlhL3ZlbmRvci9sb2dvLTE5MnB4LnBuZyAyeFwiIGFsdD1cIlN0YXJTaGVsbFwiIC8+XG5cdDwvZGl2PlxuXG5cdDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxuXHRcdDxpbWcgc3JjPVwiL21lZGlhL3ZlbmRvci90aXRsZS5zdmdcIiBhbHQ9XCJcIiAvPlxuXHQ8L2Rpdj5cblxuXHQ8ZGl2IGNsYXNzPVwibGluZVwiPiZuYnNwOzwvZGl2PlxuXG5cdDxkaXYgY2xhc3M9XCJmb3JtIGZsZXgtcm93c1wiPlxuXHRcdDxGaWVsZCBrZXk9XCJwYXNzd29yZFwiIG5hbWU9XCJcIj5cblx0XHRcdDxpbnB1dFxuXHRcdFx0XHR0eXBlPVwicGFzc3dvcmRcIlxuXHRcdFx0XHRuYW1lPVwicGFzc3dvcmRcIlxuXHRcdFx0XHRwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCJcblx0XHRcdFx0YmluZDp2YWx1ZT17c2hfcGFzc3dvcmR9XG5cdFx0XHRcdGNsYXNzOmludmFsaWQ9e3NfZXJyX3Bhc3N3b3JkfVxuXHRcdFx0Lz5cblxuXHRcdFx0eyNpZiBzX2Vycl9wYXNzd29yZH1cblx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiIHRyYW5zaXRpb246c2xpZGU9e3tkdXJhdGlvbjozMDB9fT5cblx0XHRcdFx0XHR7c19lcnJfcGFzc3dvcmR9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9pZn1cblx0XHQ8L0ZpZWxkPlxuXHQ8L2Rpdj5cblxuXHQ8QWN0aW9uc0xpbmUgY29uZmlybT17WydVbmxvY2snLCBhdHRlbXB0X3VubG9ja119IC8+XG5cblx0PExvZyBiaW5kOml0ZW1zPXtrX2xvZ2dlci5pdGVtc30gaGlkZSAvPlxuXG48L1NjcmVlbj5cbiIsImltcG9ydCB7IGRkLCBxcyB9IGZyb20gJyMvdXRpbC9kb20nO1xuXG4vLyBzZWxlY3QgZG9tIGxvZyBlbGVtZW50c1xuZXhwb3J0IGNvbnN0IGRtX2xvZyA9IHFzKGRvY3VtZW50LCAnc2VjdGlvbiNkb20tbG9nJyk7XG5leHBvcnQgY29uc3QgZG1fbG9nX2xpc3QgPSBxcyhkb2N1bWVudCwgJyNkb20tbG9nLWxpc3QnKTtcblxuLyoqXG4gKiBMb2dzIGEgbWVzc2FnZSB0byB0aGUgY29uc29sZSBhbmQgdG8gRE9NIGFzIGEgZmFsbGJhY2sgZm9yIHVuaGFuZGxlZCBlcnJvcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvbWxvZyhzaV9tc2c6IHN0cmluZyk6IHZvaWQge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRjb25zb2xlLmxvZyhzaV9tc2cpO1xuXG5cdGRtX2xvZ19saXN0Py5hcHBlbmQoZGQoJ2xpJywge30sIFtcblx0XHRkZCgncHJlJywge30sIFtzaV9tc2ddKSxcblx0XSkpO1xufVxuIiwiPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5ob3Jpem9uIHtcblx0XHR3aWR0aDogY2FsYygxMDAlIC0gNDBweCk7XG5cdFx0aGVpZ2h0OiAxcHg7XG5cdFx0YmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KDUwJSA1MCUgYXQgNTAlIDUwJSwgI0ZGQzcwMCAwJSwgcmdiYSgyNTUsIDE5OSwgMCwgMCkgMTAwJSk7XG5cblx0XHRtYXJnaW4tbGVmdDogYXV0bztcblx0XHRtYXJnaW4tcmlnaHQ6IGF1dG87XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJuby1tYXJnaW4gaG9yaXpvblwiPntAaHRtbCAnJm5ic3A7J308L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IFNjcmVlbiB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcuLi91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuXHRpbXBvcnQgUmVnaXN0ZXIgZnJvbSAnLi9SZWdpc3Rlci5zdmVsdGUnO1xuXHRpbXBvcnQgU3RhclNoZWxsTG9nbyBmcm9tICcuLi91aS9TdGFyU2hlbGxMb2dvLnN2ZWx0ZSc7XG5cdGltcG9ydCBTdGFyU2hlbGxUaXRsZSBmcm9tICcuLi91aS9TdGFyU2hlbGxUaXRsZS5zdmVsdGUnO1xuXHRpbXBvcnQgSG9yaXpvbiBmcm9tICcuLi91aS9Ib3Jpem9uLnN2ZWx0ZSc7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0Omdsb2JhbCgucHJlcmVnaXN0ZXIpIHtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRnYXA6IDIwcHg7XG5cdFx0cGFkZGluZy1sZWZ0OiAxNnB4O1xuXHRcdHBhZGRpbmctcmlnaHQ6IDE2cHg7XG5cdFx0YmFja2dyb3VuZC1pbWFnZTogdXJsKCcvbWVkaWEvdmVuZG9yL29yYi0xLnN2ZycpO1xuXHRcdGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XG5cdFx0YmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIHRvcDtcblx0XHRiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xuXG5cdFx0cGFkZGluZy10b3A6IGNhbGMoNTB2aCAtIDE1MHB4KTtcblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbiByb290IGNsYXNzTmFtZXM9J3ByZXJlZ2lzdGVyJz5cblx0PFN0YXJTaGVsbExvZ28gZGltPXs5Nn0gLz5cblxuXHQ8U3RhclNoZWxsVGl0bGUgLz5cblxuXHQ8SG9yaXpvbiAvPlxuXG5cdDxkaXYgY2xhc3M9XCJsYXJnZVwiPlxuXHRcdDxkaXY+V2VsY29tZSB0byB0aGUgYmV0YSBwcm9ncmFtLjwvZGl2PlxuXHRcdDxkaXY+VGhhbmsgZm9yIHlvdSBiZWluZyBhIHRlc3RlciE8L2Rpdj5cblx0PC9kaXY+XG5cblx0PHA+XG5cdFx0XG5cdDwvcD5cblxuXHQ8QWN0aW9uc0xpbmUgY29uZmlybT17WydHZXQgU3RhcnRlZCddfSBjb250ZD17e2NyZWF0b3I6UmVnaXN0ZXJ9fSAvPlxuPC9TY3JlZW4+XG4iXSwibmFtZXMiOlsiY3JlYXRlX2lmX2Jsb2NrIiwiY3R4IiwiY3JlYXRlX2lmX2Jsb2NrXzMiLCJjcmVhdGVfaWZfYmxvY2tfNCIsImNyZWF0ZV9pZl9ibG9ja181IiwiY3JlYXRlX2lmX2Jsb2NrXzIiLCJjcmVhdGVfaWZfYmxvY2tfMSIsInNlYXJjaCIsImNsaWNrX2hhbmRsZXIiLCJwIiwiUmVnaXN0ZXJXZWFrUGFzc3dvcmRTdmVsdGUiLCJyZWdpc3RlciIsImdfdG9rZW4iLCJTWF9JQ09OX1BFUlNPTkFMIiwic2lfdmVyc3VzIiwiYXBwZW5kXzEiLCJhcHBlbmQiLCJmdW5jXzEiLCJUaHJlYWRJZCIsIkJsYW5rU3ZlbHRlIiwiUmVnaXN0ZXJTdmVsdGUiLCJIb2xkaW5nc0hvbWVTdmVsdGUiLCJDb250YWN0c0hvbWVTdmVsdGUiLCJIaXN0b3J5SG9tZVN2ZWx0ZSIsIk5ldHdvcmtzSG9tZVN2ZWx0ZSIsIkFjY291bnRIb21lU3ZlbHRlIiwiU2l0ZXNIb21lU3ZlbHRlIiwiaWQiLCJvYmoiLCJwYXRoIiwibm9ybSIsInZhbHVlIiwidGV4dCIsInNjb3JlIiwicGF0dGVybiIsInJlc3VsdCIsIml0ZW0iLCJzZWFyY2hlcnMiLCJxdWVyeSIsIkNsYXNzVHlwZSIsInNsaWRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsTUFBTSxJQUFJLFNBQVMsV0FBVztBQUMxQixRQUFNLFVBQVUsU0FBUyxjQUFjLE1BQU0sRUFBRTtBQUMvQyxNQUFJLFdBQVcsUUFBUSxZQUFZLFFBQVEsU0FBUyxlQUFlLEdBQUc7QUFDbEU7QUFBQSxFQUNIO0FBQ0QsYUFBVyxRQUFRLFNBQVMsaUJBQWlCLDJCQUEyQixHQUFHO0FBQ3ZFLG1CQUFlLElBQUk7QUFBQSxFQUN0QjtBQUNELE1BQUksaUJBQWlCLENBQUMsY0FBYztBQUNoQyxlQUFXLFlBQVksV0FBVztBQUM5QixVQUFJLFNBQVMsU0FBUyxhQUFhO0FBQy9CO0FBQUEsTUFDSDtBQUNELGlCQUFXLFFBQVEsU0FBUyxZQUFZO0FBQ3BDLFlBQUksS0FBSyxZQUFZLFVBQVUsS0FBSyxRQUFRO0FBQ3hDLHlCQUFlLElBQUk7QUFBQSxNQUMxQjtBQUFBLElBQ0o7QUFBQSxFQUNULENBQUssRUFBRSxRQUFRLFVBQVUsRUFBRSxXQUFXLE1BQU0sU0FBUyxLQUFJLENBQUU7QUFDdkQsV0FBUyxhQUFhLFFBQVE7QUFDMUIsVUFBTSxZQUFZLENBQUE7QUFDbEIsUUFBSSxPQUFPO0FBQ1AsZ0JBQVUsWUFBWSxPQUFPO0FBQ2pDLFFBQUksT0FBTztBQUNQLGdCQUFVLGlCQUFpQixPQUFPO0FBQ3RDLFFBQUksT0FBTyxnQkFBZ0I7QUFDdkIsZ0JBQVUsY0FBYztBQUFBLGFBQ25CLE9BQU8sZ0JBQWdCO0FBQzVCLGdCQUFVLGNBQWM7QUFBQTtBQUV4QixnQkFBVSxjQUFjO0FBQzVCLFdBQU87QUFBQSxFQUNWO0FBQ0QsV0FBUyxlQUFlLE1BQU07QUFDMUIsUUFBSSxLQUFLO0FBRUw7QUFDSixTQUFLLEtBQUs7QUFFVixVQUFNLFlBQVksYUFBYSxJQUFJO0FBQ25DLFVBQU0sS0FBSyxNQUFNLFNBQVM7QUFBQSxFQUM3QjtBQUNMO0FBQXNCLEVBQUc7Ozs7Ozs7Ozs7QUMxQ3pCLGFBQWtDLFFBQUEsTUFBQSxNQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNvcEIvQixhQUVLLFFBQUEsS0FBQSxNQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUhELE1BQUEsV0FBQSxVQUFVLElBQU8sT0FBQUEsa0JBQUEsR0FBQTs7Ozs7Ozs7Ozs2REFqQlAsSUFBVSxLQUFBLGdCQUFBO21DQVFYLElBQU8sRUFBQTs0QkFJYixJQUFLLEVBQUE7O21DQVhELElBQUk7cUNBQ0YsSUFBSTtrQ0FDUCxJQUFLLEVBQUE7dUNBQ0EsSUFBUSxFQUFBOzBDQUNMLElBQVcsRUFBQTt3Q0FDYixLQUFLO21DQUNWLElBQVEsRUFBQTs7a0NBVlAsSUFBUSxFQUFBO0FBQUE7O0FBRHZCLGFBMkJLLFFBQUEsS0FBQSxNQUFBO0FBeEJKLGFBdUJNLEtBQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTEEsVUFBQSxVQUFVQyxLQUFPLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEZBakJQQSxLQUFVLEtBQUEsbUJBQUE7Ozs7OEJBWWpCQSxLQUFLLEVBQUE7QUFBQTs7cUNBWEQsSUFBSTtBQUFBOzt1Q0FDRixJQUFJO0FBQUE7O29DQUNQQSxLQUFLLEVBQUE7QUFBQTs7eUNBQ0FBLEtBQVEsRUFBQTtBQUFBOzs0Q0FDTEEsS0FBVyxFQUFBO0FBQUE7OzBDQUNiLEtBQUs7QUFBQTs7cUNBQ1ZBLEtBQVEsRUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBR1QsYUFBTyxLQUFTLFFBQVEsZUFBYzs7Ozs7Ozs7QUFob0J2QyxNQUFBLEVBQUEsTUFBTSxNQUFLLElBQUE7QUFDaEIsUUFBQSxRQUFRO0FBRUgsTUFBQSxFQUFBLFFBQVEsR0FBRSxJQUFBO0FBQ1YsTUFBQSxFQUFBLFdBQW9DLEtBQUksSUFBQTtBQUN4QyxNQUFBLEVBQUEsT0FBTyxNQUFLLElBQUE7QUFDWixNQUFBLEVBQUEsUUFBUSxNQUFLLElBQUE7QUFDYixNQUFBLEVBQUEsYUFBYSxHQUFFLElBQUE7UUFHcEIsU0FBUyxXQUFpQixNQUFNO0FBRTNCLE1BQUEsRUFBQSxTQUFTLE1BQUssSUFBQTtBQUNkLE1BQUEsRUFBQSxTQUFTLE1BQUssSUFBQTtBQUNkLE1BQUEsRUFBQSxPQUFPLE1BQU0sT0FBTyxNQUFLLElBQUE7QUFDekIsTUFBQSxFQUFBLFNBQVUsQ0FBQSxVQUFXLENBQUEsV0FBVyxLQUFJLElBQUE7QUFDekMsUUFBQSxXQUFXO0FBRU4sTUFBQSxFQUFBLE9BQU8sTUFBSyxJQUFBO0FBR1osTUFBQSxFQUFBLGNBQWMsTUFBSyxJQUFBO01BRTFCO0FBR0EsTUFBQSxVQUE4QjtRQUU1QixVQUFVLFNBQVEsV0FBVSxTQUFRLFdBQVU7QUFFOUIsd0JBQXFCO0FBQzNDLFVBQU8sTUFBQTtTQUNGLFFBQU07QUFDVCxjQUFRLEtBQVEsR0FBQSxTQUFTLHVDQUFTO0FBQUE7QUFJbEMsYUFBTyxHQUFFO0FBQUEsUUFFUixRQUFLO0FBRUosMEJBQUEsZ0JBQUEsa0JBQWtCLE9BQUssZUFBQTtBQUFBOzs7UUE4Q3ZCLE9BQUs7QUFDSCxVQUFBLGVBQWU7QUFHZCxVQUFBLHdCQUF1QixnQkFBVztBQUVuQyxZQUFBLFlBQVksSUFBSSxXQUFXLFFBQU07O0FBRWxDLDJCQUFlLFVBQVU7QUFBQSxtQkFDbEI7O1FBR0QsV0FBQSxZQUFZLElBQUksYUFBYSxRQUFNO2NBQ3ZDLFdBQVM7NEJBQ1gsVUFBVSxZQUFZLGNBQVksU0FBQTtBQUFBOztNQUdqQyxDQUFBLEVBQUEsUUFBUSxXQUNYLEVBQUEsV0FBVyxLQUFJLENBQUE7QUFBQTs7QUFLUCxNQUFBLEVBQUEsUUFBUSxHQUFFLElBQUE7Ozs7OztBQTBoQmtCLGdCQUFPOzs7Ozs7QUFUbEMsa0JBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkNubUJKLElBQVMsRUFBQTs7dUJBQ2hCLElBQUssRUFBQTtrREFBUSxJQUFVLEVBQUE7QUFBQSxhQUFBLEtBQUEsT0FBQSxhQUFBOzs7a0NBRlksSUFBSyxLQUFBLElBQUE7bUNBQWEsSUFBSyxLQUFBLElBQUE7QUFBQTs7QUFBckUsYUFHUyxRQUFBLFNBQUEsTUFBQTtBQUZSLGFBQTRELFNBQUEsTUFBQTs7QUFDNUQsYUFBcUMsU0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFuQzFCLElBQTRCLElBQUE7QUFDakMsUUFBQSxRQUFRO0FBS0gsTUFBQSxFQUFBLE1BQU0saUJBQWdCLElBQUE7QUFDM0IsUUFBQSxRQUFRO1FBRVIsUUFBUyxPQUFTLHNCQUEyQjtRQUU3QyxhQUFhLE1BQU0sS0FBSztBQUN4QixRQUFBLFlBQVksTUFBTSxRQUFRLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JDc0c3QixJQUFLLEVBQUE7Ozs7Ozs7Ozs7b0NBVE0sSUFBUyxFQUFBO0FBQUE7O0FBRHpCLGFBNEJLLFFBQUEsTUFBQSxNQUFBO0FBckJKLGFBb0JLLE1BQUEsSUFBQTtBQW5CSixhQWNLLE1BQUEsSUFBQTtBQWJKLGFBRUksTUFBQSxFQUFBOzs7QUFhTCxhQUVLLE1BQUEsSUFBQTs7Ozs7Ozs7Ozs7O3FCQWhCRkEsS0FBSyxFQUFBOzs7Ozs7Ozs7Ozs7OztzQ0FUTUEsS0FBUyxFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQWpHZixNQUFNLElBQWlCLElBQU87QUFFckMsU0FBQSxFQUFBLFVBQVU7Ozs7OztRQVpELE1BQWEsSUFBQTtBQUNiLE1BQUEsRUFBQSxPQUFPLEtBQUksSUFBQTtBQUlsQixNQUFBLFlBQVk7QUFDaEI7QUFBQTtBQUNDLG1CQUFBLEdBQUEsWUFBWSxJQUFJO0FBQUE7SUFDZDtBQUFBOztBQXFHRixpQkFBQSxHQUFBLFlBQVksS0FBSztBQUNqQixpQkFBQSxHQUFBLE9BQU8sS0FBSztBQUFBOzs7Ozs7Ozs7OztBQTNHWixzQkFBQSxTQUFFLFdBQVcsTUFBSSxRQUFBO0FBQUE7Ozs7Ozs7Ozs7QUNQbkIsSUFBZSxxQkFBQTtBQ0FmLElBQWUsaUJBQUE7QUNBZixJQUFlLGFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQzBaUTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU5wQixhQUlNLFFBQUEsTUFBQSxNQUFBO3VCQUhFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBZUQsSUFBUSxPQUFBLGtCQUFBLEdBQUE7Ozs7NEJBRlgsSUFBTzs7Ozs7Ozs7QUFEVCxhQUVNLFFBQUEsTUFBQSxNQUFBOzs7Ozs7O1VBQ0RBLEtBQVE7QUFBQSxpQkFBQSxFQUFBQSxNQUFBLEtBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUVSLElBQVE7Ozs7QUFEWixhQUVNLFFBQUEsTUFBQSxNQUFBO0FBQUE7Ozs7Ozs7Ozs7cUJBb0JBLElBQVM7Ozs7Ozs7aUJBUVgsSUFBbUIsTUFBQSxrQkFBQSxHQUFBOzs7Ozs7Ozs7Ozs7QUFaeEIsYUFVTSxRQUFBLE1BQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozt1RUFOQ0EsS0FBUyxFQUFBLEdBQUE7Ozs7Ozs7Ozs7O1VBUVhBLEtBQW1CLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQU5YLElBQVMsR0FBQSxHQUNmLElBQWlCLElBQUMsS0FBSyxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7O3FDQURqQkEsS0FBUyxHQUFBO0FBQUEsUUFDZixNQUFBLEtBQUEsV0FBQSxrQkFBQUEsU0FBa0IsS0FBSyxDQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQVFqQixJQUFtQixPQUFBLFFBQUE7K0JBQW5CLElBQW1CO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQ0FBbkJBLEtBQW1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNckIsTUFBQSxlQUFBLFFBQVUsUUFBTzs7bUNBQXRCLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUMsdUJBQUFBLFNBQVUsUUFBTzs7cUNBQXRCLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7OzhCQUFKLFFBQUksSUFBQSxZQUFBLFFBQUEsS0FBQSxHQUFBOzs7Ozs7Ozs7dUNBQUosUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXRixhQUVNLFFBQUEsTUFBQSxNQUFBO3VCQURFO0FBQUE7Ozs7Ozs7Ozs7QUFGSixNQUFBLFdBQUEsV0FBa0IsSUFBTyxPQUFBLGtCQUFBOzs7Ozs7Ozs7Ozs7O0FBQXpCLFVBQUFBLFlBQWtCQSxLQUFPLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQVJyQixJQUFPO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBTEMsS0FFckI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRlEsaUJBQUEsT0FBTyxLQUFJLEdBQUEsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBaUNmLElBQVc7Ozs7Ozs7aUJBU2IsSUFBbUIsTUFBQUMsb0JBQUEsR0FBQTs7Ozs7Ozs7Ozs7O0FBYnhCLGFBV00sUUFBQSxNQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7d0VBUENELEtBQVcsRUFBQSxHQUFBOzs7Ozs7Ozs7OztVQVNiQSxLQUFtQixJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFQWCxJQUFXLEdBQUEsR0FDakIsSUFBaUIsSUFBQyxJQUFJLENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7c0NBRGhCQSxLQUFXLEdBQUE7QUFBQSxRQUNqQixNQUFBLEtBQUEsV0FBQSxrQkFBQUEsU0FBa0IsSUFBSSxDQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQVNoQixJQUFtQixPQUFBLFFBQUE7K0JBQW5CLElBQW1CO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQ0FBbkJBLEtBQW1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ3JCLE1BQUEsYUFBQSxRQUFZLFFBQU87O2lDQUF4QixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFDLHFCQUFBQSxTQUFZLFFBQU87O21DQUF4QixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs0QkFBSixRQUFJLElBQUEsWUFBQSxRQUFBLEtBQUEsR0FBQTs7Ozs7Ozs7O3FDQUFKLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWUYsYUFFTSxRQUFBLE1BQUEsTUFBQTt1QkFERTtBQUFBOzs7Ozs7Ozs7O0FBRkosTUFBQSxXQUFBLFlBQW9CLElBQVMsT0FBQUUsb0JBQUE7Ozs7Ozs7Ozs7Ozs7QUFBN0IsVUFBQUYsYUFBb0JBLEtBQVMsS0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFRakIsT0FBQSxFQUFBLEtBQUEsY0FBYyxJQUFTLElBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFqQi9CLElBQVM7QUFBQSxvQkFDTCxJQUFTO0FBQUEsTUFDZixRQUFBLElBQVUsSUFBQSxPQUFPLG9CQUFvQjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBcEN6QixLQUV2QjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFGUSxpQkFBQSxTQUFTLEtBQUksR0FBQSxJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQXVFZCxJQUFjOzs7Ozs7QUFGM0IsYUFZSyxRQUFBLEtBQUEsTUFBQTtBQVhKLGFBTUEsS0FBQSxLQUFBOzZCQUhhLElBQVEsRUFBQTs7O0FBSXJCLGFBR00sS0FBQSxJQUFBO3VCQURFO1VBUkksSUFBYztBQUFBLGNBQUEsTUFBQTs7OztpQ0FHZixJQUFhLEdBQUE7QUFBQTs7Ozs7OzBCQUhaQSxLQUFjO0FBQUE7MENBRWJBLEtBQVEsSUFBQTsrQkFBUkEsS0FBUSxFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUEvS2pCQSxLQUFNO0FBQUEsYUFBQTtBQU1BLFFBQUEsQ0FBQUEsYUFBWUEsS0FBTztBQUFBLGFBQUE7Ozs7OztrQkFPdkIsSUFBTyxPQUFBLGtCQUFBLEdBQUE7a0JBc0JQLElBQVMsT0FBQUcsb0JBQUEsR0FBQTtrQkErQ1QsSUFBUyxPQUFBQyxvQkFBQSxHQUFBO2tCQW1GVixJQUFPLE9BQUFDLG9CQUFBLEdBQUE7a0JBS1QsSUFBUSxPQUFBTixrQkFBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs0QkFoSlQsSUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLMEIsbUJBQUEsT0FBQSxjQUFBLENBQUEsV0FBYSxJQUFPLEdBQUE7Ozs7O0FBbkM3RCxhQTZMSyxRQUFBLE1BQUEsTUFBQTtBQTNMSixhQTJLSyxNQUFBLElBQUE7Ozs7O0FBOUpKLGFBaUJNLE1BQUEsS0FBQTtBQWhCTCxhQVdLLE9BQUEsSUFBQTs7OztBQUVMLGFBRUssT0FBQSxJQUFBOztBQUlOLGFBeUlNLE1BQUEsS0FBQTtBQXZJTCxhQWlJTSxPQUFBLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQXJKQUMsS0FBTztBQUFBLGtCQUFBLEVBQUFBLE1BQUEsS0FBQTtVQXNCUEEsS0FBUztBQUFBLGtCQUFBLEVBQUFBLE1BQUEsS0FBQTtVQStDVEEsS0FBUztBQUFBLGtCQUFBLEVBQUFBLE1BQUEsS0FBQTtVQW1GVkEsS0FBTztBQUFBLGtCQUFBLEVBQUFBLE1BQUEsS0FBQTtVQUtUQSxLQUFRO0FBQUEsa0JBQUEsRUFBQUEsTUFBQSxLQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF6aEJGLE1BQUEsRUFBQSxPQUFPLE1BQUssSUFBQTtBQUNqQixRQUFBLFNBQVM7QUFLSixNQUFBLEVBQUEsUUFBUSxNQUFLLElBQUE7QUFDbEIsUUFBQSxVQUFVO0FBS0wsTUFBQSxFQUFBLFFBQVEsTUFBSyxJQUFBO0FBQ2xCLFFBQUEsVUFBVTtBQUtMLE1BQUEsRUFBQSxVQUFVLE1BQUssSUFBQTtBQUNwQixRQUFBLFlBQVk7QUFLUCxNQUFBLEVBQUEsVUFBVSxNQUFLLElBQUE7QUFDcEIsUUFBQSxZQUFZO0FBS1AsTUFBQSxFQUFBLFFBQUFNLFVBQVMsTUFBSyxJQUFBO0FBQ25CLFFBQUEsV0FBV0E7QUFLTixNQUFBLEVBQUEsUUFBUSxHQUFFLElBQUE7QUFDZixRQUFBLFVBQVU7QUFLTCxNQUFBLEVBQUEsU0FBUyxHQUFFLElBQUE7QUFDaEIsUUFBQSxXQUFXO0FBS04sTUFBQSxFQUFBLFdBQVcsR0FBRSxJQUFBO0FBQ2xCLFFBQUEsYUFBYTtBQUdiLFFBQUEsV0FBVztRQUdYLG9CQUFpQixDQUFJLFdBQVMsV0FBSztBQUFBLElBQ3hDLEtBQUs7QUFBQSxJQUNMLElBQUk7QUFBQSxJQUNKLFVBQVU7QUFBQSxJQUNWLFdBQVM7QUFBQTtBQUFBO0FBQUEsb0JBR1MsV0FBVSxnQkFBZTtBQUFBLElBQ3pDLFFBQVEsUUFBUSxHQUFHO0FBQUE7UUFJaEIsU0FBUyxXQUFpQixNQUFNO01BS2xDO01BRUE7QUEwQk8sTUFBQSxFQUFBLGlCQUFpQixNQUFLLElBQUE7QUFDdEIsTUFBQSxFQUFBLGVBQWUsR0FBRSxJQUFBO0FBRXhCLE1BQUEsV0FBVztBQVlmLFlBQVUsVUFBVyxhQUFPO0FBQ3hCLFFBQUEsa0JBQWtCLFNBQU87QUFDM0IsY0FBUSxJQUFJLCtCQUErQjtBQUMzQyxtQkFBQSxHQUFBLFdBQVcsT0FBTztVQUNmLFdBQVM7QUFDWDtBQUFBO0FBQ0Msc0JBQVUsTUFBSztBQUFBO1VBQ2I7QUFBQTs7Z0JBR0ksU0FBTztBQUNmLG1CQUFBLEdBQUEsV0FBVyxFQUFFO0FBQUE7O0FBSU4sV0FBQSxjQUFjLFNBQWM7UUFFakMsZ0JBQWM7V0FFWixVQUFRO0FBQ1gsd0JBQUEsV0FBQSxhQUFhLElBQUUsVUFBQTtBQUNmOztBQUdBLGlCQUFTLFVBQVUsUUFBUTtBQUFBO2VBSXJCLFVBQVE7QUFDRSxpQkFBVztBQUV0QixZQUFBLFdBQVcsR0FBRyxXQUFXLFFBQVE7VUFDcEMsVUFBUTtBQUNWLGlCQUFTLEtBQUk7QUFBQTs7O1FBbUJkLG9CQUFpQixNQUFBO0FBTWhCLHVCQUFBLEdBQUEsV0FBVyxFQUFFO0FBRWIsa0JBQVEsSUFBSSxrQ0FBa0M7QUFDOUMsb0JBQVUsTUFBSztBQUFBOzs7QUFLaEIsc0JBQUEsV0FBQSxhQUFhLFVBQVEsVUFBQTtBQUFBOztBQTJMYyxRQUFBQyxpQkFBQSxNQUFBLE9BQU87QUFNaUMsUUFBQSxrQkFBQSxNQUFBLGdCQUFBLGdCQUFBLGtCQUFrQixNQUFJLGVBQUE7MEJBNkI5RCxhQUFPO0FBQ3ZDLFlBQVEsZ0JBQWU7QUFDdkIsb0JBQUEsb0JBQUEsdUJBQXVCLHFCQUFtQixtQkFBQTtBQUFBOztBQXdCcEMsb0JBQUEsY0FBQSxnQkFBZ0IsU0FBTyxhQUFBO0FBQ3ZCLG9CQUFBLG9CQUFBLHNCQUFzQixPQUFLLG1CQUFBO0FBQUE7O0FBWnJCLDBCQUFtQjs7OzBCQWdDQyxhQUFPO0FBQ3ZDLFlBQVEsZ0JBQWU7QUFDdkIsb0JBQUEsb0JBQUEsdUJBQXVCLHFCQUFtQixtQkFBQTtBQUFBOztBQXVEcEMsb0JBQUEsZ0JBQUEsa0JBQWtCLFdBQVMsZUFBQTtBQUMzQixvQkFBQSxvQkFBQSxzQkFBc0IsT0FBSyxtQkFBQTtBQUFBOztBQTFDckIsMEJBQW1COzs7QUFtRVYsUUFBQSxrQkFBQSxNQUFBLFNBQVMsT0FBTzs7QUFTM0IsZUFBUSxLQUFBOzs7OztBQUVULGtCQUFTOzs7Ozs7QUFyTE8sa0JBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdlRYLE1BQUEsV0FBQSxVQUFVLElBQU8sR0FBQSxNQUFNLE1BQU0sSUFBQTs7Ozs7aUJBQzdCLElBQU0sR0FBQyxNQUFNLFVBQU87Ozs7OztnQkFEdEIsR0FBQzs7Z0JBQWdDLEtBQUk7Ozs7Ozs7OztBQUQzRCxhQUdNLFFBQUEsT0FBQSxNQUFBO0FBRkwsYUFBZ0UsT0FBQSxLQUFBOzs7OztBQUNoRSxhQUFrRCxPQUFBLEtBQUE7Ozs7QUFEM0IsVUFBQSxRQUFBLEtBQUEsY0FBQSxXQUFBLFVBQVVQLEtBQU8sR0FBQSxNQUFNLE1BQU0sSUFBQTtBQUFBLGlCQUFBLElBQUEsUUFBQTtnREFDN0JBLEtBQU0sR0FBQyxNQUFNLFVBQU87QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFBQTs7Ozs7Ozs7O0FBSnRCLE1BQUEsVUFBQSxPQUFPLFFBQUs7Ozs7Ozs7OztBQUFsQyxhQUF5QyxRQUFBLE1BQUEsTUFBQTs7OztBQUFuQixVQUFBLFFBQUEsS0FBQSxhQUFBLFVBQUFBLFFBQU8sUUFBSztBQUFBLGlCQUFBLEdBQUEsT0FBQTtBQUFBOzs7Ozs7Ozs7OztRQUQ5QixhQUFhQSxLQUFNLEdBQUM7QUFBSSxhQUFBRDtRQUVuQixZQUFZQyxLQUFNLEdBQUM7QUFBSSxhQUFBSztBQUFBQTs7Ozs7Ozs7Ozs7QUFIbEMsYUFTSSxRQUFBLElBQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21CQVZFLElBQUs7O2lDQUFWLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozt3Q0FGdUMsSUFBSSxFQUFBO0FBQUE7O0FBQW5ELGFBZUssUUFBQSxLQUFBLE1BQUE7QUFkSixhQWFJLEtBQUEsRUFBQTs7Ozs7OztxQkFaSUwsS0FBSzs7bUNBQVYsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7d0NBQUo7QUFBQTs7MENBRjJDQSxLQUFJLEVBQUE7QUFBQTs7Ozs7Ozs7Ozs7TUE1RHJDLE9BQU07QUFBQSxFQUdsQixjQUFBO0FBQ0MsU0FBSyxXQUFROztNQUdWLFFBQUs7QUFDRCxXQUFBLEtBQUs7QUFBQTtFQUdULElBQUEsTUFBTSxTQUFrQjtBQUMzQixTQUFLLFdBQVc7QUFBQTtFQUdqQixNQUFNLE9BQWUsV0FBaUI7QUFDckMsU0FBSyxTQUFTLEtBQUk7QUFBQSxNQUNqQixNQUFNO0FBQUEsTUFDTixTQUNDLFNBQVMsT0FDVCxRQUFRLFVBQVM7QUFBQTtXQUlaO0FBQUE7O0FBWUEsU0FBQSxVQUFVLE1BQVk7VUFDdEIsT0FBTyxLQUFNLFFBQVEsQ0FBQyxFQUFFLFNBQVMsR0FBRyxHQUFHOzs7UUFMckMsTUFBZ0IsSUFBQTtBQUVoQixNQUFBLEVBQUEsT0FBTyxNQUFLLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJDN0JtQixJQUFPLEtBQUEsSUFBQTtBQUFBOztBQUFsRCxhQUVLLFFBQUEsS0FBQSxNQUFBO0FBREosYUFBMEQsS0FBQSxHQUFBO0FBQUE7Ozs7Ozs7Ozs7O0FBeEIvQyxNQUFBLEVBQUEsUUFBUSxJQUFHLElBQUE7QUFDaEIsUUFBQSxVQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUNrQ29CLFNBQUEsQ0FBQSxjQUFjLElBQVUsRUFBQTtBQUFBLFlBQVM7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWhCckUsYUFFSSxRQUFBLElBQUEsTUFBQTs7QUFFSixhQUVHLFFBQUEsSUFBQSxNQUFBOztBQUVILGFBRUcsUUFBQSxJQUFBLE1BQUE7O0FBRUgsYUFFRyxRQUFBLElBQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUE1QlEsaUJBQThCLElBQUE7UUFDOUIsU0FBZ0IsSUFBQTtRQUlyQixTQUFTLFdBQWlCLE1BQU07V0FFN0IsYUFBVTtBQUNsQjtBQUNBLFdBQU8sSUFBRztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQ3lSTixJQUFjLEVBQUE7Ozs7QUFEaEIsYUFFSyxRQUFBLEtBQUEsTUFBQTs7Ozs7O29CQURIQSxLQUFjLEVBQUE7QUFBQTs7Ozs7QUFEbUMsWUFBQSxDQUFBO0FBQUEsMkJBQUEsZ0NBQUEsS0FBQSxPQUFBLEVBQUEsVUFBUyxPQUFHLElBQUE7Ozs7OztBQUFaLFVBQUEsQ0FBQTtBQUFBLHlCQUFBLGdDQUFBLEtBQUEsT0FBQSxFQUFBLFVBQVMsT0FBRyxLQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRDFELE1BQUEsV0FBQSxDQUFBLFVBQXlCLElBQWMsTUFBQUksb0JBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7QUFSN0MsYUFNdUIsUUFBQSxPQUFBLE1BQUE7NkJBQVYsSUFBUyxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7dUNBQVRKLEtBQVMsSUFBQTsrQkFBVEEsS0FBUyxFQUFBO0FBQUE7QUFFaEIsVUFBQSxDQUFBQSxXQUF5QkEsS0FBYyxJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBa0IxQyxJQUFZLEVBQUE7Ozs7QUFEZCxhQUVLLFFBQUEsS0FBQSxNQUFBOzs7Ozs7b0JBREhBLEtBQVksRUFBQTtBQUFBOzs7OztBQURxQyxZQUFBLENBQUE7QUFBQSwyQkFBQSxnQ0FBQSxLQUFBLE9BQUEsRUFBQSxVQUFTLE9BQUcsSUFBQTs7Ozs7O0FBQVosVUFBQSxDQUFBO0FBQUEseUJBQUEsZ0NBQUEsS0FBQSxPQUFBLEVBQUEsVUFBUyxPQUFHLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFEMUQsTUFBQSxXQUFBLENBQUEsVUFBeUIsSUFBWSxNQUFBSyxvQkFBQSxHQUFBOzs7Ozs7Ozs7Ozs7OztBQVIzQyxhQU11QixRQUFBLE9BQUEsTUFBQTs2QkFBVixJQUFTLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FBVEwsS0FBUyxJQUFBOytCQUFUQSxLQUFTLEVBQUE7QUFBQTtBQUVoQixVQUFBLENBQUFBLFdBQXlCQSxLQUFZLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBWXRDLElBQU8sRUFBQTtBQUFBOztBQUFiLGFBQW1CLFFBQUEsS0FBQSxNQUFBOzs7OztvQkFBYkEsS0FBTyxFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29EQXREUSxHQUFFLEVBQUEsQ0FBQTt3REFFQyxJQUFHLEVBQUEsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaURYLE1BQUEsT0FBUyxVQUFLLFFBQUE7QUFBZCxnQkFBQSxRQUFBLE9BQVM7QUFBQTs7O2lCQUVyQixJQUFPLE1BQUFELGtCQUFBLEdBQUE7O3NCQUtVLElBQWdCLEdBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE1RHRDLGFBVVEsUUFBQSxRQUFBLE1BQUE7QUFUUCxhQUlLLFFBQUEsSUFBQTs7Ozs7QUFFTCxhQUVHLFFBQUFTLEVBQUE7O0FBR0osYUF1Q0ssUUFBQSxNQUFBLE1BQUE7QUF0Q0osYUFJOEIsTUFBQSxLQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NkLHNCQUFBLFFBQUFSLFFBQVM7Ozs7VUFFckJBLEtBQU8sSUFBQTs7Ozs7Ozs7Ozs7Ozs7c0NBS1VBLEtBQWdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQTNTaEMsU0FBUyxXQUFpQixNQUFNO1FBR2hDLFlBQVksV0FBa0MsV0FBVztBQUczRCxNQUFBLFlBQVk7QUFDWixNQUFBLFlBQVk7QUFDWixNQUFBLFVBQVU7QUFFVixNQUFBLGlCQUFpQjtBQUNqQixNQUFBLGVBQWU7QUFHZixNQUFBLFdBQVc7QUFHWCxNQUFBLGVBQWU7QUFHVixXQUFBLElBQUksT0FBYTtvQkFDekIsV0FBVyxTQUFTLE1BQU0sT0FBTyxLQUFLLElBQUcsSUFBSyxRQUFRLENBQUE7QUFBQTtBQVl2RCxTQUFPLEdBQUU7QUFBQSxJQUNSLFVBQU87c0JBRU4sWUFBUyxhQUFBLEdBQUcsWUFBWSxFQUFFLENBQUE7QUFBQTs7V0FJbkIsaUJBQWM7UUFDbkIsYUFBUyxDQUFLLFdBQVcsU0FBUyxHQUFBO1VBQ2pDLFVBQVUsU0FBUyx1QkFBcUI7QUFDMUMscUJBQUEsR0FBQSxpQkFBaUIsd0NBQXdDO0FBQUEsaUJBRWxELFVBQVUsU0FBUyx1QkFBcUI7QUFDL0MscUJBQUEsR0FBQSxpQkFBaUIsMkNBQTJDO0FBQUE7QUFHNUQscUJBQUEsR0FBQSxpQkFBaUIsNEJBQTRCO0FBQUE7OztBQU0vQyxpQkFBQSxHQUFBLGlCQUFpQixFQUFFO0FBQUE7V0FHWCxlQUFZO0FBQ2pCLFFBQUEsYUFBYyxDQUFBLGtCQUFrQixjQUFjLFdBQVM7QUFDekQsbUJBQUEsR0FBQSxlQUFlLHdCQUF3Qjs7O0FBSXhDLGlCQUFBLEdBQUEsZUFBZSxFQUFFO0FBQUE7UUFJWixnQkFBWSxZQUFBO1VBQ1gsUUFBSyxNQUFTLE1BQU0sNkJBQTZCO1VBQ2pELFNBQU0sTUFBUyxNQUFNO1dBQ3BCLE9BQU8sTUFBTSxJQUFJO0FBQUE7aUJBSVYsbUJBQWdCO0FBRXhCLFVBQUEsb0JBQW9CO1FBR3ZCLFlBQVksU0FBUyxTQUFTLEdBQUE7QUFDaEMsYUFBTyxLQUFJO0FBQUEsUUFDVixTQUFTUztBQUFBQSxRQUNULFNBQ0MsaUJBQWdCO0FBQUE7O1lBTVosaUJBQWdCO0FBQUE7O0FBS3BCLE1BQUEsU0FBUztpQkFHRSxtQkFBZ0I7QUFFMUIsUUFBQSxDQUFBO2FBQThCO0FBRy9CLFFBQUE7YUFBZTtBQUFHLGFBQVM7QUFHeEIsVUFBQSxPQUFpQixPQUFBLFNBQVMsT0FBTztBQUd2QyxpQkFBQSxHQUFBLFVBQVUsRUFBRTtBQUdaLGVBQVcsS0FBSztBQUVoQixRQUFJLDZCQUE2Qjs7QUFJMUIsWUFBQSxlQUFlLE9BQU8sWUFBWSxJQUFHO1lBQ3JDLE1BQU0sZUFBZSxtQkFBbUIsbUJBQW1CLElBQUksRUFBRTtBQUNqRSxZQUFBLGdCQUFnQixPQUFPLFlBQVksSUFBRztZQUV0QyxpQkFBaUIsZ0JBQWdCO0FBQ2pDLFlBQUEsY0FBYyxLQUFLLEtBQUssaUJBQWlCO0FBQy9DLG9CQUFjLGNBQWMsS0FBTSxRQUFRLENBQUMsV0FBQTtBQUFBOztZQUtyQ0MsV0FBUyxXQUFXLEdBQUc7QUFBQSxhQUd4QjtBQUNGLFVBQUEsc0JBQXNCLHdCQUFzQjtBQUM5QyxxQkFBQSxHQUFBLFVBQVUsb0NBQW9DO0FBQUEsTUFFdkMsV0FBQSxzQkFBc0Isd0JBQXNCO0FBQ25ELHFCQUFBLEdBQUEsVUFBVSxvQkFBb0I7QUFBQTtBQUc5QixxQkFBQSxHQUFBO0VBQXNFLFdBQVcsU0FBUyxXQUFXLFNBQU87QUFBQTthQUl0RyxLQUFJO0FBQUE7QUFHWixRQUFJLHNCQUFzQjs7QUFJbkIsWUFBQSxNQUFNLFdBQVcsT0FBTyxHQUFHO0FBQUEsYUFHNUI7QUFDTCxtQkFBQSxHQUFBLFVBQVUsNERBQTREO0FBR2hFLFlBQUEsTUFBTTthQUdMLEtBQUk7QUFBQTtBQUdaLFFBQUksTUFBTTtBQUdWLGlCQUFBLEdBQUEsVUFBVSxTQUFTO1FBR2hCO0FBQVcsZ0JBQVUsSUFBSTtXQUdyQixLQUFJO0FBQUE7NkJBMkZNOztBQUNILGdCQUFTLEtBQUE7OzsrQkFlTjs7QUFDSCxnQkFBUyxLQUFBOzs7O0FBV1AsUUFBQSxPQUFBLEdBQUEsVUFBQSxTQUFTLE9BQUssS0FBQSxHQUFBO0FBQWQsZUFBUyxRQUFLOzs7Ozs7QUExUTlCLG1CQUFBLEdBQUUsd0JBQXFCLENBQUEsQ0FBSyxhQUFhLGNBQWMsYUFBYSxXQUFXLFNBQVMsQ0FBQTtBQUFBOztzQkFHdEYsbUJBQWdCLENBQUksWUFBWSxtQkFBbUIscUJBQXFCLENBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6RDVFLElBQWUsbUJBQUE7QUNBZixJQUFlLG1CQUFBO0FDQWYsSUFBZSxrQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUMyR0osSUFBWTtBQUFBO1dBRWIsSUFBUTtBQUFBO01BQ0gsSUFBTSxPQUFBLFFBQUE7NkJBQU4sSUFBTTtBQUFBOzs7Ozs7Ozs7Ozs7OztvQ0FIVlYsS0FBWTs7O21DQUdSQSxLQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFQQyxtQkFFckI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQUZRLElBQVcsR0FBQSxHQUFBLElBQUE7Ozs7Ozs7O0FBRHBCLGFBV0ssUUFBQSxLQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFuR08sTUFBQSxFQUFBLFdBQTRCLEdBQUUsSUFBQTtBQUV4QixhQUFXLE1BQU07TUFFOUIsZUFBWSxDQUFBO2lCQUVELGNBQVc7VUFDbkIsVUFBTyxDQUFBO29CQUViLGVBQVksTUFBUyxVQUFVLFVBQVUsT0FBSyxFQUM3QyxLQUFLLEdBQUUsQ0FBQSxDQUFBO0FBR0csZUFBQSxDQUFBLFNBQVMsTUFBTSxLQUFLLElBQUksVUFBVSxLQUFLLEdBQUE7QUFDakQsY0FBUSxLQUFJO0FBQUEsUUFDWCxPQUFPLFNBQVMsZUFBZSxXQUFXLE9BQU87QUFBQSxRQUNqRCxRQUFRO0FBQUEsUUFDUixTQUFTO0FBQUEsUUFDVCxXQUFXLE9BQU87QUFBQSxRQUNsQixLQUFLLE9BQU87QUFBQTs7V0FJUDtBQUFBO01BSUosU0FBTTtBQUFBLElBQ1QsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLElBQ1QsV0FBVztBQUFBLElBQ1gsS0FBSztBQUFBOztBQWdFUSxhQUFNOzs7Ozs7Ozs7QUE5RG5CO0FBRUEscUJBQUEsR0FBQSxXQUFXLFFBQVEsU0FBUyxFQUFFO0FBQUE7Ozs7Ozs7Ozs7O0FDbERoQyxJQUFlLG9CQUFBO0FDQWYsSUFBZSxvQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQ3dTUyxJQUNqQjtnQkFBQyxJQUFpQixFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFIdkIsYUEwQk0sUUFBQSxPQUFBLE1BQUE7QUF6QkwsYUFRTSxPQUFBLEtBQUE7QUFQTCxhQUdNLE9BQUEsS0FBQTs7OztBQUNOLGFBRU0sT0FBQSxLQUFBOztBQUdQLGFBY00sT0FBQSxLQUFBO0FBYkwsYUFLTSxPQUFBLEtBQUE7d0JBREU7O0FBR1IsYUFLTSxPQUFBLEtBQUE7d0JBREU7Ozs7Ozs7Ozs7Ozs7cUJBcEJKQSxLQUFpQixFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztlQTRCckIsSUFBSyxFQUFBOzs7O0FBRFAsYUFFTSxRQUFBLE1BQUEsTUFBQTs7Ozs7b0JBREpBLEtBQUssRUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztrQkFoQ0gsSUFBTyxNQUFBSyxvQkFBQSxHQUFBO2tCQThCUCxJQUFLLE1BQUFOLGtCQUFBLEdBQUE7Ozs7Ozs7Ozs7OytDQTVDRSxJQUFROzs7MkNBR2QsSUFBTSxLQUFDLE1BQU0sR0FBRztvREFDWixJQUFJLFFBQVEsUUFBUyxZQUFZLEtBQUssQ0FBQyxJQUFBLEdBQUE7Ozs7cUNBT2pDLElBQUssRUFBQTs7OztBQWJ0QixhQW1ESyxRQUFBLEtBQUEsTUFBQTtBQWxESixhQWFBLEtBQUEsS0FBQTs7Ozs7Ozs7Ozs7aUNBTFcsSUFBYSxFQUFBO0FBQUE7Ozs7Ozt5RUFQWkMsS0FBUSxLQUFBOzs7K0RBR2RBLEtBQU0sS0FBQyxNQUFNLE1BQUc7Ozt1RUFDWixJQUFJLFFBQVFBLFNBQVMsWUFBWSxLQUFLLENBQUMsSUFBQSxNQUFBOzs7Ozs7O3VDQU9qQ0EsS0FBSyxFQUFBO0FBQUE7VUFHaEJBLEtBQU8sSUFBQTs7Ozs7Ozs7Ozs7O1VBOEJQQSxLQUFLLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUExS0QsU0FBQSxXQUFXLFVBQXNCO0FBQ3JDLE1BQUEsV0FBVztRQUNULFdBQVcsT0FBTztBQUFBO0FBQ3ZCLGlCQUFXLE9BQU8sWUFBWSxVQUFVLEVBQUU7QUFBQTtJQUN4QztBQUFBO0FBRUgsU0FBTztBQUFBLElBQWlCO0FBQUE7QUFDdkIsbUJBQWEsUUFBUTtBQUNyQixvQkFBYyxRQUFRO0FBQUE7SUFFdEIsRUFBQSxNQUFNLEtBQUk7QUFBQTs7d0JBOEhDLE9BQUssRUFBRTs7Ozs7Ozs7QUFsUlQsTUFBQSxFQUFBLFFBQVEsR0FBRSxJQUFBO1FBRWYsVUFBTyxJQUFPLFVBQVUsQ0FBQztRQUN6QixTQUFNLElBQU8sVUFBVSxDQUFDO0FBRW5CLE1BQUEsRUFBQSxXQUE0QixHQUFFLElBQUE7QUFLOUIsTUFBQSxFQUFBLFlBQWdDLEVBQUMsSUFBQTtNQUV4QztBQUVBLE1BQUEsU0FBb0I7QUFDcEIsTUFBQSxVQUFxQjtBQUNyQixNQUFBLG9CQUFvQjtBQVdwQixNQUFBLGVBQWU7aUJBa0JKLGVBQVk7QUFDMUIsaUJBQUEsR0FBQSxvQkFBb0IsT0FBTztBQUVyQixVQUFBLFdBQVcsU0FBUyxnQkFBZ0IsUUFBc0I7UUFDN0QsY0FBYyxVQUFVLE1BQUk7WUFDeEIsVUFBVSxTQUFTO0FBRXpCLG1CQUFBLEdBQUEsVUFBVSxVQUFVLE1BQU0sUUFBTztBQUUzQixZQUFBLFdBQVcsbUJBQW1CLGNBQWMsV0FBVyxPQUFPO1VBRWpFLFlBQVksU0FBUyxZQUFZLEtBQUssSUFBRyxJQUFNLElBQUksWUFBVTtBQUMvRCxxQkFBQSxHQUFBLGFBQWEsVUFBVSxTQUFTLEtBQUssTUFBTSxFQUFFLFVBQVcsQ0FBQSxRQUFRLFFBQVEsRUFBRSxNQUFVLElBQUEsVUFBVSxTQUFTLENBQUEsQ0FBQTtBQUFBO0FBR2xHLFlBQUEsaUJBQWlCLG1CQUFtQixZQUFZLFdBQVcsT0FBTztVQUdyRSxhQUFhLFNBQVMsU0FBTztBQUN6QixjQUFBLGdCQUFnQixVQUFVLFNBQVMsUUFBUSxNQUFNLEVBQUUsVUFBVyxDQUFBLFFBQVEsUUFBUSxFQUFFLE1BQVUsSUFBQSxVQUFVLFNBQVMsQ0FBQTthQUMvRyxVQUFVLEdBQUcsTUFBTSxHQUFBO0FBQ3RCLHVCQUFBLEdBQUEsU0FBUyxTQUFTO0FBQUE7QUFHYixjQUFBLFNBQVMsVUFBVSxNQUFNO0FBRS9CLHFCQUFBLElBQUEsZUFBZSxRQUFRLE9BQU8sZ0JBQWdCLEVBQUU7QUFBQTtlQUcxQyxZQUFZLFVBQVUsTUFBSTtBQUlqQyxtQkFBQSxHQUFBLFVBQVUsSUFBSTtBQUFBO1FBR1osU0FBTztBQUNULGdCQUFVLE9BQU8sVUFBVyxDQUFBLFFBQVEsUUFBUTtBQUFBO0FBRzVDLGdCQUFVO0FBQ1YsbUJBQUEsR0FBQSxTQUFTLE9BQU87QUFBQTs7QUFrQlQsV0FBQSxjQUFjLFNBQWM7QUFDcEMsaUJBQUEsR0FBQSxRQUFTLFFBQVEsT0FBNEIsS0FBSztBQUFBO1dBRzFDLFlBQVM7QUFDWCxVQUFBLFVBQVUsUUFBUSxLQUFLLFNBQVMsQ0FBQztRQUVwQyxRQUFRLElBQUksTUFBTSxHQUFBO3NCQUNwQixRQUFRLFVBQVEsRUFBRTtBQUFBO3NCQUdsQixRQUFRLFNBQU8sRUFBRTtBQUFBO0FBR2xCOztXQUdRLFlBQVM7VUFDWCxVQUFVLFFBQVEsUUFBTyxFQUFHLEtBQUssU0FBUyxDQUFDO1FBQzlDLFFBQVEsSUFBSSxDQUFDLEdBQUE7VUFDWixRQUFRLEdBQUcsTUFBTSxHQUFBO3dCQUNuQixRQUFRLFNBQU8sRUFBRTtBQUFBO3dCQUdqQixRQUFRLFVBQVEsRUFBRTtBQUFBOztBQUluQixtQkFBQSxHQUFBLFFBQVEsR0FBRztBQUFBO0FBR1o7O0FBaUJVLE1BQUEsRUFBQSxRQUFRLEdBQUUsSUFBQTtNQUNqQjtBQUVLLFdBQUEsV0FBVyxPQUFhO0FBQ2hDLGFBQVMsa0JBQWtCLEtBQUs7QUFDaEMsaUJBQUEsR0FBQSxRQUFRLEtBQUs7QUFBQTtXQUdMLGlCQUFjO1NBQ2xCLE9BQUs7QUFDRCxhQUFBLFdBQVcsaUJBQWlCO0FBQUE7UUFHaEM7O0FBRUgsaUJBQVEsSUFBTyxVQUFVLEtBQUs7QUFBQSxhQUV6QjtBQUNFLGFBQUEsV0FBVyxnQkFBZ0I7QUFBQTtRQUdoQyxTQUFTLEdBQUcsT0FBTyxHQUFBO0FBQ2QsYUFBQSxXQUFXLHdCQUF3QjtBQUFBO1FBR3hDLFNBQVMsR0FBRyxNQUFNLEdBQUE7QUFDYixhQUFBLFdBQVcsc0JBQXNCO0FBQUE7QUFHekMsaUJBQUEsR0FBQSxRQUFRLEVBQUU7QUFBQTtBQUdBLE1BQUEsRUFBQSxpQkFBaUIsRUFBQyxJQUFBOytCQXNGWDs7O0FBR04saUJBQVE7Ozs7K0JBbUJBO0FBQ0ksUUFBQSxvQkFBQSxNQUFBLFdBQVcsU0FBUztnQ0FNeEI7QUFDSSxRQUFBLHNCQUFBLE1BQUEsV0FBVyxTQUFTOzs7Ozs7Ozs7Ozs7Ozs7QUExUjNDO1lBQ0csVUFBUTtlQUNMLGFBQVk7QUFBQTtBQUdqQix1QkFBQSxHQUFBLFVBQVUsSUFBSTtBQUFBOzs7O0FBS2Y7WUFDRyxjQUFZOztrQkFFUCxXQUFRLE1BQVMsVUFBVSxZQUFXLENBQUUsWUFBWSxHQUFHLE9BQU8sSUFBRSxVQUFVO0FBQzdFLGdCQUFBLGdCQUFnQixVQUFROzhCQUMxQixvQkFBb0IsY0FBZSxDQUFBLFNBQVMsU0FBUyxlQUFlLElBQUksQ0FBQTtBQUFBO0FBR3hFLDJCQUFBLEdBQUEsb0JBQW9CLEtBQUs7QUFBQTs7O0FBSzNCLHVCQUFBLEdBQUEsb0JBQW9CLEVBQUU7QUFBQTs7OztBQWdKdkI7WUFDRyxnQkFBYztBQUNoQjtvQkFFUSxPQUFLO0FBQ2IsdUJBQUEsR0FBQSxRQUFRLEVBQUU7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dDekpILElBQVM7QUFBQTtNQUNKLElBQVUsT0FBQSxRQUFBOzZCQUFWLElBQVU7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O21DQUFWQSxLQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFQRCxxQkFFdkI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQUZRLElBQWEsR0FBQSxHQUFBLElBQUE7Ozs7Ozs7O0FBRHRCLGFBV0ssUUFBQSxLQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBL0NPLE1BQUEsRUFBQSxhQUEwQixnQkFBZSxJQUFBO1FBSTlDLGFBQVUsQ0FBSSxPQUFvQixXQUEyQjtBQUFBLElBQ2xFLE9BQU87QUFBQSxJQUNQLFNBQVMsTUFBTTtBQUFBLElBQ2YsV0FBVyxNQUFNLE9BQU8sb0JBQW9CO0FBQUE7TUFLekM7TUFDQTtpQkFPVyxnQkFBYTtVQUNyQixjQUFXLE1BQVMsU0FBUztBQUVuQyxpQkFBQSxHQUFBLFlBQVksT0FBTyxZQUFZLEtBQUssVUFBVSxDQUFBO29CQUM5QyxhQUFhLFVBQVUsS0FBSyxPQUFLLGVBQWUsRUFBRSxLQUFLLENBQUE7V0FFaEQ7QUFBQTs7QUFrQk0saUJBQVU7Ozs7Ozs7OztVQTVCbEIsWUFBVTt3QkFDZixhQUFhLFdBQVcsS0FBSztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2dKN0IsYUFFTSxRQUFBLE1BQUEsTUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs4Q0FMYSxJQUFPLEdBQUEsRUFBQSxDQUFBOzs7Ozs7OztBQUQxQixhQUVNLFFBQUEsTUFBQSxNQUFBOzs7Ozs7O29DQURhQSxLQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVJ0QixNQUFBLFdBQUEsT0FBVSxPQUFJOzs7OztpQkFQWCxJQUFTLE1BQUFLLG9CQUFBLEdBQUE7OztNQVVJLFNBQUEsT0FBTyxPQUFPLE9BQVUsT0FBTztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVpuRCxhQWNLLFFBQUEsS0FBQSxNQUFBO0FBYkosYUFJTSxLQUFBLEtBQUE7Ozs7QUFFTixhQU1NLEtBQUEsS0FBQTtBQUxMLGFBRU0sT0FBQSxLQUFBOzs7Ozs7O1VBUkRMLEtBQVMsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9aLFdBQUEsQ0FBQSxXQUFBLFFBQUEsTUFBQSxjQUFBLFdBQUFBLFFBQVUsT0FBSTtBQUFBLGlCQUFBLElBQUEsUUFBQTs7QUFHRSxVQUFBLFFBQUE7QUFBQSwwQkFBQSxVQUFBLE9BQU8sT0FBT0EsUUFBVSxPQUFPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQVQvQjtBQUFBLGdCQUFjLElBQVM7QUFBQTs7Ozs7Ozs7Ozs7Ozs7c0NBQVRBLEtBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBSnZDQSxLQUFTO0FBQUEsYUFBQTtRQWdCSkEsS0FBTztBQUFBLGFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTlJTixNQUFBLEVBQUEsVUFBdUMsS0FBSSxJQUFBO0FBQ2xELE1BQUEsWUFBa0M7QUFLM0IsTUFBQSxFQUFBLFVBQThCLEdBQUUsSUFBQTtpQkFNNUIsa0JBQWU7VUFFdkIsWUFBUyxNQUFTLE9BQU87QUFHekIsVUFBQSxjQUFjLFVBQVUsU0FBUyxVQUFVO0FBYzdDLFFBQUEsQ0FBQSxhQUFhLFNBQU87QUFFVixpQkFBQSxDQUFBLEVBQUEsY0FBYyxLQUFLLGFBQVc7QUFFdkMsWUFBQSxZQUFZLE9BQU8sT0FBTyxlQUFlLE9BQU8sR0FBQTtBQUNsRCx1QkFBQSxHQUFBLFlBQVksY0FBYzs7Ozs7O09BT3pCLGdCQUFlO0FBQ2QsUUFBQSxpQkFBaUIsZ0JBQWdCLFVBQVUsZUFBZTtBQUNoRSxZQUFTLE1BQUE7QUFDUjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUMyQmdDLFNBQUEsT0FBSztBQUFBLE1BQWtCLFNBQUEsT0FBSztBQUFBOzs7Ozs7cURBRDVDLElBQVcsS0FBQSxnQkFBQTt3Q0FBdUIsSUFBUSxNQUFBLENBQUssSUFBSSxHQUFDLEtBQUs7QUFBQTs7QUFBM0UsYUFFSyxRQUFBLEtBQUEsTUFBQTs7Ozs7O0FBRDZCLFVBQUEsUUFBQTtBQUFBLHVDQUFBLFVBQUFBLFFBQUs7QUFBa0IsVUFBQSxRQUFBO0FBQUEsdUNBQUEsVUFBQUEsUUFBSzs7b0ZBRDVDQSxLQUFXLEtBQUEsbUJBQUE7Ozs7MENBQXVCQSxLQUFRLE1BQUEsQ0FBS0EsS0FBSSxHQUFDLEtBQUs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF4Ri9ELE1BQUEsRUFBQSxXQUFXLE1BQUssSUFBQTtBQUNoQixNQUFBLEVBQUEsVUFBVSxNQUFLLElBQUE7QUFDZixNQUFBLEVBQUEsVUFBVSxNQUFLLElBQUE7QUFDZixNQUFBLEVBQUEsZUFBZSxNQUFLLElBQUE7QUFDcEIsTUFBQSxFQUFBLHdCQUF1QixJQUFBO1FBQ3ZCLEtBQW1CLElBQUE7QUFJbkIsTUFBQSxFQUFBLGFBQWEsR0FBRSxJQUFBO0FBRXRCLE1BQUEsY0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVqQjtjQUNNLFVBQU8sQ0FBQTtZQUNWLFVBQVE7QUFDVixrQkFBUSxLQUFLLFFBQVE7QUFBQTtZQUduQixTQUFPO0FBQ1Qsa0JBQVEsS0FBSyxPQUFPO0FBQUE7WUFHbEIsU0FBTztBQUNULGtCQUFRLEtBQUssT0FBTztBQUFBO2FBV2pCLGNBQVk7QUFDZixrQkFBUSxLQUFLLGVBQWU7QUFBQTtBQUc3QixxQkFBQSxHQUFBLGNBQWMsUUFBUSxLQUFLLEdBQUcsQ0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01DakJFLFNBQUEsT0FBSztBQUFBLE1BQWtCLFNBQUEsT0FBSztBQUFBOzs7Ozs7Ozs7QUFEOUQsYUFFSyxRQUFBLEtBQUEsTUFBQTs7Ozs7O0FBRDZCLFVBQUEsUUFBQTtBQUFBLHVDQUFBLFVBQUFBLFFBQUs7QUFBa0IsVUFBQSxRQUFBO0FBQUEsdUNBQUEsVUFBQUEsUUFBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBdEJsRCxrQkFBaUIsSUFBQTtRQUNqQixLQUFtQixJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JDdU1oQjtBQUFBLG1CQUNHLElBQU87QUFBQSxtQkFDUCxJQUFnQjtBQUFBLFVBQ3pCO0FBQUEsZUFDSztBQUFBLFdBQ0osSUFBVTtBQUFBLFdBQ1YsSUFBYTtBQUFBLHNCQUNGO0FBQUEsc0JBS0EsSUFBSyxLQUFFLFlBQVc7QUFBQTtNQUpuQixJQUFjLE9BQUEsUUFBQTtnQ0FBZCxJQUFjO0FBQUE7TUFDaEIsSUFBVyxPQUFBLFFBQUE7OEJBQVgsSUFBVztBQUFBOzs7O3lCQUNmLElBQU0sR0FBQTt3QkFDUCxJQUFLLEdBQUE7Ozs7Ozs7Ozs7Ozt5Q0FWQUEsS0FBTzs7eUNBQ1BBLEtBQWdCOztpQ0FJeEJBLEtBQWE7OzRDQU1GQSxLQUFLLEtBQUUsWUFBVzs7O3NDQUpuQkEsS0FBYzs7Ozs7b0NBQ2hCQSxLQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFkTCxxQkFFdkI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWtDRyxJQUFLLEVBQUE7Ozs7QUFEUCxhQUVNLFFBQUEsTUFBQSxNQUFBOzs7OztvQkFESkEsS0FBSyxFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBcENBLElBQWEsR0FBQSxHQUFBLElBQUE7aUJBa0NoQixJQUFLLE1BQUFELGtCQUFBLEdBQUE7Ozs7Ozs7Ozt1Q0FuQ2tELElBQWEsRUFBQTtBQUFBOztBQUExRSxhQXdDSyxRQUFBLEtBQUEsTUFBQTs7Ozs7Ozs7Ozs7OztVQUxDLElBQUssSUFBQTs7Ozs7Ozs7Ozs7Ozt5Q0FuQ2tELElBQWEsRUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXhMOUQsTUFBQSxFQUFBLFVBQThCLEdBQUUsSUFBQTtBQUNyQyxRQUFBLFdBQVc7QUFFTixNQUFBLEVBQUEsUUFBUSxHQUFFLElBQUE7TUFFakI7TUFDQTtNQUVBO0FBRUUsUUFBQSxvQkFBcUIsUUFBdUI7QUFBQSxJQUNqRCxPQUFPLE9BQU8sT0FBTyxFQUFFLE9BQU87QUFBQSxJQUM5QixPQUFPLEVBQUU7QUFBQSxJQUNULFNBQVM7QUFBQTtpQkFHSyxnQkFBYTtVQUNyQixZQUFTLE1BQVMsT0FBTztVQUV6QixZQUFTLENBQUEsRUFDZCxPQUFPLElBQ1AsT0FBTyxJQUNQLFNBQVMsS0FBSyxDQUFBO0FBR2YsaUJBQUEsR0FBQSxhQUFpQixDQUFBLEdBQUEsVUFBVSxTQUFTLFVBQVUsQ0FBQSxDQUFBO0FBQ2pDLGVBQUEsQ0FBQSxFQUFBLFNBQVMsS0FBSyxZQUFVO1lBQzlCLFdBQVcsa0JBQWtCLFNBQVM7QUFFdEMsWUFBQSxhQUFhLE9BQU8sT0FBTyxVQUFVLE9BQU87VUFDL0MsWUFBWSxlQUFlLFVBQVE7QUFDckMscUJBQUEsR0FBQSxnQkFBZ0IsUUFBUTtBQUFBO0FBR3pCLGdCQUFVLEtBQUssUUFBUTtBQUFBO1dBR2pCO0FBQUE7QUFHQyxXQUFBLE9BQU8sU0FBbUM7QUFDbEQsaUJBQUEsR0FBQSxVQUFVLFFBQVEsT0FBTyxLQUFLO0FBQzlCLGlCQUFBLEdBQUEsUUFBUSxFQUFFO0FBQUE7V0FHRixRQUFLO0FBQ2IsaUJBQUEsR0FBQSxVQUFVLEVBQUU7QUFBQTtBQUdULE1BQUEsbUJBQW1CO0FBQ25CLE1BQUEsZ0JBQWdCO0FBRWhCLE1BQUEsY0FBYztXQWNULHFCQUFrQjtBQUMxQixpQkFBQSxHQUFBLG1CQUFtQixFQUFFO1NBRWpCLFdBQVM7QUFFWixtQkFBQSxHQUFBLFFBQVEsY0FBYztBQUFBLElBRWQsV0FBQSxDQUFBLE9BQU8sa0JBQWtCLFdBQVcsZ0JBQWdCLEtBQUssR0FBQTtBQUNqRSxtQkFBQSxHQUFBLFFBQVEsZ0NBQWdDO0FBQUE7QUFHeEMsbUJBQUEsR0FBQSxRQUFRLEVBQUU7QUFHRyxpQkFBQSxDQUFBLEVBQUEsU0FBUyxLQUFLLFlBQVU7QUFFakMsWUFBQSxtQkFBbUIsT0FBTyxPQUFPLFVBQVUsT0FBTyxHQUFBO0FBRXBELHVCQUFBLEdBQUEsaUJBQWlCLEVBQUU7MEJBR25CLGdCQUFnQixrQkFBa0IsU0FBUyxDQUFBO0FBRzNDLHVCQUFBLEdBQUEsY0FBYyxLQUFLO0FBR25CLHVCQUFBLEdBQUEsZ0JBQWdCLElBQUk7Ozs7QUFLdEIsbUJBQUEsR0FBQSxtQkFBbUIsY0FBYztBQUdqQztBQUFBO0FBQ0UsYUFBRyxXQUFXLGtCQUFrQixFQUFrQixNQUFLO0FBQ3hELHVCQUFBLEdBQUEsY0FBYyxLQUFLO0FBQUE7UUFDakI7QUFBQTs7O01BSUQ7QUFFTyxNQUFBLEVBQUEsaUJBQWlCLEVBQUMsSUFBQTs7QUF3RlYscUJBQWM7Ozs7QUFDaEIsa0JBQVc7Ozs7O0FBZkUsa0JBQVM7Ozs7Ozs7Ozs7Ozs7O0FBbEl0QztBQUNBLHFCQUFBLEdBQUEsZ0JBQWdCLEtBQUs7WUFFbEIsZ0JBQWM7QUFDaEI7O0FBR0EsdUJBQUEsR0FBQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDLHVCQUFBLEdBQUEsbUJBQW1CLEVBQUU7QUFBQTs7OztBQWlEdEI7WUFDRyxnQkFBYztlQUNaLFNBQU87Z0JBQ1AsZ0JBQWM7QUFDaEI7O0FBR0EsMkJBQUEsR0FBQSxRQUFRLG1CQUFtQjtBQUFBO1VBR3BCLFdBQUEsQ0FBQSxPQUFPLGtCQUFrQixXQUFXLFNBQVMsS0FBSyxHQUFBO0FBQzFELHlCQUFBLEdBQUEsUUFBUSxnQ0FBZ0M7QUFBQTtBQUd4Qyx5QkFBQSxHQUFBLFFBQVEsRUFBRTtBQUFBO29CQUdILFNBQU87QUFDZix1QkFBQSxHQUFBLFFBQVEsRUFBRTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkNmVCxJQUFTLElBQUUsUUFBUSxXQUFPOzs7O0FBSTFCLE1BQUEsWUFBQSxJQUFXLElBQUEsT0FBTyxvQkFBb0IsU0FBSzs7Ozs7Ozs7Ozs7OztBQUw3QyxhQUVLLFFBQUEsTUFBQSxNQUFBOzs7QUFFTCxhQUVLLFFBQUEsTUFBQSxNQUFBOzs7O2lEQUxIQyxLQUFTLElBQUUsUUFBUSxXQUFPO0FBQUEsaUJBQUEsSUFBQSxRQUFBO0FBSTFCLFVBQUEsUUFBQSxLQUFBLGNBQUEsWUFBQUEsS0FBVyxJQUFBLE9BQU8sb0JBQW9CLFNBQUs7QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFBQTs7Ozs7Ozs7Ozs7OztBQVczQyxNQUFBLFlBQUEsVUFBcUIsV0FBTzs7Ozs7OztzQkFJWCxJQUFZLEdBQUE7QUFBQTs7Ozs7Ozs7Ozs7O0FBTC9CLGFBRUssUUFBQSxNQUFBLE1BQUE7OztBQUVMLGFBRUssUUFBQSxNQUFBLE1BQUE7Ozs7O0FBTEgsV0FBQSxDQUFBLFdBQUEsUUFBQSxNQUFBLGNBQUEsWUFBQUEsV0FBcUIsV0FBTztBQUFBLGlCQUFBLElBQUEsUUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQXFCdkIsUUFFTjtBQUFBOzs7Ozs7Ozs7Ozs7Z0JBSEUsWUFBVyxJQUFLLFVBQVUsUUFBVSxNQUFNLElBQU8sRUFBQSxFQUFFLFNBQVEsQ0FBQSxJQUFBOzs7Ozs7Ozs7OzhDQUEzRCxZQUFXLElBQUssVUFBVUEsU0FBVSxNQUFNQSxLQUFPLEVBQUEsRUFBRSxTQUFRLENBQUEsSUFBQTtBQUFBLGlCQUFBLEdBQUEsT0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7UUFEeERBLEtBQU87QUFBQSxhQUFBQzs7Ozs7Ozs7QUFKWCxXQUFBLGNBQUEsR0FBQSxXQUFXLElBQU87Ozs7Ozs7O0FBRHBCLGFBRUssUUFBQSxNQUFBLE1BQUE7O0FBRUwsYUFNSyxRQUFBLE1BQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBZ0JFLFFBRU47QUFBQTs7Ozs7Ozs7Ozs7O2dCQUhFLFlBQVcsSUFBSyxVQUFVLFNBQU8sTUFBTSxJQUFPLEVBQUEsRUFBRSxTQUFRLENBQUEsSUFBQTs7Ozs7Ozs7Ozs4Q0FBeEQsWUFBVyxJQUFLLFVBQVVELFVBQU8sTUFBTUEsS0FBTyxFQUFBLEVBQUUsU0FBUSxDQUFBLElBQUE7QUFBQSxpQkFBQSxHQUFBLE9BQUE7QUFBQTs7Ozs7Ozs7Ozs7O1FBRHJEQSxLQUFPO0FBQUEsYUFBQUk7Ozs7Ozs7O0FBSlgsV0FBQSxjQUFBLEdBQUEsWUFBUSxJQUFPOzs7Ozs7OztBQURqQixhQUVLLFFBQUEsTUFBQSxNQUFBOztBQUVMLGFBTUssUUFBQSxNQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWdCRSxRQUVOO0FBQUE7Ozs7Ozs7Ozs7OztnQkFIRSxZQUFXLElBQUssVUFBVSxRQUFTLE1BQU0sSUFBTyxFQUFBLEVBQUUsU0FBUSxDQUFBLElBQUE7Ozs7Ozs7Ozs7K0NBQTFELFlBQVcsSUFBSyxVQUFVSixTQUFTLE1BQU1BLEtBQU8sRUFBQSxFQUFFLFNBQVEsQ0FBQSxJQUFBO0FBQUEsaUJBQUEsR0FBQSxPQUFBO0FBQUE7Ozs7Ozs7OztBQUwzRCxNQUFBLFlBQUEsVUFBVyxXQUFPOzs7Ozs7O1FBSWRBLEtBQU87QUFBQSxhQUFBSzs7Ozs7Ozs7OztnQkFKVSxJQUFPLEVBQUE7Ozs7Ozs7O0FBRDlCLGFBRUssUUFBQSxNQUFBLE1BQUE7Ozs7O0FBRUwsYUFNSyxRQUFBLE1BQUEsTUFBQTs7OztBQVRILFVBQUEsUUFBQSxNQUFBLGNBQUEsWUFBQUwsV0FBVyxXQUFPO0FBQUEsaUJBQUEsSUFBQSxRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCbkIsYUFBc0MsUUFBQSxNQUFBLE1BQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7dUJBRmxCLElBQUk7QUFBQTs7QUFBeEIsYUFBbUMsUUFBQSxVQUFBLE1BQUE7QUFBQTs7O3lCQUFmQSxLQUFJO0FBQUE7Ozs7Ozs7Ozs7O1FBRHBCQSxLQUFJO0FBQUEsYUFBQUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBL0ZELElBQU87QUFBQSxNQUNMLFVBQUEsT0FBVTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBc0dPLFdBQVMsSUFBQSxHQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdEZyQyxhQUFHLFFBQUEsS0FBQSxNQUFBOzs7O0FBZUgsYUFBRyxRQUFBLEtBQUEsTUFBQTs7OztBQW1CSCxhQUFHLFFBQUEsS0FBQSxNQUFBOzs7O0FBbUJILGFBQUcsUUFBQSxLQUFBLE1BQUE7Ozs7QUFtQkgsYUFBRyxRQUFBLEtBQUEsTUFBQTs7Ozs7Ozs7O0FBeEZRLFVBQUEsUUFBQTtBQUFBLHVCQUFBLFdBQUFDLFFBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBbkdmLFNBQVMsV0FBaUIsTUFBTTtRQUszQixLQUFZLElBQUE7QUFDakIsUUFBQSxVQUFVO0FBRVYsUUFBQSxTQUFTLFVBQVUsTUFBTTtRQUVwQixXQUF1QixJQUFBO01BQzlCO01BQ0E7UUFFTyxPQUFjLElBQUE7QUFDbkIsUUFBQSxXQUFXO1FBRU4sVUFBd0IsSUFBQTtBQUM3QixRQUFBLGVBQWU7QUFFakIsTUFBQSxvQkFBb0I7TUFFcEI7UUFFTyxJQUFXLElBQUE7QUFDaEIsUUFBQSxRQUFRO1FBSUgsS0FBWSxJQUFBO0FBRW5CLE1BQUEsVUFBVTtVQUVQLGVBQVU7QUFDVixVQUFBLGVBQWUsT0FBTyxPQUFPLGdCQUFnQjtRQUVoRCxjQUFZO1lBQ1IsV0FBUSxNQUFTLFVBQVUsYUFBYSxZQUFZLEdBQUcsT0FBTyxDQUFDO3NCQUNyRSxVQUFVLFNBQVMsYUFBWTtBQUFBOzs7VUFLMUIsY0FBVyxNQUFTLFNBQVM7QUFFbkMsaUJBQUEsR0FBQSxZQUFZLFlBQVksR0FBRyxVQUFVLENBQUE7QUFDckMsZ0JBQVksT0FBTyxXQUFXLFVBQVUsTUFBTTtBQUV4QyxVQUFBLFlBQVksT0FBTyxlQUFlLFlBQVk7QUFDcEQsZ0JBQWtCLE1BQUEsT0FBTyxXQUFXLFNBQVM7QUFFN0MsaUJBQUEsR0FBQSxvQkFBb0IsV0FBVyxRQUFRLEVBQUU7QUFBQTtpQkFHM0IsVUFBTztBQUNmLFVBQUEsWUFBWSxPQUFXLElBQUEsVUFBVSxRQUFRLEVBQUUsVUFBVSxPQUFPLFFBQVEsRUFBRSxTQUFRLENBQUE7QUFFOUUsVUFBQSxZQUFrQixNQUFBLG1CQUFtQixTQUFTLFdBQVcsY0FBYyxTQUFTLFdBQVcsSUFBSTtBQUcvRixVQUFBLE9BQU8sT0FBTTtBQUFBLE1BQ2xCLE1BQU07QUFBQSxNQUNOLE1BQU0sS0FBSyxJQUFHO0FBQUEsTUFDZCxNQUFNO0FBQUE7QUFJUCxXQUFPLE1BQUs7QUFHUCxTQUFBLGNBQWMsZUFBZSxTQUFTLE9BQU87QUFBQTtBQTBCbEMsUUFBQSxnQkFBQSxNQUFBLE9BQU87cUJBeUdxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE5SzVDLG1CQUFBLEdBQUUsVUFBTyxJQUFPLFVBQVUsUUFBUSxFQUFFLEtBQUssR0FBRyxFQUFFLFNBQVEsQ0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUN3aEJwQyxJQUFTLFFBQUEsUUFBQTtvQ0FBVCxJQUFTO0FBQUE7Ozs7Ozs7Ozs7Ozs7OzswQ0FBVEEsS0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBV1YsSUFBa0I7QUFBQTtNQUZ0QixJQUFlLE9BQUEsUUFBQTtrQ0FBZixJQUFlO0FBQUE7TUFDYixJQUFZLE9BQUEsUUFBQTtvQ0FBWixJQUFZO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztpREFDVkEsS0FBa0I7Ozt3Q0FGdEJBLEtBQWU7Ozs7OzBDQUNiQSxLQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFvQnNCLElBQXNCLE9BQUEsUUFBQTtrQ0FBdEIsSUFBc0I7QUFBQTs7Ozs7Ozs7OztBQUR0RSxhQUlLLFFBQUEsS0FBQSxNQUFBOzs7Ozs7Ozs7Ozt3Q0FIMkNBLEtBQXNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQUFFLGtCQUV2RTtBQUFBOzs7Ozs7Ozs7Ozs7O0FBWE8sTUFBQSxZQUFBLFFBQWUsT0FBSTs7O0FBR3pCLE1BQUEsV0FBQSxRQUFlLE9BQUk7Ozs7OztpQkFJakIsSUFBYSxNQUFBLGtCQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7OzJEQVRHLElBQWUsS0FBQSxnQkFBQTtBQUFBOztBQUFwQyxhQU9NLFFBQUEsT0FBQSxNQUFBO0FBTkwsYUFFTSxPQUFBLEtBQUE7OztBQUNOLGFBRU0sT0FBQSxLQUFBOzs7Ozs7Ozs7QUFKRSxXQUFBLENBQUEsV0FBQSxNQUFBLEtBQUEsV0FBQSxlQUFBLFlBQUFBLFNBQWUsT0FBSTtBQUFBLGNBQUEsWUFBQTtBQUd6QixXQUFBLENBQUEsV0FBQSxNQUFBLEtBQUEsV0FBQSxjQUFBLFdBQUFBLFNBQWUsT0FBSTtBQUFBLGlCQUFBLElBQUEsUUFBQTs2RkFMREEsS0FBZSxLQUFBLG1CQUFBOzs7VUFTL0JBLEtBQWEsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWtCZCxJQUFpQixFQUFBOzs7O0FBRG5CLGFBRU0sUUFBQSxNQUFBLE1BQUE7Ozs7O29CQURKQSxLQUFpQixFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7aUJBRmYsSUFBaUIsTUFBQSxrQkFBQSxHQUFBOzs7Ozs7Ozs7O3FDQUZxRSxJQUFpQixFQUFBO0FBQUE7O0FBQTVHLGFBQTZHLFFBQUEsT0FBQSxNQUFBOzs7Ozs7eUNBQXBELElBQWlCLEdBQUE7Ozs7Ozt1Q0FBaUJBLEtBQWlCLEVBQUE7QUFBQTtVQUV2R0EsS0FBaUIsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFjSyxJQUFPLE9BQUEsUUFBQTtpQ0FBUCxJQUFPO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FBUEEsS0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFRdkIsSUFBTSxNQUFFLFFBQU87QUFBQSxjQUNoQixJQUFPO0FBQUEsb0JBR0QsSUFBa0I7QUFBQTtNQUZ0QixJQUFZLE9BQUEsUUFBQTs4QkFBWixJQUFZO0FBQUE7TUFDWixJQUFRLE9BQUEsUUFBQTs4QkFBUixJQUFRO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozt3Q0FIVEEsS0FBTSxNQUFFLFFBQU87O3VDQUNoQkEsS0FBTzs7NkNBR0RBLEtBQWtCOzs7b0NBRnRCQSxLQUFZOzs7OztvQ0FDWkEsS0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFnQmhCLElBQVMsR0FBQTs7Z0JBQUcsSUFBUSxHQUFBOzs7Ozs7Ozs7c0NBS2EsSUFBVyxHQUFBOzs7O0FBVi9DLGFBT00sUUFBQSxPQUFBLE1BQUE7QUFOTCxhQUVNLE9BQUEsS0FBQTs7QUFDTixhQUVNLE9BQUEsS0FBQTs7Ozs7QUFHUCxhQUVNLFFBQUEsT0FBQSxNQUFBO0FBREwsYUFBd0YsT0FBQSxLQUFBOzs7Ozs7OztxQkFMdEZBLEtBQVMsR0FBQTs7cUJBQUdBLEtBQVEsR0FBQTs7d0NBS2FBLEtBQVcsR0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O2lCQVgzQyxJQUFPLE1BQUFJLG9CQUFBLEdBQUE7Ozs7Ozs7OztBQURiLGFBZU0sUUFBQSxNQUFBLE1BQUE7Ozs7O1VBZEFKLEtBQU8sSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBd0JYOzs7Z0JBSUEsSUFBVSxHQUFBOzs7OztBQUxaLGFBRUssUUFBQSxNQUFBLE1BQUE7O0FBRUwsYUFFSyxRQUFBLE1BQUEsTUFBQTs7Ozs7cUJBREhBLEtBQVUsR0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSVgsYUFPSyxRQUFBLEtBQUEsTUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JKLGFBRU0sUUFBQSxNQUFBLE1BQUE7Ozs7Ozs7QUFGc0MsWUFBQSxDQUFBO0FBQUEsNEJBQUEsZ0NBQUEsTUFBQSxPQUFBLEVBQUEsVUFBUyxLQUFLLE9BQU0sSUFBRyxHQUFBLElBQUE7Ozs7OztBQUF2QixVQUFBLENBQUE7QUFBQSwwQkFBQSxnQ0FBQSxNQUFBLE9BQUEsRUFBQSxVQUFTLEtBQUssT0FBTSxJQUFHLEdBQUEsS0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT3BFLGFBRUssUUFBQSxLQUFBLE1BQUE7QUFESixhQUF3QyxLQUFBLFFBQUE7Z0NBQWxCLElBQU0sR0FBQTs7Ozs7Ozs7O2tDQUFOQSxLQUFNLEdBQUE7QUFBQTs7Ozs7O0FBRFMsWUFBQSxDQUFBO0FBQUEsMkJBQUEsZ0NBQUEsS0FBQSxPQUFBLEVBQUEsVUFBUyxPQUFHLElBQUE7Ozs7OztBQUFaLFVBQUEsQ0FBQTtBQUFBLHlCQUFBLGdDQUFBLEtBQUEsT0FBQSxFQUFBLFVBQVMsT0FBRyxLQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQXZKNUMsSUFBTyxNQUFFLGlCQUFnQjtBQUFBLE1BQ3hCLFFBQUEsSUFBUyxNQUFBLElBQVEsSUFBQSxTQUFRO0FBQUEsZ0JBQ3ZCLElBQVMsS0FBRSxRQUFRO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkN6QixNQUFBLFlBQUEsVUFBaUIsSUFBc0IsTUFBQSxrQkFBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQWdHckMsSUFBZSxPQUFBSyxvQkFBQTtrQkFPaEIsSUFBZSxPQUFBTixrQkFBQSxHQUFBOzs7O01BT2UsU0FBQSxDQUFBLGtCQUF5QixJQUFZLEdBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUNBdkJ2QyxJQUFlLEdBQUE7QUFBQTs7Ozs7Ozs7Ozs7OztBQXhFakQsYUFBRyxRQUFBLEtBQUEsTUFBQTs7Ozs7Ozs7QUE0Q0gsYUFBRyxRQUFBLEtBQUEsTUFBQTs7OztBQTBCSCxhQUFHLFFBQUEsS0FBQSxNQUFBOztBQUVILGFBcUJLLFFBQUEsTUFBQSxNQUFBO0FBcEJKLGFBYUssTUFBQSxJQUFBO0FBWkosYUFFTSxNQUFBLEtBQUE7d0JBREU7O0FBRVIsYUFFTSxNQUFBLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0EzSUdDLEtBQVMsS0FBRSxRQUFROzs7Ozs7Ozs7Ozs7Ozs7OztBQTZDekIsVUFBQUEsV0FBaUJBLEtBQXNCLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztVQWdHckNBLEtBQWUsS0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VBT2hCQSxLQUFlLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VDQWhCYUEsS0FBZSxHQUFBO0FBQUE7O0FBdUJiLFVBQUEsTUFBQSxLQUFBO0FBQUEsNEJBQUEsVUFBQSxDQUFBLG1CQUF5QkEsS0FBWSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFyZ0JuRSxNQUFBLFlBQVk7QUE4QmQsSUFBQSxRQUFRO0FBb0hOLE1BQUEsaUJBQWlCO3VCQWtOUSxjQUFRO0FBQ3ZDLFdBQVMsZUFBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBNWdCakIsU0FBUyxXQUFpQixNQUFNO0FBSzNCLE1BQUEsRUFBQSxTQUErQixZQUFXLElBQUE7QUFDakQsTUFBQSxZQUF5QjtRQUtsQixTQUF1QyxPQUFPLEtBQUssVUFBVSxLQUFLLEVBQUUsR0FBQyxJQUFBO0FBQzVFLE1BQUEsWUFBWTtBQUtMLE1BQUEsRUFBQSxRQUFtQyxLQUFJLElBQUE7QUFDOUMsTUFBQVcsV0FBVTtBQU1ILE1BQUEsRUFBQSxZQUFZLEdBQUUsSUFBQTtBQUNyQixNQUFBLGVBQWU7QUFHZixNQUFBLFVBQTJCLFlBQzVCLFNBQVMsZUFBZSxXQUFXLFNBQVMsSUFDNUM7TUFlQztBQVFBLE1BQUEsZ0JBQWdCO2lCQUNMLGNBQWMsU0FBTyxPQUFLO1FBRXJDO0FBQWE7QUFHaEIsb0JBQWdCO1VBR1YsWUFBUyxNQUFTLE9BQU87VUFHekIsYUFBVSxDQUFBLEdBQU8sVUFBVSxTQUFRLENBQUE7QUFNekMsaUJBQUEsSUFBQSxvQkFBb0IsS0FBSyxZQUFjLENBQUEsQ0FBQSxXQUFXLFNBQVMsT0FBQTtBQUFBLE1BQ3pELENBQUEsT0FBTyxPQUFPLFVBQVUsT0FBTyxJQUFJO0FBQUE7QUFJckMsb0JBQWdCO0FBQUE7O0FBTVYsVUFBQSxpQkFBaUIsZ0JBQWdCLFVBQVUsYUFBYTtBQUd4RCxVQUFBLGdCQUFnQixTQUFTLFVBQVUsYUFBNkI7QUFHdEUsY0FBUyxNQUFBO0FBQ1I7QUFDQTs7O0FBZUUsTUFBQSxhQUErQjtBQTZCL0IsTUFBQSxXQUFXO1dBR04sVUFBTztBQUNmLGlCQUFBLEdBQUEsV0FBVyxTQUFTO1FBR2pCLFFBQU07c0JBQ1IsV0FBUSxJQUFPLFVBQVUsUUFBUSxFQUFFLE1BQU0sS0FBSyxFQUFFLFNBQVEsQ0FBQTtBQUFBO29CQUd6RCxzQkFBa0Isa0JBQUE7QUFBQTtBQW9CZixNQUFBLFVBQXlCO1FBMkN2QixrQkFBZTtBQUFBLElBQ3BCLFFBQ0MsTUFBTSxlQUNOLE1BQU0sR0FBRTtBQUFBLElBR1QsU0FBTztBQUFBLE1BQ04sTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBO0lBR1AsVUFBUTtBQUFBLE1BQ1AsTUFBTUM7QUFBQUEsTUFDTixNQUFNO0FBQUE7SUFHUCxVQUFRO0FBQUEsTUFDUCxNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUE7O0FBSUosTUFBQSxrQkFBZ0Q7QUEwQmhELE1BQUEsa0JBQWtCO0FBQ2xCLE1BQUEsU0FBUztBQUVULE1BQUEsY0FBYztXQUVULFNBQU07U0FDVixjQUFZO3NCQUNmLHNCQUFrQixrQkFBQTs7O0FBSWYsVUFBQTtlQUFvQjtBQUV2QixvQkFBYztVQUVYLFdBQVM7QUFDWCxlQUFPLEtBQUk7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULE9BQUs7QUFBQSxZQUNKLFlBQVk7QUFBQSxZQUNaLE1BQU07QUFBQSxZQUNOLFdBQVc7QUFBQSxZQUNYLFFBQVE7QUFBQSxZQUNSLE1BQU07QUFBQSxZQUNOLEtBQUssUUFBTTtBQUFBOzs7OztBQXFCWixNQUFBLHFCQUFxQjtBQUVyQixNQUFBLHlCQUF5QjtBQUl6QixNQUFBLGtCQUFrQjtBQUNsQixNQUFBLGVBQWU7QUFPZixNQUFBLGdCQUFnQjtBQWtDWCxXQUFBLGtCQUFrQixTQUFjO0FBQ3hDLGlCQUFBLElBQUEsZ0JBQWlCLFFBQVEsT0FBNEIsS0FBSztBQUFBOztBQTJMeEMsZ0JBQVM7Ozs7QUFTZCxzQkFBZTs7OztBQUNiLG1CQUFZOzs7O0FBb0JzQiw2QkFBc0I7Ozs7QUE0QjNDLGNBQU87Ozs7QUFVdEIsbUJBQVk7Ozs7QUFDWixlQUFROzs7K0JBcUI4QztBQW1DdEIsUUFBQSxrQkFBQSxNQUFBLGFBQUEsSUFBQSxtQkFBbUIsZUFBZTs7QUFpQnZELGFBQU0sS0FBQTs7O3FCQUttQjs7Ozs7Ozs7Ozs7OztBQXpvQi9DLG1CQUFBLElBQUEsU0FBUyxXQUFXLGNBQWMsU0FBUyxnQkFBZ0IsT0FBTyxHQUFHLFFBQVEsWUFBVyxVQUFVLFFBQVEsYUFBWSxJQUFJO0FBQUE7O0FBRzFILG1CQUFBLElBQUEsVUFBVSxXQUFXLFlBQVksU0FBUyxnQkFBZ0IsT0FBTyxHQUFHLFFBQVFELFdBQVMsU0FBUyxTQUFTQSxRQUFPLElBQUcsRUFBRTtBQUFBOztBQXdEckg7QUFDQSxnQkFBUSxJQUFHO0FBQUEsVUFDVjtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0EsU0FBQUE7QUFBQTs7OztBQU9EO0FBRUcsWUFBQSxlQUFlLFNBQU87QUFDeEIsdUJBQUEsSUFBQSxhQUFhLElBQUk7QUFHakIseUJBQWMsWUFBQTtBQUViLHlCQUFBLElBQUEsWUFBWSxPQUFPO0FBR2Isa0JBQUEsV0FBVyxtQkFBbUIsY0FBYyxXQUFXLFNBQVM7Z0JBQ25FLFlBQVksU0FBUyxZQUFZLEtBQUssSUFBRyxJQUFNLElBQUksWUFBVTtBQUMvRCwyQkFBQSxJQUFBLGlCQUFpQixVQUFVLFNBQVMsS0FBSyxNQUFNLENBQUE7QUFBQTtBQUkxQyxrQkFBQSxpQkFBaUIsbUJBQW1CLFlBQVksV0FBVyxTQUFTO2dCQUN2RSxVQUFRO0FBQ1YsMkJBQUEsSUFBQSxpQkFBaUIsVUFBVSxTQUFTLFFBQVEsTUFBTSxDQUFBO0FBQUE7Ozs7OztBQXBCckQsbUJBQUEsSUFBRSxZQUFZLGFBQVksY0FBYyxXQUFXLFVBQVMsRUFBRyxVQUFVQSxVQUFVLFFBQVEsRUFBRSxVQUFRLElBQUssRUFBRTtBQUFBOztBQTJDMUcsbUJBQUEsSUFBQSxjQUFjLGFBQWEsU0FBUztBQUFBOztBQWF0QyxtQkFBQSxJQUFFLGdCQUFnQkEsWUFBVyxTQUFTLE9BQU8sZ0JBQWdCLEVBQUU7QUFBQTs7QUFNL0Q7WUFFRyxjQUFZOztBQU9QLGtCQUFBLGlCQUFpQixVQUFVLFlBQWEsQ0FBQSxZQUFZLEdBQWUsU0FBUzs2QkFHbEYsVUFBVSxTQUFTLGFBQVk7QUFDNUIsZ0JBQUEsb0JBQW9CLFNBQU87QUFDbkIsMEJBQVksU0FBUyxTQUFTO0FBQUE7Ozs7OztBQWlCekMsbUJBQUEsSUFBQSxhQUFhLG9CQUFvQixVQUFTLFlBQVksUUFBUSxTQUFTLEtBQUssSUFBRyxFQUFFO0FBQUE7O0FBb0NuRjthQUNJLGNBQVk7QUFDZix1QkFBQSxHQUFBLGtCQUFrQixNQUFNO0FBQUE7QUFHeEIsdUJBQUEsR0FBQSxrQkFBa0IsU0FBUzs7c0JBR2pCLG1CQUFtQixXQUFXLFlBQVksR0FBQTtBQUNsRCwyQkFBQSxHQUFBLGtCQUFrQixVQUFVO0FBQUE7QUFHNUIsMkJBQUEsR0FBQSxrQkFBa0IsVUFBVTtBQUFBOzs7Ozs7QUFoQjdCLG1CQUFBLElBQUEsaUJBQWlCLGdCQUFnQixnQkFBZTtBQUFBOztBQStFbEQsbUJBQUEsR0FBRSxnQkFBZ0IsZ0JBQWdCLHFCQUFpQixFQUFNLGdCQUFnQixrQkFBaUI7QUFBQTs7c0JBTXhGLG9CQUFvQiwyQkFBMkIsc0JBQXNCLFFBQ3JFLGdCQUNDLGVBQWUsS0FBSyxhQUFhLElBQ2hDLEtBQ0EsY0FBYyxTQUFTLE9BQ3RCLDhCQUNBLDRCQUNGLDZDQUNELEVBQUU7QUFBQTs7QUFFSjtBQUNHLFlBQUEsMkJBQTJCLG9CQUFrQjtBQUMvQyx1QkFBQSxHQUFBLG9CQUFvQixFQUFFO0FBQUE7Ozs7dUJBSXJCLGVBQWdCLGdCQUNmLGFBQ0MsbUJBQUEsQ0FDQSxpQkFDQyxDQUFBLGtCQUFrQiwwQkFBMkIsaUJBQWtCLENBQUEsc0JBQ2hFLEtBQUs7QUFBQTs7QUFFVDtBQUNBLGdCQUFRLElBQUc7QUFBQSxVQUNWLElBQUk7QUFBQSxVQUNKO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQTs7OztBQXhTRCxlQUFBLElBQUUsV0FBVyxhQUFhQSxVQUFTLFVBQVUsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFGakQsYUFBc0MsUUFBQSxLQUFBLE1BQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQ0Z0QixTQUFBLFVBQVUsV0FBaUIsUUFBNEI7QUFDdEUsUUFBTSxTQUFTLFVBQVUsT0FBTyxTQUFTLE9BQU8sV0FBVyxHQUFHLEdBQUc7QUFFakUsU0FBTyxPQUFPLE1BQU0sR0FBRyxDQUFDLE9BQU8sUUFBUSxFQUFFLFFBQVEsT0FBTyxHQUFHLElBQUUsTUFBSSxPQUFPLE1BQU0sQ0FBQyxPQUFPLFFBQVE7QUFJL0Y7QUFFQSxlQUFzQixRQUFRLFdBQWlCLFFBQW9CRSxhQUFVLE9BQTJCO0FBRXZHLE1BQUcsUUFBUSxVQUFVO0FBQWUsV0FBQSxJQUFJLFVBQVUsQ0FBQztBQUc3QyxRQUFBLFdBQVcsT0FBTyxNQUFPO0FBQy9CLFFBQU0sV0FBVyxNQUFNLFVBQVUsWUFBWSxDQUFDLFFBQVEsR0FBR0EsVUFBUztBQUdsRSxTQUFPLElBQUksVUFBVSxVQUFVLE1BQU0sRUFBRSxVQUFVLENBQUMsT0FBTyxRQUFRLEVBQUUsTUFBTSxTQUFTLFNBQVM7QUFDNUY7QUF5QkEsZUFBc0IsYUFBYSxXQUFpQixRQUFvQkEsYUFBVSxPQUE2QjtBQUV4RyxRQUFBLFdBQVcsT0FBTyxNQUFPO0FBQy9CLFFBQU0sV0FBVyxNQUFNLFVBQVUsWUFBWSxDQUFDLFFBQVEsR0FBR0EsVUFBUztBQUVsRSxRQUFNLFVBQVUsU0FBUztBQUV6QixRQUFNLGFBQWEsSUFBSSxVQUFVLFVBQVUsTUFBTSxFQUFFLFVBQVUsQ0FBQyxPQUFPLFFBQVEsRUFBRSxNQUFNLE9BQU87QUFHckYsU0FBQTtBQUFBLElBQ04sUUFBUUE7QUFBQSxJQUNSLFNBQVM7QUFBQSxJQUNULE1BQU0sV0FBVyxNQUFNLE9BQU8sRUFBRSxTQUFTO0FBQUEsSUFDekMsT0FBTztBQUFBLEVBQUE7QUFFVDs7Ozs7Ozs7Ozs7OzthQ2lTUyxJQUFRO0FBQUEsZ0JBQ0wsSUFBTTtBQUFBOzs7O1dBUVgsSUFBSztBQUFBLGdCQUNBLElBQU0sTUFBSSxXQUFXO0FBQUEsb0JBQ2pCLElBQVE7QUFBQSxhQUNmLElBQVMsS0FBSyxHQUFBLGNBQWMsSUFBVSxHQUFBLGVBQWUsSUFBUSxPQUFJO0FBQUEsbUJBQzNELElBQU0sT0FBSyxJQUFPLFVBQVEsSUFBTztBQUFBLGVBQ3JDLElBQVU7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJcEIsYUFtR0ssUUFBQSxLQUFBLE1BQUE7Ozs7OzsrQkFySEdiLEtBQVE7O2tDQUNMQSxLQUFNOzs7OytCQVFYQSxLQUFLOztvQ0FDQUEsS0FBTSxNQUFJLFdBQVc7O2lDQUV4QkEsS0FBUyxLQUFLLEdBQUEsY0FBY0EsS0FBVSxHQUFBLGVBQWVBLEtBQVEsT0FBSTs7dUNBQzNEQSxLQUFNLE9BQUtBLEtBQU8sVUFBUUEsS0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOVQzQyxJQUFBLFVBQXFDOzs7Ozs7OztRQWxCbkMsU0FBUyxXQUFpQixNQUFNO1FBSzNCLFVBQXFCLElBQUE7QUFDMUIsUUFBQSxXQUFXO0FBSWIsTUFBQSxVQUFpQztBQUdqQyxNQUFBLFVBQVU7QUFDVixNQUFBLFNBQTRCO0FBUTVCLE1BQUEsUUFBc0I7QUFHdEIsTUFBQSxXQUFXO0FBR1gsTUFBQSxTQUFTO0FBR1QsTUFBQSxZQUE4QjtBQUc5QixNQUFBLFNBQVM7QUFHVCxNQUFBLFVBQVU7aUJBTUMsY0FBVztBQUNSLFVBQVMsU0FBUyxLQUFJO0FBRWpDLFVBQUEsU0FBUyxTQUFTLGdCQUFnQixRQUFRO1NBRTVDLFFBQU07QUFDQyxZQUFBLElBQUEsNERBQTRELFdBQVE7QUFBQTtBQUd4RSxZQUFBLE9BQU87QUFBQSxXQUVSO0FBQ0oscUJBQUEsR0FBQSxVQUFVLE1BQU07V0FJZixNQUFNLFFBQU8sSUFDVjtjQUdFLFVBQVUsT0FBTztjQUNqQixVQUFVLFlBQVksZ0JBQWUsa0JBQWtCLE9BQU8sR0FBRyxPQUFPO0FBQzlFLHFCQUFBLEdBQUEsU0FBUyxRQUFRLE1BQU0sUUFBTztBQUc5QixxQkFBQSxHQUFBLFdBQVcsT0FBTzt3QkFDbEIsU0FBUyxPQUFPLElBQUk7d0JBQ3BCLFFBQVEsT0FBTyxHQUFHO2NBR1osV0FBVyxtQkFBbUIsY0FBYyxPQUFPLFFBQVEsT0FBTztZQUVwRTtZQUdELFlBQVksU0FBUyxhQUFhLEtBQUssSUFBRyxJQUFNLElBQUksWUFBVTtBQUNoRSxzQkFBWSxTQUFTO0FBQUE7YUFLcEIsU0FBUyxVQUFTLElBQUEsTUFDVCxtQkFBbUIsWUFBWSxPQUFPLFFBQVEsT0FBTztBQUFBO3dCQUloRSxZQUFTLElBQU8sVUFBVSxVQUFVLE1BQU0sRUFBRSxVQUFTLENBQUUsT0FBTyxRQUFRLENBQUE7QUFHakUsYUFBQSxhQUFhLFdBQVcsTUFBTSxFQUFFLEtBQU0sZUFBUzswQkFDbkQsU0FBUyxZQUFZLFVBQVUsTUFBTSxVQUFVLE1BQU0sQ0FBQTswQkFDckQsVUFBVSxZQUFZLFVBQVUsT0FBTyxVQUFVLE1BQU0sQ0FBQTtBQUFBOzs7V0FPcEQ7QUFDSixxQkFBQSxHQUFBLFVBQVUsT0FBTztjQU1YLGFBQVUsTUFBUyxTQUFTO0FBQ2pCLG1CQUFXLE9BQU8sT0FBTyxXQUFXLFNBQVMsc0JBQXNCLFNBQVMsQ0FBQTtBQUM3Rjs7OztrQkFNVSxNQUFLLDJCQUE0QixPQUFPLE9BQUk7QUFBQTs7O0FBS3pEO1FBZ0NNLGFBQVU7QUFBQSxJQUNmLE1BQUk7QUFBQSxNQUNILE9BQU87QUFBQSxNQUNQLFVBQU87QUFDTixlQUFPLEtBQUk7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULE9BSUcsVUFBQSxFQUVBLFFBQVEsUUFBTyxJQUFBLENBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3VGQSxRQUFBLGNBQUEsU0FBUyxlQUFlLGNBQVcsVUFBTyxHQUFBOzs7SUFFM0QsTUFBTSxVQUFPO0FBQUEsSUFDYixLQUFLLFVBQVMsR0FBQztBQUFBOztBQUVHLFFBQUEsY0FBQSxVQUFTLElBQUEsUUFBUSxlQUFXLFVBQU0sR0FBQSxDQUFBOzs7Ozs7OztBQXRCbEMsUUFBQSxjQUFBLFNBQVMsZUFBZSxjQUFXLFVBQU8sR0FBQTs7Ozs7Ozs7Ozs7OztBQTNFaEUsYUFFSyxRQUFBLEtBQUEsTUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7QUEyQ3dELE1BQUEsV0FBQSxJQUFVLEdBQUEsVUFBUyxhQUFXOztpQkFBSSxJQUFRLEdBQUMsS0FBSyxNQUFNLElBQUE7Ozs7OztBQUkzRyxRQUFBQSxRQUFVO0FBQU8sYUFBQUs7Ozs7Ozs7Ozs7O2dCQUplLHNCQUFvQjs7O2dCQUF5RCxtQkFDbkg7Ozs7Ozs7Ozs7QUFIRCxhQVlLLFFBQUEsTUFBQSxNQUFBO0FBWEosYUFFSyxNQUFBLElBQUE7QUFESixhQUFxQyxNQUFBLElBQUE7Ozs7OztBQUd0QyxhQU1LLE1BQUEsSUFBQTs7OztBQVRzRCxVQUFBLE1BQUEsS0FBQSxLQUFBLGNBQUEsV0FBQUwsS0FBVSxHQUFBLFVBQVMsYUFBVztBQUFFLGlCQUFBLElBQUEsUUFBQTttREFBRUEsS0FBUSxHQUFDLEtBQUssTUFBTSxJQUFBO0FBQUEsaUJBQUEsSUFBQSxRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQU9yRixJQUFRLEdBQUMsS0FBSyxNQUFNLElBQUE7Ozs7O2dCQUF6QixNQUFJOzs7OztBQUF6QixhQUF3RCxRQUFBLFFBQUEsTUFBQTs7Ozs7bURBQTlCQSxLQUFRLEdBQUMsS0FBSyxNQUFNLElBQUE7QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFBQTs7Ozs7Ozs7OztpQkFGeUMsSUFBUSxHQUFDLEtBQUssTUFBTSxJQUFBOzs7Ozs7OztnQkFBekIsTUFBSTs7Z0JBQXVCLGNBQVk7Ozs7QUFBekgsYUFBaUksUUFBQSxRQUFBLE1BQUE7Ozs7Ozs7Ozs7bURBQTFDQSxLQUFRLEdBQUMsS0FBSyxNQUFNLElBQUE7QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7QUFSMUcsTUFBQSxXQUFBLE9BQVMsVUFBTUQsa0JBQUEsR0FBQTs7O2VBaUJELElBQVM7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQUQ1QixhQUVLLFFBQUEsS0FBQSxNQUFBOzs7OztBQWxCQSxVQUFBQyxRQUFTLFFBQU07Ozs7Ozs7Ozs7Ozs7O2tDQWlCREEsS0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkFnQ25CLElBQVU7O21DQUFmLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VCQUFDQSxLQUFVOztxQ0FBZixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs4QkFBSixRQUFJLElBQUEsWUFBQSxRQUFBLEtBQUEsR0FBQTs7Ozs7Ozs7O3VDQUFKLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFRVSxJQUFRO0FBQUEsZ0JBQ1osSUFBVTtBQUFBLGNBQ1osVUFBVSxJQUFTLEtBQUUsSUFBTSxHQUFBO0FBQUEsTUFDN0IsTUFBQSxRQUFTLEtBQUksSUFBQSxHQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7OzttQ0FITCxJQUFROzsrQkFDWixJQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBMUJmLElBQUksSUFBUyxHQUFDLEtBQUs7O21DQUF4QixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1QkFBQyxJQUFJQSxLQUFTLEdBQUMsS0FBSzs7cUNBQXhCLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7OzhCQUFKLFFBQUksSUFBQSxZQUFBLFFBQUEsS0FBQSxHQUFBOzs7Ozs7Ozs7dUNBQUosUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBR0UsSUFBTztBQUFBLE1BQ1IsS0FBQSxPQUFVO0FBQUEsTUFDUCxRQUFBLFFBQVU7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OzJCQUZaLElBQU87QUFDUixVQUFBLE1BQUEsS0FBQTtBQUFBLG9CQUFBLE1BQUEsT0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJBeUNWLElBQUksSUFBcUIsR0FBQyxJQUFXLEdBQUEsQ0FBQTs7aUNBQTFDLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBQUMsSUFBSUEsS0FBcUIsR0FBQ0EsS0FBVyxHQUFBLENBQUE7O21DQUExQyxRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozt3Q0FBSjtBQUFBOzs7Ozs7Ozs7O0FBQ0EsTUFBQSxVQUFBLFFBQVEsT0FBSTs7Ozs7Ozs7OztBQUFaLFVBQUEsTUFBQSxLQUFBLEtBQUEsYUFBQSxVQUFBQSxTQUFRLE9BQUk7QUFBQSxpQkFBQSxHQUFBLE9BQUE7QUFBQTs7Ozs7Ozs7Ozs7ZUFKK0IsbUJBRTlDO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkE3Q1EsSUFBb0IsR0FBQSxHQUFBLElBQUE7Ozs7Ozs7Ozs7OzZCQTJDcEIsU0FBUyxtQkFBbUIsSUFBUyxFQUFBLEdBQUEsTUFBQTs7Ozs7Ozs7OztBQTdDOUMsYUFvREssUUFBQSxLQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7O3FEQVBJLFNBQVMsbUJBQW1CLElBQVMsRUFBQSxNQUFBLGVBQUEsV0FBQSxNQUFBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBM0V6QyxJQUFTOzs7O3VCQTZCVCxJQUFrQjs7Ozs7Ozs7OztBQXZFbkIsTUFBQSxXQUFBLE9BQVUsV0FBTyxrQkFBQTs7OzthQVNkLElBQVE7QUFBQSxNQUNMLFVBQUEsT0FBWTtBQUFBLGdCQUNaLElBQVc7QUFBQSxvQkFDUCxJQUFlO0FBQUE7UUFFNUIsTUFDQyxFQUFBLE9BQU8sUUFDUCxTQUFPLElBQUEsSUFBQTtBQUFBLFFBU1IsTUFBSTtBQUFBLFVBQ0gsT0FBTztBQUFBLFVBQ1AsU0FBTyxJQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEzQkwsVUFBQUEsUUFBVSxTQUFPOzs7Ozs7Ozs7Ozs7OztpQ0FTZEEsS0FBUTtBQUNMLFVBQUEsTUFBQSxLQUFBO0FBQUEseUJBQUEsV0FBQUEsUUFBWTs7b0NBQ1pBLEtBQVc7O3dDQUNQQSxLQUFlOzs7VUFFNUIsTUFDQyxFQUFBLE9BQU8sUUFDUCxTQUFPQSxLQUFBLElBQUE7QUFBQSxVQVNSLE1BQUk7QUFBQSxZQUNILE9BQU87QUFBQSxZQUNQLFNBQU9BLEtBQUE7QUFBQTs7O3NFQWVKQSxLQUFTLEVBQUEsR0FBQTs7Ozs7Ozs7Ozs7MkVBNkJUQSxLQUFrQixFQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBdk9sQix3QkFBeUIsaUJBQWlELE9BQU8sYUFBVyxDQUFHLEdBQUcsTUFBTSxDQUFDO1FBR3pHLFNBQVMsV0FBaUIsTUFBTTtNQUVsQyxXQUFRLElBQU8sVUFBVSxDQUFDO0FBQzFCLE1BQUEsYUFBYTtNQUViLFdBQVEsQ0FBQTtNQUVSO01BQ0EsV0FBUSxJQUFPLFFBQWlCLGdCQUFVO0FBQzdDLHVCQUFtQjtBQUFBO0FBR2hCLE1BQUEsaUJBQWlCO1dBY1osY0FBVztBQUNuQixrQkFBYztBQUNYLFNBQXFCLFlBQVU7QUFDM0IsWUFBQSxVQUFVLFlBQVksU0FBUyxZQUFZLEtBQUs7QUFDdEQsdUJBQWlCLE9BQU87QUFHbEIsWUFBQSxZQUFZO0FBQ2IsV0FBQSxTQUFTLEtBQUssUUFBTSxHQUFHLElBQUc7QUFBQSxXQUMzQjtBQUFBLFFBQ0gsT0FBSyxFQUNKLGtCQUFrQixRQUFPO0FBQUE7OztpQkEwQmQsdUJBQW9CO1FBQzlCOztBQUVILG1CQUFtQixNQUFBLG1CQUFtQixhQUFhLFNBQVM7QUFBQSxhQUV2RDtBQUNMLGVBQ0MsT0FBTyxXQUNQLE1BQU0sZ0JBQWUsQ0FBQTs7O1VBS2pCLFNBQU0sQ0FBQTtBQUVELGVBQUEsQ0FBQSxTQUFTLE1BQU0sS0FBSyxJQUFJLFVBQVUsS0FBSyxHQUFBO1lBQzNDLFdBQVcsV0FBVztBQUV4QixVQUFBLENBQUEsWUFBWSxRQUFRLFNBQVMsUUFBUSxRQUFNO0FBQzlDLGlCQUFTLEtBQUssT0FBTztBQUFBO0FBR3RCLG9CQUFjO0FBRWQsYUFBTyxLQUFJO0FBQUEsUUFDVjtBQUFBLFFBQ0EsVUFBVSxNQUFNO0FBQUEsUUFDaEIsVUFBVSxXQUFPLEVBQUssUUFBTyxLQUFLLE9BQU0sT0FBTyxNQUFLO0FBQUEsZUFDOUMsVUFBNEI7QUFDM0IsZ0JBQUEsbUJBQW1CO0FBRXpCLHFCQUFXLFNBQVMsS0FBSyxVQUFVO0FBRW5DO2lCQUNPO0FBQUE7OztBQUtOLFFBQUEsQ0FBQSxPQUFPLFFBQU07QUFDaEIsb0JBQWM7QUFDZDs7O1dBS007QUFBQTtRQUlGLFlBQVM7QUFBQSxJQUNkLHFCQUFxQjtBQUFBLElBQ3JCLFlBQVk7QUFBQTs7QUEyRFQsV0FBTyxLQUFJO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxPQUFLLEVBQ0osTUFBTSxZQUFXO0FBQUE7OztBQVFuQixrQkFBYyxlQUFlO0FBQUE7QUF1QlMsUUFBQU8saUJBQUEsTUFBQSxtQkFBbUIsVUFBVSxVQUFVLEdBQUU7O0FBK0I3RSxXQUFPLEtBQUk7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULE9BQUssRUFDSixXQUFXLFNBQVE7QUFBQTs7QUFrQkYsUUFBQSxTQUFBLFFBQU0sWUFBWSxHQUFHLFNBQVEsR0FBSSxLQUFLOztBQUV6RCxXQUFPLEtBQUk7QUFBQSxNQUNWLFNBQVM7QUFBQSxNQUNULE9BQUssRUFDSixXQUFXLFNBQVE7QUFBQTs7OztBQTVQMUI7QUFDRyxZQUFBLGNBQWMsZ0JBQWM7QUFDOUIsdUJBQUEsSUFBQSxpQkFBaUIsU0FBUztBQUMxQixxQkFBUSxJQUFPLFVBQVUsQ0FBQztBQUMxQix1QkFBYTswQkFDYixXQUFRLElBQU8sUUFBaUIsZ0JBQVU7QUFDekMsK0JBQW1CO0FBQUE7MEJBRXBCLFdBQVEsQ0FBQSxDQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VDMEVhLElBQVM7QUFBQTtnQkFBaUIsVUFBVSxJQUFZLElBQUEsQ0FBRyxJQUFZLEVBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUNBQXJDLFVBQVVQLEtBQVksSUFBQSxDQUFHQSxLQUFZLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW5CcEYsYUFBOEUsUUFBQSxPQUFBLE1BQUE7NkJBQTdCLElBQU0sRUFBQTs7Ozs7Ozt1Q0FBTkEsS0FBTSxJQUFBOytCQUFOQSxLQUFNLEVBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztlQVczQixJQUFVO0FBQUE7Ozs7Ozs7Ozs7Ozs7a0NBQVZBLEtBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQW5CbEIscUJBRXRCO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztpQkFMRSxJQUFPLEtBQUUsU0FBUTs7Ozs7Ozs7Ozs7Ozs7OztpQkFHWCxJQUFZLEdBQUEsR0FBQSxJQUFBOzs7OztnQkFISyxVQUN6Qjs7Ozs7O0FBRkEsYUFFSSxRQUFBLElBQUEsTUFBQTs7Ozs7Ozs7Ozs7OzhEQURGLElBQU8sS0FBRSxTQUFRO0FBQUssaUJBQUEsSUFBQSxRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQWpGYixRQUFvQixJQUFBO0FBQ3pCLFFBQUEsWUFBWTtNQUVkO0FBRUEsTUFBQSxTQUFTO01BQ1Q7UUFNRSxZQUFZLFdBQWtDLFdBQVc7UUFDekQsU0FBUyxXQUFpQixNQUFNO2lCQUV2QixlQUFZO1VBQ3BCLGNBQVcsTUFBUyxTQUFTO0FBQ25DLGlCQUFBLEdBQUEsWUFBWSxZQUFZLEdBQUcsU0FBUyxDQUFBO29CQUNwQyxTQUFTLFVBQVUsSUFBSTtBQUFBO2lCQUdULGVBQVk7QUFDMUIsV0FBTyxPQUFPLFdBQ2IsRUFBQSxNQUFNLE9BQU0sQ0FBQTtVQUdQLFNBQVMsS0FBSyxpQkFBZSxZQUFZLElBQUksU0FBUyxDQUFBO0FBR3pELFFBQUEsY0FBYyxpQkFBZTtBQUMvQixzQkFBQSxnQkFBQSxrQkFBa0IsV0FBUyxlQUFBO0FBQUE7UUFHekIsV0FBUztBQUNYLGdCQUFVLElBQUk7QUFBQTtBQUdkLGFBQU8sTUFBSztBQUFBOzs7QUF1RHFDLGFBQU0sS0FBQTs7Ozs7Ozs7O0FBcEZ4RCxtQkFBQSxHQUFFLGVBQVksQ0FBQSxDQUFLLE1BQU07QUFBQTs7QUFFekIsbUJBQUEsR0FBRSxhQUFhLFlBQVcsT0FBTyxXQUFXLFVBQVUsUUFBUSxTQUFTLElBQUcsRUFBRTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JDeURqRSxJQUFTO0FBQUEsb0JBQ0wsSUFBUztBQUFBLGVBQ2QsSUFBVTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7b0NBRlRBLEtBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQUtTLFNBQUEsT0FBTyxXQUFXLE9BQVUsTUFBTTtBQUFBOzs7Ozs7Ozs7Ozs7QUFBbEMsVUFBQSxRQUFBO0FBQUEsd0JBQUEsVUFBQSxPQUFPLFdBQVdBLFFBQVUsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQVQxQyxZQUV0QjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBRlEsSUFBWSxHQUFBLEdBQUEsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUEvRFQsV0FBdUIsSUFBQTtBQUM1QixRQUFBLFlBQVk7TUFFZDtRQUVFLFNBQVMsV0FBaUIsTUFBTTtpQkFHdkIsZUFBWTtVQUNwQixjQUFXLE1BQVMsU0FBUztBQUU1QixXQUFBLGFBQUEsR0FBQSxZQUFZLFlBQVksR0FBRyxTQUFTLENBQUE7QUFBQTtRQUd0QyxhQUFVO0FBQUEsSUFDZixNQUFJO0FBQUEsTUFDSCxPQUFPO0FBQUEsTUFDUCxVQUFPO0FBQ04sZUFBTyxLQUFJO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxPQUFLO0FBQUEsWUFDSixNQUFNLE9BQU8sV0FBVyxVQUFVLE1BQU07QUFBQTs7OztJQUs1QyxNQUFJO0FBQUEsTUFDSCxPQUFPO0FBQUEsTUFDUCxVQUFPO0FBQ04sc0JBQWMsU0FBUztBQUFBOztJQUd6QixNQUFJO0FBQUEsTUFDSCxPQUFPO0FBQUEsTUFDUCxVQUFPO0FBQ04sZUFBTyxLQUFJO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxPQUFLLEVBQ0osU0FBUyxVQUFTO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRUEsUUFBQSxjQUFBLE9BQU8sV0FBVyxhQUFVLE1BQU07Ozs7Ozs7Ozs7Ozs7OztxQkFGakQsSUFBUzs7Ozs7Ozs7Ozs7Ozs7O21FQUFUQSxLQUFTLEVBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NENBcUJPLElBQVEsR0FBQSxFQUFBLENBQUE7Ozs7Ozs7Ozs7O0FBTDFCLGFBR0ssUUFBQSxLQUFBLE1BQUE7Ozs7Ozs7OztrQ0FFYUEsS0FBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBakJqQixJQUFTO0FBQUEsb0JBQ0wsSUFBUztBQUFBLGVBQ2QsSUFBUTtBQUFBLGlCQUNOO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUhELElBQVM7O21DQUNMLElBQVM7OzhCQUNkLElBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkFMWixJQUFVOztpQ0FBZixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkFBQ0EsS0FBVTs7bUNBQWYsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7NEJBQUosUUFBSSxJQUFBLFlBQUEsUUFBQSxLQUFBLEdBQUE7Ozs7Ozs7OztxQ0FBSixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFKZSxZQUV2QjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkFGUSxJQUFhLEdBQUEsR0FBQSxJQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0FBRHRCLGFBK0JLLFFBQUEsS0FBQSxNQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFoRUMsU0FBUyxXQUFpQixNQUFNO01BRWxDO2lCQUNXLGdCQUFhO1VBQ3JCLGNBQVcsTUFBUyxTQUFTOzJCQUU1QixhQUFhLFlBQVksUUFBTyxDQUFBO0FBQUE7QUF1Q25CLFFBQUFPLGlCQUFBLGVBQUEsT0FBTyxLQUFJO0FBQUEsSUFDMUIsU0FBUztBQUFBLElBQ1QsT0FBSyxFQUNKLFlBQVksVUFBUztBQUFBOzs7Ozs7Ozs7QUNuRTdCLElBQUksS0FBSztBQUVNLFNBQVMsUUFBUTtBQUM5QixTQUFPLGVBQWU7QUFDeEI7Ozs7Ozs7Ozs7Ozs7Ozs7QUM2RkEsYUFFSyxRQUFBLEtBQUEsTUFBQTs7Ozs7O3lDQUZnQyxJQUFhLEVBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BaEduQyxPQUFJLENBQUE7QUFtQlIsU0FBQSx3QkFBd0IsS0FBSyxNQUFNLGVBQWE7QUFDakQsUUFBQSxRQUFRLElBQUksUUFBUSxJQUFJO0FBQzlCLE1BQUksT0FBTyxPQUFPLENBQUM7QUFDbkIsZ0JBQWMsT0FBTyxjQUFZLGFBQWEsT0FBUSxJQUFJLFVBQVUsSUFBSSxJQUFJLFNBQVMsS0FBTSxRQUFROzs7OztBQWYxRixNQUFBLEVBQUEsdUJBQXVCLEVBQUMsSUFBQTtRQUU3QixjQUFXLENBQUE7UUFDWCxPQUFJLENBQUE7UUFDSixTQUFNLENBQUE7QUFFTixRQUFBLFdBQVcsU0FBUSxDQUFBLENBQUE7QUFDbkIsUUFBQSxZQUFZLFNBQVEsQ0FBQSxDQUFBO1FBRXBCLGNBQWMsU0FBUyxJQUFJOztRQUMzQixnQkFBZ0IsU0FBUyxJQUFJO0FBUTFCLFdBQUEsYUFBYSxLQUFLLE1BQU0sZUFBYTtBQUM1QyxRQUFJLEtBQUssSUFBSTtBQUNiLGtCQUFjLE9BQU8sY0FBWSxZQUFZLElBQUk7QUFDakQsb0JBQWdCLHdCQUF3QixLQUFLLE1BQU0sYUFBYSxDQUFBO0FBQUE7QUFHekQsV0FBQSxVQUFVLEtBQUc7QUFDZCxVQUFBLFFBQVEsS0FBSyxRQUFRLEdBQUc7QUFDOUIsZ0JBQVksSUFBSSxHQUFHO0FBQ25CLGtCQUFjLElBQUksT0FBTyxNQUFLO0FBQUE7QUFHaEMsYUFBVyxNQUFJO0FBQUEsSUFDYixZQUFZLEtBQUc7QUFDYixtQkFBYSxNQUFNLEtBQUssV0FBVztBQUFBO0lBR3JDLG1CQUFtQixZQUFVO0FBQzNCLGtCQUFZLEtBQUssVUFBVTtBQUFBO0lBRzdCLGNBQWMsT0FBSztBQUNqQixtQkFBYSxRQUFRLE9BQU8sYUFBYTtBQUFBO0lBRzNDO0FBQUEsSUFFQTtBQUFBLElBQ0E7QUFBQSxJQUVBO0FBQUEsSUFDQTtBQUFBO0FBR0YsVUFBTyxNQUFBO0FBQ0wsY0FBVSxLQUFLLHFCQUFvQjtBQUFBO0FBR3JDLGNBQVcsTUFBQTthQUNBLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxLQUFDO0FBQ2hDLGVBQVMsT0FBTyxtQkFBWTtBQUFBLFdBQVM7QUFBQSxTQUFlLEtBQUssR0FBRyxLQUFLLE9BQU8sR0FBRztBQUFBO0FBQzNFLGdCQUFVLE9BQU8sb0JBQWE7QUFBQSxXQUFTO0FBQUEsU0FBZ0IsT0FBTyxHQUFHLEtBQUssS0FBSyxHQUFHO0FBQUE7OztBQUluRSxpQkFBQSxjQUFjLE9BQUs7QUFDNUIsUUFBQSxNQUFNLE9BQU8sVUFBVSxTQUFTLGtCQUFrQixHQUFBO0FBQ2hELFVBQUEsZ0JBQWdCLEtBQUssUUFBUSxZQUFZO0FBRXJDLGNBQUEsTUFBTTtBQUFBLGFBQ1A7QUFDSCwyQkFBaUI7QUFDYixjQUFBLGdCQUFnQixLQUFLLFNBQVMsR0FBQztBQUNqQyw0QkFBZ0I7QUFBQTtBQUVsQixvQkFBVSxLQUFLLGNBQWE7QUFDNUIsc0JBQVksZUFBZTs7YUFHeEI7QUFDSCwyQkFBaUI7QUFDYixjQUFBLGdCQUFnQixHQUFDO0FBQ25CLDRCQUFnQixLQUFLLFNBQVM7QUFBQTtBQUVoQyxvQkFBVSxLQUFLLGNBQWE7QUFDNUIsc0JBQVksZUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0MvQixXQUFBLElBQUEsTUFBQSxPQUFJLEVBQUU7eURBQ0ssSUFBUyxHQUFDLElBQUcsR0FBQyxHQUFFO2dDQUNoQixJQUFVLEVBQUE7K0NBQ2QsSUFBVSxLQUFHLElBQUMsRUFBSzs7Z0RBQ0QsSUFBVSxFQUFBO0FBQUE7O0FBUHpDLGFBV0ksUUFBQSxJQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3RkFQYVAsS0FBUyxHQUFDQSxLQUFHLEdBQUMsTUFBRTs7OztrQ0FDaEJBLEtBQVUsRUFBQTtBQUFBOzhFQUNkQSxLQUFVLEtBQUcsSUFBQyxLQUFLOzs7O2tEQUNEQSxLQUFVLEVBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BOUNuQztRQUVFLE1BQUcsRUFDUCxJQUFJLE1BQUssRUFBQTtVQUVILGFBQWEsb0JBQW9CLFdBQVcsYUFBYSxTQUFRLElBQUssV0FBVyxJQUFJOzs7TUFFekY7QUFHSixjQUFZLEdBQUc7QUFFZixVQUFPLFlBQUE7VUFDQyxLQUFJO0FBQ1YsdUJBQW1CLEtBQUs7QUFBQTs7O0FBMEJmLGNBQUs7Ozs7QUFRQSxRQUFBTyxpQkFBQSxNQUFBLFVBQVUsR0FBRzs7Ozs7OztBQXhDMUIsbUJBQUEsR0FBQSxhQUFhLGlCQUFpQixHQUFHO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOdEMsYUFFSSxRQUFBLElBQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNlRyxNQUFBLFdBQUEsV0FBbUIsSUFBSyxNQUFBUixrQkFBQSxHQUFBOzs7Ozs7QUFKekIsV0FBQSxLQUFBLE1BQUEsT0FBTSxFQUFFOytEQUNLLElBQVUsR0FBQyxJQUFLLEdBQUMsR0FBRTs7Ozs7QUFGdEMsYUFRSyxRQUFBLEtBQUEsTUFBQTs7Ozs7O0FBSEUsVUFBQUMsWUFBbUJBLEtBQUssSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4RkFIWkEsS0FBVSxHQUFDQSxLQUFLLEdBQUMsTUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFoQjlCLFFBQUssRUFDVCxJQUFJLE1BQUssRUFBQTtBQUVILFFBQUEsRUFBQSxlQUFlLGVBQWUsVUFBUyxJQUFLLFdBQVcsSUFBSTs7O0FBRW5FLGdCQUFjLEtBQUs7Ozs7Ozs7Ozs7Ozs7QUNYckIsSUFBZSxvQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNvQ2IsYUFFSSxRQUFBLElBQUEsTUFBQTs7QUFFSixhQUVHLFFBQUEsSUFBQSxNQUFBOztBQUVILGFBRUcsUUFBQSxJQUFBLE1BQUE7O0FBRUgsYUFJUSxRQUFBLFFBQUEsTUFBQTtBQUhQLGFBRU0sUUFBQSxJQUFBO3VCQURFOztBQUlULGFBSUssUUFBQSxLQUFBLE1BQUE7QUFISixhQUVRLEtBQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaERDLE1BQUEsRUFBQSxRQUFRLE1BQUssSUFBQTtBQUNsQixRQUFBLFVBQVU7UUFFVixTQUFTLFdBQWlCLE1BQU07V0FFN0IsT0FBSTtRQUNULFNBQU87QUFDVCxhQUFPLE1BQUs7QUFDUCxXQUFBLGNBQWMsZUFBZSxTQUFTLE1BQU07QUFBQTtBQUdqRCxhQUFPLElBQUc7QUFBQTs7K0JBbUM4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQzRDOUIsSUFBUztBQUFBLG9CQUNMLElBQVM7QUFBQSxlQUNkLElBQVU7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQUZUQSxLQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBSk4sb0JBRWY7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFRb0IsU0FDbkI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztNQUY2QixTQUFBLE9BQU8sT0FBTyxPQUFVLE9BQU87QUFBQTs7Ozs7Ozs7Ozs7O0FBQS9CLFVBQUEsUUFBQTtBQUFBLHdCQUFBLFVBQUEsT0FBTyxPQUFPQSxRQUFVLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQVR2REEsS0FBUztBQUFBLGFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQS9FSixXQUF1QixJQUFBO0FBQzVCLFFBQUEsWUFBWTtNQUVkO09BQ0MsT0FBTyxXQUFXLFNBQVMsRUFBRSxLQUFLLE9BQUMsYUFBQSxHQUFJLFlBQVksQ0FBRSxDQUFBO1FBSXBELFNBQVMsV0FBaUIsTUFBTTtRQUVoQyxhQUFVO0FBQUEsSUFDZixNQUFJO0FBQUEsTUFDSCxPQUFPO0FBQUEsTUFDUCxVQUFPO0FBQ04sZUFBTyxLQUFJO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxPQUFLLEVBQ0osSUFBSSxPQUFPLE9BQU8sVUFBVSxPQUFPLEVBQUE7QUFBQTs7O0lBS3ZDLE1BQUk7QUFBQSxNQUNILE9BQU87QUFBQSxNQUNQLFVBQU87QUFDTixlQUFPLEtBQUk7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULE9BQUssRUFDSixZQUFZLFVBQVM7QUFBQTs7O0lBS3pCLFFBQU07QUFBQSxNQUNMLE9BQU87QUFBQSxNQUNQLFVBQU87QUFDTixlQUFPLEtBQ04sRUFBQSxTQUFTLFFBQU8sQ0FBQTtBQUFBOzs7Ozs7Ozs7QUEvQkosa0JBQVcsT0FBTyxPQUFPLFVBQVUsT0FBTyxJQUFHO0FBQUE7Ozs7Ozs7Ozs7QUN0QjlELElBQWUsZ0JBQUE7Ozs7OztXQ3FITTtBQUFBLFdBQVMsSUFBSztBQUFBLFlBQVEsSUFBTTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBRHpDLElBQUssTUFBQUQsa0JBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFOMEIsbUJBQUEsTUFBQSxpQkFBQSxhQUFhLElBQVMsRUFBQTtBQUFBOztBQUE3RCxhQWtDSyxRQUFBLE1BQUEsTUFBQTtBQWpDSixhQWdDSyxNQUFBLElBQUE7QUEvQkosYUFRTSxNQUFBLEtBQUE7Ozs7QUFFTixhQW9CTSxNQUFBLEtBQUE7QUFuQkwsYUFPSyxPQUFBLElBQUE7O0FBRUwsYUFTSyxPQUFBLElBQUE7QUFSSixhQU9LLE1BQUEsSUFBQTtBQU5KLGFBRU0sTUFBQSxLQUFBO3dCQURFOztBQUVSLGFBRU0sTUFBQSxLQUFBOzs7Ozs7OztVQXZCSEMsS0FBSztBQUFBLGlCQUFBLEVBQUFBLE1BQUEsS0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBNUdELE9BQW9CLElBQUE7UUFDekIsUUFBUSxVQUFVO0FBRWIsTUFBQSxFQUFBLE9BQU8sR0FBRSxJQUFBO0FBQ2QsUUFBQSxTQUFTO0FBRUosTUFBQSxFQUFBLFNBQTZCLFFBQU8sSUFBQTtBQUN6QyxRQUFBLFlBQVk7O1FBS2QsT0FBSztBQUNRLFlBQUEsS0FBSyxHQUFHLEtBQUs7QUFBQTs7K0JBZ0hTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3NERixRQUFBLFFBQVc7QUFBQTtNQUFnQixJQUFNLE9BQUEsUUFBQTs0QkFBTixJQUFNO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUFBakMsVUFBQSxRQUFBO0FBQUEsMkJBQUEsU0FBQUEsU0FBVzs7O2tDQUFnQkEsS0FBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JsRSxNQUFBLFdBQUEsT0FBTyxJQUFVLEVBQUEsSUFBQTs7Ozs7aUJBSWhCLElBQUksSUFBVSxFQUFBLEVBQUEsZ0JBQTJDLElBQUcsTUFBQSxFQUErQixLQUFLLElBQUksSUFBQTs7Ozs7Ozs7Ozs7O2dCQURqRixHQUNwQjs7Z0JBQXVHLEdBQ3pHOzs7Ozs7QUFuQkEsYUFXTyxRQUFBLE9BQUEsTUFBQTs7QUFFUCxhQUVNLFFBQUEsT0FBQSxNQUFBOzs7QUFFTixhQUVNLFFBQUEsT0FBQSxNQUFBOzs7Ozs7QUFMSixVQUFBLFFBQUEsT0FBQSxjQUFBLFdBQUEsT0FBT0EsS0FBVSxFQUFBLElBQUE7QUFBQSxpQkFBQSxJQUFBLFFBQUE7a0RBSWhCLElBQUlBLEtBQVUsRUFBQSxFQUFBLGlCQUEyQyxJQUFHLE1BQUEsRUFBK0IsS0FBSyxJQUFJLElBQUE7QUFBQSxpQkFBQSxJQUFBLFFBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWNyRyxJQUFVLEVBQUE7Ozs7QUFEWixhQUVNLFFBQUEsTUFBQSxNQUFBOzs7OztvQkFESkEsS0FBVSxFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7aUJBRlIsSUFBVSxNQUFBSyxvQkFBQSxHQUFBOzs7Ozs7Ozs7OztxQ0FGTyxJQUFVLEVBQUE7QUFBQTs7QUFBaEMsYUFBK0csUUFBQSxPQUFBLE1BQUE7NkJBQWxDLElBQU0sRUFBQTs7Ozs7Ozs7Ozs7dUNBQU5MLEtBQU0sSUFBQTsrQkFBTkEsS0FBTSxFQUFBO0FBQUE7O3VDQUE3REEsS0FBVSxFQUFBO0FBQUE7VUFFM0JBLEtBQVUsSUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBc0JaLElBQWEsRUFBQTs7OztBQURmLGFBRU0sUUFBQSxNQUFBLE1BQUE7Ozs7O29CQURKQSxLQUFhLEVBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7aUJBRlgsSUFBYSxNQUFBRCxrQkFBQSxHQUFBOzs7Ozs7Ozs7OzsyREFKSCxJQUFTLElBQUMsUUFBUSxNQUFHLE1BQUE7cUNBRnBCLElBQWEsRUFBQTtBQUFBOztBQUg3QixhQU9BLFFBQUEsT0FBQSxNQUFBOzZCQURhLElBQVMsRUFBQTs7Ozs7Ozs7Ozs7aUZBRFBDLEtBQVMsSUFBQyxRQUFRLE1BQUcsU0FBQTs7O3VDQUN2QkEsS0FBUyxJQUFBOytCQUFUQSxLQUFTLEVBQUE7QUFBQTs7dUNBSE5BLEtBQWEsRUFBQTtBQUFBO1VBTXhCQSxLQUFhLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXbEIsYUFBd0QsUUFBQSxVQUFBLE1BQUE7Z0NBQWxDLElBQU8sRUFBQTs7Ozs7Ozs7a0NBQVBBLEtBQU8sRUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBaUIzQixJQUFTLE1BQUUsU0FBUTs7Ozs7Ozs7OztjQTdGYixJQUFTLE1BQUUsU0FBUSxhQUFTO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFxRkYsSUFBUztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUgxQyxJQUFTLE1BQUUsU0FBUTs7Ozs7Ozs7Ozs7MERBVXVDLElBQVksRUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQWJ4RSxhQUFHLFFBQUEsSUFBQSxNQUFBOztBQUVILGFBRUksUUFBQSxJQUFBLE1BQUE7Ozs7QUFJSixhQVFLLFFBQUEsS0FBQSxNQUFBO0FBUEosYUFFUSxLQUFBLE9BQUE7O0FBRVIsYUFFUSxLQUFBLE9BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkZBRm1EQSxLQUFZLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBM0RGLE1BQUEsU0FBQSxDQUFBLENBQUEsRUFBQSxDQUFDLE1BQU0sRUFBRSxRQUFRLElBQUk7Ozs7Ozs7Ozs7OztRQWxNckYsU0FBUyxXQUFpQixNQUFNO0FBSzNCLE1BQUEsRUFBQSxhQUErQixHQUFFLElBQUE7UUFDdEMsWUFBWSxjQUFjO01BRzVCO0FBR0QsTUFBQTtBQUFnQixTQUFBLE9BQU8sV0FBVyxTQUFTLEVBQUUsS0FBSyxPQUFLLGFBQUEsR0FBQSxZQUFZLENBQUUsQ0FBQTtNQUdwRSxXQUFRLENBQUE7a0JBQ0ksY0FBVztBQUMxQixpQkFBQSxHQUFBLFdBQVcsS0FBRyxNQUFRLE9BQU8sUUFBUSxRQUFPLENBQUEsQ0FBQTtBQUFBO0FBVXpDLE1BQUEsYUFBYTtBQUNiLE1BQUEsZ0JBQWdCO0FBRVgsV0FBQSxpQkFBaUIsWUFBb0IsYUFBVyxPQUFLO0FBQ3ZELFVBQUEsU0FBUyxTQUFTLEtBQUssVUFBVTtTQUNuQyxRQUFNO1VBQ04sWUFBVTtBQUNaLHFCQUFBLEdBQUEsZ0JBQWdCLHdCQUF3QjtBQUFBO2FBR2xDO0FBQUE7YUFHQyxTQUFTLGNBQWMsSUFBSTtBQUVoQyxRQUFBLGdCQUFnQjtrQkFDUCxPQUFPLEtBQUssSUFBSSxRQUFRLEdBQUE7QUFDakMsVUFBQSxRQUFRLElBQUksZUFBZSxTQUFPO0FBQ3BDLHdCQUFnQjs7OztRQUtmLFlBQVU7V0FDUixlQUFhO0FBQ2hCLHFCQUFBLEdBQUEsaURBQWlELFVBQU87QUFBQTtBQUd4RCxxQkFBQSxHQUFBLGdCQUFnQixFQUFFO0FBQUE7O0FBSWIsV0FBQSxhQUFBLElBQUEsU0FBUyxjQUFjO0FBQUE7QUFJM0IsTUFBQSxxQkFBcUI7TUFXckI7aUJBQ1csT0FBSTtTQUNkLGNBQVk7dUJBQ2Ysc0JBQWtCLGtCQUFBOztlQUlYLFdBQVM7QUFDaEIsYUFBTyxPQUFPLFdBQVM7QUFBQSxRQUN0QixNQUFNO0FBQUEsUUFDTixTQUFTO0FBQUEsUUFDVCxLQUFLLFVBQVU7QUFBQSxRQUNmLFdBQVc7QUFBQSxRQUNYLE9BQU87QUFBQTtBQUdSLGFBQU8sTUFBSztBQUFBO3NCQWNaLFlBQVM7QUFBQSxRQUNSLE1BQU07QUFBQSxRQUNOLFFBQVE7QUFBQSxRQUNSLFNBQVM7QUFBQSxRQUNULEtBQUssVUFBVTtBQUFBLFFBQ2YsV0FBVztBQUFBLFFBQ1gsT0FBTztBQUFBLFFBQ1AsT0FBTztBQUFBLFFBQ1AsUUFBUTtBQUFBLFFBQ1IsUUFBTSxDQUFBO0FBQUE7OztZQU9ELE9BQU8sS0FBSSxPQUFPLGNBQVM7Y0FDMUIsVUFBVSxXQUFXLFNBQVM7QUFBQTtBQUdyQyxhQUFPLE1BQUs7QUFHWixhQUFPLEtBQUk7QUFBQSxRQUNWLFNBQVM7QUFBQSxRQUNULE9BQUssRUFDSixZQUFZLFVBQVM7QUFBQTthQUlsQjs7OztBQWtDeUQsYUFBTTs7O0FBMEJ4QyxRQUFBLE9BQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQyxNQUFNLGVBQWUsRUFBRTs7QUFVd0IsYUFBTSxLQUFBOzs7O0FBbUJ0RSxnQkFBUyxLQUFBOzs7O0FBY0EsY0FBTyxLQUFBOzs7QUFZTCxRQUFBTyxpQkFBQSxNQUFBLE9BQU87Z0NBSVM7OztBQS9GdkIsaUJBQVE7Ozs7Ozs7Ozs7c0JBekl2QixTQUFTLFdBQVcsUUFBUSxFQUFFO0FBQUE7O3VCQUM5QixTQUFTLFdBQVcsV0FBVyxFQUFFO0FBQUE7O0FBQ25DLG1CQUFBLEdBQUUsWUFBWSxTQUFRLE9BQU8sT0FBTyxNQUFnQixJQUFHLEVBQUU7QUFBQTs7c0JBQ3ZELFVBQVUsV0FBVyxTQUFTLEVBQUU7QUFBQTs7QUFDaEMsc0JBQWdCLFdBQVcsYUFBYSxpQkFBaUI7QUFBQTs7c0JBcUN6RCxlQUFZLENBQUEsRUFBTSxVQUFVLGlCQUFpQixTQUFTLEVBQUE7QUFBQTs7QUFHeEQ7WUFDRyxvQkFBa0I7QUFDcEIsdUJBQUEsR0FBQSxhQUFhLFNBQVEsS0FBSSx3QkFBd0I7QUFDakQsMkJBQWlCLFdBQVcsSUFBSTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZGbkMsSUFBZSxlQUFBO0FDQWYsSUFBZSxlQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21CQzBOTixJQUFNOztpQ0FBWCxRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkFBQ1AsS0FBTTs7bUNBQVgsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7NEJBQUosUUFBSSxJQUFBLFlBQUEsUUFBQSxLQUFBLEdBQUE7Ozs7Ozs7OztxQ0FBSixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQWdCZSxTQUFBLE9BQU8sT0FBTyxJQUFVLElBQUEsVUFBUSxFQUFFO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9uRCxhQUVNLFFBQUEsTUFBQSxNQUFBO3VCQURFWTtBQUFBQTs7Ozs7Ozs7Ozs7Ozs7OztvQkFITSxJQUFTO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkFtQmYsSUFBaUI7O21DQUF0QixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7O0FBRFAsYUFlTSxRQUFBLE1BQUEsTUFBQTs7Ozs7Ozs7O3VCQWRFLElBQWlCOztxQ0FBdEIsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7MENBQUo7QUFBQTs7Ozs7O0FBRHNDLFlBQUEsQ0FBQTtBQUFBLDRCQUFBLGdDQUFBLE1BQUEsT0FBQSxFQUFBLFVBQVMsS0FBSyxRQUFPLFNBQVEsR0FBQSxJQUFBOzs7Ozs7QUFBN0IsVUFBQSxDQUFBO0FBQUEsMEJBQUEsZ0NBQUEsTUFBQSxPQUFBLEVBQUEsVUFBUyxLQUFLLFFBQU8sU0FBUSxHQUFBLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPM0QsTUFBQSxZQUFBLFFBQVMsT0FBSTs7O0FBSW5CLE1BQUEsV0FBQSxRQUFTLFFBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVRqQixhQVdLLFFBQUEsS0FBQSxNQUFBO0FBUEpFLGFBRU0sS0FBQSxLQUFBOzs7QUFFTkEsYUFFTSxLQUFBLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYkwsTUFBQSxXQUFBLFdBQWUsSUFBUyxPQUFBZixrQkFBQSxHQUFBOzs7Ozs7Ozs7QUFOZCxtQkFBQSxNQUFBLFVBQUEsV0FBZSxJQUFTLEdBQUE7QUFBQTs7QUFGdkMsYUFNTSxRQUFBLE1BQUEsTUFBQTt1QkFERTs7Ozs7Ozt3Q0FGRyxJQUFnQixHQUFDLElBQVMsS0FBRSxJQUFTLEdBQUEsQ0FBQTs7Ozs7OztBQURqQyxxQkFBQSxNQUFBLFVBQUEsV0FBZSxJQUFTLEdBQUE7QUFBQTtBQU1sQyxVQUFBLFdBQWUsSUFBUyxLQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQXBDcEIsSUFBUztBQUFBLG9CQUNMLElBQVM7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFOSCxxQkFFdkI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQUZRLElBQWEsR0FBQSxHQUFBLElBQUE7Ozs7Ozs7O0FBRHRCLGFBZ0VLLFFBQUEsS0FBQSxNQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQXJQRSxTQUFTLFdBQWlCLE1BQU07UUFHM0IsU0FBdUQsT0FBSyxLQUFJLElBQUE7QUFFaEUsTUFBQSxFQUFBLE9BQTBFLENBQUEsS0FBSyxRQUFRLElBQUksT0FBTyxJQUFJLE9BQU8sS0FBRyxFQUFDLElBQUE7UUFFakgsUUFBQWdCLFVBQU0sR0FBQSxJQUFBO2lCQUlGLGdCQUFhO1VBRXJCLFlBQVMsTUFBUyxPQUFPO2VBR3BCLFVBQVUsU0FBUyxVQUFVLENBQUE7QUFBQTtBQUduQyxRQUFBLGdDQUFnQjtBQUVsQixNQUFBLGFBQWE7V0FDUixpQkFBaUIsV0FBbUIsV0FBK0I7V0FDbkUsYUFBbUI7QUFFMUIsY0FBUSx5QkFBd0I7QUFHMUIsWUFBQSxTQUFTO0FBR1osVUFBQSxVQUFVLElBQUksT0FBTyxHQUFHLGVBQWUsUUFBTTtBQUMvQyxxQkFBQSxHQUFBLGFBQWEsRUFBRTs7O0FBS2hCLG1CQUFBLEdBQUEsYUFBYSxNQUFNO0FBR25CLGFBQU87QUFBQSxRQUFpQjtBQUFBO0FBQ3ZCLG9CQUFVLElBQUksU0FDYixFQUFBLFlBQVksV0FBVSxDQUFBO0FBRXZCLHVCQUFBLEdBQUEsYUFBYSxFQUFFO0FBQUE7UUFFZixFQUFBLFNBQVMsTUFDVCxNQUFNLEtBQUk7QUFBQTs7O1FBS1Asb0JBQWlCO0FBQUE7TUFNckIsT0FBTztBQUFBLE1BQ1AsTUFBTTtBQUFBLE1BQ04sTUFBTSxXQUErQjtBQUNwQyxlQUFPLEtBQUk7QUFBQSxVQUNWLFNBQVM7QUFBQSxVQUNULE9BQUssRUFDSixTQUFTLFVBQVM7QUFBQTs7OztNQU1yQixPQUFPO0FBQUEsTUFDUCxNQUFNO0FBQUEsTUFDTixNQUFNLFdBQStCO0FBQ3BDLGVBQU8sS0FBSTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsT0FBSztBQUFBLFlBQ0osV0FBVyxPQUFPLE9BQU8sVUFBVSxPQUFPO0FBQUE7Ozs7O01BTTdDLE9BQU87QUFBQSxNQUNQLE1BQU07QUFBQSxNQUNOLE1BQU0sV0FBK0I7QUFFcEMsZUFBTyxLQUFJLEVBQ1YsU0FBUyxTQUNULE9BQUssQ0FBQSxFQUFBLENBQUE7QUFBQTs7OytDQTBJNkIsWUFBTztBQUNyQyxZQUFRLGdCQUFlO0FBQ3ZCLGFBQVMsTUFBTSxTQUFTO0FBQUE7c0NBdkNsQixZQUFPO0FBQ2IsUUFBQSxDQUFBLFVBQVUsSUFBSSxPQUFPLEdBQUcsWUFBVTtBQUNyQyxhQUFPLEtBQUk7QUFBQSxRQUNWLFNBQVM7QUFBQSxRQUNULE9BQUssRUFDSixTQUFTLFVBQVM7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUNwTG5CLEtBRUo7QUFBQTs7Ozs7Ozs7Ozs7Ozs7ZUFFSSxRQUVKO0FBQUE7Ozs7Ozs7Ozs7Ozs7O2VBRUksV0FFSjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFwQ2EsYUFBaUIsTUFBTTtBQWlEM0IsUUFBQSxPQUFBLGVBQWEsaUJBQWlCLFdBQVcsVUFBVTtBQVFuRCxRQUFBQyxVQUFBLGVBQWEsaUJBQWlCLGFBQWEsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQkMvQ3ZELElBQU07O2lDQUFYLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQUFDaEIsS0FBTTs7bUNBQVgsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7NEJBQUosUUFBSSxJQUFBLFlBQUEsUUFBQSxLQUFBLEdBQUE7Ozs7Ozs7OztxQ0FBSixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BRUMsS0FBQSxPQUFNO0FBQUEsTUFDTCxNQUFBLE9BQU07QUFBQSxvQkFDRSxJQUFLO0FBQUEsaUJBQ1I7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQVJLLFlBRW5CO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQUZRLElBQVMsR0FBQSxHQUFBLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFEbEIsYUFtQkssUUFBQSxLQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUF2Q0MsU0FBUyxXQUFpQixNQUFNO2lCQUV2QixZQUFTO1VBQ2pCLFVBQU8sTUFBUyxLQUFLO0FBRXBCLFdBQUEsUUFBUTs7O0FBMEJYLFdBQU8sS0FBSSxDQUFBLENBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQ29ESixJQUFTO0FBQUEsb0JBQ0wsSUFBUztBQUFBLGVBQ2QsSUFBVTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7QUFrQmYsTUFBQSxXQUFBLE9BQVUsV0FBT0ssb0JBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQXBCWEwsS0FBUzs7Ozs7Ozs7OztBQW9CZixVQUFBQSxRQUFVLFNBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUF4QlYsb0JBRWI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFVb0IsU0FDbkI7QUFBQTs7Ozs7Ozs7Ozs7O0FBSEksTUFBQSxXQUFBLE9BQVEsT0FBSTs7O0FBQUksTUFBQSxXQUFBLE9BQVEsS0FBRTs7Ozs7OztnQkFBYixJQUFFOztnQkFBWSxHQUM3Qjs7OztBQUZBLGFBRU0sUUFBQSxNQUFBLE1BQUE7Ozs7Ozs7QUFESixVQUFBLFFBQUEsS0FBQSxjQUFBLFdBQUFBLFFBQVEsT0FBSTtBQUFBLGlCQUFBLElBQUEsUUFBQTtBQUFJLFVBQUEsUUFBQSxLQUFBLGNBQUEsV0FBQUEsUUFBUSxLQUFFO0FBQUEsaUJBQUEsSUFBQSxRQUFBO0FBQUE7Ozs7Ozs7O0FBVTNCLE1BQUEsVUFBQSxPQUFVLGFBQVU7Ozs7Ozs7Ozs7QUFBcEIsVUFBQSxRQUFBLEtBQUEsYUFBQSxVQUFBQSxRQUFVLGFBQVU7QUFBQSxpQkFBQSxHQUFBLE9BQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVbkIsTUFBQSxVQUFBLE9BQVUsVUFBTzs7Ozs7Ozs7OztBQUFqQixVQUFBLFFBQUEsS0FBQSxhQUFBLFVBQUFBLFFBQVUsVUFBTztBQUFBLGlCQUFBLEdBQUEsT0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0E5QmhCQSxLQUFPO0FBQUEsYUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQXZFRixXQUF1QixJQUFBO0FBQzVCLFFBQUEsWUFBWTtNQUVkO09BQ0MsU0FBUyxHQUFHLFNBQVMsRUFBRSxLQUFLLE9BQUMsYUFBQSxHQUFJLFlBQVksQ0FBRSxDQUFBO01BSWhEO0FBS1csYUFBaUIsTUFBTTtRQUVoQyxhQUFVLENBQUE7Ozs7Ozs7QUFUYixtQkFBQSxHQUFBLFVBQVUsV0FBVyxLQUFLO0FBQUE7O1VBR3ZCLFNBQU87YUFDUCxPQUFPLEdBQUcsT0FBb0IsRUFBRSxLQUFLLE9BQUMsYUFBQSxHQUFJLFVBQVUsQ0FBRSxDQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7OztBQ3dCdkMsUUFBQSxjQUFBLFVBQVUsR0FBQSxHQUFHLGFBQVUsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7bUJBRHhDLElBQVU7O2lDQUFmLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQUFDQSxLQUFVOzttQ0FBZixRQUFJLEtBQUEsR0FBQTs7Ozs7Ozs7Ozs7Ozs0QkFBSixRQUFJLElBQUEsWUFBQSxRQUFBLEtBQUEsR0FBQTs7Ozs7Ozs7O3FDQUFKLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0JBR00sSUFBUztBQUFBLG9CQUNMLElBQVM7QUFBQSxpQkFDWjtBQUFBLE1BQ0EsUUFBQSxHQUFBLElBQVMsSUFBQSxTQUFTLFFBQVM7QUFBQTs7Ozs7Ozs7Ozs7Ozs7QUFBM0IsVUFBQSxRQUFBO0FBQUEsb0JBQUEsU0FBQSxHQUFBLElBQVMsSUFBQSxTQUFTLFFBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFUbEIsWUFFdkI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lCQUZRLElBQWEsR0FBQSxHQUFBLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFEdEIsYUF1QkssUUFBQSxLQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUExREMsU0FBUyxXQUFpQixNQUFNO01BRWxDO01BQ0E7aUJBQ1csZ0JBQWE7QUFFMUIsaUJBQUEsR0FBQSxDQUFBLFdBQ0EsV0FBVyxJQUNGLE1BQUEsUUFBUSxJQUNqQixDQUFBLE9BQU8sS0FDUCxHQUFBLFNBQVMsS0FBSSxDQUFBLENBQUEsR0FBQSxTQUFBO0FBR1AsV0FBQSxZQUFZOzs7QUFrQ2YsV0FBTyxLQUFJO0FBQUEsTUFDVixTQUFTO0FBQUEsTUFDVCxPQUFLLEVBQ0osWUFBWSxVQUFTO0FBQUE7Ozs7Ozs7Ozs7O0FDRFAsUUFBQSxjQUFBLE9BQVU7Ozs7Ozs7Ozs7Ozs7Ozs7OzJDQUdwQixJQUFRLEdBQUEsRUFBQSxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBTkcsb0JBRXJCO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUZRLGlCQUFBLE9BQU8sS0FBSSxHQUFBLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FCQURkLElBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUVBQVRBLEtBQVMsRUFBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF2Q1gsTUFBQSxZQUFZO0FBQ1YsUUFBQSxnQkFBZ0IsZUFBYztBQUFBLElBQ25DLFlBQVcsRUFBRSxLQUFJLFlBQVE7QUFDckIsVUFBQSxhQUFhLFVBQVE7d0JBQ3ZCLGFBQVMsU0FBQTtBQUFBOzs7QUFLWixZQUFTLE1BQUE7QUFDUjs7Ozs7Ozs7OztBQ2hCVSxJQUFBLDZCQUFBaUIsY0FBTDtBQUNOQSxZQUFBLGFBQVE7QUFDUkEsWUFBQSxVQUFLO0FBQ0xBLFlBQUEsWUFBTztBQUNQQSxZQUFBLFlBQU87QUFDUEEsWUFBQSxVQUFLO0FBQ0xBLFlBQUEsY0FBUztBQUNUQSxZQUFBLGFBQVE7QUFDUkEsWUFBQSxjQUFTO0FBQ1RBLFlBQUEsY0FBUztBQUNUQSxZQUFBLFVBQUs7QUFDTEEsWUFBQSxXQUFNO0FBWEtBLFNBQUFBO0FBQUEsR0FBQSxZQUFBLENBQUEsQ0FBQTtBQWNMLE1BQU0sWUFBWTtBQUFBLEVBQ3hCLENBQUMsWUFBbUJDO0FBQUFBLEVBQ3BCLENBQUMsU0FBZ0JDO0FBQUFBLEVBRWpCLENBQUMsV0FBa0JDO0FBQUFBLEVBRW5CLENBQUMsYUFBb0JDO0FBQUFBLEVBQ3JCLENBQUMsWUFBbUJDO0FBQUFBLEVBQ3BCLENBQUMsYUFBb0JDO0FBQUFBLEVBQ3JCLENBQUMsYUFBb0JDO0FBQUFBLEVBRXJCLENBQUMsVUFBaUJDO0FBQ25COzs7Ozs7Ozs7Ozs7O2VDSG1CLHNNQWdCbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhDQU0yRixLQUFNLElBQWtCLEtBQUcsRUFBRTs7Ozs7Ozs7QUF2QnpILGFBMEJLLFFBQUEsS0FBQSxNQUFBO0FBekJKLGFBZ0JPLEtBQUEsS0FBQTs7QUFFUCxhQUEyQyxLQUFBLE9BQUE7QUFFM0MsYUFBbUYsS0FBQSxPQUFBO0FBRW5GLGFBQXFKLEtBQUEsT0FBQTs7Ozs7Z0RBQTFELEtBQU16QixLQUFrQixLQUFHLEVBQUU7QUFBQTs7Ozs7Ozs7Ozs7Ozs7TUFqRHBIOzs7QUFpRG1JLG9CQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkNZekgsSUFBUzs7Ozs7Ozs7Ozs7Ozs7O0FBRkQsbUJBQUEsS0FBQSxXQUFBLFNBQVMsSUFBUyxFQUFBO0FBQUE7O0FBQXBELGFBSUssUUFBQSxLQUFBLE1BQUE7QUFISixhQUVTLEtBQUEsT0FBQTs7Ozs7Ozs7Ozs7Ozs7MkNBRGdCQSxLQUFTLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFGRCxxQkFBQSxLQUFBLFdBQUEsU0FBU0EsS0FBUyxFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQkFDUixhQUFZLFFBQVE7Ozs7QUFETSxRQUFBLGtCQUFBLE1BQUEsZ0JBQUEsVUFBQSxZQUFZLE1BQUksU0FBQTs7Ozs7Ozs7O0FDaEV0RixJQUFlLGlCQUFBO0FDQWYsSUFBZSxpQkFBQTtBQ0FmLElBQWUsa0JBQUE7QUNBZixJQUFlLGVBQUE7Ozs7Ozs7Ozs7OztBQzhTRixNQUFBLFlBQUEsUUFBUyxNQUFHOzs7OztBQUtsQixNQUFBLFdBQUEsUUFBUyxRQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBSGlDLElBQWlCLEdBQUMsU0FBUyxJQUFTLEdBQUEsQ0FBQTs7O29DQUpuRSxJQUFTLE1BQUEsaUJBQUE7QUFBaUIsbUJBQUEsSUFBQSxVQUFBLFdBQW1CLElBQVMsR0FBQTtBQUFBOztBQUF6RSxhQVNJLFFBQUEsSUFBQSxNQUFBO0FBUkgsYUFJSyxJQUFBLElBQUE7OztBQURKLGFBQTZGLE1BQUEsSUFBQTs7QUFFOUYsYUFFSyxJQUFBLElBQUE7Ozs7Ozs7Ozs7OzRDQUo0QyxJQUFpQixHQUFDLFNBQVMsSUFBUyxHQUFBLENBQUE7QUFBQTs7QUFKekMscUJBQUEsSUFBQSxVQUFBLFdBQW1CLElBQVMsR0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7OztBQVRoRSxNQUFBLFlBQUEsUUFBUyxNQUFHOzs7OztBQUtsQixNQUFBLFdBQUEsUUFBUyxRQUFLOzs7Ozs7Ozs7Ozs7Ozs7OzBDQUhpQyxJQUFpQixHQUFDLFNBQVMsSUFBUyxHQUFBLENBQUE7OztvQ0FKbkUsSUFBUyxNQUFBLGlCQUFBOztBQUFpQixtQkFBQSxJQUFBLFVBQUEsV0FBbUIsSUFBUyxHQUFBO0FBQUE7O0FBQXpFLGFBU0ksUUFBQSxJQUFBLE1BQUE7QUFSSCxhQUlLLElBQUEsSUFBQTs7O0FBREosYUFBNkYsTUFBQSxJQUFBOztBQUU5RixhQUVLLElBQUEsSUFBQTs7Ozs7OzRDQUo0Q0EsS0FBaUIsR0FBQyxTQUFTQSxLQUFTLEdBQUEsQ0FBQTtBQUFBOztBQUp6QyxxQkFBQSxJQUFBLFVBQUFBLFlBQW1CQSxLQUFTLEdBQUE7QUFBQTs7Ozs7Ozs7Ozs7QUFEckUsUUFBQUEsU0FBUztBQUFRLGFBQUFEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRGhCLE1BQUEsYUFBQSxJQUFJLElBQVMsRUFBQTs7aUNBQWxCLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7cUNBTGMsSUFBaUIsRUFBQTttQ0FBaUIsSUFBZSxFQUFBO0FBQUE7O0FBQXZFLGFBK0JLLFFBQUEsS0FBQSxNQUFBO0FBOUJKLGFBRUssS0FBQSxHQUFBO3NCQURHOztBQUVSLGFBMEJLLEtBQUEsRUFBQTs7Ozs7Ozs7Ozs7QUF6QkcscUJBQUEsSUFBSUMsS0FBUyxFQUFBOzttQ0FBbEIsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7d0NBQUo7QUFBQTs7dUNBTGtCQSxLQUFpQixFQUFBO0FBQUE7O3FDQUFpQkEsS0FBZSxFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUEzUGhFLFlBQVM7QUFBQSxLQUNiLFNBQVMsU0FDVCxFQUFBLEtBQUssZ0JBQ0wsT0FBTyxTQUFRO0FBQUEsSUFFZixDQUFBLFNBQVMsV0FBUTtBQUFBLE1BQ2pCLEtBQUs7QUFBQSxNQUNMLE9BQU87QUFBQSxNQUNQLFVBQVU7QUFBQTtLQU1WLFNBQVMsVUFDVCxFQUFBLEtBQUssaUJBQ0wsT0FBTyxVQUFTO0FBQUEsSUFHakIsUUFDQyxLQUFLLGNBQ0wsT0FBTyxPQUFNO0FBQUE7QUFPVCxRQUFBLGlCQUFxQixJQUFBLElBQzFCLE9BQU8sV0FBWSxDQUFBLFdBQVcsZUFBZ0IsQ0FBQSxZQUFZLFNBQXFCLENBQUEsQ0FBQTtBQUU1RSxNQUFBLGlCQUFnQztXQUkzQixtQkFBZ0I7QUFDeEIsb0JBQUEsa0JBQUEscUJBQXFCLG1CQUFpQixpQkFBQTtBQUFBO0FBRzlCLFdBQUEsVUFBVSxXQUFpQjtzQ0FFbkMsb0JBQW9CLGtCQUFrQixPQUFPLFFBQU0sY0FBYyxFQUFFLEdBQUEsaUJBQUE7UUFHaEUsVUFBUTtBQUVWLHNCQUFBLFNBQUEsV0FBVyxPQUFLLFFBQUE7QUFBQTtRQUlkLHFCQUFtQjtBQUNyQixzQkFBQSxvQkFBQSxzQkFBc0IsT0FBSyxtQkFBQTtBQUFBO1FBSXpCLHFCQUFtQjtBQUNyQixzQkFBQSxvQkFBQSxzQkFBc0IsT0FBSyxtQkFBQTtBQUFBO1lBSXJCO0FBQUEsV0FFRDtBQUVKLHdCQUFBLGtCQUFBLG9CQUFvQixNQUFJLGlCQUFBOzs7V0FNcEI7QUFFSixzQkFBYyxXQUFXLElBQUksU0FDNUIsRUFBQSxLQUFLLEdBQ0wsTUFBTSxHQUNOLFVBQVUsU0FBUSxDQUFBOzs7V0FPZixXQUFXO2NBRVQsYUFBYSxTQUFTO1lBQ3pCLGNBQWMsZUFBZSxJQUFJLFdBQVcsT0FBTyxNQUFNLFdBQVcsSUFBRTtBQUN4RSxtQkFBUyxJQUFHO0FBQUE7QUFJWixtQkFBUyxNQUFLO0FBQUE7Ozs7YUFTVixjQUFjLGVBQWUsU0FBcUI7Ozs7OytCQXlKZjtBQWlCbUQsUUFBQSxrQkFBQSxlQUFBLFVBQVUsU0FBUzs7O0FBN09oSCxtQkFBQSxHQUFFLGlCQUFpQixXQUFVLGVBQWUsSUFBSSxTQUFTLE9BQU8sS0FBSyxLQUFJLEVBQUU7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEQ3RSxTQUFTLFFBQVEsT0FBTztBQUN0QixTQUFPLENBQUMsTUFBTSxVQUNWLE9BQU8sS0FBSyxNQUFNLG1CQUNsQixNQUFNLFFBQVEsS0FBSztBQUN6QjtBQUdBLE1BQU0sV0FBVyxJQUFJO0FBQ3JCLFNBQVMsYUFBYSxPQUFPO0FBRTNCLE1BQUksT0FBTyxTQUFTLFVBQVU7QUFDNUIsV0FBTztBQUFBLEVBQ1I7QUFDRCxNQUFJLFNBQVMsUUFBUTtBQUNyQixTQUFPLFVBQVUsT0FBTyxJQUFJLFNBQVMsQ0FBQyxXQUFXLE9BQU87QUFDMUQ7QUFFQSxTQUFTLFNBQVMsT0FBTztBQUN2QixTQUFPLFNBQVMsT0FBTyxLQUFLLGFBQWEsS0FBSztBQUNoRDtBQUVBLFNBQVMsU0FBUyxPQUFPO0FBQ3ZCLFNBQU8sT0FBTyxVQUFVO0FBQzFCO0FBRUEsU0FBUyxTQUFTLE9BQU87QUFDdkIsU0FBTyxPQUFPLFVBQVU7QUFDMUI7QUFHQSxTQUFTLFVBQVUsT0FBTztBQUN4QixTQUNFLFVBQVUsUUFDVixVQUFVLFNBQ1QsYUFBYSxLQUFLLEtBQUssT0FBTyxLQUFLLEtBQUs7QUFFN0M7QUFFQSxTQUFTLFNBQVMsT0FBTztBQUN2QixTQUFPLE9BQU8sVUFBVTtBQUMxQjtBQUdBLFNBQVMsYUFBYSxPQUFPO0FBQzNCLFNBQU8sU0FBUyxLQUFLLEtBQUssVUFBVTtBQUN0QztBQUVBLFNBQVMsVUFBVSxPQUFPO0FBQ3hCLFNBQU8sVUFBVSxVQUFhLFVBQVU7QUFDMUM7QUFFQSxTQUFTLFFBQVEsT0FBTztBQUN0QixTQUFPLENBQUMsTUFBTSxLQUFJLEVBQUc7QUFDdkI7QUFJQSxTQUFTLE9BQU8sT0FBTztBQUNyQixTQUFPLFNBQVMsT0FDWixVQUFVLFNBQ1IsdUJBQ0Esa0JBQ0YsT0FBTyxVQUFVLFNBQVMsS0FBSyxLQUFLO0FBQzFDO0FBRUEsTUFBTSw4QkFBOEI7QUFFcEMsTUFBTSx1QkFBdUI7QUFFN0IsTUFBTSx1Q0FBdUMsQ0FBQyxRQUM1Qyx5QkFBeUI7QUFFM0IsTUFBTSwyQkFBMkIsQ0FBQyxRQUNoQyxpQ0FBaUM7QUFFbkMsTUFBTSx1QkFBdUIsQ0FBQyxTQUFTLFdBQVc7QUFFbEQsTUFBTSwyQkFBMkIsQ0FBQyxRQUNoQyw2QkFBNkI7QUFFL0IsTUFBTSxTQUFTLE9BQU8sVUFBVTtBQUVoQyxNQUFNLFNBQVM7QUFBQSxFQUNiLFlBQVksTUFBTTtBQUNoQixTQUFLLFFBQVE7QUFDYixTQUFLLFVBQVU7QUFFZixRQUFJLGNBQWM7QUFFbEIsU0FBSyxRQUFRLENBQUMsUUFBUTtBQUNwQixVQUFJLE1BQU0sVUFBVSxHQUFHO0FBRXZCLHFCQUFlLElBQUk7QUFFbkIsV0FBSyxNQUFNLEtBQUssR0FBRztBQUNuQixXQUFLLFFBQVEsSUFBSSxNQUFNO0FBRXZCLHFCQUFlLElBQUk7QUFBQSxJQUN6QixDQUFLO0FBR0QsU0FBSyxNQUFNLFFBQVEsQ0FBQyxRQUFRO0FBQzFCLFVBQUksVUFBVTtBQUFBLElBQ3BCLENBQUs7QUFBQSxFQUNGO0FBQUEsRUFDRCxJQUFJLE9BQU87QUFDVCxXQUFPLEtBQUssUUFBUTtBQUFBLEVBQ3JCO0FBQUEsRUFDRCxPQUFPO0FBQ0wsV0FBTyxLQUFLO0FBQUEsRUFDYjtBQUFBLEVBQ0QsU0FBUztBQUNQLFdBQU8sS0FBSyxVQUFVLEtBQUssS0FBSztBQUFBLEVBQ2pDO0FBQ0g7QUFFQSxTQUFTLFVBQVUsS0FBSztBQUN0QixNQUFJLE9BQU87QUFDWCxNQUFJMEIsTUFBSztBQUNULE1BQUksTUFBTTtBQUNWLE1BQUksU0FBUztBQUNiLE1BQUksUUFBUTtBQUVaLE1BQUksU0FBUyxHQUFHLEtBQUssUUFBUSxHQUFHLEdBQUc7QUFDakMsVUFBTTtBQUNOLFdBQU8sY0FBYyxHQUFHO0FBQ3hCLElBQUFBLE1BQUssWUFBWSxHQUFHO0FBQUEsRUFDeEIsT0FBUztBQUNMLFFBQUksQ0FBQyxPQUFPLEtBQUssS0FBSyxNQUFNLEdBQUc7QUFDN0IsWUFBTSxJQUFJLE1BQU0scUJBQXFCLE1BQU0sQ0FBQztBQUFBLElBQzdDO0FBRUQsVUFBTSxPQUFPLElBQUk7QUFDakIsVUFBTTtBQUVOLFFBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxHQUFHO0FBQzlCLGVBQVMsSUFBSTtBQUViLFVBQUksVUFBVSxHQUFHO0FBQ2YsY0FBTSxJQUFJLE1BQU0seUJBQXlCLElBQUksQ0FBQztBQUFBLE1BQy9DO0FBQUEsSUFDRjtBQUVELFdBQU8sY0FBYyxJQUFJO0FBQ3pCLElBQUFBLE1BQUssWUFBWSxJQUFJO0FBQ3JCLFlBQVEsSUFBSTtBQUFBLEVBQ2I7QUFFRCxTQUFPLEVBQUUsTUFBTSxJQUFBQSxLQUFJLFFBQVEsS0FBSyxNQUFPO0FBQ3pDO0FBRUEsU0FBUyxjQUFjLEtBQUs7QUFDMUIsU0FBTyxRQUFRLEdBQUcsSUFBSSxNQUFNLElBQUksTUFBTSxHQUFHO0FBQzNDO0FBRUEsU0FBUyxZQUFZLEtBQUs7QUFDeEIsU0FBTyxRQUFRLEdBQUcsSUFBSSxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQ3hDO0FBRUEsU0FBUyxJQUFJLEtBQUssTUFBTTtBQUN0QixNQUFJLE9BQU8sQ0FBQTtBQUNYLE1BQUksTUFBTTtBQUVWLFFBQU0sVUFBVSxDQUFDQyxNQUFLQyxPQUFNLFVBQVU7QUFDcEMsUUFBSSxDQUFDLFVBQVVELElBQUcsR0FBRztBQUNuQjtBQUFBLElBQ0Q7QUFDRCxRQUFJLENBQUNDLE1BQUssUUFBUTtBQUVoQixXQUFLLEtBQUtELElBQUc7QUFBQSxJQUNuQixPQUFXO0FBQ0wsVUFBSSxNQUFNQyxNQUFLO0FBRWYsWUFBTSxRQUFRRCxLQUFJO0FBRWxCLFVBQUksQ0FBQyxVQUFVLEtBQUssR0FBRztBQUNyQjtBQUFBLE1BQ0Q7QUFJRCxVQUNFLFVBQVVDLE1BQUssU0FBUyxNQUN2QixTQUFTLEtBQUssS0FBSyxTQUFTLEtBQUssS0FBSyxVQUFVLEtBQUssSUFDdEQ7QUFDQSxhQUFLLEtBQUssU0FBUyxLQUFLLENBQUM7QUFBQSxNQUNqQyxXQUFpQixRQUFRLEtBQUssR0FBRztBQUN6QixjQUFNO0FBRU4saUJBQVMsSUFBSSxHQUFHLE1BQU0sTUFBTSxRQUFRLElBQUksS0FBSyxLQUFLLEdBQUc7QUFDbkQsa0JBQVEsTUFBTSxJQUFJQSxPQUFNLFFBQVEsQ0FBQztBQUFBLFFBQ2xDO0FBQUEsTUFDVCxXQUFpQkEsTUFBSyxRQUFRO0FBRXRCLGdCQUFRLE9BQU9BLE9BQU0sUUFBUSxDQUFDO0FBQUEsTUFDL0I7QUFBQSxJQUNGO0FBQUEsRUFDTDtBQUdFLFVBQVEsS0FBSyxTQUFTLElBQUksSUFBSSxLQUFLLE1BQU0sR0FBRyxJQUFJLE1BQU0sQ0FBQztBQUV2RCxTQUFPLE1BQU0sT0FBTyxLQUFLO0FBQzNCO0FBRUEsTUFBTSxlQUFlO0FBQUEsRUFJbkIsZ0JBQWdCO0FBQUEsRUFHaEIsZ0JBQWdCO0FBQUEsRUFFaEIsb0JBQW9CO0FBQ3RCO0FBRUEsTUFBTSxlQUFlO0FBQUEsRUFHbkIsaUJBQWlCO0FBQUEsRUFFakIsY0FBYztBQUFBLEVBRWQsTUFBTSxDQUFFO0FBQUEsRUFFUixZQUFZO0FBQUEsRUFFWixRQUFRLENBQUMsR0FBRyxNQUNWLEVBQUUsVUFBVSxFQUFFLFFBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxLQUFLLElBQUssRUFBRSxRQUFRLEVBQUUsUUFBUSxLQUFLO0FBQzlFO0FBRUEsTUFBTSxlQUFlO0FBQUEsRUFFbkIsVUFBVTtBQUFBLEVBR1YsV0FBVztBQUFBLEVBTVgsVUFBVTtBQUNaO0FBRUEsTUFBTSxrQkFBa0I7QUFBQSxFQUV0QixtQkFBbUI7QUFBQSxFQUduQixPQUFPO0FBQUEsRUFJUCxnQkFBZ0I7QUFBQSxFQUloQixpQkFBaUI7QUFBQSxFQUVqQixpQkFBaUI7QUFDbkI7QUFFQSxJQUFJLFNBQVM7QUFBQSxFQUNYLEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFBQSxFQUNILEdBQUc7QUFDTDtBQUVBLE1BQU0sUUFBUTtBQUlkLFNBQVMsS0FBSyxTQUFTLEdBQUcsV0FBVyxHQUFHO0FBQ3RDLFFBQU0sUUFBUSxvQkFBSTtBQUNsQixRQUFNLElBQUksS0FBSyxJQUFJLElBQUksUUFBUTtBQUUvQixTQUFPO0FBQUEsSUFDTCxJQUFJLE9BQU87QUFDVCxZQUFNLFlBQVksTUFBTSxNQUFNLEtBQUssRUFBRTtBQUVyQyxVQUFJLE1BQU0sSUFBSSxTQUFTLEdBQUc7QUFDeEIsZUFBTyxNQUFNLElBQUksU0FBUztBQUFBLE1BQzNCO0FBR0QsWUFBTUMsUUFBTyxJQUFJLEtBQUssSUFBSSxXQUFXLE1BQU0sTUFBTTtBQUdqRCxZQUFNLElBQUksV0FBVyxLQUFLLE1BQU1BLFFBQU8sQ0FBQyxJQUFJLENBQUM7QUFFN0MsWUFBTSxJQUFJLFdBQVcsQ0FBQztBQUV0QixhQUFPO0FBQUEsSUFDUjtBQUFBLElBQ0QsUUFBUTtBQUNOLFlBQU0sTUFBSztBQUFBLElBQ1o7QUFBQSxFQUNGO0FBQ0g7QUFFQSxNQUFNLFVBQVU7QUFBQSxFQUNkLFlBQVk7QUFBQSxJQUNWLFFBQVEsT0FBTztBQUFBLElBQ2Ysa0JBQWtCLE9BQU87QUFBQSxFQUMxQixJQUFHLElBQUk7QUFDTixTQUFLLE9BQU8sS0FBSyxpQkFBaUIsQ0FBQztBQUNuQyxTQUFLLFFBQVE7QUFDYixTQUFLLFlBQVk7QUFFakIsU0FBSyxnQkFBZTtBQUFBLEVBQ3JCO0FBQUEsRUFDRCxXQUFXLE9BQU8sSUFBSTtBQUNwQixTQUFLLE9BQU87QUFBQSxFQUNiO0FBQUEsRUFDRCxnQkFBZ0IsVUFBVSxJQUFJO0FBQzVCLFNBQUssVUFBVTtBQUFBLEVBQ2hCO0FBQUEsRUFDRCxRQUFRLE9BQU8sSUFBSTtBQUNqQixTQUFLLE9BQU87QUFDWixTQUFLLFdBQVc7QUFDaEIsU0FBSyxRQUFRLENBQUMsS0FBSyxRQUFRO0FBQ3pCLFdBQUssU0FBUyxJQUFJLE1BQU07QUFBQSxJQUM5QixDQUFLO0FBQUEsRUFDRjtBQUFBLEVBQ0QsU0FBUztBQUNQLFFBQUksS0FBSyxhQUFhLENBQUMsS0FBSyxLQUFLLFFBQVE7QUFDdkM7QUFBQSxJQUNEO0FBRUQsU0FBSyxZQUFZO0FBR2pCLFFBQUksU0FBUyxLQUFLLEtBQUssRUFBRSxHQUFHO0FBQzFCLFdBQUssS0FBSyxRQUFRLENBQUMsS0FBSyxhQUFhO0FBQ25DLGFBQUssV0FBVyxLQUFLLFFBQVE7QUFBQSxNQUNyQyxDQUFPO0FBQUEsSUFDUCxPQUFXO0FBRUwsV0FBSyxLQUFLLFFBQVEsQ0FBQyxLQUFLLGFBQWE7QUFDbkMsYUFBSyxXQUFXLEtBQUssUUFBUTtBQUFBLE1BQ3JDLENBQU87QUFBQSxJQUNGO0FBRUQsU0FBSyxLQUFLO0VBQ1g7QUFBQSxFQUVELElBQUksS0FBSztBQUNQLFVBQU0sTUFBTSxLQUFLO0FBRWpCLFFBQUksU0FBUyxHQUFHLEdBQUc7QUFDakIsV0FBSyxXQUFXLEtBQUssR0FBRztBQUFBLElBQzlCLE9BQVc7QUFDTCxXQUFLLFdBQVcsS0FBSyxHQUFHO0FBQUEsSUFDekI7QUFBQSxFQUNGO0FBQUEsRUFFRCxTQUFTLEtBQUs7QUFDWixTQUFLLFFBQVEsT0FBTyxLQUFLLENBQUM7QUFHMUIsYUFBUyxJQUFJLEtBQUssTUFBTSxLQUFLLEtBQU0sR0FBRSxJQUFJLEtBQUssS0FBSyxHQUFHO0FBQ3BELFdBQUssUUFBUSxHQUFHLEtBQUs7QUFBQSxJQUN0QjtBQUFBLEVBQ0Y7QUFBQSxFQUNELHVCQUF1QixNQUFNLE9BQU87QUFDbEMsV0FBTyxLQUFLLEtBQUssU0FBUztBQUFBLEVBQzNCO0FBQUEsRUFDRCxPQUFPO0FBQ0wsV0FBTyxLQUFLLFFBQVE7QUFBQSxFQUNyQjtBQUFBLEVBQ0QsV0FBVyxLQUFLLFVBQVU7QUFDeEIsUUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLFFBQVEsR0FBRyxHQUFHO0FBQ25DO0FBQUEsSUFDRDtBQUVELFFBQUksU0FBUztBQUFBLE1BQ1gsR0FBRztBQUFBLE1BQ0gsR0FBRztBQUFBLE1BQ0gsR0FBRyxLQUFLLEtBQUssSUFBSSxHQUFHO0FBQUEsSUFDMUI7QUFFSSxTQUFLLFFBQVEsS0FBSyxNQUFNO0FBQUEsRUFDekI7QUFBQSxFQUNELFdBQVcsS0FBSyxVQUFVO0FBQ3hCLFFBQUksU0FBUyxFQUFFLEdBQUcsVUFBVSxHQUFHLENBQUUsRUFBQTtBQUdqQyxTQUFLLEtBQUssUUFBUSxDQUFDLEtBQUssYUFBYTtBQUNuQyxVQUFJLFFBQVEsSUFBSSxRQUFRLElBQUksTUFBTSxHQUFHLElBQUksS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJO0FBRWpFLFVBQUksQ0FBQyxVQUFVLEtBQUssR0FBRztBQUNyQjtBQUFBLE1BQ0Q7QUFFRCxVQUFJLFFBQVEsS0FBSyxHQUFHO0FBQ2xCLFlBQUksYUFBYSxDQUFBO0FBQ2pCLGNBQU0sUUFBUSxDQUFDLEVBQUUsZ0JBQWdCLElBQUksTUFBSyxDQUFFO0FBRTVDLGVBQU8sTUFBTSxRQUFRO0FBQ25CLGdCQUFNLEVBQUUsZ0JBQWdCLE9BQUFDLE9BQU8sSUFBRyxNQUFNLElBQUc7QUFFM0MsY0FBSSxDQUFDLFVBQVVBLE1BQUssR0FBRztBQUNyQjtBQUFBLFVBQ0Q7QUFFRCxjQUFJLFNBQVNBLE1BQUssS0FBSyxDQUFDLFFBQVFBLE1BQUssR0FBRztBQUN0QyxnQkFBSSxZQUFZO0FBQUEsY0FDZCxHQUFHQTtBQUFBLGNBQ0gsR0FBRztBQUFBLGNBQ0gsR0FBRyxLQUFLLEtBQUssSUFBSUEsTUFBSztBQUFBLFlBQ3BDO0FBRVksdUJBQVcsS0FBSyxTQUFTO0FBQUEsVUFDckMsV0FBcUIsUUFBUUEsTUFBSyxHQUFHO0FBQ3pCLFlBQUFBLE9BQU0sUUFBUSxDQUFDLE1BQU0sTUFBTTtBQUN6QixvQkFBTSxLQUFLO0FBQUEsZ0JBQ1QsZ0JBQWdCO0FBQUEsZ0JBQ2hCLE9BQU87QUFBQSxjQUN2QixDQUFlO0FBQUEsWUFDZixDQUFhO0FBQUEsVUFDYjtBQUFpQjtBQUFBLFFBQ1I7QUFDRCxlQUFPLEVBQUUsWUFBWTtBQUFBLE1BQzdCLFdBQWlCLFNBQVMsS0FBSyxLQUFLLENBQUMsUUFBUSxLQUFLLEdBQUc7QUFDN0MsWUFBSSxZQUFZO0FBQUEsVUFDZCxHQUFHO0FBQUEsVUFDSCxHQUFHLEtBQUssS0FBSyxJQUFJLEtBQUs7QUFBQSxRQUNoQztBQUVRLGVBQU8sRUFBRSxZQUFZO0FBQUEsTUFDdEI7QUFBQSxJQUNQLENBQUs7QUFFRCxTQUFLLFFBQVEsS0FBSyxNQUFNO0FBQUEsRUFDekI7QUFBQSxFQUNELFNBQVM7QUFDUCxXQUFPO0FBQUEsTUFDTCxNQUFNLEtBQUs7QUFBQSxNQUNYLFNBQVMsS0FBSztBQUFBLElBQ2Y7QUFBQSxFQUNGO0FBQ0g7QUFFQSxTQUFTLFlBQ1AsTUFDQSxNQUNBLEVBQUUsUUFBUSxPQUFPLE9BQU8sa0JBQWtCLE9BQU8sZ0JBQWUsSUFBSyxDQUFFLEdBQ3ZFO0FBQ0EsUUFBTSxVQUFVLElBQUksVUFBVSxFQUFFLE9BQU8sZ0JBQWlCLENBQUE7QUFDeEQsVUFBUSxRQUFRLEtBQUssSUFBSSxTQUFTLENBQUM7QUFDbkMsVUFBUSxXQUFXLElBQUk7QUFDdkIsVUFBUSxPQUFNO0FBQ2QsU0FBTztBQUNUO0FBRUEsU0FBUyxXQUNQLE1BQ0EsRUFBRSxRQUFRLE9BQU8sT0FBTyxrQkFBa0IsT0FBTyxnQkFBZSxJQUFLLENBQUUsR0FDdkU7QUFDQSxRQUFNLEVBQUUsTUFBTSxRQUFTLElBQUc7QUFDMUIsUUFBTSxVQUFVLElBQUksVUFBVSxFQUFFLE9BQU8sZ0JBQWlCLENBQUE7QUFDeEQsVUFBUSxRQUFRLElBQUk7QUFDcEIsVUFBUSxnQkFBZ0IsT0FBTztBQUMvQixTQUFPO0FBQ1Q7QUFFQSxTQUFTLGVBQ1AsU0FDQTtBQUFBLEVBQ0UsU0FBUztBQUFBLEVBQ1Qsa0JBQWtCO0FBQUEsRUFDbEIsbUJBQW1CO0FBQUEsRUFDbkIsV0FBVyxPQUFPO0FBQUEsRUFDbEIsaUJBQWlCLE9BQU87QUFDNUIsSUFBTSxDQUFFLEdBQ047QUFDQSxRQUFNLFdBQVcsU0FBUyxRQUFRO0FBRWxDLE1BQUksZ0JBQWdCO0FBQ2xCLFdBQU87QUFBQSxFQUNSO0FBRUQsUUFBTSxZQUFZLEtBQUssSUFBSSxtQkFBbUIsZUFBZTtBQUU3RCxNQUFJLENBQUMsVUFBVTtBQUViLFdBQU8sWUFBWSxJQUFNO0FBQUEsRUFDMUI7QUFFRCxTQUFPLFdBQVcsWUFBWTtBQUNoQztBQUVBLFNBQVMscUJBQ1AsWUFBWSxDQUFFLEdBQ2QscUJBQXFCLE9BQU8sb0JBQzVCO0FBQ0EsTUFBSSxVQUFVLENBQUE7QUFDZCxNQUFJLFFBQVE7QUFDWixNQUFJLE1BQU07QUFDVixNQUFJLElBQUk7QUFFUixXQUFTLE1BQU0sVUFBVSxRQUFRLElBQUksS0FBSyxLQUFLLEdBQUc7QUFDaEQsUUFBSSxRQUFRLFVBQVU7QUFDdEIsUUFBSSxTQUFTLFVBQVUsSUFBSTtBQUN6QixjQUFRO0FBQUEsSUFDVCxXQUFVLENBQUMsU0FBUyxVQUFVLElBQUk7QUFDakMsWUFBTSxJQUFJO0FBQ1YsVUFBSSxNQUFNLFFBQVEsS0FBSyxvQkFBb0I7QUFDekMsZ0JBQVEsS0FBSyxDQUFDLE9BQU8sR0FBRyxDQUFDO0FBQUEsTUFDMUI7QUFDRCxjQUFRO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFHRCxNQUFJLFVBQVUsSUFBSSxNQUFNLElBQUksU0FBUyxvQkFBb0I7QUFDdkQsWUFBUSxLQUFLLENBQUMsT0FBTyxJQUFJLENBQUMsQ0FBQztBQUFBLEVBQzVCO0FBRUQsU0FBTztBQUNUO0FBR0EsTUFBTSxXQUFXO0FBRWpCLFNBQVMsT0FDUEMsT0FDQSxTQUNBLGlCQUNBO0FBQUEsRUFDRSxXQUFXLE9BQU87QUFBQSxFQUNsQixXQUFXLE9BQU87QUFBQSxFQUNsQixZQUFZLE9BQU87QUFBQSxFQUNuQixpQkFBaUIsT0FBTztBQUFBLEVBQ3hCLHFCQUFxQixPQUFPO0FBQUEsRUFDNUIsaUJBQWlCLE9BQU87QUFBQSxFQUN4QixpQkFBaUIsT0FBTztBQUM1QixJQUFNLENBQUUsR0FDTjtBQUNBLE1BQUksUUFBUSxTQUFTLFVBQVU7QUFDN0IsVUFBTSxJQUFJLE1BQU0seUJBQXlCLFFBQVEsQ0FBQztBQUFBLEVBQ25EO0FBRUQsUUFBTSxhQUFhLFFBQVE7QUFFM0IsUUFBTSxVQUFVQSxNQUFLO0FBRXJCLFFBQU0sbUJBQW1CLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSSxVQUFVLE9BQU8sQ0FBQztBQUVoRSxNQUFJLG1CQUFtQjtBQUV2QixNQUFJLGVBQWU7QUFJbkIsUUFBTSxpQkFBaUIscUJBQXFCLEtBQUs7QUFFakQsUUFBTSxZQUFZLGlCQUFpQixNQUFNLE9BQU8sSUFBSSxDQUFBO0FBRXBELE1BQUk7QUFHSixVQUFRLFFBQVFBLE1BQUssUUFBUSxTQUFTLFlBQVksS0FBSyxJQUFJO0FBQ3pELFFBQUksUUFBUSxlQUFlLFNBQVM7QUFBQSxNQUNsQyxpQkFBaUI7QUFBQSxNQUNqQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDTixDQUFLO0FBRUQsdUJBQW1CLEtBQUssSUFBSSxPQUFPLGdCQUFnQjtBQUNuRCxtQkFBZSxRQUFRO0FBRXZCLFFBQUksZ0JBQWdCO0FBQ2xCLFVBQUksSUFBSTtBQUNSLGFBQU8sSUFBSSxZQUFZO0FBQ3JCLGtCQUFVLFFBQVEsS0FBSztBQUN2QixhQUFLO0FBQUEsTUFDTjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBR0QsaUJBQWU7QUFFZixNQUFJLGFBQWEsQ0FBQTtBQUNqQixNQUFJLGFBQWE7QUFDakIsTUFBSSxTQUFTLGFBQWE7QUFFMUIsUUFBTSxPQUFPLEtBQU0sYUFBYTtBQUVoQyxXQUFTLElBQUksR0FBRyxJQUFJLFlBQVksS0FBSyxHQUFHO0FBSXRDLFFBQUksU0FBUztBQUNiLFFBQUksU0FBUztBQUViLFdBQU8sU0FBUyxRQUFRO0FBQ3RCLFlBQU1DLFNBQVEsZUFBZSxTQUFTO0FBQUEsUUFDcEMsUUFBUTtBQUFBLFFBQ1IsaUJBQWlCLG1CQUFtQjtBQUFBLFFBQ3BDO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNSLENBQU87QUFFRCxVQUFJQSxVQUFTLGtCQUFrQjtBQUM3QixpQkFBUztBQUFBLE1BQ2pCLE9BQWE7QUFDTCxpQkFBUztBQUFBLE1BQ1Y7QUFFRCxlQUFTLEtBQUssT0FBTyxTQUFTLFVBQVUsSUFBSSxNQUFNO0FBQUEsSUFDbkQ7QUFHRCxhQUFTO0FBRVQsUUFBSSxRQUFRLEtBQUssSUFBSSxHQUFHLG1CQUFtQixTQUFTLENBQUM7QUFDckQsUUFBSSxTQUFTLGlCQUNULFVBQ0EsS0FBSyxJQUFJLG1CQUFtQixRQUFRLE9BQU8sSUFBSTtBQUduRCxRQUFJLFNBQVMsTUFBTSxTQUFTLENBQUM7QUFFN0IsV0FBTyxTQUFTLE1BQU0sS0FBSyxLQUFLO0FBRWhDLGFBQVMsSUFBSSxRQUFRLEtBQUssT0FBTyxLQUFLLEdBQUc7QUFDdkMsVUFBSSxrQkFBa0IsSUFBSTtBQUMxQixVQUFJLFlBQVksZ0JBQWdCRCxNQUFLLE9BQU8sZUFBZTtBQUUzRCxVQUFJLGdCQUFnQjtBQUVsQixrQkFBVSxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7QUFBQSxNQUNqQztBQUdELGFBQU8sTUFBTyxPQUFPLElBQUksTUFBTSxJQUFLLEtBQUs7QUFHekMsVUFBSSxHQUFHO0FBQ0wsZUFBTyxPQUNILFdBQVcsSUFBSSxLQUFLLFdBQVcsT0FBTyxJQUFLLElBQUksV0FBVyxJQUFJO0FBQUEsTUFDbkU7QUFFRCxVQUFJLE9BQU8sS0FBSyxNQUFNO0FBQ3BCLHFCQUFhLGVBQWUsU0FBUztBQUFBLFVBQ25DLFFBQVE7QUFBQSxVQUNSO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDVixDQUFTO0FBSUQsWUFBSSxjQUFjLGtCQUFrQjtBQUVsQyw2QkFBbUI7QUFDbkIseUJBQWU7QUFHZixjQUFJLGdCQUFnQixrQkFBa0I7QUFDcEM7QUFBQSxVQUNEO0FBR0Qsa0JBQVEsS0FBSyxJQUFJLEdBQUcsSUFBSSxtQkFBbUIsWUFBWTtBQUFBLFFBQ3hEO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFHRCxVQUFNLFFBQVEsZUFBZSxTQUFTO0FBQUEsTUFDcEMsUUFBUSxJQUFJO0FBQUEsTUFDWixpQkFBaUI7QUFBQSxNQUNqQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDTixDQUFLO0FBRUQsUUFBSSxRQUFRLGtCQUFrQjtBQUM1QjtBQUFBLElBQ0Q7QUFFRCxpQkFBYTtBQUFBLEVBQ2Q7QUFFRCxRQUFNLFNBQVM7QUFBQSxJQUNiLFNBQVMsZ0JBQWdCO0FBQUEsSUFFekIsT0FBTyxLQUFLLElBQUksTUFBTyxVQUFVO0FBQUEsRUFDckM7QUFFRSxNQUFJLGdCQUFnQjtBQUNsQixVQUFNLFVBQVUscUJBQXFCLFdBQVcsa0JBQWtCO0FBQ2xFLFFBQUksQ0FBQyxRQUFRLFFBQVE7QUFDbkIsYUFBTyxVQUFVO0FBQUEsSUFDbEIsV0FBVSxnQkFBZ0I7QUFDekIsYUFBTyxVQUFVO0FBQUEsSUFDbEI7QUFBQSxFQUNGO0FBRUQsU0FBTztBQUNUO0FBRUEsU0FBUyxzQkFBc0IsU0FBUztBQUN0QyxNQUFJLE9BQU8sQ0FBQTtBQUVYLFdBQVMsSUFBSSxHQUFHLE1BQU0sUUFBUSxRQUFRLElBQUksS0FBSyxLQUFLLEdBQUc7QUFDckQsVUFBTSxPQUFPLFFBQVEsT0FBTyxDQUFDO0FBQzdCLFNBQUssU0FBUyxLQUFLLFNBQVMsS0FBTSxLQUFNLE1BQU0sSUFBSTtBQUFBLEVBQ25EO0FBRUQsU0FBTztBQUNUO0FBRUEsTUFBTSxZQUFZO0FBQUEsRUFDaEIsWUFDRSxTQUNBO0FBQUEsSUFDRSxXQUFXLE9BQU87QUFBQSxJQUNsQixZQUFZLE9BQU87QUFBQSxJQUNuQixXQUFXLE9BQU87QUFBQSxJQUNsQixpQkFBaUIsT0FBTztBQUFBLElBQ3hCLGlCQUFpQixPQUFPO0FBQUEsSUFDeEIscUJBQXFCLE9BQU87QUFBQSxJQUM1QixrQkFBa0IsT0FBTztBQUFBLElBQ3pCLGlCQUFpQixPQUFPO0FBQUEsRUFDOUIsSUFBUSxDQUFFLEdBQ047QUFDQSxTQUFLLFVBQVU7QUFBQSxNQUNiO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ047QUFFSSxTQUFLLFVBQVUsa0JBQWtCLFVBQVUsUUFBUSxZQUFXO0FBRTlELFNBQUssU0FBUztBQUVkLFFBQUksQ0FBQyxLQUFLLFFBQVEsUUFBUTtBQUN4QjtBQUFBLElBQ0Q7QUFFRCxVQUFNLFdBQVcsQ0FBQ0UsVUFBUyxlQUFlO0FBQ3hDLFdBQUssT0FBTyxLQUFLO0FBQUEsUUFDZixTQUFBQTtBQUFBLFFBQ0EsVUFBVSxzQkFBc0JBLFFBQU87QUFBQSxRQUN2QztBQUFBLE1BQ1IsQ0FBTztBQUFBLElBQ1A7QUFFSSxVQUFNLE1BQU0sS0FBSyxRQUFRO0FBRXpCLFFBQUksTUFBTSxVQUFVO0FBQ2xCLFVBQUksSUFBSTtBQUNSLFlBQU0sWUFBWSxNQUFNO0FBQ3hCLFlBQU0sTUFBTSxNQUFNO0FBRWxCLGFBQU8sSUFBSSxLQUFLO0FBQ2QsaUJBQVMsS0FBSyxRQUFRLE9BQU8sR0FBRyxRQUFRLEdBQUcsQ0FBQztBQUM1QyxhQUFLO0FBQUEsTUFDTjtBQUVELFVBQUksV0FBVztBQUNiLGNBQU0sYUFBYSxNQUFNO0FBQ3pCLGlCQUFTLEtBQUssUUFBUSxPQUFPLFVBQVUsR0FBRyxVQUFVO0FBQUEsTUFDckQ7QUFBQSxJQUNQLE9BQVc7QUFDTCxlQUFTLEtBQUssU0FBUyxDQUFDO0FBQUEsSUFDekI7QUFBQSxFQUNGO0FBQUEsRUFFRCxTQUFTRixPQUFNO0FBQ2IsVUFBTSxFQUFFLGlCQUFpQixtQkFBbUIsS0FBSztBQUVqRCxRQUFJLENBQUMsaUJBQWlCO0FBQ3BCLE1BQUFBLFFBQU9BLE1BQUs7SUFDYjtBQUdELFFBQUksS0FBSyxZQUFZQSxPQUFNO0FBQ3pCLFVBQUlHLFVBQVM7QUFBQSxRQUNYLFNBQVM7QUFBQSxRQUNULE9BQU87QUFBQSxNQUNmO0FBRU0sVUFBSSxnQkFBZ0I7QUFDbEIsUUFBQUEsUUFBTyxVQUFVLENBQUMsQ0FBQyxHQUFHSCxNQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsTUFDdkM7QUFFRCxhQUFPRztBQUFBLElBQ1I7QUFHRCxVQUFNO0FBQUEsTUFDSjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDTixJQUFRLEtBQUs7QUFFVCxRQUFJLGFBQWEsQ0FBQTtBQUNqQixRQUFJLGFBQWE7QUFDakIsUUFBSSxhQUFhO0FBRWpCLFNBQUssT0FBTyxRQUFRLENBQUMsRUFBRSxTQUFTLFVBQVUsaUJBQWlCO0FBQ3pELFlBQU0sRUFBRSxTQUFTLE9BQU8sUUFBTyxJQUFLLE9BQU9ILE9BQU0sU0FBUyxVQUFVO0FBQUEsUUFDbEUsVUFBVSxXQUFXO0FBQUEsUUFDckI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ1IsQ0FBTztBQUVELFVBQUksU0FBUztBQUNYLHFCQUFhO0FBQUEsTUFDZDtBQUVELG9CQUFjO0FBRWQsVUFBSSxXQUFXLFNBQVM7QUFDdEIscUJBQWEsQ0FBQyxHQUFHLFlBQVksR0FBRyxPQUFPO0FBQUEsTUFDeEM7QUFBQSxJQUNQLENBQUs7QUFFRCxRQUFJLFNBQVM7QUFBQSxNQUNYLFNBQVM7QUFBQSxNQUNULE9BQU8sYUFBYSxhQUFhLEtBQUssT0FBTyxTQUFTO0FBQUEsSUFDNUQ7QUFFSSxRQUFJLGNBQWMsZ0JBQWdCO0FBQ2hDLGFBQU8sVUFBVTtBQUFBLElBQ2xCO0FBRUQsV0FBTztBQUFBLEVBQ1I7QUFDSDtBQUVBLE1BQU0sVUFBVTtBQUFBLEVBQ2QsWUFBWSxTQUFTO0FBQ25CLFNBQUssVUFBVTtBQUFBLEVBQ2hCO0FBQUEsRUFDRCxPQUFPLGFBQWEsU0FBUztBQUMzQixXQUFPLFNBQVMsU0FBUyxLQUFLLFVBQVU7QUFBQSxFQUN6QztBQUFBLEVBQ0QsT0FBTyxjQUFjLFNBQVM7QUFDNUIsV0FBTyxTQUFTLFNBQVMsS0FBSyxXQUFXO0FBQUEsRUFDMUM7QUFBQSxFQUNELFNBQWlCO0FBQUEsRUFBRTtBQUNyQjtBQUVBLFNBQVMsU0FBUyxTQUFTLEtBQUs7QUFDOUIsUUFBTSxVQUFVLFFBQVEsTUFBTSxHQUFHO0FBQ2pDLFNBQU8sVUFBVSxRQUFRLEtBQUs7QUFDaEM7QUFJQSxNQUFNLG1CQUFtQixVQUFVO0FBQUEsRUFDakMsWUFBWSxTQUFTO0FBQ25CLFVBQU0sT0FBTztBQUFBLEVBQ2Q7QUFBQSxFQUNELFdBQVcsT0FBTztBQUNoQixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsV0FBVyxhQUFhO0FBQ3RCLFdBQU87QUFBQSxFQUNSO0FBQUEsRUFDRCxXQUFXLGNBQWM7QUFDdkIsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUNELE9BQU9BLE9BQU07QUFDWCxVQUFNLFVBQVVBLFVBQVMsS0FBSztBQUU5QixXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQ0EsT0FBTyxVQUFVLElBQUk7QUFBQSxNQUNyQixTQUFTLENBQUMsR0FBRyxLQUFLLFFBQVEsU0FBUyxDQUFDO0FBQUEsSUFDckM7QUFBQSxFQUNGO0FBQ0g7QUFJQSxNQUFNLDBCQUEwQixVQUFVO0FBQUEsRUFDeEMsWUFBWSxTQUFTO0FBQ25CLFVBQU0sT0FBTztBQUFBLEVBQ2Q7QUFBQSxFQUNELFdBQVcsT0FBTztBQUNoQixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsV0FBVyxhQUFhO0FBQ3RCLFdBQU87QUFBQSxFQUNSO0FBQUEsRUFDRCxXQUFXLGNBQWM7QUFDdkIsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUNELE9BQU9BLE9BQU07QUFDWCxVQUFNLFFBQVFBLE1BQUssUUFBUSxLQUFLLE9BQU87QUFDdkMsVUFBTSxVQUFVLFVBQVU7QUFFMUIsV0FBTztBQUFBLE1BQ0w7QUFBQSxNQUNBLE9BQU8sVUFBVSxJQUFJO0FBQUEsTUFDckIsU0FBUyxDQUFDLEdBQUdBLE1BQUssU0FBUyxDQUFDO0FBQUEsSUFDN0I7QUFBQSxFQUNGO0FBQ0g7QUFJQSxNQUFNLHlCQUF5QixVQUFVO0FBQUEsRUFDdkMsWUFBWSxTQUFTO0FBQ25CLFVBQU0sT0FBTztBQUFBLEVBQ2Q7QUFBQSxFQUNELFdBQVcsT0FBTztBQUNoQixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsV0FBVyxhQUFhO0FBQ3RCLFdBQU87QUFBQSxFQUNSO0FBQUEsRUFDRCxXQUFXLGNBQWM7QUFDdkIsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUNELE9BQU9BLE9BQU07QUFDWCxVQUFNLFVBQVVBLE1BQUssV0FBVyxLQUFLLE9BQU87QUFFNUMsV0FBTztBQUFBLE1BQ0w7QUFBQSxNQUNBLE9BQU8sVUFBVSxJQUFJO0FBQUEsTUFDckIsU0FBUyxDQUFDLEdBQUcsS0FBSyxRQUFRLFNBQVMsQ0FBQztBQUFBLElBQ3JDO0FBQUEsRUFDRjtBQUNIO0FBSUEsTUFBTSxnQ0FBZ0MsVUFBVTtBQUFBLEVBQzlDLFlBQVksU0FBUztBQUNuQixVQUFNLE9BQU87QUFBQSxFQUNkO0FBQUEsRUFDRCxXQUFXLE9BQU87QUFDaEIsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUNELFdBQVcsYUFBYTtBQUN0QixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsV0FBVyxjQUFjO0FBQ3ZCLFdBQU87QUFBQSxFQUNSO0FBQUEsRUFDRCxPQUFPQSxPQUFNO0FBQ1gsVUFBTSxVQUFVLENBQUNBLE1BQUssV0FBVyxLQUFLLE9BQU87QUFFN0MsV0FBTztBQUFBLE1BQ0w7QUFBQSxNQUNBLE9BQU8sVUFBVSxJQUFJO0FBQUEsTUFDckIsU0FBUyxDQUFDLEdBQUdBLE1BQUssU0FBUyxDQUFDO0FBQUEsSUFDN0I7QUFBQSxFQUNGO0FBQ0g7QUFJQSxNQUFNLHlCQUF5QixVQUFVO0FBQUEsRUFDdkMsWUFBWSxTQUFTO0FBQ25CLFVBQU0sT0FBTztBQUFBLEVBQ2Q7QUFBQSxFQUNELFdBQVcsT0FBTztBQUNoQixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsV0FBVyxhQUFhO0FBQ3RCLFdBQU87QUFBQSxFQUNSO0FBQUEsRUFDRCxXQUFXLGNBQWM7QUFDdkIsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUNELE9BQU9BLE9BQU07QUFDWCxVQUFNLFVBQVVBLE1BQUssU0FBUyxLQUFLLE9BQU87QUFFMUMsV0FBTztBQUFBLE1BQ0w7QUFBQSxNQUNBLE9BQU8sVUFBVSxJQUFJO0FBQUEsTUFDckIsU0FBUyxDQUFDQSxNQUFLLFNBQVMsS0FBSyxRQUFRLFFBQVFBLE1BQUssU0FBUyxDQUFDO0FBQUEsSUFDN0Q7QUFBQSxFQUNGO0FBQ0g7QUFJQSxNQUFNLGdDQUFnQyxVQUFVO0FBQUEsRUFDOUMsWUFBWSxTQUFTO0FBQ25CLFVBQU0sT0FBTztBQUFBLEVBQ2Q7QUFBQSxFQUNELFdBQVcsT0FBTztBQUNoQixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsV0FBVyxhQUFhO0FBQ3RCLFdBQU87QUFBQSxFQUNSO0FBQUEsRUFDRCxXQUFXLGNBQWM7QUFDdkIsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUNELE9BQU9BLE9BQU07QUFDWCxVQUFNLFVBQVUsQ0FBQ0EsTUFBSyxTQUFTLEtBQUssT0FBTztBQUMzQyxXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQ0EsT0FBTyxVQUFVLElBQUk7QUFBQSxNQUNyQixTQUFTLENBQUMsR0FBR0EsTUFBSyxTQUFTLENBQUM7QUFBQSxJQUM3QjtBQUFBLEVBQ0Y7QUFDSDtBQUVBLE1BQU0sbUJBQW1CLFVBQVU7QUFBQSxFQUNqQyxZQUNFLFNBQ0E7QUFBQSxJQUNFLFdBQVcsT0FBTztBQUFBLElBQ2xCLFlBQVksT0FBTztBQUFBLElBQ25CLFdBQVcsT0FBTztBQUFBLElBQ2xCLGlCQUFpQixPQUFPO0FBQUEsSUFDeEIsaUJBQWlCLE9BQU87QUFBQSxJQUN4QixxQkFBcUIsT0FBTztBQUFBLElBQzVCLGtCQUFrQixPQUFPO0FBQUEsSUFDekIsaUJBQWlCLE9BQU87QUFBQSxFQUM5QixJQUFRLENBQUUsR0FDTjtBQUNBLFVBQU0sT0FBTztBQUNiLFNBQUssZUFBZSxJQUFJLFlBQVksU0FBUztBQUFBLE1BQzNDO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ04sQ0FBSztBQUFBLEVBQ0Y7QUFBQSxFQUNELFdBQVcsT0FBTztBQUNoQixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsV0FBVyxhQUFhO0FBQ3RCLFdBQU87QUFBQSxFQUNSO0FBQUEsRUFDRCxXQUFXLGNBQWM7QUFDdkIsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUNELE9BQU9BLE9BQU07QUFDWCxXQUFPLEtBQUssYUFBYSxTQUFTQSxLQUFJO0FBQUEsRUFDdkM7QUFDSDtBQUlBLE1BQU0scUJBQXFCLFVBQVU7QUFBQSxFQUNuQyxZQUFZLFNBQVM7QUFDbkIsVUFBTSxPQUFPO0FBQUEsRUFDZDtBQUFBLEVBQ0QsV0FBVyxPQUFPO0FBQ2hCLFdBQU87QUFBQSxFQUNSO0FBQUEsRUFDRCxXQUFXLGFBQWE7QUFDdEIsV0FBTztBQUFBLEVBQ1I7QUFBQSxFQUNELFdBQVcsY0FBYztBQUN2QixXQUFPO0FBQUEsRUFDUjtBQUFBLEVBQ0QsT0FBT0EsT0FBTTtBQUNYLFFBQUksV0FBVztBQUNmLFFBQUk7QUFFSixVQUFNLFVBQVUsQ0FBQTtBQUNoQixVQUFNLGFBQWEsS0FBSyxRQUFRO0FBR2hDLFlBQVEsUUFBUUEsTUFBSyxRQUFRLEtBQUssU0FBUyxRQUFRLEtBQUssSUFBSTtBQUMxRCxpQkFBVyxRQUFRO0FBQ25CLGNBQVEsS0FBSyxDQUFDLE9BQU8sV0FBVyxDQUFDLENBQUM7QUFBQSxJQUNuQztBQUVELFVBQU0sVUFBVSxDQUFDLENBQUMsUUFBUTtBQUUxQixXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQ0EsT0FBTyxVQUFVLElBQUk7QUFBQSxNQUNyQjtBQUFBLElBQ0Q7QUFBQSxFQUNGO0FBQ0g7QUFHQSxNQUFNLFlBQVk7QUFBQSxFQUNoQjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDRjtBQUVBLE1BQU0sZUFBZSxVQUFVO0FBRy9CLE1BQU0sV0FBVztBQUNqQixNQUFNLFdBQVc7QUFLakIsU0FBUyxXQUFXLFNBQVMsVUFBVSxJQUFJO0FBQ3pDLFNBQU8sUUFBUSxNQUFNLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUztBQUMzQyxRQUFJLFFBQVEsS0FDVCxLQUFNLEVBQ04sTUFBTSxRQUFRLEVBQ2QsT0FBTyxDQUFDSSxVQUFTQSxTQUFRLENBQUMsQ0FBQ0EsTUFBSyxLQUFJLENBQUU7QUFFekMsUUFBSSxVQUFVLENBQUE7QUFDZCxhQUFTLElBQUksR0FBRyxNQUFNLE1BQU0sUUFBUSxJQUFJLEtBQUssS0FBSyxHQUFHO0FBQ25ELFlBQU0sWUFBWSxNQUFNO0FBR3hCLFVBQUksUUFBUTtBQUNaLFVBQUksTUFBTTtBQUNWLGFBQU8sQ0FBQyxTQUFTLEVBQUUsTUFBTSxjQUFjO0FBQ3JDLGNBQU0sV0FBVyxVQUFVO0FBQzNCLFlBQUksUUFBUSxTQUFTLGFBQWEsU0FBUztBQUMzQyxZQUFJLE9BQU87QUFDVCxrQkFBUSxLQUFLLElBQUksU0FBUyxPQUFPLE9BQU8sQ0FBQztBQUN6QyxrQkFBUTtBQUFBLFFBQ1Q7QUFBQSxNQUNGO0FBRUQsVUFBSSxPQUFPO0FBQ1Q7QUFBQSxNQUNEO0FBR0QsWUFBTTtBQUNOLGFBQU8sRUFBRSxNQUFNLGNBQWM7QUFDM0IsY0FBTSxXQUFXLFVBQVU7QUFDM0IsWUFBSSxRQUFRLFNBQVMsY0FBYyxTQUFTO0FBQzVDLFlBQUksT0FBTztBQUNULGtCQUFRLEtBQUssSUFBSSxTQUFTLE9BQU8sT0FBTyxDQUFDO0FBQ3pDO0FBQUEsUUFDRDtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUQsV0FBTztBQUFBLEVBQ1gsQ0FBRztBQUNIO0FBSUEsTUFBTSxnQkFBZ0Isb0JBQUksSUFBSSxDQUFDLFdBQVcsTUFBTSxhQUFhLElBQUksQ0FBQztBQThCbEUsTUFBTSxlQUFlO0FBQUEsRUFDbkIsWUFDRSxTQUNBO0FBQUEsSUFDRSxrQkFBa0IsT0FBTztBQUFBLElBQ3pCLGlCQUFpQixPQUFPO0FBQUEsSUFDeEIscUJBQXFCLE9BQU87QUFBQSxJQUM1QixpQkFBaUIsT0FBTztBQUFBLElBQ3hCLGlCQUFpQixPQUFPO0FBQUEsSUFDeEIsV0FBVyxPQUFPO0FBQUEsSUFDbEIsWUFBWSxPQUFPO0FBQUEsSUFDbkIsV0FBVyxPQUFPO0FBQUEsRUFDeEIsSUFBUSxDQUFFLEdBQ047QUFDQSxTQUFLLFFBQVE7QUFDYixTQUFLLFVBQVU7QUFBQSxNQUNiO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ047QUFFSSxTQUFLLFVBQVUsa0JBQWtCLFVBQVUsUUFBUSxZQUFXO0FBQzlELFNBQUssUUFBUSxXQUFXLEtBQUssU0FBUyxLQUFLLE9BQU87QUFBQSxFQUNuRDtBQUFBLEVBRUQsT0FBTyxVQUFVLEdBQUcsU0FBUztBQUMzQixXQUFPLFFBQVE7QUFBQSxFQUNoQjtBQUFBLEVBRUQsU0FBU0osT0FBTTtBQUNiLFVBQU0sUUFBUSxLQUFLO0FBRW5CLFFBQUksQ0FBQyxPQUFPO0FBQ1YsYUFBTztBQUFBLFFBQ0wsU0FBUztBQUFBLFFBQ1QsT0FBTztBQUFBLE1BQ1I7QUFBQSxJQUNGO0FBRUQsVUFBTSxFQUFFLGdCQUFnQixvQkFBb0IsS0FBSztBQUVqRCxJQUFBQSxRQUFPLGtCQUFrQkEsUUFBT0EsTUFBSyxZQUFXO0FBRWhELFFBQUksYUFBYTtBQUNqQixRQUFJLGFBQWEsQ0FBQTtBQUNqQixRQUFJLGFBQWE7QUFHakIsYUFBUyxJQUFJLEdBQUcsT0FBTyxNQUFNLFFBQVEsSUFBSSxNQUFNLEtBQUssR0FBRztBQUNyRCxZQUFNSyxhQUFZLE1BQU07QUFHeEIsaUJBQVcsU0FBUztBQUNwQixtQkFBYTtBQUdiLGVBQVMsSUFBSSxHQUFHLE9BQU9BLFdBQVUsUUFBUSxJQUFJLE1BQU0sS0FBSyxHQUFHO0FBQ3pELGNBQU0sV0FBV0EsV0FBVTtBQUMzQixjQUFNLEVBQUUsU0FBUyxTQUFTLE1BQU8sSUFBRyxTQUFTLE9BQU9MLEtBQUk7QUFFeEQsWUFBSSxTQUFTO0FBQ1gsd0JBQWM7QUFDZCx3QkFBYztBQUNkLGNBQUksZ0JBQWdCO0FBQ2xCLGtCQUFNLE9BQU8sU0FBUyxZQUFZO0FBQ2xDLGdCQUFJLGNBQWMsSUFBSSxJQUFJLEdBQUc7QUFDM0IsMkJBQWEsQ0FBQyxHQUFHLFlBQVksR0FBRyxPQUFPO0FBQUEsWUFDckQsT0FBbUI7QUFDTCx5QkFBVyxLQUFLLE9BQU87QUFBQSxZQUN4QjtBQUFBLFVBQ0Y7QUFBQSxRQUNYLE9BQWU7QUFDTCx1QkFBYTtBQUNiLHVCQUFhO0FBQ2IscUJBQVcsU0FBUztBQUNwQjtBQUFBLFFBQ0Q7QUFBQSxNQUNGO0FBR0QsVUFBSSxZQUFZO0FBQ2QsWUFBSSxTQUFTO0FBQUEsVUFDWCxTQUFTO0FBQUEsVUFDVCxPQUFPLGFBQWE7QUFBQSxRQUM5QjtBQUVRLFlBQUksZ0JBQWdCO0FBQ2xCLGlCQUFPLFVBQVU7QUFBQSxRQUNsQjtBQUVELGVBQU87QUFBQSxNQUNSO0FBQUEsSUFDRjtBQUdELFdBQU87QUFBQSxNQUNMLFNBQVM7QUFBQSxNQUNULE9BQU87QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUNIO0FBRUEsTUFBTSxzQkFBc0IsQ0FBQTtBQUU1QixTQUFTLFlBQVksTUFBTTtBQUN6QixzQkFBb0IsS0FBSyxHQUFHLElBQUk7QUFDbEM7QUFFQSxTQUFTLGVBQWUsU0FBUyxTQUFTO0FBQ3hDLFdBQVMsSUFBSSxHQUFHLE1BQU0sb0JBQW9CLFFBQVEsSUFBSSxLQUFLLEtBQUssR0FBRztBQUNqRSxRQUFJLGdCQUFnQixvQkFBb0I7QUFDeEMsUUFBSSxjQUFjLFVBQVUsU0FBUyxPQUFPLEdBQUc7QUFDN0MsYUFBTyxJQUFJLGNBQWMsU0FBUyxPQUFPO0FBQUEsSUFDMUM7QUFBQSxFQUNGO0FBRUQsU0FBTyxJQUFJLFlBQVksU0FBUyxPQUFPO0FBQ3pDO0FBRUEsTUFBTSxrQkFBa0I7QUFBQSxFQUN0QixLQUFLO0FBQUEsRUFDTCxJQUFJO0FBQ047QUFFQSxNQUFNLFVBQVU7QUFBQSxFQUNkLE1BQU07QUFBQSxFQUNOLFNBQVM7QUFDWDtBQUVBLE1BQU0sZUFBZSxDQUFDLFVBQ3BCLENBQUMsRUFBRSxNQUFNLGdCQUFnQixRQUFRLE1BQU0sZ0JBQWdCO0FBRXpELE1BQU0sU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE1BQU0sUUFBUTtBQUUxQyxNQUFNLFNBQVMsQ0FBQyxVQUNkLENBQUMsUUFBUSxLQUFLLEtBQUssU0FBUyxLQUFLLEtBQUssQ0FBQyxhQUFhLEtBQUs7QUFFM0QsTUFBTSxvQkFBb0IsQ0FBQyxXQUFXO0FBQUEsRUFDcEMsQ0FBQyxnQkFBZ0IsTUFBTSxPQUFPLEtBQUssS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTO0FBQUEsSUFDdEQsQ0FBQyxNQUFNLE1BQU07QUFBQSxFQUNqQixFQUFJO0FBQ0o7QUFJQSxTQUFTLE1BQU0sT0FBTyxTQUFTLEVBQUUsT0FBTyxLQUFNLElBQUcsSUFBSTtBQUNuRCxRQUFNLE9BQU8sQ0FBQ00sV0FBVTtBQUN0QixRQUFJLE9BQU8sT0FBTyxLQUFLQSxNQUFLO0FBRTVCLFVBQU0sY0FBYyxPQUFPQSxNQUFLO0FBRWhDLFFBQUksQ0FBQyxlQUFlLEtBQUssU0FBUyxLQUFLLENBQUMsYUFBYUEsTUFBSyxHQUFHO0FBQzNELGFBQU8sS0FBSyxrQkFBa0JBLE1BQUssQ0FBQztBQUFBLElBQ3JDO0FBRUQsUUFBSSxPQUFPQSxNQUFLLEdBQUc7QUFDakIsWUFBTSxNQUFNLGNBQWNBLE9BQU0sUUFBUSxRQUFRLEtBQUs7QUFFckQsWUFBTSxVQUFVLGNBQWNBLE9BQU0sUUFBUSxXQUFXQSxPQUFNO0FBRTdELFVBQUksQ0FBQyxTQUFTLE9BQU8sR0FBRztBQUN0QixjQUFNLElBQUksTUFBTSxxQ0FBcUMsR0FBRyxDQUFDO0FBQUEsTUFDMUQ7QUFFRCxZQUFNLE1BQU07QUFBQSxRQUNWLE9BQU8sWUFBWSxHQUFHO0FBQUEsUUFDdEI7QUFBQSxNQUNSO0FBRU0sVUFBSSxNQUFNO0FBQ1IsWUFBSSxXQUFXLGVBQWUsU0FBUyxPQUFPO0FBQUEsTUFDL0M7QUFFRCxhQUFPO0FBQUEsSUFDUjtBQUVELFFBQUksT0FBTztBQUFBLE1BQ1QsVUFBVSxDQUFFO0FBQUEsTUFDWixVQUFVLEtBQUs7QUFBQSxJQUNyQjtBQUVJLFNBQUssUUFBUSxDQUFDLFFBQVE7QUFDcEIsWUFBTSxRQUFRQSxPQUFNO0FBRXBCLFVBQUksUUFBUSxLQUFLLEdBQUc7QUFDbEIsY0FBTSxRQUFRLENBQUMsU0FBUztBQUN0QixlQUFLLFNBQVMsS0FBSyxLQUFLLElBQUksQ0FBQztBQUFBLFFBQ3ZDLENBQVM7QUFBQSxNQUNGO0FBQUEsSUFDUCxDQUFLO0FBRUQsV0FBTztBQUFBLEVBQ1g7QUFFRSxNQUFJLENBQUMsYUFBYSxLQUFLLEdBQUc7QUFDeEIsWUFBUSxrQkFBa0IsS0FBSztBQUFBLEVBQ2hDO0FBRUQsU0FBTyxLQUFLLEtBQUs7QUFDbkI7QUFHQSxTQUFTLGFBQ1AsU0FDQSxFQUFFLGtCQUFrQixPQUFPLGdCQUFpQixHQUM1QztBQUNBLFVBQVEsUUFBUSxDQUFDLFdBQVc7QUFDMUIsUUFBSSxhQUFhO0FBRWpCLFdBQU8sUUFBUSxRQUFRLENBQUMsRUFBRSxLQUFLLE1BQUFSLE9BQU0sWUFBWTtBQUMvQyxZQUFNLFNBQVMsTUFBTSxJQUFJLFNBQVM7QUFFbEMsb0JBQWMsS0FBSztBQUFBLFFBQ2pCLFVBQVUsS0FBSyxTQUFTLE9BQU8sVUFBVTtBQUFBLFNBQ3hDLFVBQVUsTUFBTSxrQkFBa0IsSUFBSUE7QUFBQSxNQUMvQztBQUFBLElBQ0EsQ0FBSztBQUVELFdBQU8sUUFBUTtBQUFBLEVBQ25CLENBQUc7QUFDSDtBQUVBLFNBQVMsaUJBQWlCLFFBQVEsTUFBTTtBQUN0QyxRQUFNLFVBQVUsT0FBTztBQUN2QixPQUFLLFVBQVU7QUFFZixNQUFJLENBQUMsVUFBVSxPQUFPLEdBQUc7QUFDdkI7QUFBQSxFQUNEO0FBRUQsVUFBUSxRQUFRLENBQUMsVUFBVTtBQUN6QixRQUFJLENBQUMsVUFBVSxNQUFNLE9BQU8sS0FBSyxDQUFDLE1BQU0sUUFBUSxRQUFRO0FBQ3REO0FBQUEsSUFDRDtBQUVELFVBQU0sRUFBRSxTQUFTLE1BQU8sSUFBRztBQUUzQixRQUFJLE1BQU07QUFBQSxNQUNSO0FBQUEsTUFDQTtBQUFBLElBQ047QUFFSSxRQUFJLE1BQU0sS0FBSztBQUNiLFVBQUksTUFBTSxNQUFNLElBQUk7QUFBQSxJQUNyQjtBQUVELFFBQUksTUFBTSxNQUFNLElBQUk7QUFDbEIsVUFBSSxXQUFXLE1BQU07QUFBQSxJQUN0QjtBQUVELFNBQUssUUFBUSxLQUFLLEdBQUc7QUFBQSxFQUN6QixDQUFHO0FBQ0g7QUFFQSxTQUFTLGVBQWUsUUFBUSxNQUFNO0FBQ3BDLE9BQUssUUFBUSxPQUFPO0FBQ3RCO0FBRUEsU0FBUyxPQUNQLFNBQ0EsTUFDQTtBQUFBLEVBQ0UsaUJBQWlCLE9BQU87QUFBQSxFQUN4QixlQUFlLE9BQU87QUFDMUIsSUFBTSxDQUFFLEdBQ047QUFDQSxRQUFNLGVBQWUsQ0FBQTtBQUVyQixNQUFJO0FBQWdCLGlCQUFhLEtBQUssZ0JBQWdCO0FBQ3RELE1BQUk7QUFBYyxpQkFBYSxLQUFLLGNBQWM7QUFFbEQsU0FBTyxRQUFRLElBQUksQ0FBQyxXQUFXO0FBQzdCLFVBQU0sRUFBRSxJQUFLLElBQUc7QUFFaEIsVUFBTSxPQUFPO0FBQUEsTUFDWCxNQUFNLEtBQUs7QUFBQSxNQUNYLFVBQVU7QUFBQSxJQUNoQjtBQUVJLFFBQUksYUFBYSxRQUFRO0FBQ3ZCLG1CQUFhLFFBQVEsQ0FBQyxnQkFBZ0I7QUFDcEMsb0JBQVksUUFBUSxJQUFJO0FBQUEsTUFDaEMsQ0FBTztBQUFBLElBQ0Y7QUFFRCxXQUFPO0FBQUEsRUFDWCxDQUFHO0FBQ0g7QUFFQSxNQUFNLEtBQUs7QUFBQSxFQUNULFlBQVksTUFBTSxVQUFVLENBQUEsR0FBSSxPQUFPO0FBQ3JDLFNBQUssVUFBVSxFQUFFLEdBQUcsUUFBUSxHQUFHLFFBQU87QUFFdEMsUUFDRSxLQUFLLFFBQVEscUJBQ2IsT0FDQTtBQUNBLFlBQU0sSUFBSSxNQUFNLDJCQUEyQjtBQUFBLElBQzVDO0FBRUQsU0FBSyxZQUFZLElBQUksU0FBUyxLQUFLLFFBQVEsSUFBSTtBQUUvQyxTQUFLLGNBQWMsTUFBTSxLQUFLO0FBQUEsRUFDL0I7QUFBQSxFQUVELGNBQWMsTUFBTSxPQUFPO0FBQ3pCLFNBQUssUUFBUTtBQUViLFFBQUksU0FBUyxFQUFFLGlCQUFpQixZQUFZO0FBQzFDLFlBQU0sSUFBSSxNQUFNLG9CQUFvQjtBQUFBLElBQ3JDO0FBRUQsU0FBSyxXQUNILFNBQ0EsWUFBWSxLQUFLLFFBQVEsTUFBTSxLQUFLLE9BQU87QUFBQSxNQUN6QyxPQUFPLEtBQUssUUFBUTtBQUFBLE1BQ3BCLGlCQUFpQixLQUFLLFFBQVE7QUFBQSxJQUN0QyxDQUFPO0FBQUEsRUFDSjtBQUFBLEVBRUQsSUFBSSxLQUFLO0FBQ1AsUUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHO0FBQ25CO0FBQUEsSUFDRDtBQUVELFNBQUssTUFBTSxLQUFLLEdBQUc7QUFDbkIsU0FBSyxTQUFTLElBQUksR0FBRztBQUFBLEVBQ3RCO0FBQUEsRUFFRCxPQUFPLFlBQVksTUFBb0IsT0FBTztBQUM1QyxVQUFNLFVBQVUsQ0FBQTtBQUVoQixhQUFTLElBQUksR0FBRyxNQUFNLEtBQUssTUFBTSxRQUFRLElBQUksS0FBSyxLQUFLLEdBQUc7QUFDeEQsWUFBTSxNQUFNLEtBQUssTUFBTTtBQUN2QixVQUFJLFVBQVUsS0FBSyxDQUFDLEdBQUc7QUFDckIsYUFBSyxTQUFTLENBQUM7QUFDZixhQUFLO0FBQ0wsZUFBTztBQUVQLGdCQUFRLEtBQUssR0FBRztBQUFBLE1BQ2pCO0FBQUEsSUFDRjtBQUVELFdBQU87QUFBQSxFQUNSO0FBQUEsRUFFRCxTQUFTLEtBQUs7QUFDWixTQUFLLE1BQU0sT0FBTyxLQUFLLENBQUM7QUFDeEIsU0FBSyxTQUFTLFNBQVMsR0FBRztBQUFBLEVBQzNCO0FBQUEsRUFFRCxXQUFXO0FBQ1QsV0FBTyxLQUFLO0FBQUEsRUFDYjtBQUFBLEVBRUQsT0FBTyxPQUFPLEVBQUUsUUFBUSxHQUFFLElBQUssQ0FBQSxHQUFJO0FBQ2pDLFVBQU07QUFBQSxNQUNKO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ04sSUFBUSxLQUFLO0FBRVQsUUFBSSxVQUFVLFNBQVMsS0FBSyxJQUN4QixTQUFTLEtBQUssTUFBTSxFQUFFLElBQ3BCLEtBQUssa0JBQWtCLEtBQUssSUFDNUIsS0FBSyxrQkFBa0IsS0FBSyxJQUM5QixLQUFLLGVBQWUsS0FBSztBQUU3QixpQkFBYSxTQUFTLEVBQUUsZ0JBQWUsQ0FBRTtBQUV6QyxRQUFJLFlBQVk7QUFDZCxjQUFRLEtBQUssTUFBTTtBQUFBLElBQ3BCO0FBRUQsUUFBSSxTQUFTLEtBQUssS0FBSyxRQUFRLElBQUk7QUFDakMsZ0JBQVUsUUFBUSxNQUFNLEdBQUcsS0FBSztBQUFBLElBQ2pDO0FBRUQsV0FBTyxPQUFPLFNBQVMsS0FBSyxPQUFPO0FBQUEsTUFDakM7QUFBQSxNQUNBO0FBQUEsSUFDTixDQUFLO0FBQUEsRUFDRjtBQUFBLEVBRUQsa0JBQWtCLE9BQU87QUFDdkIsVUFBTSxXQUFXLGVBQWUsT0FBTyxLQUFLLE9BQU87QUFDbkQsVUFBTSxFQUFFLFFBQU8sSUFBSyxLQUFLO0FBQ3pCLFVBQU0sVUFBVSxDQUFBO0FBR2hCLFlBQVEsUUFBUSxDQUFDLEVBQUUsR0FBR0UsT0FBTSxHQUFHLEtBQUssR0FBR0YsWUFBVztBQUNoRCxVQUFJLENBQUMsVUFBVUUsS0FBSSxHQUFHO0FBQ3BCO0FBQUEsTUFDRDtBQUVELFlBQU0sRUFBRSxTQUFTLE9BQU8sUUFBUyxJQUFHLFNBQVMsU0FBU0EsS0FBSTtBQUUxRCxVQUFJLFNBQVM7QUFDWCxnQkFBUSxLQUFLO0FBQUEsVUFDWCxNQUFNQTtBQUFBLFVBQ047QUFBQSxVQUNBLFNBQVMsQ0FBQyxFQUFFLE9BQU8sT0FBT0EsT0FBTSxNQUFBRixPQUFNLFNBQVM7QUFBQSxRQUN6RCxDQUFTO0FBQUEsTUFDRjtBQUFBLElBQ1AsQ0FBSztBQUVELFdBQU87QUFBQSxFQUNSO0FBQUEsRUFFRCxlQUFlLE9BQU87QUFFcEIsVUFBTSxhQUFhLE1BQU0sT0FBTyxLQUFLLE9BQU87QUFFNUMsVUFBTSxXQUFXLENBQUMsTUFBTSxNQUFNLFFBQVE7QUFDcEMsVUFBSSxDQUFDLEtBQUssVUFBVTtBQUNsQixjQUFNLEVBQUUsT0FBTyxTQUFVLElBQUc7QUFFNUIsY0FBTSxVQUFVLEtBQUssYUFBYTtBQUFBLFVBQ2hDLEtBQUssS0FBSyxVQUFVLElBQUksS0FBSztBQUFBLFVBQzdCLE9BQU8sS0FBSyxTQUFTLHVCQUF1QixNQUFNLEtBQUs7QUFBQSxVQUN2RDtBQUFBLFFBQ1YsQ0FBUztBQUVELFlBQUksV0FBVyxRQUFRLFFBQVE7QUFDN0IsaUJBQU87QUFBQSxZQUNMO0FBQUEsY0FDRTtBQUFBLGNBQ0E7QUFBQSxjQUNBO0FBQUEsWUFDRDtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBRUQsZUFBTyxDQUFFO0FBQUEsTUFDVjtBQUVELFlBQU0sTUFBTSxDQUFBO0FBQ1osZUFBUyxJQUFJLEdBQUcsTUFBTSxLQUFLLFNBQVMsUUFBUSxJQUFJLEtBQUssS0FBSyxHQUFHO0FBQzNELGNBQU0sUUFBUSxLQUFLLFNBQVM7QUFDNUIsY0FBTSxTQUFTLFNBQVMsT0FBTyxNQUFNLEdBQUc7QUFDeEMsWUFBSSxPQUFPLFFBQVE7QUFDakIsY0FBSSxLQUFLLEdBQUcsTUFBTTtBQUFBLFFBQ25CLFdBQVUsS0FBSyxhQUFhLGdCQUFnQixLQUFLO0FBQ2hELGlCQUFPLENBQUU7QUFBQSxRQUNWO0FBQUEsTUFDRjtBQUNELGFBQU87QUFBQSxJQUNiO0FBRUksVUFBTSxVQUFVLEtBQUssU0FBUztBQUM5QixVQUFNLFlBQVksQ0FBQTtBQUNsQixVQUFNLFVBQVUsQ0FBQTtBQUVoQixZQUFRLFFBQVEsQ0FBQyxFQUFFLEdBQUcsTUFBTSxHQUFHLFVBQVU7QUFDdkMsVUFBSSxVQUFVLElBQUksR0FBRztBQUNuQixZQUFJLGFBQWEsU0FBUyxZQUFZLE1BQU0sR0FBRztBQUUvQyxZQUFJLFdBQVcsUUFBUTtBQUVyQixjQUFJLENBQUMsVUFBVSxNQUFNO0FBQ25CLHNCQUFVLE9BQU8sRUFBRSxLQUFLLE1BQU0sU0FBUyxDQUFBO0FBQ3ZDLG9CQUFRLEtBQUssVUFBVSxJQUFJO0FBQUEsVUFDNUI7QUFDRCxxQkFBVyxRQUFRLENBQUMsRUFBRSxjQUFjO0FBQ2xDLHNCQUFVLEtBQUssUUFBUSxLQUFLLEdBQUcsT0FBTztBQUFBLFVBQ2xELENBQVc7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ1AsQ0FBSztBQUVELFdBQU87QUFBQSxFQUNSO0FBQUEsRUFFRCxrQkFBa0IsT0FBTztBQUN2QixVQUFNLFdBQVcsZUFBZSxPQUFPLEtBQUssT0FBTztBQUNuRCxVQUFNLEVBQUUsTUFBTSxZQUFZLEtBQUs7QUFDL0IsVUFBTSxVQUFVLENBQUE7QUFHaEIsWUFBUSxRQUFRLENBQUMsRUFBRSxHQUFHLE1BQU0sR0FBRyxVQUFVO0FBQ3ZDLFVBQUksQ0FBQyxVQUFVLElBQUksR0FBRztBQUNwQjtBQUFBLE1BQ0Q7QUFFRCxVQUFJLFVBQVUsQ0FBQTtBQUdkLFdBQUssUUFBUSxDQUFDLEtBQUssYUFBYTtBQUM5QixnQkFBUTtBQUFBLFVBQ04sR0FBRyxLQUFLLGFBQWE7QUFBQSxZQUNuQjtBQUFBLFlBQ0EsT0FBTyxLQUFLO0FBQUEsWUFDWjtBQUFBLFVBQ1osQ0FBVztBQUFBLFFBQ1g7QUFBQSxNQUNBLENBQU87QUFFRCxVQUFJLFFBQVEsUUFBUTtBQUNsQixnQkFBUSxLQUFLO0FBQUEsVUFDWDtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDVixDQUFTO0FBQUEsTUFDRjtBQUFBLElBQ1AsQ0FBSztBQUVELFdBQU87QUFBQSxFQUNSO0FBQUEsRUFDRCxhQUFhLEVBQUUsS0FBSyxPQUFPLFNBQVEsR0FBSTtBQUNyQyxRQUFJLENBQUMsVUFBVSxLQUFLLEdBQUc7QUFDckIsYUFBTyxDQUFFO0FBQUEsSUFDVjtBQUVELFFBQUksVUFBVSxDQUFBO0FBRWQsUUFBSSxRQUFRLEtBQUssR0FBRztBQUNsQixZQUFNLFFBQVEsQ0FBQyxFQUFFLEdBQUdFLE9BQU0sR0FBRyxLQUFLLEdBQUdGLFlBQVc7QUFDOUMsWUFBSSxDQUFDLFVBQVVFLEtBQUksR0FBRztBQUNwQjtBQUFBLFFBQ0Q7QUFFRCxjQUFNLEVBQUUsU0FBUyxPQUFPLFFBQVMsSUFBRyxTQUFTLFNBQVNBLEtBQUk7QUFFMUQsWUFBSSxTQUFTO0FBQ1gsa0JBQVEsS0FBSztBQUFBLFlBQ1g7QUFBQSxZQUNBO0FBQUEsWUFDQSxPQUFPQTtBQUFBLFlBQ1A7QUFBQSxZQUNBLE1BQUFGO0FBQUEsWUFDQTtBQUFBLFVBQ1osQ0FBVztBQUFBLFFBQ0Y7QUFBQSxNQUNULENBQU87QUFBQSxJQUNQLE9BQVc7QUFDTCxZQUFNLEVBQUUsR0FBR0UsT0FBTSxHQUFHRixNQUFJLElBQUs7QUFFN0IsWUFBTSxFQUFFLFNBQVMsT0FBTyxRQUFTLElBQUcsU0FBUyxTQUFTRSxLQUFJO0FBRTFELFVBQUksU0FBUztBQUNYLGdCQUFRLEtBQUssRUFBRSxPQUFPLEtBQUssT0FBT0EsT0FBTSxNQUFBRixPQUFNLFFBQU8sQ0FBRTtBQUFBLE1BQ3hEO0FBQUEsSUFDRjtBQUVELFdBQU87QUFBQSxFQUNSO0FBQ0g7QUFFQSxLQUFLLFVBQVU7QUFDZixLQUFLLGNBQWM7QUFDbkIsS0FBSyxhQUFhO0FBQ2xCLEtBQUssU0FBUztBQUVkO0FBQ0UsT0FBSyxhQUFhO0FBQ3BCO0FBRUE7QUFDRSxXQUFTLGNBQWM7QUFDekI7Ozs7Ozs7Ozs7K0NDajdDdUIsSUFBUSxHQUFBLEVBQUEsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFYUixJQUFnQixNQUFBLENBQUE7QUFBQTs7Ozs7OzttQkFVNUIsSUFBUzs7aUNBQWQsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFQUixhQUdHLFFBQUFyQixJQUFBLE1BQUE7O0FBRUgsYUFNSyxRQUFBLEtBQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozs7MEJBZGdCUixLQUFnQixNQUFBLEVBQUE7QUFBQTs7O3FCQVU1QkEsS0FBUzs7bUNBQWQsUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7NEJBQUosUUFBSSxJQUFBLFlBQUEsUUFBQSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7cUNBQUosUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5Q0FiK0IsSUFBVSxFQUFBO0FBQUE7O0FBQW5ELGFBbUJLLFFBQUEsS0FBQSxNQUFBOzs7Ozs7Ozs7OzsyQ0FuQm9DQSxLQUFVLEVBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWpUdEM7QUFBQSxVQUFBc0MsWUFBUztBQUNwQixFQUFBQSxXQUFBLGFBQUE7QUFHQSxFQUFBQSxXQUFBLFlBQUE7QUFHQSxFQUFBQSxXQUFBLFdBQUE7QUFHQSxFQUFBQSxXQUFBLGFBQUE7QUFHQSxFQUFBQSxXQUFBLGFBQUE7QUFHQSxFQUFBQSxXQUFBLGFBQUE7QUFHQSxFQUFBQSxXQUFBLGNBQUE7QUFHQSxFQUFBQSxXQUFBLFdBQUE7QUFHQSxFQUFBQSxXQUFBLGFBQUE7QUFHQSxFQUFBQSxXQUFBLFNBQUE7QUFHQSxFQUFBQSxXQUFBLFVBQUE7QUFFQSxFQUFBQSxXQUFBLFNBQUE7QUFDQSxFQUFBQSxXQUFBLFVBQUE7QUFFQSxFQUFBQSxXQUFBLFVBQUE7QUFDQSxFQUFBQSxXQUFBLGFBQUE7QUFDQSxFQUFBQSxXQUFBLFNBQUE7QUFDQSxFQUFBQSxXQUFBLFdBQUE7QUF2Q1csR0FBQSxjQUFBLFlBQVMsQ0FBQSxFQUFBOzs7Ozs7TUF1RmpCO1FBQ0UsWUFBUyxDQUFBO01BSVgsVUFBTyxDQUFBO0FBRUwsUUFBQSxTQUFTLFNBQXVCLFdBQXlCLElBQUE7QUFBQSxJQUFLO0FBQUE7TUFDbkUsY0FBYztBQUFBLE1BQ2QsZ0JBQWdCO0FBQUEsTUFDaEIsTUFBSSxDQUNILFNBQ0csR0FBQSxPQUFPLElBQUksT0FBQyxXQUFlLEdBQUMsQ0FBQTtBQUFBOzs7VUFPMUIsWUFBUyxNQUFTLE9BQU87QUFFL0IsY0FBTztBQUFBLGFBRUM7QUFBQSxRQUFNLFVBQVUsUUFBTyxFQUFHLElBQU0sQ0FBQSxDQUFBLFNBQVMsT0FBTyxPQUFBO0FBQUEsVUFDdEQsT0FBTyxVQUFVO0FBQUEsVUFDakIsTUFBTSxRQUFRO0FBQUEsVUFDZCxjQUFjO0FBQUEsVUFDZCxVQUFVO0FBQUEsVUFDVixTQUFPLEVBQ04sTUFBTSxRQUFRLE1BQ2QsSUFBSSxRQUFRLEdBQUU7QUFBQTtTQUVWLElBQUk7QUFBQTthQUdIO0FBQUEsUUFBTSxVQUFVLFFBQU8sRUFBRyxRQUFPLENBQUEsQ0FBRyxTQUFTLE9BQU8sTUFBTSxPQUFPLFFBQVEsT0FBUSxDQUFBLFNBQVMsWUFBTTtBQUFBLFVBQ3RHLE9BQU8sVUFBVTtBQUFBLFVBQ2pCLE1BQU0sT0FBTyxPQUFPLE9BQU8sZ0JBQWdCLFNBQVM7QUFBQSxVQUNwRCxVQUFVO0FBQUEsVUFDVixjQUFZLEdBQUssZ0JBQWdCO0FBQUEsVUFDakMsVUFBUTtBQUFBLFlBQ1AsTUFBTSxPQUFPLE9BQU8sT0FBTyxnQkFBZ0IsU0FBUztBQUFBLFlBQ3BELEtBQUssUUFBUTtBQUFBLGVBQ1Y7QUFBQTtVQUVKLFNBQU87QUFBQSxZQUNOLFFBQVE7QUFBQSxZQUNSLE9BQU8sT0FBTztBQUFBLFlBQ2QsV0FBVyxPQUFPLE9BQU8sZ0JBQWdCO0FBQUE7O1FBRXBDLENBQUEsVUFBVSxPQUFPO0FBQUE7TUFFZixHQUFBLE1BQUEsUUFBUSxJQUFHO0FBQUE7Z0JBR1osY0FBVyxNQUFTLFNBQVM7aUJBRTVCO0FBQUEsWUFBTSxZQUFZLFFBQU8sRUFBRyxJQUFNLENBQUEsQ0FBQSxXQUFXLFNBQVMsTUFBQTtvQkFDdEQsVUFBTyxDQUFBO0FBQ1Asb0JBQUEsK0JBQWU7QUFFUix5QkFBQSxDQUFBLEVBQUEsT0FBTyxLQUFLLFdBQVM7QUFDakMseUJBQVMsSUFBSSxPQUFPLFdBQVcsVUFBVSxRQUFRLE9BQU8sQ0FBQTtBQUFBO0FBR3pELHNCQUFRLEtBQUksR0FBSSxRQUFROztnQkFHdkIsT0FBTyxVQUFVO0FBQUEsZ0JBQ2pCLE1BQU0sVUFBVTtBQUFBLGdCQUNoQixjQUFjO0FBQUEsZ0JBQ2QsVUFBVTtBQUFBLGdCQUNWLFNBQU8sRUFDTixNQUFNLFVBQVUsTUFDaEIsV0FBVyxRQUFPO0FBQUE7O2FBR2hCLFdBQVc7QUFBQTs7O2dCQUtWLFlBQVMsTUFBUyxPQUFPO2lCQUV4QjtBQUFBLFlBQVUsQ0FBQSxHQUFBLFVBQVUsVUFBUSxFQUFJLElBQU0sQ0FBQSxDQUFBLFdBQVcsU0FBUyxPQUFBO0FBQUEsY0FDaEUsT0FBTyxVQUFVO0FBQUEsY0FDakIsTUFBTSxVQUFVO0FBQUEsY0FDaEIsY0FBYztBQUFBLGNBQ2QsVUFBVTtBQUFBLGNBQ1YsU0FBTztBQUFBLGdCQUNOLE1BQU0sVUFBVTtBQUFBLGdCQUNoQixPQUFPLFVBQVU7QUFBQSxnQkFDakIsV0FBUyxDQUFBLEdBQU0sVUFBVSxTQUFTLFVBQVUsTUFBTSxDQUNoRCxFQUFBLE1BQVEsRUFBQSxPQUFPLE1BQU0sT0FBTyxPQUFPLFVBQVUsU0FBUyxPQUFPLENBQUE7QUFBQTs7YUFFM0QsT0FBTztBQUFBOzs7Z0JBS1AsVUFBTyxNQUFTLEtBQUs7aUJBRXBCO0FBQUEsWUFBTSxRQUFRLFFBQU8sRUFBRyxJQUFNLENBQUEsQ0FBQSxPQUFPLEtBQUssT0FBQTtBQUFBLGNBQ2hELE9BQU8sVUFBVTtBQUFBLGNBQ2pCLE1BQU0sTUFBTTtBQUFBLGNBQ1osY0FBYztBQUFBLGNBQ2QsVUFBVTtBQUFBLGNBQ1YsU0FDQyxFQUFBLE1BQU0sTUFBTSxLQUFJO0FBQUE7Ozs7O2dCQU9aLFdBQVEsQ0FBQTt3QkFFRCxPQUFPLEtBQUssVUFBVSxRQUFPLEdBQUE7d0JBQzlCLFNBQVMsUUFBUSxLQUFLLFVBQVUsU0FBUyxtQkFBbUIsT0FBTyxDQUFBLEdBQUE7QUFDbEUseUJBQUEsQ0FBQSxTQUFTM0IsUUFBTyxLQUFLLElBQUksUUFBUSxHQUFBO0FBQzNDLHlCQUFTLEtBQUk7QUFBQSxrQkFDWixPQUFPLFVBQVU7QUFBQSxrQkFDakIsTUFBTUEsU0FBUTtBQUFBLGtCQUNkLGNBQWM7QUFBQSxrQkFDZCxVQUFVQTtBQUFBLGtCQUNWLFNBQU87QUFBQSxvQkFDTixNQUFNO0FBQUEsb0JBQ04sTUFBTUEsU0FBUTtBQUFBLG9CQUNkLFFBQVFBLFNBQVE7QUFBQSxvQkFDaEIsUUFBUUEsU0FBUTtBQUFBLG9CQUNoQixVQUFVQSxTQUFRO0FBQUE7Ozs7O2lCQU9oQixNQUFNLFVBQ1osQ0FBQSxRQUNBLFVBQ0EsVUFDQSxVQUFVLENBQUE7QUFBQTs7OztBQVVOLFdBQUFMLFFBQU8sVUFBZ0I7VUFDekIsV0FBUSxDQUFBO1VBQ1IsU0FBTSxDQUFBO0FBQ1IsUUFBQSxVQUFVO0FBRUosZUFBQSxVQUFVLFNBQU87QUFDcEIsWUFBQSxlQUFlLE9BQU8sT0FBTyxRQUFRO0FBRXhDLFVBQUEsYUFBYSxRQUFNO0FBQ3JCLG1CQUFXLE9BQU87QUFFbEIsZUFBTyxLQUFJLEdBQUksWUFBWTtBQUUzQixpQkFBUyxLQUFJO0FBQUEsVUFDWixLQUFLLGFBQWEsR0FBRztBQUFBLFVBQ3JCLE1BQU07QUFBQTs7O0FBTVQsV0FBTyxLQUFNLENBQUEsS0FBSyxRQUFRLElBQUksUUFBUyxJQUFJLEtBQU07b0JBR2pELFdBQVcsWUFBWSxJQUFFLFVBQUE7QUFFekIsWUFBUSxJQUFJLE1BQU07QUFHUixlQUFBLFNBQVMsUUFBTTtVQUNwQixJQUFHO0FBQUEsUUFDTixRQUFRO0FBQUEsUUFDUixZQUNJLE1BQU0sTUFDVCxRQUFRLEdBQUU7QUFBQTs7O0FBb0M0QyxRQUFBLGlCQUFBLGFBQVdBLFFBQU8sUUFBUSxNQUFNOzs7QUFRL0MsbUJBQVU7Ozs7OztBQXRDcEQ7WUFDRyxZQUFVO0FBQ1osVUFBQUEsUUFBTyxVQUFVO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pOYixNQUFBLFlBQUEsSUFBYSxHQUFBLE1BQU0sT0FBYSxNQUFDOzs7QUFBTyxNQUFBLFdBQUEsT0FBYSxLQUFDOzs7Ozs7OztnQkFEUixPQUMvQzs7Z0JBQW9DLE1BQUk7OzsrQkFKYixJQUFlLEtBQUEsR0FBQTs7b0NBRFgsSUFBWSxHQUFDLEtBQUssQ0FBQzs7b0NBSXZCLElBQVksR0FBQyxLQUFLLENBQUM7QUFBQTs7QUFKcEQsYUFFSyxRQUFBLE1BQUEsTUFBQTtBQURKLGFBQXlELE1BQUEsSUFBQTs7QUFHMUQsYUFFSyxRQUFBLE1BQUEsTUFBQTs7Ozs7Ozs7aUNBTDRCTixLQUFlLEtBQUEsR0FBQTtBQUFBOztzQ0FEWEEsS0FBWSxHQUFDLEtBQUssQ0FBQztBQUFBO0FBS2pELFVBQUEsUUFBQSxLQUFBLGNBQUEsWUFBQUEsS0FBYSxHQUFBLE1BQU1BLFFBQWEsTUFBQztBQUFBLGlCQUFBLElBQUEsUUFBQTtBQUFPLFVBQUEsUUFBQSxLQUFBLGNBQUEsV0FBQUEsUUFBYSxLQUFDO0FBQUEsaUJBQUEsSUFBQSxRQUFBOztzQ0FENUJBLEtBQVksR0FBQyxLQUFLLENBQUM7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE1RGxELG1CQUFBLEdBQUUsa0JBQW1CLGFBQWEsS0FBSyxhQUFhLEtBQU0sR0FBRztBQUFBOzs7Ozs7Ozs7O0FDSC9ELElBQWUsaUJBQUE7QUNBZixJQUFlLG1CQUFBO0FDQWYsSUFBZSxpQkFBQTs7Ozs7Ozs7Ozs7Ozs7O0FDaVVBLE1BQUEsWUFBQSxRQUFPLE9BQUk7OztBQUlqQixNQUFBLFdBQUEsUUFBTyxRQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFOZixhQVFJLFFBQUEsSUFBQSxNQUFBO0FBUEgsYUFHTSxJQUFBLEtBQUE7OztBQUNOLGFBRU0sSUFBQSxLQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYUUsTUFBQSxZQUFBLFFBQU8sT0FBSTs7O0FBSWpCLE1BQUEsV0FBQSxRQUFPLFFBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU5mLGFBUUksUUFBQSxJQUFBLE1BQUE7QUFQSCxhQUdNLElBQUEsS0FBQTs7O0FBQ04sYUFFTSxJQUFBLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQkExQkQsSUFBZTs7bUNBQXBCLFFBQUksS0FBQSxHQUFBOzs7bUJBa0JDLElBQU87O2lDQUFaLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0FoQ1EsSUFBaUIsRUFBQTtBQUFBOztBQUZwQyxhQWlESyxRQUFBLE1BQUEsTUFBQTtBQTdDSixhQUVDLE1BQUEsSUFBQTs7QUFFRCxhQXdDSyxNQUFBLElBQUE7QUF2Q0osYUFFSyxNQUFBLElBQUE7dUJBREc7O0FBR1IsYUFrQ0ssTUFBQSxJQUFBO0FBakNKLGFBZ0JLLE1BQUEsSUFBQTtBQWZKLGFBWUksTUFBQSxHQUFBOzs7OztBQUVKLGFBQUcsTUFBQSxFQUFBOztBQUdKLGFBY0ssTUFBQSxJQUFBO0FBYkosYUFZSSxNQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7O3VCQTdCSUEsS0FBZTs7cUNBQXBCLFFBQUksS0FBQSxHQUFBOzs7Ozs7Ozs7Ozs7OzRDQUFKO0FBQUE7O3FCQWtCS0EsS0FBTzs7bUNBQVosUUFBSSxLQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7d0NBQUo7QUFBQTs7eUNBaENZQSxLQUFpQixFQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFyUnBCLGFBQWlCLE1BQU07QUFFN0IsV0FBQSxTQUFTLFdBQW1CO0FBQ3BDLG9CQUFBLGtCQUFBLG9CQUFvQixPQUFLLGlCQUFBO0FBRXRCLFFBQUEsY0FBYyxjQUFjLGFBQWEsSUFBRTtBQUM3QyxvQkFBYyxhQUFhOztXQUd0QixjQUFjLGVBQWUsU0FBUztBQUFBOztRQUl2QyxVQUFPO0FBQUE7TUFXWCxPQUFPO0FBQUEsTUFFUCxNQUFNO0FBQUEsTUFDTixRQUFLO0FBQ0osaUJBQVMsU0FBUyxRQUFRO0FBQUE7OztNQUkzQixPQUFPO0FBQUEsTUFFUCxNQUFNO0FBQUEsTUFDTixRQUFLO0FBQ0osaUJBQVMsU0FBUyxRQUFRO0FBQUE7OztRQW9DdkIsa0JBQWU7QUFBQTtNQUVuQixPQUFPO0FBQUEsTUFDUCxNQUFNO0FBQUEsWUFDQSxRQUFLO2NBQ0osT0FBTTtBQUNaLG1CQUFXLE1BQUs7QUFBQTs7O0FBME1GLFFBQUFPLGlCQUFBLE1BQUEsZ0JBQUEsa0JBQUEsb0JBQW9CLE9BQUssaUJBQUE7QUFJRCxRQUFBLGtCQUFBLE1BQUEsZ0JBQUEsa0JBQUEsb0JBQW9CLE9BQUssaUJBQUE7QUFRekMsUUFBQSxrQkFBQSxZQUFBLE9BQU8sTUFBSztBQWtCSCxRQUFBLGtCQUFBLFlBQUEsT0FBTyxNQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VDaUhuQyxPQUVOO0FBQUE7Ozs7Ozs7Ozs7OztBQUhHLE1BQUEsWUFBQSxJQUFvQixLQUFBLEtBQUssUUFBUSxDQUFDLElBQUE7Ozs7OztnQkFBRSxVQUN2QztBQUFBOzs7Ozs7QUFERyxVQUFBLFFBQUEsS0FBQSxjQUFBLFlBQUFQLEtBQW9CLEtBQUEsS0FBSyxRQUFRLENBQUMsSUFBQTtBQUFBLGlCQUFBLElBQUEsUUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFEaENBLEtBQWlCO0FBQUEsYUFBQUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkJBOURwQjs7Ozs7OztnQkFrQkQsSUFBZ0IsRUFBQTs7Ozs7Ozs7aUJBV2YsSUFBUSxFQUFBOzs7Ozs7OztpQkFZUixJQUFVLEVBQUE7Ozs7Ozs7aUJBVUssR0FDaEI7aUJBQUMsSUFBUSxFQUFBOzs7Ozs7Ozs7Ozs7OztpQkF3QlQsSUFBVSxFQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQS9GRSxJQUFlLEVBQUE7QUFBQTs7QUFGbEMsYUFrSEssUUFBQSxPQUFBLE1BQUE7QUE5R0osYUFFQyxPQUFBLElBQUE7O0FBRUQsYUF5R0ssT0FBQSxLQUFBO0FBeEdKLGFBRUssT0FBQSxJQUFBOztBQUVMLGFBbUdLLE9BQUEsS0FBQTtBQWxHSixhQWlHSyxPQUFBLEtBQUE7QUFoR0osYUFRSyxPQUFBLElBQUE7QUFQSixhQUVLLE1BQUEsSUFBQTs7QUFFTCxhQUVLLE1BQUEsSUFBQTs7QUFXTixhQVFLLE9BQUEsSUFBQTtBQVBKLGFBRUssTUFBQSxJQUFBOztBQUVMLGFBRUssTUFBQSxJQUFBOzs7QUFHTixhQVVLLE9BQUEsS0FBQTtBQVRKLGFBRUssT0FBQSxJQUFBOztBQUVMLGFBSUssT0FBQSxJQUFBO0FBSEosYUFFTSxNQUFBLEtBQUE7OztBQUlSLGFBVUssT0FBQSxLQUFBO0FBVEosYUFFSyxPQUFBLEtBQUE7O0FBRUwsYUFJSyxPQUFBLEtBQUE7QUFISixhQUVNLE9BQUEsS0FBQTs7O0FBSVIsYUFRSyxPQUFBLEtBQUE7QUFQSixhQUVLLE9BQUEsS0FBQTs7QUFFTCxhQUVLLE9BQUEsS0FBQTs7OztBQUdOLGFBWUssT0FBQSxLQUFBO0FBWEosYUFFSyxPQUFBLEtBQUE7O0FBRUwsYUFNSyxPQUFBLEtBQUE7OztBQUdOLGFBUUssT0FBQSxLQUFBO0FBUEosYUFFSyxPQUFBLEtBQUE7O0FBRUwsYUFFSyxPQUFBLEtBQUE7Ozs7Ozs7Ozs7OztxQkEzREhDLEtBQWdCLEVBQUE7O3NCQVdmQSxLQUFRLEVBQUE7O3NCQVlSQSxLQUFVLEVBQUE7O3NCQVdWQSxLQUFRLEVBQUE7Ozs7Ozs7Ozs7OztzQkF3QlRBLEtBQVUsRUFBQTs7MENBL0ZFQSxLQUFlLEVBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFsVTdCLE1BQUEsV0FBVztBQUNYLE1BQUEsVUFBVTtBQUNWLE1BQUEsb0JBQW9CO0FBRXBCLE1BQUEsbUJBQW1CO0FBQ25CLE1BQUEsYUFBYTtBQUNiLE1BQUEsV0FBVztBQWdCZixpQkFBYztBQUFBLElBQ2IsVUFBVSxRQUFNO1VBQ1osa0JBQWtCLE9BQU8sT0FBSztBQUNoQyxxQkFBQSxHQUFBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFBLEdBQUEsV0FBVyxPQUFPLE9BQU8sUUFBa0I7QUFFM0MscUJBQUEsR0FBQSxXQUFXLE9BQU8sT0FBTyxNQUFnQjtBQUN6QyxrQkFBVSxLQUFLO2NBRVQsWUFBWSxPQUFPO1lBQ3RCLFVBQVUsU0FBUyxHQUFDO2dCQUNoQixTQUFNLENBQUE7bUJBQ0osU0FBTyxHQUFHLFNBQU8sVUFBVSxRQUFRLFVBQU07QUFDaEQsbUJBQU8sS0FBSyxVQUFVLFVBQVUsVUFBVSxTQUFPLEVBQUM7QUFBQTtBQUduRCx1QkFBQSxHQUFBLG9CQUFvQixPQUFPLE9BQU0sQ0FBRSxPQUFPLFlBQVksUUFBUSxTQUFTLENBQUMsSUFBSSxPQUFPLE1BQU07QUFBQTs7OztBQU16RixNQUFBLGFBQWE7UUFDWCxhQUFhLE9BQU87QUFBQTtBQUN0QixVQUFBLFVBQVUsR0FBQztBQUNQLGNBQUEsU0FBUyxLQUFLLElBQUcsSUFBSztBQUM1QixxQkFBQSxHQUFBLGdCQUFnQixLQUFLLE1BQU0sU0FBUyxHQUFHLGVBQUE7QUFBQTs7SUFFdEM7QUFBQTtBQUVILFlBQVMsTUFBQTtBQUNSLGtCQUFjLFVBQVU7QUFBQTtBQWdSUixRQUFBTyxpQkFBQSxNQUFBLGdCQUFBLGdCQUFBLGtCQUFrQixPQUFLLGVBQUE7QUFJQyxRQUFBLGtCQUFBLE1BQUEsZ0JBQUEsZ0JBQUEsa0JBQWtCLE9BQUssZUFBQTs7O1VBNVQxRCxhQUFXO0FBQ2hCLHFCQUFBLEdBQUEsV0FBVyxPQUFPO0FBQ2xCLGtCQUFVO0FBQ1YscUJBQUEsR0FBQSxvQkFBb0IsQ0FBQztBQUNyQixxQkFBQSxHQUFBLG1CQUFtQixZQUFZO0FBQy9CLHFCQUFBLEdBQUEsaUJBQWlCLElBQUksWUFBWSxVQUFVLEVBQUUsSUFBSTtBQUNqRCxxQkFBQSxHQUFBLFdBQVcsRUFBRTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJSLE1BQU0sS0FJWDtBQUFBLEVBYUQsWUFBWSxTQUFvRCxZQUFvQjtBQVoxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSxxQ0FBeUYsQ0FBQTtBQUV6RjtBQUNBO0FBRXNELFNBQUEsYUFBQTtBQUM5RCxLQUFBO0FBQUEsTUFDQSxTQUFTLEtBQUs7QUFBQSxNQUNkLE9BQU8sS0FBSyxXQUFTLENBQUM7QUFBQSxNQUN0QixTQUFTLEtBQUssYUFBVyxDQUFDO0FBQUEsSUFHdkIsSUFBQTtBQUdDLFNBQUEsV0FBVyxPQUFPO0FBR2pCLFVBQUEsWUFBWSxHQUFHLEtBQUs7QUFFcEIsVUFBQSxhQUFhLElBQUksSUFBSSxJQUFJO0FBQUEsTUFDOUIsR0FBRyxLQUFLO0FBQUEsTUFDUixNQUFNO0FBQUEsSUFDTixDQUFBLENBQUM7QUFHRyxTQUFBLGdCQUFnQixJQUFJLEtBQUssWUFBWTtBQUFBLE1BQ3pDLFFBQVE7QUFBQSxNQUNSLE9BQU87QUFBQSxRQUNOLEdBQUcsS0FBSztBQUFBLFFBQ1IsUUFBUTtBQUFBLE1BQ1Q7QUFBQSxNQUNBLFNBQVM7QUFBQSxJQUFBLENBQ1Q7QUFHRCxRQUFHLFFBQVEsUUFBUTtBQUNsQixpQkFBVSxDQUFDLFVBQVUsVUFBVSxLQUFLLElBQUksUUFBUSxNQUFNLEdBQUc7QUFDbkQsYUFBQSxjQUFjLElBQUksVUFBVSxVQUFVO0FBQUEsTUFDNUM7QUFBQSxJQUNEO0FBR0EsVUFBTSxXQUFXLFVBQVU7QUFDM0IsUUFBRyxDQUFDLFVBQVU7QUFDYixZQUFNLElBQUksTUFBTSxvRUFBb0UsS0FBSyxVQUFVLE9BQU8sR0FBRztBQUFBLElBQzlHO0FBR0EsU0FBSyxXQUFXO0FBQUEsRUFDakI7QUFBQSxFQUVBLElBQUksS0FBYTtBQUNoQixXQUFPLEtBQUs7QUFBQSxFQUNiO0FBQUEsRUFFQSxJQUFJLFFBQWdCO0FBQ1osV0FBQSxLQUFLLE9BQU8sUUFBUTtBQUFBLEVBQzVCO0FBQUEsRUFFQSxJQUFJLFNBQWlCO0FBQ3BCLFdBQU8sS0FBSztBQUFBLEVBQ2I7QUFBQSxFQUVBLElBQUksVUFBc0I7QUFDekIsV0FBTyxLQUFLO0FBQUEsRUFDYjtBQUFBLEVBRUEsSUFBSSxZQUEwQjtBQUM3QixXQUFPLEtBQUs7QUFBQSxFQUNiO0FBQUEsRUFFQSxJQUFJLFFBQWlCO0FBQ3BCLFdBQU8sS0FBSztBQUFBLEVBQ2I7QUFBQSxFQUVBLElBQUksTUFBbUI7QUFDdEIsV0FBTyxLQUFLO0FBQUEsRUFDYjtBQUFBLEVBRUEsV0FBVyxTQUFxQztBQUN4QyxXQUFBLFFBQVEsWUFBWSxLQUFLLFdBQzVCLENBQUMscUJBQXFCLFFBQVEsU0FBUyxDQUFBLEdBQUksS0FBSyxLQUFLO0FBQUEsRUFDMUQ7QUFBQSxFQUVBLE9BQWE7QUFDTCxXQUFBLEtBQUssV0FBVztFQUN4QjtBQUFBLEVBRUEsS0FBSyxTQUEyQjtBQUMvQixXQUFPLEtBQUssV0FBVyxLQUFLLFNBQVMsSUFBSTtBQUFBLEVBQzFDO0FBQUEsRUFFQSxJQUFJLFFBQTBCO0FBQzdCLFdBQU8sS0FBSyxXQUFXLElBQUksVUFBVSxDQUFBLEdBQUksSUFBSTtBQUFBLEVBQzlDO0FBQUEsRUFFQSxLQUFLLFNBQXFCLFNBQTRCO0FBQ3JELFdBQU8sS0FBSyxXQUFXLEtBQUssU0FBUyxXQUFXLENBQUEsR0FBSSxJQUFJO0FBQUEsRUFDekQ7QUFBQSxFQUVBLEdBQUcsVUFBaUM7QUFDbkMsZUFBVSxDQUFDLFVBQVUsVUFBVSxLQUFLLElBQUksUUFBUSxHQUFHO0FBQ2xELFVBQUcsWUFBWTtBQUNkLGNBQU0sY0FBYyxLQUFLLFVBQVUsWUFBWSxLQUFLLFVBQVUsYUFBYTtBQUMzRSxvQkFBWSxLQUFLLFVBQVU7QUFBQSxNQUM1QjtBQUFBLElBQ0Q7QUFBQSxFQUNEO0FBQUEsRUFFQSxNQUFNLEtBQUssVUFBdUIsUUFBK0I7QUFDMUQsVUFBQSxjQUFjLEtBQUssVUFBVTtBQUVuQyxRQUFHLGFBQWE7QUFDVCxZQUFBLFFBQVEsSUFBSSxZQUFZLElBQUksQ0FBQSxNQUFLLEVBQUUsR0FBRyxVQUFVLENBQVcsQ0FBQSxDQUFDLENBQUM7QUFBQSxJQUNwRTtBQUFBLEVBQ0Q7QUFBQSxFQUVBLFVBQWdCO0FBQ2YsU0FBSyxjQUFjO0VBQ3BCO0FBQUEsRUFFQSxRQUFjO0FBQ2IsU0FBSyxXQUFXO0VBQ2pCO0FBQ0Q7QUM1Sk8sTUFBTSxPQUFPO0FBQUEsRUFLbkIsWUFBc0IsWUFBZ0MsYUFBbUMsY0FBeUI7QUFKeEc7QUFFQSxzQ0FBcUIsQ0FBQTtBQUVULFNBQUEsYUFBQTtBQUFnQyxTQUFBLGNBQUE7QUFBbUMsU0FBQSxlQUFBO0FBQ25GLFNBQUEsYUFBYSxHQUFHLE9BQU87QUFBQSxNQUMzQixTQUFTO0FBQUEsTUFDVCxrQkFBa0IsS0FBSztBQUFBLE1BQ3ZCLFNBQVM7QUFBQSxJQUFBLENBQ1Q7QUFBQSxFQUNGO0FBQUEsRUFFQSxJQUFJLEtBQWU7QUFDbEIsV0FBTyxLQUFLO0FBQUEsRUFDYjtBQUFBLEVBRUEsSUFBSSxVQUFzQjtBQUN6QixXQUFPLEtBQUs7QUFBQSxFQUNiO0FBQUEsRUFFQSxJQUFJLFVBQWtCO0FBQ3JCLFdBQU8sS0FBSztBQUFBLEVBQ2I7QUFBQSxFQUVBLElBQUksT0FBYTtBQUNoQixXQUFPLEtBQUssV0FBVztBQUFBLEVBQ3hCO0FBQUEsRUFFQSxJQUFJLE1BQW1CO0FBQ3RCLFdBQU8sS0FBSztBQUFBLEVBQ2I7QUFBQSxFQUdVLE9BQU8sU0FBMkI7QUFFckMsVUFBQSxTQUFTLElBQUksS0FBSztBQUFBLE1BQ3ZCLEdBQUc7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNSLEdBQUcsS0FBSyxhQUFhO0FBQUEsUUFDckIsR0FBRyxRQUFRO0FBQUEsTUFDWjtBQUFBLE9BQ0UsSUFBSTtBQUdGLFNBQUEsV0FBVyxZQUFZLE9BQU8sR0FBRztBQUdqQyxTQUFBLFdBQVcsUUFBUSxNQUFNO0FBR3ZCLFdBQUE7QUFBQSxFQUNSO0FBQUEsRUFHQSxNQUFNLFVBQW9CLEtBQUssU0FBUyxVQUE4QjtBQUUvRCxVQUFBO0FBQUEsTUFDTCxTQUFTO0FBQUEsSUFBQSxJQUNOLFlBQVksQ0FBQTtBQUdoQixVQUFNLFlBQVksS0FBSztBQU12QixhQUFRLFVBQVEsYUFBWSxJQUFHLEdBQUcsVUFBUSxVQUFVLFFBQVEsV0FBVztBQUM1RCxnQkFBQSxTQUFTLFVBQVUsU0FBUztBQUFBLElBQ3ZDO0FBR0EsY0FBVSxTQUFTO0FBR2IsVUFBQSxTQUFTLEtBQUssT0FBTyxPQUFPO0FBR2xDLFNBQUssS0FBSyxhQUFhLFlBQVksTUFBTSxRQUFRLFlBQVksQ0FBQSxDQUFFO0FBUXhELFdBQUE7QUFBQSxFQUNSO0FBQUEsRUFFQSxPQUF5QjtBQUN4QixXQUFPLEtBQUssV0FBVztBQUFBLEVBQ3hCO0FBQUEsRUFFQSxLQUFLLFNBQXFCLFFBQW9CO0FBRTFDLFFBQUEsV0FBVyxLQUFLLE1BQU07QUFDbEIsWUFBQSxJQUFJLE1BQU0saURBQWlEO0FBQUEsSUFDbEU7QUFHQSxRQUFHLENBQUMsS0FBSyxhQUFhLFlBQVksU0FBUyxRQUFRLElBQUksR0FBRztBQUNuRCxZQUFBLElBQUksTUFBTSxtREFBbUQ7QUFBQSxJQUNwRTtBQUdNLFVBQUEsU0FBUyxLQUFLLE9BQU8sT0FBTztBQUdsQyxTQUFLLEtBQUssYUFBYSxXQUFXLE1BQU0sUUFBUSxNQUFNO0FBRy9DLFdBQUE7QUFBQSxFQUNSO0FBQUEsRUFFQSxJQUFJLFFBQW1CLFFBQW9CO0FBRXZDLFFBQUEsV0FBVyxLQUFLLE1BQU07QUFDbEIsWUFBQSxJQUFJLE1BQU0sb0RBQW9EO0FBQUEsSUFDckU7QUFHRyxRQUFBLEtBQUssV0FBVyxTQUFTLEdBQUc7QUFDeEIsWUFBQSxJQUFJLE1BQU0sNkJBQTZCO0FBQUEsSUFDOUM7QUFHRyxRQUFBLENBQUMsS0FBSyxhQUFhLFdBQVcsUUFBUSxLQUFLLFdBQVcsSUFBSSxRQUFRLElBQUksR0FBRztBQUNyRSxZQUFBLElBQUksTUFBTSxzREFBc0Q7QUFBQSxJQUN2RTtBQUdBLFNBQUssV0FBVztBQUdoQixVQUFNLFNBQVMsS0FBSztBQUdwQixTQUFLLEtBQUssYUFBYSxVQUFVLE1BQU0sUUFBUSxRQUFRLE1BQU07QUFHdEQsV0FBQTtBQUFBLEVBQ1I7QUFBQSxFQUVBLEtBQUssU0FBcUIsU0FBcUIsUUFBb0I7QUFFL0QsUUFBQSxXQUFXLEtBQUssTUFBTTtBQUNsQixZQUFBLElBQUksTUFBTSxnREFBZ0Q7QUFBQSxJQUNqRTtBQUdHLFFBQUEsQ0FBQyxLQUFLLGFBQWEsWUFBWSxTQUFTLFNBQVMsUUFBUSxJQUFJLEdBQUc7QUFDNUQsWUFBQSxJQUFJLE1BQU0sa0RBQWtEO0FBQUEsSUFDbkU7QUFHTSxVQUFBLFVBQVUsS0FBSyxXQUFXO0FBQ2hDLFFBQUcsQ0FBQyxRQUFRLFNBQVMsU0FBUyxXQUFXLE9BQU8sR0FBRztBQUVsRCxhQUFPLEtBQUssSUFBSSxDQUFDLEdBQUcsTUFBTTtBQUFBLElBQzNCO0FBR0EsVUFBTSxTQUFTLElBQUksS0FBSyxTQUFTLElBQUk7QUFHckMsU0FBSyxNQUFNO0FBR1gsMEJBQXNCLE9BQU8sS0FBSyxPQUFPLEtBQUssQ0FBRTtBQUczQyxTQUFBLEtBQUssYUFBYSxXQUFXLE1BQU0sUUFBUSxRQUFRLE9BQU8sRUFBRSxLQUFLLE1BQU07QUFFdkUsVUFBQTtBQUNILGVBQU8sUUFBUTtBQUFBLGVBRVY7QUFDTCxnQkFBUSxLQUFLLHdEQUF3RCxPQUFPLFFBQVEsT0FBSyxJQUFJO0FBRzdGLGVBQU8sSUFBSTtNQUNaO0FBQUEsSUFBQSxDQUNBO0FBR00sV0FBQTtBQUFBLEVBQ1I7QUFBQSxFQUVBLE9BQWE7QUFDUCxTQUFBLFdBQVcsTUFBTSxVQUFVO0FBQUEsRUFDakM7QUFBQSxFQUVBLE9BQWE7QUFDUCxTQUFBLFdBQVcsTUFBTSxVQUFVO0FBQUEsRUFDakM7QUFDRDtBQ3RLZ0IsU0FBQSxzQkFBc0IsUUFBcUIsUUFBcUIsU0FBdUI7QUFDaEcsUUFBQSxTQUFTLENBQUMsT0FBTyxNQUFNO0FBQzdCLFFBQU0sU0FBUyxTQUFTO0FBQ2pCLFNBQUEsTUFBTSxTQUFTLFNBQU87QUFDdEIsU0FBQSxNQUFNLFNBQVMsU0FBTztBQUM5QjtBQUVPLE1BQU0sVUFBVTtBQUFBLEVBdUJ0QixZQUFzQixlQUFnQztBQXRCNUMsc0NBQWdELENBQUE7QUFDaEQ7QUFDQTtBQUtBLHNDQUFhLEdBQUcsS0FBSztBQUdyQjtBQUdBO0FBR0Esc0NBQXVCLFNBQVM7QUFHaEMsdUNBQWM7QUFHRixTQUFBLGdCQUFBO0FBRXBCLEtBQUE7QUFBQSxNQUNBLFdBQVcsS0FBSztBQUFBLE1BQ2hCLFNBQVMsS0FBSztBQUFBLE1BQ2QsT0FBTyxLQUFLO0FBQUEsTUFDWixTQUFTLEtBQUssYUFBVyxDQUFDO0FBQUEsSUFHdkIsSUFBQTtBQUdDLFNBQUEsWUFBWSxTQUFTLE9BQU87QUFBQSxFQUNsQztBQUFBLEVBRUEsSUFBSSxVQUF1QjtBQUMxQixXQUFPLEtBQUs7QUFBQSxFQUNiO0FBQUEsRUFFUSxZQUFZLFdBQXFCLFVBQXVCLENBQUEsR0FBSSxZQUF1QixDQUFBLEdBQVk7QUFFaEcsVUFBQSxZQUFZLEtBQUssbUJBQW1CO0FBQzFDLFFBQUcsQ0FBQyxXQUFXO0FBQ1IsWUFBQSxJQUFJLE1BQU0sNkNBQTZDLFlBQVk7QUFBQSxJQUMxRTtBQUdNLFVBQUEsU0FBUyxJQUFJLE9BQU8sV0FBVyxVQUFVLFNBQVMsU0FBUyxHQUFHLElBQUk7QUFHeEUsU0FBSyxXQUFXLGFBQWE7QUFHeEIsU0FBQSxZQUFZLFlBQVksT0FBTyxHQUFHO0FBR3ZDLFdBQU8sTUFBTTtBQUFBLE1BQ1osR0FBRyxPQUFPO0FBQUEsTUFDVixPQUFPO0FBQUEsUUFDTixHQUFHLE9BQU8sUUFBUTtBQUFBLFFBQ2xCLEdBQUc7QUFBQSxNQUNKO0FBQUEsSUFBQSxDQUNBO0FBR00sV0FBQTtBQUFBLEVBQ1I7QUFBQSxFQUtBLElBQUksZUFBdUI7QUFDbkIsV0FBQSxLQUFLLFdBQVcsS0FBSztBQUFBLEVBQzdCO0FBQUEsRUFLQSxJQUFJLGFBQW1CO0FBQ3RCLFdBQU8sS0FBSyxhQUFhO0FBQUEsRUFDMUI7QUFBQSxFQTBEQSxZQUFZLFNBQXFCLFFBQWMsVUFBMkI7QUFFekUsUUFBRyxLQUFLLGlCQUFpQjtBQUFpQixhQUFBO0FBRzFDLFFBQUcsVUFBVSxLQUFLLFNBQVMsZ0JBQWdCLFVBQVUsUUFBUSxNQUFNO0FBQVUsYUFBQTtBQUM3RSxRQUFHLFVBQVUsS0FBSyxTQUFTLGNBQWMsVUFBVSxRQUFRLE9BQU87QUFBVSxhQUFBO0FBR3JFLFdBQUE7QUFBQSxFQUNSO0FBQUEsRUFHQSxXQUFXLFFBQW1CLFFBQWMsUUFBYyxVQUEyQjtBQUVwRixRQUFHLEtBQUssaUJBQWlCO0FBQWlCLGFBQUE7QUFHMUMsUUFBRyxVQUFVLEtBQUssU0FBUyxnQkFBZ0IsVUFBVSxRQUFRLEtBQUs7QUFBVSxhQUFBO0FBQzVFLFFBQUcsVUFBVSxLQUFLLFNBQVMsYUFBYSxVQUFVLFFBQVEsUUFBUSxNQUFNO0FBQVUsYUFBQTtBQUczRSxXQUFBO0FBQUEsRUFDUjtBQUFBLEVBRUEsWUFBWSxTQUFxQixTQUFxQixRQUFjLFVBQTJCO0FBRTlGLFFBQUcsS0FBSyxpQkFBaUI7QUFBaUIsYUFBQTtBQUcxQyxRQUFHLFVBQVUsS0FBSyxTQUFTLGdCQUFnQixVQUFVLFFBQVEsTUFBTTtBQUFVLGFBQUE7QUFDN0UsUUFBRyxVQUFVLEtBQUssU0FBUyxjQUFjLFVBQVUsUUFBUSxTQUFTLE9BQU87QUFBVSxhQUFBO0FBRzlFLFdBQUE7QUFBQSxFQUNSO0FBQUEsRUFFQSxNQUFNLGNBQWMsUUFBZ0IsV0FBb0M7QUFDdkUsUUFBRyxVQUFVLEtBQUssU0FBUyxnQkFBZ0IsUUFBUSxPQUFPLE1BQU0sUUFBUTtBQUFTLFlBQUEsSUFBSSxNQUFNLDJCQUEyQjtBQUV0SCxVQUFNLEtBQUssU0FBUyxnQkFBZ0IsUUFBUSxTQUFTO0FBQUEsRUFDdEQ7QUFBQSxFQUVBLE1BQU0sV0FBVyxVQUFrQixRQUFjLFFBQTZCO0FBQzdFLFVBQU0sVUFBVSxNQUFNLEtBQUssU0FBUyxhQUFhLFVBQVUsUUFBUSxNQUFNO0FBRW5FLFVBQUEsS0FBSyxTQUFTLGVBQWUsVUFBVSxRQUFRLFFBQVEsUUFBUSxXQUFXLENBQUEsQ0FBRTtBQUFBLEVBQ25GO0FBQUEsRUFFQSxNQUFNLFVBQVUsVUFBa0IsUUFBYyxRQUFjLFFBQWtDO0FBQ3pGLFVBQUEsVUFBVSxNQUFNLEtBQUssU0FBUyxZQUFZLFVBQVUsUUFBUSxRQUFRLE1BQU07QUFFMUUsVUFBQSxLQUFLLFNBQVMsZUFBZSxVQUFVLFFBQVEsUUFBUSxPQUFPLFdBQVcsQ0FBQSxDQUFFO0FBQUEsRUFDbEY7QUFBQSxFQUVBLE1BQU0sV0FBVyxVQUFrQixRQUFjLFFBQWMsU0FBb0M7QUFDNUYsVUFBQSxVQUFVLE1BQU0sS0FBSyxTQUFTLGFBQWEsVUFBVSxRQUFRLFFBQVEsT0FBTztBQUU1RSxVQUFBLEtBQUssU0FBUyxlQUFlLFVBQVUsUUFBUSxRQUFRLFFBQVEsV0FBVyxDQUFBLENBQUU7QUFBQSxFQUNuRjtBQUFBLEVBRUEsTUFBTSxZQUFZLFVBQWtCLFFBQWMsVUFBc0M7QUFDdkYsVUFBTSxVQUFVLE1BQU0sS0FBSyxTQUFTLGNBQWMsVUFBVSxRQUFRLFFBQVE7QUFFdEUsVUFBQSxLQUFLLFNBQVMsZUFBZSxVQUFVLE1BQU0sUUFBUSxTQUFTLFdBQVcsQ0FBQSxDQUFFO0FBQUEsRUFDbEY7QUFBQSxFQUVBLE1BQU0sYUFBYSxRQUFnQixRQUErQjtBQUNqRSxVQUFNLEtBQUssU0FBUyxlQUFlLFFBQVEsTUFBTTtBQUFBLEVBQ2xEO0FBQUEsRUFLQSxNQUFNLGVBQWUsV0FBcUIsVUFBcUIsSUFBc0I7QUFFcEYsVUFBTSxTQUFTLEtBQUs7QUFHcEIsVUFBTSxTQUFTLEtBQUs7QUFHaEIsUUFBQSxTQUFTLEtBQUssV0FBVztBQUcxQixRQUFBLGNBQWMsS0FBSyxZQUFZO0FBTzNCLFlBQUEsS0FBSyxjQUFjLFFBQVEsU0FBUztBQUduQixXQUFLO0FBRzVCLFVBQUcsQ0FBQyxRQUFRO0FBQ0YsaUJBQUEsS0FBSyxZQUFZLFdBQVcsT0FBTztBQUFBLE1BQUEsV0FHckMscUJBQXFCLE9BQU8sUUFBUSxTQUFTLENBQUEsR0FBSSxPQUFPLEdBQUc7QUFFNUQsY0FBQSxTQUFTLElBQUksS0FBSztBQUFBLFVBQ3ZCLEdBQUcsT0FBTztBQUFBLFVBQ1YsT0FBTztBQUFBLFVBQ1AsU0FBUyxLQUFLO0FBQUEsV0FDWixNQUFNO0FBR1QsZUFBTyxNQUFNLFFBQVE7QUFBQSxVQUNwQixTQUFTO0FBQUEsUUFBQSxDQUNUO0FBR0QsOEJBQXNCLE9BQU8sS0FBSyxPQUFPLEtBQUssRUFBRTtBQUFBLE1BQ2pEO0FBR0EsV0FBSyxhQUFhO0FBR2xCLFdBQUssYUFBYTtBQUNsQixXQUFLLGFBQWEsSUFBSSxNQUFNLFNBQVUsS0FBSyxnQkFBZTtBQVlwRCxZQUFBLEtBQUssYUFBYSxRQUFRLE1BQU07QUFFL0IsYUFBQTtBQUFBLElBQ1I7QUFRTyxXQUFBO0FBQUEsRUFDUjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7O0FDcUpVLGlCQUFBLE1BQU0sV0FBVSxHQUFBLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBQ2xCLElBQU8sT0FBQSxrQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkFGVCxJQUFNLE1BQUFSLGtCQUFBLEdBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBUFosYUFtQk0sUUFBQSxNQUFBLE1BQUE7QUFsQkwsYUFBcUQsTUFBQSxJQUFBOzs7QUFDckQsYUFBdUQsTUFBQSxJQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUFLbERDLEtBQU07QUFBQSxpQkFBQSxFQUFBQSxNQUFBLEtBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQTNjQSxLQUFnQixJQUFBO0FBQ3JCLFFBQUEsVUFBVTtRQUVMLEtBQW9CLElBQUE7UUFDekIsU0FBUyxXQUFXO1FBQ3BCLFNBQVMsVUFBVTtNQUVyQjtNQUNBO01BRUE7QUFHRSxRQUFBLGdCQUFnQixPQUFPLFlBQVksaUJBQWlCLFFBQU8sQ0FBQTtBQUVsRCxpQkFBQXVDLE9BQU0sVUFBdUIsT0FBSyxPQUFLO0FBRS9DLFVBQUEsUUFBUSxDQUFDO0FBR0osV0FBQSxJQUFBLFFBQVMsZ0JBQVU7QUFFN0IsZUFBUyxpQkFBaUIsaUJBQTBCLFNBQUEsZUFBZSxTQUFPO1lBQ3RFLGdCQUFnQixRQUFRLGNBQVk7QUFFdEMsbUJBQVMsVUFBVSxJQUFJLE1BQU07QUFFN0I7OztBQUtGLGVBQVMsTUFBTSwwQkFBMEIsT0FBTSxRQUFPO0FBQUE7O0FBSXhELFVBQU8sWUFBQTtVQUVBLGVBQVk7QUFBQSxNQUVqQixXQUFXO0FBQUEsTUFHWCxTQUFTO0FBQUEsTUFHVCxTQUFPO0FBQUEsUUFDTixTQUFPLE9BQUEsRUFDTixTQUFTckI7O01BS1gsT0FBSztBQUFBLFFBQ0osY0FBYyxZQUFZLFFBQVEsUUFBTTtlQUVsQyxPQUFPLEtBQUssTUFBTTtBQUFBO1FBSXhCLFdBQVcsWUFBWSxRQUFRLFFBQU07QUFLL0IsZUFBQSxLQUFJLEVBQUcsS0FBSSxNQUFBO0FBRVYsaUJBQUFxQixPQUFNLE9BQU8sS0FBSyxJQUFJO0FBQUE7O1FBSzdCLFVBQVUsWUFBWSxRQUFRLFFBQVEsUUFBTTtlQUV0QyxPQUFPLEtBQUssU0FBUztBQUd0QixjQUFBLENBQUEsT0FBTyxpQkFBZTtBQUV6QixtQkFBTyxJQUFJLE1BQU0sWUFBUztBQUFBOztRQUs1QixhQUFhLFlBQVksUUFBUSxRQUFRLGNBQWMsVUFBTyxJQUFBO0FBRTdELDBCQUFBLFNBQUEsV0FBVyxRQUFNLFFBQUE7QUFDakIsMEJBQUEsV0FBQSxhQUFhLFlBQVUsVUFBQTtlQUdsQixPQUFPLEtBQUssT0FBTztBQUFBO2NBUW5CLGdCQUFhOztBQUlYLGtCQUFBLFFBQVEsSUFBRztBQUFBLGNBRWhCLGFBQWEsbUJBQW1CLFVBQVUsSUFBSTtBQUFBLGNBQzlDLE9BQU8sS0FBSSxFQUFHLEtBQUssUUFBTSxnQkFBQSxjQUFBLGdCQUFnQixJQUFJLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBQyxhQUFBLENBQUE7QUFBQSxjQUd6RCxzQkFBc0IsbUJBQW1CLG1CQUFtQixJQUFJO0FBQUEsY0FDaEUsU0FBUyxLQUFJLEVBQUcsS0FBSyxRQUFNLGdCQUFBLGdCQUFBLGtCQUFrQixJQUFJLEdBQUcsR0FBRyxFQUFFLEdBQUcsSUFBQyxlQUFBLENBQUE7QUFBQSxjQUc3RCxlQUFlLG1CQUFtQixZQUFZLElBQUk7QUFBQSxjQUNsRCxTQUFTLEtBQUksRUFBRyxLQUFLLFFBQU0sZ0JBQUEsZ0JBQUEsa0JBQWtCLElBQUksR0FBRyxHQUFHLEVBQUUsR0FBRyxJQUFDLGVBQUEsQ0FBQTtBQUFBO0FBSXZELG1CQUFBLEtBQUs7QUFBQSxtQkFFUDs7O2NBS0QsYUFBYSxRQUFRLFFBQU07bUNBRWhDLFdBQVcsT0FBTyxNQUFJLFFBQUE7QUFDdEIsMEJBQUEsV0FBQSxhQUFhLFFBQU0sVUFBQTtBQUdkLGVBQUEsT0FBTyxLQUFLLEtBQUssT0FBTztnQkFHdkIsS0FBSTtBQUdKLGdCQUFBQSxPQUFNLE9BQU8sS0FBSyxLQUFLLElBQUk7QUFBQTs7O1FBTWpDLFFBQU07QUFFUixtQkFBYSxVQUNaLEVBQUEsZUFBZSxRQUFPO0FBQUEsZUFJaEIsUUFBTTtBQUViLG1CQUFhLFVBQVUsT0FBTyxXQUFTLENBQUcsV0FBVyxjQUFTOztXQVEzRCxZQUFhLGNBQ2IsRUFBQSxTQUFTLFdBQ1QsT0FBTzs7O0FBU1YsbUJBQWEsUUFBUSxPQUFRLENBQUEsU0FBc0IsZUFBdUI7QUFBQSxXQUN0RTtBQUFBLFFBQ0gsT0FDSSxFQUFBLEdBQUEsUUFBUSxVQUNSLFFBQU87QUFBQSxRQUVYLFNBQ0ksRUFBQSxHQUFBLFFBQVEsWUFDUixVQUFTO0FBQUE7O1VBS1QsY0FBVyxJQUFPLFVBQVUsWUFBWTtBQUM5QyxvQkFBQSxjQUFBLGdCQUFnQixhQUFXLGFBQUE7QUFBQTs7O0FBNlFZLG1CQUFVOzs7Ozs7QUFDVCxvQkFBVzs7Ozs7O0FBRm5CLG9CQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQzFTdkMsSUFBYyxFQUFBOzs7O0FBRGhCLGFBRUssUUFBQSxLQUFBLE1BQUE7Ozs7OztvQkFESHZDLEtBQWMsRUFBQTtBQUFBOzs7OztBQURtQyxZQUFBLENBQUE7QUFBQSwyQkFBQSxnQ0FBQSxLQUFBLE9BQUEsRUFBQSxVQUFTLE9BQUcsSUFBQTs7Ozs7O0FBQVosVUFBQSxDQUFBO0FBQUEseUJBQUEsZ0NBQUEsS0FBQSxPQUFBLEVBQUEsVUFBUyxPQUFHLEtBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBRDNELElBQWMsTUFBQSxnQkFBQSxHQUFBOzs7Ozs7Ozs7OztxQ0FISCxJQUFjLEVBQUE7QUFBQTs7QUFMOUIsYUFNQyxRQUFBLE9BQUEsTUFBQTs2QkFGWSxJQUFXLEVBQUE7Ozs7Ozs7Ozs7Ozt1Q0FBWEEsS0FBVyxJQUFBOytCQUFYQSxLQUFXLEVBQUE7QUFBQTs7dUNBQ1JBLEtBQWMsRUFBQTtBQUFBO1VBR3pCQSxLQUFjLElBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQVFFLFNBQUEsQ0FBQSxVQUFVLElBQWMsRUFBQTtBQUFBOzs7Ozs7QUFFOUIsTUFBQSxPQUFTLFVBQUssUUFBQTtBQUFkLGdCQUFBLFFBQUEsT0FBUztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTlCMUIsYUFFSyxRQUFBLE1BQUEsTUFBQTs7QUFFTCxhQUVLLFFBQUEsTUFBQSxNQUFBOztBQUVMLGFBQTZCLFFBQUEsTUFBQSxNQUFBOztBQUU3QixhQWdCSyxRQUFBLE1BQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJWSxzQkFBQSxRQUFBQSxRQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBOUtwQixZQUFZLFdBQWtDLFdBQVc7QUFHM0QsTUFBQSxjQUFjO0FBR2QsTUFBQSxpQkFBaUI7QUFHakIsTUFBQSxTQUFTO0FBR1QsTUFBQSxXQUFXO0FBQ1gsTUFBQSxlQUFlO0FBQ1YsV0FBQSxJQUFJLE9BQWE7b0JBQ3pCLFdBQVcsU0FBUyxNQUFNLE9BQU8sS0FBSyxJQUFHLElBQUssUUFBUSxDQUFBO0FBQUE7aUJBR3hDLGVBQWUsWUFBVSxPQUFLO0FBRXpDLFFBQUE7YUFBZTtBQUFHLGFBQVM7QUFHeEIsVUFBQSxPQUFpQixPQUFBLFNBQVMsT0FBTztBQUd2QyxpQkFBQSxHQUFBLGlCQUFpQixFQUFFO0FBR25CLGVBQVcsS0FBSztBQUVoQixRQUFJLDZCQUE2Qjs7QUFJMUIsWUFBQSxlQUFlLE9BQU8sWUFBWSxJQUFHO1lBQ3JDLE1BQU0sZUFBZSxtQkFBbUIsbUJBQW1CLElBQUksRUFBRTtBQUNqRSxZQUFBLGdCQUFnQixPQUFPLFlBQVksSUFBRztZQUV0QyxhQUFhLGdCQUFnQjtBQUM3QixZQUFBLGNBQWUsS0FBSyxhQUFhO0FBQ3ZDLG9CQUFjLGNBQWMsS0FBTSxRQUFRLENBQUMsV0FBQTtBQUFBOztBQUtyQyxZQUFBLE1BQU0sYUFBYSxXQUFXLEdBQUc7QUFBQSxhQUdsQztBQUNGLFVBQUEsbUJBQW1CLG1CQUFpQjtBQUN0QyxxQkFBQSxHQUFBLGlCQUFpQixzQkFBc0I7QUFBQSxNQUVoQyxXQUFBLG1CQUFtQix3QkFBc0I7QUFDaEQscUJBQUEsR0FBQSxpQkFBaUIsb0JBQW9CO0FBQUEsTUFFOUIsV0FBQSxtQkFBbUIsdUJBQXFCO0FBQy9DLHFCQUFBLEdBQUEsaUJBQWlCLHNEQUFzRDtBQUMxRCxlQUFBLE1BQUEsZUFBZSxJQUFJO0FBQUEsaUJBRXpCLFdBQVM7d0JBQ2hCLGlCQUFjO0FBQUEsRUFBNEQsUUFBUSxTQUFRO0FBQUEsTUFFbkYsV0FBQSxtQkFBbUIscUJBQW1CO3dCQUM3QyxpQkFBYztBQUFBLEVBQWtELFFBQVEsU0FBTztBQUFBO0FBRy9FLHFCQUFBLEdBQUEsNENBQTRDLFFBQVEsU0FBUyxRQUFRLFNBQU87QUFBQTthQUl0RSxLQUFJO0FBQUE7UUFJVDtBQUFXLGdCQUFVLElBQUk7V0FHckIsS0FBSTtBQUFBOztBQWtGRyxrQkFBVyxLQUFBOzs7O0FBY1QsUUFBQSxPQUFBLEdBQUEsVUFBQSxTQUFTLE9BQUssS0FBQSxHQUFBO0FBQWQsZUFBUyxRQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbk1uQixNQUFBLFNBQVMsR0FBRyxVQUFVLGlCQUFpQjtBQUN2QyxNQUFBLGNBQWMsR0FBRyxVQUFVLGVBQWU7QUFLaEQsU0FBUyxPQUFPLFFBQXNCO0FBRTVDLFVBQVEsSUFBSSxNQUFNO0FBRWxCLGVBQWEsT0FBTyxHQUFHLE1BQU0sQ0FBQSxHQUFJO0FBQUEsSUFDaEMsR0FBRyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7QUFBQSxFQUN0QixDQUFBLENBQUM7QUFDSDs7OztrQkNMc0M7Ozs7Ozs7QUFBdEMsYUFBb0QsUUFBQSxLQUFBLE1BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29EQ21CL0IsR0FBRSxFQUFBLENBQUE7Ozs7O2dCQWVDLGFBQWE7QUFBQSxNQUFXLE9BQUEsRUFBQSxTQUFRLFNBQVE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFUL0QsYUFHSyxRQUFBLE1BQUEsTUFBQTs7QUFFTCxhQUVHLFFBQUFRLElBQUEsTUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
