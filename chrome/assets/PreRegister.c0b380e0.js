var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { S as SvelteComponent, i as init, s as safe_not_equal, h as element, M as set_style, j as insert, x as noop, l as detach, N as create_slot, g as space, w as attr, O as toggle_class, Q as append, R as listen, T as update_slot_base, U as get_all_dirty_from_scope, Y as get_slot_changes, t as transition_in, Z as group_outros, a as transition_out, _ as check_outros, $ as run_all, b as component_subscribe, a0 as yw_nav_visible, a1 as yw_blur, a2 as compute_slots, a3 as getContext, a4 as createEventDispatcher, a5 as onMount, r as set_store_value, a6 as bubble, e as binding_callbacks, a7 as src_url_equal, v as text, a8 as set_data, a9 as create_out_transition, aa as yw_search, ab as yw_cancel_search, ac as yw_thread, ad as yw_menu_vendor, ae as yw_overlay_network, af as yw_chain, ag as yw_chain_ref, ah as yw_overlay_account, ai as yw_account, y as yw_account_ref, aj as empty, ak as assign, al as PfpDisplay, c as create_component, m as mount_component, am as get_spread_update, an as get_spread_object, d as destroy_component, f as bind, k as add_flush_callback, ao as Close, ap as set_input_value, D as qs, aq as handle_promise, ar as Chains, as as update_await_block_branch, u as Accounts, at as destroy_each, au as Row, A as ActionsLine, av as acceptable, aw as Field, ax as NL_PASSPHRASE_MINIMUM, ay as NL_PASSPHRASE_MAXIMUM, V as Vault, az as ATU8_DUMMY_PHRASE, aA as ATU8_DUMMY_VECTOR, J as register$1, aB as AlreadyRegisteredError, aC as InvalidPassphraseError, K as login, aD as add_render_callback, aE as create_bidirectional_transition, aF as slide, aG as yw_owner, aH as load_pfps, I as ode, aI as Entities, aJ as StarSelect, aK as yw_network_active, aL as BigNumber, aM as XT_MINUTES, aN as CoinGecko, aO as format_amount, aP as oderac, aQ as yw_family, aR as subscribe_store, aS as onDestroy, aT as Agents, aU as Address, aV as Select, H as yw_navigator, E as Events, aW as format_fiat, aX as SX_ICON_DROPDOWN, aY as fold, C as CheckboxField, aZ as Portrait, a_ as oderom, a$ as syserr, b0 as popup_receive, B as open_external_link, b1 as forever, b2 as Info, b3 as SubHeader, b4 as setContext, b5 as afterUpdate, b6 as writable, b7 as tick, b8 as Pfps, L as F_NOOP, b9 as ofe, ba as ContactAgentType, bb as R_BECH32, bc as InlineTags, bd as proper, be as SX_ICON_EDIT, bf as SX_ICON_DELETE, bg as quintOut, bh as Apps, bi as Networks, F as global_receive, bj as TxnList, bk as svg_element, bl as yw_overscroll_pct, bm as yw_popup, bn as yw_page, bo as yw_menu_expanded, bp as yw_notifications, bq as yw_nav_collapsed, br as HtmlTag, bs as yw_header_props, bt as yw_progress, bu as SX_ICON_CLOSE, bv as logout, z as SI_VERSION, bw as yw_network, bx as dd, by as objects_might_differ, bz as getAllContexts, bA as yw_network_ref, bB as once_store_updates, bC as timeout, bD as UnregisteredError, bE as RecoverableVaultError, bF as CorruptedVaultError } from "./web-resource-cache.e17ad5a9.js";
const p = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p();
var global = "";
function create_fragment$M(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      set_style(span, "display", "none");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
class Blank extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$M, safe_not_equal, {});
  }
}
const get_help_slot_changes = (dirty) => ({});
const get_help_slot_context = (ctx) => ({});
function create_if_block$j(ctx) {
  let div;
  let current;
  const help_slot_template = ctx[21].help;
  const help_slot = create_slot(help_slot_template, ctx, ctx[20], get_help_slot_context);
  return {
    c() {
      div = element("div");
      if (help_slot)
        help_slot.c();
      attr(div, "class", "display_none");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (help_slot) {
        help_slot.m(div, null);
      }
      ctx[23](div);
      current = true;
    },
    p(ctx2, dirty) {
      if (help_slot) {
        if (help_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            help_slot,
            help_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(help_slot_template, ctx2[20], dirty, get_help_slot_changes),
            get_help_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(help_slot, local);
      current = true;
    },
    o(local) {
      transition_out(help_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (help_slot)
        help_slot.d(detaching);
      ctx[23](null);
    }
  };
}
function create_fragment$L(ctx) {
  let div;
  let form_1;
  let t;
  let form_1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[21].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[20], null);
  let if_block = "help" in ctx[10] && create_if_block$j(ctx);
  return {
    c() {
      div = element("div");
      form_1 = element("form");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(form_1, "class", form_1_class_value = "screen " + ctx[1] + " svelte-re7ihy");
      attr(form_1, "data-s2-exit", ctx[9]);
      attr(form_1, "style", ctx[3]);
      attr(form_1, "autocomplete", "off");
      toggle_class(form_1, "flex", true);
      toggle_class(form_1, "scroll", true);
      toggle_class(form_1, "nav", ctx[7]);
      toggle_class(form_1, "progress", ctx[0]);
      toggle_class(form_1, "transparent", ctx[2]);
      toggle_class(form_1, "sublimate", false);
      toggle_class(form_1, "blur", ctx[6]);
      attr(div, "class", "bounds svelte-re7ihy");
      toggle_class(div, "slides", ctx[8]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, form_1);
      if (default_slot) {
        default_slot.m(form_1, null);
      }
      append(form_1, t);
      if (if_block)
        if_block.m(form_1, null);
      ctx[24](form_1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(form_1, "submit", submit_handler_1),
          listen(form_1, "submit", ctx[22])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[20],
            !current ? get_all_dirty_from_scope(ctx2[20]) : get_slot_changes(default_slot_template, ctx2[20], dirty, null),
            null
          );
        }
      }
      if ("help" in ctx2[10]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$j(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(form_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 2 && form_1_class_value !== (form_1_class_value = "screen " + ctx2[1] + " svelte-re7ihy")) {
        attr(form_1, "class", form_1_class_value);
      }
      if (!current || dirty & 8) {
        attr(form_1, "style", ctx2[3]);
      }
      if (dirty & 2) {
        toggle_class(form_1, "flex", true);
      }
      if (dirty & 2) {
        toggle_class(form_1, "scroll", true);
      }
      if (dirty & 130) {
        toggle_class(form_1, "nav", ctx2[7]);
      }
      if (dirty & 3) {
        toggle_class(form_1, "progress", ctx2[0]);
      }
      if (dirty & 6) {
        toggle_class(form_1, "transparent", ctx2[2]);
      }
      if (dirty & 2) {
        toggle_class(form_1, "sublimate", false);
      }
      if (dirty & 66) {
        toggle_class(form_1, "blur", ctx2[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const submit_handler_1 = (d_event) => void d_event.preventDefault();
function instance$I($$self, $$props, $$invalidate) {
  let $yw_nav_visible;
  let $yw_blur;
  component_subscribe($$self, yw_nav_visible, ($$value) => $$invalidate(25, $yw_nav_visible = $$value));
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(6, $yw_blur = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { nav = false } = $$props;
  const b_nav = nav;
  let { debug = "" } = $$props;
  let { progress = null } = $$props;
  let { full = false } = $$props;
  let { keyed = false } = $$props;
  let { classNames = "" } = $$props;
  const k_page = getContext("page");
  let { leaves = false } = $$props;
  let { swipes = false } = $$props;
  let { root = 0 === k_page.index } = $$props;
  let { slides = !leaves && !swipes && !root } = $$props;
  const b_slides = slides;
  let { form = false } = $$props;
  let { transparent = false } = $$props;
  let dm_screen;
  let dm_help = null;
  const si_exit = leaves ? "leaves" : swipes ? "swipes" : "";
  createEventDispatcher();
  onMount(() => {
    if (!k_page) {
      console.warn(`${debug || "unknown"} Screen missing page context`);
    } else {
      k_page.on({
        focus() {
          set_store_value(yw_nav_visible, $yw_nav_visible = b_nav, $yw_nav_visible);
        }
      });
    }
    if (keyed) {
      let x_scroll_top = 0;
      new MutationObserver(async (a_mutations) => {
        if (a_mutations[0]?.addedNodes.length) {
          try {
            x_scroll_top = dm_screen.scrollTop;
          } catch (e_null) {
          }
        } else if (a_mutations[0]?.removedNodes.length) {
          if (dm_screen) {
            $$invalidate(4, dm_screen.scrollTop = x_scroll_top, dm_screen);
          }
        }
      }).observe(dm_screen, { childList: true });
    }
  });
  let { style = "" } = $$props;
  function submit_handler2(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_help = $$value;
      $$invalidate(5, dm_help);
    });
  }
  function form_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_screen = $$value;
      $$invalidate(4, dm_screen);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("nav" in $$props2)
      $$invalidate(11, nav = $$props2.nav);
    if ("debug" in $$props2)
      $$invalidate(12, debug = $$props2.debug);
    if ("progress" in $$props2)
      $$invalidate(0, progress = $$props2.progress);
    if ("full" in $$props2)
      $$invalidate(13, full = $$props2.full);
    if ("keyed" in $$props2)
      $$invalidate(14, keyed = $$props2.keyed);
    if ("classNames" in $$props2)
      $$invalidate(1, classNames = $$props2.classNames);
    if ("leaves" in $$props2)
      $$invalidate(15, leaves = $$props2.leaves);
    if ("swipes" in $$props2)
      $$invalidate(16, swipes = $$props2.swipes);
    if ("root" in $$props2)
      $$invalidate(17, root = $$props2.root);
    if ("slides" in $$props2)
      $$invalidate(18, slides = $$props2.slides);
    if ("form" in $$props2)
      $$invalidate(19, form = $$props2.form);
    if ("transparent" in $$props2)
      $$invalidate(2, transparent = $$props2.transparent);
    if ("style" in $$props2)
      $$invalidate(3, style = $$props2.style);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  return [
    progress,
    classNames,
    transparent,
    style,
    dm_screen,
    dm_help,
    $yw_blur,
    b_nav,
    b_slides,
    si_exit,
    $$slots,
    nav,
    debug,
    full,
    keyed,
    leaves,
    swipes,
    root,
    slides,
    form,
    $$scope,
    slots,
    submit_handler2,
    div_binding,
    form_1_binding
  ];
}
class Screen extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$L, safe_not_equal, {
      nav: 11,
      debug: 12,
      progress: 0,
      full: 13,
      keyed: 14,
      classNames: 1,
      leaves: 15,
      swipes: 16,
      root: 17,
      slides: 18,
      form: 19,
      transparent: 2,
      style: 3
    });
  }
}
function create_fragment$K(ctx) {
  let picture;
  let source;
  let t;
  let img;
  let img_src_value;
  let mounted;
  let dispose;
  return {
    c() {
      picture = element("picture");
      source = element("source");
      t = space();
      img = element("img");
      attr(source, "srcset", ctx[3]);
      attr(source, "media", "(min-resolution: 2dppx)");
      attr(img, "alt", ctx[1]);
      if (!src_url_equal(img.src, img_src_value = ctx[2]))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-5d3u97");
      attr(picture, "class", "no-margin logo svelte-5d3u97");
      set_style(picture, "width", ctx[0] + "px");
      set_style(picture, "height", ctx[0] + "px");
    },
    m(target, anchor) {
      insert(target, picture, anchor);
      append(picture, source);
      append(picture, t);
      append(picture, img);
      if (!mounted) {
        dispose = listen(picture, "click", ctx[6]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(picture);
      mounted = false;
      dispose();
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  let { dim } = $$props;
  const x_dim = dim;
  let { alt = "StarShell logo" } = $$props;
  const s_alt = alt;
  const f_src = (x) => `/media/vendor/logo-${x}px.png`;
  const sr_default = f_src(x_dim);
  const sr_double = f_src(x_dim * 2);
  function click_handler2(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("dim" in $$props2)
      $$invalidate(4, dim = $$props2.dim);
    if ("alt" in $$props2)
      $$invalidate(5, alt = $$props2.alt);
  };
  return [x_dim, s_alt, sr_default, sr_double, dim, alt, click_handler2];
}
class StarShellLogo extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$K, safe_not_equal, { dim: 4, alt: 5 });
  }
}
const get_rows_slot_changes = (dirty) => ({});
const get_rows_slot_context = (ctx) => ({});
function create_fragment$J(ctx) {
  let div3;
  let div2;
  let div0;
  let h3;
  let t0;
  let t1;
  let div1;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  const rows_slot_template = ctx[4].rows;
  const rows_slot = create_slot(rows_slot_template, ctx, ctx[3], get_rows_slot_context);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(ctx[1]);
      t1 = space();
      div1 = element("div");
      if (rows_slot)
        rows_slot.c();
      attr(h3, "class", "svelte-1f5uzt4");
      attr(div0, "class", "top svelte-1f5uzt4");
      attr(div1, "class", "rows svelte-1f5uzt4");
      attr(div2, "class", "overlay select svelte-1f5uzt4");
      attr(div3, "class", "cancel svelte-1f5uzt4");
      toggle_class(div3, "showing", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div0);
      append(div0, h3);
      append(h3, t0);
      append(div2, t1);
      append(div2, div1);
      if (rows_slot) {
        rows_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div3, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 2)
        set_data(t0, ctx2[1]);
      if (rows_slot) {
        if (rows_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            rows_slot,
            rows_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(rows_slot_template, ctx2[3], dirty, get_rows_slot_changes),
            get_rows_slot_context
          );
        }
      }
      if (dirty & 4) {
        toggle_class(div3, "showing", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(rows_slot, local);
      if (div2_outro)
        div2_outro.end(1);
      current = true;
    },
    o(local) {
      transition_out(rows_slot, local);
      div2_outro = create_out_transition(div2, pause, {});
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (rows_slot)
        rows_slot.d(detaching);
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function pause(dm, gc) {
  return { duration: 200 };
}
function instance$G($$self, $$props, $$invalidate) {
  let $yw_blur;
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(6, $yw_blur = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { title } = $$props;
  let { open = true } = $$props;
  let b_showing = false;
  setTimeout(
    () => {
      $$invalidate(2, b_showing = true);
    },
    10
  );
  const click_handler2 = () => {
    $$invalidate(2, b_showing = false);
    $$invalidate(0, open = false);
  };
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      set_store_value(yw_blur, $yw_blur = open, $yw_blur);
    }
  };
  return [open, title, b_showing, $$scope, slots, click_handler2];
}
class OverlaySelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$J, safe_not_equal, { title: 1, open: 0 });
  }
}
var SX_ICON_ARROW_LEFT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-arrow-left-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-arrow-left-fg" d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"/>\n</svg>\n';
var SX_ICON_SEARCH = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-search-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-search-fg" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n</svg>\n';
var SX_CHECKED = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">\n	<style type="text/css">\n		.s2r-checked-circle-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n		.s2r-checked-circle-bg {\n			fill: var(--svg-color-bg, black);\n		}\n	</style>\n	<circle class="s2r-checked-circle-bg" cx="10" cy="10" r="8" />\n	<path class="s2r-checked-circle-fg" d="M10.0003 1.6665C5.40033 1.6665 1.66699 5.39984 1.66699 9.99984C1.66699 14.5998 5.40033 18.3332 10.0003 18.3332C14.6003 18.3332 18.3337 14.5998 18.3337 9.99984C18.3337 5.39984 14.6003 1.6665 10.0003 1.6665ZM8.33366 14.1665L4.16699 9.99984L5.34199 8.82484L8.33366 11.8082L14.6587 5.48317L15.8337 6.6665L8.33366 14.1665Z" />\n</svg>\n';
function get_each_context$9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i][0];
  child_ctx[51] = list[i][1];
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[55] = list[i][0];
  child_ctx[56] = list[i][1];
  return child_ctx;
}
function create_if_block_11(ctx) {
  let starshelllogo;
  let current;
  starshelllogo = new StarShellLogo({
    props: {
      dim: 48,
      alt: "Click to view general status"
    }
  });
  starshelllogo.$on("click", ctx[35]);
  return {
    c() {
      create_component(starshelllogo.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starshelllogo, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starshelllogo, detaching);
    }
  };
}
function create_if_block_10(ctx) {
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      attr(span, "class", "back svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_ARROW_LEFT;
      if (!mounted) {
        dispose = listen(span, "click", ctx[34]);
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_8(ctx) {
  let span;
  let t1;
  let if_block_anchor;
  let if_block = ctx[18] && create_if_block_9(ctx);
  return {
    c() {
      span = element("span");
      span.textContent = `${ctx[17]}`;
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "name svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[18])
        if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_9(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `- ${ctx[18]}`;
      attr(span, "class", "symbol svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_5$1(ctx) {
  let span;
  let previous_key = ctx[6];
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block_1$1(ctx);
  let if_block = ctx[5] && create_if_block_6(ctx);
  return {
    c() {
      span = element("span");
      key_block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "network svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      key_block.m(span, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[36]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 64 && safe_not_equal(previous_key, previous_key = ctx2[6])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block_1$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(span, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      key_block.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block_1$1(ctx) {
  let pfpdisplay;
  let current;
  const pfpdisplay_spread_levels = [{ resource: ctx[6] }, ctx[21](false)];
  let pfpdisplay_props = {};
  for (let i = 0; i < pfpdisplay_spread_levels.length; i += 1) {
    pfpdisplay_props = assign(pfpdisplay_props, pfpdisplay_spread_levels[i]);
  }
  pfpdisplay = new PfpDisplay({ props: pfpdisplay_props });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = dirty[0] & 2097216 ? get_spread_update(pfpdisplay_spread_levels, [
        dirty[0] & 64 && { resource: ctx2[6] },
        dirty[0] & 2097152 && get_spread_object(ctx2[21](false))
      ]) : {};
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let overlayselect;
  let updating_open;
  let current;
  function overlayselect_open_binding(value) {
    ctx[38](value);
  }
  let overlayselect_props = {
    title: "Switch Network",
    $$slots: { rows: [create_rows_slot_1] },
    $$scope: { ctx }
  };
  if (ctx[5] !== void 0) {
    overlayselect_props.open = ctx[5];
  }
  overlayselect = new OverlaySelect({ props: overlayselect_props });
  binding_callbacks.push(() => bind(overlayselect, "open", overlayselect_open_binding));
  return {
    c() {
      create_component(overlayselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayselect_changes = {};
      if (dirty[0] & 160 | dirty[1] & 268435456) {
        overlayselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty[0] & 32) {
        updating_open = true;
        overlayselect_changes.open = ctx2[5];
        add_flush_callback(() => updating_open = false);
      }
      overlayselect.$set(overlayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayselect, detaching);
    }
  };
}
function create_catch_block_1$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[54].entries();
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 160) {
        each_value_1 = ctx2[54].entries();
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_7(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "overlay-select icon svelte-1fcz7ql");
      set_style(span, "--icon-color", "var(--theme-color-primary)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_CHECKED;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_right_slot_1(ctx) {
  let t;
  let if_block = ctx[7] === ctx[55] && create_if_block_7();
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[7] === ctx2[55]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_7();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block_1$3(ctx) {
  let row;
  let current;
  function click_handler_3() {
    return ctx[37](ctx[55]);
  }
  row = new Row({
    props: {
      resource: ctx[56],
      detail: "Default Provider",
      $$slots: { right: [create_right_slot_1] },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_3);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 128 | dirty[1] & 268435456) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block_1$1(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_rows_slot_1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1$1,
    then: create_then_block_1$1,
    catch: create_catch_block_1$1,
    value: 54,
    blocks: [, , ,]
  };
  handle_promise(Chains.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block_2$5(ctx) {
  let span;
  let previous_key = ctx[9];
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let key_block = create_key_block$3(ctx);
  let if_block = ctx[8] && create_if_block_3$2(ctx);
  return {
    c() {
      span = element("span");
      key_block.c();
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span, "class", "account svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      key_block.m(span, null);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[39]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 512 && safe_not_equal(previous_key, previous_key = ctx2[9])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$3(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(span, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      key_block.d(detaching);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block$3(ctx) {
  let pfpdisplay;
  let current;
  const pfpdisplay_spread_levels = [{ resource: ctx[9] }, ctx[21](true)];
  let pfpdisplay_props = {};
  for (let i = 0; i < pfpdisplay_spread_levels.length; i += 1) {
    pfpdisplay_props = assign(pfpdisplay_props, pfpdisplay_spread_levels[i]);
  }
  pfpdisplay = new PfpDisplay({ props: pfpdisplay_props });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = dirty[0] & 2097664 ? get_spread_update(pfpdisplay_spread_levels, [
        dirty[0] & 512 && { resource: ctx2[9] },
        dirty[0] & 2097152 && get_spread_object(ctx2[21](true))
      ]) : {};
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_if_block_3$2(ctx) {
  let overlayselect;
  let updating_open;
  let current;
  function overlayselect_open_binding_1(value) {
    ctx[41](value);
  }
  let overlayselect_props = {
    title: "Switch Account",
    $$slots: { rows: [create_rows_slot] },
    $$scope: { ctx }
  };
  if (ctx[8] !== void 0) {
    overlayselect_props.open = ctx[8];
  }
  overlayselect = new OverlaySelect({ props: overlayselect_props });
  binding_callbacks.push(() => bind(overlayselect, "open", overlayselect_open_binding_1));
  return {
    c() {
      create_component(overlayselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overlayselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const overlayselect_changes = {};
      if (dirty[0] & 1280 | dirty[1] & 268435456) {
        overlayselect_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty[0] & 256) {
        updating_open = true;
        overlayselect_changes.open = ctx2[8];
        add_flush_callback(() => updating_open = false);
      }
      overlayselect.$set(overlayselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(overlayselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overlayselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overlayselect, detaching);
    }
  };
}
function create_catch_block$c(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$c(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[49].entries();
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1280) {
        each_value = ctx2[49].entries();
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_4$1(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "overlay-select icon svelte-1fcz7ql");
      set_style(span, "--icon-color", "var(--theme-color-primary)");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_CHECKED;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_right_slot(ctx) {
  let t;
  let if_block = ctx[10] === ctx[50] && create_if_block_4$1();
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (ctx2[10] === ctx2[50]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$1();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_icon_slot(ctx) {
  let pfpdisplay;
  let t;
  let current;
  pfpdisplay = new PfpDisplay({
    props: { dim: 32, resource: ctx[51] }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block$9(ctx) {
  let row;
  let current;
  function click_handler_5() {
    return ctx[40](ctx[50]);
  }
  row = new Row({
    props: {
      resource: ctx[51],
      resourcePath: ctx[50],
      detail: ctx[51].extra?.total_fiat_cache ?? "(?)",
      $$slots: {
        icon: [create_icon_slot],
        right: [create_right_slot]
      },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_5);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 1024 | dirty[1] & 268435456) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$c(ctx) {
  let t;
  return {
    c() {
      t = text("...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_rows_slot(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$c,
    then: create_then_block$c,
    catch: create_catch_block$c,
    value: 49,
    blocks: [, , ,]
  };
  handle_promise(Accounts.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_if_block_1$a(ctx) {
  let close;
  let current;
  close = new Close({});
  close.$on("click", ctx[42]);
  return {
    c() {
      create_component(close.$$.fragment);
    },
    m(target, anchor) {
      mount_component(close, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(close.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(close.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(close, detaching);
    }
  };
}
function create_if_block$i(ctx) {
  let div;
  let input;
  let t;
  let span;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t = space();
      span = element("span");
      attr(input, "type", "text");
      input.autofocus = ctx[0];
      attr(input, "placeholder", "Search anything: token, account, contact, txn...");
      attr(span, "class", "action svelte-1fcz7ql");
      attr(div, "class", "search svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[3]);
      ctx[44](input);
      append(div, t);
      append(div, span);
      span.innerHTML = SX_ICON_SEARCH;
      if (ctx[0])
        input.focus();
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[43]),
          listen(input, "input", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1) {
        input.autofocus = ctx2[0];
      }
      if (dirty[0] & 8 && input.value !== ctx2[3]) {
        set_input_value(input, ctx2[3]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[44](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$I(ctx) {
  let div3;
  let div2;
  let current_block_type_index;
  let if_block0;
  let t0;
  let span0;
  let div0;
  let t1;
  let div1;
  let t3;
  let span2;
  let span1;
  let t4;
  let t5;
  let t6;
  let current;
  const if_block_creators = [create_if_block_10, create_if_block_11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[11])
      return 0;
    if (!ctx2[12] && !ctx2[13])
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = ctx[17] && create_if_block_8(ctx);
  let if_block2 = ctx[15] && create_if_block_5$1(ctx);
  let if_block3 = ctx[14] && create_if_block_2$5(ctx);
  let if_block4 = ctx[12] && create_if_block_1$a(ctx);
  let if_block5 = ctx[16] && create_if_block$i(ctx);
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span0 = element("span");
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      div1.textContent = `${ctx[19]}`;
      t3 = space();
      span2 = element("span");
      span1 = element("span");
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      if (if_block5)
        if_block5.c();
      attr(div0, "class", "title svelte-1fcz7ql");
      attr(div1, "class", "subtitle svelte-1fcz7ql");
      attr(span0, "class", "main svelte-1fcz7ql");
      attr(span1, "class", "cluster svelte-1fcz7ql");
      attr(span2, "class", "right svelte-1fcz7ql");
      toggle_class(span2, "heightless", !ctx[15] && ctx[12]);
      attr(div2, "class", "top svelte-1fcz7ql");
      attr(div3, "class", "header svelte-1fcz7ql");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      append(div2, t0);
      append(div2, span0);
      append(span0, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append(span0, t1);
      append(span0, div1);
      append(div2, t3);
      append(div2, span2);
      append(span2, span1);
      if (if_block2)
        if_block2.m(span1, null);
      append(span1, t4);
      if (if_block3)
        if_block3.m(span1, null);
      append(span2, t5);
      if (if_block4)
        if_block4.m(span2, null);
      append(div3, t6);
      if (if_block5)
        if_block5.m(div3, null);
      ctx[45](div3);
      current = true;
    },
    p(ctx2, dirty) {
      if (if_block0)
        if_block0.p(ctx2, dirty);
      if (ctx2[17])
        if_block1.p(ctx2, dirty);
      if (ctx2[15])
        if_block2.p(ctx2, dirty);
      if (ctx2[14])
        if_block3.p(ctx2, dirty);
      if (ctx2[12])
        if_block4.p(ctx2, dirty);
      if (ctx2[16])
        if_block5.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      ctx[45](null);
    }
  };
}
function instance$F($$self, $$props, $$invalidate) {
  let $yw_search;
  let $yw_cancel_search;
  let $yw_thread;
  let $yw_menu_vendor;
  let $yw_overlay_network;
  let $yw_chain;
  let $yw_chain_ref;
  let $yw_overlay_account;
  let $yw_account;
  let $yw_account_ref;
  component_subscribe($$self, yw_search, ($$value) => $$invalidate(46, $yw_search = $$value));
  component_subscribe($$self, yw_cancel_search, ($$value) => $$invalidate(47, $yw_cancel_search = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(48, $yw_thread = $$value));
  component_subscribe($$self, yw_menu_vendor, ($$value) => $$invalidate(4, $yw_menu_vendor = $$value));
  component_subscribe($$self, yw_overlay_network, ($$value) => $$invalidate(5, $yw_overlay_network = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(6, $yw_chain = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(7, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_overlay_account, ($$value) => $$invalidate(8, $yw_overlay_account = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(9, $yw_account = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(10, $yw_account_ref = $$value));
  let { pops = false } = $$props;
  const b_pops = pops;
  let { exits = false } = $$props;
  const b_exits = exits;
  let { plain = false } = $$props;
  const b_plain = plain;
  let { account = false } = $$props;
  const b_account = account;
  let { network = false } = $$props;
  const b_network = network;
  let { search: search2 = false } = $$props;
  const b_search = search2;
  let { title = "" } = $$props;
  const s_title = title;
  let { symbol = "" } = $$props;
  const s_symbol = symbol;
  let { subtitle = "" } = $$props;
  const s_subtitle = subtitle;
  const dispatch = createEventDispatcher();
  const overlay_pfp_props = (b_mirror = false) => ({
    dim: 21,
    bg: "satin",
    genStyle: "font-size:21px; outline:none;",
    rootStyle: `
			padding: 5px 6px;
			border: 2px solid var(--theme-color-border);
			border-radius: ${b_mirror ? "0 4px 4px 0" : "4px 0 0 4px"};
		`.replace(/\s+/g, " ")
  });
  const k_page = getContext("page");
  let dm_header;
  let dm_search;
  let { isSearchScreen = false } = $$props;
  let { search_input = "" } = $$props;
  let s_search = $yw_search;
  yw_search.subscribe((s_value) => {
    if (isSearchScreen && s_value) {
      console.log("search screen and search text");
      $$invalidate(3, s_search = s_value);
      if (dm_search) {
        setTimeout(
          () => {
            dm_search.focus();
          },
          0
        );
      }
    } else if (!s_value) {
      $$invalidate(3, s_search = "");
    }
  });
  function update_search(d_event) {
    if (isSearchScreen) {
      if (!s_search) {
        set_store_value(yw_search, $yw_search = "", $yw_search);
        $yw_cancel_search();
      } else {
        dispatch("search", s_search);
      }
    } else if (s_search) {
      $yw_thread.id;
      const dm_focus = qs(dm_header, ":focus");
      if (dm_focus) {
        dm_focus.blur();
      }
      set_store_value(
        yw_cancel_search,
        $yw_cancel_search = () => {
          $$invalidate(3, s_search = "");
          console.log("stealing focus for cancel search");
          dm_search.focus();
        },
        $yw_cancel_search
      );
      set_store_value(yw_search, $yw_search = s_search, $yw_search);
    }
  }
  const click_handler2 = () => k_page.pop();
  const click_handler_1 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = true, $yw_menu_vendor);
  const click_handler_2 = (d_event) => {
    d_event.stopPropagation();
    set_store_value(yw_overlay_network, $yw_overlay_network = !$yw_overlay_network, $yw_overlay_network);
  };
  const click_handler_3 = (p_chain) => {
    set_store_value(yw_chain_ref, $yw_chain_ref = p_chain, $yw_chain_ref);
    set_store_value(yw_overlay_network, $yw_overlay_network = false, $yw_overlay_network);
  };
  function overlayselect_open_binding(value) {
    $yw_overlay_network = value;
    yw_overlay_network.set($yw_overlay_network);
  }
  const click_handler_4 = (d_event) => {
    d_event.stopPropagation();
    set_store_value(yw_overlay_account, $yw_overlay_account = !$yw_overlay_account, $yw_overlay_account);
  };
  const click_handler_5 = (p_account) => {
    set_store_value(yw_account_ref, $yw_account_ref = p_account, $yw_account_ref);
    set_store_value(yw_overlay_account, $yw_overlay_account = false, $yw_overlay_account);
  };
  function overlayselect_open_binding_1(value) {
    $yw_overlay_account = value;
    yw_overlay_account.set($yw_overlay_account);
  }
  const click_handler_6 = () => dispatch("close");
  function input_input_handler() {
    s_search = this.value;
    $$invalidate(3, s_search);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_search = $$value;
      $$invalidate(2, dm_search);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_header = $$value;
      $$invalidate(1, dm_header);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("pops" in $$props2)
      $$invalidate(24, pops = $$props2.pops);
    if ("exits" in $$props2)
      $$invalidate(25, exits = $$props2.exits);
    if ("plain" in $$props2)
      $$invalidate(26, plain = $$props2.plain);
    if ("account" in $$props2)
      $$invalidate(27, account = $$props2.account);
    if ("network" in $$props2)
      $$invalidate(28, network = $$props2.network);
    if ("search" in $$props2)
      $$invalidate(29, search2 = $$props2.search);
    if ("title" in $$props2)
      $$invalidate(30, title = $$props2.title);
    if ("symbol" in $$props2)
      $$invalidate(31, symbol = $$props2.symbol);
    if ("subtitle" in $$props2)
      $$invalidate(32, subtitle = $$props2.subtitle);
    if ("isSearchScreen" in $$props2)
      $$invalidate(0, isSearchScreen = $$props2.isSearchScreen);
    if ("search_input" in $$props2)
      $$invalidate(33, search_input = $$props2.search_input);
  };
  return [
    isSearchScreen,
    dm_header,
    dm_search,
    s_search,
    $yw_menu_vendor,
    $yw_overlay_network,
    $yw_chain,
    $yw_chain_ref,
    $yw_overlay_account,
    $yw_account,
    $yw_account_ref,
    b_pops,
    b_exits,
    b_plain,
    b_account,
    b_network,
    b_search,
    s_title,
    s_symbol,
    s_subtitle,
    dispatch,
    overlay_pfp_props,
    k_page,
    update_search,
    pops,
    exits,
    plain,
    account,
    network,
    search2,
    title,
    symbol,
    subtitle,
    search_input,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    overlayselect_open_binding,
    click_handler_4,
    click_handler_5,
    overlayselect_open_binding_1,
    click_handler_6,
    input_input_handler,
    input_binding,
    div3_binding
  ];
}
class Header extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$F,
      create_fragment$I,
      safe_not_equal,
      {
        pops: 24,
        exits: 25,
        plain: 26,
        account: 27,
        network: 28,
        search: 29,
        title: 30,
        symbol: 31,
        subtitle: 32,
        isSearchScreen: 0,
        search_input: 33
      },
      null,
      [-1, -1]
    );
  }
}
function get_each_context$8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_if_block_1$9(ctx) {
  let span2;
  let span0;
  let t0;
  let t1_value = format_ms(ctx[2].value.offset) + "";
  let t1;
  let t2;
  let t3;
  let span1;
  let t4_value = ctx[2].value.message + "";
  let t4;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = text("+");
      t1 = text(t1_value);
      t2 = text("ms:");
      t3 = space();
      span1 = element("span");
      t4 = text(t4_value);
      attr(span0, "class", "offset");
      attr(span1, "class", "message");
      attr(span2, "class", "event");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span0, t0);
      append(span0, t1);
      append(span0, t2);
      append(span2, t3);
      append(span2, span1);
      append(span1, t4);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t1_value !== (t1_value = format_ms(ctx2[2].value.offset) + ""))
        set_data(t1, t1_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx2[2].value.message + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching)
        detach(span2);
    }
  };
}
function create_if_block$h(ctx) {
  let span;
  let t_value = ctx[2].value + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "string");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[2].value + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_each_block$8(ctx) {
  let li;
  let t;
  function select_block_type(ctx2, dirty) {
    if ("string" === ctx2[2].type)
      return create_if_block$h;
    if ("event" === ctx2[2].type)
      return create_if_block_1$9;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      li = element("li");
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (if_block)
        if_block.m(li, null);
      append(li, t);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(li, t);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (if_block) {
        if_block.d();
      }
    }
  };
}
function create_fragment$H(ctx) {
  let div;
  let ol;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "log-container svelte-13jddbg");
      toggle_class(div, "display_none", ctx[1]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ol, null);
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ol, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        toggle_class(div, "display_none", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
class Logger {
  constructor() {
    this._a_items = [];
  }
  get items() {
    return this._a_items;
  }
  set items(a_items) {
    this._a_items = a_items;
  }
  event(s_msg, xt_offset) {
    this._a_items.push({
      type: "event",
      value: { message: s_msg, offset: xt_offset }
    });
    return this;
  }
}
function format_ms(n_ms) {
  return (n_ms / 1e3).toFixed(2).padStart(5, "0");
}
function instance$E($$self, $$props, $$invalidate) {
  let { items } = $$props;
  let { hide = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("hide" in $$props2)
      $$invalidate(1, hide = $$props2.hide);
  };
  return [items, hide];
}
class Log extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$H, safe_not_equal, { items: 0, hide: 1 });
  }
}
function create_fragment$G(ctx) {
  let div;
  let img;
  let img_src_value;
  return {
    c() {
      div = element("div");
      img = element("img");
      attr(img, "alt", "StarShell title");
      if (!src_url_equal(img.src, img_src_value = "/media/vendor/title.svg"))
        attr(img, "src", img_src_value);
      attr(img, "class", "svelte-1htd4i8");
      attr(div, "class", "no-margin title svelte-1htd4i8");
      set_style(div, "width", ctx[0] + "px");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  let { width = 180 } = $$props;
  const x_width = width;
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
  };
  return [x_width, width];
}
class StarShellTitle extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$G, safe_not_equal, { width: 1 });
  }
}
function create_default_slot$j(ctx) {
  let h3;
  let t1;
  let p0;
  let t3;
  let p1;
  let t5;
  let p2;
  let t7;
  let actionsline;
  let current;
  actionsline = new ActionsLine({
    props: {
      cancel: "pop",
      confirm: ["Use anyway", ctx[0]],
      wait: 5e3
    }
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Weak Password Warning";
      t1 = space();
      p0 = element("p");
      p0.textContent = "The password you entered was found on a list of the top ten thousand most commonly used passwords.";
      t3 = space();
      p1 = element("p");
      p1.textContent = "In order to help prevent the loss of funds, you are encouraged to create a strong, unique password.";
      t5 = space();
      p2 = element("p");
      p2.textContent = "How do you want to proceed?";
      t7 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, p0, anchor);
      insert(target, t3, anchor);
      insert(target, p1, anchor);
      insert(target, t5, anchor);
      insert(target, p2, anchor);
      insert(target, t7, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t7);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$F(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 32) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let { attempt_register } = $$props;
  let { weakness } = $$props;
  const k_page = getContext("page");
  function use_anyway() {
    attempt_register();
    k_page.pop();
  }
  $$self.$$set = ($$props2) => {
    if ("attempt_register" in $$props2)
      $$invalidate(1, attempt_register = $$props2.attempt_register);
    if ("weakness" in $$props2)
      $$invalidate(2, weakness = $$props2.weakness);
  };
  return [use_anyway, attempt_register, weakness];
}
class RegisterWeakPassword extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$F, safe_not_equal, { attempt_register: 1, weakness: 2 });
  }
}
function create_if_block_2$4(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[4]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 16)
        set_data(t, ctx2[4]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_2$6(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && ctx[4] && create_if_block_2$4(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "autocomplete", "new-password");
      attr(input, "name", "password");
      attr(input, "placeholder", "Password");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", ctx[10]),
          listen(input, "input", ctx[11])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (!ctx2[2] && ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 20) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$8(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[5]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 32)
        set_data(t, ctx2[5]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_1$8(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[2] && ctx[5] && create_if_block_1$8(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "autocomplete", "new-password");
      attr(input, "name", "verify");
      attr(input, "placeholder", "Password");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "blur", ctx[12]),
          listen(input, "input", ctx[13])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      if (!ctx2[2] && ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 36) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$g(ctx) {
  let pre;
  let t;
  return {
    c() {
      pre = element("pre");
      t = text(ctx[3]);
    },
    m(target, anchor) {
      insert(target, pre, anchor);
      append(pre, t);
    },
    p(ctx2, dirty) {
      if (dirty & 8)
        set_data(t, ctx2[3]);
    },
    d(detaching) {
      if (detaching)
        detach(pre);
    }
  };
}
function create_default_slot$i(ctx) {
  let center;
  let div0;
  let starshelllogo;
  let t0;
  let starshelltitle;
  let t1;
  let p2;
  let t3;
  let div1;
  let input;
  let t4;
  let field0;
  let t5;
  let field1;
  let t6;
  let log_1;
  let updating_items;
  let t7;
  let t8;
  let actionsline;
  let current;
  starshelllogo = new StarShellLogo({ props: { dim: 96 } });
  starshelltitle = new StarShellTitle({ props: { width: 150 } });
  field0 = new Field({
    props: {
      key: "password",
      name: "New password",
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      key: "verify-password",
      name: "Verify password",
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  function log_1_items_binding(value) {
    ctx[14](value);
  }
  let log_1_props = {};
  if (ctx[6].items !== void 0) {
    log_1_props.items = ctx[6].items;
  }
  log_1 = new Log({ props: log_1_props });
  binding_callbacks.push(() => bind(log_1, "items", log_1_items_binding));
  let if_block = ctx[3] && create_if_block$g(ctx);
  actionsline = new ActionsLine({
    props: { confirm: ctx[7] }
  });
  return {
    c() {
      center = element("center");
      div0 = element("div");
      create_component(starshelllogo.$$.fragment);
      t0 = space();
      create_component(starshelltitle.$$.fragment);
      t1 = space();
      p2 = element("p");
      p2.textContent = "Create a new password to protect your wallet's data.";
      t3 = space();
      div1 = element("div");
      input = element("input");
      t4 = space();
      create_component(field0.$$.fragment);
      t5 = space();
      create_component(field1.$$.fragment);
      t6 = space();
      create_component(log_1.$$.fragment);
      t7 = space();
      if (if_block)
        if_block.c();
      t8 = space();
      create_component(actionsline.$$.fragment);
      attr(div0, "class", "intro svelte-pdf2wg");
      attr(p2, "class", "narrow svelte-pdf2wg");
      input.hidden = true;
      attr(input, "type", "text");
      attr(input, "name", "username");
      attr(input, "autocomplete", "username");
      input.value = "StarShell Wallet User";
      attr(div1, "class", "form flex-rows");
    },
    m(target, anchor) {
      insert(target, center, anchor);
      append(center, div0);
      mount_component(starshelllogo, div0, null);
      append(div0, t0);
      mount_component(starshelltitle, div0, null);
      append(center, t1);
      append(center, p2);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      append(div1, input);
      append(div1, t4);
      mount_component(field0, div1, null);
      append(div1, t5);
      mount_component(field1, div1, null);
      insert(target, t6, anchor);
      mount_component(log_1, target, anchor);
      insert(target, t7, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t8, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 8388629) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 8388646) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const log_1_changes = {};
      if (!updating_items && dirty & 64) {
        updating_items = true;
        log_1_changes.items = ctx2[6].items;
        add_flush_callback(() => updating_items = false);
      }
      log_1.$set(log_1_changes);
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$g(ctx2);
          if_block.c();
          if_block.m(t8.parentNode, t8);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const actionsline_changes = {};
      if (dirty & 128)
        actionsline_changes.confirm = ctx2[7];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      transition_in(starshelltitle.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(log_1.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      transition_out(starshelltitle.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(log_1.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(center);
      destroy_component(starshelllogo);
      destroy_component(starshelltitle);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      destroy_component(field0);
      destroy_component(field1);
      if (detaching)
        detach(t6);
      destroy_component(log_1, detaching);
      if (detaching)
        detach(t7);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t8);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$E(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8388863) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let b_password_acceptable;
  let a_confirm_action;
  const k_page = getContext("page");
  const completed = getContext("completed");
  let sh_phrase = "";
  let sh_verify = "";
  let s_error = "";
  let s_err_password = "";
  let s_err_verify = "";
  let xt_start = 0;
  let k_logger = new Logger();
  function log(s_msg) {
    $$invalidate(6, k_logger = k_logger.event(s_msg, Date.now() - xt_start));
  }
  k_page.on({
    restore() {
      $$invalidate(0, sh_phrase = $$invalidate(1, sh_verify = ""));
    }
  });
  function check_password() {
    if (sh_phrase && !acceptable(sh_phrase)) {
      if (sh_phrase.length < NL_PASSPHRASE_MINIMUM) {
        $$invalidate(4, s_err_password = "Password must be at least 5 characters");
      } else if (sh_phrase.length > NL_PASSPHRASE_MAXIMUM) {
        $$invalidate(4, s_err_password = "Password must be 1024 characters or fewer");
      } else {
        $$invalidate(4, s_err_password = "Password is not acceptable");
      }
      return;
    }
    $$invalidate(4, s_err_password = "");
  }
  function check_verify() {
    if (sh_phrase && !s_err_password && sh_phrase !== sh_verify) {
      $$invalidate(5, s_err_verify = "Passwords do not match");
      return;
    }
    $$invalidate(5, s_err_verify = "");
  }
  const dp_passwords = (async () => {
    const d_res = await fetch("/data/passwords-top-10k.txt");
    const s_list = await d_res.text();
    return s_list.split("\n");
  })();
  async function prepare_register() {
    const a_passwords = await dp_passwords;
    if (a_passwords.includes(sh_phrase)) {
      k_page.push({
        creator: RegisterWeakPassword,
        props: { attempt_register }
      });
    } else {
      await attempt_register();
    }
  }
  let b_busy = false;
  async function attempt_register() {
    if (!b_password_acceptable)
      return 1;
    if (b_busy)
      return 1;
    b_busy = true;
    const exit = () => (b_busy = false, 1);
    $$invalidate(3, s_error = "");
    xt_start = Date.now();
    log("Estimating time to complete");
    {
      const xt_start_est = window.performance.now();
      await Vault.deriveRootBits(ATU8_DUMMY_PHRASE, ATU8_DUMMY_VECTOR, 1 / 50);
      const xt_finish_est = window.performance.now();
      const xt_elapsed_est = xt_finish_est - xt_start_est;
      const xt_estimate = 2 * (2 * (xt_elapsed_est * 50));
      log(`About ${(xt_estimate / 1e3).toFixed(1)} seconds`);
    }
    try {
      await register$1(sh_phrase, log);
    } catch (e_register) {
      if (e_register instanceof AlreadyRegisteredError) {
        $$invalidate(3, s_error = "A passphrase is already registered");
      } else if (e_register instanceof InvalidPassphraseError) {
        $$invalidate(3, s_error = "Invalid passphrase");
      } else {
        $$invalidate(3, s_error = `Unexpected error occurred while attempting to register:
${e_register.stack || e_register.message}`);
      }
      return exit();
    }
    log("Verifying passphrase");
    try {
      await login(sh_phrase, false, log);
    } catch (e_login) {
      $$invalidate(3, s_error = "Failed to verify passphrase immediately after registration");
      await Vault.eraseBase();
      return exit();
    }
    log("Done");
    $$invalidate(3, s_error = "Success");
    if (completed)
      completed(true);
    return exit();
  }
  const blur_handler = () => check_password();
  function input_input_handler() {
    sh_phrase = this.value;
    $$invalidate(0, sh_phrase);
  }
  const blur_handler_1 = () => check_verify();
  function input_input_handler_1() {
    sh_verify = this.value;
    $$invalidate(1, sh_verify);
  }
  function log_1_items_binding(value) {
    if ($$self.$$.not_equal(k_logger.items, value)) {
      k_logger.items = value;
      $$invalidate(6, k_logger);
    }
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $$invalidate(2, b_password_acceptable = !!sh_phrase && sh_phrase === sh_verify && acceptable(sh_phrase));
    }
    if ($$self.$$.dirty & 4) {
      $$invalidate(7, a_confirm_action = ["Continue", prepare_register, !b_password_acceptable]);
    }
  };
  return [
    sh_phrase,
    sh_verify,
    b_password_acceptable,
    s_error,
    s_err_password,
    s_err_verify,
    k_logger,
    a_confirm_action,
    check_password,
    check_verify,
    blur_handler,
    input_input_handler,
    blur_handler_1,
    input_input_handler_1,
    log_1_items_binding
  ];
}
class Register extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$E, safe_not_equal, {});
  }
}
var SX_ICON_CONTACTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M19 5v14H5V5h14m0-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 9c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3zm0-4c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm6 10H6v-1.53c0-2.5 3.97-3.58 6-3.58s6 1.08 6 3.58V18zm-9.69-2h7.38c-.69-.56-2.38-1.12-3.69-1.12s-3.01.56-3.69 1.12z"/>\n</svg>';
var SX_ICON_CONTRACT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-analytics-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-analytics-fg" d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/>\n	<path class="s2r-analytics-fg" d="M7 12h2v5H7zm8-5h2v10h-2zm-4 7h2v3h-2zm0-4h2v2h-2z"/>\n</svg>';
var SX_ICON_LOADING = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M13 5.08A7 7 0 0 1 18.92 11h3.03c-.47-4.72-4.23-8.48-8.95-8.95v3.03zM18.92 13A7 7 0 0 1 13 18.92v3.03c4.72-.47 8.48-4.23 8.95-8.95h-3.03zM11 18.92c-3.39-.49-6-3.4-6-6.92s2.61-6.43 6-6.92V2.05c-5.05.5-9 4.76-9 9.95 0 5.19 3.95 9.45 9 9.95v-3.03z"/>\n</svg>';
function create_catch_block$b(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$b(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding(value) {
    ctx[4](value);
  }
  let starselect_props = {
    id: "asset-select",
    pfpMap: ctx[1],
    placeholder: "Select asset",
    items: ctx[8]
  };
  if (ctx[0] !== void 0) {
    starselect_props.value = ctx[0];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (dirty & 2)
        starselect_changes.pfpMap = ctx2[1];
      if (!updating_value && dirty & 1) {
        updating_value = true;
        starselect_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block$b(ctx) {
  let t;
  return {
    c() {
      t = text("Loading assets...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$D(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$b,
    then: create_then_block$b,
    catch: create_catch_block$b,
    value: 8,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "asset");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let $yw_owner;
  let $yw_chain;
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(5, $yw_owner = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(6, $yw_chain = $$value));
  let { assetRef = "" } = $$props;
  $yw_chain?.id || "*";
  let h_asset_pfps = {};
  async function load_assets() {
    const a_items = [];
    $$invalidate(1, h_asset_pfps = await load_pfps($yw_chain.coins, { dim: 19 }));
    for (const [si_coin, g_coin] of ode($yw_chain.coins)) {
      a_items.push({
        value: Entities.holdingPathFor($yw_owner, si_coin),
        object: g_coin,
        primary: si_coin,
        secondary: g_coin.name,
        pfp: g_coin.pfp
      });
    }
    return a_items;
  }
  let g_item = {
    value: assetRef,
    object: null,
    primary: "",
    secondary: "",
    pfp: ""
  };
  function starselect_value_binding(value) {
    g_item = value;
    $$invalidate(0, g_item);
  }
  $$self.$$set = ($$props2) => {
    if ("assetRef" in $$props2)
      $$invalidate(3, assetRef = $$props2.assetRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        $$invalidate(3, assetRef = g_item?.value || "");
      }
    }
  };
  return [g_item, h_asset_pfps, load_assets, assetRef, starselect_value_binding];
}
class AssetSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$D, safe_not_equal, { assetRef: 3 });
  }
}
var SX_ICON_INCREMENT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14l-6-6z"/>\n</svg>';
var SX_ICON_DECREMENT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"/>\n</svg>';
function create_if_block_1$7(ctx) {
  let span6;
  let span2;
  let span0;
  let t0;
  let t1;
  let t2;
  let span1;
  let t4;
  let span5;
  let span3;
  let t5;
  let span4;
  let mounted;
  let dispose;
  return {
    c() {
      span6 = element("span");
      span2 = element("span");
      span0 = element("span");
      t0 = text("= ");
      t1 = text(ctx[5]);
      t2 = space();
      span1 = element("span");
      span1.textContent = "USD";
      t4 = space();
      span5 = element("span");
      span3 = element("span");
      t5 = space();
      span4 = element("span");
      attr(span0, "class", "amount svelte-18lggj7");
      attr(span1, "class", "fiat svelte-18lggj7");
      attr(span2, "class", "equivalent svelte-18lggj7");
      attr(span3, "class", "icon increment clickable svelte-18lggj7");
      attr(span4, "class", "icon decrement clickable svelte-18lggj7");
      attr(span5, "class", "adjust svelte-18lggj7");
      attr(span6, "class", "occupy svelte-18lggj7");
    },
    m(target, anchor) {
      insert(target, span6, anchor);
      append(span6, span2);
      append(span2, span0);
      append(span0, t0);
      append(span0, t1);
      append(span2, t2);
      append(span2, span1);
      append(span6, t4);
      append(span6, span5);
      append(span5, span3);
      span3.innerHTML = SX_ICON_INCREMENT;
      append(span5, t5);
      append(span5, span4);
      span4.innerHTML = SX_ICON_DECREMENT;
      if (!mounted) {
        dispose = [
          listen(span3, "click", ctx[16]),
          listen(span3, "mousedown", ctx[17]),
          listen(span4, "click", ctx[18]),
          listen(span4, "mousedown", ctx[19])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t1, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(span6);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$f(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$C(ctx) {
  let div;
  let input;
  let input_disabled_value;
  let input_max_value;
  let input_step_value;
  let t0;
  let t1;
  let mounted;
  let dispose;
  let if_block0 = ctx[3] && create_if_block_1$7(ctx);
  let if_block1 = ctx[1] && create_if_block$f(ctx);
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      input.disabled = input_disabled_value = !ctx[2];
      attr(input, "type", "number");
      attr(input, "min", "0");
      attr(input, "max", input_max_value = ctx[4] + "" || "0");
      attr(input, "step", input_step_value = "0." + "0".repeat((ctx[3]?.decimals || 1) - 1) + "1");
      input.required = true;
      input.value = ctx[0];
      attr(input, "class", "svelte-18lggj7");
      toggle_class(input, "invalid", ctx[1]);
      attr(div, "class", "amount-input svelte-18lggj7");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      ctx[15](input);
      append(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      if (!mounted) {
        dispose = [
          listen(input, "change", ctx[14]),
          listen(input, "input", ctx[7]),
          listen(input, "invalid", invalid_handler)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4 && input_disabled_value !== (input_disabled_value = !ctx2[2])) {
        input.disabled = input_disabled_value;
      }
      if (dirty & 16 && input_max_value !== (input_max_value = ctx2[4] + "" || "0")) {
        attr(input, "max", input_max_value);
      }
      if (dirty & 8 && input_step_value !== (input_step_value = "0." + "0".repeat((ctx2[3]?.decimals || 1) - 1) + "1")) {
        attr(input, "step", input_step_value);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        input.value = ctx2[0];
      }
      if (dirty & 2) {
        toggle_class(input, "invalid", ctx2[1]);
      }
      if (ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1$7(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$f(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[15](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function long_press(f_action) {
  let i_ticker = 0;
  const i_buffer = window.setTimeout(
    () => {
      i_ticker = window.setInterval(f_action, 90);
    },
    1e3
  );
  window.addEventListener(
    "mouseup",
    () => {
      clearTimeout(i_buffer);
      clearInterval(i_ticker);
    },
    { once: true }
  );
}
const invalid_handler = (d) => d.preventDefault();
function instance$z($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_owner;
  let $yw_network_active;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(21, $yw_chain = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(22, $yw_owner = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(23, $yw_network_active = $$value));
  let { value = "" } = $$props;
  const YG_ZERO = new BigNumber(0);
  const YG_ONE = new BigNumber(1);
  let { assetRef = "" } = $$props;
  let { bufferMax = 0 } = $$props;
  let g_asset;
  let yg_max = YG_ZERO;
  let yg_step = YG_ZERO;
  let s_fiat_equivalent = "";
  let si_coingecko = "";
  async function reload_asset() {
    $$invalidate(5, s_fiat_equivalent = "[...]");
    const g_entity = Entities.parseEntityPath(assetRef);
    if ("holding" === g_entity?.type) {
      const si_coin = g_entity.coin;
      $$invalidate(3, g_asset = $yw_chain.coins[si_coin]);
      const g_cached = $yw_network_active.cachedBalance($yw_owner, si_coin);
      if (g_cached && g_cached.timestamp > Date.now() - 5 * XT_MINUTES) {
        $$invalidate(4, yg_max = new BigNumber(g_cached.data.amount).shiftedBy(-g_asset.decimals).minus(new BigNumber(bufferMax)));
      }
      const g_bundle = await $yw_network_active.bankBalance($yw_owner, si_coin);
      if (assetRef === g_bundle.holding) {
        const yg_amount = new BigNumber(g_bundle.balance.amount).shiftedBy(-g_asset.decimals).minus(new BigNumber(bufferMax));
        if (!yg_amount.eq(yg_max)) {
          $$invalidate(4, yg_max = yg_amount);
        }
        const g_coin = $yw_chain.coins[si_coin];
        $$invalidate(13, si_coingecko = g_coin?.extra?.coingecko_id || "");
      }
    } else if ("token" === g_entity?.type) {
      $$invalidate(3, g_asset = null);
    }
    if (g_asset) {
      yg_step = YG_ONE.shiftedBy(-g_asset.decimals);
    } else {
      yg_step = YG_ZERO;
      $$invalidate(4, yg_max = YG_ZERO);
    }
  }
  function capture_input(d_event) {
    $$invalidate(0, value = d_event.target.value);
  }
  function increment() {
    const yg_next = yg_step.plus(value || 0);
    if (yg_next.lte(yg_max)) {
      $$invalidate(0, value = yg_next + "");
    } else {
      $$invalidate(0, value = yg_max + "");
    }
    check_validity();
  }
  function decrement() {
    const yg_next = yg_step.negated().plus(value || 0);
    if (yg_next.gte(0)) {
      if (yg_next.gt(yg_max)) {
        $$invalidate(0, value = yg_max + "");
      } else {
        $$invalidate(0, value = yg_next + "");
      }
    } else {
      $$invalidate(0, value = "0");
    }
    check_validity();
  }
  let { error = "" } = $$props;
  let dm_input;
  function invalidate(s_msg) {
    dm_input.setCustomValidity(s_msg);
    $$invalidate(1, error = s_msg);
  }
  function check_validity() {
    if (!value) {
      return invalidate("Enter an amount");
    }
    let yg_input;
    try {
      yg_input = new BigNumber(value);
    } catch (e_parse) {
      return invalidate("Invalid number");
    }
    if (yg_input.lt(YG_ZERO)) {
      return invalidate("Value must be positive");
    }
    if (yg_input.gt(yg_max)) {
      return invalidate("Insufficient balance");
    }
    $$invalidate(1, error = "");
  }
  let { showValidation = 0 } = $$props;
  const change_handler = () => check_validity();
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_input = $$value;
      $$invalidate(6, dm_input);
    });
  }
  const click_handler2 = () => increment();
  const mousedown_handler = () => long_press(increment);
  const click_handler_1 = () => decrement();
  const mousedown_handler_1 = () => long_press(decrement);
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("assetRef" in $$props2)
      $$invalidate(2, assetRef = $$props2.assetRef);
    if ("bufferMax" in $$props2)
      $$invalidate(11, bufferMax = $$props2.bufferMax);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("showValidation" in $$props2)
      $$invalidate(12, showValidation = $$props2.showValidation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 4) {
      {
        if (assetRef) {
          void reload_asset();
        } else {
          $$invalidate(3, g_asset = null);
        }
      }
    }
    if ($$self.$$.dirty & 8193) {
      {
        if (si_coingecko) {
          (async () => {
            const h_versus = await CoinGecko.coinsVersus([si_coingecko], "usd", 1 * XT_MINUTES);
            if (si_coingecko in h_versus) {
              $$invalidate(5, s_fiat_equivalent = format_amount(+value * +h_versus[si_coingecko], true));
            } else {
              $$invalidate(5, s_fiat_equivalent = "(?)");
            }
          })();
        } else {
          $$invalidate(5, s_fiat_equivalent = "");
        }
      }
    }
    if ($$self.$$.dirty & 4097) {
      {
        if (showValidation) {
          check_validity();
        } else if (!value) {
          $$invalidate(1, error = "");
        }
      }
    }
  };
  return [
    value,
    error,
    assetRef,
    g_asset,
    yg_max,
    s_fiat_equivalent,
    dm_input,
    capture_input,
    increment,
    decrement,
    check_validity,
    bufferMax,
    showValidation,
    si_coingecko,
    change_handler,
    input_binding,
    click_handler2,
    mousedown_handler,
    click_handler_1,
    mousedown_handler_1
  ];
}
class AmountInput extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$C, safe_not_equal, {
      value: 0,
      assetRef: 2,
      bufferMax: 11,
      error: 1,
      showValidation: 12
    });
  }
}
function create_catch_block$a(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$a(ctx) {
  let starselect;
  let updating_value;
  let current;
  function starselect_value_binding(value) {
    ctx[4](value);
  }
  let starselect_props = {
    id: "sender-select",
    placeholder: "Select account",
    secondaryClass: "balance",
    items: ctx[1]
  };
  if (ctx[0] !== void 0) {
    starselect_props.value = ctx[0];
  }
  starselect = new StarSelect({ props: starselect_props });
  binding_callbacks.push(() => bind(starselect, "value", starselect_value_binding));
  return {
    c() {
      create_component(starselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(starselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const starselect_changes = {};
      if (!updating_value && dirty & 1) {
        updating_value = true;
        starselect_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      starselect.$set(starselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(starselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starselect, detaching);
    }
  };
}
function create_pending_block$a(ctx) {
  let t;
  return {
    c() {
      t = text("Loading accounts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$B(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$a,
    then: create_then_block$a,
    catch: create_catch_block$a,
    value: 1,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "sender");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$y($$self, $$props, $$invalidate) {
  let $yw_account_ref;
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(5, $yw_account_ref = $$value));
  let { accountRef = $yw_account_ref } = $$props;
  const mk_account = (p_acc, g_acc) => ({
    value: p_acc,
    primary: g_acc.name,
    secondary: g_acc.extra?.total_fiat_cache || "(?)"
  });
  let g_selected;
  let a_options;
  async function load_accounts() {
    const ks_accounts = await Accounts.read();
    $$invalidate(1, a_options = oderac(ks_accounts.raw, mk_account));
    $$invalidate(0, g_selected = a_options.find((g) => accountRef === g.value));
    return a_options;
  }
  function starselect_value_binding(value) {
    g_selected = value;
    $$invalidate(0, g_selected);
  }
  $$self.$$set = ($$props2) => {
    if ("accountRef" in $$props2)
      $$invalidate(3, accountRef = $$props2.accountRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      if (g_selected) {
        $$invalidate(3, accountRef = g_selected.value);
      }
    }
  };
  return [g_selected, a_options, load_accounts, accountRef, starselect_value_binding];
}
class SenderSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$B, safe_not_equal, { accountRef: 3 });
  }
}
function create_else_block$6(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "Failed to locate contact";
      attr(span, "class", "warning");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block_2$3(ctx) {
  let span;
  let address_1;
  let current;
  address_1 = new Address({ props: { address: ctx[0] } });
  return {
    c() {
      span = element("span");
      create_component(address_1.$$.fragment);
      attr(span, "class", "manual");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      mount_component(address_1, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const address_1_changes = {};
      if (dirty & 1)
        address_1_changes.address = ctx2[0];
      address_1.$set(address_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(address_1);
    }
  };
}
function create_if_block$e(ctx) {
  let div;
  let span0;
  let t0;
  let span2;
  let span1;
  let t1_value = ctx[1].name + "";
  let t1;
  let t2;
  let address_1;
  let current;
  let if_block = ctx[1] && create_if_block_1$6(ctx);
  address_1 = new Address({
    props: {
      address: Chains.bech32(ctx[1].address)
    }
  });
  return {
    c() {
      div = element("div");
      span0 = element("span");
      if (if_block)
        if_block.c();
      t0 = space();
      span2 = element("span");
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      create_component(address_1.$$.fragment);
      attr(span0, "class", "contact-pfp svelte-1ontxbe");
      attr(span1, "class", "name svelte-1ontxbe");
      attr(span2, "class", "info svelte-1ontxbe");
      attr(div, "class", "contact svelte-1ontxbe");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      if (if_block)
        if_block.m(span0, null);
      append(div, t0);
      append(div, span2);
      append(span2, span1);
      append(span1, t1);
      append(span2, t2);
      mount_component(address_1, span2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if ((!current || dirty & 2) && t1_value !== (t1_value = ctx2[1].name + ""))
        set_data(t1, t1_value);
      const address_1_changes = {};
      if (dirty & 2)
        address_1_changes.address = Chains.bech32(ctx2[1].address);
      address_1.$set(address_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(address_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(address_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      destroy_component(address_1);
    }
  };
}
function create_if_block_1$6(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 28,
      resource: ctx[1],
      genStyle: "font-size:18px;"
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pfpdisplay_changes = {};
      if (dirty & 2)
        pfpdisplay_changes.resource = ctx2[1];
      pfpdisplay.$set(pfpdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_fragment$A(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$e, create_if_block_2$3, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return 0;
    if (ctx2[0])
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let $yw_family;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(3, $yw_family = $$value));
  let { contact = null } = $$props;
  let g_contact = contact;
  let { address = "" } = $$props;
  async function reload_contacts() {
    const ks_agents = await Agents.read();
    const di_contacts = ks_agents.contacts($yw_family);
    if (!g_contact && address) {
      for (const [, g_contact_each] of di_contacts) {
        if (address === Chains.bech32(g_contact_each.address)) {
          $$invalidate(1, g_contact = g_contact_each);
          break;
        }
      }
    }
  }
  void reload_contacts();
  const f_unsub_agents = subscribe_store("agents", reload_contacts);
  onDestroy(() => {
    f_unsub_agents();
  });
  $$self.$$set = ($$props2) => {
    if ("contact" in $$props2)
      $$invalidate(2, contact = $$props2.contact);
    if ("address" in $$props2)
      $$invalidate(0, address = $$props2.address);
  };
  return [address, g_contact, contact];
}
class InlineContactSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$A, safe_not_equal, { contact: 2, address: 0 });
  }
}
function create_fragment$z(ctx) {
  let div;
  let inlinecontactselection;
  let div_class_value;
  let current;
  inlinecontactselection = new InlineContactSelection({
    props: {
      contact: ctx[1].contact,
      address: ctx[1].value
    }
  });
  return {
    c() {
      div = element("div");
      create_component(inlinecontactselection.$$.fragment);
      attr(div, "class", div_class_value = "item " + ctx[2] + " svelte-pgx3pp");
      toggle_class(div, "display_none", ctx[0] || !ctx[1].value);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inlinecontactselection, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const inlinecontactselection_changes = {};
      if (dirty & 2)
        inlinecontactselection_changes.contact = ctx2[1].contact;
      if (dirty & 2)
        inlinecontactselection_changes.address = ctx2[1].value;
      inlinecontactselection.$set(inlinecontactselection_changes);
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "item " + ctx2[2] + " svelte-pgx3pp")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & 7) {
        toggle_class(div, "display_none", ctx2[0] || !ctx2[1].value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinecontactselection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontactselection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inlinecontactselection);
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let { isActive = false } = $$props;
  let { isFirst = false } = $$props;
  let { isHover = false } = $$props;
  let { isSelectable = false } = $$props;
  let { getOptionLabel = void 0 } = $$props;
  let { item } = $$props;
  let { filterText = "" } = $$props;
  let itemClasses = "";
  $$self.$$set = ($$props2) => {
    if ("isActive" in $$props2)
      $$invalidate(0, isActive = $$props2.isActive);
    if ("isFirst" in $$props2)
      $$invalidate(3, isFirst = $$props2.isFirst);
    if ("isHover" in $$props2)
      $$invalidate(4, isHover = $$props2.isHover);
    if ("isSelectable" in $$props2)
      $$invalidate(5, isSelectable = $$props2.isSelectable);
    if ("getOptionLabel" in $$props2)
      $$invalidate(6, getOptionLabel = $$props2.getOptionLabel);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
    if ("filterText" in $$props2)
      $$invalidate(7, filterText = $$props2.filterText);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 57) {
      {
        const classes = [];
        if (isActive) {
          classes.push("active");
        }
        if (isFirst) {
          classes.push("first");
        }
        if (isHover) {
          classes.push("hover");
        }
        if (!isSelectable) {
          classes.push("notSelectable");
        }
        $$invalidate(2, itemClasses = classes.join(" "));
      }
    }
  };
  return [
    isActive,
    item,
    itemClasses,
    isFirst,
    isHover,
    isSelectable,
    getOptionLabel,
    filterText
  ];
}
class RecipientSelectItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$z, safe_not_equal, {
      isActive: 0,
      isFirst: 3,
      isHover: 4,
      isSelectable: 5,
      getOptionLabel: 6,
      item: 1,
      filterText: 7
    });
  }
}
function create_fragment$y(ctx) {
  let div;
  let inlinecontactselection;
  let current;
  inlinecontactselection = new InlineContactSelection({
    props: {
      contact: ctx[0].contact,
      address: ctx[0].value
    }
  });
  return {
    c() {
      div = element("div");
      create_component(inlinecontactselection.$$.fragment);
      attr(div, "class", "selection svelte-aitqlq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(inlinecontactselection, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const inlinecontactselection_changes = {};
      if (dirty & 1)
        inlinecontactselection_changes.contact = ctx2[0].contact;
      if (dirty & 1)
        inlinecontactselection_changes.address = ctx2[0].value;
      inlinecontactselection.$set(inlinecontactselection_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinecontactselection.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinecontactselection.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(inlinecontactselection);
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  let { getSelectionLabel } = $$props;
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("getSelectionLabel" in $$props2)
      $$invalidate(1, getSelectionLabel = $$props2.getSelectionLabel);
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item, getSelectionLabel];
}
class RecipientSelectSelection extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$y, safe_not_equal, { getSelectionLabel: 1, item: 0 });
  }
}
function create_catch_block$9(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$9(ctx) {
  let select_1;
  let updating_filterText;
  let updating_listOpen;
  let current;
  function select_1_filterText_binding(value) {
    ctx[14](value);
  }
  function select_1_listOpen_binding(value) {
    ctx[15](value);
  }
  let select_1_props = {
    id: "recipient-select",
    placeholder: "Address or contact",
    listOffset: 1,
    isClearable: !!ctx[0],
    isCreatable: !!ctx[3],
    Item: RecipientSelectItem,
    Selection: RecipientSelectSelection,
    items: ctx[8],
    value: ctx[4],
    noOptionsMessage: "Stop typing in the address. \n Use copy/paste instead!",
    containerClasses: ctx[1] ? "invalid" : ""
  };
  if (ctx[2] !== void 0) {
    select_1_props.filterText = ctx[2];
  }
  if (ctx[6] !== void 0) {
    select_1_props.listOpen = ctx[6];
  }
  select_1 = new Select({ props: select_1_props });
  binding_callbacks.push(() => bind(select_1, "filterText", select_1_filterText_binding));
  binding_callbacks.push(() => bind(select_1, "listOpen", select_1_listOpen_binding));
  select_1.$on("select", ctx[10]);
  select_1.$on("clear", ctx[11]);
  return {
    c() {
      create_component(select_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(select_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_1_changes = {};
      if (dirty & 1)
        select_1_changes.isClearable = !!ctx2[0];
      if (dirty & 8)
        select_1_changes.isCreatable = !!ctx2[3];
      if (dirty & 16)
        select_1_changes.value = ctx2[4];
      if (dirty & 2)
        select_1_changes.containerClasses = ctx2[1] ? "invalid" : "";
      if (!updating_filterText && dirty & 4) {
        updating_filterText = true;
        select_1_changes.filterText = ctx2[2];
        add_flush_callback(() => updating_filterText = false);
      }
      if (!updating_listOpen && dirty & 64) {
        updating_listOpen = true;
        select_1_changes.listOpen = ctx2[6];
        add_flush_callback(() => updating_listOpen = false);
      }
      select_1.$set(select_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_1, detaching);
    }
  };
}
function create_pending_block$9(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contacts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$d(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[1]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 2)
        set_data(t, ctx2[1]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_fragment$x(ctx) {
  let div;
  let t;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$9,
    then: create_then_block$9,
    catch: create_catch_block$9,
    value: 8,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  let if_block = ctx[1] && create_if_block$d(ctx);
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "sender svelte-1rmr362");
      toggle_class(div, "hide-cursor", ctx[5]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      ctx[16](div);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (ctx[1]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$d(ctx);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 32) {
        toggle_class(div, "hide-cursor", ctx[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      if (if_block)
        if_block.d();
      ctx[16](null);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_family;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(13, $yw_chain = $$value));
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(17, $yw_family = $$value));
  let { address = "" } = $$props;
  const sa_input = address;
  let { error = "" } = $$props;
  let s_manual_input;
  let g_item_select;
  let a_contacts;
  const contact_to_option = (g) => ({
    value: Chains.bech32(g.address),
    label: g.name,
    contact: g
  });
  async function load_contacts() {
    const ks_agents = await Agents.read();
    const a_options = [{ value: "", label: "", contact: null }];
    $$invalidate(8, a_contacts = [...ks_agents.contacts($yw_family)]);
    for (const [, g_contact] of a_contacts) {
      const g_option = contact_to_option(g_contact);
      const sa_contact = Chains.bech32(g_contact.address);
      if (sa_input && sa_contact === sa_input) {
        $$invalidate(4, g_item_select = g_option);
      }
      a_options.push(g_option);
    }
    return a_options;
  }
  function select(d_event) {
    $$invalidate(0, address = d_event.detail.value);
    $$invalidate(1, error = "");
  }
  function clear() {
    $$invalidate(0, address = "");
  }
  let s_accepted_input = "";
  let b_hide_cursor = false;
  let b_list_open = false;
  function check_manual_input() {
    $$invalidate(3, s_accepted_input = "");
    if (!$yw_chain) {
      $$invalidate(1, error = "No chain set");
    } else if (!Chains.isValidAddressFor($yw_chain, s_manual_input, "acc")) {
      $$invalidate(1, error = "Invalid address for this chain");
    } else {
      $$invalidate(1, error = "");
      for (const [, g_contact] of a_contacts) {
        if (s_manual_input === Chains.bech32(g_contact.address)) {
          $$invalidate(2, s_manual_input = "");
          $$invalidate(4, g_item_select = contact_to_option(g_contact));
          $$invalidate(6, b_list_open = false);
          $$invalidate(5, b_hide_cursor = true);
          return;
        }
      }
      $$invalidate(3, s_accepted_input = s_manual_input);
      setTimeout(
        () => {
          qs(dm_sender, ".manual>.address").click();
          $$invalidate(6, b_list_open = false);
        },
        0
      );
    }
  }
  let dm_sender;
  let { showValidation = 0 } = $$props;
  function select_1_filterText_binding(value) {
    s_manual_input = value;
    $$invalidate(2, s_manual_input);
  }
  function select_1_listOpen_binding(value) {
    b_list_open = value;
    $$invalidate(6, b_list_open);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_sender = $$value;
      $$invalidate(7, dm_sender);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("address" in $$props2)
      $$invalidate(0, address = $$props2.address);
    if ("error" in $$props2)
      $$invalidate(1, error = $$props2.error);
    if ("showValidation" in $$props2)
      $$invalidate(12, showValidation = $$props2.showValidation);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 12) {
      {
        $$invalidate(5, b_hide_cursor = false);
        if (s_manual_input) {
          check_manual_input();
        } else {
          $$invalidate(5, b_hide_cursor = !!s_accepted_input);
          $$invalidate(3, s_accepted_input = "");
        }
      }
    }
    if ($$self.$$.dirty & 12293) {
      {
        if (showValidation) {
          if (!address) {
            if (s_manual_input) {
              check_manual_input();
            } else {
              $$invalidate(1, error = "Enter a recipient");
            }
          } else if (!Chains.isValidAddressFor($yw_chain, address, "acc")) {
            $$invalidate(1, error = "Invalid address for this chain");
          } else {
            $$invalidate(1, error = "");
          }
        } else if (!address) {
          $$invalidate(1, error = "");
        }
      }
    }
  };
  return [
    address,
    error,
    s_manual_input,
    s_accepted_input,
    g_item_select,
    b_hide_cursor,
    b_list_open,
    dm_sender,
    a_contacts,
    load_contacts,
    select,
    clear,
    showValidation,
    $yw_chain,
    select_1_filterText_binding,
    select_1_listOpen_binding,
    div_binding
  ];
}
class RecipientSelect extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$x, safe_not_equal, { address: 0, error: 1, showValidation: 12 });
  }
}
function create_default_slot_6$3(ctx) {
  let div0;
  let t0_value = (ctx[1]?.name || "[...]") + "";
  let t0;
  let t1;
  let div1;
  let t2_value = (ctx[1]?.extra?.total_fiat_cache || "(?)") + "";
  let t2;
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      append(div1, t2);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = (ctx2[1]?.name || "[...]") + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = (ctx2[1]?.extra?.total_fiat_cache || "(?)") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
    }
  };
}
function create_default_slot_5$4(ctx) {
  let div0;
  let t0_value = (ctx[2] || "[...]") + "";
  let t0;
  let t1;
  let div1;
  let address;
  let current;
  address = new Address({
    props: { address: ctx[9] }
  });
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      create_component(address.$$.fragment);
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      insert(target, t1, anchor);
      insert(target, div1, anchor);
      mount_component(address, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & 4) && t0_value !== (t0_value = (ctx2[2] || "[...]") + ""))
        set_data(t0, t0_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div1);
      destroy_component(address);
    }
  };
}
function create_else_block_3(ctx) {
  let t;
  return {
    c() {
      t = text("=[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_3$1(ctx) {
  let t_value = format_fiat(new BigNumber(ctx[8]).times(ctx[3]).toNumber()) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = format_fiat(new BigNumber(ctx2[8]).times(ctx2[3]).toNumber()) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_4$4(ctx) {
  let div0;
  let t3;
  let div1;
  function select_block_type(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_3$1;
    return create_else_block_3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${ctx[8]}  ${ctx[7]}`;
      t3 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_else_block_2(ctx) {
  let t;
  return {
    c() {
      t = text("=[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_2$2(ctx) {
  let t_value = format_fiat(new BigNumber(ctx[10]).times(ctx[3]).toNumber()) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 8 && t_value !== (t_value = format_fiat(new BigNumber(ctx2[10]).times(ctx2[3]).toNumber()) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3$5(ctx) {
  let div0;
  let t3;
  let div1;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_2$2;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${ctx[10]}  ${ctx[7]}`;
      t3 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_else_block_1(ctx) {
  let t;
  return {
    c() {
      t = text("=[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block_1$5(ctx) {
  let t_value = format_fiat(new BigNumber(ctx[4]).times(ctx[3]).toNumber()) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 24 && t_value !== (t_value = format_fiat(new BigNumber(ctx2[4]).times(ctx2[3]).toNumber()) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let div0;
  let t0_value = (ctx[4] || "[...]") + "";
  let t0;
  let t1;
  let t2;
  let t3;
  let div1;
  function select_block_type_2(ctx2, dirty) {
    if (ctx2[3])
      return create_if_block_1$5;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(ctx[7]);
      t3 = space();
      div1 = element("div");
      if_block.c();
      attr(div0, "class", "title");
      attr(div1, "class", "subtitle svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t0);
      append(div0, t1);
      append(div0, t2);
      insert(target, t3, anchor);
      insert(target, div1, anchor);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (dirty & 16 && t0_value !== (t0_value = (ctx2[4] || "[...]") + ""))
        set_data(t0, t0_value);
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div1);
      if_block.d();
    }
  };
}
function create_else_block$5(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = "(empty)";
      attr(span, "class", "empty-memo svelte-m8l3qm");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_if_block$c(ctx) {
  let textarea;
  return {
    c() {
      textarea = element("textarea");
      textarea.disabled = true;
      textarea.value = ctx[0];
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1) {
        textarea.value = ctx2[0];
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let if_block_anchor;
  function select_block_type_3(ctx2, dirty) {
    if (ctx2[0])
      return create_if_block$c;
    return create_else_block$5;
  }
  let current_block_type = select_block_type_3(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot$h(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let hr0;
  let t2;
  let field1;
  let t3;
  let hr1;
  let t4;
  let field2;
  let t5;
  let hr2;
  let t6;
  let field3;
  let t7;
  let hr3;
  let t8;
  let field4;
  let t9;
  let hr4;
  let t10;
  let field5;
  let t11;
  let actionsline;
  let current;
  header = new Header({
    props: {
      pops: true,
      exits: true,
      title: "Sending",
      symbol: ctx[7],
      subtitle: ctx[5].name
    }
  });
  header.$on("close", ctx[17]);
  field0 = new Field({
    props: {
      short: true,
      key: "sender",
      name: "From",
      $$slots: { default: [create_default_slot_6$3] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      short: true,
      key: "recipient",
      name: "To",
      $$slots: { default: [create_default_slot_5$4] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      short: true,
      key: "amount",
      name: "Amount",
      $$slots: { default: [create_default_slot_4$4] },
      $$scope: { ctx }
    }
  });
  field3 = new Field({
    props: {
      short: true,
      key: "fee-review",
      name: "Fee",
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      short: true,
      key: "total",
      name: "Total",
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    }
  });
  field5 = new Field({
    props: {
      short: true,
      key: "memo",
      name: "Memo",
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      back: true,
      confirm: ["Approve", ctx[18]]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      hr0 = element("hr");
      t2 = space();
      create_component(field1.$$.fragment);
      t3 = space();
      hr1 = element("hr");
      t4 = space();
      create_component(field2.$$.fragment);
      t5 = space();
      hr2 = element("hr");
      t6 = space();
      create_component(field3.$$.fragment);
      t7 = space();
      hr3 = element("hr");
      t8 = space();
      create_component(field4.$$.fragment);
      t9 = space();
      hr4 = element("hr");
      t10 = space();
      create_component(field5.$$.fragment);
      t11 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      insert(target, hr0, anchor);
      insert(target, t2, anchor);
      mount_component(field1, target, anchor);
      insert(target, t3, anchor);
      insert(target, hr1, anchor);
      insert(target, t4, anchor);
      mount_component(field2, target, anchor);
      insert(target, t5, anchor);
      insert(target, hr2, anchor);
      insert(target, t6, anchor);
      mount_component(field3, target, anchor);
      insert(target, t7, anchor);
      insert(target, hr3, anchor);
      insert(target, t8, anchor);
      mount_component(field4, target, anchor);
      insert(target, t9, anchor);
      insert(target, hr4, anchor);
      insert(target, t10, anchor);
      mount_component(field5, target, anchor);
      insert(target, t11, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & 32)
        header_changes.subtitle = ctx2[5].name;
      header.$set(header_changes);
      const field0_changes = {};
      if (dirty & 16777218) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 16777220) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 16777224) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const field3_changes = {};
      if (dirty & 16777224) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty & 16777240) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      const field5_changes = {};
      if (dirty & 16777217) {
        field5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field5.$set(field5_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(field5.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(field5.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(hr0);
      if (detaching)
        detach(t2);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(hr1);
      if (detaching)
        detach(t4);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(hr2);
      if (detaching)
        detach(t6);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(hr3);
      if (detaching)
        detach(t8);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t9);
      if (detaching)
        detach(hr4);
      if (detaching)
        detach(t10);
      destroy_component(field5, detaching);
      if (detaching)
        detach(t11);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment$w(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "SendNative",
      slides: true,
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 16777279) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let s_total;
  let $yw_navigator;
  let $yw_network_active;
  let $yw_chain;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(21, $yw_navigator = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(22, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(5, $yw_chain = $$value));
  const k_page = getContext("page");
  let { coin } = $$props;
  const si_coin = coin;
  const g_coin = $yw_chain.coins[si_coin];
  let { accountRef } = $$props;
  let g_account;
  let sa_sender;
  let { amount } = $$props;
  const s_amount = amount;
  let { recipient } = $$props;
  const sa_recipient = recipient;
  let s_recipient_title = "";
  let g_contact;
  let { fee } = $$props;
  const s_fee = fee;
  let { memo } = $$props;
  let x_worth = 0;
  (async (fk_resolve) => {
    const si_coingecko = g_coin.extra?.coingecko_id || "";
    if (si_coingecko) {
      const h_versus = await CoinGecko.coinsVersus([si_coingecko], "usd", 0);
      $$invalidate(3, x_worth = h_versus[si_coingecko]);
    }
  })();
  (async () => {
    const ks_accounts = await Accounts.read();
    $$invalidate(1, g_account = ks_accounts.at(accountRef));
    sa_sender = Chains.addressFor(g_account.pubkey);
    const p_contact = Agents.pathForContact(sa_recipient);
    g_contact = await Agents.getContact(p_contact);
    $$invalidate(2, s_recipient_title = g_contact?.name || "");
  })();
  async function approve() {
    const xg_amount = BigInt(new BigNumber(s_amount).shiftedBy(g_coin.decimals).toString());
    const g_attempt = await $yw_network_active.bankSend(sa_sender, sa_recipient, si_coin, xg_amount, memo);
    await Events.insert({
      type: "pending",
      time: Date.now(),
      data: g_attempt
    });
    k_page.reset();
    void $yw_navigator.activateThread(ThreadId.HISTORY);
  }
  const close_handler = () => k_page.reset();
  const func = () => approve();
  $$self.$$set = ($$props2) => {
    if ("coin" in $$props2)
      $$invalidate(12, coin = $$props2.coin);
    if ("accountRef" in $$props2)
      $$invalidate(13, accountRef = $$props2.accountRef);
    if ("amount" in $$props2)
      $$invalidate(14, amount = $$props2.amount);
    if ("recipient" in $$props2)
      $$invalidate(15, recipient = $$props2.recipient);
    if ("fee" in $$props2)
      $$invalidate(16, fee = $$props2.fee);
    if ("memo" in $$props2)
      $$invalidate(0, memo = $$props2.memo);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 65536) {
      $$invalidate(4, s_total = new BigNumber(s_amount).plus(fee).toString());
    }
  };
  return [
    memo,
    g_account,
    s_recipient_title,
    x_worth,
    s_total,
    $yw_chain,
    k_page,
    si_coin,
    s_amount,
    sa_recipient,
    s_fee,
    approve,
    coin,
    accountRef,
    amount,
    recipient,
    fee,
    close_handler,
    func
  ];
}
class SendNative extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$w, safe_not_equal, {
      coin: 12,
      accountRef: 13,
      amount: 14,
      recipient: 15,
      fee: 16,
      memo: 0
    });
  }
}
function create_default_slot_9(ctx) {
  let senderselect;
  let updating_accountRef;
  let current;
  function senderselect_accountRef_binding(value) {
    ctx[38](value);
  }
  let senderselect_props = {};
  if (ctx[13] !== void 0) {
    senderselect_props.accountRef = ctx[13];
  }
  senderselect = new SenderSelect({ props: senderselect_props });
  binding_callbacks.push(() => bind(senderselect, "accountRef", senderselect_accountRef_binding));
  return {
    c() {
      create_component(senderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(senderselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const senderselect_changes = {};
      if (!updating_accountRef && dirty[0] & 8192) {
        updating_accountRef = true;
        senderselect_changes.accountRef = ctx2[13];
        add_flush_callback(() => updating_accountRef = false);
      }
      senderselect.$set(senderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(senderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(senderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(senderselect, detaching);
    }
  };
}
function create_default_slot_8$1(ctx) {
  let recipientselect;
  let updating_error;
  let updating_address;
  let current;
  function recipientselect_error_binding(value) {
    ctx[39](value);
  }
  function recipientselect_address_binding(value) {
    ctx[40](value);
  }
  let recipientselect_props = {
    showValidation: ctx[4]
  };
  if (ctx[6] !== void 0) {
    recipientselect_props.error = ctx[6];
  }
  if (ctx[0] !== void 0) {
    recipientselect_props.address = ctx[0];
  }
  recipientselect = new RecipientSelect({ props: recipientselect_props });
  binding_callbacks.push(() => bind(recipientselect, "error", recipientselect_error_binding));
  binding_callbacks.push(() => bind(recipientselect, "address", recipientselect_address_binding));
  return {
    c() {
      create_component(recipientselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(recipientselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const recipientselect_changes = {};
      if (dirty[0] & 16)
        recipientselect_changes.showValidation = ctx2[4];
      if (!updating_error && dirty[0] & 64) {
        updating_error = true;
        recipientselect_changes.error = ctx2[6];
        add_flush_callback(() => updating_error = false);
      }
      if (!updating_address && dirty[0] & 1) {
        updating_address = true;
        recipientselect_changes.address = ctx2[0];
        add_flush_callback(() => updating_address = false);
      }
      recipientselect.$set(recipientselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(recipientselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(recipientselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(recipientselect, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let div;
  let checkboxfield;
  let updating_checked;
  let current;
  function checkboxfield_checked_binding(value) {
    ctx[41](value);
  }
  let checkboxfield_props = {
    id: "save-contact",
    $$slots: { default: [create_default_slot_7$1] },
    $$scope: { ctx }
  };
  if (ctx[5] !== void 0) {
    checkboxfield_props.checked = ctx[5];
  }
  checkboxfield = new CheckboxField({ props: checkboxfield_props });
  binding_callbacks.push(() => bind(checkboxfield, "checked", checkboxfield_checked_binding));
  return {
    c() {
      div = element("div");
      create_component(checkboxfield.$$.fragment);
      attr(div, "class", "new-address svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(checkboxfield, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const checkboxfield_changes = {};
      if (dirty[1] & 134217728) {
        checkboxfield_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_checked && dirty[0] & 32) {
        updating_checked = true;
        checkboxfield_changes.checked = ctx2[5];
        add_flush_callback(() => updating_checked = false);
      }
      checkboxfield.$set(checkboxfield_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(checkboxfield.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(checkboxfield.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(checkboxfield);
    }
  };
}
function create_default_slot_7$1(ctx) {
  let t;
  return {
    c() {
      t = text("Save to contacts");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6$2(ctx) {
  let span2;
  let span0;
  let raw_value = ctx[17].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[17].text + "";
  let t1;
  let span2_class_value;
  let t2;
  let if_block_anchor;
  let current;
  let if_block = ctx[9] && create_if_block_5(ctx);
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(span0, "class", "icon svelte-ipiv9p");
      attr(span1, "class", "text svelte-ipiv9p");
      attr(span2, "class", span2_class_value = "status " + ctx[3] + " svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      span0.innerHTML = raw_value;
      append(span2, t0);
      append(span2, span1);
      append(span1, t1);
      insert(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & 131072) && raw_value !== (raw_value = ctx2[17].icon + ""))
        span0.innerHTML = raw_value;
      if ((!current || dirty[0] & 131072) && t1_value !== (t1_value = ctx2[17].text + ""))
        set_data(t1, t1_value);
      if (!current || dirty[0] & 8 && span2_class_value !== (span2_class_value = "status " + ctx2[3] + " svelte-ipiv9p")) {
        attr(span2, "class", span2_class_value);
      }
      if (ctx2[9]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      if (detaching)
        detach(t2);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let field;
  let current;
  field = new Field({
    props: {
      short: true,
      slides: true,
      key: "new-contact-name",
      name: "Contact Name",
      $$slots: { default: [create_default_slot_5$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty[0] & 256 | dirty[1] & 134217728) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[8]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256)
        set_data(t, ctx2[8]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_5$3(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[8] && create_if_block_4(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "id", "new-contact-name-value");
      attr(input, "type", "text");
      toggle_class(input, "invalid", ctx[8]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[24]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 256) {
        toggle_class(input, "invalid", ctx2[8]);
      }
      if (ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_4$3(ctx) {
  let assetselect;
  let updating_assetRef;
  let current;
  function assetselect_assetRef_binding(value) {
    ctx[42](value);
  }
  let assetselect_props = {};
  if (ctx[1] !== void 0) {
    assetselect_props.assetRef = ctx[1];
  }
  assetselect = new AssetSelect({ props: assetselect_props });
  binding_callbacks.push(() => bind(assetselect, "assetRef", assetselect_assetRef_binding));
  return {
    c() {
      create_component(assetselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(assetselect, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const assetselect_changes = {};
      if (!updating_assetRef && dirty[0] & 2) {
        updating_assetRef = true;
        assetselect_changes.assetRef = ctx2[1];
        add_flush_callback(() => updating_assetRef = false);
      }
      assetselect.$set(assetselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(assetselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(assetselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(assetselect, detaching);
    }
  };
}
function create_default_slot_3$4(ctx) {
  let amountinput;
  let updating_error;
  let updating_value;
  let current;
  function amountinput_error_binding(value) {
    ctx[43](value);
  }
  function amountinput_value_binding(value) {
    ctx[44](value);
  }
  let amountinput_props = {
    bufferMax: ctx[10] ? x_fee : 0,
    assetRef: ctx[1],
    showValidation: ctx[4]
  };
  if (ctx[7] !== void 0) {
    amountinput_props.error = ctx[7];
  }
  if (ctx[2] !== void 0) {
    amountinput_props.value = ctx[2];
  }
  amountinput = new AmountInput({ props: amountinput_props });
  binding_callbacks.push(() => bind(amountinput, "error", amountinput_error_binding));
  binding_callbacks.push(() => bind(amountinput, "value", amountinput_value_binding));
  return {
    c() {
      create_component(amountinput.$$.fragment);
    },
    m(target, anchor) {
      mount_component(amountinput, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const amountinput_changes = {};
      if (dirty[0] & 1024)
        amountinput_changes.bufferMax = ctx2[10] ? x_fee : 0;
      if (dirty[0] & 2)
        amountinput_changes.assetRef = ctx2[1];
      if (dirty[0] & 16)
        amountinput_changes.showValidation = ctx2[4];
      if (!updating_error && dirty[0] & 128) {
        updating_error = true;
        amountinput_changes.error = ctx2[7];
        add_flush_callback(() => updating_error = false);
      }
      if (!updating_value && dirty[0] & 4) {
        updating_value = true;
        amountinput_changes.value = ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      amountinput.$set(amountinput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(amountinput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(amountinput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(amountinput, detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let span2;
  let span0;
  let t1;
  let span1;
  let t2;
  let t3;
  let t4;
  let t5;
  let span4;
  let span3;
  let mounted;
  let dispose;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      span0.textContent = "Balance";
      t1 = space();
      span1 = element("span");
      t2 = text(ctx[11]);
      t3 = space();
      t4 = text(ctx[20]);
      t5 = space();
      span4 = element("span");
      span3 = element("span");
      span3.textContent = "USE MAX";
      attr(span0, "class", "label svelte-ipiv9p");
      attr(span1, "class", "amount svelte-ipiv9p");
      attr(span2, "class", "balance svelte-ipiv9p");
      attr(span3, "class", "link svelte-ipiv9p");
      toggle_class(span3, "disabled", ctx[19]);
      attr(span4, "class", "use-max");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span2, t1);
      append(span2, span1);
      append(span1, t2);
      append(span1, t3);
      append(span1, t4);
      insert(target, t5, anchor);
      insert(target, span4, anchor);
      append(span4, span3);
      if (!mounted) {
        dispose = listen(span3, "click", ctx[45]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2048)
        set_data(t2, ctx2[11]);
      if (dirty[0] & 1048576)
        set_data(t4, ctx2[20]);
      if (dirty[0] & 524288) {
        toggle_class(span3, "disabled", ctx2[19]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(span2);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(span4);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$4(ctx) {
  let span;
  let if_block = ctx[1] && create_if_block_2$1(ctx);
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      attr(span, "class", "balance-line svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_2$1(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (if_block)
        if_block.d();
    }
  };
}
function create_default_slot_1$6(ctx) {
  let div0;
  let t2;
  let div1;
  let t3;
  return {
    c() {
      div0 = element("div");
      div0.textContent = `${x_fee} SCRT`;
      t2 = space();
      div1 = element("div");
      t3 = text(ctx[18]);
      attr(div0, "class", "fee-amount");
      attr(div1, "class", "fee-fiat svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append(div1, t3);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 262144)
        set_data(t3, ctx2[18]);
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div1);
    }
  };
}
function create_post_slot(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "manual-fee svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block_1$4(ctx) {
  let span;
  let span_transition;
  let current;
  return {
    c() {
      span = element("span");
      span.textContent = "Caution: Memos are NOT private";
      attr(span, "class", "disclaimer svelte-ipiv9p");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, slide, { duration: 350, delay: 400 }, true);
        span_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!span_transition)
        span_transition = create_bidirectional_transition(span, slide, { duration: 350, delay: 400 }, false);
      span_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_if_block$b(ctx) {
  let div;
  let textarea;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      textarea = element("textarea");
      attr(textarea, "class", "svelte-ipiv9p");
      attr(div, "class", "input");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, textarea);
      set_input_value(textarea, ctx[15]);
      current = true;
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[47]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32768) {
        set_input_value(textarea, ctx2[15]);
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 350 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 350 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$g(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let field1;
  let t2;
  let field2;
  let t3;
  let t4;
  let hr0;
  let t5;
  let field3;
  let t6;
  let field4;
  let t7;
  let field5;
  let t8;
  let hr1;
  let t9;
  let field6;
  let t10;
  let hr2;
  let t11;
  let div1;
  let div0;
  let span0;
  let t12;
  let span1;
  let t14;
  let t15;
  let t16;
  let actionsline;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: {
      pops: true,
      title: ctx[21] ? "Transferring" : "Sending",
      symbol: ctx[21] ? ctx[21].symbol : "",
      subtitle: ctx[12]?.name || "?"
    }
  });
  field0 = new Field({
    props: {
      short: true,
      key: "sender-select",
      name: "From",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      short: true,
      key: "recipient-select",
      name: "To",
      $$slots: { default: [create_default_slot_8$1] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      short: true,
      key: "recipient-status",
      name: "",
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  let if_block0 = ctx[9] && ctx[5] && create_if_block_3(ctx);
  field3 = new Field({
    props: {
      short: true,
      key: "asset-select",
      name: "Asset",
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      short: true,
      key: "amount",
      name: "Amount",
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  field5 = new Field({
    props: {
      short: true,
      key: "balance",
      name: "",
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  field6 = new Field({
    props: {
      short: true,
      key: "fee",
      name: "Fee",
      $$slots: {
        post: [create_post_slot],
        default: [create_default_slot_1$6]
      },
      $$scope: { ctx }
    }
  });
  let if_block1 = ctx[14] && create_if_block_1$4();
  let if_block2 = ctx[14] && create_if_block$b(ctx);
  actionsline = new ActionsLine({
    props: {
      cancel: "pop",
      confirm: ["Next", ctx[48], !ctx[16]]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      create_component(field1.$$.fragment);
      t2 = space();
      create_component(field2.$$.fragment);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      hr0 = element("hr");
      t5 = space();
      create_component(field3.$$.fragment);
      t6 = space();
      create_component(field4.$$.fragment);
      t7 = space();
      create_component(field5.$$.fragment);
      t8 = space();
      hr1 = element("hr");
      t9 = space();
      create_component(field6.$$.fragment);
      t10 = space();
      hr2 = element("hr");
      t11 = space();
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t12 = space();
      span1 = element("span");
      span1.textContent = "Add memo";
      t14 = space();
      if (if_block1)
        if_block1.c();
      t15 = space();
      if (if_block2)
        if_block2.c();
      t16 = space();
      create_component(actionsline.$$.fragment);
      attr(span0, "class", "icon dropdown svelte-ipiv9p");
      attr(span1, "class", "text");
      attr(div0, "class", "title clickable svelte-ipiv9p");
      attr(div1, "class", "memo svelte-ipiv9p");
      toggle_class(div1, "expanded", ctx[14]);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      mount_component(field1, target, anchor);
      insert(target, t2, anchor);
      mount_component(field2, target, anchor);
      insert(target, t3, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t4, anchor);
      insert(target, hr0, anchor);
      insert(target, t5, anchor);
      mount_component(field3, target, anchor);
      insert(target, t6, anchor);
      mount_component(field4, target, anchor);
      insert(target, t7, anchor);
      mount_component(field5, target, anchor);
      insert(target, t8, anchor);
      insert(target, hr1, anchor);
      insert(target, t9, anchor);
      mount_component(field6, target, anchor);
      insert(target, t10, anchor);
      insert(target, hr2, anchor);
      insert(target, t11, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span0);
      span0.innerHTML = SX_ICON_DROPDOWN;
      append(div0, t12);
      append(div0, span1);
      append(div0, t14);
      if (if_block1)
        if_block1.m(div0, null);
      append(div1, t15);
      if (if_block2)
        if_block2.m(div1, null);
      insert(target, t16, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[46]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty[0] & 4096)
        header_changes.subtitle = ctx2[12]?.name || "?";
      header.$set(header_changes);
      const field0_changes = {};
      if (dirty[0] & 8192 | dirty[1] & 134217728) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty[0] & 81 | dirty[1] & 134217728) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty[0] & 131624 | dirty[1] & 134217728) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      if (ctx2[9] && ctx2[5]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 544) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t4.parentNode, t4);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const field3_changes = {};
      if (dirty[0] & 2 | dirty[1] & 134217728) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty[0] & 1174 | dirty[1] & 134217728) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      const field5_changes = {};
      if (dirty[0] & 1574914 | dirty[1] & 134217728) {
        field5_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field5.$set(field5_changes);
      const field6_changes = {};
      if (dirty[0] & 262144 | dirty[1] & 134217728) {
        field6_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field6.$set(field6_changes);
      if (ctx2[14]) {
        if (if_block1) {
          if (dirty[0] & 16384) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$4();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[14]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & 16384) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block$b(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (dirty[0] & 16384) {
        toggle_class(div1, "expanded", ctx2[14]);
      }
      const actionsline_changes = {};
      if (dirty[0] & 65536)
        actionsline_changes.confirm = ["Next", ctx2[48], !ctx2[16]];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(if_block0);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(field5.$$.fragment, local);
      transition_in(field6.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(if_block0);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(field5.$$.fragment, local);
      transition_out(field6.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t3);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(hr0);
      if (detaching)
        detach(t5);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t6);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t7);
      destroy_component(field5, detaching);
      if (detaching)
        detach(t8);
      if (detaching)
        detach(hr1);
      if (detaching)
        detach(t9);
      destroy_component(field6, detaching);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(hr2);
      if (detaching)
        detach(t11);
      if (detaching)
        detach(div1);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (detaching)
        detach(t16);
      destroy_component(actionsline, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$v(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      form: true,
      slides: true,
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  screen.$on("submit", submit_handler);
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const screen_changes = {};
      if (dirty[0] & 2097151 | dirty[1] & 134217728) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
const si_versus = "usd";
let x_fee = 0.01;
const R_CONTACT_NAME = /^\S.{0,1023}$/;
const submit_handler = (d_submit) => {
  d_submit.preventDefault();
};
function instance$s($$self, $$props, $$invalidate) {
  let g_coin;
  let p_token;
  let s_symbol;
  let s_balance;
  let b_using_max;
  let si_coingecko;
  let s_fee_fiat;
  let g_address_type;
  let b_new_address;
  let s_err_new_contact;
  let b_form_valid;
  let $yw_network_active;
  let $yw_owner;
  let $yw_account;
  let $yw_chain;
  let $yw_account_ref;
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(35, $yw_network_active = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(36, $yw_owner = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(37, $yw_account = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(12, $yw_chain = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(53, $yw_account_ref = $$value));
  const k_page = getContext("page");
  let { sender = $yw_account } = $$props;
  let p_account = $yw_account_ref;
  let { native = Object.keys($yw_chain.coins)[0] } = $$props;
  let si_native = native;
  let { token = null } = $$props;
  let g_token2 = token;
  let { recipient = "" } = $$props;
  let sa_recipient = recipient;
  let p_asset = si_native ? Entities.holdingPathFor($yw_owner, si_native) : "";
  let h_addr_to_contact;
  let b_busy_agents = false;
  async function reload_agents(b_init = false) {
    if (b_busy_agents)
      return;
    b_busy_agents = true;
    const ks_agents = await Agents.read();
    const a_contacts = [...ks_agents.contacts()];
    $$invalidate(29, h_addr_to_contact = fold(a_contacts, ([p_contact, g_contact]) => ({
      [Chains.bech32(g_contact.address)]: p_contact
    })));
    b_busy_agents = false;
  }
  {
    const f_unsub_agents = subscribe_store("agents", reload_agents);
    const f_unsub_chain = yw_chain.subscribe(reload_agents);
    onDestroy(() => {
      f_unsub_agents();
      f_unsub_chain();
    });
  }
  let yg_balance = null;
  let s_amount = "";
  function use_max() {
    $$invalidate(2, s_amount = s_balance);
    if (g_coin) {
      $$invalidate(2, s_amount = new BigNumber(s_amount).minus(x_fee).toString());
    }
    $$invalidate(4, c_show_validations++, c_show_validations);
  }
  let x_worth = null;
  const H_ADDRESS_TYPES = {
    none: { icon: "<svg></svg>", text: "" },
    unknown: {
      icon: SX_ICON_LOADING,
      text: "Determining address type..."
    },
    personal: {
      icon: SX_ICON_CONTACTS,
      text: "Personal address"
    },
    contract: {
      icon: SX_ICON_CONTRACT,
      text: "Contract address"
    }
  };
  let si_address_type = "none";
  let b_memo_expanded = false;
  let s_memo = "";
  let b_submitted = false;
  function submit() {
    if (!b_form_valid) {
      $$invalidate(4, c_show_validations++, c_show_validations);
      return;
    } else {
      if (b_submitted)
        return false;
      b_submitted = true;
      if (si_native) {
        k_page.push({
          creator: SendNative,
          props: {
            accountRef: p_account,
            coin: si_native,
            recipient: sa_recipient,
            amount: s_amount,
            memo: s_memo,
            fee: x_fee + ""
          }
        });
      }
    }
  }
  let c_show_validations = 0;
  let b_checked_save_contact = false;
  let s_err_recipient = "";
  let s_err_amount = "";
  let s_new_contact = "";
  function input_new_contact(d_event) {
    $$invalidate(32, s_new_contact = d_event.target.value);
  }
  function senderselect_accountRef_binding(value) {
    p_account = value;
    $$invalidate(13, p_account);
  }
  function recipientselect_error_binding(value) {
    s_err_recipient = value;
    $$invalidate(6, s_err_recipient);
  }
  function recipientselect_address_binding(value) {
    sa_recipient = value;
    $$invalidate(0, sa_recipient);
  }
  function checkboxfield_checked_binding(value) {
    b_checked_save_contact = value;
    $$invalidate(5, b_checked_save_contact);
  }
  function assetselect_assetRef_binding(value) {
    p_asset = value;
    $$invalidate(1, p_asset);
  }
  function amountinput_error_binding(value) {
    s_err_amount = value;
    $$invalidate(7, s_err_amount);
  }
  function amountinput_value_binding(value) {
    s_amount = value;
    $$invalidate(2, s_amount);
  }
  const click_handler2 = () => use_max();
  const click_handler_1 = () => $$invalidate(14, b_memo_expanded = !b_memo_expanded);
  function textarea_input_handler() {
    s_memo = this.value;
    $$invalidate(15, s_memo);
  }
  const func = () => submit();
  $$self.$$set = ($$props2) => {
    if ("sender" in $$props2)
      $$invalidate(25, sender = $$props2.sender);
    if ("native" in $$props2)
      $$invalidate(26, native = $$props2.native);
    if ("token" in $$props2)
      $$invalidate(27, token = $$props2.token);
    if ("recipient" in $$props2)
      $$invalidate(28, recipient = $$props2.recipient);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4098) {
      $$invalidate(10, g_coin = p_asset && "holding" === Entities.parseEntityPath(p_asset)?.type && si_native ? $yw_chain.coins?.[si_native] : null);
    }
    if ($$self.$$.dirty[0] & 2) {
      $$invalidate(34, p_token = p_asset && "token" === Entities.parseEntityPath(p_asset)?.type && g_token2 ? Entities.pathFrom(g_token2) : "");
    }
    if ($$self.$$.dirty[0] & 1026 | $$self.$$.dirty[1] & 8) {
      {
        console.log({
          si_native,
          g_coin,
          p_asset,
          p_token,
          g_token: g_token2
        });
      }
    }
    if ($$self.$$.dirty[0] & 2 | $$self.$$.dirty[1] & 112) {
      {
        if ($yw_account && p_asset) {
          $$invalidate(30, yg_balance = null);
          queueMicrotask(async () => {
            $$invalidate(11, s_balance = "[...]");
            const g_cached = $yw_network_active.cachedBalance($yw_owner, si_native);
            if (g_cached && g_cached.timestamp > Date.now() - 5 * XT_MINUTES) {
              $$invalidate(30, yg_balance = new BigNumber(g_cached.data.amount));
            }
            const g_bundle = await $yw_network_active.bankBalance($yw_owner, si_native);
            if (g_bundle) {
              $$invalidate(30, yg_balance = new BigNumber(g_bundle.balance.amount));
            }
          });
        }
      }
    }
    if ($$self.$$.dirty[0] & 1073742848) {
      $$invalidate(11, s_balance = yg_balance ? format_amount(yg_balance.shiftedBy(-(g_coin || g_token2).decimals).toNumber()) : "");
    }
    if ($$self.$$.dirty[0] & 2052) {
      $$invalidate(19, b_using_max = s_amount === s_balance);
    }
    if ($$self.$$.dirty[0] & 1024) {
      $$invalidate(33, si_coingecko = (g_token2 || g_coin)?.extra?.coingecko_id || "");
    }
    if ($$self.$$.dirty[1] & 5) {
      {
        if (si_coingecko) {
          (async () => {
            const h_versus = await CoinGecko.coinsVersus([si_coingecko], si_versus);
            $$invalidate(31, x_worth = h_versus[si_coingecko]);
            if ("number" === typeof x_worth) {
              format_fiat(x_worth, si_versus);
            }
          })();
        }
      }
    }
    if ($$self.$$.dirty[1] & 1) {
      $$invalidate(18, s_fee_fiat = "number" === typeof x_worth ? format_fiat(x_fee * x_worth, "usd") : "");
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 16) {
      {
        if (!sa_recipient) {
          $$invalidate(3, si_address_type = "none");
        } else {
          $$invalidate(3, si_address_type = "unknown");
          (async () => {
            if (await $yw_network_active.isContract(sa_recipient)) {
              $$invalidate(3, si_address_type = "contract");
            } else {
              $$invalidate(3, si_address_type = "personal");
            }
          })();
        }
      }
    }
    if ($$self.$$.dirty[0] & 8) {
      $$invalidate(17, g_address_type = H_ADDRESS_TYPES[si_address_type]);
    }
    if ($$self.$$.dirty[0] & 536870913) {
      $$invalidate(9, b_new_address = sa_recipient && h_addr_to_contact && !(sa_recipient in h_addr_to_contact));
    }
    if ($$self.$$.dirty[0] & 48 | $$self.$$.dirty[1] & 2) {
      $$invalidate(8, s_err_new_contact = b_checked_save_contact && (c_show_validations || true) ? s_new_contact ? R_CONTACT_NAME.test(s_new_contact) ? "" : s_new_contact.length > 1024 ? "That name is way too long" : "Cannot begin with space" : "Enter a contact name to save new address" : "");
    }
    if ($$self.$$.dirty[0] & 48) {
      {
        if (b_checked_save_contact && !c_show_validations) {
          $$invalidate(8, s_err_new_contact = "");
        }
      }
    }
    if ($$self.$$.dirty[0] & 997 | $$self.$$.dirty[1] & 2) {
      $$invalidate(16, b_form_valid = sa_recipient && s_amount && !s_err_recipient && !s_err_amount && (!b_new_address || !b_checked_save_contact || s_new_contact && !s_err_new_contact) || false);
    }
    if ($$self.$$.dirty[0] & 197) {
      {
        console.log({
          to: sa_recipient,
          s_amount,
          s_err_recipient,
          s_err_amount
        });
      }
    }
  };
  $$invalidate(20, s_symbol = si_native || g_token2?.symbol || "");
  return [
    sa_recipient,
    p_asset,
    s_amount,
    si_address_type,
    c_show_validations,
    b_checked_save_contact,
    s_err_recipient,
    s_err_amount,
    s_err_new_contact,
    b_new_address,
    g_coin,
    s_balance,
    $yw_chain,
    p_account,
    b_memo_expanded,
    s_memo,
    b_form_valid,
    g_address_type,
    s_fee_fiat,
    b_using_max,
    s_symbol,
    g_token2,
    use_max,
    submit,
    input_new_contact,
    sender,
    native,
    token,
    recipient,
    h_addr_to_contact,
    yg_balance,
    x_worth,
    s_new_contact,
    si_coingecko,
    p_token,
    $yw_network_active,
    $yw_owner,
    $yw_account,
    senderselect_accountRef_binding,
    recipientselect_error_binding,
    recipientselect_address_binding,
    checkboxfield_checked_binding,
    assetselect_assetRef_binding,
    amountinput_error_binding,
    amountinput_value_binding,
    click_handler2,
    click_handler_1,
    textarea_input_handler,
    func
  ];
}
class Send extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$s,
      create_fragment$v,
      safe_not_equal,
      {
        sender: 25,
        native: 26,
        token: 27,
        recipient: 28
      },
      null,
      [-1, -1]
    );
  }
}
function create_fragment$u(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "\xA0";
      attr(div, "class", "gap no-margin svelte-1rn5flx");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class Gap extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$u, safe_not_equal, {});
  }
}
function as_amount(g_balance, g_coin) {
  const s_norm = g_balance.amount.padStart(g_coin.decimals + 2, "0");
  return s_norm.slice(0, -g_coin.decimals).replace(/^0+/, "0") + "." + s_norm.slice(-g_coin.decimals);
}
async function to_fiat(g_balance, g_coin, si_versus2 = "usd") {
  if ("0" === g_balance.amount)
    return new BigNumber(0);
  const si_gecko = g_coin.extra.coingecko_id;
  const g_versus = await CoinGecko.coinsVersus([si_gecko], si_versus2);
  return new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals).times(g_versus[si_gecko]);
}
async function coin_formats(g_balance, g_coin, si_versus2 = "usd") {
  const si_gecko = g_coin.extra.coingecko_id;
  const g_versus = await CoinGecko.coinsVersus([si_gecko], si_versus2);
  const x_worth = g_versus[si_gecko];
  const yg_balance = new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals).times(x_worth);
  return {
    versus: si_versus2,
    balance: yg_balance,
    fiat: yg_balance.times(x_worth).toNumber(),
    worth: x_worth
  };
}
function create_default_slot$f(ctx) {
  let header;
  let t0;
  let portrait;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      pops: true,
      account: true,
      network: true,
      title: ctx[3],
      subtitle: ctx[4]
    }
  });
  portrait = new Portrait({
    props: {
      pfp: ctx[2],
      resource: ctx[1] || g_token || null,
      resourcePath: ctx[8],
      title: ctx[5] ? `${format_amount(ctx[5].toNumber())} ${ctx[3]}` : "...",
      subtitle: `${ctx[6]} (${ctx[7]} per ${ctx[0]})`,
      actions: ctx[9],
      circular: true
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(portrait.$$.fragment);
      t1 = space();
      div = element("div");
      attr(div, "class", "txns no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(portrait, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & 8)
        header_changes.title = ctx2[3];
      if (dirty & 16)
        header_changes.subtitle = ctx2[4];
      header.$set(header_changes);
      const portrait_changes = {};
      if (dirty & 4)
        portrait_changes.pfp = ctx2[2];
      if (dirty & 2)
        portrait_changes.resource = ctx2[1] || g_token || null;
      if (dirty & 40)
        portrait_changes.title = ctx2[5] ? `${format_amount(ctx2[5].toNumber())} ${ctx2[3]}` : "...";
      if (dirty & 193)
        portrait_changes.subtitle = `${ctx2[6]} (${ctx2[7]} per ${ctx2[0]})`;
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
    }
  };
}
function create_fragment$t(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "HoldingView",
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 262399) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
let g_token = null;
function instance$r($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_network_active;
  let $yw_chain_ref;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(13, $yw_chain = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(14, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(15, $yw_chain_ref = $$value));
  const k_page = getContext("page");
  let { entityRef } = $$props;
  const p_entity = entityRef;
  let si_type = "";
  let si_coin = "";
  let g_coin = null;
  let p_pfp = "";
  let s_symbol = "";
  let s_name = "";
  let yg_amount = null;
  let s_fiat = "";
  let s_worth = "";
  async function load_entity() {
    await Entities.read();
    const g_info = Entities.parseEntityPath(p_entity);
    if (!g_info) {
      throw new Error(`Attempted to load holding view on non-entity path "${p_entity}"`);
    }
    switch (g_info.type) {
      case "holding": {
        $$invalidate(0, si_type = "coin");
        ({ coin: si_coin } = g_info);
        const p_chain = g_info.chainRef;
        const g_chain = p_chain === $yw_chain_ref ? $yw_chain : await Chains.at(p_chain);
        $$invalidate(1, g_coin = g_chain.coins[si_coin]);
        $$invalidate(3, s_symbol = si_coin);
        $$invalidate(4, s_name = g_coin.name);
        $$invalidate(2, p_pfp = g_coin.pfp);
        const g_cached = $yw_network_active.cachedBalance(g_info.bech32, si_coin);
        let g_balance;
        if (g_cached && g_cached.timestamp >= Date.now() - 2 * XT_MINUTES) {
          g_balance = g_cached.data;
        } else {
          ({ balance: g_balance } = await $yw_network_active.bankBalance(g_info.bech32, si_coin));
        }
        $$invalidate(5, yg_amount = new BigNumber(g_balance.amount).shiftedBy(-g_coin.decimals));
        void coin_formats(g_balance, g_coin).then((g_formats) => {
          $$invalidate(6, s_fiat = format_fiat(g_formats.fiat, g_formats.versus));
          $$invalidate(7, s_worth = format_fiat(g_formats.worth, g_formats.versus));
        });
        break;
      }
      case "token": {
        $$invalidate(0, si_type = "token");
        const ks_entites = await Entities.read();
        ks_entites.tokens(g_info.entityRef, Entities.fungibleInterfacesFor($yw_chain));
        debugger;
        break;
      }
      default: {
        throw new Error(`Unhandled entity type: "${g_info.type}"`);
      }
    }
  }
  load_entity();
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: si_coin ? { native: si_coin } : {}
        });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("entityRef" in $$props2)
      $$invalidate(10, entityRef = $$props2.entityRef);
  };
  return [
    si_type,
    g_coin,
    p_pfp,
    s_symbol,
    s_name,
    yg_amount,
    s_fiat,
    s_worth,
    p_entity,
    gc_actions,
    entityRef
  ];
}
class HoldingView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$t, safe_not_equal, { entityRef: 10 });
  }
}
function get_each_context$7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i][0];
  child_ctx[24] = list[i][1];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i][0];
  child_ctx[33] = list[i][1];
  child_ctx[34] = list[i][2];
  child_ctx[35] = list[i][3];
  const constants_0 = Entities.holdingPathFor(child_ctx[3], child_ctx[27]);
  child_ctx[29] = constants_0;
  const constants_1 = {
    name: child_ctx[27],
    pfp: child_ctx[0].pfp
  };
  child_ctx[36] = constants_1;
  const constants_2 = child_ctx[35](to_fiat(child_ctx[34], child_ctx[33]));
  child_ctx[37] = constants_2;
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i][0];
  child_ctx[28] = list[i][1];
  const constants_0 = Entities.holdingPathFor(child_ctx[3], child_ctx[27]);
  child_ctx[29] = constants_0;
  return child_ctx;
}
function create_if_block_2(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "TESETNET";
      attr(div, "class", "testnet-reminder no-margin svelte-8v4b7t");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block$a(ctx) {
  let div2;
  let div0;
  let span;
  let t1;
  let t2_value = ctx[0].testnet ? "testnet " : "";
  let t2;
  let t3_value = ctx[1].join(" or ") + "";
  let t3;
  let t4;
  let t5;
  let div1;
  function select_block_type(ctx2, dirty) {
    if (ctx2[0].testnet)
      return create_if_block_1$3;
    return create_else_block$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      span = element("span");
      span.textContent = "Warning:";
      t1 = text(" you don't have any ");
      t2 = text(t2_value);
      t3 = text(t3_value);
      t4 = text(" to pay gas fees.");
      t5 = space();
      div1 = element("div");
      if_block.c();
      attr(span, "class", "warning");
      attr(div0, "class", "message svelte-8v4b7t");
      attr(div1, "class", "buttons");
      attr(div2, "class", "no-gas text-align_center subinfo svelte-8v4b7t");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, span);
      append(div0, t1);
      append(div0, t2);
      append(div0, t3);
      append(div0, t4);
      append(div2, t5);
      append(div2, div1);
      if_block.m(div1, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t2_value !== (t2_value = ctx2[0].testnet ? "testnet " : ""))
        set_data(t2, t2_value);
      if (dirty[0] & 2 && t3_value !== (t3_value = ctx2[1].join(" or ") + ""))
        set_data(t3, t3_value);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div1, null);
        }
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      if_block.d();
    }
  };
}
function create_else_block$4(ctx) {
  let button;
  let t0;
  let t1_value = ctx[1].join(" or ") + "";
  let t1;
  return {
    c() {
      button = element("button");
      t0 = text("Buy ");
      t1 = text(t1_value);
      attr(button, "class", "pill");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t1_value !== (t1_value = ctx2[1].join(" or ") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
    }
  };
}
function create_if_block_1$3(ctx) {
  let button;
  let t0;
  let t1_value = ctx[1].join(" or ") + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      t0 = text("Get ");
      t1 = text(t1_value);
      t2 = text(" from faucet");
      attr(button, "class", "pill");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t0);
      append(button, t1);
      append(button, t2);
      if (!mounted) {
        dispose = listen(button, "click", ctx[14]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 2 && t1_value !== (t1_value = ctx2[1].join(" or ") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_key_block_1(ctx) {
  let t;
  let div;
  let address;
  let current;
  let if_block = ctx[1].length && create_if_block$a(ctx);
  address = new Address({
    props: {
      address: ctx[3],
      copyable: "text"
    }
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      create_component(address.$$.fragment);
      attr(div, "class", "owner-address subinfo svelte-8v4b7t");
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      mount_component(address, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[1].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$a(ctx2);
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const address_changes = {};
      if (dirty[0] & 8)
        address_changes.address = ctx2[3];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      destroy_component(address);
    }
  };
}
function create_catch_block_1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ctx[32];
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 777) {
        each_value_2 = ctx2[32];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_2(ctx) {
  let row;
  let current;
  function click_handler_2() {
    return ctx[17](ctx[29]);
  }
  row = new Row({
    props: {
      lockIcon: true,
      detail: "Native Coin",
      resourcePath: ctx[29],
      resource: ctx[36],
      amount: as_amount(ctx[34], ctx[33]),
      fiat: ctx[37].then(ctx[16])
    }
  });
  row.$on("click", click_handler_2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 8)
        row_changes.resourcePath = ctx[29];
      if (dirty[0] & 1)
        row_changes.resource = ctx[36];
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ode(ctx[0].coins);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 265) {
        each_value_1 = ode(ctx2[0].coins);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1$2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_1$2(ctx) {
  let row;
  let current;
  function click_handler_1() {
    return ctx[15](ctx[29]);
  }
  row = new Row({
    props: {
      lockIcon: true,
      detail: "Native Coin",
      name: ctx[27],
      pfp: ctx[0].pfp,
      amount: forever()
    }
  });
  row.$on("click", click_handler_1);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty[0] & 1)
        row_changes.name = ctx[27];
      if (dirty[0] & 1)
        row_changes.pfp = ctx[0].pfp;
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_catch_block$8(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$8(ctx) {
  let each_1_anchor;
  let each_value = ode(ctx[7](ctx[22]));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 129) {
        each_value = ode(ctx2[7](ctx2[22]));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$7(ctx) {
  let t_value = ctx[24].spec + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && t_value !== (t_value = ctx2[24].spec + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_pending_block$8(ctx) {
  let t;
  return {
    c() {
      t = text("Loading tokens...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_key_block$2(ctx) {
  let div;
  let t;
  let promise_1;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 32,
    blocks: [, , ,]
  };
  handle_promise(ctx[9](), info);
  let info_1 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$8,
    then: create_then_block$8,
    catch: create_catch_block$8,
    value: 22
  };
  handle_promise(promise_1 = Entities.readFungibleTokens(ctx[0]), info_1);
  return {
    c() {
      div = element("div");
      info.block.c();
      t = space();
      info_1.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t;
      append(div, t);
      info_1.block.m(div, info_1.anchor = null);
      info_1.mount = () => div;
      info_1.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      info_1.ctx = ctx;
      if (dirty[0] & 1 && promise_1 !== (promise_1 = Entities.readFungibleTokens(ctx[0])) && handle_promise(promise_1, info_1))
        ;
      else {
        update_await_block_branch(info_1, ctx, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
      info_1.block.d();
      info_1.token = null;
      info_1 = null;
    }
  };
}
function create_default_slot$e(ctx) {
  let header;
  let t0;
  let t1;
  let portrait;
  let t2;
  let previous_key = ctx[0];
  let t3;
  let gap;
  let t4;
  let previous_key_1 = ctx[4];
  let key_block1_anchor;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  let if_block = ctx[0].testnet && create_if_block_2();
  portrait = new Portrait({
    props: {
      noPfp: true,
      title: ctx[2],
      subtitle: ctx[5].name,
      resource: ctx[5],
      resourcePath: ctx[6],
      actions: {
        send: { label: "Send", trigger: ctx[12] },
        recv: {
          label: "Receive",
          trigger: ctx[13]
        }
      }
    }
  });
  let key_block0 = create_key_block_1(ctx);
  gap = new Gap({});
  let key_block1 = create_key_block$2(ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(portrait.$$.fragment);
      t2 = space();
      key_block0.c();
      t3 = space();
      create_component(gap.$$.fragment);
      t4 = space();
      key_block1.c();
      key_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      mount_component(portrait, target, anchor);
      insert(target, t2, anchor);
      key_block0.m(target, anchor);
      insert(target, t3, anchor);
      mount_component(gap, target, anchor);
      insert(target, t4, anchor);
      key_block1.m(target, anchor);
      insert(target, key_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[0].testnet) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_2();
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const portrait_changes = {};
      if (dirty[0] & 4)
        portrait_changes.title = ctx2[2];
      if (dirty[0] & 32)
        portrait_changes.subtitle = ctx2[5].name;
      if (dirty[0] & 32)
        portrait_changes.resource = ctx2[5];
      if (dirty[0] & 64)
        portrait_changes.resourcePath = ctx2[6];
      if (dirty[0] & 96)
        portrait_changes.actions = {
          send: { label: "Send", trigger: ctx2[12] },
          recv: {
            label: "Receive",
            trigger: ctx2[13]
          }
        };
      portrait.$set(portrait_changes);
      if (dirty[0] & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block0, 1, 1, noop);
        check_outros();
        key_block0 = create_key_block_1(ctx2);
        key_block0.c();
        transition_in(key_block0, 1);
        key_block0.m(t3.parentNode, t3);
      } else {
        key_block0.p(ctx2, dirty);
      }
      if (dirty[0] & 16 && safe_not_equal(previous_key_1, previous_key_1 = ctx2[4])) {
        group_outros();
        transition_out(key_block1, 1, 1, noop);
        check_outros();
        key_block1 = create_key_block$2(ctx2);
        key_block1.c();
        transition_in(key_block1, 1);
        key_block1.m(key_block1_anchor.parentNode, key_block1_anchor);
      } else {
        key_block1.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(portrait.$$.fragment, local);
      transition_in(key_block0);
      transition_in(gap.$$.fragment, local);
      transition_in(key_block1);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(portrait.$$.fragment, local);
      transition_out(key_block0);
      transition_out(gap.$$.fragment, local);
      transition_out(key_block1);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t2);
      key_block0.d(detaching);
      if (detaching)
        detach(t3);
      destroy_component(gap, detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(key_block1_anchor);
      key_block1.d(detaching);
    }
  };
}
function create_fragment$s(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "HoldingsHome",
      nav: true,
      root: true,
      keyed: true,
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const screen_changes = {};
      if (dirty[0] & 127 | dirty[1] & 512) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let $yw_chain;
  let $yw_owner;
  let $yw_network_active;
  let $yw_account;
  let $yw_account_ref;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(0, $yw_chain = $$value));
  component_subscribe($$self, yw_owner, ($$value) => $$invalidate(3, $yw_owner = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(4, $yw_network_active = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(5, $yw_account = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(6, $yw_account_ref = $$value));
  const merge_fungible_tokens = (h_fungibles) => oderom(h_fungibles, (_, h) => h);
  const k_page = getContext("page");
  let yg_total = new BigNumber(0);
  let c_balances = 0;
  let a_no_gas = [];
  let fk_resolve_total;
  let dp_total = new Promise((fk_resolve) => {
    fk_resolve_total = fk_resolve;
  });
  let g_chain_cached = $yw_chain;
  function check_total() {
    c_balances -= 1;
    if (!c_balances) {
      const s_total = format_fiat(yg_total.toNumber(), "usd");
      fk_resolve_total(s_total);
      const g_account = $yw_account;
      void Accounts.open((ks) => ks.put({
        ...g_account,
        extra: { total_fiat_cache: s_total }
      }));
    }
  }
  async function load_native_balances() {
    let h_balances;
    try {
      h_balances = await $yw_network_active.bankBalances($yw_owner);
    } catch (e_network) {
      syserr({ error: e_network, text: "Network error" });
      return [];
    }
    const a_outs = [];
    for (const [si_coin, g_coin] of ode($yw_chain.coins)) {
      const g_bundle = h_balances[si_coin];
      if (!g_bundle || "0" === g_bundle.balance.amount) {
        a_no_gas.push(si_coin);
      }
      c_balances += 1;
      a_outs.push([
        si_coin,
        $yw_chain.coins[si_coin],
        g_bundle?.balance || { amount: "0", denom: g_coin.denom },
        async (z_out) => {
          const yg_balance = await z_out;
          yg_total = yg_total.plus(yg_balance);
          check_total();
          return yg_balance;
        }
      ]);
    }
    if (!a_outs.length) {
      c_balances += 1;
      check_total();
    }
    $$invalidate(1, a_no_gas), $$invalidate(0, $yw_chain), $$invalidate(11, g_chain_cached);
    return a_outs;
  }
  const H_FAUCETS = {
    "theta-testnet-001": "https://discord.com/channels/669268347736686612/953697793476821092",
    "pulsar-2": "https://faucet.secrettestnet.io/"
  };
  const func = function() {
    k_page.push({
      creator: Send,
      props: { from: $yw_account }
    });
  };
  const func_12 = function() {
    popup_receive($yw_account_ref);
  };
  const click_handler2 = () => open_external_link(H_FAUCETS[$yw_chain.id]);
  const click_handler_1 = (p_entity) => {
    k_page.push({
      creator: HoldingView,
      props: { entityRef: p_entity }
    });
  };
  const func_2 = (yg) => format_fiat(yg.toNumber(), "usd");
  const click_handler_2 = (p_entity) => {
    k_page.push({
      creator: HoldingView,
      props: { entityRef: p_entity }
    });
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2049) {
      {
        if ($yw_chain !== g_chain_cached) {
          $$invalidate(11, g_chain_cached = $yw_chain);
          yg_total = new BigNumber(0);
          c_balances = 0;
          $$invalidate(2, dp_total = new Promise((fk_resolve) => {
            fk_resolve_total = fk_resolve;
          }));
          $$invalidate(1, a_no_gas = []);
        }
      }
    }
  };
  return [
    $yw_chain,
    a_no_gas,
    dp_total,
    $yw_owner,
    $yw_network_active,
    $yw_account,
    $yw_account_ref,
    merge_fungible_tokens,
    k_page,
    load_native_balances,
    H_FAUCETS,
    g_chain_cached,
    func,
    func_12,
    click_handler2,
    click_handler_1,
    func_2,
    click_handler_2
  ];
}
class HoldingsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$s, safe_not_equal, {}, null, [-1, -1]);
  }
}
function create_catch_block$7(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$7(ctx) {
  let field0;
  let t0;
  let field1;
  let t1;
  let field2;
  let t2;
  let actionsline;
  let current;
  field0 = new Field({
    props: {
      key: "profile-icon",
      name: "Profile icon"
    }
  });
  field1 = new Field({
    props: {
      key: "account-name",
      name: "Name",
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      key: "account-address",
      name: "Public address",
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      cancel: !ctx[4],
      back: true,
      confirm: ["Finish", ctx[6], !ctx[3]]
    }
  });
  return {
    c() {
      create_component(field0.$$.fragment);
      t0 = space();
      create_component(field1.$$.fragment);
      t1 = space();
      create_component(field2.$$.fragment);
      t2 = space();
      create_component(actionsline.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field0, target, anchor);
      insert(target, t0, anchor);
      mount_component(field1, target, anchor);
      insert(target, t1, anchor);
      mount_component(field2, target, anchor);
      insert(target, t2, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field1_changes = {};
      if (dirty & 8194) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 8196) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const actionsline_changes = {};
      if (dirty & 8)
        actionsline_changes.confirm = ["Finish", ctx2[6], !ctx2[3]];
      actionsline.$set(actionsline_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t2);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(input, "id", "account-name");
      attr(input, "type", "text");
      attr(input, "placeholder", "Satoshi");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      if (!mounted) {
        dispose = listen(input, "input", ctx[9]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2$3(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: ctx[2]
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 4)
        address_changes.address = ctx2[2];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_default_slot_1$5(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      address: true,
      key: "account-address",
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 8196) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_pending_block$7(ctx) {
  let t;
  return {
    c() {
      t = text("Loading accounts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$d(ctx) {
  let h3;
  let t0_value = ctx[0] ? "Edit" : "New";
  let t0;
  let t1;
  let t2;
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$7,
    then: create_then_block$7,
    catch: create_catch_block$7,
    blocks: [, , ,]
  };
  handle_promise(ctx[5](), info);
  return {
    c() {
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = text(" account");
      t2 = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      append(h3, t0);
      append(h3, t1);
      insert(target, t2, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[0] ? "Edit" : "New"))
        set_data(t0, t0_value);
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$r(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8207) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  let b_form_valid;
  let $yw_account_ref;
  let $yw_chain;
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(10, $yw_account_ref = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(8, $yw_chain = $$value));
  let { account } = $$props;
  const p_account = account;
  let g_account;
  let s_name = "";
  let sa_account;
  const completed = getContext("completed");
  const k_page = getContext("page");
  async function load_account() {
    const ks_accounts = await Accounts.read();
    $$invalidate(7, g_account = ks_accounts.at(p_account));
    $$invalidate(1, s_name = g_account.name);
  }
  async function save_account() {
    Object.assign(g_account, { name: s_name });
    await Accounts.open((ks_accounts) => ks_accounts.put(g_account));
    if (p_account === $yw_account_ref) {
      set_store_value(yw_account_ref, $yw_account_ref = p_account, $yw_account_ref);
    }
    if (completed) {
      completed(true);
    } else {
      k_page.reset();
    }
  }
  function input_input_handler() {
    s_name = this.value;
    $$invalidate(1, s_name);
  }
  $$self.$$set = ($$props2) => {
    if ("account" in $$props2)
      $$invalidate(0, account = $$props2.account);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $$invalidate(3, b_form_valid = !!s_name);
    }
    if ($$self.$$.dirty & 384) {
      $$invalidate(2, sa_account = g_account ? Chains.addressFor(g_account.pubkey, $yw_chain) : "");
    }
  };
  return [
    account,
    s_name,
    sa_account,
    b_form_valid,
    completed,
    load_account,
    save_account,
    g_account,
    $yw_chain,
    input_input_handler
  ];
}
class AccountEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$r, safe_not_equal, { account: 0 });
  }
}
function create_catch_block$6(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$6(ctx) {
  let portrait;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[1],
      actions: ctx[3],
      $$slots: { subtitle: [create_subtitle_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portrait.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 65) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
    }
  };
}
function create_subtitle_slot$2(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: Chains.addressFor(ctx[0].pubkey)
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = Chains.addressFor(ctx2[0].pubkey);
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_pending_block$6(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$c(ctx) {
  let header;
  let t;
  let await_block_anchor;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      title: "Account"
    }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$6,
    then: create_then_block$6,
    catch: create_catch_block$6,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t);
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$q(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 65) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let { accountRef } = $$props;
  const p_account = accountRef;
  let g_account;
  const k_page = getContext("page");
  async function load_account() {
    const ks_accounts = await Accounts.read();
    return $$invalidate(0, g_account = ks_accounts.at(p_account));
  }
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: {
            from: Chains.addressFor(g_account.pubkey)
          }
        });
      }
    },
    recv: {
      label: "Receive",
      trigger() {
        popup_receive(p_account);
      }
    },
    edit: {
      label: "Edit",
      trigger() {
        k_page.push({
          creator: AccountEdit,
          props: { account: p_account }
        });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("accountRef" in $$props2)
      $$invalidate(4, accountRef = $$props2.accountRef);
  };
  return [g_account, p_account, load_account, gc_actions, accountRef];
}
class AccountView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$q, safe_not_equal, { accountRef: 4 });
  }
}
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i][0];
  child_ctx[6] = list[i][1];
  const constants_0 = Chains.addressFor(child_ctx[6].pubkey);
  child_ctx[7] = constants_0;
  return child_ctx;
}
function create_catch_block$5(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$5(ctx) {
  let previous_key = ctx[1];
  let key_block_anchor;
  let current;
  let key_block = create_key_block$1(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 2 && safe_not_equal(previous_key, previous_key = ctx2[1])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block$1(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_detail_slot$1(ctx) {
  let div;
  let t1;
  let address;
  let t2;
  let current;
  address = new Address({ props: { address: ctx[7] } });
  return {
    c() {
      div = element("div");
      div.textContent = "StarShell - - m/44'/118'/0'/0/??";
      t1 = space();
      create_component(address.$$.fragment);
      t2 = space();
      attr(div, "class", "hd-path");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t1, anchor);
      mount_component(address, target, anchor);
      insert(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = ctx2[7];
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t1);
      destroy_component(address, detaching);
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block$6(ctx) {
  let row;
  let current;
  function click_handler2() {
    return ctx[4](ctx[5]);
  }
  row = new Row({
    props: {
      resource: ctx[6],
      resourcePath: ctx[5],
      address: ctx[7],
      iconClass: "square pfp",
      $$slots: { detail: [create_detail_slot$1] },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1)
        row_changes.resource = ctx[6];
      if (dirty & 1)
        row_changes.resourcePath = ctx[5];
      if (dirty & 1)
        row_changes.address = ctx[7];
      if (dirty & 1025) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_key_block$1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 5) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_pending_block$5(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$b(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "Accounts" } });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$5,
    then: create_then_block$5,
    catch: create_catch_block$5,
    blocks: [, , ,]
  };
  handle_promise(ctx[3](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$p(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Accounts",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1027) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let $yw_chain;
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(1, $yw_chain = $$value));
  const k_page = getContext("page");
  let a_accounts;
  async function load_accounts() {
    const ks_accounts = await Accounts.read();
    return $$invalidate(0, a_accounts = ks_accounts.entries());
  }
  const click_handler2 = (p_account) => k_page.push({
    creator: AccountView,
    props: { accountRef: p_account }
  });
  return [a_accounts, $yw_chain, k_page, load_accounts, click_handler2];
}
class AccountsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$p, safe_not_equal, {});
  }
}
let id = 1;
function getId() {
  return `svelte-tabs-${id++}`;
}
function create_fragment$o(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr(div, "class", "svelte-tabs");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "keydown", ctx[1]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
const TABS = {};
function removeAndUpdateSelected(arr, item, selectedStore) {
  const index = arr.indexOf(item);
  arr.splice(index, 1);
  selectedStore.update((selected) => selected === item ? arr[index] || arr[arr.length - 1] : selected);
}
function instance$m($$self, $$props, $$invalidate) {
  let $selectedTab;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { initialSelectedIndex = 0 } = $$props;
  const tabElements = [];
  const tabs = [];
  const panels = [];
  const controls = writable({});
  const labeledBy = writable({});
  const selectedTab = writable(null);
  component_subscribe($$self, selectedTab, (value) => $$invalidate(5, $selectedTab = value));
  const selectedPanel = writable(null);
  function registerItem(arr, item, selectedStore) {
    arr.push(item);
    selectedStore.update((selected) => selected || item);
    onDestroy(() => removeAndUpdateSelected(arr, item, selectedStore));
  }
  function selectTab(tab) {
    const index = tabs.indexOf(tab);
    selectedTab.set(tab);
    selectedPanel.set(panels[index]);
  }
  setContext(TABS, {
    registerTab(tab) {
      registerItem(tabs, tab, selectedTab);
    },
    registerTabElement(tabElement) {
      tabElements.push(tabElement);
    },
    registerPanel(panel) {
      registerItem(panels, panel, selectedPanel);
    },
    selectTab,
    selectedTab,
    selectedPanel,
    controls,
    labeledBy
  });
  onMount(() => {
    selectTab(tabs[initialSelectedIndex]);
  });
  afterUpdate(() => {
    for (let i = 0; i < tabs.length; i++) {
      controls.update((controlsData) => ({
        ...controlsData,
        [tabs[i].id]: panels[i].id
      }));
      labeledBy.update((labeledByData) => ({
        ...labeledByData,
        [panels[i].id]: tabs[i].id
      }));
    }
  });
  async function handleKeyDown(event) {
    if (event.target.classList.contains("svelte-tabs__tab")) {
      let selectedIndex = tabs.indexOf($selectedTab);
      switch (event.key) {
        case "ArrowRight":
          selectedIndex += 1;
          if (selectedIndex > tabs.length - 1) {
            selectedIndex = 0;
          }
          selectTab(tabs[selectedIndex]);
          tabElements[selectedIndex].focus();
          break;
        case "ArrowLeft":
          selectedIndex -= 1;
          if (selectedIndex < 0) {
            selectedIndex = tabs.length - 1;
          }
          selectTab(tabs[selectedIndex]);
          tabElements[selectedIndex].focus();
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("initialSelectedIndex" in $$props2)
      $$invalidate(2, initialSelectedIndex = $$props2.initialSelectedIndex);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [selectedTab, handleKeyDown, initialSelectedIndex, $$scope, slots];
}
class Tabs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$o, safe_not_equal, { initialSelectedIndex: 2 });
  }
}
function create_fragment$n(ctx) {
  let li;
  let li_aria_controls_value;
  let li_tabindex_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  return {
    c() {
      li = element("li");
      if (default_slot)
        default_slot.c();
      attr(li, "role", "tab");
      attr(li, "id", ctx[3].id);
      attr(li, "aria-controls", li_aria_controls_value = ctx[2][ctx[3].id]);
      attr(li, "aria-selected", ctx[1]);
      attr(li, "tabindex", li_tabindex_value = ctx[1] ? 0 : -1);
      attr(li, "class", "svelte-tabs__tab svelte-1fbofsd");
      toggle_class(li, "svelte-tabs__selected", ctx[1]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (default_slot) {
        default_slot.m(li, null);
      }
      ctx[10](li);
      current = true;
      if (!mounted) {
        dispose = listen(li, "click", ctx[11]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4 && li_aria_controls_value !== (li_aria_controls_value = ctx2[2][ctx2[3].id])) {
        attr(li, "aria-controls", li_aria_controls_value);
      }
      if (!current || dirty & 2) {
        attr(li, "aria-selected", ctx2[1]);
      }
      if (!current || dirty & 2 && li_tabindex_value !== (li_tabindex_value = ctx2[1] ? 0 : -1)) {
        attr(li, "tabindex", li_tabindex_value);
      }
      if (dirty & 2) {
        toggle_class(li, "svelte-tabs__selected", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let $selectedTab;
  let $controls;
  let { $$slots: slots = {}, $$scope } = $$props;
  let tabEl;
  const tab = { id: getId() };
  const { registerTab, registerTabElement, selectTab, selectedTab, controls } = getContext(TABS);
  component_subscribe($$self, selectedTab, (value) => $$invalidate(7, $selectedTab = value));
  component_subscribe($$self, controls, (value) => $$invalidate(2, $controls = value));
  let isSelected;
  registerTab(tab);
  onMount(async () => {
    await tick();
    registerTabElement(tabEl);
  });
  function li_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tabEl = $$value;
      $$invalidate(0, tabEl);
    });
  }
  const click_handler2 = () => selectTab(tab);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(1, isSelected = $selectedTab === tab);
    }
  };
  return [
    tabEl,
    isSelected,
    $controls,
    tab,
    selectTab,
    selectedTab,
    controls,
    $selectedTab,
    $$scope,
    slots,
    li_binding,
    click_handler2
  ];
}
class Tab extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$n, safe_not_equal, {});
  }
}
function create_fragment$m(ctx) {
  let ul;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      attr(ul, "role", "tablist");
      attr(ul, "class", "svelte-tabs__tab-list svelte-12yby2a");
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
class TabList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$m, safe_not_equal, {});
  }
}
function create_if_block$9(ctx) {
  let current;
  const default_slot_template = ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[5], null);
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[5],
            !current ? get_all_dirty_from_scope(ctx2[5]) : get_slot_changes(default_slot_template, ctx2[5], dirty, null),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let div;
  let div_aria_labelledby_value;
  let current;
  let if_block = ctx[1] === ctx[2] && create_if_block$9(ctx);
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "id", ctx[2].id);
      attr(div, "aria-labelledby", div_aria_labelledby_value = ctx[0][ctx[2].id]);
      attr(div, "class", "svelte-tabs__tab-panel svelte-epfyet");
      attr(div, "role", "tabpanel");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[1] === ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 1 && div_aria_labelledby_value !== (div_aria_labelledby_value = ctx2[0][ctx2[2].id])) {
        attr(div, "aria-labelledby", div_aria_labelledby_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let $labeledBy;
  let $selectedPanel;
  let { $$slots: slots = {}, $$scope } = $$props;
  const panel = { id: getId() };
  const { registerPanel, selectedPanel, labeledBy } = getContext(TABS);
  component_subscribe($$self, selectedPanel, (value) => $$invalidate(1, $selectedPanel = value));
  component_subscribe($$self, labeledBy, (value) => $$invalidate(0, $labeledBy = value));
  registerPanel(panel);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  return [$labeledBy, $selectedPanel, panel, selectedPanel, labeledBy, $$scope, slots];
}
class TabPanel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$l, safe_not_equal, {});
  }
}
var SX_ICON_ASTRONAUT = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M64 224h13.5c24.7 56.5 80.9 96 146.5 96s121.8-39.5 146.5-96H384c8.8 0 16-7.2 16-16v-96c0-8.8-7.2-16-16-16h-13.5C345.8 39.5 289.6 0 224 0S102.2 39.5 77.5 96H64c-8.8 0-16 7.2-16 16v96c0 8.8 7.2 16 16 16zm40-88c0-22.1 21.5-40 48-40h144c26.5 0 48 17.9 48 40v24c0 53-43 96-96 96h-48c-53 0-96-43-96-96v-24zm72 72l12-36 36-12-36-12-12-36-12 36-36 12 36 12 12 36zm151.6 113.4C297.7 340.7 262.2 352 224 352s-73.7-11.3-103.6-30.6C52.9 328.5 0 385 0 454.4v9.6c0 26.5 21.5 48 48 48h80v-64c0-17.7 14.3-32 32-32h128c17.7 0 32 14.3 32 32v64h80c26.5 0 48-21.5 48-48v-9.6c0-69.4-52.9-125.9-120.4-133zM272 448c-8.8 0-16 7.2-16 16s7.2 16 16 16 16-7.2 16-16-7.2-16-16-16zm-96 0c-8.8 0-16 7.2-16 16v48h32v-48c0-8.8-7.2-16-16-16z"/></svg>';
function create_default_slot$a(ctx) {
  let header;
  let t0;
  let h3;
  let t2;
  let p0;
  let t4;
  let p1;
  let t6;
  let center;
  let span;
  let t7;
  let div;
  let button;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: { pops: true, title: "Not yet available" }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      h3 = element("h3");
      h3.textContent = "Nothing to see here!";
      t2 = space();
      p0 = element("p");
      p0.textContent = "This screen has not yet been implemented.";
      t4 = space();
      p1 = element("p");
      p1.textContent = "Please continue exploring the beta.";
      t6 = space();
      center = element("center");
      span = element("span");
      t7 = space();
      div = element("div");
      button = element("button");
      button.textContent = "Continue";
      attr(span, "class", "icon svelte-o7n71o");
      attr(button, "class", "primary");
      attr(div, "class", "action-line");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, h3, anchor);
      insert(target, t2, anchor);
      insert(target, p0, anchor);
      insert(target, t4, anchor);
      insert(target, p1, anchor);
      insert(target, t6, anchor);
      insert(target, center, anchor);
      append(center, span);
      span.innerHTML = SX_ICON_ASTRONAUT;
      insert(target, t7, anchor);
      insert(target, div, anchor);
      append(div, button);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[2]);
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(center);
      if (detaching)
        detach(t7);
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$k(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 64) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let $yw_navigator;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(3, $yw_navigator = $$value));
  let { reset = false } = $$props;
  const b_reset = reset;
  const k_page = getContext("page");
  function cont() {
    if (b_reset) {
      k_page.reset();
      void $yw_navigator.activateThread(ThreadId.TOKENS);
    } else {
      k_page.pop();
    }
  }
  const click_handler2 = () => cont();
  $$self.$$set = ($$props2) => {
    if ("reset" in $$props2)
      $$invalidate(1, reset = $$props2.reset);
  };
  return [cont, reset, click_handler2];
}
class DeadEnd extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$k, safe_not_equal, { reset: 1 });
  }
}
function create_else_block$3(ctx) {
  let portrait;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[1],
      actions: ctx[2],
      $$slots: {
        subtitle: [create_subtitle_slot$1],
        default: [create_default_slot_1$4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portrait.$$.fragment);
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 65) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
    }
  };
}
function create_if_block$8(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contact...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let t;
  return {
    c() {
      t = text("address");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_subtitle_slot$1(ctx) {
  let address;
  let current;
  address = new Address({
    props: {
      copyable: true,
      address: Chains.bech32(ctx[0].address)
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const address_changes = {};
      if (dirty & 1)
        address_changes.address = Chains.bech32(ctx2[0].address);
      address.$set(address_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
    }
  };
}
function create_default_slot$9(ctx) {
  let header;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      account: true
    }
  });
  const if_block_creators = [create_if_block$8, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[0])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t = space();
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$j(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 65) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  let { contactRef } = $$props;
  const p_contact = contactRef;
  let g_contact;
  void Agents.getContact(p_contact).then((g) => $$invalidate(0, g_contact = g));
  const k_page = getContext("page");
  const gc_actions = {
    send: {
      label: "Send",
      trigger() {
        k_page.push({
          creator: Send,
          props: { to: Chains.bech32(g_contact.address) }
        });
      }
    },
    edit: {
      label: "Edit",
      trigger() {
        k_page.push({
          creator: ContactEdit,
          props: { contactRef: p_contact }
        });
      }
    },
    delete: {
      label: "Delete",
      trigger() {
        k_page.push({ creator: DeadEnd });
      }
    }
  };
  $$self.$$set = ($$props2) => {
    if ("contactRef" in $$props2)
      $$invalidate(3, contactRef = $$props2.contactRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      g_contact ? Chains.bech32(g_contact.address) : "";
    }
  };
  return [g_contact, p_contact, gc_actions, contactRef];
}
class ContactView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$h, create_fragment$j, safe_not_equal, { contactRef: 3 });
  }
}
var SX_ICON_IMAGE = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/>\n</svg>';
function create_if_block$7(ctx) {
  let pfpdisplay;
  let current;
  pfpdisplay = new PfpDisplay({
    props: {
      dim: 48,
      ref: ctx[0],
      name: ctx[1]
    }
  });
  return {
    c() {
      create_component(pfpdisplay.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pfpdisplay, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(pfpdisplay.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pfpdisplay.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pfpdisplay, detaching);
    }
  };
}
function create_fragment$i(ctx) {
  let div4;
  let div3;
  let span0;
  let t0;
  let span5;
  let div0;
  let t4;
  let div2;
  let div1;
  let span3;
  let t5;
  let span4;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] && create_if_block$7(ctx);
  return {
    c() {
      div4 = element("div");
      div3 = element("div");
      span0 = element("span");
      if (if_block)
        if_block.c();
      t0 = space();
      span5 = element("span");
      div0 = element("div");
      div0.innerHTML = `<span class="warning svelte-1i7pjsy">Notice:</span> 
				<span class="info">Uploaded icons will be resized to be square. Only JPG &amp; PNG files less than 1MB allowed.</span>`;
      t4 = space();
      div2 = element("div");
      div1 = element("div");
      span3 = element("span");
      t5 = space();
      span4 = element("span");
      span4.textContent = "Upload Icon";
      attr(span0, "class", "left svelte-1i7pjsy");
      attr(div0, "class", "disclaimer svelte-1i7pjsy");
      attr(span3, "class", "icon svelte-1i7pjsy");
      attr(span4, "class", "text svelte-1i7pjsy");
      attr(div1, "class", "upload svelte-1i7pjsy");
      attr(div2, "class", "actions svelte-1i7pjsy");
      attr(span5, "class", "right svelte-1i7pjsy");
      attr(div3, "class", "row svelte-1i7pjsy");
      attr(div4, "class", "area svelte-1i7pjsy");
      toggle_class(div4, "intent-person", "person" === ctx[2]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div3);
      append(div3, span0);
      if (if_block)
        if_block.m(span0, null);
      append(div3, t0);
      append(div3, span5);
      append(span5, div0);
      append(span5, t4);
      append(span5, div2);
      append(div2, div1);
      append(div1, span3);
      span3.innerHTML = SX_ICON_IMAGE;
      append(div1, t5);
      append(div1, span4);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (ctx2[0])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { pfpRef } = $$props;
  const p_pfp = pfpRef || "";
  let { name = "" } = $$props;
  const s_name = name;
  let { intent = "token" } = $$props;
  const si_intent = intent;
  (async () => {
    if (p_pfp) {
      await Pfps.at(p_pfp);
    }
  })();
  const click_handler2 = () => F_NOOP;
  $$self.$$set = ($$props2) => {
    if ("pfpRef" in $$props2)
      $$invalidate(3, pfpRef = $$props2.pfpRef);
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("intent" in $$props2)
      $$invalidate(5, intent = $$props2.intent);
  };
  return [p_pfp, s_name, si_intent, pfpRef, name, intent, click_handler2];
}
class IconEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$i, safe_not_equal, { pfpRef: 3, name: 4, intent: 5 });
  }
}
function create_default_slot_6$1(ctx) {
  let iconeditor;
  let updating_name;
  let current;
  function iconeditor_name_binding(value) {
    ctx[17](value);
  }
  let iconeditor_props = {
    intent: "person",
    pfpRef: ctx[0]?.pfp
  };
  if (ctx[1] !== void 0) {
    iconeditor_props.name = ctx[1];
  }
  iconeditor = new IconEditor({ props: iconeditor_props });
  binding_callbacks.push(() => bind(iconeditor, "name", iconeditor_name_binding));
  return {
    c() {
      create_component(iconeditor.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconeditor, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const iconeditor_changes = {};
      if (dirty & 1)
        iconeditor_changes.pfpRef = ctx2[0]?.pfp;
      if (!updating_name && dirty & 2) {
        updating_name = true;
        iconeditor_changes.name = ctx2[1];
        add_flush_callback(() => updating_name = false);
      }
      iconeditor.$set(iconeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(iconeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconeditor, detaching);
    }
  };
}
function create_default_slot_5$2(ctx) {
  let style;
  let t1;
  let span0;
  let t2_value = proper(ctx[9]) + "";
  let t2;
  let t3;
  let span1;
  let t4;
  let t5_value = ode(ctx[3]).filter(ctx[18]).map(func_1).join(", ") + "";
  let t5;
  let t6;
  return {
    c() {
      style = element("style");
      style.textContent = ".font-family_mono {\n  font-family: 'PT Mono';\n  white-space: pre;\n}\n.hide-scrollbar {\n  scrollbar-width: none;\n}\n.hide-scrollbar::-webkit-scrollbar {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-track {\n  display: none;\n}\n.hide-scrollbar::-webkit-scrollbar-thumb {\n  background-color: rgba(0, 0, 0, 0.2);\n}\n.title {\n  font-family: Poppins;\n  font-weight: 400;\n  font-size: 14px;\n  color: var(--theme-color-text-light);\n}\n.examples {\n  margin-left: 0.5em;\n}";
      t1 = space();
      span0 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span1 = element("span");
      t4 = text("(");
      t5 = text(t5_value);
      t6 = text(")");
      attr(style, "lang", "less");
      attr(span0, "class", "title");
      attr(span1, "class", "examples");
    },
    m(target, anchor) {
      insert(target, style, anchor);
      insert(target, t1, anchor);
      insert(target, span0, anchor);
      append(span0, t2);
      insert(target, t3, anchor);
      insert(target, span1, anchor);
      append(span1, t4);
      append(span1, t5);
      append(span1, t6);
    },
    p(ctx2, dirty) {
      if (dirty & 512 && t2_value !== (t2_value = proper(ctx2[9]) + ""))
        set_data(t2, t2_value);
      if (dirty & 520 && t5_value !== (t5_value = ode(ctx2[3]).filter(ctx2[18]).map(func_1).join(", ") + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching)
        detach(style);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(span0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(span1);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "chain-family",
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 268435976) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_if_block_1$2(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[4]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 16)
        set_data(t, ctx2[4]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[4] && create_if_block_1$2(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Enter a name");
      toggle_class(input, "invalid", ctx[4]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[1]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[19]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 2 && input.value !== ctx2[1]) {
        set_input_value(input, ctx2[1]);
      }
      if (dirty & 16) {
        toggle_class(input, "invalid", ctx2[4]);
      }
      if (ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$6(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(ctx[5]);
      attr(span, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & 32)
        set_data(t, ctx2[5]);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_2$2(ctx) {
  let input;
  let input_placeholder_value;
  let t;
  let if_block_anchor;
  let mounted;
  let dispose;
  let if_block = ctx[5] && create_if_block$6(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "text");
      attr(input, "class", "address");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", input_placeholder_value = ctx[10].bech32s.acc + "1...");
      toggle_class(input, "invalid", ctx[5]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[2]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      if (!mounted) {
        dispose = listen(input, "input", ctx[20]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && input_placeholder_value !== (input_placeholder_value = ctx2[10].bech32s.acc + "1...")) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty & 4 && input.value !== ctx2[2]) {
        set_input_value(input, ctx2[2]);
      }
      if (dirty & 32) {
        toggle_class(input, "invalid", ctx2[5]);
      }
      if (ctx2[5]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$6(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_1$3(ctx) {
  let textarea;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      attr(textarea, "placeholder", "");
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      set_input_value(textarea, ctx[7]);
      if (!mounted) {
        dispose = listen(textarea, "input", ctx[21]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 128) {
        set_input_value(textarea, ctx2[7]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(textarea);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$8(ctx) {
  let header;
  let t0;
  let field0;
  let t1;
  let field1;
  let t2;
  let field2;
  let t3;
  let field3;
  let t4;
  let field4;
  let t5;
  let hr;
  let t6;
  let h3;
  let t9;
  let inlinetags;
  let t10;
  let div;
  let button0;
  let t12;
  let button1;
  let t13_value = ctx[12] ? "Save" : "Add";
  let t13;
  let button1_readonly_value;
  let current;
  let mounted;
  let dispose;
  header = new Header({
    props: {
      plain: true,
      pops: true,
      title: (ctx[12] ? "Edit" : "Add New") + " Contact"
    }
  });
  field0 = new Field({
    props: {
      key: "contact-pfp",
      name: "Profile Icon",
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  field1 = new Field({
    props: {
      key: "chain-family",
      name: "Chain Family",
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  field2 = new Field({
    props: {
      key: "contact-name",
      name: "Name",
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  field3 = new Field({
    props: {
      key: "contact-address",
      name: "Address",
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  field4 = new Field({
    props: {
      key: "contact-notes",
      name: "Secure Notes",
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  inlinetags = new InlineTags({
    props: {
      editable: true,
      resourcePath: ctx[12]
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(field0.$$.fragment);
      t1 = space();
      create_component(field1.$$.fragment);
      t2 = space();
      create_component(field2.$$.fragment);
      t3 = space();
      create_component(field3.$$.fragment);
      t4 = space();
      create_component(field4.$$.fragment);
      t5 = space();
      hr = element("hr");
      t6 = space();
      h3 = element("h3");
      h3.textContent = `${ctx[12] ? "Edit" : "Add"} Tags`;
      t9 = space();
      create_component(inlinetags.$$.fragment);
      t10 = space();
      div = element("div");
      button0 = element("button");
      button0.textContent = "Back";
      t12 = space();
      button1 = element("button");
      t13 = text(t13_value);
      attr(button1, "class", "primary");
      attr(button1, "readonly", button1_readonly_value = !ctx[8]);
      attr(div, "class", "action-line");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(field0, target, anchor);
      insert(target, t1, anchor);
      mount_component(field1, target, anchor);
      insert(target, t2, anchor);
      mount_component(field2, target, anchor);
      insert(target, t3, anchor);
      mount_component(field3, target, anchor);
      insert(target, t4, anchor);
      mount_component(field4, target, anchor);
      insert(target, t5, anchor);
      insert(target, hr, anchor);
      insert(target, t6, anchor);
      insert(target, h3, anchor);
      insert(target, t9, anchor);
      mount_component(inlinetags, target, anchor);
      insert(target, t10, anchor);
      insert(target, div, anchor);
      append(div, button0);
      append(div, t12);
      append(div, button1);
      append(button1, t13);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", ctx[22]),
          listen(button1, "click", ctx[23])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const field0_changes = {};
      if (dirty & 268435459) {
        field0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field0.$set(field0_changes);
      const field1_changes = {};
      if (dirty & 268435976) {
        field1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field1.$set(field1_changes);
      const field2_changes = {};
      if (dirty & 268435474) {
        field2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field2.$set(field2_changes);
      const field3_changes = {};
      if (dirty & 268436516) {
        field3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field3.$set(field3_changes);
      const field4_changes = {};
      if (dirty & 268435584) {
        field4_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field4.$set(field4_changes);
      if (!current || dirty & 256 && button1_readonly_value !== (button1_readonly_value = !ctx2[8])) {
        attr(button1, "readonly", button1_readonly_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(field0.$$.fragment, local);
      transition_in(field1.$$.fragment, local);
      transition_in(field2.$$.fragment, local);
      transition_in(field3.$$.fragment, local);
      transition_in(field4.$$.fragment, local);
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(field0.$$.fragment, local);
      transition_out(field1.$$.fragment, local);
      transition_out(field2.$$.fragment, local);
      transition_out(field3.$$.fragment, local);
      transition_out(field4.$$.fragment, local);
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(field1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(field2, detaching);
      if (detaching)
        detach(t3);
      destroy_component(field3, detaching);
      if (detaching)
        detach(t4);
      destroy_component(field4, detaching);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(hr);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(h3);
      if (detaching)
        detach(t9);
      destroy_component(inlinetags, detaching);
      if (detaching)
        detach(t10);
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$h(ctx) {
  let screen;
  let current;
  let screen_props = {
    leaves: true,
    $$slots: { default: [create_default_slot$8] },
    $$scope: { ctx }
  };
  screen = new Screen({ props: screen_props });
  ctx[24](screen);
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 268437439) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[24](null);
      destroy_component(screen, detaching);
    }
  };
}
const func_1 = ([, g]) => g.bech32s.acc.hrp;
function instance$f($$self, $$props, $$invalidate) {
  let s_name;
  let s_addr;
  let sa_bech32;
  let s_notes;
  let si_agent_type;
  let b_form_valid;
  let $yw_family;
  let $yw_chain;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(9, $yw_family = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(10, $yw_chain = $$value));
  const k_page = getContext("page");
  let { contactRef = "" } = $$props;
  const p_contact = contactRef || "";
  let g_contact;
  if (p_contact)
    void Agents.getContact(p_contact).then((g) => $$invalidate(0, g_contact = g));
  let h_chains = {};
  (async function load_chains() {
    $$invalidate(3, h_chains = ofe((await Chains.read()).entries()));
  })();
  let s_err_name = "";
  let s_err_address = "";
  function pubkey_from_addr(sa_address, b_show_err = false) {
    const m_bech = R_BECH32.exec(sa_address);
    if (!m_bech) {
      if (b_show_err) {
        $$invalidate(5, s_err_address = "Invalid Bech32 address");
      }
      return "";
    }
    const [, s_chain, s_pubkey_local] = m_bech;
    let k_chain_match = null;
    for (const [, k_chain] of ode(H_CHAINS)) {
      if (k_chain.def.bechPrefix === s_chain) {
        k_chain_match = k_chain;
        break;
      }
    }
    if (b_show_err) {
      if (!k_chain_match) {
        $$invalidate(5, s_err_address = `No Cosmos SDK chains matched '${s_chain}'`);
      } else {
        $$invalidate(5, s_err_address = "");
      }
    }
    return $$invalidate(16, s_addr = s_pubkey_local);
  }
  let c_show_validations = 0;
  let y_screen;
  async function save() {
    if (!b_form_valid) {
      $$invalidate(15, c_show_validations++, c_show_validations);
      return;
    } else if (p_contact) {
      Object.assign(g_contact, {
        name: s_name,
        address: s_addr,
        pfp: g_contact.pfp,
        agentType: si_agent_type,
        notes: s_notes
      });
      k_page.reset();
    } else {
      $$invalidate(0, g_contact = {
        name: s_name,
        family: $yw_family,
        address: s_addr,
        pfp: g_contact.pfp,
        agentType: si_agent_type,
        notes: s_notes,
        space: "acc",
        origin: "user",
        chains: {}
      });
    }
    try {
      await Agents.open(async (ks_agents) => {
        await ks_agents.putContact(g_contact);
      });
      k_page.reset();
      k_page.push({
        creator: ContactView,
        props: { contactRef: p_contact }
      });
    } catch (e_write) {
    }
  }
  function iconeditor_name_binding(value) {
    s_name = value;
    $$invalidate(1, s_name), $$invalidate(0, g_contact);
  }
  const func = ([, g]) => $yw_family === g.family;
  function input_input_handler() {
    s_name = this.value;
    $$invalidate(1, s_name), $$invalidate(0, g_contact);
  }
  function input_input_handler_1() {
    sa_bech32 = this.value;
    $$invalidate(2, sa_bech32), $$invalidate(16, s_addr), $$invalidate(0, g_contact);
  }
  function textarea_input_handler() {
    s_notes = this.value;
    $$invalidate(7, s_notes), $$invalidate(0, g_contact);
  }
  const click_handler2 = () => k_page.pop();
  const click_handler_1 = () => save();
  function screen_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      y_screen = $$value;
      $$invalidate(6, y_screen);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("contactRef" in $$props2)
      $$invalidate(14, contactRef = $$props2.contactRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, s_name = g_contact?.name || "");
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(16, s_addr = g_contact?.address || "");
    }
    if ($$self.$$.dirty & 65536) {
      $$invalidate(2, sa_bech32 = s_addr ? Chains.bech32(s_addr) : "");
    }
    if ($$self.$$.dirty & 1) {
      $$invalidate(7, s_notes = g_contact?.notes || "");
    }
    if ($$self.$$.dirty & 1) {
      si_agent_type = g_contact?.agentType || ContactAgentType.PERSON;
    }
    if ($$self.$$.dirty & 6) {
      $$invalidate(8, b_form_valid = !!(s_name && pubkey_from_addr(sa_bech32)));
    }
    if ($$self.$$.dirty & 32774) {
      {
        if (c_show_validations) {
          $$invalidate(4, s_err_name = s_name ? "" : "Name must not be empty");
          pubkey_from_addr(sa_bech32, true);
        }
      }
    }
  };
  return [
    g_contact,
    s_name,
    sa_bech32,
    h_chains,
    s_err_name,
    s_err_address,
    y_screen,
    s_notes,
    b_form_valid,
    $yw_family,
    $yw_chain,
    k_page,
    p_contact,
    save,
    contactRef,
    c_show_validations,
    s_addr,
    iconeditor_name_binding,
    func,
    input_input_handler,
    input_input_handler_1,
    textarea_input_handler,
    click_handler2,
    click_handler_1,
    screen_binding
  ];
}
class ContactEdit extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$h, safe_not_equal, { contactRef: 14 });
  }
}
var SX_ICON_DOTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-more-vert-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-more-vert-fg" d="M12 8C13.1 8 14 7.1 14 6C14 4.9 13.1 4 12 4C10.9 4 10 4.9 10 6C10 7.1 10.9 8 12 8ZM12 10C10.9 10 10 10.9 10 12C10 13.1 10.9 14 12 14C13.1 14 14 13.1 14 12C14 10.9 13.1 10 12 10ZM12 16C10.9 16 10 16.9 10 18C10 19.1 10.9 20 12 20C13.1 20 14 19.1 14 18C14 16.9 13.1 16 12 16Z" fill="#FFB61A"/>\n</svg>\n';
var SX_ICON_SEND = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M9 16h6v-6h4l-7-7-7 7h4v6zm3-10.17L14.17 8H13v6h-2V8H9.83L12 5.83zM5 18h14v2H5z"/>\n</svg>';
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i][0];
  child_ctx[14] = list[i][1];
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i];
  return child_ctx;
}
function create_catch_block$4(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$4(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[12];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 63) {
        each_value = ctx2[12];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_detail_slot(ctx) {
  let address;
  let t;
  let current;
  address = new Address({
    props: {
      address: Chains.bech32(ctx[14].address + "")
    }
  });
  return {
    c() {
      create_component(address.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(address, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(address.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(address.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(address, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_prefix_slot(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      attr(span, "class", "icon contact-type svelte-1l93agm");
      attr(span, "slot", "prefix");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_CONTACTS;
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_tags_slot(ctx) {
  let inlinetags;
  let t;
  let current;
  inlinetags = new InlineTags({
    props: {
      collapsed: true,
      rootStyle: "margin: 0px;",
      resourcePath: ctx[13],
      $$slots: { prefix: [create_prefix_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(inlinetags.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(inlinetags, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inlinetags_changes = {};
      if (dirty & 1048576) {
        inlinetags_changes.$$scope = { dirty, ctx: ctx2 };
      }
      inlinetags.$set(inlinetags_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inlinetags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inlinetags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inlinetags, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$5(ctx) {
  let span;
  let span_transition;
  let current;
  let each_value_1 = ctx[5];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(span, "class", "overlay");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(span, null);
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 36) {
        each_value_1 = ctx[5];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, slide, { duration: 300, easing: quintOut }, true);
        span_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!span_transition)
        span_transition = create_bidirectional_transition(span, slide, { duration: 300, easing: quintOut }, false);
      span_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_each(each_blocks, detaching);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_each_block_1$1(ctx) {
  let div;
  let span0;
  let raw_value = ctx[17].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[17].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler2(...args) {
    return ctx[9](ctx[17], ctx[14], ...args);
  }
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon");
      attr(span1, "class", "text");
      attr(div, "class", "action");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      span0.innerHTML = raw_value;
      append(div, t0);
      append(div, span1);
      append(span1, t1);
      append(div, t2);
      if (!mounted) {
        dispose = listen(div, "click", click_handler2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_status_slot(ctx) {
  let span;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[0] === ctx[13] && create_if_block$5(ctx);
  return {
    c() {
      span = element("span");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      attr(span, "class", "icon more-menu");
      toggle_class(span, "active", ctx[0] === ctx[13]);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      span.innerHTML = SX_ICON_DOTS;
      insert(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t1, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", ctx[4](ctx[13], ctx[14]));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 5) {
        toggle_class(span, "active", ctx[0] === ctx[13]);
      }
      if (ctx[0] === ctx[13]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      if (detaching)
        detach(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block$5(ctx) {
  let row;
  let current;
  function click_handler_1(...args) {
    return ctx[10](ctx[14], ...args);
  }
  row = new Row({
    props: {
      resource: ctx[14],
      resourcePath: ctx[13],
      $$slots: {
        status: [create_status_slot],
        tags: [create_tags_slot],
        detail: [create_detail_slot]
      },
      $$scope: { ctx }
    }
  });
  row.$on("click", click_handler_1);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1048577) {
        row_changes.$$scope = { dirty, ctx };
      }
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading contacts...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment$g(ctx) {
  let div;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block$4,
    value: 12,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      div = element("div");
      info.block.c();
      attr(div, "class", "rows svelte-1l93agm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let $yw_family;
  component_subscribe($$self, yw_family, ($$value) => $$invalidate(11, $yw_family = $$value));
  const k_page = getContext("page");
  let { filter = (g) => true } = $$props;
  let { sort = (g_a, g_b) => g_a.name < g_b.name ? -1 : 1 } = $$props;
  let { append: append2 = [] } = $$props;
  async function load_contacts() {
    const ks_agents = await Agents.read();
    return [...ks_agents.contacts($yw_family)];
  }
  const hm_events = /* @__PURE__ */ new WeakMap();
  let si_overlay = "";
  function activate_overlay(p_contact, g_contact) {
    return (d_event) => {
      d_event.stopImmediatePropagation();
      const si_set = p_contact;
      if (hm_events.get(d_event)?.cancelMenu === si_set) {
        $$invalidate(0, si_overlay = "");
        return;
      }
      $$invalidate(0, si_overlay = si_set);
      window.addEventListener(
        "click",
        () => {
          hm_events.set(d_event, { cancelMenu: si_overlay });
          $$invalidate(0, si_overlay = "");
        },
        { capture: true, once: true }
      );
    };
  }
  const a_overlay_actions = [
    {
      label: "Edit",
      icon: SX_ICON_EDIT,
      click(g_contact) {
        k_page.push({
          creator: ContactEdit,
          props: { contact: g_contact }
        });
      }
    },
    {
      label: "Send",
      icon: SX_ICON_SEND,
      click(g_contact) {
        k_page.push({
          creator: Send,
          props: {
            recipient: Chains.bech32(g_contact.address)
          }
        });
      }
    },
    {
      label: "Delete",
      icon: SX_ICON_DELETE,
      click(g_contact) {
        k_page.push({ creator: DeadEnd, props: {} });
      }
    }
  ];
  const click_handler2 = (g_action, g_contact, d_event) => {
    d_event.stopPropagation();
    g_action.click(g_contact);
  };
  const click_handler_1 = (g_contact, d_event) => {
    if (!hm_events.get(d_event)?.cancelMenu) {
      k_page.push({
        creator: ContactView,
        props: { contact: g_contact }
      });
    }
  };
  $$self.$$set = ($$props2) => {
    if ("filter" in $$props2)
      $$invalidate(6, filter = $$props2.filter);
    if ("sort" in $$props2)
      $$invalidate(7, sort = $$props2.sort);
    if ("append" in $$props2)
      $$invalidate(8, append2 = $$props2.append);
  };
  return [
    si_overlay,
    k_page,
    load_contacts,
    hm_events,
    activate_overlay,
    a_overlay_actions,
    filter,
    sort,
    append2,
    click_handler2,
    click_handler_1
  ];
}
class ContactList extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$g, safe_not_equal, { filter: 6, sort: 7, append: 8 });
  }
}
function create_default_slot_8(ctx) {
  let t;
  return {
    c() {
      t = text("All");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_7(ctx) {
  let t;
  return {
    c() {
      t = text("Humans");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_6(ctx) {
  let t;
  return {
    c() {
      t = text("Contracts");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5$1(ctx) {
  let tab0;
  let t0;
  let tab1;
  let t1;
  let tab2;
  let current;
  tab0 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  tab1 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  tab2 = new Tab({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tab0.$$.fragment);
      t0 = space();
      create_component(tab1.$$.fragment);
      t1 = space();
      create_component(tab2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tab0, target, anchor);
      insert(target, t0, anchor);
      mount_component(tab1, target, anchor);
      insert(target, t1, anchor);
      mount_component(tab2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tab0_changes = {};
      if (dirty & 8) {
        tab0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab0.$set(tab0_changes);
      const tab1_changes = {};
      if (dirty & 8) {
        tab1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab1.$set(tab1_changes);
      const tab2_changes = {};
      if (dirty & 8) {
        tab2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tab2.$set(tab2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tab0.$$.fragment, local);
      transition_in(tab1.$$.fragment, local);
      transition_in(tab2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tab0.$$.fragment, local);
      transition_out(tab1.$$.fragment, local);
      transition_out(tab2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tab0, detaching);
      if (detaching)
        detach(t0);
      destroy_component(tab1, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tab2, detaching);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({});
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_3$1(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({ props: { filter: ctx[0] } });
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let contactlist;
  let current;
  contactlist = new ContactList({ props: { filter: ctx[1] } });
  return {
    c() {
      create_component(contactlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(contactlist, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(contactlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(contactlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(contactlist, detaching);
    }
  };
}
function create_default_slot_1$2(ctx) {
  let tablist;
  let t0;
  let tabpanel0;
  let t1;
  let tabpanel1;
  let t2;
  let tabpanel2;
  let current;
  tablist = new TabList({
    props: {
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  tabpanel0 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  tabpanel1 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  tabpanel2 = new TabPanel({
    props: {
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(tablist.$$.fragment);
      t0 = space();
      create_component(tabpanel0.$$.fragment);
      t1 = space();
      create_component(tabpanel1.$$.fragment);
      t2 = space();
      create_component(tabpanel2.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tablist, target, anchor);
      insert(target, t0, anchor);
      mount_component(tabpanel0, target, anchor);
      insert(target, t1, anchor);
      mount_component(tabpanel1, target, anchor);
      insert(target, t2, anchor);
      mount_component(tabpanel2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tablist_changes = {};
      if (dirty & 8) {
        tablist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablist.$set(tablist_changes);
      const tabpanel0_changes = {};
      if (dirty & 8) {
        tabpanel0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel0.$set(tabpanel0_changes);
      const tabpanel1_changes = {};
      if (dirty & 8) {
        tabpanel1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel1.$set(tabpanel1_changes);
      const tabpanel2_changes = {};
      if (dirty & 8) {
        tabpanel2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabpanel2.$set(tabpanel2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tablist.$$.fragment, local);
      transition_in(tabpanel0.$$.fragment, local);
      transition_in(tabpanel1.$$.fragment, local);
      transition_in(tabpanel2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tablist.$$.fragment, local);
      transition_out(tabpanel0.$$.fragment, local);
      transition_out(tabpanel1.$$.fragment, local);
      transition_out(tabpanel2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tablist, detaching);
      if (detaching)
        detach(t0);
      destroy_component(tabpanel0, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tabpanel1, detaching);
      if (detaching)
        detach(t2);
      destroy_component(tabpanel2, detaching);
    }
  };
}
function create_default_slot$7(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let tabs;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "Contacts" } });
  tabs = new Tabs({
    props: {
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      create_component(tabs.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      mount_component(tabs, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_changes = {};
      if (dirty & 8) {
        tabs_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabs.$set(tabs_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(tabs.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      transition_out(tabs.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      destroy_component(tabs, detaching);
    }
  };
}
function create_fragment$f(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      root: true,
      classNames: "contacts",
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 8) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$d($$self) {
  getContext("page");
  const func = (g_contact) => ContactAgentType.PERSON === g_contact.agentType;
  const func_12 = (g_contact) => ContactAgentType.CONTRACT === g_contact.agentType;
  return [func, func_12];
}
class ContactsHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$f, safe_not_equal, {});
  }
}
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i][0];
  child_ctx[5] = list[i][1];
  return child_ctx;
}
function create_catch_block$3(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 3) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$4(ctx) {
  let row;
  let current;
  row = new Row({
    props: {
      pfp: ctx[5].pfp,
      name: ctx[5].host,
      resourcePath: ctx[4],
      iconClass: "square pfp"
    }
  });
  row.$on("click", ctx[2]);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$3(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$6(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({
    props: { bare: true, title: "Sites / Apps" }
  });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    value: 3,
    blocks: [, , ,]
  };
  handle_promise(ctx[1](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$e(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "SitesHome",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 256) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$c($$self) {
  const k_page = getContext("page");
  async function load_apps() {
    const ks_apps = await Apps.read();
    return ks_apps.entries();
  }
  const click_handler2 = () => {
    k_page.push({});
  };
  return [k_page, load_apps, click_handler2];
}
class SitesHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$e, safe_not_equal, {});
  }
}
function create_else_block$2(ctx) {
  let portrait;
  let t0;
  let field;
  let t1;
  let if_block_anchor;
  let current;
  portrait = new Portrait({
    props: {
      resource: ctx[0],
      resourcePath: ctx[2],
      actions: ctx[3],
      $$slots: {
        subtitle: [create_subtitle_slot],
        default: [create_default_slot_5]
      },
      $$scope: { ctx }
    }
  });
  field = new Field({
    props: {
      name: "gRPC-web URL",
      key: "grpc-web",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  let if_block = ctx[0].rpcHost && create_if_block_1$1(ctx);
  return {
    c() {
      create_component(portrait.$$.fragment);
      t0 = space();
      create_component(field.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(portrait, target, anchor);
      insert(target, t0, anchor);
      mount_component(field, target, anchor);
      insert(target, t1, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portrait_changes = {};
      if (dirty & 1)
        portrait_changes.resource = ctx2[0];
      if (dirty & 130) {
        portrait_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portrait.$set(portrait_changes);
      const field_changes = {};
      if (dirty & 129) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
      if (ctx2[0].rpcHost) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(portrait.$$.fragment, local);
      transition_in(field.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(portrait.$$.fragment, local);
      transition_out(field.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      destroy_component(portrait, detaching);
      if (detaching)
        detach(t0);
      destroy_component(field, detaching);
      if (detaching)
        detach(t1);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block$4(ctx) {
  let t;
  return {
    c() {
      t = text("Loading network...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_5(ctx) {
  let t;
  return {
    c() {
      t = text("address");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_subtitle_slot(ctx) {
  let span;
  let t0_value = ctx[1].name + "";
  let t0;
  let t1;
  let t2_value = ctx[1].id + "";
  let t2;
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" (");
      t2 = text(t2_value);
      t3 = text(")");
      attr(span, "class", "font-family_mono svelte-yy3tbl");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = ctx2[1].name + ""))
        set_data(t0, t0_value);
      if (dirty & 2 && t2_value !== (t2_value = ctx2[1].id + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function create_default_slot_4(ctx) {
  let t_value = ctx[0].grpcWebUrl + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].grpcWebUrl + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_3(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "grpc-web-value",
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 129) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let field;
  let current;
  field = new Field({
    props: {
      name: "RPC Host",
      key: "rpc",
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(field.$$.fragment);
    },
    m(target, anchor) {
      mount_component(field, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 129) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(field, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let t_value = ctx[0].rpcHost + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 1 && t_value !== (t_value = ctx2[0].rpcHost + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let info;
  let current;
  info = new Info({
    props: {
      key: "rpc-value",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(info.$$.fragment);
    },
    m(target, anchor) {
      mount_component(info, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const info_changes = {};
      if (dirty & 129) {
        info_changes.$$scope = { dirty, ctx: ctx2 };
      }
      info.$set(info_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(info.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(info, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let header;
  let t0;
  let current_block_type_index;
  let if_block;
  let t1;
  let gap;
  let current;
  header = new Header({
    props: {
      pops: true,
      search: true,
      network: true,
      account: true
    }
  });
  const if_block_creators = [create_if_block$4, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!ctx2[1])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  gap = new Gap({});
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      if_block.c();
      t1 = space();
      create_component(gap.$$.fragment);
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, t1, anchor);
      mount_component(gap, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t1.parentNode, t1);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      transition_in(gap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      transition_out(gap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(t1);
      destroy_component(gap, detaching);
    }
  };
}
function create_fragment$d(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      slides: true,
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 131) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  let p_chain;
  let { networkRef } = $$props;
  const p_network = networkRef;
  let g_network;
  void Networks.at(p_network).then((g) => $$invalidate(0, g_network = g));
  let g_chain;
  getContext("page");
  const gc_actions = {};
  $$self.$$set = ($$props2) => {
    if ("networkRef" in $$props2)
      $$invalidate(4, networkRef = $$props2.networkRef);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(5, p_chain = g_network?.chain);
    }
    if ($$self.$$.dirty & 32) {
      if (p_chain) {
        void Chains.at(p_chain).then((g) => $$invalidate(1, g_chain = g));
      }
    }
  };
  return [g_network, g_chain, p_network, gc_actions, networkRef, p_chain];
}
class NetworkView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$d, safe_not_equal, { networkRef: 4 });
  }
}
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i][0];
  child_ctx[7] = list[i][1];
  const constants_0 = child_ctx[0].at(child_ctx[7].chain);
  child_ctx[8] = constants_0;
  return child_ctx;
}
function create_catch_block$2(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[5];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 7) {
        each_value = ctx2[5];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block$3(ctx) {
  let row;
  let current;
  function click_handler2() {
    return ctx[3](ctx[6]);
  }
  row = new Row({
    props: {
      resource: ctx[7],
      resourcePath: ctx[6],
      iconClass: "square pfp",
      detail: `${ctx[8]?.name} (${ctx[8]?.id})`
    }
  });
  row.$on("click", click_handler2);
  return {
    c() {
      create_component(row.$$.fragment);
    },
    m(target, anchor) {
      mount_component(row, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const row_changes = {};
      if (dirty & 1)
        row_changes.detail = `${ctx[8]?.name} (${ctx[8]?.id})`;
      row.$set(row_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(row.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(row.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(row, detaching);
    }
  };
}
function create_pending_block$2(ctx) {
  let t;
  return {
    c() {
      t = text("Loading...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot$4(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let div;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { bare: true, title: "Networks" } });
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2,
    value: 5,
    blocks: [, , ,]
  };
  handle_promise(ctx[2](), info);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      div = element("div");
      info.block.c();
      attr(div, "class", "rows no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = null;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(info.block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div);
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function create_fragment$c(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "NetworksHome",
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 2049) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  const k_page = getContext("page");
  let ks_chains;
  let ks_networks;
  async function load_networks() {
    $$invalidate(0, [ks_chains, ks_networks] = await Promise.all([Chains.read(), Networks.read()]), ks_chains);
    return ks_networks.entries();
  }
  const click_handler2 = (p_network) => {
    k_page.push({
      creator: NetworkView,
      props: { networkRef: p_network }
    });
  };
  return [ks_chains, k_page, load_networks, click_handler2];
}
class NetworksHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$c, safe_not_equal, {});
  }
}
function get_then_context(ctx) {
  const constants_0 = ctx[2].raw;
  ctx[3] = constants_0;
}
function create_catch_block$1(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block$1(ctx) {
  get_then_context(ctx);
  let txnlist;
  let current;
  txnlist = new TxnList({ props: { events: ctx[3] } });
  return {
    c() {
      create_component(txnlist.$$.fragment);
    },
    m(target, anchor) {
      mount_component(txnlist, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      get_then_context(ctx2);
    },
    i(local) {
      if (current)
        return;
      transition_in(txnlist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(txnlist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(txnlist, detaching);
    }
  };
}
function create_pending_block$1(ctx) {
  let t;
  return {
    c() {
      t = text("Loading history...");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_key_block(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    value: 2,
    blocks: [, , ,]
  };
  handle_promise(Events.read(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_default_slot$3(ctx) {
  let header;
  let t0;
  let subheader;
  let t1;
  let previous_key = ctx[0];
  let key_block_anchor;
  let current;
  header = new Header({
    props: {
      search: true,
      network: true,
      account: true
    }
  });
  subheader = new SubHeader({ props: { title: "History", bare: true } });
  let key_block = create_key_block(ctx);
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(subheader.$$.fragment);
      t1 = space();
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      mount_component(subheader, target, anchor);
      insert(target, t1, anchor);
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 1 && safe_not_equal(previous_key, previous_key = ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(subheader.$$.fragment, local);
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(subheader.$$.fragment, local);
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      destroy_component(subheader, detaching);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(key_block_anchor);
      key_block.d(detaching);
    }
  };
}
function create_fragment$b(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      nav: true,
      root: true,
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 17) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let c_reloads = 1;
  const f_unsubscribe = global_receive({
    updateStore({ key: si_store }) {
      if ("events" === si_store) {
        $$invalidate(0, c_reloads++, c_reloads);
      }
    }
  });
  onDestroy(() => {
    f_unsubscribe();
  });
  return [c_reloads];
}
class HistoryHome extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$b, safe_not_equal, {});
  }
}
var ThreadId = /* @__PURE__ */ ((ThreadId2) => {
  ThreadId2["DEFAULT"] = "default";
  ThreadId2["INIT"] = "init";
  ThreadId2["SEARCH"] = "search";
  ThreadId2["TOKENS"] = "tokens";
  ThreadId2["NFTS"] = "nfts";
  ThreadId2["CONTACTS"] = "contacts";
  ThreadId2["HISTORY"] = "history";
  ThreadId2["NETWORKS"] = "networks";
  ThreadId2["ACCOUNTS"] = "accounts";
  ThreadId2["TAGS"] = "tags";
  ThreadId2["SITES"] = "sites";
  return ThreadId2;
})(ThreadId || {});
const H_THREADS = {
  ["default"]: Blank,
  ["init"]: Register,
  ["tokens"]: HoldingsHome,
  ["contacts"]: ContactsHome,
  ["history"]: HistoryHome,
  ["networks"]: NetworksHome,
  ["accounts"]: AccountsHome,
  ["sites"]: SitesHome
};
var Overscroll_svelte_svelte_type_style_lang = "";
function create_fragment$a(ctx) {
  let svg;
  let style;
  let t;
  let circle0;
  let circle1;
  let circle2;
  return {
    c() {
      svg = svg_element("svg");
      style = svg_element("style");
      t = text(".overscroll .bg {\n  fill: var(--theme-color-text-light);\n}\n.overscroll .ring {\n  fill: transparent;\n  stroke: #c4c4c4;\n}\n.overscroll .progress {\n  fill: transparent;\n  stroke: black;\n}\n");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      attr(style, "lang", "less");
      attr(circle0, "cx", "16");
      attr(circle0, "cy", "16");
      attr(circle0, "r", "16");
      attr(circle0, "class", "bg");
      attr(circle1, "cx", "16");
      attr(circle1, "cy", "16");
      attr(circle1, "r", "10");
      attr(circle1, "class", "ring");
      attr(circle1, "stroke-width", "3");
      set_style(circle1, "opacity", "0.2");
      attr(circle2, "cx", "16");
      attr(circle2, "cy", "16");
      attr(circle2, "r", "10");
      attr(circle2, "class", "progress svelte-1u2i3kk");
      attr(circle2, "stroke-width", "3");
      set_style(circle2, "stroke-dashoffset", 62 - ctx[1] * 62);
      attr(svg, "width", "32");
      attr(svg, "height", "32");
      attr(svg, "viewBox", "0 0 32 32");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "class", "overscroll svelte-1u2i3kk");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, style);
      append(style, t);
      append(svg, circle0);
      append(svg, circle1);
      append(svg, circle2);
      ctx[2](circle2);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        set_style(circle2, "stroke-dashoffset", 62 - ctx2[1] * 62);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
      ctx[2](null);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $yw_overscroll_pct;
  component_subscribe($$self, yw_overscroll_pct, ($$value) => $$invalidate(1, $yw_overscroll_pct = $$value));
  let dm_progress;
  function circle2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_progress = $$value;
      $$invalidate(0, dm_progress);
    });
  }
  return [dm_progress, $yw_overscroll_pct, circle2_binding];
}
class Overscroll extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$a, safe_not_equal, {});
  }
}
var Popup_svelte_svelte_type_style_lang = "";
function create_fragment$9(ctx) {
  let div;
  let section;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = ctx[0];
  function switch_props(ctx2) {
    return {};
  }
  if (switch_value) {
    switch_instance = new switch_value(switch_props());
  }
  return {
    c() {
      div = element("div");
      section = element("section");
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      attr(section, "class", "screen content svelte-rtd9ps");
      attr(div, "class", "popup svelte-rtd9ps");
      toggle_class(div, "showing", null !== ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, section);
      if (switch_instance) {
        mount_component(switch_instance, section, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(section, "click", click_handler),
          listen(div, "click", ctx[1])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (switch_value !== (switch_value = ctx2[0])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = new switch_value(switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, section, null);
        } else {
          switch_instance = null;
        }
      }
      if (dirty & 1) {
        toggle_class(div, "showing", null !== ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (switch_instance)
        destroy_component(switch_instance);
      mounted = false;
      run_all(dispose);
    }
  };
}
const click_handler = (d_event) => d_event.stopPropagation();
function instance$7($$self, $$props, $$invalidate) {
  let $yw_popup;
  component_subscribe($$self, yw_popup, ($$value) => $$invalidate(0, $yw_popup = $$value));
  const click_handler_1 = () => set_store_value(yw_popup, $yw_popup = null, $yw_popup);
  return [$yw_popup, click_handler_1];
}
class Popup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$9, safe_not_equal, {});
  }
}
var SX_ICON_EXPAND = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M12 16L18 10L16.59 8.59L12 13.17L7.41 8.59L6 10L12 16Z" />\n</svg>\n';
var SX_ICON_TOKENS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-tokens-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-tokens-fg" d="M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8Zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6ZM3 12a5.99 5.99 0 0 1 4-5.65V4.26C3.55 5.15 1 8.27 1 12c0 3.73 2.55 6.85 6 7.74v-2.09A5.99 5.99 0 0 1 3 12Z" />\n</svg>\n';
var SX_ICON_HISTORY = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg,currentColor);" d="M13 3a9 9 0 0 0-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42A8.954 8.954 0 0 0 13 21a9 9 0 0 0 0-18Zm-1 5v5l4.25 2.52.77-1.28-3.52-2.09V8H12Z" />\n</svg>\n';
var SX_ICON_MENU = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<style type="text/css">\n		.s2r-menu-fg {\n			fill: var(--svg-color-fg, currentColor);\n		}\n	</style>\n	<path class="s2r-menu-fg" d="M4 19h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1Zm0-6h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1s.45 1 1 1ZM3 6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1s-.45-1-1-1H4c-.55 0-1 .45-1 1Z" />\n</svg>\n';
var Nav_svelte_svelte_type_style_lang = "";
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i][0];
  child_ctx[18] = list[i][1];
  return child_ctx;
}
function create_else_block$1(ctx) {
  let li;
  let div0;
  let html_tag;
  let raw_value = ctx[18].svg + "";
  let t0;
  let span;
  let t1;
  let div1;
  let t2_value = ctx[18].label + "";
  let t2;
  let t3;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[9](ctx[17]);
  }
  return {
    c() {
      li = element("li");
      div0 = element("div");
      html_tag = new HtmlTag(false);
      t0 = space();
      span = element("span");
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      html_tag.a = t0;
      attr(span, "class", "notification svelte-1ylq4j5");
      toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      attr(div0, "class", "icon svelte-1ylq4j5");
      attr(div1, "class", "label svelte-1ylq4j5");
      attr(li, "class", "button " + ctx[17] + " svelte-1ylq4j5");
      toggle_class(li, "active", ctx[0] === ctx[17]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      html_tag.m(raw_value, div0);
      append(div0, t0);
      append(div0, span);
      append(li, t1);
      append(li, div1);
      append(div1, t2);
      append(li, t3);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 18) {
        toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      }
      if (dirty & 17) {
        toggle_class(li, "active", ctx[0] === ctx[17]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$3(ctx) {
  let li;
  let div0;
  let html_tag;
  let raw_value = ctx[18].svg + "";
  let t0;
  let span;
  let t1;
  let div1;
  let t2_value = ctx[18].label + "";
  let t2;
  let t3;
  return {
    c() {
      li = element("li");
      div0 = element("div");
      html_tag = new HtmlTag(false);
      t0 = space();
      span = element("span");
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      html_tag.a = t0;
      attr(span, "class", "notification svelte-1ylq4j5");
      toggle_class(span, "display_none", !ctx[1].includes(ctx[17]));
      attr(div0, "class", "icon svelte-1ylq4j5");
      attr(div1, "class", "label svelte-1ylq4j5");
      attr(li, "class", "button " + ctx[17] + " svelte-1ylq4j5");
      set_style(li, "opacity", "0.5");
      toggle_class(li, "active", ctx[0] === ctx[17]);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      html_tag.m(raw_value, div0);
      append(div0, t0);
      append(div0, span);
      append(li, t1);
      append(li, div1);
      append(div1, t2);
      append(li, t3);
    },
    p(ctx2, dirty) {
      if (dirty & 18) {
        toggle_class(span, "display_none", !ctx2[1].includes(ctx2[17]));
      }
      if (dirty & 17) {
        toggle_class(li, "active", ctx2[0] === ctx2[17]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(li);
    }
  };
}
function create_each_block$2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (ctx2[18].disabled)
      return create_if_block$3;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment$8(ctx) {
  let nav;
  let div;
  let t;
  let ul;
  let mounted;
  let dispose;
  let each_value = ode(ctx[4]);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  return {
    c() {
      nav = element("nav");
      div = element("div");
      t = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "collapse icon svelte-1ylq4j5");
      attr(ul, "class", "bar svelte-1ylq4j5");
      attr(nav, "class", "svelte-1ylq4j5");
      toggle_class(nav, "collapsed", ctx[2]);
      toggle_class(nav, "visible", ctx[3]);
    },
    m(target, anchor) {
      insert(target, nav, anchor);
      append(nav, div);
      div.innerHTML = SX_ICON_EXPAND;
      append(nav, t);
      append(nav, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul, null);
      }
      if (!mounted) {
        dispose = listen(div, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 83) {
        each_value = ode(ctx2[4]);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 4) {
        toggle_class(nav, "collapsed", ctx2[2]);
      }
      if (dirty & 8) {
        toggle_class(nav, "visible", ctx2[3]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(nav);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_thread;
  let $yw_page;
  let $yw_menu_expanded;
  let $yw_overlay_account;
  let $yw_overlay_network;
  let $yw_blur;
  let $yw_notifications;
  let $yw_nav_collapsed;
  let $yw_nav_visible;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(10, $yw_navigator = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(11, $yw_thread = $$value));
  component_subscribe($$self, yw_page, ($$value) => $$invalidate(7, $yw_page = $$value));
  component_subscribe($$self, yw_menu_expanded, ($$value) => $$invalidate(12, $yw_menu_expanded = $$value));
  component_subscribe($$self, yw_overlay_account, ($$value) => $$invalidate(13, $yw_overlay_account = $$value));
  component_subscribe($$self, yw_overlay_network, ($$value) => $$invalidate(14, $yw_overlay_network = $$value));
  component_subscribe($$self, yw_blur, ($$value) => $$invalidate(15, $yw_blur = $$value));
  component_subscribe($$self, yw_notifications, ($$value) => $$invalidate(1, $yw_notifications = $$value));
  component_subscribe($$self, yw_nav_collapsed, ($$value) => $$invalidate(2, $yw_nav_collapsed = $$value));
  component_subscribe($$self, yw_nav_visible, ($$value) => $$invalidate(3, $yw_nav_visible = $$value));
  const H_BUTTONS = {
    [ThreadId.TOKENS]: { svg: SX_ICON_TOKENS, label: "Tokens" },
    [ThreadId.CONTACTS]: {
      svg: SX_ICON_CONTACTS,
      label: "Contacts",
      disabled: true
    },
    [ThreadId.HISTORY]: { svg: SX_ICON_HISTORY, label: "History" },
    menu: { svg: SX_ICON_MENU, label: "Menu" }
  };
  const HM_HOMESCREENS = new Map(oderac(H_THREADS, (si_thread, dc_creator) => [dc_creator, si_thread]));
  let si_thread_head = "";
  function toggle_collapsed() {
    set_store_value(yw_nav_collapsed, $yw_nav_collapsed = !$yw_nav_collapsed, $yw_nav_collapsed);
  }
  function nav_click(si_button) {
    set_store_value(yw_notifications, $yw_notifications = $yw_notifications.filter((si) => si_button !== si), $yw_notifications);
    if ($yw_blur) {
      set_store_value(yw_blur, $yw_blur = false, $yw_blur);
    }
    if ($yw_overlay_network) {
      set_store_value(yw_overlay_network, $yw_overlay_network = false, $yw_overlay_network);
    }
    if ($yw_overlay_account) {
      set_store_value(yw_overlay_account, $yw_overlay_account = false, $yw_overlay_account);
    }
    switch (si_button) {
      case "menu": {
        set_store_value(yw_menu_expanded, $yw_menu_expanded = true, $yw_menu_expanded);
        break;
      }
      case si_thread_head: {
        $yw_navigator.activePage.dom.scrollTo({ top: 0, left: 0, behavior: "smooth" });
        break;
      }
      case $yw_thread.id: {
        const k_previous = $yw_page.peak();
        if (k_previous && HM_HOMESCREENS.get(k_previous.creator) === $yw_thread.id) {
          $yw_page.pop();
        } else {
          $yw_page.reset();
        }
        break;
      }
      default: {
        void $yw_navigator.activateThread(si_button);
        break;
      }
    }
  }
  const click_handler2 = () => toggle_collapsed();
  const click_handler_1 = (si_button) => nav_click(si_button);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      $$invalidate(0, si_thread_head = $yw_page ? HM_HOMESCREENS.get($yw_page.creator) || "" : "");
    }
  };
  return [
    si_thread_head,
    $yw_notifications,
    $yw_nav_collapsed,
    $yw_nav_visible,
    H_BUTTONS,
    toggle_collapsed,
    nav_click,
    $yw_page,
    click_handler2,
    click_handler_1
  ];
}
class Nav extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$8, safe_not_equal, {});
  }
}
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
const INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
const PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
const hasOwn = Object.prototype.hasOwnProperty;
class KeyStore {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
}
function createKey(key) {
  let path = null;
  let id2 = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id2 = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id2 = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id: id2, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
const MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
const BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
const FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
const AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
const SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
class FuseIndex {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
}
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
const MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
class BitapSearch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
}
class BaseMatch {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
}
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
class ExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InverseExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class PrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
}
class InversePrefixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class SuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
}
class InverseSuffixExactMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
}
class FuzzyMatch extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
}
class IncludeMatch extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
}
const searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
const searchersLen = searchers.length;
const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
const OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
class ExtendedSearch {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
}
const registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
const LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
const KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
const isPath = (query) => !!query[KeyType.PATH];
const isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
const convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
class Fuse {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
}
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}
var Search_svelte_svelte_type_style_lang = "";
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function create_each_block$1(ctx) {
  let genericrow;
  let current;
  genericrow = new GenericRow({ props: { item: ctx[9] } });
  return {
    c() {
      create_component(genericrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(genericrow, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(genericrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(genericrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(genericrow, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let header;
  let t0;
  let p2;
  let t3;
  let div;
  let each_1_anchor;
  let current;
  const header_spread_levels = [
    { network: true },
    { account: true },
    { search: true },
    { isSearchScreen: true },
    ctx[2] || {}
  ];
  let header_props = {};
  for (let i = 0; i < header_spread_levels.length; i += 1) {
    header_props = assign(header_props, header_spread_levels[i]);
  }
  header = new Header({ props: header_props });
  header.$on("search", ctx[5]);
  let each_value = ctx[3];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      create_component(header.$$.fragment);
      t0 = space();
      p2 = element("p");
      p2.innerHTML = `<span style="color:var(--theme-color-caution);">Disclaimer:</span>
			This temporary search interface does not represent the look and function of the actual search interface currently under development for beta.`;
      t3 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
      set_style(p2, "font-size", "12px");
      attr(div, "class", "results no-margin");
    },
    m(target, anchor) {
      mount_component(header, target, anchor);
      insert(target, t0, anchor);
      insert(target, p2, anchor);
      insert(target, t3, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append(div, each_1_anchor);
      ctx[6](div);
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = dirty & 4 ? get_spread_update(header_spread_levels, [
        header_spread_levels[0],
        header_spread_levels[1],
        header_spread_levels[2],
        header_spread_levels[3],
        get_spread_object(ctx2[2] || {})
      ]) : {};
      header.$set(header_changes);
      if (dirty & 8) {
        each_value = ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
      ctx[6](null);
    }
  };
}
function create_fragment$7(ctx) {
  let div;
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Search",
      root: true,
      $$slots: { default: [create_default_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(screen.$$.fragment);
      attr(div, "class", "search svelte-5f3tva");
      toggle_class(div, "display_none", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(screen, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 4102) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
      if (dirty & 1) {
        toggle_class(div, "display_none", !ctx2[0]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(screen);
    }
  };
}
var ClassType;
(function(ClassType2) {
  ClassType2["UNKNOWN"] = "unknown";
  ClassType2["FAMILY"] = "family";
  ClassType2["CHAIN"] = "chain";
  ClassType2["NETWORK"] = "network";
  ClassType2["ACCOUNT"] = "account";
  ClassType2["CONTACT"] = "contact";
  ClassType2["CONTRACT"] = "contract";
  ClassType2["TOKEN"] = "token";
  ClassType2["HOLDING"] = "holding";
  ClassType2["APP"] = "app";
  ClassType2["COIN"] = "coin";
  ClassType2["TAG"] = "tag";
  ClassType2["ICON"] = "icon";
  ClassType2["IBCT"] = "ibct";
  ClassType2["SNIP721"] = "snip721";
  ClassType2["TXN"] = "txn";
  ClassType2["OTHER"] = "other";
})(ClassType || (ClassType = {}));
function instance$5($$self, $$props, $$invalidate) {
  let $yw_search;
  let $yw_header_props;
  component_subscribe($$self, yw_search, ($$value) => $$invalidate(0, $yw_search = $$value));
  component_subscribe($$self, yw_header_props, ($$value) => $$invalidate(2, $yw_header_props = $$value));
  let dm_results;
  const a_results = [];
  let a_fuses = [];
  const fuzey = (a_items, a_keys) => new Fuse(
    a_items,
    {
      includeScore: true,
      includeMatches: true,
      keys: ["label", ...a_keys.map((s) => `details.${s}`)]
    }
  );
  (async () => {
    const ks_chains = await Chains.read();
    a_fuses = [
      (() => fuzey(
        ks_chains.entries().map(([p_chain, g_chain]) => ({
          class: ClassType.CHAIN,
          name: g_chain.name,
          resourcePath: p_chain,
          resource: g_chain,
          details: { name: g_chain.name, id: g_chain.id }
        })),
        ["id"]
      ))(),
      (() => fuzey(
        ks_chains.entries().flatMap(([p_chain, g_chain]) => oderac(g_chain.coins, (si_coin, g_coin) => ({
          class: ClassType.COIN,
          name: proper(g_coin.extra?.coingecko_id || "Unknown"),
          postname: si_coin,
          resourcePath: `${p_chain}/coin.${si_coin}`,
          resource: {
            name: proper(g_coin.extra?.coingecko_id || "Unknown"),
            pfp: g_chain.pfp,
            ...g_coin
          },
          details: {
            symbol: si_coin,
            denom: g_coin.denom,
            coingecko: g_coin.extra?.coingecko_id || ""
          }
        }))),
        ["symbol", "denom"]
      ))(),
      ...await Promise.all([
        (async () => {
          const ks_accounts = await Accounts.read();
          return fuzey(
            ks_accounts.entries().map(([p_account, g_account]) => {
              const a_addrs = [];
              const as_addrs = /* @__PURE__ */ new Set();
              for (const [, g_chain] of ks_chains) {
                as_addrs.add(Chains.addressFor(g_account.pubkey, g_chain));
              }
              a_addrs.push(...as_addrs);
              return {
                class: ClassType.ACCOUNT,
                name: g_account.name,
                resourcePath: p_account,
                resource: g_account,
                details: { name: g_account.name, addresses: a_addrs }
              };
            }),
            ["addresses"]
          );
        })(),
        (async () => {
          const ks_agents = await Agents.read();
          return fuzey(
            [...ks_agents.contacts()].map(([p_contact, g_contact]) => ({
              class: ClassType.CONTACT,
              name: g_contact.name,
              resourcePath: p_contact,
              resource: g_contact,
              details: {
                name: g_contact.name,
                notes: g_contact.notes,
                addresses: [...ks_chains.inFamily(g_contact.family)].map(([, g_chain]) => Chains.bech32(g_contact.address, g_chain))
              }
            })),
            ["notes"]
          );
        })(),
        (async () => {
          const ks_apps = await Apps.read();
          return fuzey(
            ks_apps.entries().map(([p_app, g_app]) => ({
              class: ClassType.APP,
              name: g_app.host,
              resourcePath: p_app,
              resource: g_app,
              details: { host: g_app.host }
            })),
            []
          );
        })(),
        (async () => {
          const a_tokens = [];
          for (const [, g_chain] of ks_chains.entries()) {
            for (const [si_spec, h_tokens] of ode(await Entities.readFungibleTokens(g_chain))) {
              for (const [p_token, g_token2] of ode(h_tokens)) {
                a_tokens.push({
                  class: ClassType.TOKEN,
                  name: g_token2.name,
                  resourcePath: p_token,
                  resource: g_token2,
                  details: {
                    spec: si_spec,
                    name: g_token2.name,
                    symbol: g_token2.symbol,
                    bech32: g_token2.bech32,
                    codehash: g_token2.hash
                  }
                });
              }
            }
          }
          return fuzey(a_tokens, ["spec", "symbol", "bech32", "codehash"]);
        })()
      ])
    ];
  })();
  function search2(s_search) {
    const a_groups = [];
    const a_hits = [];
    let c_total = 0;
    for (const y_fuse of a_fuses) {
      const a_hits_local = y_fuse.search(s_search);
      if (a_hits_local.length) {
        c_total += a_hits.length;
        a_hits.push(...a_hits_local);
        a_groups.push({
          top: a_hits_local[0].score,
          hits: a_hits_local
        });
      }
    }
    a_hits.sort((g_a, g_b) => g_b.score - g_a.score);
    $$invalidate(1, dm_results.innerHTML = "", dm_results);
    console.log(a_hits);
    for (const g_hit of a_hits) {
      new Row({
        target: dm_results,
        props: { ...g_hit.item, pfpDim: 32 }
      });
    }
  }
  const search_handler = (d_event) => search2(d_event.detail);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_results = $$value;
      $$invalidate(1, dm_results);
    });
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      {
        if ($yw_search) {
          search2($yw_search);
        }
      }
    }
  };
  return [
    $yw_search,
    dm_results,
    $yw_header_props,
    a_results,
    search2,
    search_handler,
    div_binding
  ];
}
class Search extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$7, safe_not_equal, {});
  }
}
var Progress_svelte_svelte_type_style_lang = "";
function create_fragment$6(ctx) {
  let div1;
  let div0;
  let t0;
  let div2;
  let t1;
  let t2_value = (ctx[0][0] || ctx[0][1]) + "";
  let t2;
  let t3;
  let t4_value = ctx[0][1] + "";
  let t4;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      div2 = element("div");
      t1 = text("Step ");
      t2 = text(t2_value);
      t3 = text(" of ");
      t4 = text(t4_value);
      attr(div0, "class", "bar svelte-1hwu1hf");
      set_style(div0, "width", ctx[1] + "%");
      attr(div1, "class", "progress svelte-1hwu1hf");
      toggle_class(div1, "visible", ctx[0][0] > 0);
      attr(div2, "class", "step svelte-1hwu1hf");
      toggle_class(div2, "visible", ctx[0][0] > 0);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      insert(target, t0, anchor);
      insert(target, div2, anchor);
      append(div2, t1);
      append(div2, t2);
      append(div2, t3);
      append(div2, t4);
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        set_style(div0, "width", ctx2[1] + "%");
      }
      if (dirty & 1) {
        toggle_class(div1, "visible", ctx2[0][0] > 0);
      }
      if (dirty & 1 && t2_value !== (t2_value = (ctx2[0][0] || ctx2[0][1]) + ""))
        set_data(t2, t2_value);
      if (dirty & 1 && t4_value !== (t4_value = ctx2[0][1] + ""))
        set_data(t4, t4_value);
      if (dirty & 1) {
        toggle_class(div2, "visible", ctx2[0][0] > 0);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div2);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let x_width_pct_bar;
  let $yw_progress;
  component_subscribe($$self, yw_progress, ($$value) => $$invalidate(0, $yw_progress = $$value));
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 1) {
      $$invalidate(1, x_width_pct_bar = $yw_progress[0] / $yw_progress[1] * 100);
    }
  };
  return [$yw_progress, x_width_pct_bar];
}
class Progress extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$6, safe_not_equal, {});
  }
}
var SX_ICON_CHAINS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="m18 16 4-4-4-4v3h-5.06A8.974 8.974 0 0 0 8 3.95 3.005 3.005 0 0 0 5 1C3.34 1 2 2.34 2 4s1.34 3 3 3c.95 0 1.78-.45 2.33-1.14C9.23 6.9 10.6 8.77 10.92 11h-3.1C7.4 9.84 6.3 9 5 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c1.3 0 2.4-.84 2.82-2h3.1c-.32 2.23-1.69 4.1-3.58 5.14C6.78 17.45 5.95 17 5 17c-1.66 0-3 1.34-3 3s1.34 3 3 3a2.99 2.99 0 0 0 2.99-2.95A8.974 8.974 0 0 0 12.93 13H18v3z"/>\n</svg>';
var SX_ICON_ACCOUNTS = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM7.07 18.28c.43-.9 3.05-1.78 4.93-1.78s4.51.88 4.93 1.78C15.57 19.36 13.86 20 12 20s-3.57-.64-4.93-1.72zm11.29-1.45c-1.43-1.74-4.9-2.33-6.36-2.33s-4.93.59-6.36 2.33A7.95 7.95 0 0 1 4 12c0-4.41 3.59-8 8-8s8 3.59 8 8c0 1.82-.62 3.49-1.64 4.83zM12 6c-1.94 0-3.5 1.56-3.5 3.5S10.06 13 12 13s3.5-1.56 3.5-3.5S13.94 6 12 6zm0 5c-.83 0-1.5-.67-1.5-1.5S11.17 8 12 8s1.5.67 1.5 1.5S12.83 11 12 11z"/>\n</svg>';
var SX_ICON_LOGOUT = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n	<path style="fill: var(--svg-color-fg, currentColor);" d="M18 4v16H6V4h12m0-2H6c-1.1 0-2 .9-2 2v18h16V4c0-1.1-.9-2-2-2zm-2.5 8.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5S17 12.83 17 12s-.67-1.5-1.5-1.5z"/>\n</svg>';
var SideMenu_svelte_svelte_type_style_lang = "";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let li;
  let span0;
  let raw_value = ctx[10].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[10].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler_2() {
    return ctx[5](ctx[10]);
  }
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon svelte-fhv297");
      attr(span1, "class", "text svelte-fhv297");
      attr(li, "class", "svelte-fhv297");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span0);
      span0.innerHTML = raw_value;
      append(li, t0);
      append(li, span1);
      append(span1, t1);
      append(li, t2);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block(ctx) {
  let li;
  let span0;
  let raw_value = ctx[10].icon + "";
  let t0;
  let span1;
  let t1_value = ctx[10].label + "";
  let t1;
  let t2;
  let mounted;
  let dispose;
  function click_handler_3() {
    return ctx[6](ctx[10]);
  }
  return {
    c() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "icon svelte-fhv297");
      attr(span1, "class", "text svelte-fhv297");
      attr(li, "class", " svelte-fhv297");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, span0);
      span0.innerHTML = raw_value;
      append(li, t0);
      append(li, span1);
      append(span1, t1);
      append(li, t2);
      if (!mounted) {
        dispose = listen(li, "click", click_handler_3);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$5(ctx) {
  let div6;
  let div0;
  let t0;
  let div5;
  let div1;
  let t1;
  let div4;
  let div2;
  let ul0;
  let t2;
  let hr;
  let t3;
  let div3;
  let ul1;
  let mounted;
  let dispose;
  let each_value_1 = ctx[2];
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div6 = element("div");
      div0 = element("div");
      t0 = space();
      div5 = element("div");
      div1 = element("div");
      t1 = space();
      div4 = element("div");
      div2 = element("div");
      ul0 = element("ul");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      hr = element("hr");
      t3 = space();
      div3 = element("div");
      ul1 = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "backdrop svelte-fhv297");
      attr(div1, "class", "close icon svelte-fhv297");
      attr(ul0, "class", "session svelte-fhv297");
      attr(hr, "class", "svelte-fhv297");
      attr(div2, "class", "top svelte-fhv297");
      attr(ul1, "class", "items svelte-fhv297");
      attr(div3, "class", "main svelte-fhv297");
      attr(div4, "class", "menu svelte-fhv297");
      attr(div5, "class", "bar svelte-fhv297");
      attr(div6, "class", "side-menu svelte-fhv297");
      toggle_class(div6, "collapsed", !ctx[0]);
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      append(div6, t0);
      append(div6, div5);
      append(div5, div1);
      div1.innerHTML = SX_ICON_CLOSE;
      append(div5, t1);
      append(div5, div4);
      append(div4, div2);
      append(div2, ul0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(ul0, null);
      }
      append(div2, t2);
      append(div2, hr);
      append(div4, t3);
      append(div4, div3);
      append(div3, ul1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ul1, null);
      }
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[3]),
          listen(div1, "click", ctx[4])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4) {
        each_value_1 = ctx2[2];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(ul0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & 2) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 1) {
        toggle_class(div6, "collapsed", !ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div6);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_menu_expanded;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(7, $yw_navigator = $$value));
  component_subscribe($$self, yw_menu_expanded, ($$value) => $$invalidate(0, $yw_menu_expanded = $$value));
  getContext("page");
  function activate(si_thread) {
    set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
    if (si_thread === $yw_navigator.activeThread.id) {
      $yw_navigator.activeThread.reset();
    } else {
      void $yw_navigator.activateThread(si_thread);
    }
  }
  const A_ITEMS = [
    {
      label: "Accounts",
      icon: SX_ICON_ACCOUNTS,
      click() {
        activate(ThreadId.ACCOUNTS);
      }
    },
    {
      label: "Networks",
      icon: SX_ICON_CHAINS,
      click() {
        activate(ThreadId.NETWORKS);
      }
    }
  ];
  const A_SESSION_ITEMS = [
    {
      label: "Log out",
      icon: SX_ICON_LOGOUT,
      async click() {
        await logout();
        globalThis.close();
      }
    }
  ];
  const click_handler2 = () => set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
  const click_handler_1 = () => set_store_value(yw_menu_expanded, $yw_menu_expanded = false, $yw_menu_expanded);
  const click_handler_2 = (g_item) => g_item.click();
  const click_handler_3 = (g_item) => g_item.click();
  return [
    $yw_menu_expanded,
    A_ITEMS,
    A_SESSION_ITEMS,
    click_handler2,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
class SideMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$3, create_fragment$5, safe_not_equal, {});
  }
}
var VendorMenu_svelte_svelte_type_style_lang = "";
function create_else_block(ctx) {
  let t;
  return {
    c() {
      t = text("[...]");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_if_block$2(ctx) {
  let t0_value = (ctx[1] / 1e3).toFixed(2) + "";
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" seconds");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && t0_value !== (t0_value = (ctx2[1] / 1e3).toFixed(2) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(t1);
    }
  };
}
function create_fragment$4(ctx) {
  let div26;
  let div0;
  let t0;
  let div25;
  let div1;
  let t1;
  let div24;
  let div23;
  let div4;
  let div2;
  let t2;
  let div3;
  let t5;
  let div7;
  let div5;
  let t7;
  let div6;
  let t8;
  let t9;
  let div10;
  let div8;
  let t11;
  let div9;
  let span0;
  let t12;
  let t13;
  let div13;
  let div11;
  let t15;
  let div12;
  let span1;
  let t16;
  let t17;
  let div16;
  let div14;
  let t19;
  let div15;
  let t20;
  let t21;
  let t22;
  let div19;
  let div17;
  let t24;
  let div18;
  let t25;
  let div22;
  let div20;
  let t27;
  let div21;
  let t28;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[1])
      return create_if_block$2;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div26 = element("div");
      div0 = element("div");
      t0 = space();
      div25 = element("div");
      div1 = element("div");
      t1 = space();
      div24 = element("div");
      div23 = element("div");
      div4 = element("div");
      div2 = element("div");
      t2 = space();
      div3 = element("div");
      div3.textContent = `v${SI_VERSION}`;
      t5 = space();
      div7 = element("div");
      div5 = element("div");
      div5.textContent = "Network Status";
      t7 = space();
      div6 = element("div");
      t8 = text(ctx[2]);
      t9 = space();
      div10 = element("div");
      div8 = element("div");
      div8.textContent = "Chain Id";
      t11 = space();
      div9 = element("div");
      span0 = element("span");
      t12 = text(ctx[4]);
      t13 = space();
      div13 = element("div");
      div11 = element("div");
      div11.textContent = "Current Provider";
      t15 = space();
      div12 = element("div");
      span1 = element("span");
      t16 = text(ctx[3]);
      t17 = space();
      div16 = element("div");
      div14 = element("div");
      div14.textContent = "Current Block Height";
      t19 = space();
      div15 = element("div");
      t20 = text("#");
      t21 = text(ctx[0]);
      t22 = space();
      div19 = element("div");
      div17 = element("div");
      div17.textContent = "Average Block Time";
      t24 = space();
      div18 = element("div");
      if_block.c();
      t25 = space();
      div22 = element("div");
      div20 = element("div");
      div20.textContent = "Last Block Seen";
      t27 = space();
      div21 = element("div");
      t28 = text(ctx[5]);
      attr(div0, "class", "backdrop svelte-1y4wjl5");
      attr(div1, "class", "close icon svelte-1y4wjl5");
      attr(div4, "class", "app svelte-1y4wjl5");
      attr(div5, "class", "name svelte-1y4wjl5");
      attr(div6, "class", "value svelte-1y4wjl5");
      attr(div7, "class", "info svelte-1y4wjl5");
      attr(div8, "class", "name svelte-1y4wjl5");
      attr(span0, "class", "font-family_mono svelte-1y4wjl5");
      attr(div9, "class", "value svelte-1y4wjl5");
      attr(div10, "class", "info svelte-1y4wjl5");
      attr(div11, "class", "name svelte-1y4wjl5");
      attr(span1, "class", "font-family_mono svelte-1y4wjl5");
      attr(div12, "class", "value svelte-1y4wjl5");
      attr(div13, "class", "info svelte-1y4wjl5");
      attr(div14, "class", "name svelte-1y4wjl5");
      attr(div15, "class", "value svelte-1y4wjl5");
      attr(div16, "class", "info svelte-1y4wjl5");
      attr(div17, "class", "name svelte-1y4wjl5");
      attr(div18, "class", "value svelte-1y4wjl5");
      attr(div19, "class", "info svelte-1y4wjl5");
      attr(div20, "class", "name svelte-1y4wjl5");
      attr(div21, "class", "value svelte-1y4wjl5");
      attr(div22, "class", "info svelte-1y4wjl5");
      attr(div23, "class", "main svelte-1y4wjl5");
      attr(div24, "class", "menu svelte-1y4wjl5");
      attr(div25, "class", "bar svelte-1y4wjl5");
      attr(div26, "class", "vendor-menu svelte-1y4wjl5");
      toggle_class(div26, "collapsed", !ctx[6]);
    },
    m(target, anchor) {
      insert(target, div26, anchor);
      append(div26, div0);
      append(div26, t0);
      append(div26, div25);
      append(div25, div1);
      append(div25, t1);
      append(div25, div24);
      append(div24, div23);
      append(div23, div4);
      append(div4, div2);
      append(div4, t2);
      append(div4, div3);
      append(div23, t5);
      append(div23, div7);
      append(div7, div5);
      append(div7, t7);
      append(div7, div6);
      append(div6, t8);
      append(div23, t9);
      append(div23, div10);
      append(div10, div8);
      append(div10, t11);
      append(div10, div9);
      append(div9, span0);
      append(span0, t12);
      append(div23, t13);
      append(div23, div13);
      append(div13, div11);
      append(div13, t15);
      append(div13, div12);
      append(div12, span1);
      append(span1, t16);
      append(div23, t17);
      append(div23, div16);
      append(div16, div14);
      append(div16, t19);
      append(div16, div15);
      append(div15, t20);
      append(div15, t21);
      append(div23, t22);
      append(div23, div19);
      append(div19, div17);
      append(div19, t24);
      append(div19, div18);
      if_block.m(div18, null);
      append(div23, t25);
      append(div23, div22);
      append(div22, div20);
      append(div22, t27);
      append(div22, div21);
      append(div21, t28);
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[8]),
          listen(div1, "click", ctx[9])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 4)
        set_data(t8, ctx2[2]);
      if (dirty & 16)
        set_data(t12, ctx2[4]);
      if (dirty & 8)
        set_data(t16, ctx2[3]);
      if (dirty & 1)
        set_data(t21, ctx2[0]);
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div18, null);
        }
      }
      if (dirty & 32)
        set_data(t28, ctx2[5]);
      if (dirty & 64) {
        toggle_class(div26, "collapsed", !ctx2[6]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div26);
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $yw_chain_ref;
  let $yw_network;
  let $yw_menu_vendor;
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(11, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_network, ($$value) => $$invalidate(7, $yw_network = $$value));
  component_subscribe($$self, yw_menu_vendor, ($$value) => $$invalidate(6, $yw_menu_vendor = $$value));
  let s_height = "";
  let xt_when = 0;
  let xt_avg_block_time = 0;
  let s_network_status = "Loading";
  let p_provider = "";
  let si_chain = "";
  global_receive({
    blockInfo(g_info) {
      if ($yw_chain_ref === g_info.chain) {
        $$invalidate(2, s_network_status = "Online");
        $$invalidate(4, si_chain = g_info.header.chain_id);
        $$invalidate(0, s_height = g_info.header.height);
        xt_when = Date.now();
        const a_recents = g_info.recents;
        if (a_recents.length > 1) {
          const a_gaps = [];
          for (let i_each = 1; i_each < a_recents.length; i_each++) {
            a_gaps.push(a_recents[i_each] - a_recents[i_each - 1]);
          }
          $$invalidate(1, xt_avg_block_time = a_gaps.reduce((c_out, x_value) => c_out + x_value, 0) / a_gaps.length);
        }
      }
    }
  });
  let s_long_ago = "[...]";
  const i_long_ago = window.setInterval(
    () => {
      if (xt_when > 0) {
        const xt_ago = Date.now() - xt_when;
        $$invalidate(5, s_long_ago = `${Math.round(xt_ago / 1e3)} seconds ago`);
      }
    },
    500
  );
  onDestroy(() => {
    clearInterval(i_long_ago);
  });
  const click_handler2 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = false, $yw_menu_vendor);
  const click_handler_1 = () => set_store_value(yw_menu_vendor, $yw_menu_vendor = false, $yw_menu_vendor);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 128) {
      if ($yw_network) {
        $$invalidate(0, s_height = "[...]");
        xt_when = 0;
        $$invalidate(1, xt_avg_block_time = 0);
        $$invalidate(2, s_network_status = "Connecting");
        $$invalidate(3, p_provider = new URL($yw_network.grpcWebUrl).host);
        $$invalidate(4, si_chain = "");
      }
    }
  };
  return [
    s_height,
    xt_avg_block_time,
    s_network_status,
    p_provider,
    si_chain,
    s_long_ago,
    $yw_menu_vendor,
    $yw_network,
    click_handler2,
    click_handler_1
  ];
}
class VendorMenu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2, create_fragment$4, safe_not_equal, {});
  }
}
class Page {
  constructor(gc_page, _kt_parent) {
    __publicField(this, "_dc_creator");
    __publicField(this, "_yc_component");
    __publicField(this, "_h_props");
    __publicField(this, "_h_context");
    __publicField(this, "_dm_page");
    __publicField(this, "_si_page");
    __publicField(this, "_h_events", {});
    __publicField(this, "_sr_path");
    __publicField(this, "_sx_pattern");
    this._kt_parent = _kt_parent;
    ({
      creator: this._dc_creator,
      props: this._h_props = {},
      context: this._h_context = {}
    } = gc_page);
    this._si_page = crypto.randomUUID();
    const dm_buffer = dd("div");
    const hm_context = new Map(ode({
      ...this._h_context,
      page: this
    }));
    this._yc_component = new this._dc_creator({
      target: dm_buffer,
      props: {
        ...this._h_props,
        k_page: this
      },
      context: hm_context
    });
    if (gc_page.events) {
      for (const [si_event, f_listener] of ode(gc_page.events)) {
        this._yc_component.$on(si_event, f_listener);
      }
    }
    const dm_state = dm_buffer.firstElementChild;
    if (!dm_state) {
      throw new Error(`No DOM element was created during page component spawning using: ${JSON.stringify(gc_page)}`);
    }
    this._dm_page = dm_state;
  }
  get id() {
    return this._si_page;
  }
  get index() {
    return this.thread.history.length;
  }
  get thread() {
    return this._kt_parent;
  }
  get creator() {
    return this._dc_creator;
  }
  get component() {
    return this._yc_component;
  }
  get props() {
    return this._h_props;
  }
  get dom() {
    return this._dm_page;
  }
  equivalent(w_other) {
    return w_other.creator === this.creator && !objects_might_differ(w_other.props || {}, this.props);
  }
  peak() {
    return this._kt_parent.peak();
  }
  push(gc_page) {
    return this._kt_parent.push(gc_page, this);
  }
  pop(gc_pop) {
    return this._kt_parent.pop(gc_pop || {}, this);
  }
  jump(gc_page, gc_jump) {
    return this._kt_parent.jump(gc_page, gc_jump || {}, this);
  }
  on(h_events) {
    for (const [si_event, f_listener] of ode(h_events)) {
      if (f_listener) {
        const a_listeners = this._h_events[si_event] = this._h_events[si_event] || [];
        a_listeners.push(f_listener);
      }
    }
  }
  async fire(si_event, a_args) {
    const a_listeners = this._h_events[si_event];
    if (a_listeners) {
      await Promise.all(a_listeners.map((f) => f(...a_args || [])));
    }
  }
  destroy() {
    this._yc_component.$destroy();
  }
  reset() {
    this._kt_parent.reset();
  }
}
class Thread {
  constructor(_si_thread, _gc_default, _k_navigator) {
    __publicField(this, "_dm_thread");
    __publicField(this, "_a_history", []);
    this._si_thread = _si_thread;
    this._gc_default = _gc_default;
    this._k_navigator = _k_navigator;
    this._dm_thread = dd("div", {
      "class": "thread",
      "data-thread-id": this._si_thread,
      "style": "z-index: 100;"
    });
  }
  get id() {
    return this._si_thread;
  }
  get default() {
    return this._gc_default;
  }
  get history() {
    return this._a_history;
  }
  get page() {
    return this._a_history[0];
  }
  get dom() {
    return this._dm_thread;
  }
  _place(gc_page) {
    const kp_new = new Page({
      ...gc_page,
      context: {
        ...this._k_navigator.context,
        ...gc_page.context
      }
    }, this);
    this._dm_thread.appendChild(kp_new.dom);
    this._a_history.unshift(kp_new);
    return kp_new;
  }
  reset(gc_page = this.default, gc_reset) {
    const {
      keepTop: b_keep_top
    } = gc_reset || {};
    const a_history = this._a_history;
    for (let i_state = b_keep_top ? 1 : 0; i_state < a_history.length; i_state++) {
      a_history[i_state].component.$destroy();
    }
    a_history.length = 0;
    const kp_new = this._place(gc_page);
    void this._k_navigator.after_reset(this, kp_new, gc_reset || {});
    return kp_new;
  }
  peak() {
    return this._a_history[1];
  }
  push(gc_page, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from pushing new screen");
    }
    if (!this._k_navigator.before_push(gc_page, kp_src, this)) {
      throw new Error("Prevented inactive thread from pushing new screen");
    }
    const kp_new = this._place(gc_page);
    void this._k_navigator.after_push(this, kp_src, kp_new);
    return kp_new;
  }
  pop(gc_pop, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from popping active screen");
    }
    if (this._a_history.length < 2) {
      throw new Error(`Failed to pop empty history`);
    }
    if (!this._k_navigator.before_pop(gc_pop, this._a_history[1], kp_src, this)) {
      throw new Error("Prevented inactive thread from popping active screen");
    }
    this._a_history.shift();
    const kp_dst = this.page;
    void this._k_navigator.after_pop(this, kp_src, kp_dst, gc_pop);
    return kp_dst;
  }
  jump(gc_page, gc_jump, kp_src) {
    if (kp_src !== this.page) {
      throw new Error("Prevented inactive page from jumping to screen");
    }
    if (!this._k_navigator.before_jump(gc_jump, gc_page, kp_src, this)) {
      throw new Error("Prevented inactive thread from jumping to screen");
    }
    const kp_prev = this._a_history[1];
    if (!gc_jump.force && kp_prev?.equivalent(gc_page)) {
      return this.pop({}, kp_src);
    }
    const kp_dst = new Page(gc_page, this);
    this.reset();
    set_zindex_relatively(kp_dst.dom, kp_src.dom, 1);
    void this._k_navigator.after_jump(this, kp_src, kp_dst, gc_jump).then(() => {
      try {
        kp_src.destroy();
      } catch (e_destroy) {
        console.warn(`Failed to destroy stale component belonging to page: ${kp_src.creator.name + ""}`);
        kp_src.dom.remove();
      }
    });
    return kp_dst;
  }
  hide() {
    this._dm_thread.style.display = "none";
  }
  show() {
    this._dm_thread.style.display = "initial";
  }
}
function set_zindex_relatively(dm_src, dm_dst, n_order) {
  const iz_src = +dm_src.style.zIndex;
  const iz_dst = iz_src + n_order;
  dm_src.style.zIndex = iz_src + "";
  dm_dst.style.zIndex = iz_dst + "";
}
class Navigator {
  constructor(_gc_navigator) {
    __publicField(this, "_h_threads", {});
    __publicField(this, "_h_thread_spawners");
    __publicField(this, "_dm_threads");
    __publicField(this, "_dm_buffer", dd("div"));
    __publicField(this, "_g_hooks");
    __publicField(this, "_h_context");
    __publicField(this, "_si_thread", ThreadId.DEFAULT);
    __publicField(this, "_c_thread_z", 200);
    this._gc_navigator = _gc_navigator;
    ({
      container: this._dm_threads,
      threads: this._h_thread_spawners,
      hooks: this._g_hooks,
      context: this._h_context = {}
    } = _gc_navigator);
    this._new_thread(ThreadId.DEFAULT);
  }
  get context() {
    return this._h_context;
  }
  _new_thread(si_thread, h_props = {}, h_context = {}) {
    const f_spawner = this._h_thread_spawners[si_thread];
    if (!f_spawner) {
      throw new Error(`Navigator has no such thread registered: '${si_thread}'`);
    }
    const kt_new = new Thread(si_thread, f_spawner(h_props, h_context), this);
    this._h_threads[si_thread] = kt_new;
    this._dm_threads.appendChild(kt_new.dom);
    kt_new.reset({
      ...kt_new.default,
      props: {
        ...kt_new.default.props,
        ...h_props
      }
    });
    return kt_new;
  }
  get activeThread() {
    return this._h_threads[this._si_thread];
  }
  get activePage() {
    return this.activeThread.page;
  }
  before_push(gc_page, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (false === this._g_hooks.before_change?.(kt_child, kp_src, "push"))
      return false;
    if (false === this._g_hooks.before_push?.(kt_child, kp_src, gc_page))
      return false;
    return true;
  }
  before_pop(gc_pop, kp_dst, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (false === this._g_hooks.before_change?.(kt_child, kp_src, "pop"))
      return false;
    if (false === this._g_hooks.before_pop?.(kt_child, kp_src, kp_dst, gc_pop))
      return false;
    return true;
  }
  before_jump(gc_jump, gc_page, kp_src, kt_child) {
    if (this.activeThread !== kt_child)
      return false;
    if (false === this._g_hooks.before_change?.(kt_child, kp_src, "jump"))
      return false;
    if (false === this._g_hooks.before_jump?.(kt_child, kp_src, gc_page, gc_jump))
      return false;
    return true;
  }
  async before_switch(kt_src, si_thread) {
    if (false === this._g_hooks.before_change?.(kt_src, kt_src.page, "switch"))
      throw new Error("Cannot stop thread switch");
    await this._g_hooks.before_switch?.(kt_src, si_thread);
  }
  async after_push(kt_child, kp_src, kp_dst) {
    const h_extra = await this._g_hooks.after_push?.(kt_child, kp_src, kp_dst);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "push", h_extra || {});
  }
  async after_pop(kt_child, kp_src, kp_dst, gc_pop) {
    const h_extra = await this._g_hooks.after_pop?.(kt_child, kp_src, kp_dst, gc_pop);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "pop", h_extra || {});
  }
  async after_jump(kt_child, kp_src, kp_dst, gc_jump) {
    const h_extra = await this._g_hooks.after_jump?.(kt_child, kp_src, kp_dst, gc_jump);
    await this._g_hooks.after_change?.(kt_child, kp_src, kp_dst, "jump", h_extra || {});
  }
  async after_reset(kt_child, kp_dst, gc_reset) {
    const h_extra = await this._g_hooks.after_reset?.(kt_child, kp_dst, gc_reset);
    await this._g_hooks.after_change?.(kt_child, null, kp_dst, "reset", h_extra || {});
  }
  async after_switch(kt_src, kt_dst) {
    await this._g_hooks.after_switch?.(kt_src, kt_dst);
  }
  async activateThread(si_thread, h_props = {}) {
    const kt_src = this.activeThread;
    const kp_src = this.activePage;
    let kt_dst = this._h_threads[si_thread];
    if (si_thread !== this._si_thread) {
      await this.before_switch(kt_src, si_thread);
      this._si_thread;
      if (!kt_dst) {
        kt_dst = this._new_thread(si_thread, h_props);
      } else if (objects_might_differ(kt_dst.default.props || {}, h_props)) {
        const kp_dst = new Page({
          ...kt_dst.default,
          props: h_props,
          context: this._h_context
        }, kt_dst);
        kt_dst.reset(kp_dst, {
          keepTop: true
        });
        set_zindex_relatively(kp_src.dom, kp_dst.dom, -1);
      }
      this._si_thread = si_thread;
      this.activeThread.show();
      this.activeThread.dom.style.zIndex = this._c_thread_z++ + "";
      await this.after_switch(kt_src, kt_dst);
      return true;
    }
    return false;
  }
}
var System_svelte_svelte_type_style_lang = "";
function create_if_block$1(ctx) {
  let await_block_anchor;
  let current;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 25,
    blocks: [, , ,]
  };
  handle_promise(Vault.getRootKey(), info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(info.block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < 3; i += 1) {
        const block = info.blocks[i];
        transition_out(block);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(await_block_anchor);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_then_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[25] && create_if_block_1();
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_1(ctx) {
  let overscrollsvelte;
  let t0;
  let navsvelte;
  let t1;
  let searchsvelte;
  let t2;
  let vendormenusvelte;
  let t3;
  let sidemenusvelte;
  let t4;
  let popupsvelte;
  let current;
  overscrollsvelte = new Overscroll({});
  navsvelte = new Nav({});
  searchsvelte = new Search({});
  vendormenusvelte = new VendorMenu({});
  sidemenusvelte = new SideMenu({});
  popupsvelte = new Popup({});
  return {
    c() {
      create_component(overscrollsvelte.$$.fragment);
      t0 = space();
      create_component(navsvelte.$$.fragment);
      t1 = space();
      create_component(searchsvelte.$$.fragment);
      t2 = space();
      create_component(vendormenusvelte.$$.fragment);
      t3 = space();
      create_component(sidemenusvelte.$$.fragment);
      t4 = space();
      create_component(popupsvelte.$$.fragment);
    },
    m(target, anchor) {
      mount_component(overscrollsvelte, target, anchor);
      insert(target, t0, anchor);
      mount_component(navsvelte, target, anchor);
      insert(target, t1, anchor);
      mount_component(searchsvelte, target, anchor);
      insert(target, t2, anchor);
      mount_component(vendormenusvelte, target, anchor);
      insert(target, t3, anchor);
      mount_component(sidemenusvelte, target, anchor);
      insert(target, t4, anchor);
      mount_component(popupsvelte, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(overscrollsvelte.$$.fragment, local);
      transition_in(navsvelte.$$.fragment, local);
      transition_in(searchsvelte.$$.fragment, local);
      transition_in(vendormenusvelte.$$.fragment, local);
      transition_in(sidemenusvelte.$$.fragment, local);
      transition_in(popupsvelte.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(overscrollsvelte.$$.fragment, local);
      transition_out(navsvelte.$$.fragment, local);
      transition_out(searchsvelte.$$.fragment, local);
      transition_out(vendormenusvelte.$$.fragment, local);
      transition_out(sidemenusvelte.$$.fragment, local);
      transition_out(popupsvelte.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(overscrollsvelte, detaching);
      if (detaching)
        detach(t0);
      destroy_component(navsvelte, detaching);
      if (detaching)
        detach(t1);
      destroy_component(searchsvelte, detaching);
      if (detaching)
        detach(t2);
      destroy_component(vendormenusvelte, detaching);
      if (detaching)
        detach(t3);
      destroy_component(sidemenusvelte, detaching);
      if (detaching)
        detach(t4);
      destroy_component(popupsvelte, detaching);
    }
  };
}
function create_pending_block(ctx) {
  return {
    c: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
}
function create_fragment$3(ctx) {
  let main;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2;
  let progresssvelte;
  let t3;
  let current;
  const default_slot_template = ctx[7].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[6], null);
  progresssvelte = new Progress({});
  let if_block = ctx[3] && create_if_block$1(ctx);
  return {
    c() {
      main = element("main");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(progresssvelte.$$.fragment);
      t3 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "content threads svelte-m1b0zj");
      attr(div1, "class", "content exitting svelte-m1b0zj");
      attr(main, "class", "viewport svelte-m1b0zj");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div0);
      ctx[8](div0);
      append(main, t0);
      append(main, div1);
      ctx[9](div1);
      append(main, t1);
      if (default_slot) {
        default_slot.m(main, null);
      }
      append(main, t2);
      mount_component(progresssvelte, main, null);
      append(main, t3);
      if (if_block)
        if_block.m(main, null);
      ctx[10](main);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[6],
            !current ? get_all_dirty_from_scope(ctx2[6]) : get_slot_changes(default_slot_template, ctx2[6], dirty, null),
            null
          );
        }
      }
      if (ctx2[3])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(progresssvelte.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(progresssvelte.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      ctx[8](null);
      ctx[9](null);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(progresssvelte);
      if (if_block)
        if_block.d();
      ctx[10](null);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $yw_navigator;
  let $yw_thread;
  let $yw_page;
  let $yw_account_ref;
  let $yw_account;
  let $yw_network_ref;
  let $yw_network_active;
  let $yw_chain_ref;
  let $yw_chain;
  component_subscribe($$self, yw_navigator, ($$value) => $$invalidate(11, $yw_navigator = $$value));
  component_subscribe($$self, yw_thread, ($$value) => $$invalidate(12, $yw_thread = $$value));
  component_subscribe($$self, yw_page, ($$value) => $$invalidate(13, $yw_page = $$value));
  component_subscribe($$self, yw_account_ref, ($$value) => $$invalidate(14, $yw_account_ref = $$value));
  component_subscribe($$self, yw_account, ($$value) => $$invalidate(15, $yw_account = $$value));
  component_subscribe($$self, yw_network_ref, ($$value) => $$invalidate(16, $yw_network_ref = $$value));
  component_subscribe($$self, yw_network_active, ($$value) => $$invalidate(17, $yw_network_active = $$value));
  component_subscribe($$self, yw_chain_ref, ($$value) => $$invalidate(18, $yw_chain_ref = $$value));
  component_subscribe($$self, yw_chain, ($$value) => $$invalidate(19, $yw_chain = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { page } = $$props;
  const gc_page = page;
  let { mode } = $$props;
  const b_flow = "flow" === mode;
  const b_main = "app" === mode;
  let dm_viewport;
  let dm_threads;
  let dm_exitting;
  const h_context_all = Object.fromEntries(getAllContexts().entries());
  async function slide2(dm_slide, b_in = false) {
    await timeout(0);
    return new Promise((fk_resolve) => {
      dm_slide.addEventListener("transitionend", function transition_end(d_event) {
        if ("transform" === d_event.propertyName) {
          dm_slide.classList.add("slid");
          fk_resolve();
        }
      });
      dm_slide.style.transform = `translateX(${b_in ? "0px" : "var(--app-window-width)"})`;
    });
  }
  onMount(async () => {
    const gc_navigator = {
      container: dm_threads,
      context: h_context_all,
      threads: {
        default: () => ({ creator: Blank })
      },
      hooks: {
        before_change(kt_context, kp_src, kp_dst) {
          void kp_src.fire("blur");
        },
        after_push(kt_context, kp_src, kp_dst) {
          void tick().then(() => {
            void slide2(kp_dst.dom, true);
          });
        },
        after_pop(kt_context, kp_src, kp_dst, gc_pop) {
          void kp_dst.fire("restore");
          if (!gc_pop.bypassAnimation) {
            kp_src.dom.style.transform = `translateX(var(--app-window-width))`;
          }
        },
        after_change(kt_context, kp_src, kp_dst, s_transition, h_extra = {}) {
          set_store_value(yw_page, $yw_page = kp_dst, $yw_page);
          set_store_value(yw_thread, $yw_thread = kt_context, $yw_thread);
          void kp_dst.fire("focus");
        },
        async before_switch() {
          try {
            await Promise.all([
              $yw_chain || once_store_updates(yw_chain, true),
              Chains.read().then((ks) => set_store_value(yw_chain_ref, $yw_chain_ref = ode(ks.raw)[0][0], $yw_chain_ref)),
              $yw_network_active || once_store_updates(yw_network_active, true),
              Networks.read().then((ks) => set_store_value(yw_network_ref, $yw_network_ref = ode(ks.raw)[0][0], $yw_network_ref)),
              $yw_account || once_store_updates(yw_account, true),
              Accounts.read().then((ks) => set_store_value(yw_account_ref, $yw_account_ref = ode(ks.raw)[0][0], $yw_account_ref))
            ]);
            delete this.before_switch;
          } catch (e_load_default) {
          }
        },
        async after_switch(kt_src, kt_dst) {
          set_store_value(yw_page, $yw_page = kt_dst.page, $yw_page);
          set_store_value(yw_thread, $yw_thread = kt_dst, $yw_thread);
          void kt_dst.page.fire("focus");
          await tick();
          await slide2(kt_dst.page.dom, true);
        }
      }
    };
    if (b_flow) {
      gc_navigator.threads = { default: () => gc_page };
    } else if (b_main) {
      gc_navigator.threads = oderom(H_THREADS, (si_thread, dc_screen) => {
        return {
          [si_thread]: (h_props) => ({ creator: dc_screen, props: h_props })
        };
      });
      gc_navigator.threads.init = (h_props, h_context) => ({
        ...gc_page,
        props: { ...gc_page.props, ...h_props },
        context: { ...gc_page.context, ...h_context }
      });
    }
    const k_navigator = new Navigator(gc_navigator);
    set_store_value(yw_navigator, $yw_navigator = k_navigator, $yw_navigator);
  });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_threads = $$value;
      $$invalidate(1, dm_threads);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_exitting = $$value;
      $$invalidate(2, dm_exitting);
    });
  }
  function main_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dm_viewport = $$value;
      $$invalidate(0, dm_viewport);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("page" in $$props2)
      $$invalidate(4, page = $$props2.page);
    if ("mode" in $$props2)
      $$invalidate(5, mode = $$props2.mode);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  return [
    dm_viewport,
    dm_threads,
    dm_exitting,
    b_main,
    page,
    mode,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    main_binding
  ];
}
class System extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$3, safe_not_equal, { page: 4, mode: 5 });
  }
}
var Authenticate_svelte_svelte_type_style_lang = "";
function create_if_block(ctx) {
  let div;
  let t;
  let div_transition;
  let current;
  return {
    c() {
      div = element("div");
      t = text(ctx[1]);
      attr(div, "class", "validation-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & 2)
        set_data(t, ctx2[1]);
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o(local) {
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
      div_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_default_slot_1(ctx) {
  let input;
  let t;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[1] && create_if_block(ctx);
  return {
    c() {
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr(input, "type", "password");
      attr(input, "name", "password");
      attr(input, "placeholder", "Password");
      toggle_class(input, "invalid", ctx[1]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(input, ctx[0]);
      insert(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(input, "input", ctx[4]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (dirty & 2) {
        toggle_class(input, "invalid", ctx2[1]);
      }
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(input);
      if (detaching)
        detach(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot$1(ctx) {
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t3;
  let div3;
  let field;
  let t4;
  let actionsline;
  let t5;
  let log_1;
  let updating_items;
  let current;
  field = new Field({
    props: {
      key: "password",
      name: "",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  actionsline = new ActionsLine({
    props: {
      confirm: ["Unlock", ctx[3]]
    }
  });
  function log_1_items_binding(value) {
    ctx[5](value);
  }
  let log_1_props = { hide: true };
  if (ctx[2].items !== void 0) {
    log_1_props.items = ctx[2].items;
  }
  log_1 = new Log({ props: log_1_props });
  binding_callbacks.push(() => bind(log_1, "items", log_1_items_binding));
  return {
    c() {
      div0 = element("div");
      div0.innerHTML = `<img width="96" src="/media/vendor/logo-96px.png" srcset="/media/vendor/logo-96px.png 1x, /media/vendor/logo-192px.png 2x" alt="StarShell"/>`;
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<img src="/media/vendor/title.svg" alt=""/>`;
      t1 = space();
      div2 = element("div");
      div2.textContent = "\xA0";
      t3 = space();
      div3 = element("div");
      create_component(field.$$.fragment);
      t4 = space();
      create_component(actionsline.$$.fragment);
      t5 = space();
      create_component(log_1.$$.fragment);
      attr(div0, "class", "logo");
      attr(div1, "class", "title");
      attr(div2, "class", "line svelte-wsweyo");
      attr(div3, "class", "form flex-rows");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      insert(target, t3, anchor);
      insert(target, div3, anchor);
      mount_component(field, div3, null);
      insert(target, t4, anchor);
      mount_component(actionsline, target, anchor);
      insert(target, t5, anchor);
      mount_component(log_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const field_changes = {};
      if (dirty & 1027) {
        field_changes.$$scope = { dirty, ctx: ctx2 };
      }
      field.$set(field_changes);
      const log_1_changes = {};
      if (!updating_items && dirty & 4) {
        updating_items = true;
        log_1_changes.items = ctx2[2].items;
        add_flush_callback(() => updating_items = false);
      }
      log_1.$set(log_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(field.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      transition_in(log_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(field.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      transition_out(log_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div3);
      destroy_component(field);
      if (detaching)
        detach(t4);
      destroy_component(actionsline, detaching);
      if (detaching)
        detach(t5);
      destroy_component(log_1, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let t;
  let screen;
  let current;
  screen = new Screen({
    props: {
      debug: "Authenticate",
      classNames: "welcome",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      t = space();
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      insert(target, t, anchor);
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1031) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t);
      destroy_component(screen, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  const completed = getContext("completed");
  let sh_password = "";
  let s_err_password = "";
  let b_busy = false;
  let xt_start = 0;
  let k_logger = new Logger();
  function log(s_msg) {
    $$invalidate(2, k_logger = k_logger.event(s_msg, Date.now() - xt_start));
  }
  async function attempt_unlock(b_recover = false) {
    if (b_busy)
      return 1;
    b_busy = true;
    const exit = () => (b_busy = false, 1);
    $$invalidate(1, s_err_password = "");
    xt_start = Date.now();
    log("Estimating time to complete");
    {
      const xt_start_est = window.performance.now();
      await Vault.deriveRootBits(ATU8_DUMMY_PHRASE, ATU8_DUMMY_VECTOR, 1 / 50);
      const xt_finish_est = window.performance.now();
      const xt_elapsed = xt_finish_est - xt_start_est;
      const xt_estimate = 2 * (xt_elapsed * 50);
      log(`About ${(xt_estimate / 1e3).toFixed(1)} seconds`);
    }
    try {
      await login(sh_password, b_recover, log);
    } catch (e_login) {
      if (e_login instanceof UnregisteredError) {
        $$invalidate(1, s_err_password = "No accounts detected");
      } else if (e_login instanceof InvalidPassphraseError) {
        $$invalidate(1, s_err_password = "Invalid passphrase");
      } else if (e_login instanceof RecoverableVaultError) {
        $$invalidate(1, s_err_password = "Vault is partially corrupted; attempting recovery...");
        return await attempt_unlock(true);
      } else if (b_recover) {
        $$invalidate(1, s_err_password = `Recovery failed. Vault may be irreparably corrupted.
${e_login.message}`);
      } else if (e_login instanceof CorruptedVaultError) {
        $$invalidate(1, s_err_password = `Vault appears to be irreparably corrupted.
${e_login.message}`);
      } else {
        $$invalidate(1, s_err_password = `Unknown error occurred: ${e_login.stack || e_login.message}`);
      }
      return exit();
    }
    if (completed)
      completed(true);
    return exit();
  }
  function input_input_handler() {
    sh_password = this.value;
    $$invalidate(0, sh_password);
  }
  function log_1_items_binding(value) {
    if ($$self.$$.not_equal(k_logger.items, value)) {
      k_logger.items = value;
      $$invalidate(2, k_logger);
    }
  }
  return [
    sh_password,
    s_err_password,
    k_logger,
    attempt_unlock,
    input_input_handler,
    log_1_items_binding
  ];
}
class Authenticate extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment$2, safe_not_equal, {});
  }
}
const dm_log = qs(document, "section#dom-log");
const dm_log_list = qs(document, "#dom-log-list");
function domlog(si_msg) {
  console.log(si_msg);
  dm_log_list?.append(dd("li", {}, [
    dd("pre", {}, [si_msg])
  ]));
}
var Horizon_svelte_svelte_type_style_lang = "";
function create_fragment$1(ctx) {
  let div;
  let raw_value = "&nbsp;";
  return {
    c() {
      div = element("div");
      attr(div, "class", "no-margin horizon svelte-12kmiz9");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = raw_value;
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
class Horizon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$1, safe_not_equal, {});
  }
}
var PreRegister_svelte_svelte_type_style_lang = "";
function create_default_slot(ctx) {
  let starshelllogo;
  let t0;
  let starshelltitle;
  let t1;
  let horizon;
  let t2;
  let div2;
  let t6;
  let p2;
  let t7;
  let actionsline;
  let current;
  starshelllogo = new StarShellLogo({ props: { dim: 96 } });
  starshelltitle = new StarShellTitle({});
  horizon = new Horizon({});
  actionsline = new ActionsLine({
    props: {
      confirm: ["Get Started"],
      contd: { creator: Register }
    }
  });
  return {
    c() {
      create_component(starshelllogo.$$.fragment);
      t0 = space();
      create_component(starshelltitle.$$.fragment);
      t1 = space();
      create_component(horizon.$$.fragment);
      t2 = space();
      div2 = element("div");
      div2.innerHTML = `<div>Welcome to the beta program.</div> 
		<div>Thank for you being a tester!</div>`;
      t6 = space();
      p2 = element("p");
      t7 = space();
      create_component(actionsline.$$.fragment);
      attr(div2, "class", "large");
    },
    m(target, anchor) {
      mount_component(starshelllogo, target, anchor);
      insert(target, t0, anchor);
      mount_component(starshelltitle, target, anchor);
      insert(target, t1, anchor);
      mount_component(horizon, target, anchor);
      insert(target, t2, anchor);
      insert(target, div2, anchor);
      insert(target, t6, anchor);
      insert(target, p2, anchor);
      insert(target, t7, anchor);
      mount_component(actionsline, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(starshelllogo.$$.fragment, local);
      transition_in(starshelltitle.$$.fragment, local);
      transition_in(horizon.$$.fragment, local);
      transition_in(actionsline.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(starshelllogo.$$.fragment, local);
      transition_out(starshelltitle.$$.fragment, local);
      transition_out(horizon.$$.fragment, local);
      transition_out(actionsline.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(starshelllogo, detaching);
      if (detaching)
        detach(t0);
      destroy_component(starshelltitle, detaching);
      if (detaching)
        detach(t1);
      destroy_component(horizon, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(div2);
      if (detaching)
        detach(t6);
      if (detaching)
        detach(p2);
      if (detaching)
        detach(t7);
      destroy_component(actionsline, detaching);
    }
  };
}
function create_fragment(ctx) {
  let screen;
  let current;
  screen = new Screen({
    props: {
      root: true,
      classNames: "preregister",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(screen.$$.fragment);
    },
    m(target, anchor) {
      mount_component(screen, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const screen_changes = {};
      if (dirty & 1) {
        screen_changes.$$scope = { dirty, ctx: ctx2 };
      }
      screen.$set(screen_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(screen.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(screen.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(screen, detaching);
    }
  };
}
class PreRegister extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment, safe_not_equal, {});
  }
}
export { AccountEdit as A, Blank as B, Header as H, PreRegister as P, Screen as S, ThreadId as T, StarShellLogo as a, StarShellTitle as b, Horizon as c, dm_log as d, System as e, domlog as f, Authenticate as g };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJlUmVnaXN0ZXIuYzBiMzgwZTAuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3ZpdGUvbW9kdWxlcHJlbG9hZC1wb2x5ZmlsbCIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0JsYW5rLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL1NjcmVlbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3VpL1N0YXJTaGVsbExvZ28uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9PdmVybGF5U2VsZWN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL2Fycm93LWxlZnQuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3NlYXJjaC5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vY2hlY2tlZC1jaXJjbGUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvSGVhZGVyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvTG9nLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvU3RhclNoZWxsVGl0bGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vUmVnaXN0ZXJXZWFrUGFzc3dvcmQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vUmVnaXN0ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vYWNjb3VudF9ib3guc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2FuYWx5dGljcy5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vZG9udXRfbGFyZ2Uuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvQXNzZXRTZWxlY3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vZXhwYW5kX2xlc3Muc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2V4cGFuZF9tb3JlLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL3VpL0Ftb3VudElucHV0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvU2VuZGVyU2VsZWN0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvSW5saW5lQ29udGFjdFNlbGVjdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3VpL1JlY2lwaWVudFNlbGVjdEl0ZW0uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9SZWNpcGllbnRTZWxlY3RTZWxlY3Rpb24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9SZWNpcGllbnRTZWxlY3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vU2VuZE5hdGl2ZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9TZW5kLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvR2FwLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jaGFpbi9jb2luLnRzIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSG9sZGluZ1ZpZXcuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSG9sZGluZ3NIb21lLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRFZGl0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRWaWV3LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0FjY291bnRzSG9tZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRhYnMvc3JjL2lkLmpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS10YWJzL3NyYy9UYWJzLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGFicy9zcmMvVGFiLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtdGFicy9zcmMvVGFiTGlzdC5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLXRhYnMvc3JjL1RhYlBhbmVsLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL3VzZXItYXN0cm9uYXV0LnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9EZWFkRW5kLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL0NvbnRhY3RWaWV3LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL2ltYWdlLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL3VpL0ljb25FZGl0b3Iuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vQ29udGFjdEVkaXQuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vbW9yZS12ZXJ0LnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvaWNvbi91cGxvYWQuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvdWkvQ29udGFjdExpc3Quc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vQ29udGFjdHNIb21lLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL1NpdGVzSG9tZS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9OZXR3b3JrVmlldy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9OZXR3b3Jrc0hvbWUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9zY3JlZW4vSGlzdG9yeUhvbWUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9kZWYudHMiLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vT3ZlcnNjcm9sbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vUG9wdXAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2ljb24vZXhwYW5kLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvaWNvbi90b2tlbnMuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL2hpc3Rvcnkuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL21lbnUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL3N5c3RlbS9OYXYuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Z1c2UuanMvZGlzdC9mdXNlLmVzbS5qcyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL3N5c3RlbS9TZWFyY2guc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9jb250YWluZXIvc3lzdGVtL1Byb2dyZXNzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9pY29uL21lZGlhdGlvbi5zdmc/cmF3IiwiLi4vLi4vLi4vc3JjL2ljb24vYWNjb3VudF9jaXJjbGUuc3ZnP3JhdyIsIi4uLy4uLy4uL3NyYy9pY29uL3NlbnNvcl9kb29yLnN2Zz9yYXciLCIuLi8uLi8uLi9zcmMvYXBwL2NvbnRhaW5lci9zeXN0ZW0vU2lkZU1lbnUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9jb250YWluZXIvc3lzdGVtL1ZlbmRvck1lbnUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2FwcC9uYXYvcGFnZS50cyIsIi4uLy4uLy4uL3NyYy9hcHAvbmF2L3RocmVhZC50cyIsIi4uLy4uLy4uL3NyYy9hcHAvbmF2L25hdmlnYXRvci50cyIsIi4uLy4uLy4uL3NyYy9hcHAvY29udGFpbmVyL1N5c3RlbS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvYXBwL3NjcmVlbi9BdXRoZW50aWNhdGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2VudHJ5L2ZhbGxiYWNrLnRzIiwiLi4vLi4vLi4vc3JjL2FwcC91aS9Ib3Jpem9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9hcHAvc2NyZWVuL1ByZVJlZ2lzdGVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwID0gZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgY29uc3QgcmVsTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKS5yZWxMaXN0O1xuICAgIGlmIChyZWxMaXN0ICYmIHJlbExpc3Quc3VwcG9ydHMgJiYgcmVsTGlzdC5zdXBwb3J0cygnbW9kdWxlcHJlbG9hZCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsaW5rIG9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbcmVsPVwibW9kdWxlcHJlbG9hZFwiXScpKSB7XG4gICAgICAgIHByb2Nlc3NQcmVsb2FkKGxpbmspO1xuICAgIH1cbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgICAgICBpZiAobXV0YXRpb24udHlwZSAhPT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBtdXRhdGlvbi5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ0xJTksnICYmIG5vZGUucmVsID09PSAnbW9kdWxlcHJlbG9hZCcpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NQcmVsb2FkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkub2JzZXJ2ZShkb2N1bWVudCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgZnVuY3Rpb24gZ2V0RmV0Y2hPcHRzKHNjcmlwdCkge1xuICAgICAgICBjb25zdCBmZXRjaE9wdHMgPSB7fTtcbiAgICAgICAgaWYgKHNjcmlwdC5pbnRlZ3JpdHkpXG4gICAgICAgICAgICBmZXRjaE9wdHMuaW50ZWdyaXR5ID0gc2NyaXB0LmludGVncml0eTtcbiAgICAgICAgaWYgKHNjcmlwdC5yZWZlcnJlcnBvbGljeSlcbiAgICAgICAgICAgIGZldGNoT3B0cy5yZWZlcnJlclBvbGljeSA9IHNjcmlwdC5yZWZlcnJlcnBvbGljeTtcbiAgICAgICAgaWYgKHNjcmlwdC5jcm9zc29yaWdpbiA9PT0gJ3VzZS1jcmVkZW50aWFscycpXG4gICAgICAgICAgICBmZXRjaE9wdHMuY3JlZGVudGlhbHMgPSAnaW5jbHVkZSc7XG4gICAgICAgIGVsc2UgaWYgKHNjcmlwdC5jcm9zc29yaWdpbiA9PT0gJ2Fub255bW91cycpXG4gICAgICAgICAgICBmZXRjaE9wdHMuY3JlZGVudGlhbHMgPSAnb21pdCc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZldGNoT3B0cy5jcmVkZW50aWFscyA9ICdzYW1lLW9yaWdpbic7XG4gICAgICAgIHJldHVybiBmZXRjaE9wdHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2Nlc3NQcmVsb2FkKGxpbmspIHtcbiAgICAgICAgaWYgKGxpbmsuZXApXG4gICAgICAgICAgICAvLyBlcCBtYXJrZXIgPSBwcm9jZXNzZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGluay5lcCA9IHRydWU7XG4gICAgICAgIC8vIHByZXBvcHVsYXRlIHRoZSBsb2FkIHJlY29yZFxuICAgICAgICBjb25zdCBmZXRjaE9wdHMgPSBnZXRGZXRjaE9wdHMobGluayk7XG4gICAgICAgIGZldGNoKGxpbmsuaHJlZiwgZmV0Y2hPcHRzKTtcbiAgICB9XG59O19fVklURV9JU19NT0RFUk5fXyYmcCgpOyIsIjxzcGFuIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPjwvc3Bhbj5cbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiIGxhbmc9XCJ0c1wiPlxuXHRsZXQgY19zY3JlZW5zID0gMDtcbjwvc2NyaXB0PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBhcnJpdmFsLCB5d19ibHVyLCB5d19oZWxwLCB5d19uYXZfY29sbGFwc2VkLCB5d19uYXZfdmlzaWJsZSwgeXdfb3ZlcnNjcm9sbF9wY3QsIHl3X3Byb2dyZXNzIH0gZnJvbSAnIy9hcHAvbWVtJztcblxuXHRpbXBvcnQgdHlwZSB7IFBhZ2UgfSBmcm9tICcuLi9zY3JlZW4vX3NjcmVlbnMnO1xuXG5cdGltcG9ydCB7IHRpbWVvdXQgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cdGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgZ2V0Q29udGV4dCwgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBuYXYgPSBmYWxzZTtcblx0Y29uc3QgYl9uYXYgPSBuYXY7XG5cblx0ZXhwb3J0IGxldCBkZWJ1ZyA9ICcnO1xuXHRleHBvcnQgbGV0IHByb2dyZXNzOiBudWxsIHwgW251bWJlciwgbnVtYmVyXSA9IG51bGw7XG5cdGV4cG9ydCBsZXQgZnVsbCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGtleWVkID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgY2xhc3NOYW1lcyA9ICcnO1xuXG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGV4cG9ydCBsZXQgbGVhdmVzID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgc3dpcGVzID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgcm9vdCA9IDAgPT09IGtfcGFnZS5pbmRleDtcblx0ZXhwb3J0IGxldCBzbGlkZXMgPSAhbGVhdmVzICYmICFzd2lwZXMgJiYgIXJvb3Q7XG5cdGNvbnN0IGJfc2xpZGVzID0gc2xpZGVzO1xuXG5cdGV4cG9ydCBsZXQgZm9ybSA9IGZhbHNlO1xuXHRjb25zdCBiX2Zvcm0gPSAhIWZvcm07XG5cblx0ZXhwb3J0IGxldCB0cmFuc3BhcmVudCA9IGZhbHNlO1xuXG5cdGxldCBkbV9zY3JlZW46IEhUTUxFbGVtZW50O1xuXG5cdC8vIEBtdnBcblx0bGV0IGRtX2hlbHA6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cblx0Y29uc3Qgc2lfZXhpdCA9IGxlYXZlcz8gJ2xlYXZlcyc6IHN3aXBlcz8gJ3N3aXBlcyc6ICcnO1xuXG5cdGNvbnN0IGRpc3BhdGNoRXZlbnQgPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblx0b25Nb3VudCgoKSA9PiB7XG5cdFx0aWYoIWtfcGFnZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKGAke2RlYnVnIHx8ICd1bmtub3duJ30gU2NyZWVuIG1pc3NpbmcgcGFnZSBjb250ZXh0YCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gbGlzdGVuIGZvciBwYWdlIGV2ZW50c1xuXHRcdFx0a19wYWdlLm9uKHtcblx0XHRcdFx0Ly8gb24gcGFnZSBmb2N1c1xuXHRcdFx0XHRmb2N1cygpIHtcblx0XHRcdFx0XHQvLyBzZXQgbmF2IHZpc2liaWxpdHlcblx0XHRcdFx0XHQkeXdfbmF2X3Zpc2libGUgPSBiX25hdjtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIC8vIHNjcm9sbGluZ1xuXHRcdC8vIGRtX3NjcmVlbi5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIChkZV93aGVlbCkgPT4ge1xuXHRcdC8vIFx0Ly8gb3ZlcnNjcm9sbFxuXHRcdC8vIFx0aWYoMCA9PT0gZG1fc2NyZWVuLnNjcm9sbFRvcCkge1xuXHRcdC8vIFx0XHRpZihkZV93aGVlbC5ET01fREVMVEFfUElYRUwgPT09IGRlX3doZWVsLmRlbHRhTW9kZSkge1xuXHRcdC8vIFx0XHRcdC8vIGNvbnN0IHhfZGVsdGFfeSA9IGRlX3doZWVsLmRlbHRhWTtcblx0XHQvLyBcdFx0XHQvLyBjb25zdCB4X3BjdCA9IE1hdGgubWluKE1hdGguYWJzKHhfZGVsdGFfeSksIDUwKSAvIDUwO1xuXHRcdC8vIFx0XHRcdC8vICR5d19vdmVyc2Nyb2xsX3BjdCA9IHhfcGN0O1xuXHRcdC8vIFx0XHRcdC8vIGNvbnNvbGUubG9nKCh4X3BjdCAqIDEwMCkudG9GaXhlZCgyKSk7XG5cblx0XHQvLyBcdFx0XHQvLyBjb25zb2xlLmxvZyh7XG5cdFx0Ly8gXHRcdFx0Ly8gXHRkZWx0YVk6IGRlX3doZWVsLmRlbHRhWSxcblx0XHQvLyBcdFx0XHQvLyBcdC8vIHdoZWVsRGVsdGFZOiBkZV93aGVlbC53aGVlbERlbHRhWSxcblx0XHQvLyBcdFx0XHQvLyBcdHNjcmVlblk6IGRlX3doZWVsLnNjcmVlblksXG5cdFx0Ly8gXHRcdFx0Ly8gXHRtb2RlOiBkZV93aGVlbC5kZWx0YU1vZGUsXG5cdFx0Ly8gXHRcdFx0Ly8gfSk7XG5cdFx0Ly8gXHRcdH1cblx0XHQvLyBcdH1cblx0XHQvLyB9KTtcblxuXHRcdC8vIGFycml2YWwoZG1fc2NyZWVuLCAoKSA9PiB7XG5cdFx0Ly8gXHRjb25zb2xlLmxvZygnYXJyaXZlZCB0byBzY3JlZW4nKTtcblx0XHQvLyBcdCR5d19uYXZfdmlzaWJsZSA9IG5hdjtcblx0XHQvLyBcdC8vICR5d19uYXZfY29sbGFwc2VkID0gIW5hdjtcblxuXHRcdC8vIFx0Ly8gaWYobmF2KSB7XG5cdFx0Ly8gXHQvLyBcdCR5d19uYXZfdmlzaWJsZSA9IHRydWU7XG5cdFx0Ly8gXHQvLyB9XG5cblx0XHQvLyBcdGlmKHByb2dyZXNzKSB7XG5cdFx0Ly8gXHRcdCR5d19wcm9ncmVzcyA9IHByb2dyZXNzO1xuXHRcdC8vIFx0fVxuXG5cdFx0Ly8gXHQkeXdfaGVscCA9IGRtX2hlbHBcblx0XHQvLyBcdFx0PyBBcnJheS5mcm9tKGRtX2hlbHAuY2xvbmVOb2RlKHRydWUpLmNoaWxkTm9kZXMpIGFzIEhUTUxFbGVtZW50W11cblx0XHQvLyBcdFx0OiBbXTtcblxuXHRcdC8vIFx0ZGlzcGF0Y2hFdmVudCgnYXJyaXZlJyk7XG5cdFx0Ly8gfSk7XG5cblx0XHQvLyBpZiBzY3JlZW4gaGFzIGtleWVkIHN2ZWx0ZSBjb21wb25lbnRzXG5cdFx0aWYoa2V5ZWQpIHtcblx0XHRcdGxldCB4X3Njcm9sbF90b3AgPSAwO1xuXG5cdFx0XHQvLyBzdmVsdGUgd2lsbCByZXBsYWNlIHRob3NlIGVsZW1lbnRzIHdoZW4gY2hhbmdpbmcgc2NyZWVuc1xuXHRcdFx0KG5ldyBNdXRhdGlvbk9ic2VydmVyKGFzeW5jKGFfbXV0YXRpb25zKSA9PiB7XG5cdFx0XHRcdC8vIGtleWVkIGNvbXBvbmVudCB3YXMgcmVtb3ZlZFxuXHRcdFx0XHRpZihhX211dGF0aW9uc1swXT8uYWRkZWROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0eF9zY3JvbGxfdG9wID0gZG1fc2NyZWVuLnNjcm9sbFRvcDtcblx0XHRcdFx0XHR9IGNhdGNoKGVfbnVsbCkge31cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBrZXllZCBjb21wb25lbnQgd2FzIHJlc3RvcmVkXG5cdFx0XHRcdGVsc2UgaWYoYV9tdXRhdGlvbnNbMF0/LnJlbW92ZWROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRpZihkbV9zY3JlZW4pIHtcblx0XHRcdFx0XHRcdGRtX3NjcmVlbi5zY3JvbGxUb3AgPSB4X3Njcm9sbF90b3A7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KSkub2JzZXJ2ZShkbV9zY3JlZW4sIHtcblx0XHRcdFx0Y2hpbGRMaXN0OiB0cnVlLFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblxuXHRleHBvcnQgbGV0IHN0eWxlID0gJyc7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0ZGl2LmJvdW5kcyB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRwYWRkaW5nLWxlZnQ6IGNhbGMoNTB2dyAtICh2YXIoLS1hcHAtbWF4LXdpZHRoKSAvIDIpKTtcblx0fVxuXG5cdC5zbGlkZXMge1xuXHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlWChjYWxjKHZhcigtLWFwcC13aW5kb3ctd2lkdGgpIC8gMikpO1xuXHRcdHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjZzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0fVxuXG5cdEBtZWRpYShwcmVmZXJzLXJlZHVjZWQtbW90aW9uKSB7XG5cdFx0LnNsaWRlcyB7XG5cdFx0XHR0cmFuc2l0aW9uOiBub25lIDBzIGxpbmVhcjtcblx0XHR9XG5cdH1cblxuXHRzZWN0aW9uLnNjcmVlbixmb3JtLnNjcmVlbiB7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdG1heC13aWR0aDogdmFyKC0tYXBwLW1heC13aWR0aCk7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXG5cdFx0LmZvbnQocmVndWxhcik7XG5cblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cblx0XHRvcGFjaXR5OiAxO1xuXHRcdGZpbHRlcjogYmx1cigwKTtcblxuXHRcdC8vIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjZzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblxuXHRcdCYudHJhbnNwYXJlbnQge1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cdFx0fVxuXG5cdFx0Ji5wcm9ncmVzcyB7XG5cdFx0XHRwYWRkaW5nLXRvcDogMjJweDtcblx0XHR9XG5cblx0XHQmLm5hdiB7XG5cdFx0XHRwYWRkaW5nLWJvdHRvbTogNzFweDtcblx0XHR9XG5cblx0XHQmLmZsZXgge1xuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRhbGlnbi1pdGVtczogc3RyZXRjaDtcblx0XHRcdGdhcDogdmFyKC0tZ2FwLCB2YXIoLS11aS1wYWRkaW5nKSk7XG5cblx0XHRcdD46Zmlyc3QtY2hpbGQ6bm90KC5uby1tYXJnaW4pIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0bWFyZ2luLXRvcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Jj4qIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0ZmxleDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdDpnbG9iYWwoJjpub3QoLm5vLW1hcmdpbikpIHtcblx0XHRcdFx0XHRtYXJnaW46IDAgdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXHRcdCYuc2Nyb2xsIHtcblx0XHRcdG92ZXJmbG93LXk6IHNjcm9sbDtcblx0XHRcdG92ZXJzY3JvbGwtYmVoYXZpb3IteTogY29udGFpbjtcblx0XHRcdC5oaWRlLXNjcm9sbGJhcigpO1xuXHRcdH1cblxuXHRcdC8vICYuc2xpZGVzIHtcblx0XHQvLyBcdHRyYW5zZm9ybTogdHJhbnNsYXRlWChjYWxjKHZhcigtLWFwcC13aW5kb3ctd2lkdGgpIC8gMikpO1xuXHRcdC8vIFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuNnMgdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHRcdC8vIH1cblxuXHRcdCYuc2xpZCB7XG5cdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC41cyB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cdFx0fVxuXG5cdFx0JltkYXRhLXMyLWV4aXRdOm5vdChbZGF0YS1zMi1leGl0PScnXSkge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC8vIGxlZnQ6IDA7XG5cdFx0XHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwcHgpO1xuXHRcdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC41cyB2YXIoLS1lYXNlLW91dC1xdWludCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0QGtleWZyYW1lcyBmYWRlLWF3YXkge1xuXHRcdFx0MCUge1xuXHRcdFx0XHRvcGFjaXR5OiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQ3NSUge1xuXHRcdFx0XHRvcGFjaXR5OiAwO1xuXHRcdFx0fVxuXG5cdFx0XHQxMDAlIHtcblx0XHRcdFx0b3BhY2l0eTogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRAa2V5ZnJhbWVzIGJsdXItYXdheSB7XG5cdFx0XHQwJSB7XG5cdFx0XHRcdGZpbHRlcjogYmx1cigwKTtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdGZpbHRlcjogYmx1cigxNHB4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRAa2V5ZnJhbWVzIHNjYWxlLXVwIHtcblx0XHRcdDAlIHtcblx0XHRcdFx0dHJhbnNmb3JtOiBzY2FsZSgxKTtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogc2NhbGUoMS43NSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQGtleWZyYW1lcyBzdWJsaW1hdGUge1xuXHRcdC8vIFx0MCUge1xuXHRcdC8vIFx0XHRvcGFjaXR5OiAxO1xuXHRcdC8vIFx0XHR0cmFuc2Zvcm06IHNjYWxlKDEpO1xuXHRcdC8vIFx0XHRmaWx0ZXI6IGJsdXIoMCk7XG5cdFx0Ly8gXHR9XG5cblx0XHQvLyBcdDI1JSB7XG5cdFx0Ly8gXHRcdGZpbHRlcjogYmx1cigxNHB4KTtcblx0XHQvLyBcdH1cblxuXHRcdC8vIFx0ODAlIHtcblx0XHQvLyBcdFx0b3BhY2l0eTogMDtcblx0XHQvLyBcdH1cblxuXHRcdC8vIFx0MTAwJSB7XG5cdFx0Ly8gXHRcdHRyYW5zZm9ybTogc2NhbGUoMS43NSlcblx0XHQvLyBcdH1cblx0XHQvLyB9XG5cblx0XHRAa2V5ZnJhbWVzIHR1cm4tYXdheSB7XG5cdFx0XHQwJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMHB4KSByb3RhdGVZKDBkZWcpO1xuXHRcdFx0fVxuXG5cdFx0XHQxJSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcGVyc3BlY3RpdmUoMTUwMHB4KSByb3RhdGVZKDBkZWcpO1xuXHRcdFx0fVxuXG5cdFx0XHQxMDAlIHtcblx0XHRcdFx0dHJhbnNmb3JtOiBwZXJzcGVjdGl2ZSgxNTAwcHgpIHJvdGF0ZVkoLTgwZGVnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRAa2V5ZnJhbWVzIGZhZGUtb3V0IHtcblx0XHRcdDAlIHtcblx0XHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdH1cblxuXHRcdFx0MTAlIHtcblx0XHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdH1cblxuXHRcdFx0ODAlIHtcblx0XHRcdFx0b3BhY2l0eTogMDtcblx0XHRcdH1cblxuXHRcdFx0MTAwJSB7XG5cdFx0XHRcdG9wYWNpdHk6IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ji5zdWJsaW1hdGUge1xuXHRcdFx0Ly8gYW5pbWF0aW9uOiBcblx0XHRcdC8vIFx0c2NhbGUtdXAgMTAwMG1zIHZhcigtLWVhc2Utb3V0LWN1YmljKSBmb3J3YXJkcyxcblx0XHRcdC8vIFx0ZmFkZS1hd2F5IDEwMDBtcyB2YXIoLS1lYXNlLW91dC1xdWFkKSBmb3J3YXJkcyxcblx0XHRcdC8vIFx0Ymx1ci1hd2F5IDIwMG1zIHZhcigtLWVhc2Utb3V0LXF1YWQpIGZvcndhcmRzO1xuXG5cdFx0XHQvLyAtLW1pbWljOiAxMDAwbXMgdmFyKC0tZWFzZS1vdXQtcXVpbnQpIGZvcndhcmRzO1xuXHRcdFx0Ly8gYW5pbWF0aW9uOiB0dXJuLWF3YXkgdmFyKC0tbWltaWMpLFxuXHRcdFx0Ly8gXHRmYWRlLW91dCB2YXIoLS1taW1pYyk7XG5cdFx0XHQvLyB0cmFuc2Zvcm0tb3JpZ2luOiAxMjAlO1xuXG5cdFx0XHR0cmFuc2l0aW9uOiBvcGFjaXR5IDQwMG1zIHZhcigtLWVhc2Utb3V0LXF1YWQpO1xuXHRcdFx0b3BhY2l0eTogMDtcblx0XHR9XG5cblx0XHQmLm1hdGVyaWFsaXplIHtcblxuXHRcdH1cblxuXHRcdD4qOm5vdCguaGVhZGVyKSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0dHJhbnNpdGlvbjogZmlsdGVyIDQwMG1zIHZhcigtLWVhc2Utb3V0LWN1YmljKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQmLmJsdXIge1xuXHRcdFx0Pio6bm90KC5oZWFkZXIpIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0ZmlsdGVyOiBibHVyKDJweCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblxuXG5cdFx0Lypcblx0XHRcdENvcGllZCBmcm9tIHNjcmVlbi5sZXNzXG5cdFx0Ki9cblx0XHQqIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRmb250LWZhbWlseTogaW5oZXJpdDtcblx0XHRcdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnRleHQ6bm90KGJ1dHRvbiAudGV4dCk6bm90KC5yb3cgLnRleHQpIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR1c2VyLXNlbGVjdDogdGV4dDtcblx0XHRcdFx0Y3Vyc29yOiBkZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlucHV0LHRleHRhcmVhIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR1c2VyLXNlbGVjdDogaW5pdGlhbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQudmFsaWRhdGlvbi1tZXNzYWdlIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pO1xuXHRcdFx0XHR0ZXh0LWFsaWduOiByaWdodDtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cblx0XHRcdFx0cGFkZGluZy10b3A6IDNweDtcblx0XHRcdFx0bWFyZ2luLWxlZnQ6IC05cHg7XG5cdFx0XHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQudXNlci1zZWxlY3RfYWxsIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHR1c2VyLXNlbGVjdDogYWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5hY3Rpb25zLXdhbGwsIC5hY3Rpb25zLWxpbmUge1xuXHRcdFx0YnV0dG9uIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0bWluLWhlaWdodDogdmFyKC0tdWktcm93LWhlaWdodCk7XG5cdFx0XHRcdFx0bWF4LWhlaWdodDogdmFyKC0tdWktcm93LWhlaWdodCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cblx0XHRcdFx0XHRib3JkZXItcmFkaXVzOiB2YXIoLS11aS1ib3JkZXItcmFkaXVzKTtcblxuXHRcdFx0XHRcdHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMXMgdmFyKC0tZWFzZS1vdXQtZXhwbyksXG5cdFx0XHRcdFx0XHRjb2xvciAycyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQmLnByaW1hcnkge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtZGFyayk7XG5cdFx0XHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmOmRpc2FibGVkLCZbcmVhZG9ubHk9XCJ0cnVlXCJdIHtcblx0XHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0XHRcdFx0XHRjdXJzb3I6IG5vdC1hbGxvd2VkO1xuXHRcdFx0XHRcdFx0XHRvcGFjaXR5OiAwLjQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YnV0dG9uIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdH1cblxuXHRcdFx0Ji5waWxsIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0LmZvbnQocmVndWxhciwgQHNpemU6IDExcHgsIEB3ZWlnaHQ6IDUwMCk7XG5cdFx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0XHRcdHBhZGRpbmc6IDAuNGVtIDFlbTtcblx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0Ym9yZGVyLXJhZGl1czogNDAwZW07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRoMyB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0Zm9udC13ZWlnaHQ6IDUwMDtcblx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5hY3Rpb24td2FsbCB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XG5cdFx0XHRcdGdhcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHR9XG5cblx0XHRcdCY+YnV0dG9uIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0ZmxleDogMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHAge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC5mb250KHJlZ3VsYXIsIEB3ZWlnaHQ6IDMwMCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmZvcm0tZW50cnkoKSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRcdGhlaWdodDogdmFyKC0tdWktcm93LWhlaWdodCk7XG5cdFx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRcdHBhZGRpbmctbGVmdDogdmFyKC0tdWktcGFkZGluZyk7XG5cblx0XHRcdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0tdWktYm9yZGVyLXJhZGl1cyk7XG5cdFx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cblx0XHRcdFx0Zm9udC13ZWlnaHQ6IDMwMDtcblx0XHRcdH1cblxuXHRcdFx0Jjo6cGxhY2Vob2xkZXIge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRmb250LXdlaWdodDogMzAwO1xuXHRcdFx0XHRcdC8vIGNvbG9yOiByZ2IoMTE3LDExNywxMTcpO1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdFx0b3BhY2l0eTogMC43O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCY6Zm9jdXMge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpbnB1dCB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0Zm9udC1zaXplOiBpbmhlcml0O1xuXHRcdFx0fVxuXG5cdFx0XHQmW3R5cGU9XCJ0ZXh0XCJdLCZbdHlwZT1cInBhc3N3b3JkXCJdLCZbdHlwZT1cIm51bWJlclwiXSB7XG5cdFx0XHRcdC5mb3JtLWVudHJ5KCk7XG5cdFx0XHR9XG5cblx0XHRcdCYuaW52YWxpZDpub3QoOmZvY3VzKSB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pICFpbXBvcnRhbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ji5hZGRyZXNzIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0LmZvbnQobW9uby10aW55KTtcblx0XHRcdFx0XHRsZXR0ZXItc3BhY2luZzogMC4yNXB4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LnNlbGVjdENvbnRhaW5lci5pbnZhbGlkIHtcblx0XHRcdGlucHV0IHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItY2F1dGlvbikgIWltcG9ydGFudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRleHRhcmVhIHtcblx0XHRcdC5mb3JtLWVudHJ5KCk7XG5cblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udChyZWd1bGFyKTtcblxuXHRcdFx0XHRwYWRkaW5nOiAxZXggMmV4O1xuXHRcdFx0XHRoZWlnaHQ6IDEwLjc1ZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblx0XHQuZmxleC1yb3dzIHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRhbGlnbi1pdGVtczogc3RyZXRjaDtcblx0XHRcdFx0Z2FwOiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdH1cblxuXHRcdFx0Jj4qIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0ZmxleDogMDtcblx0XHRcdFx0XHRtYXJnaW4tdG9wOiAwO1xuXHRcdFx0XHRcdG1hcmdpbi1ib3R0b206IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQuZm9udC12YXJpYW50X21vbm8ge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC5mb250KG1vbm8pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5mb250LXZhcmlhbnRfbW9uby10aW55IHtcblx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHQuZm9udChtb25vLXRpbnkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5jb2xvci1pY29uLXNlbmQge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci1vcmFuZ2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5jb2xvci1pY29uLXJlY3Yge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci1zbGltZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Lmxpbmsge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0fVxuXG5cdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQuc3ZlbHRlLXRhYnMge1xuXHRcdFx0PnVsLnN2ZWx0ZS10YWJzX190YWItbGlzdCB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xuXG5cdFx0XHRcdFx0bWFyZ2luLWxlZnQ6IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHRcdFx0XHRcdG1hcmdpbi1yaWdodDogY2FsYygwcHggLSB2YXIoLS11aS1wYWRkaW5nKSk7XG5cdFx0XHRcdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+bGkuc3ZlbHRlLXRhYnNfX3RhYiB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRmbGV4OiAxO1xuXHRcdFx0XHRcdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXG5cdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItZ3JheW1lZCk7XG5cdFx0XHRcdFx0XHRib3JkZXItYm90dG9tOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiAxMnB4IDAuNzVlbTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmLnN2ZWx0ZS10YWJzX19zZWxlY3RlZCB7XG5cdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdFx0XHRib3JkZXItYm90dG9tOiAycHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdD5kaXYuc3ZlbHRlLXRhYnNfX3RhYi1wYW5lbCB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdG1hcmdpbi10b3A6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbjwvc3R5bGU+XG48IS0tIGNsYXNzOnNsaWRlcz17c2xpZGVzfSAtLT5cblxuPGRpdiBjbGFzcz1cImJvdW5kc1wiXG5cdGNsYXNzOnNsaWRlcz17Yl9zbGlkZXN9XG4+XG5cdDxmb3JtXG5cdFx0Y2xhc3M9XCJzY3JlZW4ge2NsYXNzTmFtZXN9XCJcblx0XHRjbGFzczpmbGV4PXt0cnVlfVxuXHRcdGNsYXNzOnNjcm9sbD17dHJ1ZX1cblx0XHRjbGFzczpuYXY9e2JfbmF2fVxuXHRcdGNsYXNzOnByb2dyZXNzPXtwcm9ncmVzc31cblx0XHRjbGFzczp0cmFuc3BhcmVudD17dHJhbnNwYXJlbnR9XG5cdFx0Y2xhc3M6c3VibGltYXRlPXtmYWxzZX1cblx0XHRjbGFzczpibHVyPXskeXdfYmx1cn1cblx0XHRkYXRhLXMyLWV4aXQ9e3NpX2V4aXR9XG5cdFx0YmluZDp0aGlzPXtkbV9zY3JlZW59XG5cdFx0b246c3VibWl0PXtkX2V2ZW50ID0+IHZvaWQgZF9ldmVudC5wcmV2ZW50RGVmYXVsdCgpfVxuXHRcdG9uOnN1Ym1pdFxuXHRcdHN0eWxlPVwie3N0eWxlfVwiXG5cdFx0YXV0b2NvbXBsZXRlPVwib2ZmXCJcblx0PlxuXHRcdDxzbG90Pjwvc2xvdD5cblxuXHRcdHsjaWYgJ2hlbHAnIGluICQkc2xvdHN9XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiZGlzcGxheV9ub25lXCIgYmluZDp0aGlzPXtkbV9oZWxwfT5cblx0XHRcdFx0PHNsb3QgbmFtZT1cImhlbHBcIiAvPlxuXHRcdFx0PC9kaXY+XG5cdFx0ey9pZn1cblx0PC9mb3JtPlxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBGX05PT1AgfSBmcm9tIFwiIy91dGlsL2JlbHRcIjtcblxuXHQvKipcblx0ICogdGFyZ2V0IGRpbWVuc2lub3Ncblx0ICovXG5cdGV4cG9ydCBsZXQgZGltOiAzMiB8IDQ4IHwgNjQgfCA5NiB8IDEyODtcblx0Y29uc3QgeF9kaW0gPSBkaW07XG5cblx0LyoqXG5cdCAqIGFsdGVybmF0aXZlIHRleHRcblx0ICovXG5cdGV4cG9ydCBsZXQgYWx0ID0gJ1N0YXJTaGVsbCBsb2dvJztcblx0Y29uc3Qgc19hbHQgPSBhbHQ7XG5cblx0Y29uc3QgZl9zcmMgPSAoeDogbnVtYmVyKSA9PiBgL21lZGlhL3ZlbmRvci9sb2dvLSR7eH1weC5wbmdgO1xuXG5cdGNvbnN0IHNyX2RlZmF1bHQgPSBmX3NyYyh4X2RpbSk7XG5cdGNvbnN0IHNyX2RvdWJsZSA9IGZfc3JjKHhfZGltICogMik7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5sb2dvIHtcblx0XHRkaXNwbGF5OiBibG9jaztcblx0XHRtYXJnaW46IDA7XG5cdFx0cGFkZGluZzogMDtcblx0XHRib3JkZXI6IDA7XG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XG5cblx0XHRtYXJnaW4tbGVmdDogYXV0bztcblx0XHRtYXJnaW4tcmlnaHQ6IGF1dG87XG5cblx0XHRpbWcge1xuXHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48cGljdHVyZSBjbGFzcz1cIm5vLW1hcmdpbiBsb2dvXCIgc3R5bGU9XCJ3aWR0aDp7eF9kaW19cHg7IGhlaWdodDp7eF9kaW19cHg7XCIgb246Y2xpY2s+XG5cdDxzb3VyY2Ugc3Jjc2V0PVwie3NyX2RvdWJsZX1cIiBtZWRpYT1cIihtaW4tcmVzb2x1dGlvbjogMmRwcHgpXCI+XG5cdDxpbWcgYWx0PXtzX2FsdH0gc3JjPVwie3NyX2RlZmF1bHR9XCIgLz5cbjwvcGljdHVyZT5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7eXdfYmx1cn0gZnJvbSAnIyMvbWVtJztcblx0aW1wb3J0IFNYX0lDT05fQUREX1NNQUxMIGZyb20gJyMvaWNvbi9hZGQtc21hbGwuc3ZnP3Jhdyc7XG5cdFxuXHRleHBvcnQgbGV0IHRpdGxlOiBzdHJpbmc7XG5cdGV4cG9ydCBsZXQgb3BlbiA9IHRydWU7XG5cblx0JDogJHl3X2JsdXIgPSBvcGVuO1xuXG5cdGxldCBiX3Nob3dpbmcgPSBmYWxzZTtcblx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0Yl9zaG93aW5nID0gdHJ1ZTtcblx0fSwgMTApO1xuXG5cdGZ1bmN0aW9uIHBhdXNlKGRtOiBIVE1MRWxlbWVudCwgZ2M6IGFueSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkdXJhdGlvbjogMjAwLFxuXHRcdH07XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQuY2FuY2VsIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdHotaW5kZXg6IDUwMDA7XG5cblx0XHQmLnNob3dpbmcge1xuXHRcdFx0Pi5vdmVybGF5IHtcblx0XHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdFx0Ly8gaGVpZ2h0OiBhdXRvO1xuXHRcdFx0XHRoZWlnaHQ6IDMyMHB4O1xuXG5cdFx0XHRcdG1heC1oZWlnaHQ6IDMyMHB4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5vdmVybGF5IHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogNGVtO1xuXHRcdFx0cmlnaHQ6IDIwcHg7XG5cdFx0XHR6LWluZGV4OiAxMDAwO1xuXHRcdFx0d2lkdGg6IDMwMHB4O1xuXHRcdFx0cGFkZGluZy1sZWZ0OiB2YXIoLS11aS1wYWRkaW5nKTtcblx0XHRcdHBhZGRpbmctcmlnaHQ6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFx0cGFkZGluZy1ib3R0b206IHZhcigtLXVpLXBhZGRpbmcpO1xuXG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOTUpO1xuXHRcdFx0Ym9yZGVyLXJhZGl1czogOHB4O1xuXHRcdFx0bWF4LWhlaWdodDogMzIwcHg7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdG92ZXJzY3JvbGwtYmVoYXZpb3I6IGNvbnRhaW47XG5cdFx0XHRvdmVyZmxvdzogc2Nyb2xsO1xuXHRcdFx0LmhpZGUtc2Nyb2xsYmFyKCk7XG5cblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0XHRvcGFjaXR5OiAwLjI1O1xuXHRcdFx0dHJhbnNpdGlvbjogb3BhY2l0eSAyMDBtcyBsaW5lYXIsIGhlaWdodCAyNTBtcyB2YXIoLS1lYXNlLW91dC1leHBvKTtcblx0XHRcdGhlaWdodDogMDtcblxuXHRcdFx0Pi50b3Age1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cblx0XHRcdFx0PmgzIHtcblx0XHRcdFx0XHRtYXJnaW46IDE2cHggMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4uYWRkLW5ldyB7XG5cdFx0XHRcdFx0Pi5pY29uIHtcblx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogOHB4O1xuXHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Pi5yb3dzIHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0LS1yb3ctcGFkZGluZzogMTJweDtcblxuXG5cdFx0XHRcdC5vdmVybGF5LXNlbGVjdC5pY29uIHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjBweDtcblx0XHRcdFx0XHRcdGFsaWduLXNlbGY6IGNlbnRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LnJvdyB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLXRvcDogdmFyKC0tcm93LXBhZGRpbmcpICFpbXBvcnRhbnQ7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLWxlZnQ6IDAgIWltcG9ydGFudDtcblx0XHRcdFx0XHRcdHBhZGRpbmctcmlnaHQ6IHZhcigtLXJvdy1wYWRkaW5nKSAhaW1wb3J0YW50O1xuXHRcdFx0XHRcdFx0cGFkZGluZy1ib3R0b206IHZhcigtLXJvdy1wYWRkaW5nKSAhaW1wb3J0YW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz1cImNhbmNlbFwiXG5cdGNsYXNzOnNob3dpbmc9e2Jfc2hvd2luZ31cblx0b246Y2xpY2s9eygpID0+IHtcblx0XHRiX3Nob3dpbmcgPSBmYWxzZTtcblx0XHRvcGVuID0gZmFsc2U7XG5cdH19XG4+XG5cdDxkaXYgY2xhc3M9XCJvdmVybGF5IHNlbGVjdFwiIG91dDpwYXVzZT5cblx0XHQ8ZGl2IGNsYXNzPVwidG9wXCI+XG5cdFx0XHQ8aDM+XG5cdFx0XHRcdHt0aXRsZX1cblx0XHRcdDwvaDM+XG48IS0tIFxuXHRcdFx0PGJ1dHRvbiBjbGFzcz1cInBpbGwgYWRkLW5ld1wiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9BRERfU01BTEx9XG5cdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0XHRBZGQgTmV3XG5cdFx0XHRcdDwvc3Bhbj5cblx0XHRcdDwvYnV0dG9uPiAtLT5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJyb3dzXCI+XG5cdFx0XHQ8c2xvdCBuYW1lPVwicm93c1wiPjwvc2xvdD5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLWFycm93LWxlZnQtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0PC9zdHlsZT5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLWFycm93LWxlZnQtZmdcXFwiIGQ9XFxcIk0yMCwxMVYxM0g4TDEzLjUsMTguNUwxMi4wOCwxOS45Mkw0LjE2LDEyTDEyLjA4LDQuMDhMMTMuNSw1LjVMOCwxMUgyMFpcXFwiLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItc2VhcmNoLWZnIHtcXG5cXHRcXHRcXHRmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsIGN1cnJlbnRDb2xvcik7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PHBhdGggY2xhc3M9XFxcInMyci1zZWFyY2gtZmdcXFwiIGQ9XFxcIk0xNS41IDE0aC0uNzlsLS4yOC0uMjdBNi40NzEgNi40NzEgMCAwIDAgMTYgOS41IDYuNSA2LjUgMCAxIDAgOS41IDE2YzEuNjEgMCAzLjA5LS41OSA0LjIzLTEuNTdsLjI3LjI4di43OWw1IDQuOTlMMjAuNDkgMTlsLTQuOTktNXptLTYgMEM3LjAxIDE0IDUgMTEuOTkgNSA5LjVTNy4wMSA1IDkuNSA1IDE0IDcuMDEgMTQgOS41IDExLjk5IDE0IDkuNSAxNHpcXFwiLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItY2hlY2tlZC1jaXJjbGUtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0XFx0LnMyci1jaGVja2VkLWNpcmNsZS1iZyB7XFxuXFx0XFx0XFx0ZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWJnLCBibGFjayk7XFxuXFx0XFx0fVxcblxcdDwvc3R5bGU+XFxuXFx0PGNpcmNsZSBjbGFzcz1cXFwiczJyLWNoZWNrZWQtY2lyY2xlLWJnXFxcIiBjeD1cXFwiMTBcXFwiIGN5PVxcXCIxMFxcXCIgcj1cXFwiOFxcXCIgLz5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLWNoZWNrZWQtY2lyY2xlLWZnXFxcIiBkPVxcXCJNMTAuMDAwMyAxLjY2NjVDNS40MDAzMyAxLjY2NjUgMS42NjY5OSA1LjM5OTg0IDEuNjY2OTkgOS45OTk4NEMxLjY2Njk5IDE0LjU5OTggNS40MDAzMyAxOC4zMzMyIDEwLjAwMDMgMTguMzMzMkMxNC42MDAzIDE4LjMzMzIgMTguMzMzNyAxNC41OTk4IDE4LjMzMzcgOS45OTk4NEMxOC4zMzM3IDUuMzk5ODQgMTQuNjAwMyAxLjY2NjUgMTAuMDAwMyAxLjY2NjVaTTguMzMzNjYgMTQuMTY2NUw0LjE2Njk5IDkuOTk5ODRMNS4zNDE5OSA4LjgyNDg0TDguMzMzNjYgMTEuODA4MkwxNC42NTg3IDUuNDgzMTdMMTUuODMzNyA2LjY2NjVMOC4zMzM2NiAxNC4xNjY1WlxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IFN0YXJTaGVsbExvZ28gZnJvbSAnLi9TdGFyU2hlbGxMb2dvLnN2ZWx0ZSc7XG5cdGltcG9ydCBPdmVybGF5U2VsZWN0IGZyb20gJy4vT3ZlcmxheVNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgUGZwRGlzcGxheSBmcm9tICcuL1BmcERpc3BsYXkuc3ZlbHRlJztcblx0aW1wb3J0IENsb3NlIGZyb20gJy4vQ2xvc2Uuc3ZlbHRlJztcblx0aW1wb3J0IFJvdyBmcm9tICcuL1Jvdy5zdmVsdGUnO1xuXG5cdGltcG9ydCBTWF9JQ09OX0FSUk9XX0xFRlQgZnJvbSAnIy9pY29uL2Fycm93LWxlZnQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX1NFQVJDSCBmcm9tICcjL2ljb24vc2VhcmNoLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfQ0hFQ0tFRCBmcm9tICcjL2ljb24vY2hlY2tlZC1jaXJjbGUuc3ZnP3Jhdyc7XG5cdFxuXHRpbXBvcnQge1xuXHRcdHl3X2FjY291bnQsXG5cdFx0eXdfYWNjb3VudF9yZWYsXG5cdFx0eXdfY2FuY2VsX3NlYXJjaCxcblx0XHR5d19jaGFpbixcblx0XHR5d19jaGFpbl9yZWYsXG5cdFx0eXdfbWVudV92ZW5kb3IsXG5cdFx0eXdfb3ZlcmxheV9hY2NvdW50LFxuXHRcdHl3X292ZXJsYXlfbmV0d29yayxcblx0XHR5d19zZWFyY2gsXG5cdFx0eXdfdGhyZWFkLFxuXHR9IGZyb20gJy4uL21lbSc7XG5cblx0aW1wb3J0IHR5cGUge1xuXHRcdFBhZ2UsXG5cdH0gZnJvbSAnIyMvc2NyZWVuL19zY3JlZW5zJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQgeyBxcyB9IGZyb20gJyMvdXRpbC9kb20nO1xuXHRcblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgaW5jbHVkZXMgYSBiYWNrIGJ1dHRvbiB0byBwb3AgdGhpcyBwYWdlIGZyb20gdGhlIHN0YWNrXG5cdCAqL1xuXHRleHBvcnQgbGV0IHBvcHMgPSBmYWxzZTtcblx0Y29uc3QgYl9wb3BzID0gcG9wcztcblxuXHQvKipcblx0ICogSWYgYHRydWVgLCBpbmNsdWRlcyBhbiBleGl0IGJ1dHRvbiB0byByZXNldCB0aGUgc3RhY2tcblx0ICovXG5cdGV4cG9ydCBsZXQgZXhpdHMgPSBmYWxzZTtcblx0Y29uc3QgYl9leGl0cyA9IGV4aXRzO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIGRvZXMgbm90IGRpc3BsYXkgdGhlIGxvZ28gaW4gY2FzZXMgd2hlcmUgdGhlIGxvZ28gd291bGQgZGlzcGxheVxuXHQgKi9cblx0ZXhwb3J0IGxldCBwbGFpbiA9IGZhbHNlO1xuXHRjb25zdCBiX3BsYWluID0gcGxhaW47XG5cblx0LyoqXG5cdCAqIElmIGB0cnVlYCwgYWxsb3dzIHRoZSBhY2NvdW50IHRvIGJlIHN3aXRjaGVkXG5cdCAqL1xuXHRleHBvcnQgbGV0IGFjY291bnQgPSBmYWxzZTtcblx0Y29uc3QgYl9hY2NvdW50ID0gYWNjb3VudDtcblxuXHQvKipcblx0ICogSWYgYHRydWVgLCBhbGxvd3MgdGhlIG5ldHdvcmsgdG8gYmUgc3dpdGNoZWRcblx0ICovXG5cdGV4cG9ydCBsZXQgbmV0d29yayA9IGZhbHNlO1xuXHRjb25zdCBiX25ldHdvcmsgPSBuZXR3b3JrO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIGluY2x1ZGVzIGEgc2VhcmNoIGlucHV0IGJveFxuXHQgKi9cblx0ZXhwb3J0IGxldCBzZWFyY2ggPSBmYWxzZTtcblx0Y29uc3QgYl9zZWFyY2ggPSBzZWFyY2g7XG5cblx0LyoqXG5cdCAqIFRoZSBwcmltYXJ5IHRpdGxlIHRvIGRpc3BsYXlcblx0ICovXG5cdGV4cG9ydCBsZXQgdGl0bGUgPSAnJztcblx0Y29uc3Qgc190aXRsZSA9IHRpdGxlO1xuXG5cdC8qKlxuXHQgKiBBIHNob3J0IHN0cmluZyB0byBkaXNwbGF5IGltbWVkaWF0ZWx5IGZvbGxvd2luZyB0aGUgdGl0bGVcblx0ICovXG5cdGV4cG9ydCBsZXQgc3ltYm9sID0gJyc7XG5cdGNvbnN0IHNfc3ltYm9sID0gc3ltYm9sO1xuXG5cdC8qKlxuXHQgKiBUaGUgc3Vic3RpdGxlIHRvIGRpc3BsYXkgdW5kZXIgdGhlIHByaW1hcnkgdGl0bGVcblx0ICovXG5cdGV4cG9ydCBsZXQgc3VidGl0bGUgPSAnJztcblx0Y29uc3Qgc19zdWJ0aXRsZSA9IHN1YnRpdGxlO1xuXG5cdC8vIGV2ZW50IGRpc3BhdGNoZXIgZm9yIHBhcmVudCBjb21wb25lbnRcblx0Y29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcblxuXHQvLyBkaW1lbnNpb24gb2YgdGhlIGFjY291bnQgYW5kIG5ldHdvcmsgaWNvbnNcblx0Y29uc3Qgb3ZlcmxheV9wZnBfcHJvcHMgPSAoYl9taXJyb3I9ZmFsc2UpID0+ICh7XG5cdFx0ZGltOiAyMSxcblx0XHRiZzogJ3NhdGluJyxcblx0XHRnZW5TdHlsZTogJ2ZvbnQtc2l6ZToyMXB4OyBvdXRsaW5lOm5vbmU7Jyxcblx0XHRyb290U3R5bGU6IGBcblx0XHRcdHBhZGRpbmc6IDVweCA2cHg7XG5cdFx0XHRib3JkZXI6IDJweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdFx0Ym9yZGVyLXJhZGl1czogJHtiX21pcnJvcj8gJzAgNHB4IDRweCAwJzogJzRweCAwIDAgNHB4J307XG5cdFx0YC5yZXBsYWNlKC9cXHMrL2csICcgJyksXG5cdH0pIGFzIGNvbnN0O1xuXG5cdC8vIGdldCBwYWdlIGZyb20gY29udGV4dFxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0Ly8gJDogcF9hY2NvdW50X2ljb24gPSBiX2FjY291bnQ/ICR5d19hY2NvdW50Py5kZWY/Lmljb25SZWY6IG51bGw7XG5cblxuXHRsZXQgZG1faGVhZGVyOiBIVE1MRWxlbWVudDtcblxuXHRsZXQgZG1fc2VhcmNoOiBIVE1MRWxlbWVudDtcblxuXHQvLyBpbXBvcnQgU1hfU0VBUkNIIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL2ZpbGxlZC9zZWFyY2guc3ZnP3Jhdyc7XG5cblx0Ly8gaW1wb3J0IFNYX0xPR08gZnJvbSAnIy9hc3NldC92ZW5kb3IvbG9nby5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0RST1BfRE9XTiBmcm9tICcjL2Fzc2V0L25hdi9kcm9wLWRvd24uc3ZnP3Jhdyc7XG5cblx0Ly8gaW1wb3J0IFNYX0NIRUNLRUQgZnJvbSAnIy9hc3NldC9uYXYvY2hlY2tlZC1jaXJjbGUuc3ZnP3Jhdyc7XG5cblx0Ly8gaW1wb3J0IFB1dCBmcm9tICcuL1B1dC5zdmVsdGUnO1xuXHQvLyBpbXBvcnQgeyBmb3JtYXRfZmlhdCwgSF9BQ0NPVU5UUywgSF9DSEFJTlMsIEhfSE9MRElOR1MsIEhfSUNPTlMsIEhfVE9LRU5TLCBIX1ZFUlNVU19VU0QgfSBmcm9tICcjL3NpbS9kYXRhJztcblx0Ly8gaW1wb3J0IHsgbWljcm90YXNrLCBvZGUsIHRpbWVvdXQgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cdC8vIGltcG9ydCB7IHFzIH0gZnJvbSAnIy91dGlsL2RvbSc7XG5cdC8vIGltcG9ydCBDbG9zZSBmcm9tICcuL0Nsb3NlLnN2ZWx0ZSc7XG5cdC8vIGltcG9ydCBPdmVybGF5U2VsZWN0IGZyb20gJy4vT3ZlcmxheVNlbGVjdC5zdmVsdGUnO1xuXHQvLyBpbXBvcnQgUm93IGZyb20gJy4vUm93LnN2ZWx0ZSc7XG5cblx0Ly8gaW1wb3J0IHtcblx0Ly8gXHRBY2NvdW50LFxuXHQvLyBcdEljb24sXG5cdC8vIFx0SG9sZGluZyxcblx0Ly8gfSBmcm9tICcjL29iamVjdHMnO1xuXHQvLyBpbXBvcnQgUGZwIGZyb20gJy4vUGZwLnN2ZWx0ZSc7XG5cblxuXG5cdGV4cG9ydCBsZXQgaXNTZWFyY2hTY3JlZW4gPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBzZWFyY2hfaW5wdXQgPSAnJztcblxuXHRsZXQgc19zZWFyY2ggPSAkeXdfc2VhcmNoO1xuXG5cblx0Ly8gb25Nb3VudCgoKSA9PiB7XG5cdC8vIFx0aWYoJHl3X3NlYXJjaCkge1xuXHQvLyBcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdC8vIFx0XHRcdGNvbnNvbGUubG9nKCdzdGVhbGluZyBmb2N1cyBmb3IgZW50cnkgc2VhcmNoJyk7XG5cdC8vIFx0XHRcdGRtX3NlYXJjaC5mb2N1cygpO1xuXHQvLyBcdFx0fSwgMCk7XG5cdC8vIFx0fVxuXHQvLyB9KTtcblxuXHR5d19zZWFyY2guc3Vic2NyaWJlKChzX3ZhbHVlKSA9PiB7XG5cdFx0aWYoaXNTZWFyY2hTY3JlZW4gJiYgc192YWx1ZSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ3NlYXJjaCBzY3JlZW4gYW5kIHNlYXJjaCB0ZXh0Jyk7XG5cdFx0XHRzX3NlYXJjaCA9IHNfdmFsdWU7XG5cdFx0XHRpZihkbV9zZWFyY2gpIHtcblx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0ZG1fc2VhcmNoLmZvY3VzKCk7XG5cdFx0XHRcdH0sIDApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmKCFzX3ZhbHVlKSB7XG5cdFx0XHRzX3NlYXJjaCA9ICcnO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gdXBkYXRlX3NlYXJjaChkX2V2ZW50OiBFdmVudCkge1xuXHRcdC8vIGN1cnJlbnRseSBpbiBzZWFyY2ggdGhyZWFkXG5cdFx0aWYoaXNTZWFyY2hTY3JlZW4pIHtcblx0XHRcdC8vIHNlYXJjaCBpcyBiZWluZyBjYW5jZWxsZWRcblx0XHRcdGlmKCFzX3NlYXJjaCkge1xuXHRcdFx0XHQkeXdfc2VhcmNoID0gJyc7XG5cdFx0XHRcdCR5d19jYW5jZWxfc2VhcmNoKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0ZGlzcGF0Y2goJ3NlYXJjaCcsIHNfc2VhcmNoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gbm90IHNlYXJjaCBzY3JlZW4sIGJ1dCB1c2VyIHR5cGVkIHNvbWV0aGluZ1xuXHRcdGVsc2UgaWYoc19zZWFyY2gpIHtcblx0XHRcdGNvbnN0IHNpX2NhY2hlID0gJHl3X3RocmVhZC5pZDtcblxuXHRcdFx0Y29uc3QgZG1fZm9jdXMgPSBxcyhkbV9oZWFkZXIsICc6Zm9jdXMnKSBhcyBIVE1MRWxlbWVudDtcblx0XHRcdGlmKGRtX2ZvY3VzKSB7XG5cdFx0XHRcdGRtX2ZvY3VzLmJsdXIoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZG1faGVhZGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuXHRcdFx0Ly8gY29uc3QgZG1fY2xvbmUgPSAkeXdfc2NyZWVuX2RvbS5jbG9uZU5vZGUodHJ1ZSkgYXMgSFRNTEVsZW1lbnQ7XG5cdFx0XHQvLyAkeXdfZXhpdHRpbmdfZG9tLmFwcGVuZChkbV9jbG9uZSlcblxuXHRcdFx0Ly8gJHl3X2hlYWRlcl9wcm9wcyA9IHtcblx0XHRcdC8vIFx0cG9wcyxcblx0XHRcdC8vIFx0YWNjb3VudCxcblx0XHRcdC8vIFx0bmV0d29yayxcblx0XHRcdC8vIFx0c2VhcmNoLFxuXHRcdFx0Ly8gXHRuYW1lLFxuXHRcdFx0Ly8gXHRzeW1ib2wsXG5cdFx0XHQvLyBcdHN1Ym5hbWUsXG5cdFx0XHQvLyBcdHNlYXJjaF9pbnB1dDogJHl3X3NlYXJjaCxcblx0XHRcdC8vIH07XG5cblx0XHRcdCR5d19jYW5jZWxfc2VhcmNoID0gKCkgPT4ge1xuXHRcdFx0XHQvLyBkbV9oZWFkZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcblx0XHRcdFx0Ly8gJHl3X3NlYXJjaCA9ICcnO1xuXG5cdFx0XHRcdC8vICR5d190aHJlYWRfaWQgPSBzaV9jYWNoZTtcblxuXHRcdFx0XHRzX3NlYXJjaCA9ICcnO1xuXG5cdFx0XHRcdGNvbnNvbGUubG9nKCdzdGVhbGluZyBmb2N1cyBmb3IgY2FuY2VsIHNlYXJjaCcpO1xuXHRcdFx0XHRkbV9zZWFyY2guZm9jdXMoKTtcblx0XHRcdH07XG5cblxuXHRcdFx0Ly8gc2F2ZSBzZWFyY2ggc3RyaW5nXG5cdFx0XHQkeXdfc2VhcmNoID0gc19zZWFyY2g7XG5cblx0XHRcdC8vIC8vIHNldCB0aHJlYWRcblx0XHRcdC8vICR5d190aHJlYWRfaWQgPSBUaHJlYWRJZC5TRUFSQ0g7XG5cdFx0fVxuXHR9XG5cblx0Ly8gYXN5bmMgZnVuY3Rpb24gc2VhcmNoX2lucHV0KCkge1xuXHQvLyBcdGF3YWl0IHRpY2soKTtcblx0Ly8gXHRkZWJ1Z2dlcjtcblx0Ly8gXHRpZihzX3NlYXJjaF9pbnB1dCkge1xuXHQvLyBcdFx0aWYoVGhyZWFkSWQuU0VBUkNIICE9PSAkeXdfdGhyZWFkX2lkKSB7XG5cdC8vIFx0XHRcdGRtX2hlYWRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdC8vIFx0XHRcdC8vIGNvbnN0IGRtX2Nsb25lID0gZG1faGVhZGVyLmNsb25lTm9kZSh0cnVlKTtcblx0XHRcdFx0XG5cdC8vIFx0XHRcdCR5d190aHJlYWRfaWQgPSBUaHJlYWRJZC5TRUFSQ0g7XG5cdC8vIFx0XHR9XG5cdC8vIFx0fSBcblx0Ly8gfVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5oZWFkZXIge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRnYXA6IDE2cHg7XG5cblx0XHQmLmJsdXIge1xuXHRcdFx0Pio6bm90KC50b3ApIHtcblx0XHRcdFx0ZmlsdGVyOiBibHVyKDJweCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pio6bm90KC50b3ApIHtcblx0XHRcdHRyYW5zaXRpb246IGJsdXIgNDAwbXMgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdH1cblx0fVxuXG5cdC50b3Age1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cblx0XHQ+LmJhY2sge1xuXHRcdFx0ZmxleDogMTtcblx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdG1heC13aWR0aDogMjRweDtcblx0XHRcdG1hcmdpbi1yaWdodDogMjBweDtcblx0XHR9XG5cblx0XHQ+LmxvZ28uaWNvbiB7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDMycHg7XG5cdFx0XHR0cmFuc2Zvcm06IHNjYWxlKDEuNDI1KTtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHR9XG5cblx0XHQ+Lm1haW4ge1xuXHRcdFx0ZmxleDogMztcblx0XHRcdC8vIG1heC13aWR0aDogZml0LWNvbnRlbnQ7XG5cdFx0XHRjdXJzb3I6IGRlZmF1bHQ7XG5cdFx0XHRtYXJnaW4tcmlnaHQ6IDFlbTtcblx0XHRcdG1pbi13aWR0aDogMjUlO1xuXG5cdFx0XHQ+LnRpdGxlIHtcblx0XHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHRcdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdFx0XHRcdHdoaXRlLXNwYWNlOiBub3dyYXA7XG5cblx0XHRcdFx0Pi5uYW1lIHtcblx0XHRcdFx0XHRmb250LXdlaWdodDogNTAwO1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4uc3ltYm9sIHtcblx0XHRcdFx0XHRmb250LXdlaWdodDogNDAwO1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Pi5zdWJ0aXRsZSB7XG5cdFx0XHRcdGZvbnQtc2l6ZTogMTJweDtcblx0XHRcdFx0Zm9udC13ZWlnaHQ6IDUwMDtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQ+LnJpZ2h0IHtcblx0XHRcdGZsZXg6IDU7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0bWF4LXdpZHRoOiBtYXgtY29udGVudDtcblx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0XHRnYXA6IDFlbTtcblxuXHRcdFx0Ly8gLy8gZm9yIGFic29sdXRlLXBvc2l0aW9uZWQgb3ZlcmxheSBjaGlsZFxuXHRcdFx0Ly8gcG9zaXRpb246IHJlbGF0aXZlO1xuXG5cdFx0XHQmLmhlaWdodGxlc3Mge1xuXHRcdFx0XHRoZWlnaHQ6IDA7XG5cdFx0XHR9XG5cblx0XHRcdC8vID4ubmV0d29yayB7XG5cdFx0XHQvLyBcdGZsZXg6IDM7XG5cdFx0XHQvLyBcdG1heC13aWR0aDogZml0LWNvbnRlbnQ7XG5cdFx0XHQvLyBcdGN1cnNvcjogcG9pbnRlcjtcblx0XHRcdC8vIFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRcdC8vIFx0bWFyZ2luLXRvcDogLTE3cHg7XG5cblx0XHRcdC8vIFx0Pi5pY29uIHtcblx0XHRcdC8vIFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0Ly8gXHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdC8vIFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdFx0Ly8gXHRcdG1hcmdpbi1sZWZ0OiAtNHB4O1xuXHRcdFx0Ly8gXHR9XG5cdFx0XHQvLyB9XG5cblx0XHRcdD4uY2x1c3RlciB7XG5cdFx0XHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdFx0XHRAcmFkaXVzOiA1cHg7XG5cblx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gY29sbGFwc2UgYWRqYWNlbnQgYm9yZGVyc1xuXHRcdFx0XHQ+Om50aC1jaGlsZChuKzEpIHtcblx0XHRcdFx0XHRtYXJnaW4tbGVmdDogLTJweDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vID5zcGFuLm5ldHdvcmsge1xuXHRcdFx0XHQvLyBcdC0taWNvbi1kaWFtZXRlcjogMjZweDtcblx0XHRcdFx0Ly8gXHQtLWJ1dHRvbi1kaWFtZXRlcjogMzJweDtcblx0XHRcdFx0Ly8gXHRtYXJnaW4tYm90dG9tOiAtMXB4O1xuXHRcdFx0XHQvLyB9XG5cblx0XHRcdFx0Ly8gPi5hY2NvdW50LD4ubmV0d29yayB7XG5cdFx0XHRcdC8vIFx0LS1pY29uLWRpYW1ldGVyOiAzMnB4O1xuXG5cdFx0XHRcdC8vIFx0ZmxleDogMTtcblx0XHRcdFx0Ly8gXHRtYXgtd2lkdGg6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHQvLyBcdG1pbi13aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdC8vIFx0bWFyZ2luLWJvdHRvbTogLTVweDtcblx0XHRcdFx0Ly8gXHRjdXJzb3I6IHBvaW50ZXI7XG5cblx0XHRcdFx0Ly8gXHQuZmFjZSB7XG5cdFx0XHRcdC8vIFx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG5cdFx0XHRcdC8vIFx0XHR3aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdC8vIFx0XHRoZWlnaHQ6IHZhcigtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHQvLyBcdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdC8vIFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0Ly8gXHR9XG5cdFx0XHRcdC8vIH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQuc2VhcmNoIHtcblx0XHRmb250LXdlaWdodDogNDAwO1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuXHRcdD4uYWN0aW9uIHtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjBweDtcblx0XHRcdHdpZHRoOiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdGhlaWdodDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRmaWxsOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblxuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0cmlnaHQ6IDEycHg7XG5cdFx0XHR0b3A6IGNhbGMoNTAlIC0gKHZhcigtLWljb24tZGlhbWV0ZXIpIC8gMikpO1xuXG5cdFx0XHQ+c3ZnIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0d2lkdGg6IDEwMCU7XG5cdFx0XHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiaGVhZGVyXCIgYmluZDp0aGlzPXtkbV9oZWFkZXJ9PiAgPCEtLSBjbGFzczpibHVyPXskeXdfYmx1cn0gLS0+XG5cdDwhLS0gdG9wIHJvdyAtLT5cblx0PGRpdiBjbGFzcz1cInRvcFwiPlxuXHRcdDwhLS0gbGVmdG1vc3QgYWN0aW9uL2J1dHRvbiAtLT5cblx0XHR7I2lmIGJfcG9wc31cblx0XHRcdDxzcGFuIGNsYXNzPVwiYmFja1wiIG9uOmNsaWNrPXsoKSA9PiBrX3BhZ2UucG9wKCl9PlxuXHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9BUlJPV19MRUZUfVxuXHRcdFx0XHQ8IS0tIDxBcnJvd0JhY2tJY29uIHNpemU9JzI0cHgnIC8+IC0tPlxuXHRcdFx0XHQ8IS0tIDxpbWcgc3JjPVwiL21lZGlhL25hdi9hcnJvdy1sZWZ0LnN2Z1wiIGFsdD1cIkNsaWNrIHRvIGdvIGJhY2tcIiAvPiAtLT5cblx0XHRcdDwvc3Bhbj5cblx0XHR7OmVsc2UgaWYgIWJfZXhpdHMgJiYgIWJfcGxhaW59XG5cdFx0XHQ8U3RhclNoZWxsTG9nbyBkaW09ezQ4fSBhbHQ9XCJDbGljayB0byB2aWV3IGdlbmVyYWwgc3RhdHVzXCIgb246Y2xpY2s9eygpID0+ICR5d19tZW51X3ZlbmRvciA9IHRydWV9IC8+XG5cdFx0ey9pZn1cblxuXHRcdDwhLS0gbWFpbiB0aXRsZSBzZWN0aW9uIG9uIHRoZSBsZWZ0IC0tPlxuXHRcdDxzcGFuIGNsYXNzPVwibWFpblwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cInRpdGxlXCI+XG5cdFx0XHRcdHsjaWYgc190aXRsZX1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdHtzX3RpdGxlfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHR7I2lmIHNfc3ltYm9sfVxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJzeW1ib2xcIj5cblx0XHRcdFx0XHRcdFx0LSB7c19zeW1ib2x9XG5cdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0ey9pZn1cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IGNsYXNzPVwic3VidGl0bGVcIj5cblx0XHRcdFx0e3Nfc3VidGl0bGV9XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L3NwYW4+XG5cblx0XHQ8IS0tIGFsbCB0b3AgYWN0aW9ucyB0aGF0IGFwcGVhciBvbiB0aGUgcmlnaHQgc2lkZSAtLT5cblx0XHQ8c3BhbiBjbGFzcz1cInJpZ2h0XCIgY2xhc3M6aGVpZ2h0bGVzcz17IWJfbmV0d29yayAmJiBiX2V4aXRzfT5cblx0XHRcdDwhLS0gYWNjb3VudC9uZXR3b3JrIHN3aXRjaCBjbHVzdGVyIC0tPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJjbHVzdGVyXCI+XG5cdFx0XHRcdDwhLS0gbmV0d29yayBzd2l0Y2hlciAtLT5cblx0XHRcdFx0eyNpZiBiX25ldHdvcmt9XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJuZXR3b3JrXCIgb246Y2xpY2s9eyhkX2V2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRkX2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0JHl3X292ZXJsYXlfbmV0d29yayA9ICEkeXdfb3ZlcmxheV9uZXR3b3JrO1xuXHRcdFx0XHRcdH19PlxuXHRcdFx0XHRcdFx0eyNrZXkgJHl3X2NoYWlufVxuXHRcdFx0XHRcdFx0XHQ8UGZwRGlzcGxheVxuXHRcdFx0XHRcdFx0XHRcdHJlc291cmNlPXskeXdfY2hhaW59XG5cdFx0XHRcdFx0XHRcdFx0ey4uLm92ZXJsYXlfcGZwX3Byb3BzKGZhbHNlKX1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdHsva2V5fVxuXHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdHsjaWYgJHl3X292ZXJsYXlfbmV0d29ya31cblx0XHRcdFx0XHRcdDxPdmVybGF5U2VsZWN0XG5cdFx0XHRcdFx0XHRcdHRpdGxlPSdTd2l0Y2ggTmV0d29yaydcblx0XHRcdFx0XHRcdFx0YmluZDpvcGVuPXskeXdfb3ZlcmxheV9uZXR3b3JrfVxuXHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJyb3dzXCI+XG5cdFx0XHRcdFx0XHRcdFx0eyNhd2FpdCBDaGFpbnMucmVhZCgpfVxuXHRcdFx0XHRcdFx0XHRcdFx0Li4uXG5cdFx0XHRcdFx0XHRcdFx0ezp0aGVuIGtzX2NoYWluc30gXG5cdFx0XHRcdFx0XHRcdFx0XHR7I2VhY2gga3NfY2hhaW5zLmVudHJpZXMoKSBhcyBbcF9jaGFpbiwgZ19jaGFpbl19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZT17Z19jaGFpbn1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXRhaWw9J0RlZmF1bHQgUHJvdmlkZXInXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCR5d19jaGFpbl9yZWYgPSBwX2NoYWluO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JHl3X292ZXJsYXlfbmV0d29yayA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJyaWdodFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyNpZiAkeXdfY2hhaW5fcmVmID09PSBwX2NoYWlufVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm92ZXJsYXktc2VsZWN0IGljb25cIiBzdHlsZT1cIi0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e0BodG1sIFNYX0NIRUNLRUR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDwvUm93PlxuXHRcdFx0XHRcdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHRcdFx0XHRcdHsvYXdhaXR9XG5cdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdFx0PC9PdmVybGF5U2VsZWN0PlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdHsvaWZ9XG5cblx0XHRcdFx0PCEtLSBhY2NvdW50IHN3aXRjaGVyIC0tPlxuXHRcdFx0XHR7I2lmIGJfYWNjb3VudH1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImFjY291bnRcIiBvbjpjbGljaz17KGRfZXZlbnQpID0+IHtcblx0XHRcdFx0XHRcdGRfZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHQkeXdfb3ZlcmxheV9hY2NvdW50ID0gISR5d19vdmVybGF5X2FjY291bnQ7XG5cdFx0XHRcdFx0fX0+XG5cdFx0XHRcdFx0XHR7I2tleSAkeXdfYWNjb3VudH1cblx0XHRcdFx0XHRcdFx0PFBmcERpc3BsYXlcblx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZT17JHl3X2FjY291bnR9XG5cdFx0XHRcdFx0XHRcdFx0ey4uLm92ZXJsYXlfcGZwX3Byb3BzKHRydWUpfVxuXHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0ey9rZXl9XG5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHR7I2lmICR5d19vdmVybGF5X2FjY291bnR9XG5cdFx0XHRcdFx0XHQ8T3ZlcmxheVNlbGVjdFxuXHRcdFx0XHRcdFx0XHR0aXRsZT0nU3dpdGNoIEFjY291bnQnXG5cdFx0XHRcdFx0XHRcdGJpbmQ6b3Blbj17JHl3X292ZXJsYXlfYWNjb3VudH1cblx0XHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwicm93c1wiPlxuXHRcdFx0XHRcdFx0XHRcdHsjYXdhaXQgQWNjb3VudHMucmVhZCgpfVxuXHRcdFx0XHRcdFx0XHRcdFx0Li4uXG5cdFx0XHRcdFx0XHRcdFx0ezp0aGVuIGtzX2FjY291bnRzfVxuXHRcdFx0XHRcdFx0XHRcdFx0PCEtLSB7I2lmIGtzX2FjY291bnRzLmVudHJpZXMoKS5sZW5ndGggPiAyfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmFtZT1cIkFsbCBBY2NvdW50c1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGV0YWlsPXtmb3JtYXRfZmlhdChPYmplY3QudmFsdWVzKEhfQUNDT1VOVFMpLnJlZHVjZSgoY19zdW0sIGtfYWNjb3VudCkgPT4gY19zdW0gKyAoa19hY2NvdW50LmFnZ3JlZ2F0b3I/IDA6IEhvbGRpbmcudXNkU3VtKGtfYWNjb3VudC5ob2xkaW5ncyhIX0hPTERJTkdTLCAkeXdfY2hhaW4pLCBIX1RPS0VOUywgSF9WRVJTVVNfVVNEKSksIDApKX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgcF9hY2NvdW50X2FsbCA9IEFjY291bnQucmVmRnJvbUlkKCcqJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfYWNjb3VudCA9IEhfQUNDT1VOVFNbcF9hY2NvdW50X2FsbF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfb3ZlcmxheV9hY2NvdW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInJpZ2h0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7I2lmICR5d19hY2NvdW50LmRlZi5pcmkgPT09IEFjY291bnQucmVmRnJvbUlkKCcqJyl9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwib3ZlcmxheS1zZWxlY3QgaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBTWF9DSEVDS0VEfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJwZnAgc3F1YXJlIGljb24gYWdncmVnYXRvclwiIHN0eWxlPVwiZGlzcGxheTogaW5saW5lLWJsb2NrOyBmb250LXNpemU6MzBweDsgbWFyZ2luLWxlZnQ6YXV0bzsgbWFyZ2luLXJpZ2h0OmF1dG87XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0XHRcdFx0XHQtLT5cblxuXHRcdFx0XHRcdFx0XHRcdFx0PCEtLSB7I2VhY2gga3NfYWNjb3VudHMuZW50cmllcygpLmZpbHRlcigoWyxrXSkgPT4gIWsuYWdncmVnYXRvcikgYXMgW3BfYWNjb3VudCwga19hY2NvdW50XX0gLS0+XG5cdFx0XHRcdFx0XHRcdFx0XHR7I2VhY2gga3NfYWNjb3VudHMuZW50cmllcygpIGFzIFtwX2FjY291bnQsIGdfYWNjb3VudF19XG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvdXJjZT17Z19hY2NvdW50fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc291cmNlUGF0aD17cF9hY2NvdW50fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRldGFpbD17Z19hY2NvdW50LmV4dHJhPy50b3RhbF9maWF0X2NhY2hlID8/ICcoPyknfVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfYWNjb3VudF9yZWYgPSBwX2FjY291bnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkeXdfb3ZlcmxheV9hY2NvdW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInJpZ2h0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7I2lmICR5d19hY2NvdW50X3JlZiA9PT0gcF9hY2NvdW50fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm92ZXJsYXktc2VsZWN0IGljb25cIiBzdHlsZT1cIi0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0e0BodG1sIFNYX0NIRUNLRUR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8UGZwRGlzcGxheSBkaW09ezMyfSByZXNvdXJjZT17Z19hY2NvdW50fSAvPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHRcdFx0XHR7L2F3YWl0fVxuXHRcdFx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0XHRcdDwvT3ZlcmxheVNlbGVjdD5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHR7L2lmfVxuXHRcdFx0PC9zcGFuPlxuXG5cdFx0XHQ8IS0tIGV4aXQgYnV0dG9uIC0tPlxuXHRcdFx0eyNpZiBiX2V4aXRzfVxuXHRcdFx0XHQ8Q2xvc2Ugb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdjbG9zZScpfSAvPlxuXHRcdFx0ey9pZn1cblx0XHQ8L3NwYW4+XG5cdDwvZGl2PlxuXHR7I2lmIGJfc2VhcmNofVxuXHRcdDxkaXYgY2xhc3M9XCJzZWFyY2hcIj5cblx0XHRcdDxpbnB1dCB0eXBlPVwidGV4dFwiXG5cdFx0XHRcdGF1dG9mb2N1cz17aXNTZWFyY2hTY3JlZW59XG5cdFx0XHRcdHBsYWNlaG9sZGVyPSdTZWFyY2ggYW55dGhpbmc6IHRva2VuLCBhY2NvdW50LCBjb250YWN0LCB0eG4uLi4nXG5cdFx0XHRcdGJpbmQ6dmFsdWU9e3Nfc2VhcmNofVxuXHRcdFx0XHRvbjppbnB1dD17dXBkYXRlX3NlYXJjaH1cblx0XHRcdFx0YmluZDp0aGlzPXtkbV9zZWFyY2h9XG5cdFx0XHQ+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImFjdGlvblwiPlxuXHRcdFx0XHQ8IS0tIDxpbWcgc3JjPVwiL2Fzc2V0cy9tZWRpYS9uYXYvc2VhcmNoLnN2Z1wiIGFsdD1cIlwiIC8+IC0tPlxuXHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9TRUFSQ0h9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9kaXY+XG5cdHsvaWZ9XG48L2Rpdj5cbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiIGxhbmc9XCJ0c1wiPlxuXHRleHBvcnQgbmFtZXNwYWNlIExvZ0l0ZW0ge1xuXHRcdGV4cG9ydCBpbnRlcmZhY2UgU3RyaW5nIHtcblx0XHRcdHR5cGU6ICdzdHJpbmcnO1xuXHRcdFx0dmFsdWU6IHN0cmluZztcblx0XHR9XG5cblx0XHRleHBvcnQgaW50ZXJmYWNlIEV2ZW50IHtcblx0XHRcdHR5cGU6ICdldmVudCc7XG5cdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRtZXNzYWdlOiBzdHJpbmc7XG5cdFx0XHRcdG9mZnNldDogbnVtYmVyO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRleHBvcnQgdHlwZSBBbnkgPSBTdHJpbmcgfCBFdmVudDtcblx0fVxuXG5cdGV4cG9ydCB0eXBlIExvZ0l0ZW0gPSBMb2dJdGVtLkFueTtcblxuXHRleHBvcnQgY2xhc3MgTG9nZ2VyIHtcblx0XHQvLyBwcml2YXRlIF9hX2l0ZW1zOiBMb2dJdGVtW10gPSBbXTtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0dGhpcy5fYV9pdGVtcyA9IFtdO1xuXHRcdH1cblxuXHRcdGdldCBpdGVtcygpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hX2l0ZW1zO1xuXHRcdH1cblxuXHRcdHNldCBpdGVtcyhhX2l0ZW1zOiBMb2dJdGVtW10pIHtcblx0XHRcdHRoaXMuX2FfaXRlbXMgPSBhX2l0ZW1zO1xuXHRcdH1cblxuXHRcdGV2ZW50KHNfbXNnOiBzdHJpbmcsIHh0X29mZnNldDogbnVtYmVyKTogdGhpcyB7XG5cdFx0XHR0aGlzLl9hX2l0ZW1zLnB1c2goe1xuXHRcdFx0XHR0eXBlOiAnZXZlbnQnLFxuXHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdG1lc3NhZ2U6IHNfbXNnLFxuXHRcdFx0XHRcdG9mZnNldDogeHRfb2Zmc2V0LFxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fVxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG5cblx0ZXhwb3J0IGxldCBpdGVtczogTG9nSXRlbVtdO1xuXG5cdGV4cG9ydCBsZXQgaGlkZSA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIGZvcm1hdF9tcyhuX21zOiBudW1iZXIpOiBzdHJpbmcge1xuXHRcdHJldHVybiAobl9tcyAvIDEwMDApLnRvRml4ZWQoMikucGFkU3RhcnQoNSwgJzAnKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQubG9nLWNvbnRhaW5lciB7XG5cdFx0Zm9udC1mYW1pbHk6ICdQVCBNb25vJywgbW9ub3NwYWNlO1xuXG5cdFx0Pm9sIHtcblx0XHRcdD5saSB7XG5cdFx0XHRcdD5zcGFuIHtcblx0XHRcdFx0XHQmLnN0cmluZyB7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmLmV2ZW50IHtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJsb2ctY29udGFpbmVyXCIgY2xhc3M6ZGlzcGxheV9ub25lPXtoaWRlfT5cblx0PG9sPlxuXHRcdHsjZWFjaCBpdGVtcyBhcyBnX2l0ZW19XG5cdFx0XHQ8bGk+XG5cdFx0XHRcdHsjaWYgJ3N0cmluZycgPT09IGdfaXRlbS50eXBlfVxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwic3RyaW5nXCI+e2dfaXRlbS52YWx1ZX08L3NwYW4+XG5cdFx0XHRcdHs6ZWxzZSBpZiAnZXZlbnQnID09PSBnX2l0ZW0udHlwZX1cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImV2ZW50XCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm9mZnNldFwiPit7Zm9ybWF0X21zKGdfaXRlbS52YWx1ZS5vZmZzZXQpfW1zOiA8L3NwYW4+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm1lc3NhZ2VcIj57Z19pdGVtLnZhbHVlLm1lc3NhZ2V9PC9zcGFuPlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0ey9pZn1cblx0XHRcdDwvbGk+XG5cdFx0ey9lYWNofVxuXHQ8L29sPlxuPC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHQvLyB0YXJnZXQgd2lkdGhcblx0ZXhwb3J0IGxldCB3aWR0aCA9IDE4MDtcblx0Y29uc3QgeF93aWR0aCA9IHdpZHRoO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQudGl0bGUge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdG1hcmdpbjogMDtcblx0XHRwYWRkaW5nOiAwO1xuXHRcdGJvcmRlcjogMDtcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblxuXHRcdG1hcmdpbi1sZWZ0OiBhdXRvO1xuXHRcdG1hcmdpbi1yaWdodDogYXV0bztcblxuXHRcdGhlaWdodDogYXV0bztcblxuXHRcdGltZyB7XG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJuby1tYXJnaW4gdGl0bGVcIiBzdHlsZT1cIndpZHRoOnt4X3dpZHRofXB4O1wiPlxuXHQ8aW1nIGFsdD1cIlN0YXJTaGVsbCB0aXRsZVwiIHNyYz1cIi9tZWRpYS92ZW5kb3IvdGl0bGUuc3ZnXCIgLz5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtnZXRDb250ZXh0fSBmcm9tICdzdmVsdGUnO1xuXG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcuLi91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuXHRpbXBvcnQge1NjcmVlbiwgdHlwZSBQYWdlfSBmcm9tICcuL19zY3JlZW5zJztcblxuXG5cdGV4cG9ydCBsZXQgYXR0ZW1wdF9yZWdpc3RlcjogVm9pZEZ1bmN0aW9uO1xuXHRleHBvcnQgbGV0IHdlYWtuZXNzOiBudW1iZXI7XG5cdGNvbnN0IGlfd2Vha25lc3MgPSB3ZWFrbmVzcztcblxuXHQvLyBnZXQgcGFnZSBmcm9tIGNvbnRleHRcblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGZ1bmN0aW9uIHVzZV9hbnl3YXkoKSB7XG5cdFx0YXR0ZW1wdF9yZWdpc3RlcigpO1xuXHRcdGtfcGFnZS5wb3AoKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxTY3JlZW4+XG5cdDxoMz5cblx0XHRXZWFrIFBhc3N3b3JkIFdhcm5pbmdcblx0PC9oMz5cblxuXHQ8cD5cblx0XHRUaGUgcGFzc3dvcmQgeW91IGVudGVyZWQgd2FzIGZvdW5kIG9uIGEgbGlzdCBvZiB0aGUgdG9wIHRlbiB0aG91c2FuZCBtb3N0IGNvbW1vbmx5IHVzZWQgcGFzc3dvcmRzLlxuXHQ8L3A+XG5cblx0PHA+XG5cdFx0SW4gb3JkZXIgdG8gaGVscCBwcmV2ZW50IHRoZSBsb3NzIG9mIGZ1bmRzLCB5b3UgYXJlIGVuY291cmFnZWQgdG8gY3JlYXRlIGEgc3Ryb25nLCB1bmlxdWUgcGFzc3dvcmQuXG5cdDwvcD5cblxuXHQ8cD5cblx0XHRIb3cgZG8geW91IHdhbnQgdG8gcHJvY2VlZD9cblx0PC9wPlxuXG5cdDxBY3Rpb25zTGluZSBjYW5jZWw9J3BvcCcgY29uZmlybT17WydVc2UgYW55d2F5JywgdXNlX2FueXdheV19IHdhaXQ9ezUwMDB9IC8+XG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBnZXRBbGxDb250ZXh0cywgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IFBhZ2UsIFNjcmVlbiB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGltcG9ydCBGaWVsZCBmcm9tICcjL2FwcC91aS9GaWVsZC5zdmVsdGUnO1xuXHRpbXBvcnQgTG9nLCB7IExvZ2dlciB9IGZyb20gJyMvYXBwL3VpL0xvZy5zdmVsdGUnO1xuXG5cdGltcG9ydCB7IFZhdWx0IH0gZnJvbSAnIy9jcnlwdG8vdmF1bHQnO1xuXHRpbXBvcnQge1xuXHRcdEFUVThfRFVNTVlfUEhSQVNFLFxuXHRcdEFUVThfRFVNTVlfVkVDVE9SLFxuXHRcdGFjY2VwdGFibGUsXG5cdFx0bG9naW4sXG5cdFx0cmVnaXN0ZXIsXG5cdFx0QWxyZWFkeVJlZ2lzdGVyZWRFcnJvcixcblx0XHRJbnZhbGlkUGFzc3BocmFzZUVycm9yLFxuXHRcdE5MX1BBU1NQSFJBU0VfTUlOSU1VTSxcblx0XHROTF9QQVNTUEhSQVNFX01BWElNVU0sXG5cdH0gZnJvbSAnIy9zaGFyZS9hdXRoJztcblxuXHRpbXBvcnQgdHlwZSB7IENvbXBsZXRlZCB9IGZyb20gJyMvZW50cnkvZmxvdyc7XG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcuLi91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuXHRpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblx0aW1wb3J0IFN0YXJTaGVsbExvZ28gZnJvbSAnLi4vdWkvU3RhclNoZWxsTG9nby5zdmVsdGUnO1xuXHRpbXBvcnQgU3RhclNoZWxsVGl0bGUgZnJvbSAnLi4vdWkvU3RhclNoZWxsVGl0bGUuc3ZlbHRlJztcblx0aW1wb3J0IFJlZ2lzdGVyV2Vha1Bhc3N3b3JkU3ZlbHRlIGZyb20gJy4vUmVnaXN0ZXJXZWFrUGFzc3dvcmQuc3ZlbHRlJztcblxuXHQvLyBnZXQgcGFnZSBmcm9tIGNvbnRleHRcblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8vIHdpbGwgYmUgc2V0IGlmIHRoaXMgaXMgcGFydCBvZiBhIGZsb3dcblx0Y29uc3QgY29tcGxldGVkID0gZ2V0Q29udGV4dDxDb21wbGV0ZWQgfCB1bmRlZmluZWQ+KCdjb21wbGV0ZWQnKTtcblxuXHQvLyBiaW5kaW5nc1xuXHRsZXQgc2hfcGhyYXNlID0gJyc7XG5cdGxldCBzaF92ZXJpZnkgPSAnJztcblx0bGV0IHNfZXJyb3IgPSAnJztcblxuXHRsZXQgc19lcnJfcGFzc3dvcmQgPSAnJztcblx0bGV0IHNfZXJyX3ZlcmlmeSA9ICcnO1xuXG5cdC8vIHRpbWUgc3RhcnRlZCByZWdpc3RyYXRpb25cblx0bGV0IHh0X3N0YXJ0ID0gMDtcblxuXHQvLyBsb2dnZXIgaW5zdGFjZVxuXHRsZXQga19sb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cblx0Ly8gbG9nIHRvIGxvZ2dlclxuXHRmdW5jdGlvbiBsb2coc19tc2c6IHN0cmluZykge1xuXHRcdGtfbG9nZ2VyID0ga19sb2dnZXIuZXZlbnQoc19tc2csIERhdGUubm93KCkgLSB4dF9zdGFydCk7XG5cdH1cblxuXG5cdC8vIGNvbnRpbnVvdXNseSBjaGVjayB0aGUgYWNjZXB0YWJpbGl0eSBvZiB0aGUgcGFzc3dvcmRcblx0JDogYl9wYXNzd29yZF9hY2NlcHRhYmxlID0gISFzaF9waHJhc2UgJiYgc2hfcGhyYXNlID09PSBzaF92ZXJpZnkgJiYgYWNjZXB0YWJsZShzaF9waHJhc2UpO1xuXG5cdC8vIHVwZGF0ZSB0aGUgY29uZmlybSBhY3Rpb25cblx0JDogYV9jb25maXJtX2FjdGlvbiA9IFsnQ29udGludWUnLCBwcmVwYXJlX3JlZ2lzdGVyLCAhYl9wYXNzd29yZF9hY2NlcHRhYmxlXSBhcyBjb25zdDtcblxuXG5cdC8vIGxpc3RlbiBmb3IgcGFnZSBldmVudCByZXN0b3JlXG5cdGtfcGFnZS5vbih7XG5cdFx0cmVzdG9yZSgpIHtcblx0XHRcdC8vIGNsZWFyIHBhc3N3b3Jkc1xuXHRcdFx0c2hfcGhyYXNlID0gc2hfdmVyaWZ5ID0gJyc7XG5cdFx0fSxcblx0fSk7XG5cblx0ZnVuY3Rpb24gY2hlY2tfcGFzc3dvcmQoKSB7XG5cdFx0aWYoc2hfcGhyYXNlICYmICFhY2NlcHRhYmxlKHNoX3BocmFzZSkpIHtcblx0XHRcdGlmKHNoX3BocmFzZS5sZW5ndGggPCBOTF9QQVNTUEhSQVNFX01JTklNVU0pIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSAnUGFzc3dvcmQgbXVzdCBiZSBhdCBsZWFzdCA1IGNoYXJhY3RlcnMnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihzaF9waHJhc2UubGVuZ3RoID4gTkxfUEFTU1BIUkFTRV9NQVhJTVVNKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gJ1Bhc3N3b3JkIG11c3QgYmUgMTAyNCBjaGFyYWN0ZXJzIG9yIGZld2VyJztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9ICdQYXNzd29yZCBpcyBub3QgYWNjZXB0YWJsZSc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzX2Vycl9wYXNzd29yZCA9ICcnO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tfdmVyaWZ5KCkge1xuXHRcdGlmKHNoX3BocmFzZSAmJiAhc19lcnJfcGFzc3dvcmQgJiYgc2hfcGhyYXNlICE9PSBzaF92ZXJpZnkpIHtcblx0XHRcdHNfZXJyX3ZlcmlmeSA9ICdQYXNzd29yZHMgZG8gbm90IG1hdGNoJztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRzX2Vycl92ZXJpZnkgPSAnJztcblx0fVxuXG5cdC8vIGRvd25sb2FkIHRvcCAxMGsgbGlzdCBhbmQgcGFyc2UgaXRcblx0Y29uc3QgZHBfcGFzc3dvcmRzID0gKGFzeW5jKCkgPT4ge1xuXHRcdGNvbnN0IGRfcmVzID0gYXdhaXQgZmV0Y2goJy9kYXRhL3Bhc3N3b3Jkcy10b3AtMTBrLnR4dCcpO1xuXHRcdGNvbnN0IHNfbGlzdCA9IGF3YWl0IGRfcmVzLnRleHQoKTtcblx0XHRyZXR1cm4gc19saXN0LnNwbGl0KCdcXG4nKTtcblx0fSkoKTtcblxuXHQvLyBwcmVwYXJlIHRvIHJlZ2lzdGVyXG5cdGFzeW5jIGZ1bmN0aW9uIHByZXBhcmVfcmVnaXN0ZXIoKSB7XG5cdFx0Ly8gY2hlY2sgYWdhaW5zdCB0b3AgMTBrIGxpc3Rcblx0XHRjb25zdCBhX3Bhc3N3b3JkcyA9IGF3YWl0IGRwX3Bhc3N3b3JkcztcblxuXHRcdC8vIHBhc3N3b3JkIGZvdW5kIGluIGxpc3Rcblx0XHRpZihhX3Bhc3N3b3Jkcy5pbmNsdWRlcyhzaF9waHJhc2UpKSB7XG5cdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdGNyZWF0b3I6IFJlZ2lzdGVyV2Vha1Bhc3N3b3JkU3ZlbHRlLFxuXHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdGF0dGVtcHRfcmVnaXN0ZXIsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0Ly8gcGFzc3dvcmQgbm90IGluIGxpc3Rcblx0XHRlbHNlIHtcblx0XHRcdGF3YWl0IGF0dGVtcHRfcmVnaXN0ZXIoKTtcblx0XHR9XG5cdH1cblxuXHQvLyByZWdpc3RyYXRpb24gaXMgYnVzeVxuXHRsZXQgYl9idXN5ID0gZmFsc2U7XG5cdFxuXHQvLyBhdHRlbXB0IHRvIHJlZ2lzdGVyXG5cdGFzeW5jIGZ1bmN0aW9uIGF0dGVtcHRfcmVnaXN0ZXIoKTogUHJvbWlzZTwxPiB7XG5cdFx0Ly8gaW52YWxpZCBzdGF0ZVxuXHRcdGlmKCFiX3Bhc3N3b3JkX2FjY2VwdGFibGUpIHJldHVybiAxO1xuXG5cdFx0Ly8gZG8gbm90IGludGVydXB0OyBsb2NrXG5cdFx0aWYoYl9idXN5KSByZXR1cm4gMTsgYl9idXN5ID0gdHJ1ZTtcblxuXHRcdC8vIHByZXAgZ3JhY2VmdWwgZXhpdFxuXHRcdGNvbnN0IGV4aXQgPSAoKTogMSA9PiAoYl9idXN5ID0gZmFsc2UsIDEpO1xuXG5cdFx0Ly8gcmVzZXQgZXJyb3Jcblx0XHRzX2Vycm9yID0gJyc7XG5cblx0XHQvLyBzdGFydCB0aW1lclxuXHRcdHh0X3N0YXJ0ID0gRGF0ZS5ub3coKTtcblxuXHRcdGxvZygnRXN0aW1hdGluZyB0aW1lIHRvIGNvbXBsZXRlJyk7XG5cblx0XHQvLyBlc3RpbWF0ZSB0aW1lIHRvIGNvbXBsZXRlXG5cdFx0e1xuXHRcdFx0Y29uc3QgeHRfc3RhcnRfZXN0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0YXdhaXQgVmF1bHQuZGVyaXZlUm9vdEJpdHMoQVRVOF9EVU1NWV9QSFJBU0UsIEFUVThfRFVNTVlfVkVDVE9SLCAxIC8gNTApO1xuXHRcdFx0Y29uc3QgeHRfZmluaXNoX2VzdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdFx0Y29uc3QgeHRfZWxhcHNlZF9lc3QgPSB4dF9maW5pc2hfZXN0IC0geHRfc3RhcnRfZXN0O1xuXHRcdFx0Y29uc3QgeHRfZXN0aW1hdGUgPSAyICogKDIgKiAoeHRfZWxhcHNlZF9lc3QgKiA1MCkpO1xuXHRcdFx0bG9nKGBBYm91dCAkeyh4dF9lc3RpbWF0ZSAvIDEwMDApLnRvRml4ZWQoMSl9IHNlY29uZHNgKTtcblx0XHR9XG5cblx0XHQvLyBhdHRlbXB0IHRvIHJlZ2lzdGVyXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IHJlZ2lzdGVyKHNoX3BocmFzZSwgbG9nKTtcblx0XHR9XG5cdFx0Ly8gaGFuZGxlIGVycm9yXG5cdFx0Y2F0Y2goZV9yZWdpc3Rlcikge1xuXHRcdFx0aWYoZV9yZWdpc3RlciBpbnN0YW5jZW9mIEFscmVhZHlSZWdpc3RlcmVkRXJyb3IpIHtcblx0XHRcdFx0c19lcnJvciA9ICdBIHBhc3NwaHJhc2UgaXMgYWxyZWFkeSByZWdpc3RlcmVkJztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZV9yZWdpc3RlciBpbnN0YW5jZW9mIEludmFsaWRQYXNzcGhyYXNlRXJyb3IpIHtcblx0XHRcdFx0c19lcnJvciA9ICdJbnZhbGlkIHBhc3NwaHJhc2UnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNfZXJyb3IgPSBgVW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCB3aGlsZSBhdHRlbXB0aW5nIHRvIHJlZ2lzdGVyOlxcbiR7ZV9yZWdpc3Rlci5zdGFjayB8fCBlX3JlZ2lzdGVyLm1lc3NhZ2V9YDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZXhpdFxuXHRcdFx0cmV0dXJuIGV4aXQoKTtcblx0XHR9XG5cblx0XHRsb2coJ1ZlcmlmeWluZyBwYXNzcGhyYXNlJyk7XG5cblx0XHQvLyBhdHRlbXB0IGxvZ2luXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGxvZ2luKHNoX3BocmFzZSwgZmFsc2UsIGxvZyk7XG5cdFx0fVxuXHRcdC8vIGZhaWxlZCB0byB2ZXJpZnlcblx0XHRjYXRjaChlX2xvZ2luKSB7XG5cdFx0XHRzX2Vycm9yID0gJ0ZhaWxlZCB0byB2ZXJpZnkgcGFzc3BocmFzZSBpbW1lZGlhdGVseSBhZnRlciByZWdpc3RyYXRpb24nO1xuXG5cdFx0XHQvLyByZXNldCB2YXVsdFxuXHRcdFx0YXdhaXQgVmF1bHQuZXJhc2VCYXNlKCk7XG5cblx0XHRcdC8vIGV4aXRcblx0XHRcdHJldHVybiBleGl0KCk7XG5cdFx0fVxuXG5cdFx0bG9nKCdEb25lJyk7XG5cblx0XHQvLyBwcm9jZWVkXG5cdFx0c19lcnJvciA9ICdTdWNjZXNzJztcblxuXHRcdC8vIGNvbXBsZXRlXG5cdFx0aWYoY29tcGxldGVkKSBjb21wbGV0ZWQodHJ1ZSk7XG5cblx0XHQvLyBkb25lXG5cdFx0cmV0dXJuIGV4aXQoKTtcblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdC5pbnRybyB7XG5cdFx0bWFyZ2luLXRvcDogMWVtO1xuXHRcdC8vIG1hcmdpbi1ib3R0b206IDRlbTtcblx0XHRtYXJnaW4tYm90dG9tOiAwO1xuXG5cdFx0LmxlYWQge1xuXHRcdFx0bWFyZ2luLXRvcDogMWVtO1xuXHRcdFx0bWFyZ2luLWJvdHRvbTogMDtcblx0XHR9XG5cblx0XHQudGl0bGUge1xuXHRcdFx0bGV0dGVyLXNwYWNpbmc6IDFweDtcblx0XHRcdGZvbnQtd2VpZ2h0OiAxMDA7XG5cdFx0XHRmb250LXNpemU6IDI3cHg7XG5cdFx0XHRjb2xvcjogI2QwZDBkMDtcblx0XHRcdG1hcmdpbjogMDtcblxuXHRcdFx0ZW0ge1xuXHRcdFx0XHRmb250LXNpemU6IDMycHg7XG5cdFx0XHRcdGZvbnQtc3R5bGU6IG5vcm1hbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQubG9nbyB7XG5cdFx0XHRoZWlnaHQ6IDM0dmg7XG5cdFx0XHR3aWR0aDogYXV0bztcblx0XHR9XG5cblx0XHQuaWNvbiB7XG5cdFx0XHQtLXN2Zy1jb2xvci1mZzogc2lsdmVyO1xuXHRcdFx0Ly8gLS1zdmctY29sb3ItYmc6ICNmNTI1MjU7XG5cdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gNjBweCk7XG5cdFx0XHRoZWlnaHQ6IGF1dG87XG5cblx0XHRcdC5ncmFwaGljKHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0d2lkdGg6IDE3MnB4O1xuXHRcdFx0XHRcdGhlaWdodDogMTM3cHg7XG5cdFx0XHRcdFx0bWFyZ2luOiAxMHB4IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQ+c3ZnIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHR9XG5cblx0Lm5hcnJvdyB7XG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRmb250LXdlaWdodDogMzAwO1xuXHRcdG1heC13aWR0aDogMThlbTtcblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbj5cblx0PGNlbnRlcj5cblx0XHQ8ZGl2IGNsYXNzPVwiaW50cm9cIj5cblx0XHRcdDxTdGFyU2hlbGxMb2dvIGRpbT17OTZ9IC8+XG5cblx0XHRcdDxTdGFyU2hlbGxUaXRsZSB3aWR0aD17MTUwfSAvPlxuXHRcdDwvZGl2PlxuXG5cdFx0PHAgY2xhc3M9XCJuYXJyb3dcIj5cblx0XHRcdENyZWF0ZSBhIG5ldyBwYXNzd29yZCB0byBwcm90ZWN0IHlvdXIgd2FsbGV0J3MgZGF0YS5cblx0XHQ8L3A+XG5cdDwvY2VudGVyPlxuXG5cdDxkaXYgY2xhc3M9XCJmb3JtIGZsZXgtcm93c1wiPlxuXHRcdDxpbnB1dCBoaWRkZW5cblx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdG5hbWU9XCJ1c2VybmFtZVwiXG5cdFx0XHRhdXRvY29tcGxldGU9XCJ1c2VybmFtZVwiXG5cdFx0XHR2YWx1ZT1cIlN0YXJTaGVsbCBXYWxsZXQgVXNlclwiPlxuXG5cdFx0PEZpZWxkIGtleT1cInBhc3N3b3JkXCIgbmFtZT1cIk5ldyBwYXNzd29yZFwiPlxuXHRcdFx0PGlucHV0XG5cdFx0XHRcdHR5cGU9XCJwYXNzd29yZFwiXG5cdFx0XHRcdGF1dG9jb21wbGV0ZT1cIm5ldy1wYXNzd29yZFwiXG5cdFx0XHRcdG5hbWU9XCJwYXNzd29yZFwiXG5cdFx0XHRcdHBsYWNlaG9sZGVyPVwiUGFzc3dvcmRcIlxuXHRcdFx0XHRvbjpibHVyPXsoKSA9PiBjaGVja19wYXNzd29yZCgpfVxuXHRcdFx0XHRiaW5kOnZhbHVlPXtzaF9waHJhc2V9PlxuXG5cdFx0XHR7I2lmICFiX3Bhc3N3b3JkX2FjY2VwdGFibGUgJiYgc19lcnJfcGFzc3dvcmR9XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzAwfX0+XG5cdFx0XHRcdFx0e3NfZXJyX3Bhc3N3b3JkfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvaWZ9XG5cdFx0PC9GaWVsZD5cblxuXHRcdDxGaWVsZCBrZXk9XCJ2ZXJpZnktcGFzc3dvcmRcIiBuYW1lPVwiVmVyaWZ5IHBhc3N3b3JkXCI+XG5cdFx0XHQ8aW5wdXRcblx0XHRcdFx0dHlwZT1cInBhc3N3b3JkXCJcblx0XHRcdFx0YXV0b2NvbXBsZXRlPVwibmV3LXBhc3N3b3JkXCJcblx0XHRcdFx0bmFtZT1cInZlcmlmeVwiXG5cdFx0XHRcdHBsYWNlaG9sZGVyPVwiUGFzc3dvcmRcIlxuXHRcdFx0XHRvbjpibHVyPXsoKSA9PiBjaGVja192ZXJpZnkoKX1cblx0XHRcdFx0YmluZDp2YWx1ZT17c2hfdmVyaWZ5fT5cblxuXHRcdFx0eyNpZiAhYl9wYXNzd29yZF9hY2NlcHRhYmxlICYmIHNfZXJyX3ZlcmlmeX1cblx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiIHRyYW5zaXRpb246c2xpZGU9e3tkdXJhdGlvbjozMDB9fT5cblx0XHRcdFx0XHR7c19lcnJfdmVyaWZ5fVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvaWZ9XG5cdFx0PC9GaWVsZD5cblxuXHQ8L2Rpdj5cblxuXHQ8TG9nIGJpbmQ6aXRlbXM9e2tfbG9nZ2VyLml0ZW1zfSAvPlxuXG5cdHsjaWYgc19lcnJvcn1cblx0XHQ8cHJlPntzX2Vycm9yfTwvcHJlPlxuXHR7L2lmfVxuXG5cblx0PEFjdGlvbnNMaW5lIGNvbmZpcm09e2FfY29uZmlybV9hY3Rpb259IC8+XG48L1NjcmVlbj5cbiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTkgNXYxNEg1VjVoMTRtMC0ySDVhMiAyIDAgMCAwLTIgMnYxNGEyIDIgMCAwIDAgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bS03IDljLTEuNjUgMC0zLTEuMzUtMy0zczEuMzUtMyAzLTMgMyAxLjM1IDMgMy0xLjM1IDMtMyAzem0wLTRjLS41NSAwLTEgLjQ1LTEgMXMuNDUgMSAxIDEgMS0uNDUgMS0xLS40NS0xLTEtMXptNiAxMEg2di0xLjUzYzAtMi41IDMuOTctMy41OCA2LTMuNThzNiAxLjA4IDYgMy41OFYxOHptLTkuNjktMmg3LjM4Yy0uNjktLjU2LTIuMzgtMS4xMi0zLjY5LTEuMTJzLTMuMDEuNTYtMy42OSAxLjEyelxcXCIvPlxcbjwvc3ZnPlwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+XFxuXFx0XFx0LnMyci1hbmFseXRpY3MtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0PC9zdHlsZT5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLWFuYWx5dGljcy1mZ1xcXCIgZD1cXFwiTTE5IDNINWMtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDVWNWgxNHYxNHpcXFwiLz5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLWFuYWx5dGljcy1mZ1xcXCIgZD1cXFwiTTcgMTJoMnY1SDd6bTgtNWgydjEwaC0yem0tNCA3aDJ2M2gtMnptMC00aDJ2MmgtMnpcXFwiLz5cXG48L3N2Zz5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTMgNS4wOEE3IDcgMCAwIDEgMTguOTIgMTFoMy4wM2MtLjQ3LTQuNzItNC4yMy04LjQ4LTguOTUtOC45NXYzLjAzek0xOC45MiAxM0E3IDcgMCAwIDEgMTMgMTguOTJ2My4wM2M0LjcyLS40NyA4LjQ4LTQuMjMgOC45NS04Ljk1aC0zLjAzek0xMSAxOC45MmMtMy4zOS0uNDktNi0zLjQtNi02LjkyczIuNjEtNi40MyA2LTYuOTJWMi4wNWMtNS4wNS41LTkgNC43Ni05IDkuOTUgMCA1LjE5IDMuOTUgOS40NSA5IDkuOTV2LTMuMDN6XFxcIi8+XFxuPC9zdmc+XCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgU3RhclNlbGVjdCwgeyBTZWxlY3RPcHRpb24gfSBmcm9tICcuL1N0YXJTZWxlY3Quc3ZlbHRlJztcblxuXHRpbXBvcnQge29kZSwgb2RlcmFmfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IHt5d19hY2NvdW50LCB5d19jaGFpbiwgeXdfb3duZXJ9IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB0eXBlIHsgUmVzb3VyY2UgfSBmcm9tICcjL21ldGEvcmVzb3VyY2UnO1xuXHRpbXBvcnQgdHlwZSB7IFRva2VuLCBUb2tlblBhdGgsIFRva2VuU3BlY0tleSB9IGZyb20gJyMvbWV0YS90b2tlbic7XG5cdGltcG9ydCB7IEVudGl0aWVzIH0gZnJvbSAnIy9zdG9yZS9lbnRpdGllcyc7XG5cdGltcG9ydCB0eXBlIHsgRW50aXR5UGF0aCB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHR5cGUgeyBQZnBQYXRoIH0gZnJvbSAnIy9tZXRhL3BmcCc7XG5cdGltcG9ydCB7IGxvYWRfcGZwcyB9IGZyb20gJy4uL3N2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBhc3NldFJlZjogRW50aXR5UGF0aCB8ICcnID0gJyc7XG5cblx0Y29uc3Qgc2lfY2hhaW4gPSAkeXdfY2hhaW4/LmlkIHx8ICcqJztcblxuXHRsZXQgaF9hc3NldF9wZnBzOiBSZWNvcmQ8UGZwUGF0aCwgSFRNTEVsZW1lbnQ+ID0ge307XG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9hc3NldHMoKSB7XG5cdFx0Y29uc3QgYV9pdGVtczogU2VsZWN0T3B0aW9uW10gPSBbXTtcblxuXHRcdGhfYXNzZXRfcGZwcyA9IGF3YWl0IGxvYWRfcGZwcygkeXdfY2hhaW4uY29pbnMsIHtcblx0XHRcdGRpbTogMTksXG5cdFx0fSk7XG5cblx0XHRmb3IoY29uc3QgW3NpX2NvaW4sIGdfY29pbl0gb2Ygb2RlKCR5d19jaGFpbi5jb2lucykpIHtcblx0XHRcdGFfaXRlbXMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBFbnRpdGllcy5ob2xkaW5nUGF0aEZvcigkeXdfb3duZXIsIHNpX2NvaW4pLFxuXHRcdFx0XHRvYmplY3Q6IGdfY29pbixcblx0XHRcdFx0cHJpbWFyeTogc2lfY29pbixcblx0XHRcdFx0c2Vjb25kYXJ5OiBnX2NvaW4ubmFtZSxcblx0XHRcdFx0cGZwOiBnX2NvaW4ucGZwLFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFfaXRlbXM7XG5cdH1cblxuXHQvLyB0aGUgY3VycmVudCBpdGVtIHNlbGVjdGVkIGJ5IHVzZXJcblx0bGV0IGdfaXRlbTogU2VsZWN0T3B0aW9uPEVudGl0eVBhdGg+ID0ge1xuXHRcdHZhbHVlOiBhc3NldFJlZiBhcyBFbnRpdHlQYXRoLFxuXHRcdG9iamVjdDogbnVsbCEsXG5cdFx0cHJpbWFyeTogJycsXG5cdFx0c2Vjb25kYXJ5OiAnJyxcblx0XHRwZnA6ICcnIGFzIFBmcFBhdGgsXG5cdH07XG5cdCQ6IHtcblx0XHQvLyBwcm9wYWdhdGUgY2hhbmdlIGJhY2sgdG8gZXhwb3J0ZWQgYmluZGluZ1xuXHRcdGFzc2V0UmVmID0gZ19pdGVtPy52YWx1ZSB8fCAnJztcblx0fVxuXG5cdC8vIGFzeW5jIGZ1bmN0aW9uIGxvYWRfdG9rZW5zKCkge1xuXHQvLyBcdC8vIHByZXAgYW4gb3V0cHV0IGxpc3Qgb2Ygc2VsZWN0IGl0ZW1zXG5cdC8vIFx0Y29uc3QgYV9pdGVtcyA9IFtdO1xuXG5cdC8vIFx0Ly8gcmVhZCBhbGwgZnVuZ2libGUgdG9rZW5zIGZvciB0aGlzIGNoYWluXG5cdC8vIFx0Y29uc3QgaF9pbnRlcmZhY2VzID0gYXdhaXQgRW50aXRpZXMucmVhZEZ1bmdpYmxlVG9rZW5zKCR5d19jaGFpbik7XG5cblx0Ly8gXHQvLyBlYWNoIGludGVyZmFjZVxuXHQvLyBcdGZvcihjb25zdCBzaV9pbnRlcmZhY2UgaW4gaF9pbnRlcmZhY2VzKSB7XG5cdC8vIFx0XHQvLyByZWYgdG9rZW4gZGljdFxuXHQvLyBcdFx0Y29uc3QgaF90b2tlbnMgPSBoX2ludGVyZmFjZXNbc2lfaW50ZXJmYWNlIGFzIFRva2VuU3BlY0tleV07XG5cblx0Ly8gXHRcdC8vIGVhY2ggdG9rZW5cblx0Ly8gXHRcdGZvcihjb25zdCBwX3Rva2VuIGluIGhfdG9rZW5zKSB7XG5cdC8vIFx0XHRcdC8vIHJlZiB0b2tlblxuXHQvLyBcdFx0XHRjb25zdCBnX3Rva2VuID0gaF90b2tlbnNbcF90b2tlbiBhcyBUb2tlblBhdGhdO1xuXG5cdC8vIFx0XHRcdC8vIGFkZCB0byBzZWxlY3QgaXRlbXMgbGlzdFxuXHQvLyBcdFx0XHRhX2l0ZW1zLnB1c2goe1xuXHQvLyBcdFx0XHRcdHZhbHVlOiBwX3Rva2VuLFxuXHQvLyBcdFx0XHRcdGxhYmVsOiBgJHtnX3Rva2VuLmJlY2gzMn0gJHtnX3Rva2VuLnN5bWJvbH0gJHtnX3Rva2VuLm5hbWV9YCxcblx0Ly8gXHRcdFx0fSk7XG5cdC8vIFx0XHR9XG5cdC8vIFx0fVxuXHQvLyB9XG5cblx0Ly8gY29uc3QgYV90b2tlbnMgPSBvZGVyYWYoSF9UT0tFTlMsIChfLCBrX3Rva2VuKSA9PiB7XG5cdC8vIFx0Y29uc3Qga19jaGFpbiA9IEhfQ0hBSU5TW2tfdG9rZW4uZGVmLmNoYWluUmVmXTtcblxuXHQvLyBcdGlmKHNpX2NoYWluID09PSBrX2NoYWluLmRlZi5pZCkge1xuXHQvLyBcdFx0cmV0dXJuIFt7XG5cdC8vIFx0XHRcdHZhbHVlOiBrX3Rva2VuLmRlZi5pcmksXG5cdC8vIFx0XHRcdGxhYmVsOiBgJHtrX3Rva2VuLmRlZi5hZGRyZXNzfSAke2tfdG9rZW4uZGVmLnN5bWJvbH0gJHtrX3Rva2VuLmRlZi5sYWJlbH1gLFxuXHQvLyBcdFx0XHRwcmltYXJ5OiBrX3Rva2VuLmRlZi5zeW1ib2wsXG5cdC8vIFx0XHRcdHNlY29uZGFyeToga190b2tlbi5kZWYubGFiZWwsXG5cdC8vIFx0XHRcdHRva2VuOiBrX3Rva2VuLFxuXHQvLyBcdFx0fV07XG5cdC8vIFx0fVxuXG5cdC8vIFx0cmV0dXJuIFtdO1xuXHQvLyB9KTtcblxuXHQvLyBsZXQgZ190b2tlbl9zZWxlY3QgPSBrX3Rva2VuPyBhX3Rva2Vucy5maW5kKGcgPT4gZy52YWx1ZSA9PT0ga190b2tlbi5kZWYuaXJpKTogdm9pZCAwO1xuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiYXNzZXRcIj5cblx0eyNhd2FpdCBsb2FkX2Fzc2V0cygpfVxuXHRcdExvYWRpbmcgYXNzZXRzLi4uXG5cdHs6dGhlbiBhX2Fzc2V0c31cblx0XHQ8U3RhclNlbGVjdCBpZD1cImFzc2V0LXNlbGVjdFwiXG5cdFx0XHRwZnBNYXA9e2hfYXNzZXRfcGZwc31cblx0XHRcdHBsYWNlaG9sZGVyPVwiU2VsZWN0IGFzc2V0XCJcblx0XHRcdGl0ZW1zPXthX2Fzc2V0c31cblx0XHRcdGJpbmQ6dmFsdWU9e2dfaXRlbX1cblx0XHQvPlxuXHR7L2F3YWl0fVxuPC9kaXY+IiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIm0xMiA4LTYgNiAxLjQxIDEuNDFMMTIgMTAuODNsNC41OSA0LjU4TDE4IDE0bC02LTZ6XFxcIi8+XFxuPC9zdmc+XCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTE2LjU5IDguNTkgMTIgMTMuMTcgNy40MSA4LjU5IDYgMTBsNiA2IDYtNi0xLjQxLTEuNDF6XFxcIi8+XFxuPC9zdmc+XCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cblx0Ly8gaW1wb3J0IHsgeXdfYXNzZXRfc2VuZCwgeXdfaG9sZGluZ19zZW5kIH0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgU1hfSUNPTl9JTkNSRU1FTlQgZnJvbSAnIy9pY29uL2V4cGFuZF9sZXNzLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9ERUNSRU1FTlQgZnJvbSAnIy9pY29uL2V4cGFuZF9tb3JlLnN2Zz9yYXcnO1xuXHRpbXBvcnQgdHlwZSB7IEVudGl0eSwgRW50aXR5UGF0aCwgTmF0aXZlQ29pbiB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB7IEVudGl0aWVzIH0gZnJvbSAnIy9zdG9yZS9lbnRpdGllcyc7XG5cdGltcG9ydCB7IHl3X2FjY291bnQsIHl3X2NoYWluLCB5d19uZXR3b3JrX2FjdGl2ZSwgeXdfb3duZXIgfSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgeyBYVF9NSU5VVEVTIH0gZnJvbSAnIy9zaGFyZS9jb25zdGFudHMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IGZvcm1hdF9hbW91bnQgfSBmcm9tICcjL3V0aWwvZm9ybWF0Jztcblx0aW1wb3J0IHsgQ29pbkdlY2tvIH0gZnJvbSAnIy9zdG9yZS93ZWItYXBpcyc7XG5cblx0ZXhwb3J0IGxldCB2YWx1ZSA9ICcnO1xuXG5cdGNvbnN0IFlHX1pFUk8gPSBuZXcgQmlnTnVtYmVyKDApO1xuXHRjb25zdCBZR19PTkUgPSBuZXcgQmlnTnVtYmVyKDEpO1xuXG5cdGV4cG9ydCBsZXQgYXNzZXRSZWY6IEVudGl0eVBhdGggfCAnJyA9ICcnO1xuXG5cdC8qKlxuXHQgKiBMZWF2ZSBhIGJ1ZmZlciBmb3IgdGhlIG1heGltdW0gYW1vdW50IHRoYXQgY2FuIGJlIHVzZWRcblx0ICovXG5cdGV4cG9ydCBsZXQgYnVmZmVyTWF4OiBCaWdOdW1iZXIgfCBudW1iZXIgPSAwO1xuXG5cdGxldCBnX2Fzc2V0OiBOYXRpdmVDb2luIHwgbnVsbDtcblxuXHRsZXQgeWdfbWF4OiBCaWdOdW1iZXIgPSBZR19aRVJPO1xuXHRsZXQgeWdfc3RlcDogQmlnTnVtYmVyID0gWUdfWkVSTztcblx0bGV0IHNfZmlhdF9lcXVpdmFsZW50ID0gJyc7XG5cblx0JDoge1xuXHRcdGlmKGFzc2V0UmVmKSB7XG5cdFx0XHR2b2lkIHJlbG9hZF9hc3NldCgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGdfYXNzZXQgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGxldCBzaV9jb2luZ2Vja28gPSAnJztcblx0JDoge1xuXHRcdGlmKHNpX2NvaW5nZWNrbykge1xuXHRcdFx0KGFzeW5jKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBoX3ZlcnN1cyA9IGF3YWl0IENvaW5HZWNrby5jb2luc1ZlcnN1cyhbc2lfY29pbmdlY2tvXSwgJ3VzZCcsIDEqWFRfTUlOVVRFUyk7XG5cdFx0XHRcdGlmKHNpX2NvaW5nZWNrbyBpbiBoX3ZlcnN1cykge1xuXHRcdFx0XHRcdHNfZmlhdF9lcXVpdmFsZW50ID0gZm9ybWF0X2Ftb3VudCgrdmFsdWUgKiAraF92ZXJzdXNbc2lfY29pbmdlY2tvXSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c19maWF0X2VxdWl2YWxlbnQgPSAnKD8pJztcblx0XHRcdFx0fVxuXHRcdFx0fSkoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRzX2ZpYXRfZXF1aXZhbGVudCA9ICcnO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGZ1bmN0aW9uIHJlbG9hZF9hc3NldCgpIHtcblx0XHRzX2ZpYXRfZXF1aXZhbGVudCA9ICdbLi4uXSc7XG5cblx0XHRjb25zdCBnX2VudGl0eSA9IEVudGl0aWVzLnBhcnNlRW50aXR5UGF0aChhc3NldFJlZiBhcyBFbnRpdHlQYXRoKTtcblx0XHRpZignaG9sZGluZycgPT09IGdfZW50aXR5Py50eXBlKSB7XG5cdFx0XHRjb25zdCBzaV9jb2luID0gZ19lbnRpdHkuY29pbjtcblxuXHRcdFx0Z19hc3NldCA9ICR5d19jaGFpbi5jb2luc1tzaV9jb2luXTtcblxuXHRcdFx0Y29uc3QgZ19jYWNoZWQgPSAkeXdfbmV0d29ya19hY3RpdmUuY2FjaGVkQmFsYW5jZSgkeXdfb3duZXIsIHNpX2NvaW4pO1xuXG5cdFx0XHRpZihnX2NhY2hlZCAmJiBnX2NhY2hlZC50aW1lc3RhbXAgPiBEYXRlLm5vdygpIC0gKDUgKiBYVF9NSU5VVEVTKSkge1xuXHRcdFx0XHR5Z19tYXggPSBuZXcgQmlnTnVtYmVyKGdfY2FjaGVkLmRhdGEuYW1vdW50KS5zaGlmdGVkQnkoLWdfYXNzZXQuZGVjaW1hbHMpLm1pbnVzKG5ldyBCaWdOdW1iZXIoYnVmZmVyTWF4KSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGdfYnVuZGxlID0gYXdhaXQgJHl3X25ldHdvcmtfYWN0aXZlLmJhbmtCYWxhbmNlKCR5d19vd25lciwgc2lfY29pbik7XG5cblx0XHRcdC8vIHN0aWxsIG9uIHNhbWUgY29pblxuXHRcdFx0aWYoYXNzZXRSZWYgPT09IGdfYnVuZGxlLmhvbGRpbmcpIHtcblx0XHRcdFx0Y29uc3QgeWdfYW1vdW50ID0gbmV3IEJpZ051bWJlcihnX2J1bmRsZS5iYWxhbmNlLmFtb3VudCkuc2hpZnRlZEJ5KC1nX2Fzc2V0LmRlY2ltYWxzKS5taW51cyhuZXcgQmlnTnVtYmVyKGJ1ZmZlck1heCkpO1xuXHRcdFx0XHRpZigheWdfYW1vdW50LmVxKHlnX21heCkpIHtcblx0XHRcdFx0XHR5Z19tYXggPSB5Z19hbW91bnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBnX2NvaW4gPSAkeXdfY2hhaW4uY29pbnNbc2lfY29pbl07XG5cblx0XHRcdFx0c2lfY29pbmdlY2tvID0gZ19jb2luPy5leHRyYT8uY29pbmdlY2tvX2lkIHx8ICcnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmKCd0b2tlbicgPT09IGdfZW50aXR5Py50eXBlKSB7XG5cdFx0XHQvLyBjb25zdCBoX2ludGVyZmFjZXMgPSBFbnRpdGllcy5pbmZvRm9yVG9rZW4oKTtcblx0XHRcdC8vIC4uLlxuXHRcdFx0Ly8gVE9ETzogaW1wbGVtZW50XG5cdFx0XHRnX2Fzc2V0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZihnX2Fzc2V0KSB7XG5cdFx0XHR5Z19zdGVwID0gWUdfT05FLnNoaWZ0ZWRCeSgtZ19hc3NldC5kZWNpbWFscyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0eWdfc3RlcCA9IFlHX1pFUk87XG5cdFx0XHR5Z19tYXggPSBZR19aRVJPO1xuXHRcdH1cblx0fVxuXG5cblx0Ly8gJDogeGdfYW1vdW50ID0gQmlnSW50KChuZXcgQmlnTnVtYmVyKHZhbHVlKSkuc2hpZnRlZEJ5KCR5d19hc3NldF9zZW5kPy5kZWYuZGVjaW1hbHMgfHwgMCkrJycpO1xuXG5cdC8vICQ6IHlnX3N0ZXAgPSBnX2Fzc2V0PyBZR19PTkUuc2hpZnRlZEJ5KC1nX2Fzc2V0LmRlY2ltYWxzKTogWUdfWkVSTztcblx0Ly8gJDogeWdfbWF4ID0gQ2hhaW5zLlxuXHQvLyBnX2Fzc2V0Py5hbW91bnQoSF9UT0tFTlMpIHx8IFlHX1pFUk87XG5cblx0Ly8gLy8gZml4IHN2ZWx0ZSdzIHN0dXBpZCBtaXN0YWtlIG9mIGNvZXJjaW5nIGlucHV0W3R5cGU9XCJudW1iZXJcIl0gdmFsdWVzIHRvIGVzIG51bWJlcnNcblx0Ly8gJDoge1xuXHQvLyBcdGlmKCdudW1iZXInID09PSB0eXBlb2YgdmFsdWUpIHtcblx0Ly8gXHRcdHZhbHVlID0gZG1faW5wdXQudmFsdWU7XG5cdC8vIFx0fVxuXHQvLyB9XG5cblx0ZnVuY3Rpb24gY2FwdHVyZV9pbnB1dChkX2V2ZW50OiBFdmVudCkge1xuXHRcdHZhbHVlID0gKGRfZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuXHRcdGNvbnN0IHlnX25leHQgPSB5Z19zdGVwLnBsdXModmFsdWUgfHwgMCk7XG5cblx0XHRpZih5Z19uZXh0Lmx0ZSh5Z19tYXgpKSB7XG5cdFx0XHR2YWx1ZSA9IHlnX25leHQrJyc7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFsdWUgPSB5Z19tYXgrJyc7XG5cdFx0fVxuXG5cdFx0Y2hlY2tfdmFsaWRpdHkoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY3JlbWVudCgpIHtcblx0XHRjb25zdCB5Z19uZXh0ID0geWdfc3RlcC5uZWdhdGVkKCkucGx1cyh2YWx1ZSB8fCAwKTtcblx0XHRpZih5Z19uZXh0Lmd0ZSgwKSkge1xuXHRcdFx0aWYoeWdfbmV4dC5ndCh5Z19tYXgpKSB7XG5cdFx0XHRcdHZhbHVlID0geWdfbWF4KycnO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0geWdfbmV4dCsnJztcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2YWx1ZSA9ICcwJztcblx0XHR9XG5cblx0XHRjaGVja192YWxpZGl0eSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9uZ19wcmVzcyhmX2FjdGlvbjogVm9pZEZ1bmN0aW9uKSB7XG5cdFx0bGV0IGlfdGlja2VyID0gMDtcblx0XHRjb25zdCBpX2J1ZmZlciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdGlfdGlja2VyID0gd2luZG93LnNldEludGVydmFsKGZfYWN0aW9uLCA5MCk7XG5cdFx0fSwgMTAwMCk7XG5cblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHtcblx0XHRcdGNsZWFyVGltZW91dChpX2J1ZmZlcik7XG5cdFx0XHRjbGVhckludGVydmFsKGlfdGlja2VyKTtcblx0XHR9LCB7XG5cdFx0XHRvbmNlOiB0cnVlLFxuXHRcdH0pO1xuXHR9XG5cblx0ZXhwb3J0IGxldCBlcnJvciA9ICcnO1xuXHRsZXQgZG1faW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cblx0ZnVuY3Rpb24gaW52YWxpZGF0ZShzX21zZzogc3RyaW5nKSB7XG5cdFx0ZG1faW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoc19tc2cpO1xuXHRcdGVycm9yID0gc19tc2c7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja192YWxpZGl0eSgpIHtcblx0XHRpZighdmFsdWUpIHtcblx0XHRcdHJldHVybiBpbnZhbGlkYXRlKCdFbnRlciBhbiBhbW91bnQnKTtcblx0XHR9XG5cblx0XHRsZXQgeWdfaW5wdXQhOiBCaWdOdW1iZXI7XG5cdFx0dHJ5IHtcblx0XHRcdHlnX2lucHV0ID0gbmV3IEJpZ051bWJlcih2YWx1ZSk7XG5cdFx0fVxuXHRcdGNhdGNoKGVfcGFyc2UpIHtcblx0XHRcdHJldHVybiBpbnZhbGlkYXRlKCdJbnZhbGlkIG51bWJlcicpO1xuXHRcdH1cblxuXHRcdGlmKHlnX2lucHV0Lmx0KFlHX1pFUk8pKSB7XG5cdFx0XHRyZXR1cm4gaW52YWxpZGF0ZSgnVmFsdWUgbXVzdCBiZSBwb3NpdGl2ZScpO1xuXHRcdH1cblxuXHRcdGlmKHlnX2lucHV0Lmd0KHlnX21heCkpIHtcblx0XHRcdHJldHVybiBpbnZhbGlkYXRlKCdJbnN1ZmZpY2llbnQgYmFsYW5jZScpO1xuXHRcdH1cblxuXHRcdGVycm9yID0gJyc7XG5cdH1cblxuXHRleHBvcnQgbGV0IHNob3dWYWxpZGF0aW9uID0gMDtcblx0JDoge1xuXHRcdGlmKHNob3dWYWxpZGF0aW9uKSB7XG5cdFx0XHRjaGVja192YWxpZGl0eSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmKCF2YWx1ZSkge1xuXHRcdFx0ZXJyb3IgPSAnJztcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHRpbnB1dFt0eXBlPVwibnVtYmVyXCJdIHtcblx0XHRhcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XG5cblx0XHQmOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLCAmOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcblx0XHRcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcblx0XHR9XG5cdH1cblxuXHQuYW1vdW50LWlucHV0IHtcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cdH1cblxuXHQub2NjdXB5IHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0cmlnaHQ6IDA7XG5cdFx0dG9wOiAwO1xuXHRcdGhlaWdodDogdmFyKC0tdWktcm93LWhlaWdodCk7XG5cblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cblx0XHQuYWRqdXN0IHtcblxuXHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRcdGdhcDogNHB4O1xuXHRcdFx0bWFyZ2luLXJpZ2h0OiA4cHg7XG5cblx0XHRcdC5pY29uIHtcblx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0XHRwYWRkaW5nOiAwcHggOHB4O1xuXHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDE2cHg7XG5cdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cblx0XHRcdFx0Omdsb2JhbChzdmcpIHtcblx0XHRcdFx0XHR3aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdFx0aGVpZ2h0OiB2YXIoLS1pY29uLWRpYW1ldGVyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC5pbmNyZW1lbnQge1xuXHRcdFx0XHRcdHBhZGRpbmctdG9wOiA0cHg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQuZGVjcmVtZW50IHtcblx0XHRcdFx0XHRwYWRkaW5nLWJvdHRvbTogNHB4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmVxdWl2YWxlbnQge1xuXHRcdFx0LmZvbnQocmVndWxhciwgQHNpemU6IDEzcHgsIEB3ZWlnaHQ6IDMwMCk7XG5cblx0XHRcdC5hbW91bnQge1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHQuZmlhdCB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJhbW91bnQtaW5wdXRcIj5cblx0PGlucHV0XG5cdFx0ZGlzYWJsZWQ9eyFhc3NldFJlZn1cblx0XHR0eXBlPVwibnVtYmVyXCJcblx0XHRtaW49XCIwXCJcblx0XHRtYXg9e3lnX21heCsnJyB8fCAnMCd9XG5cdFx0c3RlcD1cIjAueycwJy5yZXBlYXQoKGdfYXNzZXQ/LmRlY2ltYWxzIHx8IDEpIC0gMSl9MVwiXG5cdFx0cmVxdWlyZWRcblx0XHRvbjpjaGFuZ2U9eygpID0+IGNoZWNrX3ZhbGlkaXR5KCl9XG5cdFx0b246aW5wdXQ9e2NhcHR1cmVfaW5wdXR9XG5cdFx0e3ZhbHVlfVxuXHRcdGJpbmQ6dGhpcz17ZG1faW5wdXR9XG5cdFx0b246aW52YWxpZD17ZCA9PiBkLnByZXZlbnREZWZhdWx0KCl9XG5cdFx0Y2xhc3M6aW52YWxpZD17ZXJyb3J9XG5cdD5cblxuXHR7I2lmIGdfYXNzZXR9XG5cdFx0PHNwYW4gY2xhc3M9XCJvY2N1cHlcIj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiZXF1aXZhbGVudFwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImFtb3VudFwiPlxuXHRcdFx0XHRcdD0ge3NfZmlhdF9lcXVpdmFsZW50fVxuXHRcdFx0XHRcdDwhLS0gIGFtb3VudF90b19maWF0KCt2YWx1ZSwgJHl3X2Fzc2V0X3NlbmQsIHRydWUpIC0tPlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiZmlhdFwiPlxuXHRcdFx0XHRcdFVTRFxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L3NwYW4+XG5cblx0XHRcdDxzcGFuIGNsYXNzPVwiYWRqdXN0XCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvbiBpbmNyZW1lbnQgY2xpY2thYmxlXCJcblx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gaW5jcmVtZW50KCl9XG5cdFx0XHRcdFx0b246bW91c2Vkb3duPXsoKSA9PiBsb25nX3ByZXNzKGluY3JlbWVudCl9XG5cdFx0XHRcdD5cblx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9JTkNSRU1FTlR9XG5cdFx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb24gZGVjcmVtZW50IGNsaWNrYWJsZVwiXG5cdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IGRlY3JlbWVudCgpfVxuXHRcdFx0XHRcdG9uOm1vdXNlZG93bj17KCkgPT4gbG9uZ19wcmVzcyhkZWNyZW1lbnQpfVxuXHRcdFx0XHQ+XG5cdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fREVDUkVNRU5UfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9zcGFuPlxuXHR7L2lmfVxuXG5cdHsjaWYgZXJyb3J9XG5cdFx0PHNwYW4gY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIj5cblx0XHRcdHtlcnJvcn1cblx0XHQ8L3NwYW4+XG5cdHsvaWZ9XG48L2Rpdj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyB5d19hY2NvdW50X3JlZiwgeXdfY2hhaW59IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB0eXBlIHtBY2NvdW50LCBBY2NvdW50UGF0aH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXHRpbXBvcnQgeyBBY2NvdW50cyB9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQgeyBvZGUsIG9kZXJhYyB9IGZyb20gJyMvdXRpbC9iZWx0JztcblxuXG5cdGltcG9ydCBTdGFyU2VsZWN0LCB7IFNlbGVjdE9wdGlvbiB9IGZyb20gJy4vU3RhclNlbGVjdC5zdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgYWNjb3VudFJlZjogQWNjb3VudFBhdGggPSAkeXdfYWNjb3VudF9yZWY7XG5cdC8vIGNvbnN0IHBfYWNjb3VudCA9IGFjY291bnRSZWY7XG5cblxuXHRjb25zdCBta19hY2NvdW50ID0gKHBfYWNjOiBBY2NvdW50UGF0aCwgZ19hY2M6IEFjY291bnRbJ2ludGVyZmFjZSddKSA9PiAoe1xuXHRcdHZhbHVlOiBwX2FjYyxcblx0XHRwcmltYXJ5OiBnX2FjYy5uYW1lLFxuXHRcdHNlY29uZGFyeTogZ19hY2MuZXh0cmE/LnRvdGFsX2ZpYXRfY2FjaGUgfHwgJyg/KScsXG5cdFx0Ly8gc2Vjb25kYXJ5OiBmb3JtYXRfZmlhdChnX2FjYy5ob2xkaW5ncyhIX0hPTERJTkdTLCAkeXdfY2hhaW4pXG5cdFx0XHQvLyAucmVkdWNlKChjX3N1bSwga19ob2xkaW5nKSA9PiBjX3N1bSArIGtfaG9sZGluZy50b1VzZChIX1RPS0VOUywgSF9WRVJTVVNfVVNEKSwgMCkpLFxuXHR9KTtcblxuXHRsZXQgZ19zZWxlY3RlZDogU2VsZWN0T3B0aW9uPEFjY291bnRQYXRoPjsgIC8vID0gbWtfYWNjb3VudCgkeXdfYWNjb3VudF9yZWYsICR5d19hY2NvdW50KTtcblx0bGV0IGFfb3B0aW9uczogdHlwZW9mIGdfc2VsZWN0ZWRbXTtcblxuXHQvLyByZWFjdGl2ZWx5IHVwZGF0ZSB0aGUgZXhwb3J0ZWQgYWNjb3VudCByZWYgYmluZGluZ1xuXHQkOiBpZihnX3NlbGVjdGVkKSB7XG5cdFx0YWNjb3VudFJlZiA9IGdfc2VsZWN0ZWQudmFsdWU7XG5cdH1cblxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX2FjY291bnRzKCkge1xuXHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXG5cdFx0YV9vcHRpb25zID0gb2RlcmFjKGtzX2FjY291bnRzLnJhdywgbWtfYWNjb3VudCk7XG5cdFx0Z19zZWxlY3RlZCA9IGFfb3B0aW9ucy5maW5kKGcgPT4gYWNjb3VudFJlZiA9PT0gZy52YWx1ZSkhO1xuXG5cdFx0cmV0dXJuIGFfb3B0aW9ucztcblx0fVxuPC9zY3JpcHQ+XG5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJ19iYXNlLmxlc3MnO1xuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwic2VuZGVyXCI+XG5cdHsjYXdhaXQgbG9hZF9hY2NvdW50cygpfVxuXHRcdExvYWRpbmcgYWNjb3VudHMuLi5cblx0ezp0aGVuIGFfb3B0aW9uc31cblx0XHQ8U3RhclNlbGVjdCBpZD1cInNlbmRlci1zZWxlY3RcIlxuXHRcdFx0cGxhY2Vob2xkZXI9XCJTZWxlY3QgYWNjb3VudFwiXG5cdFx0XHRzZWNvbmRhcnlDbGFzcz0nYmFsYW5jZSdcblx0XHRcdGl0ZW1zPXthX29wdGlvbnN9XG5cdFx0XHRiaW5kOnZhbHVlPXtnX3NlbGVjdGVkfVxuXHRcdC8+XG5cdHsvYXdhaXR9XG48L2Rpdj4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIiBsYW5nPVwidHNcIj5cblx0ZXhwb3J0IGludGVyZmFjZSBDb250YWN0T3B0aW9uIHtcblx0XHR2YWx1ZTogQ2hhaW4uQmVjaDMyU3RyaW5nO1xuXHRcdGxhYmVsOiBzdHJpbmc7XG5cdFx0Y29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ107XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge3l3X2NoYWluLCB5d19mYW1pbHl9IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgdHlwZSB7IENvbnRhY3QsIENvbnRhY3RQYXRoIH0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXHRpbXBvcnQgeyBBZ2VudHMgfSBmcm9tICcjL3N0b3JlL2FnZW50cyc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgc3Vic2NyaWJlX3N0b3JlIH0gZnJvbSAnIy9zdG9yZS9fYmFzZSc7XG5cdGltcG9ydCB7IG9uRGVzdHJveSB9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBQZnBEaXNwbGF5IGZyb20gJy4vUGZwRGlzcGxheS5zdmVsdGUnO1xuXG5cdC8qKlxuXHQgKiBSZXNvdXJjZSBwYXRoIHRvIHRoZSBjb250YWN0XG5cdCAqL1xuXHRleHBvcnQgbGV0IGNvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddIHwgbnVsbCA9IG51bGw7XG5cdGxldCBnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddID0gY29udGFjdCE7XG5cblx0LyoqXG5cdCAqIE1hbnVhbGx5IGVudGVyZWQgYWRkcmVzc1xuXHQgKi9cblx0ZXhwb3J0IGxldCBhZGRyZXNzOiBDaGFpbi5CZWNoMzJTdHJpbmcgPSAnJztcblxuXHQvLyAvLyByZXNvbHZlZCBjb250YWN0XG5cdC8vIGxldCBnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddO1xuXG5cdC8vIGxvYWQgY29udGFjdCBkZWYgZnJvbSBzdG9yZVxuXHRhc3luYyBmdW5jdGlvbiByZWxvYWRfY29udGFjdHMoKSB7XG5cdFx0Ly8gbG9hZCBhZ2VudHMgc3RvcmVcblx0XHRjb25zdCBrc19hZ2VudHMgPSBhd2FpdCBBZ2VudHMucmVhZCgpO1xuXG5cdFx0Ly8gY29udGFjdCBpdGVyYXRvclxuXHRcdGNvbnN0IGRpX2NvbnRhY3RzID0ga3NfYWdlbnRzLmNvbnRhY3RzKCR5d19mYW1pbHkpO1xuLy8gZGVidWdnZXI7XG4vLyBcdFx0Ly8gY29udGFjdCBpcyBwcmVzZW50XG4vLyBcdFx0aWYoZ19jb250YWN0KSB7XG4vLyBcdFx0XHQvLyBlYWNoIGNvbnRhY3Rcbi8vIFx0XHRcdGZvcihjb25zdCBbcF9jb250YWN0X2VhY2gsIGdfY29udGFjdF9lYWNoXSBvZiBkaV9jb250YWN0cykge1xuLy8gXHRcdFx0XHQvLyBmb3VuZCBtYXRjaFxuLy8gXHRcdFx0XHRpZihwX2NvbnRhY3QgPT09IHBfY29udGFjdF9lYWNoKSB7XG4vLyBcdFx0XHRcdFx0Z19jb250YWN0ID0gZ19jb250YWN0X2VhY2g7XG4vLyBcdFx0XHRcdFx0YnJlYWs7XG4vLyBcdFx0XHRcdH1cbi8vIFx0XHRcdH1cbi8vIFx0XHR9XG5cdFx0Ly8gb25seSBhZGRyZXNzIHdhcyBnaXZlblxuXHRcdGlmKCFnX2NvbnRhY3QgJiYgYWRkcmVzcykge1xuXHRcdFx0Ly8gZWFjaCBjb250YWN0XG5cdFx0XHRmb3IoY29uc3QgWywgZ19jb250YWN0X2VhY2hdIG9mIGRpX2NvbnRhY3RzKSB7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIGFkZHJlc3MgZXhpc3RzIGluIGNvbnRhY3RzLCBmb3VuZCBtYXRjaFxuXHRcdFx0XHRpZihhZGRyZXNzID09PSBDaGFpbnMuYmVjaDMyKGdfY29udGFjdF9lYWNoLmFkZHJlc3MpKSB7XG5cdFx0XHRcdFx0Z19jb250YWN0ID0gZ19jb250YWN0X2VhY2g7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2b2lkIHJlbG9hZF9jb250YWN0cygpO1xuXHRjb25zdCBmX3Vuc3ViX2FnZW50cyA9IHN1YnNjcmliZV9zdG9yZSgnYWdlbnRzJywgcmVsb2FkX2NvbnRhY3RzKTtcblx0b25EZXN0cm95KCgpID0+IHtcblx0XHRmX3Vuc3ViX2FnZW50cygpO1xuXHR9KTtcblxuXG5cdC8vIGV4cG9ydCBsZXQgZ19pdGVtOiB7XG5cdC8vIFx0Y29udGFjdDogQ29udGFjdDtcblx0Ly8gXHRpc0dyb3VwSGVhZGVyPzogYm9vbGVhbjtcblx0Ly8gXHRpc0dyb3VwSXRlbT86IGJvb2xlYW47XG5cdC8vIFx0aXNDcmVhdG9yPzogYm9vbGVhbjtcblx0Ly8gfSB8IHVuZGVmaW5lZCA9IHZvaWQgMDtcblxuXHQ8L3NjcmlwdD5cblx0XG5cdDxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcdEBpbXBvcnQgJ19iYXNlLmxlc3MnO1xuXHRcblx0XHQuY29udGFjdCB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0ZmxleC1kaXJlY3Rpb246IHJvdztcblx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFxuXHRcdFx0Ly8gcGFkZGluZy10b3A6IDNweDtcblx0XHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7O1xuXHRcblx0XHRcdD4uY29udGFjdC1wZnAge1xuXHRcdFx0XHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0XHRcdFx0LS1wcm94eS1pY29uLWRpYW1ldGVyOiAyNnB4O1xuXHRcdFx0XHRsaW5lLWhlaWdodDogMjZweDtcblx0XHRcdFx0bWFyZ2luLXJpZ2h0OiA2cHg7XG5cdFxuXHRcdFx0XHQ+Lmljb24ge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0Ym9yZGVyLXJhZGl1czogMjAlO1xuXHRcdFx0XHRcdFx0ZGlzcGxheTogaW5saW5lLWZsZXg7XG5cdFx0XHRcdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Lmljb24tZG9tIHtcblx0XHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0XHRoZWlnaHQ6IHVuc2V0O1xuXHRcdFx0XHRcdFx0XHRmb250LXNpemU6IDE0cHg7IFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdD4uaW5mbyB7XG5cdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0XHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0XHRcdG1heC13aWR0aDogMTcycHg7XG5cdFxuXHRcdFx0XHQ+Lm5hbWUge1xuXHRcdFx0XHRcdGxpbmUtaGVpZ2h0OiAxLjJlbTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Pi5hZGRyZXNzIHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdC8vIC5mb250KG1vbm8tdGlueSk7XG5cdFx0XHRcdFx0XHRsaW5lLWhlaWdodDogMS4yZW07XG5cdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vID4qIHtcblx0XHRcdC8vIFx0Omdsb2JhbCgmKSB7XG5cdFx0XHQvLyBcdFx0dmVydGljYWwtYWxpZ246IG1pZGRsZTtcblx0XHRcdC8vIFx0fVxuXHRcdFx0Ly8gfVxuXHRcdH1cblx0XG5cdFx0Lm1hbnVhbCB7XG5cdFx0XHQuYWRkcmVzcyB7XG5cdFx0XHRcdHdpZHRoOiBjYWxjKDEwMCUgLSAzLjVjaCk7XG5cdFx0XHR9XG5cdFx0fVxuXHQ8L3N0eWxlPlxuXHRcblx0eyNpZiBnX2NvbnRhY3R9XG5cdFx0PGRpdiBjbGFzcz1cImNvbnRhY3RcIj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiY29udGFjdC1wZnBcIj5cblx0XHRcdFx0eyNpZiBnX2NvbnRhY3R9XG5cdFx0XHRcdFx0PFBmcERpc3BsYXkgZGltPXsyOH0gcmVzb3VyY2U9e2dfY29udGFjdH0gZ2VuU3R5bGU9J2ZvbnQtc2l6ZToxOHB4OycgLz5cblx0XHRcdFx0ey9pZn1cblx0XHRcdDwvc3Bhbj5cblx0XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0e2dfY29udGFjdC5uYW1lfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFxuXHRcdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXtDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKX0gLz5cblx0XHRcdDwvc3Bhbj5cblx0XHQ8L2Rpdj5cblx0ezplbHNlIGlmIGFkZHJlc3N9XG5cdFx0PHNwYW4gY2xhc3M9XCJtYW51YWxcIj5cblx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9e2FkZHJlc3N9IC8+XG5cdFx0PC9zcGFuPlxuXHR7OmVsc2V9XG5cdFx0PHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+XG5cdFx0XHRGYWlsZWQgdG8gbG9jYXRlIGNvbnRhY3Rcblx0XHQ8L3NwYW4+XG5cdHsvaWZ9IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBDaGFpbiB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cblx0aW1wb3J0IHR5cGUgeyBDb250YWN0UGF0aH0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXG5cdGltcG9ydCBJbmxpbmVDb250YWN0U2VsZWN0aW9uLCB7IENvbnRhY3RPcHRpb24gfSBmcm9tICcuL0lubGluZUNvbnRhY3RTZWxlY3Rpb24uc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IGlzQWN0aXZlID0gZmFsc2U7XG5cdGV4cG9ydCBsZXQgaXNGaXJzdCA9IGZhbHNlO1xuXHRleHBvcnQgbGV0IGlzSG92ZXIgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBpc1NlbGVjdGFibGUgPSBmYWxzZTtcblx0ZXhwb3J0IGxldCBnZXRPcHRpb25MYWJlbCA9IHZvaWQgMDtcblx0ZXhwb3J0IGxldCBpdGVtOiBDb250YWN0T3B0aW9uO1xuXHQvLyBcdGlzR3JvdXBIZWFkZXI/OiBib29sZWFuO1xuXHQvLyBcdGlzR3JvdXBJdGVtPzogYm9vbGVhbjtcblx0Ly8gfTtcblx0ZXhwb3J0IGxldCBmaWx0ZXJUZXh0ID0gJyc7XG5cblx0bGV0IGl0ZW1DbGFzc2VzID0gJyc7XG5cblx0JDoge1xuXHRcdGNvbnN0IGNsYXNzZXM6IHN0cmluZ1tdID0gW107XG5cdFx0aWYoaXNBY3RpdmUpIHtcblx0XHRcdGNsYXNzZXMucHVzaCgnYWN0aXZlJyk7XG5cdFx0fVxuXHRcblx0XHRpZihpc0ZpcnN0KSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2ZpcnN0Jyk7XG5cdFx0fVxuXHRcblx0XHRpZihpc0hvdmVyKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ2hvdmVyJyk7XG5cdFx0fVxuXHRcblx0XHQvLyBpZihpdGVtLmlzR3JvdXBIZWFkZXIpIHtcblx0XHQvLyBcdGNsYXNzZXMucHVzaCgnZ3JvdXBIZWFkZXInKTtcblx0XHQvLyB9XG5cdFxuXHRcdC8vIGlmKGl0ZW0uaXNHcm91cEl0ZW0pIHtcblx0XHQvLyBcdGNsYXNzZXMucHVzaCgnZ3JvdXBJdGVtJyk7XG5cdFx0Ly8gfVxuXHRcblx0XHRpZighaXNTZWxlY3RhYmxlKSB7XG5cdFx0XHRjbGFzc2VzLnB1c2goJ25vdFNlbGVjdGFibGUnKTtcblx0XHR9XG5cdFxuXHRcdGl0ZW1DbGFzc2VzID0gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0Lml0ZW0ge1xuXHRcdGN1cnNvcjogZGVmYXVsdDtcblx0XHRoZWlnaHQ6IHZhcigtLWhlaWdodCwgNDJweCk7XG5cdFx0bGluZS1oZWlnaHQ6IHZhcigtLWhlaWdodCwgNDJweCk7XG5cdFx0cGFkZGluZzogdmFyKC0taXRlbVBhZGRpbmcsIDAgMjBweCk7XG5cdFx0Y29sb3I6IHZhcigtLWl0ZW1Db2xvciwgaW5oZXJpdCk7XG5cdFx0dGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdHBhZGRpbmctbGVmdDogOHB4O1xuXHR9XG5cblx0Lmdyb3VwSGVhZGVyIHtcblx0XHR0ZXh0LXRyYW5zZm9ybTogdmFyKC0tZ3JvdXBUaXRsZVRleHRUcmFuc2Zvcm0sIHVwcGVyY2FzZSk7XG5cdH1cblxuXHQuZ3JvdXBJdGVtIHtcblx0XHRwYWRkaW5nLWxlZnQ6IHZhcigtLWdyb3VwSXRlbVBhZGRpbmdMZWZ0LCA0MHB4KTtcblx0fVxuXG5cdC5pdGVtOmFjdGl2ZSB7XG5cdFx0YmFja2dyb3VuZDogdmFyKC0taXRlbUFjdGl2ZUJhY2tncm91bmQsICNiOWRhZmYpO1xuXHR9XG5cblx0Lml0ZW0uYWN0aXZlIHtcblx0XHRiYWNrZ3JvdW5kOiB2YXIoLS1pdGVtSXNBY3RpdmVCRywgIzAwN2FmZik7XG5cdFx0Y29sb3I6IHZhcigtLWl0ZW1Jc0FjdGl2ZUNvbG9yLCAjZmZmKTtcblx0fVxuXG5cdC5pdGVtLm5vdFNlbGVjdGFibGUge1xuXHRcdGNvbG9yOiB2YXIoLS1pdGVtSXNOb3RTZWxlY3RhYmxlQ29sb3IsICM5OTkpO1xuXHR9XG5cblx0Lml0ZW0uZmlyc3Qge1xuXHRcdGJvcmRlci1yYWRpdXM6IHZhcigtLWl0ZW1GaXJzdEJvcmRlclJhZGl1cywgNHB4IDRweCAwIDApO1xuXHR9XG5cblx0Lml0ZW0uaG92ZXI6bm90KC5hY3RpdmUpIHtcblx0XHRiYWNrZ3JvdW5kOiB2YXIoLS1pdGVtSG92ZXJCRywgI2U3ZjJmZik7XG5cdFx0Y29sb3I6IHZhcigtLWl0ZW1Ib3ZlckNvbG9yLCBpbmhlcml0KTtcblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwiaXRlbSB7aXRlbUNsYXNzZXN9XCIgY2xhc3M6ZGlzcGxheV9ub25lPXtpc0FjdGl2ZSB8fCAhaXRlbS52YWx1ZX0+XG5cdDxJbmxpbmVDb250YWN0U2VsZWN0aW9uIGNvbnRhY3Q9e2l0ZW0uY29udGFjdH0gYWRkcmVzcz17aXRlbS52YWx1ZX0gLz5cbjwvZGl2PlxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBDaGFpbiB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cblx0aW1wb3J0IHR5cGUgeyBDb250YWN0UGF0aH0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXG5cdGltcG9ydCBJbmxpbmVDb250YWN0U2VsZWN0aW9uLCB7IENvbnRhY3RPcHRpb24gfSBmcm9tICcuL0lubGluZUNvbnRhY3RTZWxlY3Rpb24uc3ZlbHRlJztcblxuXHRleHBvcnQgbGV0IGdldFNlbGVjdGlvbkxhYmVsO1xuXHRleHBvcnQgbGV0IGl0ZW06IENvbnRhY3RPcHRpb247XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5zZWxlY3Rpb24ge1xuXHRcdHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzO1xuXHRcdG92ZXJmbG93LXg6IGhpZGRlbjtcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRwYWRkaW5nLWxlZnQ6IDhweDtcblxuXHRcdC5tYW51YWw+LmFkZHJlc3Mge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdHdpZHRoOiBjYWxjKDEwMCUgLSAzLjVjaCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG5cbjxkaXYgY2xhc3M9XCJzZWxlY3Rpb25cIj5cblx0PElubGluZUNvbnRhY3RTZWxlY3Rpb24gY29udGFjdD17aXRlbS5jb250YWN0fSBhZGRyZXNzPXtpdGVtLnZhbHVlfSAvPlxuPC9kaXY+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHt5d19hY2NvdW50LCB5d19jaGFpbiwgeXdfZmFtaWx5LCB5d19oZWxwfSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCBSZWNpcGllbnRTZWxlY3RJdGVtIGZyb20gJy4vUmVjaXBpZW50U2VsZWN0SXRlbS5zdmVsdGUnO1xuXG5cdGltcG9ydCBTZWxlY3QgZnJvbSAnc3ZlbHRlLXNlbGVjdCc7XG5cdGltcG9ydCBTWF9JQ09OX1NDQU4gZnJvbSAnIy9pY29uL3FyX2NvZGVfc2Nhbm5lci5zdmc/cmF3Jztcblx0aW1wb3J0IFJlY2lwaWVudFNlbGVjdFNlbGVjdGlvbiBmcm9tICcuL1JlY2lwaWVudFNlbGVjdFNlbGVjdGlvbi5zdmVsdGUnO1xuXHRpbXBvcnQge29kZXJhY30gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQge29uTW91bnR9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7ZGQsIHFzfSBmcm9tICcjL3V0aWwvZG9tJztcblx0aW1wb3J0IHR5cGUge0FnZW50UGF0aCwgQ2hhaW59IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdCB9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHsgQWdlbnRzIH0gZnJvbSAnIy9zdG9yZS9hZ2VudHMnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB0eXBlIHsgQ29udGFjdE9wdGlvbiB9IGZyb20gJy4vSW5saW5lQ29udGFjdFNlbGVjdGlvbi5zdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgYWRkcmVzczogQ2hhaW4uQmVjaDMyU3RyaW5nID0gJyc7XG5cdGNvbnN0IHNhX2lucHV0ID0gYWRkcmVzcztcblxuXHRleHBvcnQgbGV0IGVycm9yID0gJyc7XG5cblx0bGV0IHNfbWFudWFsX2lucHV0OiBzdHJpbmc7XG5cdGxldCBnX2l0ZW1fc2VsZWN0OiBDb250YWN0T3B0aW9uO1xuXG5cdGxldCBhX2NvbnRhY3RzOiBbQWdlbnRQYXRoLCBDb250YWN0WydpbnRlcmZhY2UnXV1bXTtcblxuXHRjb25zdCBjb250YWN0X3RvX29wdGlvbiA9IChnOiBDb250YWN0WydpbnRlcmZhY2UnXSk6IENvbnRhY3RPcHRpb24gPT4gKHtcblx0XHR2YWx1ZTogQ2hhaW5zLmJlY2gzMihnLmFkZHJlc3MpLFxuXHRcdGxhYmVsOiBnLm5hbWUsXG5cdFx0Y29udGFjdDogZyxcblx0fSk7XG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9jb250YWN0cygpOiBQcm9taXNlPENvbnRhY3RPcHRpb25bXT4ge1xuXHRcdGNvbnN0IGtzX2FnZW50cyA9IGF3YWl0IEFnZW50cy5yZWFkKCk7XG5cblx0XHRjb25zdCBhX29wdGlvbnM6IENvbnRhY3RPcHRpb25bXSA9IFt7XG5cdFx0XHR2YWx1ZTogJycsXG5cdFx0XHRsYWJlbDogJycsXG5cdFx0XHRjb250YWN0OiBudWxsISxcblx0XHR9XTtcblxuXHRcdGFfY29udGFjdHMgPSBbLi4ua3NfYWdlbnRzLmNvbnRhY3RzKCR5d19mYW1pbHkpXTtcblx0XHRmb3IoY29uc3QgWywgZ19jb250YWN0XSBvZiBhX2NvbnRhY3RzKSB7XG5cdFx0XHRjb25zdCBnX29wdGlvbiA9IGNvbnRhY3RfdG9fb3B0aW9uKGdfY29udGFjdCk7XG5cblx0XHRcdGNvbnN0IHNhX2NvbnRhY3QgPSBDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKTtcblx0XHRcdGlmKHNhX2lucHV0ICYmIHNhX2NvbnRhY3QgPT09IHNhX2lucHV0KSB7XG5cdFx0XHRcdGdfaXRlbV9zZWxlY3QgPSBnX29wdGlvbjtcblx0XHRcdH1cblxuXHRcdFx0YV9vcHRpb25zLnB1c2goZ19vcHRpb24pO1xuXHRcdH1cblxuXHRcdHJldHVybiBhX29wdGlvbnM7XG5cdH1cblxuXHRmdW5jdGlvbiBzZWxlY3QoZF9ldmVudDogQ3VzdG9tRXZlbnQ8Q29udGFjdE9wdGlvbj4pIHtcblx0XHRhZGRyZXNzID0gZF9ldmVudC5kZXRhaWwudmFsdWU7XG5cdFx0ZXJyb3IgPSAnJztcblx0fVxuXG5cdGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRcdGFkZHJlc3MgPSAnJztcblx0fVxuXG5cdGxldCBzX2FjY2VwdGVkX2lucHV0ID0gJyc7XG5cdGxldCBiX2hpZGVfY3Vyc29yID0gZmFsc2U7XG5cblx0bGV0IGJfbGlzdF9vcGVuID0gZmFsc2U7XG5cblx0JDoge1xuXHRcdGJfaGlkZV9jdXJzb3IgPSBmYWxzZTtcblxuXHRcdGlmKHNfbWFudWFsX2lucHV0KSB7XG5cdFx0XHRjaGVja19tYW51YWxfaW5wdXQoKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRiX2hpZGVfY3Vyc29yID0gISFzX2FjY2VwdGVkX2lucHV0O1xuXHRcdFx0c19hY2NlcHRlZF9pbnB1dCA9ICcnO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrX21hbnVhbF9pbnB1dCgpIHtcblx0XHRzX2FjY2VwdGVkX2lucHV0ID0gJyc7XG5cblx0XHRpZighJHl3X2NoYWluKSB7XG5cdFx0XHQvLyBzaG91bGQgbm90IGJlIGFibGUgdG8gZ2V0IGhlcmUgd2l0aG91dCBiZWluZyBvbiBhIGNoYWluXG5cdFx0XHRlcnJvciA9ICdObyBjaGFpbiBzZXQnO1xuXHRcdH1cblx0XHRlbHNlIGlmKCFDaGFpbnMuaXNWYWxpZEFkZHJlc3NGb3IoJHl3X2NoYWluLCBzX21hbnVhbF9pbnB1dCwgJ2FjYycpKSB7XG5cdFx0XHRlcnJvciA9ICdJbnZhbGlkIGFkZHJlc3MgZm9yIHRoaXMgY2hhaW4nO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGVycm9yID0gJyc7XG5cblx0XHRcdC8vIHNlYXJjaCBmb3IgYWRkcmVzcyBpbiBjb250YWN0c1xuXHRcdFx0Zm9yKGNvbnN0IFssIGdfY29udGFjdF0gb2YgYV9jb250YWN0cykge1xuXHRcdFx0XHQvLyBjb250YWN0IGV4aXN0c1xuXHRcdFx0XHRpZihzX21hbnVhbF9pbnB1dCA9PT0gQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcykpIHtcblx0XHRcdFx0XHQvLyBjbGVhciBmaWx0ZXIgdGV4dFxuXHRcdFx0XHRcdHNfbWFudWFsX2lucHV0ID0gJyc7XG5cdFxuXHRcdFx0XHRcdC8vIHNlbGVjdCBjb250YWN0IGluc3RlYWQgb2YgdXNpbmcgcmF3IGFkZHJlc3Ncblx0XHRcdFx0XHRnX2l0ZW1fc2VsZWN0ID0gY29udGFjdF90b19vcHRpb24oZ19jb250YWN0KTtcblxuXHRcdFx0XHRcdC8vIGNsb3NlIGxpc3Rcblx0XHRcdFx0XHRiX2xpc3Rfb3BlbiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gaGlkZSBjdXJzb3Jcblx0XHRcdFx0XHRiX2hpZGVfY3Vyc29yID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c19hY2NlcHRlZF9pbnB1dCA9IHNfbWFudWFsX2lucHV0O1xuXG5cdFx0XHQvLyBzZWxlY3QgYWRkcmVzcyBpbW1lZGlhdGVseVxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdChxcyhkbV9zZW5kZXIsICcubWFudWFsPi5hZGRyZXNzJykgYXMgSFRNTEVsZW1lbnQpLmNsaWNrKCk7XG5cdFx0XHRcdGJfbGlzdF9vcGVuID0gZmFsc2U7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdH1cblxuXHRsZXQgZG1fc2VuZGVyOiBIVE1MRWxlbWVudDtcblx0XG5cdGV4cG9ydCBsZXQgc2hvd1ZhbGlkYXRpb24gPSAwO1xuXHQkOiB7XG5cdFx0aWYoc2hvd1ZhbGlkYXRpb24pIHtcblx0XHRcdGlmKCFhZGRyZXNzKSB7XG5cdFx0XHRcdGlmKHNfbWFudWFsX2lucHV0KSB7XG5cdFx0XHRcdFx0Y2hlY2tfbWFudWFsX2lucHV0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSAnRW50ZXIgYSByZWNpcGllbnQnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKCFDaGFpbnMuaXNWYWxpZEFkZHJlc3NGb3IoJHl3X2NoYWluLCBhZGRyZXNzLCAnYWNjJykpIHtcblx0XHRcdFx0ZXJyb3IgPSAnSW52YWxpZCBhZGRyZXNzIGZvciB0aGlzIGNoYWluJztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRlcnJvciA9ICcnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmKCFhZGRyZXNzKSB7XG5cdFx0XHRlcnJvciA9ICcnO1xuXHRcdH1cblx0fVxuPC9zY3JpcHQ+XG5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJ19iYXNlLmxlc3MnO1xuXG5cdC5zZW5kZXIge1xuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblxuXHRcdC5zdHlsZS1zdmVsdGUtc2VsZWN0KCk7XG5cdFx0LmZvbnQocmVndWxhciwgNDAwLCAxM3B4KTtcblxuXHRcdC0taW5wdXRQYWRkaW5nOiAxNnB4O1xuXHRcdC0tcGFkZGluZzogMCA0cHg7XG5cdFx0LS1pdGVtUGFkZGluZzogMDtcblx0XHQtLXNlbGVjdGVkSXRlbVBhZGRpbmc6IDA7XG5cblx0XHQ+aW5wdXQge1xuXHRcdFx0Jjo6YWZ0ZXIge1xuXHRcdFx0XHRjb250ZW50OiAnJztcblx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHRyaWdodDogMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQ+Lmljb24ge1xuXHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdHJpZ2h0OiAwO1xuXHRcdFx0cGFkZGluZzogMTJweDtcblx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblx0XHR9XG5cblx0XHQubGlzdENvbnRhaW5lciAuZW1wdHkge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQmLmhpZGUtY3Vyc29yIHtcblx0XHRcdC5zZWxlY3RDb250YWluZXIgaW5wdXRbdHlwZT1cInRleHRcIl0ge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG5cbjxkaXYgY2xhc3M9XCJzZW5kZXJcIiBiaW5kOnRoaXM9e2RtX3NlbmRlcn0gY2xhc3M6aGlkZS1jdXJzb3I9e2JfaGlkZV9jdXJzb3J9PlxuXHR7I2F3YWl0IGxvYWRfY29udGFjdHMoKX1cblx0XHRMb2FkaW5nIGNvbnRhY3RzLi4uXG5cdHs6dGhlbiBhX2NvbnRhY3RzfVxuXHRcdDxTZWxlY3QgaWQ9XCJyZWNpcGllbnQtc2VsZWN0XCJcblx0XHRcdHBsYWNlaG9sZGVyPVwiQWRkcmVzcyBvciBjb250YWN0XCJcblx0XHRcdGxpc3RPZmZzZXQ9ezF9XG5cdFx0XHRpc0NsZWFyYWJsZT17ISFhZGRyZXNzfVxuXHRcdFx0aXNDcmVhdGFibGU9eyEhc19hY2NlcHRlZF9pbnB1dH1cblx0XHRcdEl0ZW09e1JlY2lwaWVudFNlbGVjdEl0ZW19XG5cdFx0XHRTZWxlY3Rpb249e1JlY2lwaWVudFNlbGVjdFNlbGVjdGlvbn1cblx0XHRcdGl0ZW1zPXthX2NvbnRhY3RzfVxuXHRcdFx0dmFsdWU9e2dfaXRlbV9zZWxlY3R9XG5cdFx0XHRub09wdGlvbnNNZXNzYWdlPXsnU3RvcCB0eXBpbmcgaW4gdGhlIGFkZHJlc3MuIFxcbiBVc2UgY29weS9wYXN0ZSBpbnN0ZWFkISd9XG5cdFx0XHRiaW5kOmZpbHRlclRleHQ9e3NfbWFudWFsX2lucHV0fVxuXHRcdFx0YmluZDpsaXN0T3Blbj17Yl9saXN0X29wZW59XG5cdFx0XHRvbjpzZWxlY3Q9e3NlbGVjdH1cblx0XHRcdG9uOmNsZWFyPXtjbGVhcn1cblx0XHRcdGNvbnRhaW5lckNsYXNzZXM9e2Vycm9yPyAnaW52YWxpZCc6ICcnfVxuXHRcdC8+XG5cdHsvYXdhaXR9XG5cblxuPCEtLSBcblx0PHNwYW4gY2xhc3M9XCJpY29uXCIgY2xhc3M6dmlzaWJpbGl0eV9oaWRkZW49eyEhYWRkcmVzc30gb246Y2xpY2s9eygpID0+IHtcblx0XHQkeXdfaGVscCA9IFtcblx0XHRcdGRkKCdicicpLFxuXHRcdFx0ZGQoJ3AnLCB7fSwgW2BObyBRUiBjb2RlIHNjYW5uZXIgaW4gTVZQLiBCdXQgeW91IGNhbiB0cnkgY29weWluZyB0aGUgYWRkcmVzcyB0ZXh0IGJ5IHVzaW5nIHlvdXIgZGV2aWNlJ3MgYnVpbHQtaW4gY2FtZXJhIGFwcC5gXSksXG5cdFx0XHRkZCgnYnInKSxcblx0XHRcdGRkKCdicicpLFxuXHRcdF07XG5cdH19PlxuXHRcdHtAaHRtbCBTWF9JQ09OX1NDQU59XG5cdDwvc3Bhbj4gLS0+XG5cblx0eyNpZiBlcnJvcn1cblx0XHQ8c3BhbiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiPlxuXHRcdFx0e2Vycm9yfVxuXHRcdDwvc3Bhbj5cblx0ey9pZn1cbjwvZGl2PiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiIGxhbmc9XCJ0c1wiPlxuXG48L3NjcmlwdD5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBBY2NvdW50LCBBY2NvdW50UGF0aCB9IGZyb20gXCIjL21ldGEvYWNjb3VudFwiO1xuXHRpbXBvcnQgdHlwZSB7IEJlY2gzMiB9IGZyb20gXCIjL21ldGEvY2hhaW5cIjtcblx0aW1wb3J0IHR5cGUgeyBDb250YWN0IH0gZnJvbSBcIiMvbWV0YS9jb250YWN0XCI7XG5cdGltcG9ydCB7IEFjY291bnRzIH0gZnJvbSBcIiMvc3RvcmUvYWNjb3VudHNcIjtcblx0aW1wb3J0IHsgQWdlbnRzIH0gZnJvbSBcIiMvc3RvcmUvYWdlbnRzXCI7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gXCIjL3N0b3JlL2NoYWluc1wiO1xuXHRpbXBvcnQgeyBFdmVudHMgfSBmcm9tIFwiIy9zdG9yZS9ldmVudHNcIjtcblx0aW1wb3J0IHsgQ29pbkdlY2tvIH0gZnJvbSBcIiMvc3RvcmUvd2ViLWFwaXNcIjtcblx0aW1wb3J0IHsgZm9ybWF0X2ZpYXQgfSBmcm9tIFwiIy91dGlsL2Zvcm1hdFwiO1xuXHRpbXBvcnQgQmlnTnVtYmVyIGZyb20gXCJiaWdudW1iZXIuanNcIjtcblxuXHRpbXBvcnQgeyBnZXRDb250ZXh0LCBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyBUaHJlYWRJZCB9IGZyb20gXCIuLi9kZWZcIjtcblx0aW1wb3J0IHsgeXdfY2hhaW4sIHl3X25hdmlnYXRvciwgeXdfbmV0d29ya19hY3RpdmUgfSBmcm9tIFwiLi4vbWVtXCI7XG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tIFwiLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlXCI7XG5cdGltcG9ydCBBZGRyZXNzIGZyb20gXCIuLi91aS9BZGRyZXNzLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgRmllbGQgZnJvbSBcIi4uL3VpL0ZpZWxkLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgeyBTY3JlZW4sIEhlYWRlciwgdHlwZSBQYWdlIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8qKlxuXHQgKiBOYXRpdmUgY29pbiBpZFxuXHQgKi9cblx0ZXhwb3J0IGxldCBjb2luOiBzdHJpbmc7XG5cdGNvbnN0IHNpX2NvaW4gPSBjb2luO1xuXG5cdGNvbnN0IGdfY29pbiA9ICR5d19jaGFpbi5jb2luc1tzaV9jb2luXTtcblxuXHRleHBvcnQgbGV0IGFjY291bnRSZWY6IEFjY291bnRQYXRoO1xuXHRsZXQgZ19hY2NvdW50OiBBY2NvdW50WydpbnRlcmZhY2UnXTtcblx0bGV0IHNhX3NlbmRlcjogQmVjaDMyLlN0cmluZztcblxuXHRleHBvcnQgbGV0IGFtb3VudDogc3RyaW5nO1xuXHRjb25zdCBzX2Ftb3VudCA9IGFtb3VudDtcblxuXHRleHBvcnQgbGV0IHJlY2lwaWVudDogQmVjaDMyLlN0cmluZztcblx0Y29uc3Qgc2FfcmVjaXBpZW50ID0gcmVjaXBpZW50O1xuXG5cdGxldCBzX3JlY2lwaWVudF90aXRsZSA9ICcnO1xuXG5cdGxldCBnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddIHwgbnVsbDtcblxuXHRleHBvcnQgbGV0IGZlZTogc3RyaW5nO1xuXHRjb25zdCBzX2ZlZSA9IGZlZTtcblxuXHQkOiBzX3RvdGFsID0gbmV3IEJpZ051bWJlcihzX2Ftb3VudCkucGx1cyhmZWUpLnRvU3RyaW5nKCk7XG5cblx0ZXhwb3J0IGxldCBtZW1vOiBzdHJpbmc7XG5cblx0bGV0IHhfd29ydGggPSAwO1xuXG5cdChhc3luYyhma19yZXNvbHZlKSA9PiB7XG5cdFx0Y29uc3Qgc2lfY29pbmdlY2tvID0gZ19jb2luLmV4dHJhPy5jb2luZ2Vja29faWQgfHwgJyc7XG5cblx0XHRpZihzaV9jb2luZ2Vja28pIHtcblx0XHRcdGNvbnN0IGhfdmVyc3VzID0gYXdhaXQgQ29pbkdlY2tvLmNvaW5zVmVyc3VzKFtzaV9jb2luZ2Vja29dLCAndXNkJywgMCk7XG5cdFx0XHR4X3dvcnRoID0gaF92ZXJzdXNbc2lfY29pbmdlY2tvXTtcblx0XHR9XG5cdH0pKCk7XG5cblx0KGFzeW5jKCkgPT4ge1xuXHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXG5cdFx0Z19hY2NvdW50ID0ga3NfYWNjb3VudHMuYXQoYWNjb3VudFJlZikhO1xuXHRcdHNhX3NlbmRlciA9IENoYWlucy5hZGRyZXNzRm9yKGdfYWNjb3VudC5wdWJrZXkpO1xuXG5cdFx0Y29uc3QgcF9jb250YWN0ID0gQWdlbnRzLnBhdGhGb3JDb250YWN0KHNhX3JlY2lwaWVudCk7XG5cdFx0Z19jb250YWN0ID0gYXdhaXQgQWdlbnRzLmdldENvbnRhY3QocF9jb250YWN0KTtcblxuXHRcdHNfcmVjaXBpZW50X3RpdGxlID0gZ19jb250YWN0Py5uYW1lIHx8ICcnO1xuXHR9KSgpO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGFwcHJvdmUoKSB7XG5cdFx0Y29uc3QgeGdfYW1vdW50ID0gQmlnSW50KG5ldyBCaWdOdW1iZXIoc19hbW91bnQpLnNoaWZ0ZWRCeShnX2NvaW4uZGVjaW1hbHMpLnRvU3RyaW5nKCkpO1xuXG5cdFx0Y29uc3QgZ19hdHRlbXB0ID0gYXdhaXQgJHl3X25ldHdvcmtfYWN0aXZlLmJhbmtTZW5kKHNhX3NlbmRlciwgc2FfcmVjaXBpZW50LCBzaV9jb2luLCB4Z19hbW91bnQsIG1lbW8pO1xuXG5cdFx0Ly8gcHJlcGVuZCBwZW5kaW5nIGV2ZW50IHRvIGV2ZW50cyBzdG9yZVxuXHRcdGF3YWl0IEV2ZW50cy5pbnNlcnQoe1xuXHRcdFx0dHlwZTogJ3BlbmRpbmcnLFxuXHRcdFx0dGltZTogRGF0ZS5ub3coKSxcblx0XHRcdGRhdGE6IGdfYXR0ZW1wdCxcblx0XHR9KTtcblxuXHRcdC8vIHJlc2V0IHBhZ2Vcblx0XHRrX3BhZ2UucmVzZXQoKTtcblxuXHRcdC8vIGFjdGl2YXRlIGhpc3RvcnkgdGhyZWFkXG5cdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKFRocmVhZElkLkhJU1RPUlkpO1xuXHR9XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQudGl0bGUge1xuXG5cdH1cblxuXHQuc3VidGl0bGUge1xuXHRcdC5mb250KHRpbnkpO1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdH1cblxuXHQuZW1wdHktbWVtbyB7XG5cdFx0LmZvbnQodGlueSk7XG5cdFx0Zm9udC1zdHlsZTogaXRhbGljO1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdH1cbjwvc3R5bGU+XG5cbjxTY3JlZW4gZGVidWc9J1NlbmROYXRpdmUnIHNsaWRlcz5cblx0PEhlYWRlciBwb3BzIGV4aXRzXG5cdFx0b246Y2xvc2U9eygpID0+IGtfcGFnZS5yZXNldCgpfVxuXHRcdHRpdGxlPSdTZW5kaW5nJ1xuXHRcdHN5bWJvbD17c2lfY29pbn1cblx0XHRzdWJ0aXRsZT17JHl3X2NoYWluLm5hbWV9XG5cdC8+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdzZW5kZXInXG5cdFx0bmFtZT0nRnJvbSdcblx0PlxuXHRcdDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxuXHRcdFx0e2dfYWNjb3VudD8ubmFtZSB8fCAnWy4uLl0nfVxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0XHR7Z19hY2NvdW50Py5leHRyYT8udG90YWxfZmlhdF9jYWNoZSB8fCAnKD8pJ31cblx0XHQ8L2Rpdj5cblx0PC9GaWVsZD5cblxuXHQ8aHI+XG5cblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdyZWNpcGllbnQnXG5cdFx0bmFtZT0nVG8nXG5cdD5cblx0XHQ8ZGl2IGNsYXNzPVwidGl0bGVcIj5cblx0XHRcdHtzX3JlY2lwaWVudF90aXRsZSB8fCAnWy4uLl0nfVxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXtzYV9yZWNpcGllbnR9IC8+XG5cdFx0PC9kaXY+XG5cdDwvRmllbGQ+XG5cblx0PGhyPlxuXG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0nYW1vdW50J1xuXHRcdG5hbWU9J0Ftb3VudCdcblx0PlxuXHRcdDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlxuXHRcdFx0e3NfYW1vdW50fSB7c2lfY29pbn1cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0eyNpZiB4X3dvcnRofVxuXHRcdFx0XHR7Zm9ybWF0X2ZpYXQobmV3IEJpZ051bWJlcihzX2Ftb3VudCkudGltZXMoeF93b3J0aCkudG9OdW1iZXIoKSl9XG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdD1bLi4uXVxuXHRcdFx0ey9pZn1cblx0XHQ8L2Rpdj5cblx0PC9GaWVsZD5cblxuXHQ8aHI+XG5cdFxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2ZlZS1yZXZpZXcnXG5cdFx0bmFtZT0nRmVlJ1xuXHQ+XG5cdFx0PGRpdiBjbGFzcz1cInRpdGxlXCI+XG5cdFx0XHR7c19mZWV9IHtzaV9jb2lufVxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0XHR7I2lmIHhfd29ydGh9XG5cdFx0XHRcdHtmb3JtYXRfZmlhdChuZXcgQmlnTnVtYmVyKHNfZmVlKS50aW1lcyh4X3dvcnRoKS50b051bWJlcigpKX1cblx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0PVsuLi5dXG5cdFx0XHR7L2lmfVxuXHRcdDwvZGl2PlxuXHQ8L0ZpZWxkPlxuXG5cdDxocj5cblx0XG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0ndG90YWwnXG5cdFx0bmFtZT0nVG90YWwnXG5cdD5cblx0XHQ8ZGl2IGNsYXNzPVwidGl0bGVcIj5cblx0XHRcdHtzX3RvdGFsIHx8ICdbLi4uXSd9IHtzaV9jb2lufVxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+XG5cdFx0XHR7I2lmIHhfd29ydGh9XG5cdFx0XHRcdHtmb3JtYXRfZmlhdChuZXcgQmlnTnVtYmVyKHNfdG90YWwpLnRpbWVzKHhfd29ydGgpLnRvTnVtYmVyKCkpfVxuXHRcdFx0ezplbHNlfVxuXHRcdFx0XHQ9Wy4uLl1cblx0XHRcdHsvaWZ9XG5cdFx0PC9kaXY+XG5cdDwvRmllbGQ+XG5cblx0PGhyPlxuXHRcblx0PEZpZWxkIHNob3J0XG5cdFx0a2V5PSdtZW1vJ1xuXHRcdG5hbWU9J01lbW8nXG5cdD5cblx0XHR7I2lmIG1lbW99XG5cdFx0XHQ8dGV4dGFyZWEgZGlzYWJsZWQ+e21lbW99PC90ZXh0YXJlYT5cblx0XHR7OmVsc2V9XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImVtcHR5LW1lbW9cIj4oZW1wdHkpPC9zcGFuPlxuXHRcdHsvaWZ9XG5cdDwvRmllbGQ+XG5cblxuXHQ8QWN0aW9uc0xpbmUgYmFjayBjb25maXJtPXtbJ0FwcHJvdmUnLCAoKSA9PiBhcHByb3ZlKCldfSAvPlxuXG48L1NjcmVlbj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGdldENvbnRleHQsIG9uRGVzdHJveSB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IHNsaWRlIH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXG5cdGltcG9ydCB7XG5cdFx0eXdfYWNjb3VudCxcblx0XHR5d19hY2NvdW50X3JlZixcblx0XHR5d19jaGFpbixcblx0XHR5d19jaGFpbl9yZWYsXG5cdFx0eXdfbmV0d29ya19hY3RpdmUsXG5cdFx0eXdfb3duZXIsXG5cdFx0eXdfc2VuZF9hc3NldCxcblx0XHQvLyB5d19hc3NldF9zZW5kLFxuXHRcdC8vIHl3X2hvbGRpbmdfc2VuZCxcblx0fSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCBTWF9JQ09OX1BFUlNPTkFMIGZyb20gJyMvaWNvbi9hY2NvdW50X2JveC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ09OVFJBQ1QgZnJvbSAnIy9pY29uL2FuYWx5dGljcy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fTE9BRElORyBmcm9tICcjL2ljb24vZG9udXRfbGFyZ2Uuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0lORk8gZnJvbSAnIy9pY29uL2luZm8uc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0RST1BET1dOIGZyb20gJyMvaWNvbi9kcm9wLWRvd24uc3ZnP3Jhdyc7XG5cblx0aW1wb3J0IEFzc2V0U2VsZWN0IGZyb20gJyMjL3VpL0Fzc2V0U2VsZWN0LnN2ZWx0ZSc7XG5cdGltcG9ydCBBbW91bnRJbnB1dCBmcm9tICcjIy91aS9BbW91bnRJbnB1dC5zdmVsdGUnO1xuXHRpbXBvcnQgQ2hlY2tib3hGaWVsZCBmcm9tICcjIy91aS9DaGVja2JveEZpZWxkLnN2ZWx0ZSc7XG5cdGltcG9ydCBIZWFkZXIgZnJvbSAnIyMvdWkvSGVhZGVyLnN2ZWx0ZSc7XG5cdGltcG9ydCBGaWVsZCBmcm9tICcjIy91aS9GaWVsZC5zdmVsdGUnO1xuXG5cdC8vIGltcG9ydCBFeGVjdXRlIGZyb20gJy4vRXhlY3V0ZS5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IEFjY291bnQsIEFjY291bnRQYXRoIH0gZnJvbSAnIy9tZXRhL2FjY291bnQnO1xuXG5cdGltcG9ydCB7IFNjcmVlbiwgdHlwZSBQYWdlIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cdGltcG9ydCB0eXBlIHsgVG9rZW4gfSBmcm9tICcjL21ldGEvdG9rZW4nO1xuXHRpbXBvcnQgeyBFbnRpdGllcyB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgU2VuZGVyU2VsZWN0IGZyb20gJy4uL3VpL1NlbmRlclNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgUmVjaXBpZW50U2VsZWN0IGZyb20gJy4uL3VpL1JlY2lwaWVudFNlbGVjdC5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IENoYWluLCBFbnRpdHlQYXRoLCBOYXRpdmVDb2luIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IHR5cGUgeyBDb250YWN0LCBDb250YWN0UGF0aCB9IGZyb20gJyMvbWV0YS9jb250YWN0Jztcblx0aW1wb3J0IHsgc3Vic2NyaWJlX3N0b3JlIH0gZnJvbSAnIy9zdG9yZS9fYmFzZSc7XG5cdGltcG9ydCB7IEFnZW50cyB9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHsgZm9sZCwgb2ZlIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IENvaW5HZWNrbyB9IGZyb20gJyMvc3RvcmUvd2ViLWFwaXMnO1xuXHRpbXBvcnQgeyBmb3JtYXRfYW1vdW50LCBmb3JtYXRfZmlhdCB9IGZyb20gJyMvdXRpbC9mb3JtYXQnO1xuXHRpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cdGltcG9ydCB7IFhUX01JTlVURVMgfSBmcm9tICcjL3NoYXJlL2NvbnN0YW50cyc7XG5cdGltcG9ydCBBY3Rpb25zTGluZSBmcm9tICcuLi91aS9BY3Rpb25zTGluZS5zdmVsdGUnO1xuaW1wb3J0IFNlbmROYXRpdmUgZnJvbSAnLi9TZW5kTmF0aXZlLnN2ZWx0ZSc7XG5cblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0LyoqXG5cdCAqIFdoaWNoIGFjY291bnQgdG8gaW5pdGlhdGUgc2VuZCBmcm9tXG5cdCAqL1xuXHRleHBvcnQgbGV0IHNlbmRlcjogQWNjb3VudFsnaW50ZXJmYWNlJ10gPSAkeXdfYWNjb3VudDtcblx0bGV0IHBfYWNjb3VudDogQWNjb3VudFBhdGggPSAkeXdfYWNjb3VudF9yZWY7XG5cblx0LyoqXG5cdCAqIE5hdGl2ZSBjb2luIHN5bWJvbCB0byB1c2UgZm9yIHRoZSB0cmFuc2ZlclxuXHQgKi9cblx0ZXhwb3J0IGxldCBuYXRpdmU6IGtleW9mIHR5cGVvZiAkeXdfY2hhaW4uY29pbnMgPSBPYmplY3Qua2V5cygkeXdfY2hhaW4uY29pbnMpWzBdO1xuXHRsZXQgc2lfbmF0aXZlID0gbmF0aXZlO1xuXG5cdC8qKlxuXHQgKiBUb2tlbiB0byB1c2UgZm9yIHRyYW5zZmVyIChpbnN0ZWFkIG9mIG5hdGl2ZSBjb2luKVxuXHQgKi9cblx0ZXhwb3J0IGxldCB0b2tlbjogVG9rZW5bJ2ludGVyZmFjZSddIHwgbnVsbCA9IG51bGw7XG5cdGxldCBnX3Rva2VuID0gdG9rZW47XG5cblxuXHQvKipcblx0ICogQWRkcmVzcyBvZiBpbml0aWFsIHJlY2VpdmVyXG5cdCAqL1xuXHRleHBvcnQgbGV0IHJlY2lwaWVudCA9ICcnO1xuXHRsZXQgc2FfcmVjaXBpZW50ID0gcmVjaXBpZW50O1xuXG5cblx0bGV0IHBfYXNzZXQ6IEVudGl0eVBhdGggfCAnJyA9IHNpX25hdGl2ZVxuXHRcdD8gRW50aXRpZXMuaG9sZGluZ1BhdGhGb3IoJHl3X293bmVyLCBzaV9uYXRpdmUpXG5cdFx0OiAnJztcblx0XHQvLyA6IEVudGl0aWVzLnBhdGhGcm9tKGdfdG9rZW4pO1xuXG5cblx0Ly8gcmVhY3RpdmVseSBhc3NpZ24gdGhlIGNvaW4gc3RydWN0IGZvciB0aGUgbmF0aXZlIGFzc2V0XG5cdCQ6IGdfY29pbiA9IHBfYXNzZXQgJiYgJ2hvbGRpbmcnID09PSBFbnRpdGllcy5wYXJzZUVudGl0eVBhdGgocF9hc3NldCk/LnR5cGUgJiYgc2lfbmF0aXZlPyAkeXdfY2hhaW4uY29pbnM/LltzaV9uYXRpdmVdOiBudWxsO1xuXHRcblx0Ly8gcmVhY3RpdmVseSBhc3NpZ24gdGhlIHRva2VuJ3MgcGF0aFxuXHQkOiBwX3Rva2VuID0gcF9hc3NldCAmJiAndG9rZW4nID09PSBFbnRpdGllcy5wYXJzZUVudGl0eVBhdGgocF9hc3NldCk/LnR5cGUgJiYgZ190b2tlbj8gRW50aXRpZXMucGF0aEZyb20oZ190b2tlbik6ICcnO1xuXG5cblx0Ly8gY2FjaGUgb2YgY29udGFjdHNcblx0bGV0IGhfY29udGFjdHM6IFJlY29yZDxDb250YWN0UGF0aCwgQ29udGFjdFsnaW50ZXJmYWNlJ10+O1xuXG5cdC8vIGFkZHJlc3MgdG8gY29udGFjdCBsb29rdXAgY2FjaGVcblx0bGV0IGhfYWRkcl90b19jb250YWN0OiBSZWNvcmQ8Q2hhaW4uQmVjaDMyU3RyaW5nLCBDb250YWN0UGF0aD47XG5cblx0Ly8gYXNzZXQgc3ltYm9sXG5cdCQ6IHNfc3ltYm9sID0gc2lfbmF0aXZlIHx8IGdfdG9rZW4/LnN5bWJvbCB8fCAnJztcblxuXG5cblxuXHRsZXQgYl9idXN5X2FnZW50cyA9IGZhbHNlO1xuXHRhc3luYyBmdW5jdGlvbiByZWxvYWRfYWdlbnRzKGJfaW5pdD1mYWxzZSkge1xuXHRcdC8vIGFscmVhZHkgYnVzeSByZWxvYWRpbmdcblx0XHRpZihiX2J1c3lfYWdlbnRzKSByZXR1cm47XG5cblx0XHQvLyBub3cgaXQncyBidXN5XG5cdFx0Yl9idXN5X2FnZW50cyA9IHRydWU7XG5cblx0XHQvLyBsb2FkIGFnZW50cyBzdG9yZVxuXHRcdGNvbnN0IGtzX2FnZW50cyA9IGF3YWl0IEFnZW50cy5yZWFkKCk7XG5cblx0XHQvLyByZWFkIGNvbnRhY3QgZW50cmllc1xuXHRcdGNvbnN0IGFfY29udGFjdHMgPSBbLi4ua3NfYWdlbnRzLmNvbnRhY3RzKCldO1xuXG5cdFx0Ly8gcmVwbGFjZSBjYWNoZVxuXHRcdGhfY29udGFjdHMgPSBvZmUoYV9jb250YWN0cyk7XG5cblx0XHQvLyByZXBsYWNlIGFkZHJlc3MgbG9va3VwIGNhY2hlXG5cdFx0aF9hZGRyX3RvX2NvbnRhY3QgPSBmb2xkKGFfY29udGFjdHMsIChbcF9jb250YWN0LCBnX2NvbnRhY3RdKSA9PiAoe1xuXHRcdFx0W0NoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MpXTogcF9jb250YWN0LFxuXHRcdH0pKTtcblxuXHRcdC8vIG5vIGxvbmdlciBidXN5XG5cdFx0Yl9idXN5X2FnZW50cyA9IGZhbHNlO1xuXHR9XG5cblx0Ly8gc3Vic2NyaXB0aW9uc1xuXHR7XG5cdFx0Ly8gcmVsb2FkIGFnZW50cyB3aGVuIGFnZW50cyBzdG9yZSB1cGRhdGVzXG5cdFx0Y29uc3QgZl91bnN1Yl9hZ2VudHMgPSBzdWJzY3JpYmVfc3RvcmUoJ2FnZW50cycsIHJlbG9hZF9hZ2VudHMpO1xuXG5cdFx0Ly8gcmVsb2FkIGFnZW50cyB3aGVuIGNoYWluIGNoYW5nZXNcblx0XHRjb25zdCBmX3Vuc3ViX2NoYWluID0geXdfY2hhaW4uc3Vic2NyaWJlKHJlbG9hZF9hZ2VudHMgYXMgVm9pZEZ1bmN0aW9uKTtcblxuXHRcdC8vIHVuc3Vic2NyaWJlIHdoZW4gc2NyZWVuIGlzIGRlc3Ryb3llZFxuXHRcdG9uRGVzdHJveSgoKSA9PiB7XG5cdFx0XHRmX3Vuc3ViX2FnZW50cygpO1xuXHRcdFx0Zl91bnN1Yl9jaGFpbigpO1xuXHRcdH0pO1xuXHR9XG5cblx0JDoge1xuXHRcdGNvbnNvbGUubG9nKHtcblx0XHRcdHNpX25hdGl2ZSxcblx0XHRcdGdfY29pbixcblx0XHRcdHBfYXNzZXQsXG5cdFx0XHRwX3Rva2VuLFxuXHRcdFx0Z190b2tlbixcblx0XHR9KTtcblx0fVxuXG5cdC8vIHJlYWN0aXZlbHkgY29tcHV0ZSB0aGUgYmFsYW5jZSBvZiB0aGUgc2VsZWN0ZWQgYXNzZXRcblx0bGV0IHlnX2JhbGFuY2U6IEJpZ051bWJlciB8IG51bGwgPSBudWxsO1xuXHQkOiBzX2JhbGFuY2UgPSB5Z19iYWxhbmNlPyBmb3JtYXRfYW1vdW50KHlnX2JhbGFuY2Uuc2hpZnRlZEJ5KC0oZ19jb2luIHx8IGdfdG9rZW4pIS5kZWNpbWFscykudG9OdW1iZXIoKSk6ICcnO1xuXHQkOiB7XG5cdFx0Ly8gcmVhY3QgdG8gYWNjb3VudCBhbmQgYXNzZXQgY2hhbmdlc1xuXHRcdGlmKCR5d19hY2NvdW50ICYmIHBfYXNzZXQpIHtcblx0XHRcdHlnX2JhbGFuY2UgPSBudWxsO1xuXG5cdFx0XHQvLyBnbyBhc3luY1xuXHRcdFx0cXVldWVNaWNyb3Rhc2soYXN5bmMoKSA9PiB7XG5cdFx0XHRcdC8vIGluZGljYXRlIGxvYWRpbmcgc3RhdGVcblx0XHRcdFx0c19iYWxhbmNlID0gJ1suLi5dJztcblxuXHRcdFx0XHQvLyBzdGFydCB3aXRoIHRoZSBjYWNoZWQgYmFsYW5jZSBpZiBpdCBleGlzdHNcblx0XHRcdFx0Y29uc3QgZ19jYWNoZWQgPSAkeXdfbmV0d29ya19hY3RpdmUuY2FjaGVkQmFsYW5jZSgkeXdfb3duZXIsIHNpX25hdGl2ZSk7XG5cdFx0XHRcdGlmKGdfY2FjaGVkICYmIGdfY2FjaGVkLnRpbWVzdGFtcCA+IERhdGUubm93KCkgLSAoNSAqIFhUX01JTlVURVMpKSB7XG5cdFx0XHRcdFx0eWdfYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoZ19jYWNoZWQuZGF0YS5hbW91bnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZ2V0IHRoZSBsYXRlc3QgYmFsYW5jZVxuXHRcdFx0XHRjb25zdCBnX2J1bmRsZSA9IGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5iYW5rQmFsYW5jZSgkeXdfb3duZXIsIHNpX25hdGl2ZSk7XG5cdFx0XHRcdGlmKGdfYnVuZGxlKSB7XG5cdFx0XHRcdFx0eWdfYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoZ19idW5kbGUuYmFsYW5jZS5hbW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXG5cdC8vIGlucHV0IGFtb3VudCB1c2VyIGludGVuZHMgdG8gc2VuZFxuXHRsZXQgc19hbW91bnQgPSAnJztcblxuXHQvLyBhcHBseSB0aGUgbWF4aW11bSBhbW91bnQgdGhlIHVzZXIgY2FuIHBvc3NpYmx5IHNlbmRcblx0ZnVuY3Rpb24gdXNlX21heCgpIHtcblx0XHRzX2Ftb3VudCA9IHNfYmFsYW5jZTtcblxuXHRcdC8vIHRha2UgYXdheSBmcm9tIGdhcyBmZWVcblx0XHRpZihnX2NvaW4pIHtcblx0XHRcdHNfYW1vdW50ID0gbmV3IEJpZ051bWJlcihzX2Ftb3VudCkubWludXMoeF9mZWUpLnRvU3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0Y19zaG93X3ZhbGlkYXRpb25zKys7XG5cdH1cblxuXHQvLyByZWFjdGl2ZWx5IGluZGljYXRlIHdoZXRoZXIgdGhlIG1heCBpcyBjdXJyZW50bHkgYmVpbmcgdXNlZFxuXHQkOiBiX3VzaW5nX21heCA9IHNfYW1vdW50ID09PSBzX2JhbGFuY2U7XG5cblx0Ly8gJDoge1xuXHQvLyBcdGlmKGdfdG9rZW4gJiYgRW50aXRpZXMucGF0aEZyb20oZ190bykgIT09IHBfZW50aXR5KSB7XG5cdC8vIFx0XHRzX2Ftb3VudCA9ICcnO1xuXHQvLyBcdFx0Y19zaG93X3ZhbGlkYXRpb25zID0gMDtcblx0Ly8gXHRcdHBfZW50aXR5ID0gZ190b2tlbi5pcmk7XG5cdC8vIFx0fVxuXHQvLyB9XG5cblxuXG5cdC8vIHJlYWN0aXZlbHkgYXNzaWduIHRoZSBjb2luZ2Vja28gaWQgZnJvbSB0aGUgYXNzZXQgc3RydWN0XG5cdCQ6IHNpX2NvaW5nZWNrbyA9IChnX3Rva2VuIHx8IGdfY29pbik/LmV4dHJhPy5jb2luZ2Vja29faWQgfHwgJyc7XG5cblx0Ly8gcmVhY3RpdmVseSBmZXRjaCB0aGUgd29ydGggb2YgdGhlIGFzc2V0XG5cdGxldCB4X3dvcnRoOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblx0bGV0IHNfd29ydGggPSAnJztcblx0Y29uc3Qgc2lfdmVyc3VzID0gJ3VzZCc7XG5cdCQ6IHtcblx0XHQvLyBjb2luZ2Vja28gaWQgaXMgc2V0XG5cdFx0aWYoc2lfY29pbmdlY2tvKSB7XG5cdFx0XHQvLyBpbmRpY2F0ZSBsb2FkaW5nIHN0YXRlXG5cdFx0XHRzX3dvcnRoID0gJ1suLi5dJztcblxuXHRcdFx0Ly8gZ28gYXN5bmNcblx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0Ly8gbG9hZCB0aGUgYXNzZXQncyB3b3J0aCBmcm9tIGNvaW5nZWNrb1xuXHRcdFx0XHRjb25zdCBoX3ZlcnN1cyA9IGF3YWl0IENvaW5HZWNrby5jb2luc1ZlcnN1cyhbc2lfY29pbmdlY2tvXSBhcyBzdHJpbmdbXSwgc2lfdmVyc3VzKTtcblxuXHRcdFx0XHQvLyB1cGRhdGUgdGhlIGZpYXQgZGlzcGxheVxuXHRcdFx0XHR4X3dvcnRoID0gaF92ZXJzdXNbc2lfY29pbmdlY2tvXTtcblx0XHRcdFx0aWYoJ251bWJlcicgPT09IHR5cGVvZiB4X3dvcnRoKSB7XG5cdFx0XHRcdFx0c193b3J0aCA9IGZvcm1hdF9maWF0KHhfd29ydGgsIHNpX3ZlcnN1cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc2V0IGVycm9yIGluZGljYXRpb25cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0c193b3J0aCA9ICcoPyknO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSgpO1xuXHRcdH1cblx0XHQvLyBkb24ndCBkaXNwbGF5IGFueXRoaW5nXG5cdFx0ZWxzZSB7XG5cdFx0XHRzX3dvcnRoID0gJyc7XG5cdFx0fVxuXHR9XG5cblxuXHRsZXQgeF9mZWUgPSAwLjAxO1xuXHRcblx0JDogc19mZWVfZmlhdCA9ICdudW1iZXInID09PSB0eXBlb2YgeF93b3J0aD8gZm9ybWF0X2ZpYXQoeF9mZWUgKiB4X3dvcnRoLCAndXNkJyk6ICcnO1xuXG5cdFxuXHRcblx0Ly8gLy8gXG5cdC8vIGlmKCR5d19hc3NldF9zZW5kKSB7XG5cdC8vIFx0JHl3X2NoYWluX3JlZiA9ICR5d19hc3NldF9zZW5kLmNoYWluUmVmO1xuXHQvLyB9XG5cblx0Y29uc3QgSF9BRERSRVNTX1RZUEVTID0ge1xuXHRcdG5vbmU6IHtcblx0XHRcdGljb246ICc8c3ZnPjwvc3ZnPicsXG5cdFx0XHR0ZXh0OiAnJyxcblx0XHR9LFxuXG5cdFx0dW5rbm93bjoge1xuXHRcdFx0aWNvbjogU1hfSUNPTl9MT0FESU5HLFxuXHRcdFx0dGV4dDogJ0RldGVybWluaW5nIGFkZHJlc3MgdHlwZS4uLicsXG5cdFx0fSxcblxuXHRcdHBlcnNvbmFsOiB7XG5cdFx0XHRpY29uOiBTWF9JQ09OX1BFUlNPTkFMLFxuXHRcdFx0dGV4dDogJ1BlcnNvbmFsIGFkZHJlc3MnLFxuXHRcdH0sXG5cblx0XHRjb250cmFjdDoge1xuXHRcdFx0aWNvbjogU1hfSUNPTl9DT05UUkFDVCxcblx0XHRcdHRleHQ6ICdDb250cmFjdCBhZGRyZXNzJyxcblx0XHR9LFxuXHR9IGFzIGNvbnN0O1xuXG5cdGxldCBzaV9hZGRyZXNzX3R5cGU6IGtleW9mIHR5cGVvZiBIX0FERFJFU1NfVFlQRVMgPSAnbm9uZSc7XG5cdCQ6IGdfYWRkcmVzc190eXBlID0gSF9BRERSRVNTX1RZUEVTW3NpX2FkZHJlc3NfdHlwZV07XG5cblxuXG5cdCQ6IHtcblx0XHRpZighc2FfcmVjaXBpZW50KSB7XG5cdFx0XHRzaV9hZGRyZXNzX3R5cGUgPSAnbm9uZSc7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2lfYWRkcmVzc190eXBlID0gJ3Vua25vd24nO1xuXG5cdFx0XHQoYXN5bmMoKSA9PiB7XG5cdFx0XHRcdGlmKGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5pc0NvbnRyYWN0KHNhX3JlY2lwaWVudCkpIHtcblx0XHRcdFx0XHRzaV9hZGRyZXNzX3R5cGUgPSAnY29udHJhY3QnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHNpX2FkZHJlc3NfdHlwZSA9ICdwZXJzb25hbCc7XG5cdFx0XHRcdH1cblx0XHRcdH0pKCk7XG5cdFx0fVxuXHR9XG5cblxuXG5cblx0bGV0IGJfbWVtb19leHBhbmRlZCA9IGZhbHNlO1xuXHRsZXQgc19tZW1vID0gJyc7XG5cblx0bGV0IGJfc3VibWl0dGVkID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gc3VibWl0KCkge1xuXHRcdGlmKCFiX2Zvcm1fdmFsaWQpIHtcblx0XHRcdGNfc2hvd192YWxpZGF0aW9ucysrO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmKGJfc3VibWl0dGVkKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdGJfc3VibWl0dGVkID0gdHJ1ZTtcblxuXHRcdFx0aWYoc2lfbmF0aXZlKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBTZW5kTmF0aXZlLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRhY2NvdW50UmVmOiBwX2FjY291bnQsXG5cdFx0XHRcdFx0XHRjb2luOiBzaV9uYXRpdmUsXG5cdFx0XHRcdFx0XHRyZWNpcGllbnQ6IHNhX3JlY2lwaWVudCxcblx0XHRcdFx0XHRcdGFtb3VudDogc19hbW91bnQsXG5cdFx0XHRcdFx0XHRtZW1vOiBzX21lbW8sXG5cdFx0XHRcdFx0XHRmZWU6IHhfZmVlKycnLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIGtfcGFnZS5wdXN5d19zZW5kX2Fzc2V0XG5cdFx0XHRcdC8vIFx0Y3JlYXRvcjogRXhlY3V0ZSxcblx0XHRcdFx0Ly8gXHRwcm9wczoge1xuXHRcdFx0XHQvLyBcdFx0Y29udHJhY3Q6ICR5d19hc3NldF9zZW5kPy5hZGRyZXNzLFxuXHRcdFx0XHQvLyBcdFx0c25pcDIwOiB5d19zZW5kX2Fzc2V0XG5cdFx0XHRcdC8vIFx0XHRcdHRyYW5zZmVyOiB7XG5cdFx0XHRcdC8vIFx0XHRcdFx0cmVjaXBpZW50OiBzYV9yZWNlaXZlcixcblx0XHRcdFx0Ly8gXHRcdFx0XHRhbW91bnQ6ICR5d19hc3NldF9zZW5kPy5kZW5vbUZyb21TdHJpbmcoc19hbW91bnQpIHx8ICcwJyxcblx0XHRcdFx0Ly8gXHRcdFx0fSxcblx0XHRcdFx0Ly8gXHRcdH0sXG5cdFx0XHRcdC8vIFx0fSxcblx0XHRcdFx0Ly8gfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bGV0IGNfc2hvd192YWxpZGF0aW9ucyA9IDA7XG5cblx0bGV0IGJfY2hlY2tlZF9zYXZlX2NvbnRhY3QgPSBmYWxzZTtcblx0bGV0IGJfZGVhZCA9IGZhbHNlO1xuXG5cblx0bGV0IHNfZXJyX3JlY2lwaWVudCA9ICcnO1xuXHRsZXQgc19lcnJfYW1vdW50ID0gJyc7XG5cblx0JDogYl9uZXdfYWRkcmVzcyA9IHNhX3JlY2lwaWVudCAmJiBoX2FkZHJfdG9fY29udGFjdCAmJiAhKHNhX3JlY2lwaWVudCBpbiBoX2FkZHJfdG9fY29udGFjdCk7XG5cblxuXHRjb25zdCBSX0NPTlRBQ1RfTkFNRSA9IC9eXFxTLnswLDEwMjN9JC87XG5cdFxuXHRsZXQgc19uZXdfY29udGFjdCA9ICcnO1xuXHQkOiBzX2Vycl9uZXdfY29udGFjdCA9IGJfY2hlY2tlZF9zYXZlX2NvbnRhY3QgJiYgKGNfc2hvd192YWxpZGF0aW9ucyB8fCB0cnVlKVxuXHRcdD8gc19uZXdfY29udGFjdFxuXHRcdFx0PyBSX0NPTlRBQ1RfTkFNRS50ZXN0KHNfbmV3X2NvbnRhY3QpXG5cdFx0XHRcdD8gJydcblx0XHRcdFx0OiBzX25ld19jb250YWN0Lmxlbmd0aCA+IDEwMjRcblx0XHRcdFx0XHQ/ICdUaGF0IG5hbWUgaXMgd2F5IHRvbyBsb25nJ1xuXHRcdFx0XHRcdDogJ0Nhbm5vdCBiZWdpbiB3aXRoIHNwYWNlJ1xuXHRcdFx0OiAnRW50ZXIgYSBjb250YWN0IG5hbWUgdG8gc2F2ZSBuZXcgYWRkcmVzcydcblx0XHQ6ICcnO1xuXG5cdCQ6IHtcblx0XHRpZihiX2NoZWNrZWRfc2F2ZV9jb250YWN0ICYmICFjX3Nob3dfdmFsaWRhdGlvbnMpIHtcblx0XHRcdHNfZXJyX25ld19jb250YWN0ID0gJyc7XG5cdFx0fVxuXHR9XG5cblx0JDogYl9mb3JtX3ZhbGlkID0gKHNhX3JlY2lwaWVudFxuXHRcdCYmIHNfYW1vdW50XG5cdFx0JiYgIXNfZXJyX3JlY2lwaWVudFxuXHRcdCYmICFzX2Vycl9hbW91bnRcblx0XHQmJiAoIWJfbmV3X2FkZHJlc3MgfHwgIWJfY2hlY2tlZF9zYXZlX2NvbnRhY3QgfHwgKHNfbmV3X2NvbnRhY3QgJiYgIXNfZXJyX25ld19jb250YWN0KSlcblx0KSB8fCBmYWxzZTtcblxuXHQkOiB7XG5cdFx0Y29uc29sZS5sb2coe1xuXHRcdFx0dG86IHNhX3JlY2lwaWVudCxcblx0XHRcdHNfYW1vdW50LFxuXHRcdFx0c19lcnJfcmVjaXBpZW50LFxuXHRcdFx0c19lcnJfYW1vdW50LFxuXHRcdH0pO1xuXHR9XG5cblxuXHRmdW5jdGlvbiBpbnB1dF9uZXdfY29udGFjdChkX2V2ZW50OiBFdmVudCkge1xuXHRcdHNfbmV3X2NvbnRhY3QgPSAoZF9ldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICdfYmFzZS5sZXNzJztcblxuXHRAa2V5ZnJhbWVzIHNwaW4ge1xuXHRcdGZyb20ge1xuXHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdFx0fVxuXHRcdHRvIHtcblx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG5cdFx0fVxuXHR9XG5cblx0I2ZpZWxkLXJlY2lwaWVudC1zdGF0dXMge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0bWFyZ2luLXRvcDogLTEycHg7XG5cdFx0XHRwYWRkaW5nLWxlZnQ6IDZweDtcblx0XHR9XG5cblx0XHQuc3RhdHVzIHtcblx0XHRcdDpnbG9iYWwoJi51bmtub3duPi5pY29uKSB7XG5cdFx0XHRcdGFuaW1hdGlvbjogc3BpbiAxcyBsaW5lYXIgaW5maW5pdGU7XG5cdFx0XHR9XG5cdFx0XHQ6Z2xvYmFsKCYuY29udHJhY3Q+Lmljb24pIHtcblx0XHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xuXHRcdFx0fVxuXHRcdFx0Omdsb2JhbCgmLmNvbnRyYWN0Pi5pY29uKSB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKDkwZGVnKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQuc3RhdHVzIHtcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItZ3JheW1lZCk7XG5cblx0XHQ+KiB7XG5cdFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdH1cblxuXHRcdD4uaWNvbiB7XG5cdFx0XHQtLXByb3h5LWljb24tZGlhbWV0ZXI6IDIwcHg7XG5cdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWdyYXltZWQpO1xuXG5cdFx0XHQ6Z2xvYmFsKHN2Zykge1xuXHRcdFx0XHR3aWR0aDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHRcdGhlaWdodDogdmFyKC0taWNvbi1kaWFtZXRlcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pi50ZXh0IHtcblx0XHRcdC5mb250KHRpbnkpO1xuXHRcdH1cblx0fVxuXG5cblx0I2ZpZWxkLWJhbGFuY2Uge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0bWFyZ2luLXRvcDogLTEycHg7XG5cdFx0fVxuXHR9XG5cblx0LmJhbGFuY2UtbGluZSB7XG5cdFx0LmZvbnQodGlueSwgQHNpemU6IDEycHgsIEB3ZWlnaHQ6IDMwMCk7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cblx0XHQ+LmJhbGFuY2Uge1xuXHRcdFx0Pi5sYWJlbCB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHR9XG5cblx0XHRcdD4uYW1vdW50IHtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC5mZWUtZmlhdCB7XG5cdFx0LmZvbnQodGlueSk7XG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0fVxuXG5cdCNmaWVsZC1mZWUge1xuXHRcdC5maWVsZC12YWx1ZSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZmxleDogMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQubWFudWFsLWZlZSB7XG5cdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0ZmxleDogMjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQjZmllbGQtbWFudWFsLWZlZSB7XG5cdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRtYXJnaW4tdG9wOiAtMTJweDtcblx0XHR9XG5cdH1cblxuXHQubWFudWFsLWZlZSB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGdhcDogMC41ZW07XG5cblx0XHQ+Lmljb24uaW5mbyB7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDE4cHg7XG5cdFx0XHRwYWRkaW5nOiAycHg7XG5cdFx0fVxuXHR9XG5cblx0Lm1lbW8ge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRnYXA6IDAuNzVlbTtcblxuXHRcdC50aXRsZSB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0Z2FwOiA0cHg7XG5cdFx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XG5cblx0XHRcdC5pY29uIHtcblx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyMnB4O1xuXHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0fVxuXHRcblx0XHRcdD4uZGlzY2xhaW1lciB7XG5cdFx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItY2F1dGlvbik7XG5cdFx0XHRcdHJpZ2h0OiAwO1xuXHRcdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRcdGJvdHRvbTogMC41ZXg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LmRyb3Bkb3duLmljb24ge1xuXHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdFx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMzAwbXMgdmFyKC0tZWFzZS1vdXQtcXVhZCk7XG5cdFx0fVxuXG5cdFx0Ji5leHBhbmRlZCB7XG5cdFx0XHQuZHJvcGRvd24uaWNvbiB7XG5cdFx0XHRcdHRyYW5zZm9ybTogcm90YXRlKC0xODBkZWcpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC5pbnB1dCB7XG5cdFx0XHR0ZXh0YXJlYSB7XG5cdFx0XHRcdHJlc2l6ZTogdmVydGljYWw7XG5cdFx0XHRcdG1pbi1oZWlnaHQ6IDEwLjc1ZXg7XG5cdFx0XHRcdG1heC1oZWlnaHQ6IDQwZXg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Lm5ldy1hZGRyZXNzIHtcblx0XHRtYXJnaW4tdG9wOiAxMnB4O1xuXHR9XG5cblx0LmRpc2FibGVkLmxpbmsge1xuXHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0Zm9udC1zdHlsZTogaXRhbGljO1xuXHRcdHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xuXHR9XG48L3N0eWxlPlxuXG5cbjxTY3JlZW4gZm9ybSBzbGlkZXMgb246c3VibWl0PXsoZF9zdWJtaXQpID0+IHtcblx0ZF9zdWJtaXQucHJldmVudERlZmF1bHQoKTtcbn19PlxuXHQ8SGVhZGVyIHBvcHNcblx0XHR0aXRsZT17Z190b2tlbj8gJ1RyYW5zZmVycmluZyc6ICdTZW5kaW5nJ31cblx0XHRzeW1ib2w9e2dfdG9rZW4/IGdfdG9rZW4uc3ltYm9sOiAnJ31cblx0XHRzdWJ0aXRsZT17JHl3X2NoYWluPy5uYW1lIHx8ICc/J31cblx0Lz5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J3NlbmRlci1zZWxlY3QnXG5cdFx0bmFtZT0nRnJvbSdcblx0PlxuXHRcdDxTZW5kZXJTZWxlY3Rcblx0XHRcdGJpbmQ6YWNjb3VudFJlZj17cF9hY2NvdW50fVxuXHRcdFx0Lz5cblx0PC9GaWVsZD5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J3JlY2lwaWVudC1zZWxlY3QnXG5cdFx0bmFtZT0nVG8nXG5cdD5cblx0XHQ8UmVjaXBpZW50U2VsZWN0XG5cdFx0XHRiaW5kOmVycm9yPXtzX2Vycl9yZWNpcGllbnR9XG5cdFx0XHRiaW5kOmFkZHJlc3M9e3NhX3JlY2lwaWVudH1cblx0XHRcdHNob3dWYWxpZGF0aW9uPXtjX3Nob3dfdmFsaWRhdGlvbnN9XG5cdFx0Lz5cblx0PC9GaWVsZD5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J3JlY2lwaWVudC1zdGF0dXMnXG5cdFx0bmFtZT0nJ1xuXHQ+XG5cdFx0PHNwYW4gY2xhc3M9XCJzdGF0dXMge3NpX2FkZHJlc3NfdHlwZX1cIj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHR7QGh0bWwgZ19hZGRyZXNzX3R5cGUuaWNvbn1cblx0XHRcdDwvc3Bhbj5cblx0XHRcdDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuXHRcdFx0XHR7Z19hZGRyZXNzX3R5cGUudGV4dH1cblx0XHRcdDwvc3Bhbj5cblx0XHQ8L3NwYW4+XG5cblx0XHR7I2lmIGJfbmV3X2FkZHJlc3N9XG5cdFx0XHQ8ZGl2IGNsYXNzPVwibmV3LWFkZHJlc3NcIj5cblx0XHRcdFx0PENoZWNrYm94RmllbGQgaWQ9XCJzYXZlLWNvbnRhY3RcIiBiaW5kOmNoZWNrZWQ9e2JfY2hlY2tlZF9zYXZlX2NvbnRhY3R9ID5cblx0XHRcdFx0XHRTYXZlIHRvIGNvbnRhY3RzXG5cdFx0XHRcdDwvQ2hlY2tib3hGaWVsZD5cblx0XHRcdDwvZGl2PlxuXHRcdHsvaWZ9XG5cdDwvRmllbGQ+XG5cblx0eyNpZiBiX25ld19hZGRyZXNzICYmIGJfY2hlY2tlZF9zYXZlX2NvbnRhY3R9XG5cdFx0PEZpZWxkIHNob3J0IHNsaWRlc1xuXHRcdFx0a2V5PSduZXctY29udGFjdC1uYW1lJ1xuXHRcdFx0bmFtZT0nQ29udGFjdCBOYW1lJ1xuXHRcdD5cblx0XHRcdDxpbnB1dCBpZD1cIm5ldy1jb250YWN0LW5hbWUtdmFsdWVcIiB0eXBlPVwidGV4dFwiIG9uOmlucHV0PXtpbnB1dF9uZXdfY29udGFjdH0gY2xhc3M6aW52YWxpZD17c19lcnJfbmV3X2NvbnRhY3R9PlxuXG5cdFx0XHR7I2lmIHNfZXJyX25ld19jb250YWN0fVxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiPlxuXHRcdFx0XHRcdHtzX2Vycl9uZXdfY29udGFjdH1cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0ey9pZn1cblx0XHQ8L0ZpZWxkPlxuXHR7L2lmfVxuXG5cdDxocj5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2Fzc2V0LXNlbGVjdCdcblx0XHRuYW1lPSdBc3NldCdcblx0PlxuXHRcdDxBc3NldFNlbGVjdCBiaW5kOmFzc2V0UmVmPXtwX2Fzc2V0fSAvPlxuXHQ8L0ZpZWxkPlxuXG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0nYW1vdW50J1xuXHRcdG5hbWU9J0Ftb3VudCdcblx0PlxuXHRcdDxBbW91bnRJbnB1dFxuXHRcdFx0YnVmZmVyTWF4PXtnX2NvaW4/IHhfZmVlOiAwfVxuXHRcdFx0YXNzZXRSZWY9e3BfYXNzZXR9XG5cdFx0XHRiaW5kOmVycm9yPXtzX2Vycl9hbW91bnR9XG5cdFx0XHRiaW5kOnZhbHVlPXtzX2Ftb3VudH1cblx0XHRcdHNob3dWYWxpZGF0aW9uPXtjX3Nob3dfdmFsaWRhdGlvbnN9XG5cdFx0Lz5cblx0PC9GaWVsZD5cblxuXHQ8RmllbGQgc2hvcnRcblx0XHRrZXk9J2JhbGFuY2UnXG5cdFx0bmFtZT0nJ1xuXHQ+XG5cdFx0PHNwYW4gY2xhc3M9XCJiYWxhbmNlLWxpbmVcIj5cblx0XHRcdHsjaWYgcF9hc3NldH1cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJiYWxhbmNlXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsYWJlbFwiPlxuXHRcdFx0XHRcdFx0QmFsYW5jZVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImFtb3VudFwiPlxuXHRcdFx0XHRcdFx0e3NfYmFsYW5jZX0ge3Nfc3ltYm9sfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9zcGFuPlxuXG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwidXNlLW1heFwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibGlua1wiIGNsYXNzOmRpc2FibGVkPXtiX3VzaW5nX21heH0gb246Y2xpY2s9eygpID0+IHVzZV9tYXgoKX0+VVNFIE1BWDwvc3Bhbj5cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0ey9pZn1cblx0XHQ8L3NwYW4+XG5cdDwvRmllbGQ+XG5cblx0PGhyPlxuXG5cdDxGaWVsZCBzaG9ydFxuXHRcdGtleT0nZmVlJ1xuXHRcdG5hbWU9J0ZlZSdcblx0PlxuXHRcdDxkaXYgY2xhc3M9XCJmZWUtYW1vdW50XCI+XG5cdFx0XHR7eF9mZWV9IFNDUlRcblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJmZWUtZmlhdFwiPlxuXHRcdFx0e3NfZmVlX2ZpYXR9XG5cdFx0PC9kaXY+XG5cblx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJwb3N0XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwibWFudWFsLWZlZVwiPlxuPCEtLSBcblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJsaW5rIGRpc2FibGVkXCI+U2V0IGZlZSBtYW51YWxseTwvc3Bhbj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJpY29uIGluZm9cIj5cblx0XHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9JTkZPfVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdCAtLT5cblx0XHRcdDwvZGl2PlxuXHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHQ8L0ZpZWxkPlxuXG5cdDxocj5cblxuXHQ8ZGl2IGNsYXNzPVwibWVtb1wiIGNsYXNzOmV4cGFuZGVkPXtiX21lbW9fZXhwYW5kZWR9PlxuXHRcdDxkaXYgY2xhc3M9XCJ0aXRsZSBjbGlja2FibGVcIiBvbjpjbGljaz17KCkgPT4gYl9tZW1vX2V4cGFuZGVkID0gIWJfbWVtb19leHBhbmRlZH0+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImljb24gZHJvcGRvd25cIj5cblx0XHRcdFx0e0BodG1sIFNYX0lDT05fRFJPUERPV059XG5cdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0QWRkIG1lbW9cblx0XHRcdDwvc3Bhbj5cblxuXHRcdFx0eyNpZiBiX21lbW9fZXhwYW5kZWR9XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiZGlzY2xhaW1lclwiIHRyYW5zaXRpb246c2xpZGU9e3tkdXJhdGlvbjozNTAsIGRlbGF5OjQwMH19PlxuXHRcdFx0XHRcdENhdXRpb246IE1lbW9zIGFyZSBOT1QgcHJpdmF0ZVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHR7L2lmfVxuXHRcdDwvZGl2PlxuXG5cdFx0eyNpZiBiX21lbW9fZXhwYW5kZWR9XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiaW5wdXRcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzUwfX0+XG5cdFx0XHRcdDx0ZXh0YXJlYSBiaW5kOnZhbHVlPXtzX21lbW99PjwvdGV4dGFyZWE+XG5cdFx0XHQ8L2Rpdj5cblx0XHR7L2lmfVxuXHQ8L2Rpdj5cblxuXHQ8QWN0aW9uc0xpbmUgY2FuY2VsPSdwb3AnIGNvbmZpcm09e1snTmV4dCcsICgpID0+IHN1Ym1pdCgpLCAhYl9mb3JtX3ZhbGlkXX0gLz5cblxuPCEtLSBcblx0PGRpdiBjbGFzcz1cImFjdGlvbi1saW5lXCIgY2xhc3M6cG9pbnRlci1ldmVudHNfbm9uZT17Yl9kZWFkfT5cblx0XHQ8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbjpjbGljaz17KCkgPT4gKChiX2RlYWQgPSB0cnVlKSAmJiBrX3BhZ2UucG9wKCkpfT5cblx0XHRcdENhbmNlbFxuXHRcdDwvYnV0dG9uPiAtLT5cbjwhLS0gXG5cdFx0PGJ1dHRvbiBjbGFzcz1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gc3VibWl0KCl9IHJlYWRvbmx5PXshYl9mb3JtX3ZhbGlkfT5cblx0XHRcdE5leHRcblx0XHQ8L2J1dHRvbj4gLS0+XG5cdDwhLS0gPC9kaXY+IC0tPlxuPC9TY3JlZW4+IiwiPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5nYXAge1xuXHRcdGhlaWdodDogOHB4O1xuXHRcdGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xuXHRcdG1hcmdpbi1ib3R0b206IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiZ2FwIG5vLW1hcmdpblwiPiZuYnNwOzwvZGl2PiIsImltcG9ydCB0eXBlIHtOYXRpdmVDb2lufSBmcm9tICcjL21ldGEvY2hhaW4nO1xuaW1wb3J0IHR5cGUge0NvaW59IGZyb20gJ2Nvc21vcy1ncnBjL2Rpc3QvY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luJztcblxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHtDb2luR2Vja299IGZyb20gJyMvc3RvcmUvd2ViLWFwaXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXNfYW1vdW50KGdfYmFsYW5jZTogQ29pbiwgZ19jb2luOiBOYXRpdmVDb2luKTogc3RyaW5nIHtcblx0Y29uc3Qgc19ub3JtID0gZ19iYWxhbmNlLmFtb3VudC5wYWRTdGFydChnX2NvaW4uZGVjaW1hbHMgKyAyLCAnMCcpO1xuXG5cdHJldHVybiBzX25vcm0uc2xpY2UoMCwgLWdfY29pbi5kZWNpbWFscykucmVwbGFjZSgvXjArLywgJzAnKSsnLicrc19ub3JtLnNsaWNlKC1nX2NvaW4uZGVjaW1hbHMpO1xuXG5cdC8vIC8vIGdfY29pbi5kZWNpbWFsc1xuXHQvLyByZXR1cm4gZ19iYWxhbmNlLmFtb3VudDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvX2ZpYXQoZ19iYWxhbmNlOiBDb2luLCBnX2NvaW46IE5hdGl2ZUNvaW4sIHNpX3ZlcnN1cz0ndXNkJyk6IFByb21pc2U8QmlnTnVtYmVyPiB7XG5cdC8vIHplcm9cblx0aWYoJzAnID09PSBnX2JhbGFuY2UuYW1vdW50KSByZXR1cm4gbmV3IEJpZ051bWJlcigwKTtcblxuXHQvLyBsb29rdXAgcHJpY2Vcblx0Y29uc3Qgc2lfZ2Vja28gPSBnX2NvaW4uZXh0cmEhLmNvaW5nZWNrb19pZDtcblx0Y29uc3QgZ192ZXJzdXMgPSBhd2FpdCBDb2luR2Vja28uY29pbnNWZXJzdXMoW3NpX2dlY2tvXSwgc2lfdmVyc3VzKTtcblxuXHQvLyBwYXJzZSBiYWxhbmNlIGFuZCBtdWx0aXBseSBieSB2YWx1ZVxuXHRyZXR1cm4gbmV3IEJpZ051bWJlcihnX2JhbGFuY2UuYW1vdW50KS5zaGlmdGVkQnkoLWdfY29pbi5kZWNpbWFscykudGltZXMoZ192ZXJzdXNbc2lfZ2Vja29dKTtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENvaW5Gb3JtYXRzIHtcblx0LyoqXG5cdCAqIFRoZSBpZCBvZiB0aGUgZmlhdCB0aGlzIGNvaW4gaXMgdmVyc3VzXG5cdCAqL1xuXHR2ZXJzdXM6IHN0cmluZztcblxuXHQvKipcblx0ICogVGhlIGJhbGFuY2Ugb2YgdGhlIGhvbGRpbmdcblx0ICovXG5cdGJhbGFuY2U6IEJpZ051bWJlcjtcblxuXHQvKipcblx0ICogVGhlIHRvdGFsIFxuXHQgKi9cblx0ZmlhdDogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBUaGUgd29ydGggb2YgZXhhY3RseSAxIGNvaW4gdmVyc3VzIHRoZSBnaXZlbiBmaWF0XG5cdCAqL1xuXHR3b3J0aDogbnVtYmVyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29pbl9mb3JtYXRzKGdfYmFsYW5jZTogQ29pbiwgZ19jb2luOiBOYXRpdmVDb2luLCBzaV92ZXJzdXM9J3VzZCcpOiBQcm9taXNlPENvaW5Gb3JtYXRzPiB7XG5cdC8vIGxvb2t1cCBwcmljZVxuXHRjb25zdCBzaV9nZWNrbyA9IGdfY29pbi5leHRyYSEuY29pbmdlY2tvX2lkO1xuXHRjb25zdCBnX3ZlcnN1cyA9IGF3YWl0IENvaW5HZWNrby5jb2luc1ZlcnN1cyhbc2lfZ2Vja29dLCBzaV92ZXJzdXMpO1xuXG5cdGNvbnN0IHhfd29ydGggPSBnX3ZlcnN1c1tzaV9nZWNrb107XG5cblx0Y29uc3QgeWdfYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoZ19iYWxhbmNlLmFtb3VudCkuc2hpZnRlZEJ5KC1nX2NvaW4uZGVjaW1hbHMpLnRpbWVzKHhfd29ydGgpXG5cblx0Ly8gcGFyc2UgYmFsYW5jZSBhbmQgbXVsdGlwbHkgYnkgdmFsdWVcblx0cmV0dXJuIHtcblx0XHR2ZXJzdXM6IHNpX3ZlcnN1cyxcblx0XHRiYWxhbmNlOiB5Z19iYWxhbmNlLFxuXHRcdGZpYXQ6IHlnX2JhbGFuY2UudGltZXMoeF93b3J0aCkudG9OdW1iZXIoKSxcblx0XHR3b3J0aDogeF93b3J0aCxcblx0fTtcbn1cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcblxuXHRpbXBvcnQgU1hfSUNPTl9TRU5EIGZyb20gJyMvaWNvbi9zZW5kLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9SRUNWIGZyb20gJyMvaWNvbi9yZWN2LnN2Zz9yYXcnO1xuXG5cdC8vIGltcG9ydCB7ZGVmaW5pdGlvbn0gZnJvbSAnQGZvcnRhd2Vzb21lL2ZyZWUtc29saWQtc3ZnLWljb25zL2ZhUm9ib3QnO1xuXHQvLyBjb25zdCBTWFBfUk9CT1QgPSBkZWZpbml0aW9uLmljb25bNF07XG5cdGNvbnN0IFNYUF9ST0JPVCA9ICcnO1xuXG5cdC8vIGltcG9ydCBTWF9OT1JUSF9FQVNUIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL2ZpbGxlZC9ub3J0aF9lYXN0LnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfRURJVCBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9maWxsZWQvZWRpdC5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0lORk8gZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvaW5mby5zdmc/cmF3JztcblxuXHRpbXBvcnQgU1hfSUNPTl9QRVJTT05BTCBmcm9tICcjL2ljb24vYWNjb3VudF9ib3guc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NPTlRSQUNUIGZyb20gJyMvaWNvbi9hbmFseXRpY3Muc3ZnP3Jhdyc7XG5cdGltcG9ydCB7IEhlYWRlciwgU2NyZWVuLCB0eXBlIFBhZ2UgfSBmcm9tICcuL19zY3JlZW5zJztcblx0aW1wb3J0IFBvcnRyYWl0LCB7IEFjdGlvbnMgfSBmcm9tICcuLi91aS9Qb3J0cmFpdC5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IEVudGl0eVBhdGgsIE5hdGl2ZUNvaW4gfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgeyBFbnRpdGllcyB9IGZyb20gJyMvc3RvcmUvZW50aXRpZXMnO1xuXHRpbXBvcnQgeyB5d19jaGFpbiwgeXdfY2hhaW5fcmVmLCB5d19uZXR3b3JrX2FjdGl2ZSB9IGZyb20gJy4uL21lbSc7XG5cdGltcG9ydCB7IFNJX1NUT1JFX0NIQUlOUywgWFRfTUlOVVRFUyB9IGZyb20gJyMvc2hhcmUvY29uc3RhbnRzJztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCBTZW5kIGZyb20gJy4vU2VuZC5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IFRva2VuLCBUb2tlblBhdGggfSBmcm9tICcjL21ldGEvdG9rZW4nO1xuXHRpbXBvcnQgeyBDaGFpbnMgfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cdGltcG9ydCB7IGNvaW5fZm9ybWF0cywgdG9fZmlhdCB9IGZyb20gJyMvY2hhaW4vY29pbic7XG5cdGltcG9ydCB7IGZvcm1hdF9hbW91bnQsIGZvcm1hdF9maWF0IH0gZnJvbSAnIy91dGlsL2Zvcm1hdCc7XG5cdGltcG9ydCB0eXBlIHsgQ29pbiB9IGZyb20gJ2Nvc21vcy1ncnBjL2Rpc3QvY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luJztcblx0aW1wb3J0IHR5cGUgeyBQZnBQYXRoIH0gZnJvbSAnIy9tZXRhL3BmcCc7XG5pbXBvcnQgUGZwRGlzcGxheSBmcm9tICcuLi91aS9QZnBEaXNwbGF5LnN2ZWx0ZSc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdC8qKlxuXHQgKiBFbnRpdHkgcGF0aCBzaG91bGQgYmUgZWl0aGVyIGEgaG9sZGluZyBvciB0b2tlblxuXHQgKi9cblx0ZXhwb3J0IGxldCBlbnRpdHlSZWY6IEVudGl0eVBhdGg7XG5cdGNvbnN0IHBfZW50aXR5ID0gZW50aXR5UmVmO1xuXG5cblx0Ly8gZWl0aGVyIGEgbmF0aXZlIGNvaW4gb3IgYSBmdW5naWJsZSB0b2tlblxuXHRsZXQgc2lfdHlwZTogJ2NvaW4nIHwgJ3Rva2VuJyB8ICcnID0gJyc7XG5cblx0Ly8gdGhlIGNvaW4ncyBpZCBhbmQgb2JqZWN0IChpZiBpdHMgYSBjb2luKVxuXHRsZXQgc2lfY29pbiA9ICcnO1xuXHRsZXQgZ19jb2luOiBOYXRpdmVDb2luIHwgbnVsbCA9IG51bGw7XG5cblx0Ly8gdGhlIHRva2VuJ3MgcGF0aCBhbmQgb2JqZWN0IChpZiBpdCdzIGEgdG9rZW4pXG5cdGxldCBwX3Rva2VuOiBUb2tlblBhdGggfCAnJyA9ICcnO1xuXHRsZXQgZ190b2tlbjogVG9rZW5bJ2ludGVyZmFjZSddIHwgbnVsbCA9IG51bGw7XG5cblxuXHQvLyBpdHMgcGZwXG5cdGxldCBwX3BmcDogUGZwUGF0aCB8ICcnID0gJyc7XG5cblx0Ly8gaXRzIFNZTUJMXG5cdGxldCBzX3N5bWJvbCA9ICcnO1xuXG5cdC8vIGl0cyBuYW1lXG5cdGxldCBzX25hbWUgPSAnJztcblx0XG5cdC8vIHRoZSBhbW91bnQgdGhlIG93bmVyIGhvbGRzXG5cdGxldCB5Z19hbW91bnQ6IEJpZ051bWJlciB8IG51bGwgPSBudWxsO1xuXG5cdC8vIHRoZSBlcXVpdmFsZW50IGluIGZpYXRcblx0bGV0IHNfZmlhdCA9ICcnO1xuXG5cdC8vIHRoZSBmaWF0IHdvcnRoIG9mIGV4YWN0bHkgMSBjb2luL3Rva2VuXG5cdGxldCBzX3dvcnRoID0gJyc7XG5cblxuXHQvLyBjb25zdCB4X3ZlcnN1c191c2QgPSBIX1ZFUlNVU19VU0RbcF90b2tlbl0udmFsdWU7XG5cblxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX2VudGl0eSgpIHtcblx0XHRjb25zdCBrc19lbnRpdGllcyA9IGF3YWl0IEVudGl0aWVzLnJlYWQoKTtcblxuXHRcdGNvbnN0IGdfaW5mbyA9IEVudGl0aWVzLnBhcnNlRW50aXR5UGF0aChwX2VudGl0eSk7XG5cblx0XHRpZighZ19pbmZvKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2FkIGhvbGRpbmcgdmlldyBvbiBub24tZW50aXR5IHBhdGggXCIke3BfZW50aXR5fVwiYCk7XG5cdFx0fVxuXG5cdFx0c3dpdGNoKGdfaW5mby50eXBlKSB7XG5cdFx0XHQvLyBuYXRpdmUgY29pblxuXHRcdFx0Y2FzZSAnaG9sZGluZyc6IHtcblx0XHRcdFx0c2lfdHlwZSA9ICdjb2luJztcblxuXHRcdFx0XHQvLyBkZXN0cnVjdHVyZVxuXHRcdFx0XHQoe1xuXHRcdFx0XHRcdGNvaW46IHNpX2NvaW4sXG5cdFx0XHRcdH0gPSBnX2luZm8pO1xuXG5cdFx0XHRcdC8vIGxvb2t1cCBkZXRhaWxzIGZyb20gY2hhaW5cblx0XHRcdFx0Y29uc3QgcF9jaGFpbiA9IGdfaW5mby5jaGFpblJlZjtcblx0XHRcdFx0Y29uc3QgZ19jaGFpbiA9IHBfY2hhaW4gPT09ICR5d19jaGFpbl9yZWY/ICR5d19jaGFpbjogKGF3YWl0IENoYWlucy5hdChwX2NoYWluKSkhO1xuXHRcdFx0XHRnX2NvaW4gPSBnX2NoYWluLmNvaW5zW3NpX2NvaW5dO1xuXG5cdFx0XHRcdC8vIHNldCBkZXRhaWxzXG5cdFx0XHRcdHNfc3ltYm9sID0gc2lfY29pbjtcblx0XHRcdFx0c19uYW1lID0gZ19jb2luLm5hbWU7XG5cdFx0XHRcdHBfcGZwID0gZ19jb2luLnBmcDtcblxuXHRcdFx0XHQvLyByZWFkIGNhY2hlXG5cdFx0XHRcdGNvbnN0IGdfY2FjaGVkID0gJHl3X25ldHdvcmtfYWN0aXZlLmNhY2hlZEJhbGFuY2UoZ19pbmZvLmJlY2gzMiwgc2lfY29pbik7XG5cblx0XHRcdFx0bGV0IGdfYmFsYW5jZTogQ29pbjtcblxuXHRcdFx0XHQvLyBjYWNoZSBpcyB3aXRoaW4gYXNraW5nIHRpbWVcblx0XHRcdFx0aWYoZ19jYWNoZWQgJiYgZ19jYWNoZWQudGltZXN0YW1wID49IERhdGUubm93KCkgLSAoMiAqIFhUX01JTlVURVMpKSB7XG5cdFx0XHRcdFx0Z19iYWxhbmNlID0gZ19jYWNoZWQuZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBkZXN0cnVjdHVyZSBiYWxhbmNlXG5cdFx0XHRcdFx0KHtcblx0XHRcdFx0XHRcdGJhbGFuY2U6IGdfYmFsYW5jZSxcblx0XHRcdFx0XHR9ID0gYXdhaXQgJHl3X25ldHdvcmtfYWN0aXZlLmJhbmtCYWxhbmNlKGdfaW5mby5iZWNoMzIsIHNpX2NvaW4pKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNldCBhbW91bnRcblx0XHRcdFx0eWdfYW1vdW50ID0gbmV3IEJpZ051bWJlcihnX2JhbGFuY2UuYW1vdW50KS5zaGlmdGVkQnkoLWdfY29pbi5kZWNpbWFscyk7XG5cblx0XHRcdFx0Ly8gc2V0IGZpYXQgYW1vdW50IGFzeW5jaHJvbm91c2x5XG5cdFx0XHRcdHZvaWQgY29pbl9mb3JtYXRzKGdfYmFsYW5jZSwgZ19jb2luKS50aGVuKChnX2Zvcm1hdHMpID0+IHtcblx0XHRcdFx0XHRzX2ZpYXQgPSBmb3JtYXRfZmlhdChnX2Zvcm1hdHMuZmlhdCwgZ19mb3JtYXRzLnZlcnN1cyk7XG5cdFx0XHRcdFx0c193b3J0aCA9IGZvcm1hdF9maWF0KGdfZm9ybWF0cy53b3J0aCwgZ19mb3JtYXRzLnZlcnN1cyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyB0b2tlblxuXHRcdFx0Y2FzZSAndG9rZW4nOiB7XG5cdFx0XHRcdHNpX3R5cGUgPSAndG9rZW4nO1xuXG5cdFx0XHRcdC8vIHNldCB0b2tlbiBwYXRoXG5cdFx0XHRcdHBfdG9rZW4gPSBwX2VudGl0eSBhcyBUb2tlblBhdGg7XG5cblx0XHRcdFx0Ly8gcmVhZCB0b2tlbiBpbnRlcmZhY2VzXG5cdFx0XHRcdGNvbnN0IGtzX2VudGl0ZXMgPSBhd2FpdCBFbnRpdGllcy5yZWFkKCk7XG5cdFx0XHRcdGNvbnN0IGhfaWZhY2VzID0ga3NfZW50aXRlcy50b2tlbnMoZ19pbmZvLmVudGl0eVJlZiwgRW50aXRpZXMuZnVuZ2libGVJbnRlcmZhY2VzRm9yKCR5d19jaGFpbikpO1xuXHRcdFx0XHRkZWJ1Z2dlcjtcblxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBlbnRpdHkgdHlwZTogXCIke2dfaW5mby50eXBlfVwiYCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bG9hZF9lbnRpdHkoKTtcblxuXHQvLyBleHBvcnQgY29uc3QgYWNjb3VudElkID0gT2JqZWN0LnZhbHVlcyhIX0FDQ09VTlRTKS5maW5kKChrKSA9PiBrLmFkZHJlc3Moa19jaGFpbikgPT09IGhvbGRpbmcuZGVmLmhvbGRlckFkZHIpPy5kZWYuaWQgfHwgJHl3X2NoYWluLmRlZi5pZDtcblxuXHQvLyBjb25zdCBrX2FjY291bnQgPSAkeXdfYWNjb3VudDtcblx0Ly8geXdfYWNjb3VudC5zdWJzY3JpYmUoKF9rX2FjY291bnQpID0+IHtcblx0Ly8gXHRpZigkeXdfcGF0dGVybi5lbmRzV2l0aCgnL3Rva2Vucy97dG9rZW5JZH0vaG9sZGluZ3Mve2FjY291bnRJZH0vdmlldycpICYmIGtfYWNjb3VudC5kZWYucHVia2V5ICE9PSBfa19hY2NvdW50LmRlZi5wdWJrZXkpIHtcblx0Ly8gXHRcdHJlc3RhcnQoKTtcblx0Ly8gXHR9XG5cdC8vIH0pO1xuXG5cdC8vIGNvbnN0IEhfVFhOX0lDT05TID0ge1xuXHQvLyBcdFtUeG4uVHlwZS5VTktOXTogSWNvbi5CTEFOSyxcblx0Ly8gXHRbVHhuLlR5cGUuU0VORF06IEljb24uZnJvbUh0bWwoU1hfSUNPTl9TRU5ELCB7Y2xhc3M6J2ljb24tMjAnfSksXG5cdC8vIFx0W1R4bi5UeXBlLlJFQ1ZdOiBJY29uLmZyb21IdG1sKFNYX0lDT05fUkVDViwge2NsYXNzOidpY29uLTIwJ30pLFxuXHQvLyBcdFtUeG4uVHlwZS5DT01QXTogSWNvbi5mcm9tSHRtbChgPHN2Zz48cGF0aCBkPVwiJHtTWFBfUk9CT1R9XCIvPjwvc3ZnPmAsIHtjbGFzczonaWNvbi0yMCd9KSxcblx0Ly8gXHRbVHhuLlR5cGUuU05JUDIwX1hGRVJdOiBJY29uLmZyb21IdG1sKFNYX0lDT05fUkVDViwge2NsYXNzOidpY29uLTIwJ30pLFxuXHQvLyB9IGFzIFJlY29yZDxUeG4uVHlwZSB8IFR4bi5CYW5raXNoVHlwZSwgSWNvbj47XG5cblx0Ly8gY29uc3QgSF9TVU1NQVJJWkVSUyA9IHtcblx0Ly8gXHRbVHhuLlR5cGUuVU5LTl06IChfKSA9PiAnVW5rbm93bicsXG5cdC8vIFx0W1R4bi5UeXBlLlNFTkRdOiAoaykgPT4gYFNlbmQgb24gJHtrLmRhdGUoKX1gLFxuXHQvLyBcdFtUeG4uVHlwZS5SRUNWXTogKGspID0+IGBSZWNlaXZlIG9uICR7ay5kYXRlKCl9YCxcblx0Ly8gXHRbVHhuLlR5cGUuQ09NUF06IChrKSA9PiBgQ29tcHV0ZSBvbiAke2suZGF0ZSgpfWAsXG5cdC8vIH0gYXMgUmVjb3JkPFR4bi5UeXBlIHwgVHhuLkJhbmtpc2hUeXBlLCAoa190eG46IFR4bikgPT4gc3RyaW5nPjtcblxuXHQvLyBjb25zdCBIX1RYTl9DTEFTU0VTID0ge1xuXHQvLyBcdFtUeG4uVHlwZS5TRU5EXTogJ2NvbG9yLWljb24tc2VuZCcsXG5cdC8vIFx0W1R4bi5UeXBlLlJFQ1ZdOiAnY29sb3ItaWNvbi1yZWN2Jyxcblx0Ly8gfSBhcyBSZWNvcmQ8VHhuLlR5cGUgfCBUeG4uQmFua2lzaFR5cGUsIHN0cmluZz47XG5cblx0Ly8gdGhlIHNldCBvZiBhY3Rpb25zIGF2YWlsYWJsZSBvbiB0aGlzIGFzc2V0XG5cdGNvbnN0IGdjX2FjdGlvbnM6IEFjdGlvbnMgPSB7XG5cdFx0c2VuZDoge1xuXHRcdFx0bGFiZWw6ICdTZW5kJyxcblx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBTZW5kLFxuXHRcdFx0XHRcdHByb3BzOiBnX3Rva2VuXG5cdFx0XHRcdFx0XHQ/IHtcblx0XHRcdFx0XHRcdFx0dG9rZW46IGdfdG9rZW4sXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQ6IHNpX2NvaW5cblx0XHRcdFx0XHRcdFx0PyB7XG5cdFx0XHRcdFx0XHRcdFx0bmF0aXZlOiBzaV9jb2luLFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdDoge30sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHR9O1xuXG5cdC8vIC8vIGhvbWUgdG9rZW5cblx0Ly8gY29uc3Qga19pYmN0X25hdGl2ZSA9IEhfSUJDVFNbSWJjdC5yZWZGcm9tSG9tZVRva2VuKGdkX3Rva2VuLmlyaSldO1xuXHQvLyBpZihrX2liY3RfbmF0aXZlKSB7XG5cdC8vIFx0Z2NfYWN0aW9ucy53cmFwID0ge1xuXHQvLyBcdFx0bGFiZWw6ICdXcmFwJyxcblx0Ly8gXHRcdHRyaWdnZXIoKSB7XG5cdC8vIFx0XHRcdHB1c2hfc2NyZWVuKERlYWRFbmQpO1xuXHQvLyBcdFx0fSxcblx0Ly8gXHR9O1xuXHQvLyB9XG5cblx0Ly8gLy8gY29sb255IHRva2VuXG5cdC8vIGlmKGtfdG9rZW4uaWJjdCkge1xuXHQvLyBcdGdjX2FjdGlvbnMudW53cmFwID0ge1xuXHQvLyBcdFx0bGFiZWw6ICdVbndyYXAnLFxuXHQvLyBcdFx0dHJpZ2dlcigpIHtcblx0Ly8gXHRcdFx0cHVzaF9zY3JlZW4oRGVhZEVuZCk7XG5cdC8vIFx0XHR9LFxuXHQvLyBcdH07XG5cdC8vIH1cblxuXHQvLyAvLyBub24tbmF0aXZlIHRva2VuXG5cdC8vIGlmKCFnZF90b2tlbi5uYXRpdmUpIHtcblx0Ly8gXHRPYmplY3QuYXNzaWduKGdjX2FjdGlvbnMsIHtcblx0Ly8gXHRcdGVkaXQ6IHtcblx0Ly8gXHRcdFx0bGFiZWw6ICdFZGl0Jyxcblx0Ly8gXHRcdFx0dHJpZ2dlcigpIHtcblx0Ly8gXHRcdFx0XHRwdXNoX3NjcmVlbihUb2tlbkVkaXQsIHtcblx0Ly8gXHRcdFx0XHRcdHRva2VuOiBrX3Rva2VuLFxuXHQvLyBcdFx0XHRcdH0pO1xuXHQvLyBcdFx0XHR9LFxuXHQvLyBcdFx0fSxcblx0Ly8gXHR9KTtcblx0Ly8gfVxuXG5cdC8vIGZ1bmN0aW9uIGRldGFpbF9iYW5raXNoKGdfYmFua2lzaD86IFR4bi5CYW5raXNoIHwgbnVsbCk6IHtwcmVmaXg6c3RyaW5nLCBuYW1lOnN0cmluZywgaWNvbjpzdHJpbmd9IHtcblx0Ly8gXHRpZighZ19iYW5raXNoKSByZXR1cm4ge3ByZWZpeDonJywgbmFtZTonJywgaWNvbjonJ307XG5cblx0Ly8gXHRjb25zdCBrX2NvbnRhY3QgPSBIX0FERFJfVE9fQ09OVEFDVFtnX2Jhbmtpc2guYWRkcmVzc107XG5cblx0Ly8gXHRyZXR1cm4ge1xuXHQvLyBcdFx0cHJlZml4OiAoVHhuLkJhbmtpc2hUeXBlLlNFTkQgPT09IGdfYmFua2lzaC50eXBlPyAndG8nOiAnZnInKSsnOicsXG5cdC8vIFx0XHRuYW1lOiBrX2NvbnRhY3Q/IGtfY29udGFjdC5kZWYubGFiZWw6ICcnLFxuXHQvLyBcdFx0aWNvbjoga19jb250YWN0XG5cdC8vIFx0XHRcdD8gQ29udGFjdC5UeXBlLlBFUlNPTiA9PT0ga19jb250YWN0LmRlZi50eXBlXG5cdC8vIFx0XHRcdFx0PyBTWF9JQ09OX1BFUlNPTkFMXG5cdC8vIFx0XHRcdFx0OiBTWF9JQ09OX0NPTlRSQUNUXG5cdC8vIFx0XHRcdDogJycsXG5cdC8vIFx0fTtcblx0Ly8gfVxuXG5cdFxuXHQvLyBjb25zdCBhX2FsbG93YW5jZXMgPSBnZF90b2tlbi5hbGxvd2FuY2VzLm1hcCgoZ19hbGxvd2FuY2UpID0+IHtcblx0Ly8gXHRjb25zdCBrX3NwZW5kZXIgPSBIX0FERFJfVE9fQ09OVFJBQ1RbZ19hbGxvd2FuY2Uuc3BlbmRlcl07XG5cdC8vIFx0aWYoIWtfc3BlbmRlcikge1xuXHQvLyBcdFx0ZGVidWdnZXI7XG5cdC8vIFx0fVxuXG5cdC8vIFx0bGV0IHNfYW1vdW50O1xuXHQvLyBcdGNvbnN0IHlnX2Ftb3VudCA9IG5ldyBCaWdOdW1iZXIoZ19hbGxvd2FuY2UuYW1vdW50KTtcblx0Ly8gXHRpZih5Z19hbW91bnQuaXNHcmVhdGVyVGhhbihuZXcgQmlnTnVtYmVyKCcxMDAwMDAwMDAwMDAwMDAwMDAwJykpKSB7XG5cdC8vIFx0XHRzX2Ftb3VudCA9ICdMaW1pdGxlc3MnO1xuXHQvLyBcdH1cblx0Ly8gXHRlbHNlIHtcblx0Ly8gXHRcdGZvcm1hdF9hbW91bnQoa190b2tlbi5hcHByb3goQmlnSW50KGdfYWxsb3dhbmNlLmFtb3VudCkpKTtcblx0Ly8gXHR9XG5cblx0Ly8gXHRsZXQgc19leHBpcnk7XG5cdC8vIFx0Y29uc3QgeF9leHBpcmVzID0gZ19hbGxvd2FuY2UuZXhwaXJhdGlvbjtcblx0Ly8gXHRpZih4X2V4cGlyZXMpIHtcblx0Ly8gXHRcdGNvbnN0IGR0X3doZW4gPSBuZXcgRGF0ZSh4X2V4cGlyZXMgKiAxZTMpO1xuXG5cdC8vIFx0XHRzX2V4cGlyeSA9IGR0X3doZW4udG9Mb2NhbGVEYXRlU3RyaW5nKCdlbi1VUycsIHtcblx0Ly8gXHRcdFx0bW9udGg6ICdzaG9ydCcsXG5cdC8vIFx0XHRcdGRheTogJ251bWVyaWMnLFxuXHQvLyBcdFx0XHR5ZWFyOiBkdF93aGVuLmdldEZ1bGxZZWFyKCkgIT09IChuZXcgRGF0ZSgpKS5nZXRGdWxsWWVhcigpPyAnbnVtZXJpYyc6IHZvaWQgMCxcblx0Ly8gXHRcdH0pO1xuXHQvLyBcdH1cblx0Ly8gXHRlbHNlIHtcblx0Ly8gXHRcdHNfZXhwaXJ5ID0gJ05ldmVyIGV4cGlyZXMnO1xuXHQvLyBcdH1cblxuXHQvLyBcdHJldHVybiB7XG5cdC8vIFx0XHQuLi5nX2FsbG93YW5jZSxcblx0Ly8gXHRcdGtfc3BlbmRlcixcblx0Ly8gXHRcdHNfYW1vdW50LFxuXHQvLyBcdFx0c19leHBpcnksXG5cdC8vIFx0fTtcblx0Ly8gfSk7XG5cblx0Ly8gaWYoVGFza3MuVkVSSUZZID09PSAkeXdfdGFzayAmJiAnQVRPTScgPT09IGdkX3Rva2VuLnN5bWJvbCAmJiBnZF90b2tlbi5uYXRpdmUgJiYgJzInID09PSAkeXdfYWNjb3VudC5kZWYuaWQpIHtcblx0Ly8gXHRzZXRUaW1lb3V0KCgpID0+IHtcblx0Ly8gXHRcdCR5d190YXNrID0gLSR5d190YXNrO1xuXHQvLyBcdH0sIDE0MDApO1xuXHQvLyB9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LnR4bnMge1xuXHRcdC5yb3cgLmljb24ge1xuXHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0Ym9yZGVyLXJhZGl1czogMzJweDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQuc2VjdGlvbiB7XG5cdFx0bWFyZ2luOiAwO1xuXHRcdGJvcmRlci10b3A6IDZweCBzb2xpZCBibGFjaztcblx0XHRib3JkZXItYm90dG9tOiA2cHggc29saWQgYmxhY2s7XG5cblx0XHQuYmFyIHtcblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdFx0cGFkZGluZzogdmFyKC0tdWktcGFkZGluZyk7XG5cblx0XHRcdC5sZWZ0IHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0Z2FwOiAwLjVleDtcblxuXHRcdFx0XHQ+LnRpdGxlIHtcblx0XHRcdFx0XHQuZm9udChyZWd1bGFyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4uaW5mbyB7XG5cdFx0XHRcdFx0LmZvbnQodGlueSk7XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQucmlnaHQge1xuXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LnR4bi10eXBlLmljb24ge1xuXHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdFx0LS1pY29uLWRpYW1ldGVyOiAxOHB4O1xuXHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHR9XG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdIb2xkaW5nVmlldycgbmF2IHNsaWRlcz5cblx0PEhlYWRlciBwb3BzIGFjY291bnQgbmV0d29ya1xuXHRcdHRpdGxlPXtzX3N5bWJvbH1cblx0XHRzdWJ0aXRsZT17c19uYW1lfVxuXHQ+XG5cdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwidGl0bGVcIj5cblxuXHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHQ8L0hlYWRlcj5cblxuXHQ8UG9ydHJhaXRcblx0XHRwZnA9e3BfcGZwfVxuXHRcdHJlc291cmNlPXtnX2NvaW4gfHwgZ190b2tlbiB8fCBudWxsfVxuXHRcdHJlc291cmNlUGF0aD17cF9lbnRpdHl9XG5cdFx0dGl0bGU9e3lnX2Ftb3VudD8gYCR7Zm9ybWF0X2Ftb3VudCh5Z19hbW91bnQudG9OdW1iZXIoKSl9ICR7c19zeW1ib2x9YDogJy4uLid9XG5cdFx0c3VidGl0bGU9e2Ake3NfZmlhdH0gKCR7c193b3J0aH0gcGVyICR7c2lfdHlwZX0pYH1cblx0XHRhY3Rpb25zPXtnY19hY3Rpb25zfVxuXHRcdGNpcmN1bGFyXG5cdC8+XG5cblx0PGRpdiBjbGFzcz1cInR4bnMgbm8tbWFyZ2luXCI+XG5cblx0XHQ8IS0tIHsjaWYga19pYmN0X25hdGl2ZX1cblx0XHRcdDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJiYXJcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImxlZnRcIj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJsYWJlbFwiPlxuXHRcdFx0XHRcdFx0XHRTdGFrZVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdFx0XHRFYXJuIHVwIHRvIDI0JSBwZXIgeWVhclxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwicmlnaHRcIj5cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJwaWxsXCI+XG5cdFx0XHRcdFx0XHRcdFN0YWtlIHtnZF90b2tlbi5zeW1ib2x9XG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQgLS0+XG5cdFx0PCEtLSB7OmVsc2UgaWYgJHl3X2NoYWluLmRlZi5pZC5zdGFydHNXaXRoKCdzZWNyZXQtJyl9IC0tPlxuPCEtLSBcblx0XHRcdDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJiYXJcIiBzdHlsZT17YV9hbGxvd2FuY2VzLmxlbmd0aD8gXCJib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcIjogJyd9PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwibGVmdFwiPlxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxhYmVsXCI+XG5cdFx0XHRcdFx0XHRcdEFsbG93YW5jZXMgKHtnZF90b2tlbi5hbGxvd2FuY2VzLmxlbmd0aH0pXG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0XHRcdEFjY291bnRzIGFsbG93ZWQgdG8gc3BlbmQgdGhpcyB0b2tlblxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwicmlnaHRcIj5cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9XCJwaWxsXCIgb246Y2xpY2s9eygpID0+IHB1c2hfc2NyZWVuKERlYWRFbmQpfT5cblx0XHRcdFx0XHRcdFx0TWFuYWdlXG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdHsjZWFjaCBhX2FsbG93YW5jZXMgYXMgZ19hbGxvd2FuY2UsIGlfYWxsb3dhbmNlfVxuXHRcdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRcdG5hbWU9e2dfYWxsb3dhbmNlLmtfc3BlbmRlci5kZWYubGFiZWx9XG5cdFx0XHRcdFx0XHRhZGRyZXNzPXtnX2FsbG93YW5jZS5rX3NwZW5kZXIuZGVmLmFkZHJlc3N9XG5cdFx0XHRcdFx0XHRhbW91bnQ9e2dfYWxsb3dhbmNlLnNfYW1vdW50fVxuXHRcdFx0XHRcdFx0ZmlhdD17Z19hbGxvd2FuY2Uuc19leHBpcnl9XG5cdFx0XHRcdFx0XHRpY29uUmVmPXtnX2FsbG93YW5jZS5rX3NwZW5kZXIuZGVmLmljb25SZWZ9XG5cdFx0XHRcdFx0XHRpY29uQ2xhc3M9J3NpdGUnXG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4gcHVzaF9zY3JlZW4oRGVhZEVuZCl9XG5cdFx0XHRcdFx0XHRyb290U3R5bGU9e2lfYWxsb3dhbmNlID09PSBhX2FsbG93YW5jZXMubGVuZ3RoLTE/ICdib3JkZXItYm90dG9tOiBub25lOyc6ICcnfVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0ey9lYWNofVxuXHRcdFx0PC9kaXY+IC0tPlxuXG5cdFx0PCEtLSB7L2lmfSAtLT5cbjwhLS0gXG5cdFx0eyNlYWNoIGFfaGlzdG9yeSBhcyBrX3R4bn1cblx0XHRcdHtAY29uc3QgZ19iYW5raXNoID0ga190eG4uYmFua2lzaCgkeXdfYWNjb3VudC5hZGRyZXNzKCR5d19jaGFpbikpfVxuXHRcdFx0e0Bjb25zdCBnZF90eG4gPSBrX3R4bi5kZWZ9XG5cdFx0XHR7QGNvbnN0IGdfZGV0YWlsID0gZGV0YWlsX2Jhbmtpc2goZ19iYW5raXNoKX1cblxuXHRcdFx0eyNpZiBnX2Jhbmtpc2h9XG5cdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRpY29uPXtIX1RYTl9JQ09OU1tnX2Jhbmtpc2gudHlwZV19XG5cdFx0XHRcdFx0aWNvbkNsYXNzPXtIX1RYTl9DTEFTU0VTW2dfYmFua2lzaC50eXBlXSB8fCAnJ31cblx0XHRcdFx0XHRuYW1lPXtIX1NVTU1BUklaRVJTW2dfYmFua2lzaC50eXBlXShrX3R4bil9XG5cdFx0XHRcdFx0YWRkcmVzcz17Z19iYW5raXNoLmFkZHJlc3N9XG5cdFx0XHRcdFx0ZGV0YWlsPXtnX2RldGFpbC5uYW1lfVxuXHRcdFx0XHRcdHByZWZpeD17Z19kZXRhaWwucHJlZml4fVxuXHRcdFx0XHRcdGFtb3VudD17Zm9ybWF0X2Ftb3VudChrX3Rva2VuLmFwcHJveChnX2Jhbmtpc2guYW1vdW50KSl9XG5cdFx0XHRcdFx0ZmlhdD17YW1vdW50X3RvX2ZpYXQoa190b2tlbi5hcHByb3goZ19iYW5raXNoLmFtb3VudCksIGtfdG9rZW4pfVxuXHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiBwdXNoX3NjcmVlbihEZWFkRW5kKX1cblx0XHRcdFx0PlxuXHRcdFx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cImRldGFpbFwiPlxuXHRcdFx0XHRcdFx0eyNpZiBnX2RldGFpbC5pY29ufVxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInR4bi10eXBlIGljb25cIj5cblx0XHRcdFx0XHRcdFx0XHR7QGh0bWwgZ19kZXRhaWwuaWNvbn1cblx0XHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHRcdHsjaWYgZ19kZXRhaWwubmFtZX1cblx0XHRcdFx0XHRcdFx0e2dfZGV0YWlsLm5hbWV9XG5cdFx0XHRcdFx0XHR7OmVsc2UgaWYgZ19iYW5raXNoLmFkZHJlc3N9XG5cdFx0XHRcdFx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9e2dfYmFua2lzaC5hZGRyZXNzfSAvPlxuXHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdFx0PC9Sb3c+XG5cdFx0XHR7OmVsc2V9XG5cdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRpY29uPXtIX1RYTl9JQ09OU1tnZF90eG4udHlwZV19XG5cdFx0XHRcdFx0aWNvbkNsYXNzPXtIX1RYTl9DTEFTU0VTW2dkX3R4bi50eXBlXSB8fCAnJ31cblx0XHRcdFx0XHRuYW1lPXtIX1NVTU1BUklaRVJTW2dkX3R4bi50eXBlXShrX3R4bil9XG5cdFx0XHRcdFx0YWRkcmVzcz17Z2RfdHhuLmFkZHJlc3N9XG5cdFx0XHRcdFx0YW1vdW50PXtmb3JtYXRfYW1vdW50KGtfdG9rZW4uYXBwcm94KGdkX3R4bi5hbW91bnQpKX1cblx0XHRcdFx0XHRmaWF0PXthbW91bnRfdG9fZmlhdChrX3Rva2VuLmFwcHJveChnZF90eG4uYW1vdW50KSwga190b2tlbil9XG5cdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHB1c2hfc2NyZWVuKERlYWRFbmQpfVxuXHRcdFx0XHQvPlxuXHRcdFx0ey9pZn1cblx0XHR7L2VhY2h9IC0tPlxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB0eXBlIHsgVG9rZW5TcGVjS2V5IH0gZnJvbSAnIy9tZXRhL3Rva2VuJztcblxuXHRpbXBvcnQgeyBFbnRpdGllcywgVG9rZW5EaWN0IH0gZnJvbSAnIy9zdG9yZS9lbnRpdGllcyc7XG5cdGltcG9ydCB7IERpY3QsIGZvcmV2ZXIsIG9kZSwgb2Rlcm9tLCBQcm9taXNhYmxlIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IHsgeXdfYWNjb3VudCwgeXdfYWNjb3VudF9yZWYsIHl3X2NoYWluLCB5d19jaGFpbl9yZWYsIHl3X3BvcHVwLCB5d19jb250ZXh0X3BvcHVwLCBwb3B1cF9yZWNlaXZlLCB5d19uZXR3b3JrLCB5d19uZXR3b3JrX2FjdGl2ZSwgeXdfb3duZXIgfSBmcm9tICcuLi9tZW0nO1xuXHRpbXBvcnQgUG9ydHJhaXQgZnJvbSAnLi4vdWkvUG9ydHJhaXQuc3ZlbHRlJztcblx0aW1wb3J0IFNlbmQgZnJvbSAnLi9TZW5kLnN2ZWx0ZSc7XG5cdGltcG9ydCBQb3B1cFJlY2VpdmUgZnJvbSAnLi4vdWkvUG9wdXBSZWNlaXZlLnN2ZWx0ZSc7XG5cdGltcG9ydCBSb3cgZnJvbSAnLi4vdWkvUm93LnN2ZWx0ZSc7XG5cdGltcG9ydCB7IEhlYWRlciwgU2NyZWVuLCB0eXBlIFBhZ2UgfSBmcm9tICcuL19zY3JlZW5zJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQgeyBDb2luR2Vja28gfSBmcm9tICcjL3N0b3JlL3dlYi1hcGlzJztcblx0aW1wb3J0IHsgZm9ybWF0X2Ftb3VudCwgZm9ybWF0X2ZpYXQgfSBmcm9tICcjL3V0aWwvZm9ybWF0Jztcblx0aW1wb3J0IHR5cGUgeyBDb2luIH0gZnJvbSAnY29zbW9zLWdycGMvZGlzdC9jb3Ntb3MvYmFzZS92MWJldGExL2NvaW4nO1xuXHRpbXBvcnQgdHlwZSB7IENoYWluLCBOYXRpdmVDb2luIH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IHR5cGUgeyBWYWx1ZXMgfSBmcm9tICcjL21ldGEvYmVsdCc7XG5cdGltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi4vdWkvQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgR2FwIGZyb20gJy4uL3VpL0dhcC5zdmVsdGUnO1xuXHRpbXBvcnQgeyBvcGVuX2V4dGVybmFsX2xpbmsgfSBmcm9tICcjL3V0aWwvZG9tJztcblx0aW1wb3J0IFRva2Vuc0FkZCBmcm9tICcuL1Rva2Vuc0FkZC5zdmVsdGUnO1xuXHRpbXBvcnQgeyBhc19hbW91bnQsIHRvX2ZpYXQgfSBmcm9tICcjL2NoYWluL2NvaW4nO1xuXHRpbXBvcnQgSG9sZGluZ1ZpZXcgZnJvbSAnLi9Ib2xkaW5nVmlldy5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IEJhbGFuY2VCdW5kbGUgfSBmcm9tICcjL3N0b3JlL25ldHdvcmtzJztcblx0aW1wb3J0IHsgc3lzZXJyIH0gZnJvbSAnLi4vY29tbW9uJztcblx0aW1wb3J0IHsgQWNjb3VudHMgfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblxuXHQvLyAkOiBzYV9vd25lciA9IENoYWlucy5hZGRyZXNzRm9yKCR5d19hY2NvdW50LnB1YmtleSwgJHl3X2NoYWluKTtcblxuXHRjb25zdCBtZXJnZV9mdW5naWJsZV90b2tlbnMgPSAoaF9mdW5naWJsZXM6IFJlY29yZDxUb2tlblNwZWNLZXksIFRva2VuRGljdD4pID0+IG9kZXJvbShoX2Z1bmdpYmxlcywgKF8sIGgpID0+IGgpO1xuXG5cdC8vIGdldCBwYWdlIGZyb20gY29udGV4dFxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0bGV0IHlnX3RvdGFsID0gbmV3IEJpZ051bWJlcigwKTtcblx0bGV0IGNfYmFsYW5jZXMgPSAwO1xuXHRsZXQgYl9iYWxhbmNlc19yZWFkeSA9IHRydWU7XG5cdGxldCBhX25vX2dhczogc3RyaW5nW10gPSBbXTtcblxuXHRsZXQgZmtfcmVzb2x2ZV90b3RhbDogKHNfdG90YWw6IHN0cmluZykgPT4gdm9pZDtcblx0bGV0IGRwX3RvdGFsID0gbmV3IFByb21pc2U8c3RyaW5nPigoZmtfcmVzb2x2ZSkgPT4ge1xuXHRcdGZrX3Jlc29sdmVfdG90YWwgPSBma19yZXNvbHZlO1xuXHR9KTtcblxuXHRsZXQgZ19jaGFpbl9jYWNoZWQgPSAkeXdfY2hhaW47XG5cdCQ6IHtcblx0XHRpZigkeXdfY2hhaW4gIT09IGdfY2hhaW5fY2FjaGVkKSB7XG5cdFx0XHRnX2NoYWluX2NhY2hlZCA9ICR5d19jaGFpbjtcblx0XHRcdHlnX3RvdGFsID0gbmV3IEJpZ051bWJlcigwKTtcblx0XHRcdGNfYmFsYW5jZXMgPSAwO1xuXHRcdFx0ZHBfdG90YWwgPSBuZXcgUHJvbWlzZTxzdHJpbmc+KChma19yZXNvbHZlKSA9PiB7XG5cdFx0XHRcdGZrX3Jlc29sdmVfdG90YWwgPSBma19yZXNvbHZlO1xuXHRcdFx0fSk7XG5cdFx0XHRhX25vX2dhcyA9IFtdO1xuXHRcdH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gY2hlY2tfdG90YWwoKSB7XG5cdFx0Y19iYWxhbmNlcyAtPSAxO1xuXHRcdGlmKGJfYmFsYW5jZXNfcmVhZHkgJiYgIWNfYmFsYW5jZXMpIHtcblx0XHRcdGNvbnN0IHNfdG90YWwgPSBmb3JtYXRfZmlhdCh5Z190b3RhbC50b051bWJlcigpLCAndXNkJyk7XG5cdFx0XHRma19yZXNvbHZlX3RvdGFsKHNfdG90YWwpO1xuXG5cdFx0XHQvLyBzYXZlIHRvIGNhY2hlXG5cdFx0XHRjb25zdCBnX2FjY291bnQgPSAkeXdfYWNjb3VudDtcblx0XHRcdHZvaWQgQWNjb3VudHMub3BlbihrcyA9PiBrcy5wdXQoe1xuXHRcdFx0XHQuLi5nX2FjY291bnQsXG5cdFx0XHRcdGV4dHJhOiB7XG5cdFx0XHRcdFx0dG90YWxfZmlhdF9jYWNoZTogc190b3RhbCxcblx0XHRcdFx0fSxcblx0XHRcdH0pKTtcblx0XHR9XG5cdH1cblxuXHR0eXBlIFN1Ym1pdHRlciA9ICh6X291dDogUHJvbWlzYWJsZTxCaWdOdW1iZXI+KSA9PiBQcm9taXNlPEJpZ051bWJlcj47XG5cblx0Ly8gYXN5bmMgZnVuY3Rpb24gd2l0aF9iYWxhbmNlPHdfdmFsdWU+KGRwX3RoaW5nOiBQcm9taXNhYmxlPHdfdmFsdWU+KTogUHJvbWlzZTxbd192YWx1ZSwgU3VibWl0dGVyXT4ge1xuXHQvLyBcdGNfYmFsYW5jZXMgKz0gMTtcblxuXHQvLyBcdGNvbnN0IHdfdmFsdWUgPSBhd2FpdCBkcF90aGluZztcblxuXHQvLyBcdHJldHVybiBbXG5cdC8vIFx0XHR3X3ZhbHVlLFxuXHQvLyBcdFx0YXN5bmMoel9vdXQ6IFByb21pc2FibGU8QmlnTnVtYmVyPik6IFByb21pc2U8QmlnTnVtYmVyPiA9PiB7XG5cdC8vIFx0XHRcdGNvbnN0IHlnX2JhbGFuY2UgPSBhd2FpdCB6X291dDtcblxuXHQvLyBcdFx0XHR5Z190b3RhbCA9IHlnX3RvdGFsLnBsdXMoeWdfYmFsYW5jZSk7XG5cblx0Ly8gXHRcdFx0Y2hlY2tfdG90YWwoKTtcblx0Ly8gXHRcdFx0cmV0dXJuIHlnX2JhbGFuY2U7XG5cdC8vIFx0XHR9LFxuXHQvLyBcdF07XG5cdC8vIH1cblxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX25hdGl2ZV9iYWxhbmNlcygpIHtcblx0XHRsZXQgaF9iYWxhbmNlczogRGljdDxCYWxhbmNlQnVuZGxlPjtcblx0XHR0cnkge1xuXHRcdFx0aF9iYWxhbmNlcyA9IGF3YWl0ICR5d19uZXR3b3JrX2FjdGl2ZS5iYW5rQmFsYW5jZXMoJHl3X293bmVyKTtcblx0XHR9XG5cdFx0Y2F0Y2goZV9uZXR3b3JrKSB7XG5cdFx0XHRzeXNlcnIoe1xuXHRcdFx0XHRlcnJvcjogZV9uZXR3b3JrIGFzIEVycm9yLFxuXHRcdFx0XHR0ZXh0OiAnTmV0d29yayBlcnJvcicsXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHRjb25zdCBhX291dHM6IFtzdHJpbmcsIE5hdGl2ZUNvaW4sIENvaW4sIFN1Ym1pdHRlcl1bXSA9IFtdO1xuXG5cdFx0Zm9yKGNvbnN0IFtzaV9jb2luLCBnX2NvaW5dIG9mIG9kZSgkeXdfY2hhaW4uY29pbnMpKSB7XG5cdFx0XHRjb25zdCBnX2J1bmRsZSA9IGhfYmFsYW5jZXNbc2lfY29pbl07XG5cblx0XHRcdGlmKCFnX2J1bmRsZSB8fCAnMCcgPT09IGdfYnVuZGxlLmJhbGFuY2UuYW1vdW50KSB7XG5cdFx0XHRcdGFfbm9fZ2FzLnB1c2goc2lfY29pbik7XG5cdFx0XHR9XG5cblx0XHRcdGNfYmFsYW5jZXMgKz0gMTtcblxuXHRcdFx0YV9vdXRzLnB1c2goW1xuXHRcdFx0XHRzaV9jb2luLFxuXHRcdFx0XHQkeXdfY2hhaW4uY29pbnNbc2lfY29pbl0sXG5cdFx0XHRcdGdfYnVuZGxlPy5iYWxhbmNlIHx8IHthbW91bnQ6JzAnLCBkZW5vbTpnX2NvaW4uZGVub219LFxuXHRcdFx0XHRhc3luYyh6X291dDogUHJvbWlzYWJsZTxCaWdOdW1iZXI+KTogUHJvbWlzZTxCaWdOdW1iZXI+ID0+IHtcblx0XHRcdFx0XHRjb25zdCB5Z19iYWxhbmNlID0gYXdhaXQgel9vdXQ7XG5cblx0XHRcdFx0XHR5Z190b3RhbCA9IHlnX3RvdGFsLnBsdXMoeWdfYmFsYW5jZSk7XG5cblx0XHRcdFx0XHRjaGVja190b3RhbCgpO1xuXHRcdFx0XHRcdHJldHVybiB5Z19iYWxhbmNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0aWYoIWFfb3V0cy5sZW5ndGgpIHtcblx0XHRcdGNfYmFsYW5jZXMgKz0gMTtcblx0XHRcdGNoZWNrX3RvdGFsKCk7XG5cdFx0fVxuXG5cdFx0YV9ub19nYXMgPSBhX25vX2dhcztcblxuXHRcdHJldHVybiBhX291dHM7XG5cdH1cblxuXG5cdGNvbnN0IEhfRkFVQ0VUUyA9IHtcblx0XHQndGhldGEtdGVzdG5ldC0wMDEnOiAnaHR0cHM6Ly9kaXNjb3JkLmNvbS9jaGFubmVscy82NjkyNjgzNDc3MzY2ODY2MTIvOTUzNjk3NzkzNDc2ODIxMDkyJyxcblx0XHQncHVsc2FyLTInOiAnaHR0cHM6Ly9mYXVjZXQuc2VjcmV0dGVzdG5ldC5pby8nLFxuXHR9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdC50ZXN0bmV0LXJlbWluZGVyIHtcblx0XHQuZm9udCh0aW55KTtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHR0cmFuc2Zvcm06IHNjYWxlWCgxLjI1KTtcblx0XHRtYXJnaW4tYm90dG9tOiBjYWxjKDBweCAtIHZhcigtLXVpLXBhZGRpbmcpIC0gdmFyKC0taW5saW5lLXBhZGRpbmcpKTtcblx0fVxuXG5cdC5zdWJpbmZvIHtcblx0XHRib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRwYWRkaW5nLXRvcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdH1cblxuXHQubm8tZ2FzIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG5cdFx0Z2FwOiB2YXIoLS1pbmxpbmUtcGFkZGluZyk7XG5cdFx0Lm1lc3NhZ2Uge1xuXHRcdFx0LmZvbnQodGlueSk7XG5cdFx0fVxuXHR9XG5cblx0Lm93bmVyLWFkZHJlc3Mge1xuXHR9XG5cbjwvc3R5bGU+XG5cbjxTY3JlZW4gZGVidWc9J0hvbGRpbmdzSG9tZScgbmF2IHJvb3Qga2V5ZWQ+XG5cblx0PEhlYWRlciBzZWFyY2ggbmV0d29yayBhY2NvdW50ID5cblx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJ0aXRsZVwiPlxuXG5cdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdDwvSGVhZGVyPlxuXG5cdHsjaWYgJHl3X2NoYWluLnRlc3RuZXR9XG5cdFx0PGRpdiBjbGFzcz1cInRlc3RuZXQtcmVtaW5kZXIgbm8tbWFyZ2luXCI+XG5cdFx0XHRURVNFVE5FVFxuXHRcdDwvZGl2PlxuXHR7L2lmfVxuXG5cdDwhLS0gdGl0bGU9e2Zvcm1hdF9maWF0KHhfdXNkX2JhbGFuY2UpfSAtLT5cblx0PFBvcnRyYWl0XG5cdFx0bm9QZnBcblx0XHR0aXRsZT17ZHBfdG90YWx9XG5cdFx0c3VidGl0bGU9eyR5d19hY2NvdW50Lm5hbWV9XG5cdFx0cmVzb3VyY2U9eyR5d19hY2NvdW50fVxuXHRcdHJlc291cmNlUGF0aD17JHl3X2FjY291bnRfcmVmfVxuXHRcdGFjdGlvbnM9e3tcblx0XHRcdHNlbmQ6IHtcblx0XHRcdFx0bGFiZWw6ICdTZW5kJyxcblx0XHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRjcmVhdG9yOiBTZW5kLFxuXHRcdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdFx0ZnJvbTogJHl3X2FjY291bnQsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblx0XHRcdHJlY3Y6IHtcblx0XHRcdFx0bGFiZWw6ICdSZWNlaXZlJyxcblx0XHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0XHRwb3B1cF9yZWNlaXZlKCR5d19hY2NvdW50X3JlZik7XG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdFx0Ly8gYWRkOiB7XG5cdFx0XHQvLyBcdGxhYmVsOiAnQWRkIFRva2VuJyxcblx0XHRcdC8vIFx0dHJpZ2dlcigpIHtcblx0XHRcdC8vIFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHQvLyBcdFx0XHRjcmVhdG9yOiBUb2tlbnNBZGQsXG5cdFx0XHQvLyBcdFx0fSk7XG5cdFx0XHQvLyBcdH0sXG5cdFx0XHQvLyB9LFxuXHRcdH19XG5cdC8+XG5cblx0eyNrZXkgJHl3X2NoYWlufVxuXHRcdHsjaWYgYV9ub19nYXMubGVuZ3RofVxuXHRcdFx0PGRpdiBjbGFzcz1cIm5vLWdhcyB0ZXh0LWFsaWduX2NlbnRlciBzdWJpbmZvXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJtZXNzYWdlXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+V2FybmluZzo8L3NwYW4+IHlvdSBkb24ndCBoYXZlIGFueSB7JHl3X2NoYWluLnRlc3RuZXQ/ICd0ZXN0bmV0ICc6Jyd9e2Ffbm9fZ2FzLmpvaW4oJyBvciAnKX0gdG8gcGF5IGdhcyBmZWVzLlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYnV0dG9uc1wiPlxuXHRcdFx0XHRcdHsjaWYgJHl3X2NoYWluLnRlc3RuZXR9XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwicGlsbFwiIG9uOmNsaWNrPXsoKSA9PiBvcGVuX2V4dGVybmFsX2xpbmsoSF9GQVVDRVRTWyR5d19jaGFpbi5pZF0pfT5HZXQge2Ffbm9fZ2FzLmpvaW4oJyBvciAnKX0gZnJvbSBmYXVjZXQ8L2J1dHRvbj5cblx0XHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwicGlsbFwiPkJ1eSB7YV9ub19nYXMuam9pbignIG9yICcpfTwvYnV0dG9uPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0ey9pZn1cblxuXHRcdDxkaXYgY2xhc3M9XCJvd25lci1hZGRyZXNzIHN1YmluZm9cIj5cblx0XHRcdDxBZGRyZXNzIGFkZHJlc3M9eyR5d19vd25lcn0gY29weWFibGU9J3RleHQnIC8+XG5cdFx0PC9kaXY+XG5cdHsva2V5fVxuXG5cblx0PEdhcCAvPlxuXG5cdDwhLS0geyNrZXkgYV9ob2xkaW5nc31cblx0XHQ8SG9sZGluZ3NMaXN0IGhvbGRpbmdzPXthX2hvbGRpbmdzfSAvPlxuXHR7L2tleX0gLS0+XG5cblx0eyNrZXkgJHl3X25ldHdvcmtfYWN0aXZlfVxuXHRcdDxkaXYgY2xhc3M9XCJyb3dzIG5vLW1hcmdpblwiPlxuXHRcdFx0PCEtLSBuYXRpdmUgY29pbihzKSAtLT5cblx0XHRcdHsjYXdhaXQgbG9hZF9uYXRpdmVfYmFsYW5jZXMoKX1cblx0XHRcdFx0eyNlYWNoIG9kZSgkeXdfY2hhaW4uY29pbnMpIGFzIFtzaV9jb2luLCBnX2J1bmRsZV19XG5cdFx0XHRcdFx0e0Bjb25zdCBwX2VudGl0eSA9IEVudGl0aWVzLmhvbGRpbmdQYXRoRm9yKCR5d19vd25lciwgc2lfY29pbil9XG5cdFx0XHRcdFx0PFJvdyBsb2NrSWNvbiBkZXRhaWw9J05hdGl2ZSBDb2luJ1xuXHRcdFx0XHRcdFx0bmFtZT17c2lfY29pbn1cblx0XHRcdFx0XHRcdHBmcD17JHl3X2NoYWluLnBmcH1cblx0XHRcdFx0XHRcdGFtb3VudD17Zm9yZXZlcignJyl9XG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0Y3JlYXRvcjogSG9sZGluZ1ZpZXcsXG5cdFx0XHRcdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGVudGl0eVJlZjogcF9lbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHs6dGhlbiBhX2JhbGFuY2VzfVxuXHRcdFx0XHR7I2VhY2ggYV9iYWxhbmNlcyBhcyBbc2lfY29pbiwgZ19jb2luLCBnX2JhbGFuY2UsIGZfc3VibWl0XX1cblx0XHRcdFx0e0Bjb25zdCBwX2VudGl0eSA9IEVudGl0aWVzLmhvbGRpbmdQYXRoRm9yKCR5d19vd25lciwgc2lfY29pbil9XG5cdFx0XHRcdFx0e0Bjb25zdCBnX3Jlc291cmNlID0ge1xuXHRcdFx0XHRcdFx0bmFtZTogc2lfY29pbixcblx0XHRcdFx0XHRcdHBmcDogJHl3X2NoYWluLnBmcCxcblx0XHRcdFx0XHR9fVxuXHRcdFx0XHRcdHtAY29uc3QgZHBfd29ydGggPSBmX3N1Ym1pdCh0b19maWF0KGdfYmFsYW5jZSwgZ19jb2luKSl9XG5cdFx0XHRcdFx0PFJvdyBsb2NrSWNvbiBkZXRhaWw9J05hdGl2ZSBDb2luJ1xuXHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoPXtwX2VudGl0eX1cblx0XHRcdFx0XHRcdHJlc291cmNlPXtnX3Jlc291cmNlfVxuXHRcdFx0XHRcdFx0YW1vdW50PXthc19hbW91bnQoZ19iYWxhbmNlLCBnX2NvaW4pfVxuXHRcdFx0XHRcdFx0ZmlhdD17ZHBfd29ydGgudGhlbih5ZyA9PiBmb3JtYXRfZmlhdCh5Zy50b051bWJlcigpLCAndXNkJykpfVxuXHRcdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdGNyZWF0b3I6IEhvbGRpbmdWaWV3LFxuXHRcdFx0XHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbnRpdHlSZWY6IHBfZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR7L2VhY2h9XG5cdFx0XHR7L2F3YWl0fVxuXG5cblx0XHRcdHsjYXdhaXQgRW50aXRpZXMucmVhZEZ1bmdpYmxlVG9rZW5zKCR5d19jaGFpbil9XG5cdFx0XHRcdExvYWRpbmcgdG9rZW5zLi4uXG5cdFx0XHR7OnRoZW4gaF9mdW5naWJsZXN9XG5cdFx0XHRcdHsjZWFjaCBvZGUobWVyZ2VfZnVuZ2libGVfdG9rZW5zKGhfZnVuZ2libGVzKSkgYXMgW3BfdG9rZW4sIGdfdG9rZW5dfVxuXHRcdFx0XHRcdHtnX3Rva2VuLnNwZWN9XG5cdFx0XHRcdHsvZWFjaH1cblx0XHRcdHsvYXdhaXR9XG5cdFx0PC9kaXY+XG5cdHsva2V5fVxuPC9TY3JlZW4+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuXHRpbXBvcnQgdHlwZSB7IENvbXBsZXRlZCB9IGZyb20gJyMvZW50cnkvZmxvdyc7XG5cblx0aW1wb3J0IHR5cGUge0FjY291bnQsIEFjY291bnRQYXRofSBmcm9tICcjL21ldGEvYWNjb3VudCc7XG5cdGltcG9ydCB0eXBlIHtCZWNoMzJ9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5cdGltcG9ydCB7QWNjb3VudHN9IGZyb20gJyMvc3RvcmUvYWNjb3VudHMnO1xuXHRpbXBvcnQge0NoYWluc30gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQge3l3X2FjY291bnRfcmVmLCB5d19jaGFpbn0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IEFjdGlvbnNMaW5lIGZyb20gJy4uL3VpL0FjdGlvbnNMaW5lLnN2ZWx0ZSc7XG5cdGltcG9ydCBBZGRyZXNzIGZyb20gJy4uL3VpL0FkZHJlc3Muc3ZlbHRlJztcblx0aW1wb3J0IEZpZWxkIGZyb20gJy4uL3VpL0ZpZWxkLnN2ZWx0ZSc7XG5cdGltcG9ydCBJbmxpbmVUYWdzIGZyb20gJy4uL3VpL0lubGluZVRhZ3Muc3ZlbHRlJztcblx0aW1wb3J0IEluZm8gZnJvbSAnIyMvdWkvSW5mby5zdmVsdGUnO1xuXHRpbXBvcnQge1NjcmVlbiwgdHlwZSBQYWdlfSBmcm9tICcuL19zY3JlZW5zJztcblxuXG5cdGV4cG9ydCBsZXQgYWNjb3VudDogQWNjb3VudFBhdGg7XG5cdGNvbnN0IHBfYWNjb3VudCA9IGFjY291bnQ7XG5cblx0bGV0IGdfYWNjb3VudDogQWNjb3VudFsnaW50ZXJmYWNlJ107XG5cblx0bGV0IHNfbmFtZSA9ICcnO1xuXHRsZXQgc2FfYWNjb3VudDogQmVjaDMyLlN0cmluZztcblxuXHQkOiBiX2Zvcm1fdmFsaWQgPSAhIXNfbmFtZTtcblxuXHQkOiBzYV9hY2NvdW50ID0gZ19hY2NvdW50PyBDaGFpbnMuYWRkcmVzc0ZvcihnX2FjY291bnQucHVia2V5LCAkeXdfY2hhaW4pOiAnJztcblxuXHRjb25zdCBjb21wbGV0ZWQgPSBnZXRDb250ZXh0PENvbXBsZXRlZCB8IHVuZGVmaW5lZD4oJ2NvbXBsZXRlZCcpO1xuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9hY2NvdW50KCkge1xuXHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXHRcdGdfYWNjb3VudCA9IGtzX2FjY291bnRzLmF0KHBfYWNjb3VudCkhO1xuXHRcdHNfbmFtZSA9IGdfYWNjb3VudC5uYW1lO1xuXHR9XG5cblx0YXN5bmMgZnVuY3Rpb24gc2F2ZV9hY2NvdW50KCkge1xuXHRcdE9iamVjdC5hc3NpZ24oZ19hY2NvdW50LCB7XG5cdFx0XHRuYW1lOiBzX25hbWUsXG5cdFx0fSk7XG5cblx0XHRhd2FpdCBBY2NvdW50cy5vcGVuKGtzX2FjY291bnRzID0+IGtzX2FjY291bnRzLnB1dChnX2FjY291bnQpKTtcblxuXHRcdC8vIGVkaXR0ZWQgYWN0aXZlIGFjY291bnQ7IHJlbG9hZFxuXHRcdGlmKHBfYWNjb3VudCA9PT0gJHl3X2FjY291bnRfcmVmKSB7XG5cdFx0XHQkeXdfYWNjb3VudF9yZWYgPSBwX2FjY291bnQ7XG5cdFx0fVxuXG5cdFx0aWYoY29tcGxldGVkKSB7XG5cdFx0XHRjb21wbGV0ZWQodHJ1ZSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0a19wYWdlLnJlc2V0KCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gZnVuY3Rpb24gc2F2ZSgpIHtcblx0Ly8gXHRpZighYl9mb3JtX3ZhbGlkKSByZXR1cm47XG5cblx0Ly8gXHRjb25zdCBnX3NhdmUgPSB7XG5cdC8vIFx0XHRsYWJlbDogYWNjb3VudE5hbWUsXG5cdC8vIFx0XHR0YWdSZWZzOiBhX3RhZ3MubWFwKGsgPT4gay5kZWYuaXJpKSxcblx0Ly8gXHR9O1xuXG5cdC8vIFx0aWYoYWNjb3VudCkge1xuXHQvLyBcdFx0T2JqZWN0LmFzc2lnbihhY2NvdW50LmRlZiwgZ19zYXZlKTtcblxuXHQvLyBcdFx0cmVzdGFydCgpO1xuXG5cdC8vIFx0XHRpZihUYXNrcy5BRERfVEFHID09PSAkeXdfdGFzaykge1xuXHQvLyBcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0Ly8gXHRcdFx0XHQkeXdfdGFzayA9IC0keXdfdGFzaztcblx0Ly8gXHRcdFx0fSwgMTIwMCk7XG5cdC8vIFx0XHR9XG5cdC8vIFx0fVxuXHQvLyBcdGVsc2Uge1xuXHQvLyBcdFx0Y29uc3QgZ2RfYWNjb3VudCA9IEFjY291bnQuRGVmLmZyb21Db25maWcoe1xuXHQvLyBcdFx0XHQuLi5nX3NhdmUsXG5cdC8vIFx0XHRcdHB1YmtleTogc2FfYWNjb3VudC5yZXBsYWNlKC9eXFx3KzEvZywgJycpLFxuXHQvLyBcdFx0XHRpY29uUmVmOiBwX2ljb24sXG5cdC8vIFx0XHR9KTtcblxuXHQvLyBcdFx0Y29uc3Qga19hY2NvdW50ID0gSF9BQ0NPVU5UU1tnZF9hY2NvdW50LmlyaV0gPSBuZXcgQWNjb3VudChnZF9hY2NvdW50KTtcblxuXHQvLyBcdFx0cmVzdGFydCgpO1xuXG5cdC8vIFx0XHRwdXNoX3NjcmVlbihBY2NvdW50Vmlldywge1xuXHQvLyBcdFx0XHRhY2NvdW50OiBrX2FjY291bnQsXG5cdC8vIFx0XHR9KTtcblx0Ly8gXHR9XG5cdC8vIH1cblxuPC9zY3JpcHQ+XG5cbjxTY3JlZW4+XG5cdDxoMz5cblx0XHR7YWNjb3VudD8gJ0VkaXQnOiAnTmV3J30gYWNjb3VudFxuXHQ8L2gzPlxuXG5cdHsjYXdhaXQgbG9hZF9hY2NvdW50KCl9XG5cdFx0TG9hZGluZyBhY2NvdW50cy4uLlxuXHR7OnRoZW59XG5cdFx0PEZpZWxkIGtleT1cInByb2ZpbGUtaWNvblwiIG5hbWU9XCJQcm9maWxlIGljb25cIj5cblx0XHRcdDwhLS0gPEljb25FZGl0b3IgaW50ZW50PSdwZXJzb24nIGljb25SZWY9e3BfaWNvbn0gLz4gLS0+XG5cdFx0PC9GaWVsZD5cblxuXHRcdDxGaWVsZCBrZXk9XCJhY2NvdW50LW5hbWVcIiBuYW1lPVwiTmFtZVwiPlxuXHRcdFx0PGlucHV0IGlkPVwiYWNjb3VudC1uYW1lXCIgdHlwZT1cInRleHRcIiBiaW5kOnZhbHVlPXtzX25hbWV9IHBsYWNlaG9sZGVyPVwiU2F0b3NoaVwiPlxuXHRcdDwvRmllbGQ+XG5cblx0XHQ8IS0tIDxGaWVsZCBrZXk9XCJhY2NvdW50LXBhdGhcIiBuYW1lPVwiRGVyaXZhdGlvbiBwYXRoXCI+XG5cdFx0XHQ8SW5mbyBrZXk9XCJhY2NvdW50LXBhdGhcIj5cblx0XHRcdFx0bS80NCcvMTE4Jy8wJy8wL3tPYmplY3QudmFsdWVzKEhfQUNDT1VOVFMpLmxlbmd0aH1cblx0XHRcdDwvSW5mbz5cblx0XHQ8L0ZpZWxkPiAtLT5cblxuXHRcdDxGaWVsZCBrZXk9XCJhY2NvdW50LWFkZHJlc3NcIiBuYW1lPVwiUHVibGljIGFkZHJlc3NcIj5cblx0XHRcdDxJbmZvIGFkZHJlc3Mga2V5PVwiYWNjb3VudC1hZGRyZXNzXCI+XG5cdFx0XHRcdDxBZGRyZXNzIGNvcHlhYmxlIGFkZHJlc3M9e3NhX2FjY291bnR9IC8+XG5cdFx0XHQ8L0luZm8+XG5cdFx0PC9GaWVsZD5cbjwhLS0gXG5cdFx0PEZpZWxkIGtleT1cImFjY291bnQtdGFnc1wiIG5hbWU9XCJBZGQgdGFnc1wiPlxuXHRcdFx0PElubGluZVRhZ3MgZWRpdGFibGUgcmVzb3VyY2VQYXRoPXtwX2FjY291bnR9IC8+XG5cdFx0PC9GaWVsZD4gLS0+XG5cblx0XHQ8QWN0aW9uc0xpbmUgY2FuY2VsPXshY29tcGxldGVkfSBiYWNrIGNvbmZpcm09e1snRmluaXNoJywgc2F2ZV9hY2NvdW50LCAhYl9mb3JtX3ZhbGlkXX0gLz5cblxuXHRcdDwhLS0gPGRpdiBjbGFzcz1cImFjdGlvbi1saW5lIGNsaWNrYWJsZVwiPlxuXHRcdFx0PGJ1dHRvbiBvbjpjbGljaz17KCkgPT4gcG9wKCl9PlxuXHRcdFx0XHRDYW5jZWxcblx0XHRcdDwvYnV0dG9uPlxuXG5cdFx0XHQ8YnV0dG9uIGNsYXNzPVwicHJpbWFyeVwiIHJlYWRvbmx5PXshYl9mb3JtX3ZhbGlkfSBvbjpjbGljaz17KCkgPT4gc2F2ZSgpfT5cblx0XHRcdFx0RmluaXNoXG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQ8L2Rpdj4gLS0+XG5cdHsvYXdhaXR9XG48L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgdHlwZSB7QWNjb3VudCwgQWNjb3VudFBhdGh9IGZyb20gJyMvbWV0YS9hY2NvdW50Jztcblx0aW1wb3J0IHtBY2NvdW50c30gZnJvbSAnIy9zdG9yZS9hY2NvdW50cyc7XG5cdGltcG9ydCB7Q2hhaW5zfSBmcm9tICcjL3N0b3JlL2NoYWlucyc7XG5cblx0aW1wb3J0IHtnZXRDb250ZXh0fSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQge3BvcHVwX3JlY2VpdmV9IGZyb20gJy4uL21lbSc7XG5cdGltcG9ydCBBZGRyZXNzIGZyb20gJy4uL3VpL0FkZHJlc3Muc3ZlbHRlJztcblx0aW1wb3J0IFBvcnRyYWl0IGZyb20gJy4uL3VpL1BvcnRyYWl0LnN2ZWx0ZSc7XG5cdGltcG9ydCBBY2NvdW50RWRpdCBmcm9tICcuL0FjY291bnRFZGl0LnN2ZWx0ZSc7XG5cdGltcG9ydCBTZW5kIGZyb20gJy4vU2VuZC5zdmVsdGUnO1xuXG5cdGltcG9ydCB7XG5cdFx0U2NyZWVuLFxuXHRcdEhlYWRlcixcblx0XHR0eXBlIFBhZ2UsXG5cdH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0ZXhwb3J0IGxldCBhY2NvdW50UmVmOiBBY2NvdW50UGF0aDtcblx0Y29uc3QgcF9hY2NvdW50ID0gYWNjb3VudFJlZjtcblxuXHRsZXQgZ19hY2NvdW50OiBBY2NvdW50WydpbnRlcmZhY2UnXTtcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblxuXHRhc3luYyBmdW5jdGlvbiBsb2FkX2FjY291bnQoKTogUHJvbWlzZTxBY2NvdW50WydpbnRlcmZhY2UnXT4ge1xuXHRcdGNvbnN0IGtzX2FjY291bnRzID0gYXdhaXQgQWNjb3VudHMucmVhZCgpO1xuXG5cdFx0cmV0dXJuIGdfYWNjb3VudCA9IGtzX2FjY291bnRzLmF0KHBfYWNjb3VudCkhO1xuXHR9XG5cblx0Y29uc3QgZ2NfYWN0aW9ucyA9IHtcblx0XHRzZW5kOiB7XG5cdFx0XHRsYWJlbDogJ1NlbmQnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IFNlbmQsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdGZyb206IENoYWlucy5hZGRyZXNzRm9yKGdfYWNjb3VudC5wdWJrZXkpLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRcdHJlY3Y6IHtcblx0XHRcdGxhYmVsOiAnUmVjZWl2ZScsXG5cdFx0XHR0cmlnZ2VyKCkge1xuXHRcdFx0XHRwb3B1cF9yZWNlaXZlKHBfYWNjb3VudCk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0ZWRpdDoge1xuXHRcdFx0bGFiZWw6ICdFZGl0Jyxcblx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBBY2NvdW50RWRpdCxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0YWNjb3VudDogcF9hY2NvdW50LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHR9O1xuXG48L3NjcmlwdD5cblxuPCEtLSBcbjxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInBmcFwiPlxuXHR7I2lmIEhfSUNPTlNbYWNjb3VudC5kZWYuaWNvblJlZl19XG5cdFx0PFB1dCBlbGVtZW50PXtIX0lDT05TW2FjY291bnQuZGVmLmljb25SZWZdLnJlbmRlcigpfSAvPlxuXHR7OmVsc2V9XG5cdFx0PHNwYW4gY2xhc3M9XCJwZnAtZ2VuXCI+XG5cdFx0XHR7YWNjb3VudC5kZWYubGFiZWxbMF19XG5cdFx0PC9zcGFuPlxuXHR7L2lmfVxuPC9zdmVsdGU6ZnJhZ21lbnQ+IC0tPlxuXG48U2NyZWVuIG5hdj5cblx0PEhlYWRlciBwb3BzIHNlYXJjaCBuZXR3b3JrXG5cdFx0dGl0bGU9XCJBY2NvdW50XCJcblx0PjwvSGVhZGVyPlxuXG5cdHsjYXdhaXQgbG9hZF9hY2NvdW50KCl9XG5cdFx0TG9hZGluZy4uLlxuXHR7OnRoZW59XG5cdFx0PFBvcnRyYWl0XG5cdFx0XHRyZXNvdXJjZT17Z19hY2NvdW50fVxuXHRcdFx0cmVzb3VyY2VQYXRoPXtwX2FjY291bnR9XG5cdFx0XHRhY3Rpb25zPXtnY19hY3Rpb25zfVxuXHRcdD5cblx0XHRcdDxzdmVsdGU6ZnJhZ21lbnQgc2xvdD1cInN1YnRpdGxlXCI+XG5cdFx0XHRcdDxBZGRyZXNzIGNvcHlhYmxlIGFkZHJlc3M9e0NoYWlucy5hZGRyZXNzRm9yKGdfYWNjb3VudC5wdWJrZXkpfSAvPlxuXHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdFx0PC9Qb3J0cmFpdD5cblx0ey9hd2FpdH1cblxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHR5cGUgeyBBY2NvdW50LCBBY2NvdW50UGF0aCB9IGZyb20gJyMvbWV0YS9hY2NvdW50Jztcblx0aW1wb3J0IHsgQWNjb3VudHMgfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHsgQ2hhaW5zIH0gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyB5d19jaGFpbiB9IGZyb20gJy4uL21lbSc7XG5cdGltcG9ydCBBZGRyZXNzIGZyb20gJy4uL3VpL0FkZHJlc3Muc3ZlbHRlJztcblx0aW1wb3J0IFJvdyBmcm9tICcuLi91aS9Sb3cuc3ZlbHRlJztcblx0aW1wb3J0IEFjY291bnRDcmVhdGUgZnJvbSAnLi9BY2NvdW50Q3JlYXRlLnN2ZWx0ZSc7XG5cdGltcG9ydCBBY2NvdW50VmlldyBmcm9tICcuL0FjY291bnRWaWV3LnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHtcblx0XHRTY3JlZW4sXG5cdFx0SGVhZGVyLFxuXHRcdFN1YkhlYWRlcixcblx0XHR0eXBlIFBhZ2UsXG5cdH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGxldCBhX2FjY291bnRzOiBbQWNjb3VudFBhdGgsIEFjY291bnRbJ2ludGVyZmFjZSddXVtdO1xuXHRhc3luYyBmdW5jdGlvbiBsb2FkX2FjY291bnRzKCk6IFByb21pc2U8dHlwZW9mIGFfYWNjb3VudHM+IHtcblx0XHRjb25zdCBrc19hY2NvdW50cyA9IGF3YWl0IEFjY291bnRzLnJlYWQoKTtcblxuXHRcdHJldHVybiBhX2FjY291bnRzID0ga3NfYWNjb3VudHMuZW50cmllcygpO1xuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cblx0LmhkLXBhdGgge1xuXHRcdDpnbG9iYWwoJikge1xuXHRcdFx0LmZvbnQodGlueSk7XG5cdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPFNjcmVlbiBkZWJ1Zz0nQWNjb3VudHMnIG5hdiByb290PlxuXHQ8SGVhZGVyIHNlYXJjaCBuZXR3b3JrIGFjY291bnRcblx0PlxuXHQ8L0hlYWRlcj5cblxuXHQ8U3ViSGVhZGVyXG5cdFx0dGl0bGU9XCJBY2NvdW50c1wiXG5cdC8+XG5cdFx0PCEtLSBvbjphZGRfbmV3PXsoKSA9PiBrX3BhZ2UucHVzaCh7XG5cdFx0XHRjcmVhdG9yOiBBY2NvdW50Q3JlYXRlLFxuXHRcdH0pfSAtLT5cblxuXHQ8ZGl2IGNsYXNzPVwicm93cyBuby1tYXJnaW5cIj5cblx0XHR7I2F3YWl0IGxvYWRfYWNjb3VudHMoKX1cblx0XHRcdExvYWRpbmcuLi5cblx0XHR7OnRoZW59XG5cdFx0XHR7I2tleSAkeXdfY2hhaW59XG5cdFx0XHRcdHsjZWFjaCBhX2FjY291bnRzIGFzIFtwX2FjY291bnQsIGdfYWNjb3VudF19XG5cdFx0XHRcdFx0e0Bjb25zdCBzYV9vd25lciA9IENoYWlucy5hZGRyZXNzRm9yKGdfYWNjb3VudC5wdWJrZXkpfVxuXHRcdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRcdHJlc291cmNlPXtnX2FjY291bnR9XG5cdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg9e3BfYWNjb3VudH1cblx0XHRcdFx0XHRcdGFkZHJlc3M9e3NhX293bmVyfVxuXHRcdFx0XHRcdFx0aWNvbkNsYXNzPXsnc3F1YXJlIHBmcCd9XG5cdFx0XHRcdFx0XHRvbjpjbGljaz17KCkgPT4ga19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRjcmVhdG9yOiBBY2NvdW50Vmlldyxcblx0XHRcdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdFx0XHRhY2NvdW50UmVmOiBwX2FjY291bnQsXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9KX1cblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJkZXRhaWxcIj5cblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImhkLXBhdGhcIj5cblx0XHRcdFx0XHRcdFx0XHRTdGFyU2hlbGwgLSAtIG0vNDQnLzExOCcvMCcvMC8/P1xuXHRcdFx0XHRcdFx0XHRcdDwhLS0gU3RhclNoZWxsIC0gbS80NCcvMTE4Jy8wJy8wL3srZ19hY2NvdW50LmlkLTF9IC0tPlxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXtzYV9vd25lcn0gLz5cblx0XHRcdFx0XHRcdDwvc3ZlbHRlOmZyYWdtZW50PlxuXHRcdFx0XHRcdDwvUm93PlxuXHRcdFx0XHR7L2VhY2h9XG5cdFx0XHR7L2tleX1cblx0XHR7L2F3YWl0fVxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsImxldCBpZCA9IDE7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldElkKCkge1xuICByZXR1cm4gYHN2ZWx0ZS10YWJzLSR7aWQrK31gO1xufVxuIiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG4gIGV4cG9ydCBjb25zdCBUQUJTID0ge307XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUsIHNldENvbnRleHQsIG9uRGVzdHJveSwgb25Nb3VudCwgdGljayB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSAnc3ZlbHRlL3N0b3JlJztcblxuICBleHBvcnQgbGV0IGluaXRpYWxTZWxlY3RlZEluZGV4ID0gMDtcblxuICBjb25zdCB0YWJFbGVtZW50cyA9IFtdO1xuICBjb25zdCB0YWJzID0gW107XG4gIGNvbnN0IHBhbmVscyA9IFtdO1xuXG4gIGNvbnN0IGNvbnRyb2xzID0gd3JpdGFibGUoe30pO1xuICBjb25zdCBsYWJlbGVkQnkgPSB3cml0YWJsZSh7fSk7XG5cbiAgY29uc3Qgc2VsZWN0ZWRUYWIgPSB3cml0YWJsZShudWxsKTtcbiAgY29uc3Qgc2VsZWN0ZWRQYW5lbCA9IHdyaXRhYmxlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZFVwZGF0ZVNlbGVjdGVkKGFyciwgaXRlbSwgc2VsZWN0ZWRTdG9yZSkge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgc2VsZWN0ZWRTdG9yZS51cGRhdGUoc2VsZWN0ZWQgPT4gc2VsZWN0ZWQgPT09IGl0ZW0gPyAoYXJyW2luZGV4XSB8fCBhcnJbYXJyLmxlbmd0aCAtIDFdKSA6IHNlbGVjdGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVySXRlbShhcnIsIGl0ZW0sIHNlbGVjdGVkU3RvcmUpIHtcbiAgICBhcnIucHVzaChpdGVtKTtcbiAgICBzZWxlY3RlZFN0b3JlLnVwZGF0ZShzZWxlY3RlZCA9PiBzZWxlY3RlZCB8fCBpdGVtKTtcbiAgICBvbkRlc3Ryb3koKCkgPT4gcmVtb3ZlQW5kVXBkYXRlU2VsZWN0ZWQoYXJyLCBpdGVtLCBzZWxlY3RlZFN0b3JlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RUYWIodGFiKSB7XG4gICAgY29uc3QgaW5kZXggPSB0YWJzLmluZGV4T2YodGFiKTtcbiAgICBzZWxlY3RlZFRhYi5zZXQodGFiKTtcbiAgICBzZWxlY3RlZFBhbmVsLnNldChwYW5lbHNbaW5kZXhdKTtcbiAgfVxuXG4gIHNldENvbnRleHQoVEFCUywge1xuICAgIHJlZ2lzdGVyVGFiKHRhYikge1xuICAgICAgcmVnaXN0ZXJJdGVtKHRhYnMsIHRhYiwgc2VsZWN0ZWRUYWIpO1xuICAgIH0sXG5cbiAgICByZWdpc3RlclRhYkVsZW1lbnQodGFiRWxlbWVudCkge1xuICAgICAgdGFiRWxlbWVudHMucHVzaCh0YWJFbGVtZW50KTtcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJQYW5lbChwYW5lbCkge1xuICAgICAgcmVnaXN0ZXJJdGVtKHBhbmVscywgcGFuZWwsIHNlbGVjdGVkUGFuZWwpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUYWIsXG5cbiAgICBzZWxlY3RlZFRhYixcbiAgICBzZWxlY3RlZFBhbmVsLFxuXG4gICAgY29udHJvbHMsXG4gICAgbGFiZWxlZEJ5XG4gIH0pO1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIHNlbGVjdFRhYih0YWJzW2luaXRpYWxTZWxlY3RlZEluZGV4XSk7XG4gIH0pO1xuXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnRyb2xzLnVwZGF0ZShjb250cm9sc0RhdGEgPT4gKHsuLi5jb250cm9sc0RhdGEsIFt0YWJzW2ldLmlkXTogcGFuZWxzW2ldLmlkfSkpO1xuICAgICAgbGFiZWxlZEJ5LnVwZGF0ZShsYWJlbGVkQnlEYXRhID0+ICh7Li4ubGFiZWxlZEJ5RGF0YSwgW3BhbmVsc1tpXS5pZF06IHRhYnNbaV0uaWR9KSk7XG4gICAgfVxuICB9KTtcblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3N2ZWx0ZS10YWJzX190YWInKSkge1xuICAgICAgbGV0IHNlbGVjdGVkSW5kZXggPSB0YWJzLmluZGV4T2YoJHNlbGVjdGVkVGFiKTtcblxuICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgc2VsZWN0ZWRJbmRleCArPSAxO1xuICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID4gdGFicy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZWN0VGFiKHRhYnNbc2VsZWN0ZWRJbmRleF0pO1xuICAgICAgICAgIHRhYkVsZW1lbnRzW3NlbGVjdGVkSW5kZXhdLmZvY3VzKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICBzZWxlY3RlZEluZGV4IC09IDE7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gdGFicy5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxlY3RUYWIodGFic1tzZWxlY3RlZEluZGV4XSk7XG4gICAgICAgICAgdGFiRWxlbWVudHNbc2VsZWN0ZWRJbmRleF0uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuXG48ZGl2IGNsYXNzPVwic3ZlbHRlLXRhYnNcIiBvbjprZXlkb3duPXtoYW5kbGVLZXlEb3dufT5cbiAgPHNsb3Q+PC9zbG90PlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRDb250ZXh0LCBvbk1vdW50LCB0aWNrIH0gZnJvbSAnc3ZlbHRlJztcblxuICBpbXBvcnQgZ2V0SWQgZnJvbSAnLi9pZCc7XG4gIGltcG9ydCB7IFRBQlMgfSBmcm9tICcuL1RhYnMuc3ZlbHRlJztcblxuICBsZXQgdGFiRWw7XG5cbiAgY29uc3QgdGFiID0ge1xuICAgIGlkOiBnZXRJZCgpXG4gIH07XG4gIGNvbnN0IHsgcmVnaXN0ZXJUYWIsIHJlZ2lzdGVyVGFiRWxlbWVudCwgc2VsZWN0VGFiLCBzZWxlY3RlZFRhYiwgY29udHJvbHMgfSA9IGdldENvbnRleHQoVEFCUyk7XG5cbiAgbGV0IGlzU2VsZWN0ZWQ7XG4gICQ6IGlzU2VsZWN0ZWQgPSAkc2VsZWN0ZWRUYWIgPT09IHRhYjtcblxuICByZWdpc3RlclRhYih0YWIpO1xuXG4gIG9uTW91bnQoYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHRpY2soKTtcbiAgICByZWdpc3RlclRhYkVsZW1lbnQodGFiRWwpO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cdC5zdmVsdGUtdGFic19fdGFiIHtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0Ym9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xuXHRcdGNvbG9yOiAjMDAwMDAwO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICBwYWRkaW5nOiAwLjVlbSAwLjc1ZW07XG5cdH1cblx0XG4gIC5zdmVsdGUtdGFic19fdGFiOmZvY3VzIHtcbiAgICBvdXRsaW5lOiB0aGluIGRvdHRlZDtcbiAgfVxuXG5cdC5zdmVsdGUtdGFic19fc2VsZWN0ZWQge1xuXHRcdGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjNEY4MUU1O1xuICAgIGNvbG9yOiAjNEY4MUU1O1xuXHR9XG48L3N0eWxlPlxuXG48bGlcbiAgYmluZDp0aGlzPXt0YWJFbH1cbiAgcm9sZT1cInRhYlwiXG4gIGlkPXt0YWIuaWR9XG4gIGFyaWEtY29udHJvbHM9eyRjb250cm9sc1t0YWIuaWRdfVxuICBhcmlhLXNlbGVjdGVkPXtpc1NlbGVjdGVkfVxuICB0YWJpbmRleD1cIntpc1NlbGVjdGVkID8gMCA6IC0xfVwiXG4gIGNsYXNzOnN2ZWx0ZS10YWJzX19zZWxlY3RlZD17aXNTZWxlY3RlZH1cbiAgY2xhc3M9XCJzdmVsdGUtdGFic19fdGFiXCJcbiAgb246Y2xpY2s9eygpID0+IHNlbGVjdFRhYih0YWIpfT5cblx0PHNsb3Q+PC9zbG90PlxuPC9saT5cbiIsIjxzdHlsZT5cblx0LnN2ZWx0ZS10YWJzX190YWItbGlzdCB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNDQ0NDQ0M7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG5cdH1cbjwvc3R5bGU+XG5cbjx1bCByb2xlPVwidGFibGlzdFwiIGNsYXNzPVwic3ZlbHRlLXRhYnNfX3RhYi1saXN0XCI+XG4gIDxzbG90Pjwvc2xvdD5cbjwvdWw+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuICBpbXBvcnQgZ2V0SWQgZnJvbSAnLi9pZCc7XG4gIGltcG9ydCB7IFRBQlMgfSBmcm9tICcuL1RhYnMuc3ZlbHRlJztcblxuICBjb25zdCBwYW5lbCA9IHtcbiAgICBpZDogZ2V0SWQoKVxuICB9O1xuICBjb25zdCB7IHJlZ2lzdGVyUGFuZWwsIHNlbGVjdGVkUGFuZWwsIGxhYmVsZWRCeSB9ID0gZ2V0Q29udGV4dChUQUJTKTtcblxuICByZWdpc3RlclBhbmVsKHBhbmVsKTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC5zdmVsdGUtdGFic19fdGFiLXBhbmVsIHtcbiAgICBtYXJnaW4tdG9wOiAwLjVlbTtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdiBcbiAgaWQ9e3BhbmVsLmlkfVxuICBhcmlhLWxhYmVsbGVkYnk9eyRsYWJlbGVkQnlbcGFuZWwuaWRdfVxuICBjbGFzcz1cInN2ZWx0ZS10YWJzX190YWItcGFuZWxcIlxuICByb2xlPVwidGFicGFuZWxcIj5cbiAgeyNpZiAkc2VsZWN0ZWRQYW5lbCA9PT0gcGFuZWx9XG4gICAgPHNsb3Q+PC9zbG90PlxuICB7L2lmfVxuPC9kaXY+XG4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB2aWV3Qm94PVxcXCIwIDAgNDQ4IDUxMlxcXCI+PCEtLSBGb250IEF3ZXNvbWUgRnJlZSA1LjE1LjQgYnkgQGZvbnRhd2Vzb21lIC0gaHR0cHM6Ly9mb250YXdlc29tZS5jb20gTGljZW5zZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tL2xpY2Vuc2UvZnJlZSAoSWNvbnM6IENDIEJZIDQuMCwgRm9udHM6IFNJTCBPRkwgMS4xLCBDb2RlOiBNSVQgTGljZW5zZSkgLS0+PHBhdGggZD1cXFwiTTY0IDIyNGgxMy41YzI0LjcgNTYuNSA4MC45IDk2IDE0Ni41IDk2czEyMS44LTM5LjUgMTQ2LjUtOTZIMzg0YzguOCAwIDE2LTcuMiAxNi0xNnYtOTZjMC04LjgtNy4yLTE2LTE2LTE2aC0xMy41QzM0NS44IDM5LjUgMjg5LjYgMCAyMjQgMFMxMDIuMiAzOS41IDc3LjUgOTZINjRjLTguOCAwLTE2IDcuMi0xNiAxNnY5NmMwIDguOCA3LjIgMTYgMTYgMTZ6bTQwLTg4YzAtMjIuMSAyMS41LTQwIDQ4LTQwaDE0NGMyNi41IDAgNDggMTcuOSA0OCA0MHYyNGMwIDUzLTQzIDk2LTk2IDk2aC00OGMtNTMgMC05Ni00My05Ni05NnYtMjR6bTcyIDcybDEyLTM2IDM2LTEyLTM2LTEyLTEyLTM2LTEyIDM2LTM2IDEyIDM2IDEyIDEyIDM2em0xNTEuNiAxMTMuNEMyOTcuNyAzNDAuNyAyNjIuMiAzNTIgMjI0IDM1MnMtNzMuNy0xMS4zLTEwMy42LTMwLjZDNTIuOSAzMjguNSAwIDM4NSAwIDQ1NC40djkuNmMwIDI2LjUgMjEuNSA0OCA0OCA0OGg4MHYtNjRjMC0xNy43IDE0LjMtMzIgMzItMzJoMTI4YzE3LjcgMCAzMiAxNC4zIDMyIDMydjY0aDgwYzI2LjUgMCA0OC0yMS41IDQ4LTQ4di05LjZjMC02OS40LTUyLjktMTI1LjktMTIwLjQtMTMzek0yNzIgNDQ4Yy04LjggMC0xNiA3LjItMTYgMTZzNy4yIDE2IDE2IDE2IDE2LTcuMiAxNi0xNi03LjItMTYtMTYtMTZ6bS05NiAwYy04LjggMC0xNiA3LjItMTYgMTZ2NDhoMzJ2LTQ4YzAtOC44LTcuMi0xNi0xNi0xNnpcXFwiLz48L3N2Zz5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cblx0aW1wb3J0IFNYX0lDT05fQVNUUk9OQVVUIGZyb20gJyMvaWNvbi91c2VyLWFzdHJvbmF1dC5zdmc/cmF3Jztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IFRocmVhZElkIH0gZnJvbSAnLi4vZGVmJztcblx0aW1wb3J0IHsgeXdfbmF2aWdhdG9yIH0gZnJvbSAnLi4vbWVtJztcblx0aW1wb3J0IHR5cGUgeyBQYWdlIH0gZnJvbSAnLi4vbmF2L3BhZ2UnO1xuXHRpbXBvcnQgeyBTY3JlZW4sIEhlYWRlciB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXG5cdGV4cG9ydCBsZXQgcmVzZXQgPSBmYWxzZTtcblx0Y29uc3QgYl9yZXNldCA9IHJlc2V0O1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXHRmdW5jdGlvbiBjb250KCkge1xuXHRcdGlmKGJfcmVzZXQpIHtcblx0XHRcdGtfcGFnZS5yZXNldCgpO1xuXHRcdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKFRocmVhZElkLlRPS0VOUyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0a19wYWdlLnBvcCgpO1xuXHRcdH1cblx0fVxuXHQ8L3NjcmlwdD5cblx0XG5cdDxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcdC5pY29uIHtcblx0XHRcdHBhZGRpbmctdG9wOiAyNSU7XG5cdFx0fVxuXHQ8L3N0eWxlPlxuXHRcblx0PFNjcmVlbj5cblx0XHQ8SGVhZGVyIHBvcHNcblx0XHRcdHRpdGxlPVwiTm90IHlldCBhdmFpbGFibGVcIlxuXHRcdC8+XG5cdFxuXHRcdDxoMz5cblx0XHRcdE5vdGhpbmcgdG8gc2VlIGhlcmUhXG5cdFx0PC9oMz5cblx0XG5cdFx0PHA+XG5cdFx0XHRUaGlzIHNjcmVlbiBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLlxuXHRcdDwvcD5cblx0XG5cdFx0PHA+XG5cdFx0XHRQbGVhc2UgY29udGludWUgZXhwbG9yaW5nIHRoZSBiZXRhLlxuXHRcdDwvcD5cblx0XG5cdFx0PGNlbnRlcj5cblx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHR7QGh0bWwgU1hfSUNPTl9BU1RST05BVVR9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9jZW50ZXI+XG5cdFxuXHRcdDxkaXYgY2xhc3M9XCJhY3Rpb24tbGluZVwiPlxuXHRcdFx0PGJ1dHRvbiBjbGFzcz1cInByaW1hcnlcIiBvbjpjbGljaz17KCkgPT4gY29udCgpfT5cblx0XHRcdFx0Q29udGludWVcblx0XHRcdDwvYnV0dG9uPlxuXHRcdDwvZGl2PlxuXHQ8L1NjcmVlbj4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge3l3X2FjY291bnQsIHl3X2NoYWlufSBmcm9tICcjIy9tZW0nO1xuXHRpbXBvcnQgdHlwZSB7IENvbnRhY3QsIENvbnRhY3RQYXRoIH0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXHRpbXBvcnQgeyBBZ2VudHMgfSBmcm9tICcjL3N0b3JlL2FnZW50cyc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdFxuXHRpbXBvcnQgeyBIZWFkZXIsIHR5cGUgUGFnZSwgU2NyZWVuIH0gZnJvbSAnLi4vc2NyZWVuL19zY3JlZW5zJztcblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnIyMvdWkvQWRkcmVzcy5zdmVsdGUnO1xuXHRpbXBvcnQgUG9ydHJhaXQgZnJvbSAnIyMvdWkvUG9ydHJhaXQuc3ZlbHRlJztcblx0aW1wb3J0IFNlbmQgZnJvbSAnIyMvc2NyZWVuL1NlbmQuc3ZlbHRlJztcblx0Ly8gaW1wb3J0IFR4bkxpc3QsIHsgVHhuQ29udGV4dCB9IGZyb20gJyMjL3VpL1R4bkxpc3Quc3ZlbHRlJztcblx0aW1wb3J0IENvbnRhY3RFZGl0IGZyb20gJy4vQ29udGFjdEVkaXQuc3ZlbHRlJztcblx0aW1wb3J0IERlYWRFbmQgZnJvbSAnLi9EZWFkRW5kLnN2ZWx0ZSc7XG5cblxuXHRleHBvcnQgbGV0IGNvbnRhY3RSZWY6IENvbnRhY3RQYXRoO1xuXHRjb25zdCBwX2NvbnRhY3QgPSBjb250YWN0UmVmO1xuXG5cdGxldCBnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddO1xuXHR2b2lkIEFnZW50cy5nZXRDb250YWN0KHBfY29udGFjdCkudGhlbihnID0+IGdfY29udGFjdCA9IGchKTtcblxuXHQkOiBzYV9jb250YWN0ID0gZ19jb250YWN0PyBDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKTogJyc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGNvbnN0IGdjX2FjdGlvbnMgPSB7XG5cdFx0c2VuZDoge1xuXHRcdFx0bGFiZWw6ICdTZW5kJyxcblx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBTZW5kLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHR0bzogQ2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcyksXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0ZWRpdDoge1xuXHRcdFx0bGFiZWw6ICdFZGl0Jyxcblx0XHRcdHRyaWdnZXIoKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBDb250YWN0RWRpdCxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0Y29udGFjdFJlZjogcF9jb250YWN0LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRcdGRlbGV0ZToge1xuXHRcdFx0bGFiZWw6ICdEZWxldGUnLFxuXHRcdFx0dHJpZ2dlcigpIHtcblx0XHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRcdGNyZWF0b3I6IERlYWRFbmQsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHR9O1xuXG5cdC8vICQ6IGFfdHhucyA9IEFfVFhOUy5maWx0ZXIoKGtfdHhuKSA9PiB7XG5cdC8vIFx0Y29uc3QgZ2RfdHhuID0ga190eG4uZGVmO1xuXG5cdC8vIFx0aWYoc2FfY29udGFjdCA9PT0gZ2RfdHhuLmFkZHJlc3MpIHJldHVybiB0cnVlO1xuXG5cdC8vIFx0Y29uc3QgZ19iYW5raXNoID0ga190eG4uYmFua2lzaCgkeXdfYWNjb3VudC5hZGRyZXNzKCR5d19jaGFpbikpO1xuXHQvLyBcdGlmKGdfYmFua2lzaCkge1xuXHQvLyBcdFx0cmV0dXJuIHNhX2NvbnRhY3QgPT09IGdfYmFua2lzaC5hZGRyZXNzO1xuXHQvLyBcdH1cblxuXHQvLyBcdHJldHVybiBmYWxzZTtcblx0Ly8gfSk7XG5cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnX2Jhc2UubGVzcyc7XG5cblxuXHQucGZwLWdlbiB7XG5cdFx0LmZvbnQoaHVnZSwgQHNpemU6IDMwcHgpO1xuXHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJvcmRlci1yYWRpdXM6IDIwJTtcblx0XHRvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0YmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KGVsbGlwc2UgZmFydGhlc3Qtc2lkZSBhdCBib3R0b20gcmlnaHQsICMwNzA4MGEsICMwZjEzMTcpO1xuXHR9XG48L3N0eWxlPlxuXG5cbjxTY3JlZW4gbmF2IHNsaWRlcz5cblx0PEhlYWRlciBwb3BzIHNlYXJjaCBuZXR3b3JrIGFjY291bnQgLz5cblxuXHR7I2lmICFnX2NvbnRhY3R9XG5cdFx0TG9hZGluZyBjb250YWN0Li4uXG5cdHs6ZWxzZX1cblx0XHQ8UG9ydHJhaXRcblx0XHRcdHJlc291cmNlPXtnX2NvbnRhY3R9XG5cdFx0XHRyZXNvdXJjZVBhdGg9e3BfY29udGFjdH1cblx0XHRcdGFjdGlvbnM9e2djX2FjdGlvbnN9XG5cdFx0PlxuXHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwic3VidGl0bGVcIj5cblx0XHRcdFx0PEFkZHJlc3MgY29weWFibGUgYWRkcmVzcz17Q2hhaW5zLmJlY2gzMihnX2NvbnRhY3QuYWRkcmVzcyl9IC8+XG5cdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5hZGRyZXNzXG5cdFx0PC9Qb3J0cmFpdD5cbjwhLS0gXG5cdFx0PFR4bkxpc3Rcblx0XHRcdGNvbnRleHQ9e1R4bkNvbnRleHQuQ09OVEFDVH1cblx0XHRcdHR4bnM9e2FfdHhuc31cblx0XHQvPiAtLT5cblx0PCEtLSBcblx0XHQ8ZGl2IGNsYXNzPVwidHhucyBuby1tYXJnaW5cIj5cblx0XHRcdHsjaWYgIWFfdHhucy5sZW5ndGh9XG5cdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0Tm8gdHJhbnNhY3Rpb25zIHlldFxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvaWZ9XG5cblx0XHRcdHsjZWFjaCBhX3R4bnMgYXMga190eG59XG5cdFx0XHRcdHtAY29uc3QgZ2RfdHhuID0ga190eG4uZGVmfVxuXHRcdFx0XHR7QGNvbnN0IGtfdG9rZW4gPSBIX0FERFJFU1NfVE9fVE9LRU5ba190eG4uZGVmLmFkZHJlc3NdfVxuXHRcdFx0XHR7QGNvbnN0IGdfYmFua2lzaCA9IGtfdHhuLmJhbmtpc2goJHl3X2FjY291bnQuYWRkcmVzcygkeXdfY2hhaW4pKX1cblx0XHRcdFx0e0Bjb25zdCBhX2RlYnVnID0gW2dfYmFua2lzaCwga190eG5dfVxuXHRcdFx0XHQ8LyEtLSB7QGRlYnVnIGFfZGVidWd9IC0tLz5cblxuXHRcdFx0XHR7I2lmIFR4bi5UeXBlLlJFQ1YgPT09IGdkX3R4bi50eXBlfVxuXHRcdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRcdG5hbWU9XCJSZWNlaXZlZCBTQ1JUXCJcblx0XHRcdFx0XHQ+XG5cdFx0XHRcdFx0PC9Sb3c+XG5cdFx0XHRcdFx0PC8hLS0gYXBwcm94KGdkX3R4bi5hbW91bnQpIC0tLz5cblx0XHRcdFx0ezplbHNlIGlmIFR4bi5UeXBlLlNFTkQgPT09IGdkX3R4bi50eXBlfVxuXHRcdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRcdG5hbWU9XCJTZW50IFNDUlRcIlxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHQ8L1Jvdz5cblx0XHRcdFx0ey9pZn1cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Rpdj4gLS0+XG5cdHsvaWZ9XG5cbjwvU2NyZWVuPiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTE5IDV2MTRINVY1aDE0bTAtMkg1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bS00Ljg2IDguODYtMyAzLjg3TDkgMTMuMTQgNiAxN2gxMmwtMy44Ni01LjE0elxcXCIvPlxcbjwvc3ZnPlwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IFNYX0lDT05fSU1BR0UgZnJvbSAnIy9pY29uL2ltYWdlLnN2Zz9yYXcnO1xuXHRpbXBvcnQgdHlwZSB7IFBmcCwgUGZwUGF0aCB9IGZyb20gJyMvbWV0YS9wZnAnO1xuXHRpbXBvcnQgeyBQZnBzIH0gZnJvbSAnIy9zdG9yZS9wZnBzJztcblx0aW1wb3J0IHsgRl9OT09QIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCBQZnBEaXNwbGF5IGZyb20gJy4vUGZwRGlzcGxheS5zdmVsdGUnO1xuXHRcblx0ZXhwb3J0IGxldCBwZnBSZWY6ICcnIHwgUGZwUGF0aDtcblx0Y29uc3QgcF9wZnAgPSBwZnBSZWYgfHwgJyc7XG5cblx0ZXhwb3J0IGxldCBuYW1lID0gJyc7XG5cdGNvbnN0IHNfbmFtZSA9IG5hbWU7XG5cblx0ZXhwb3J0IGxldCBpbnRlbnQ6ICd0b2tlbicgfCAncGVyc29uJyA9ICd0b2tlbic7XG5cdGNvbnN0IHNpX2ludGVudCA9IGludGVudDtcblxuXHRsZXQgZ19wZnA6IFBmcFsnaW50ZXJmYWNlJ107XG5cblx0KGFzeW5jKCkgPT4ge1xuXHRcdGlmKHBfcGZwKSB7XG5cdFx0XHRnX3BmcCA9IChhd2FpdCBQZnBzLmF0KHBfcGZwKSkhO1xuXHRcdH1cblx0fSkoKTtcblxuXHQvLyBjb25zdCBwX2ljb24gPSBpY29uUmVmIHx8IEljb24uRGVmLkJMQU5LLmlyaTtcblxuXHQvLyBjb25zdCBrX2ljb24gPSBwX2ljb24/IEhfSUNPTlNbcF9pY29uXTogSWNvbi5CTEFOSztcbjwvc2NyaXB0PlxuXHRcbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdC5hcmVhIHtcblx0XHRib3JkZXI6IDFweCBkYXNoZWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRib3JkZXItcmFkaXVzOiA0cHg7XG5cblx0XHQ+LnJvdyB7XG5cdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuXHRcdFx0bWFyZ2luOiB2YXIoLS11aS1wYWRkaW5nKTtcblxuXHRcdFx0Pioge1xuXHRcdFx0XHRmbGV4OiBhdXRvO1xuXHRcdFx0fVxuXG5cdFx0XHQ+LmxlZnQge1xuXHRcdFx0XHRmbGV4OiAxO1xuXG5cdFx0XHRcdD4uaWNvbi5wZnAge1xuXHRcdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdFx0LS1idXR0b24tZGlhbWV0ZXI6IDY0cHg7XG5cdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDY0cHg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdD4ucmlnaHQge1xuXHRcdFx0XHRmbGV4OiAzO1xuXHRcdFx0XHRwYWRkaW5nOiAwIGNhbGModmFyKC0tdWktcGFkZGluZykgLyAyKTtcblx0XHRcdFx0bWFyZ2luLXRvcDogLTRweDtcblx0XHRcdFx0Ly8gcGFkZGluZy10b3A6IGNhbGModmFyKC0tdWktcGFkZGluZykgLyAxLjUpO1xuXG5cdFx0XHRcdD4uZGlzY2xhaW1lciB7XG5cdFx0XHRcdFx0LmZvbnQodGlueSk7XG5cblx0XHRcdFx0XHQ+Lndhcm5pbmcge1xuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdD4uaW5mbyB7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcGFkZGluZy1ib3R0b206IDIwcHg7XG5cblx0XHRcdC5hY3Rpb25zIHtcblx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRtYXJnaW4tdG9wOiA0cHg7XG5cblx0XHRcdFx0Ly8gd2hpdGUtc3BhY2U6IG5vd3JhcDtcblx0XHRcdFx0Ly8gcG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHQvLyBtYXJnaW4tdG9wOiA0cHg7XG5cdFx0XHRcdC8vIG1hcmdpbi1sZWZ0OiAtNHB4O1xuXG5cdFx0XHRcdD4qIHtcblx0XHRcdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cblx0XHRcdFx0XHQmOmhvdmVyIHtcblx0XHRcdFx0XHRcdD4udGV4dCB7XG5cdFx0XHRcdFx0XHRcdHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdD4qIHtcblx0XHRcdFx0XHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pi5pY29uIHtcblx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDIwcHg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwiYXJlYVwiIGNsYXNzOmludGVudC1wZXJzb249eydwZXJzb24nID09PSBzaV9pbnRlbnR9PlxuXHQ8ZGl2IGNsYXNzPVwicm93XCI+XG5cdFx0PHNwYW4gY2xhc3M9XCJsZWZ0XCI+XG5cdFx0XHQ8IS0tIDxzcGFuIGNsYXNzPVwiaWNvbiBwZnBcIiBjbGFzczpzcXVhcmU9eydwZXJzb24nID09PSBpbnRlbnR9PlxuXHRcdFx0XHQ8UHV0IGVsZW1lbnQ9e0hfSUNPTlNbcF9pY29uXS5yZW5kZXIoKX0gLz5cblx0XHRcdDwvc3Bhbj4gLS0+XG5cdFx0XHR7I2lmIHBfcGZwfVxuXHRcdFx0XHQ8UGZwRGlzcGxheSBkaW09ezQ4fSByZWY9e3BfcGZwfSBuYW1lPXtzX25hbWV9IC8+XG5cdFx0XHR7L2lmfVxuXHRcdFx0PCEtLSA8UGZwRGlzcGxheSBiaW5kOmljb25SZWY9e2ljb25SZWZ9IGJpbmQ6bmFtZT17bmFtZX0gLz4gLS0+XG5cdFx0PC9zcGFuPlxuXG5cdFx0PHNwYW4gY2xhc3M9XCJyaWdodFwiPlxuXHRcdFx0PGRpdiBjbGFzcz1cImRpc2NsYWltZXJcIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ3YXJuaW5nXCI+XG5cdFx0XHRcdFx0Tm90aWNlOlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdFVwbG9hZGVkIGljb25zIHdpbGwgYmUgcmVzaXplZCB0byBiZSBzcXVhcmUuIE9ubHkgSlBHICYgUE5HIGZpbGVzIGxlc3MgdGhhbiAxTUIgYWxsb3dlZC5cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9kaXY+XG5cblx0XHRcdDxkaXYgY2xhc3M9XCJhY3Rpb25zXCI+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ1cGxvYWRcIiBvbjpjbGljaz17KCkgPT4gRl9OT09QfT5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0XHRcdHtAaHRtbCBTWF9JQ09OX0lNQUdFfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInRleHRcIj5cblx0XHRcdFx0XHRcdFVwbG9hZCBJY29uXG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvc3Bhbj5cblx0PC9kaXY+XG48L2Rpdj5cbiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7Z2V0Q29udGV4dCwgU3ZlbHRlQ29tcG9uZW50fSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQge21pY3JvdGFzaywgb2RlLCBvZmUsIHByb3Blcn0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCB7IENvbnRhY3QsIENvbnRhY3RBZ2VudFR5cGUsIENvbnRhY3RQYXRoIH0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXHRpbXBvcnQgeyBBZ2VudHMgfSBmcm9tICcjL3N0b3JlL2FnZW50cyc7XG5cdGltcG9ydCB0eXBlIHsgUGFnZSB9IGZyb20gJy4uL25hdi9wYWdlJztcblx0aW1wb3J0IHsgeXdfY2hhaW4sIHl3X2ZhbWlseSB9IGZyb20gJy4uL21lbSc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgUl9CRUNIMzIgfSBmcm9tICcjL3NoYXJlL2NvbnN0YW50cyc7XG5cdGltcG9ydCB7IFRhZ3MgfSBmcm9tICcjL3N0b3JlL3RhZ3MnO1xuXHRpbXBvcnQgeyBIZWFkZXIsIFNjcmVlbiB9IGZyb20gJy4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgQ29udGFjdFZpZXcgZnJvbSAnLi9Db250YWN0Vmlldy5zdmVsdGUnO1xuXHRpbXBvcnQgRmllbGQgZnJvbSAnLi4vdWkvRmllbGQuc3ZlbHRlJztcblx0aW1wb3J0IEluZm8gZnJvbSAnLi4vdWkvSW5mby5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IENoYWluLCBDaGFpblBhdGggfSBmcm9tICcjL21ldGEvY2hhaW4nO1xuXHRpbXBvcnQgSW5saW5lVGFncyBmcm9tICcuLi91aS9JbmxpbmVUYWdzLnN2ZWx0ZSc7XG5cdGltcG9ydCBJY29uRWRpdG9yIGZyb20gJy4uL3VpL0ljb25FZGl0b3Iuc3ZlbHRlJztcblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0LyoqXG5cdCAqIENvbnRhY3QgcmVzb3VyY2UgcGF0aFxuXHQgKi9cblx0ZXhwb3J0IGxldCBjb250YWN0UmVmOiBDb250YWN0UGF0aCB8ICcnID0gJyc7XG5cdGNvbnN0IHBfY29udGFjdCA9IGNvbnRhY3RSZWYgfHwgJyc7XG5cblx0Ly8gcHJlcCBvYmplY3QgcGxhY2Vob2xkZXJcblx0bGV0IGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ107XG5cblx0Ly8gcGF0aCB3YXMgZ2l2ZW47IGxvYWQgY29udGFjdFxuXHRpZihwX2NvbnRhY3QpIHZvaWQgQWdlbnRzLmdldENvbnRhY3QocF9jb250YWN0KS50aGVuKGcgPT4gZ19jb250YWN0ID0gZyEpO1xuXG5cdC8vIGxvYWQgYWxsIGNoYWluc1xuXHRsZXQgaF9jaGFpbnM6IFJlY29yZDxDaGFpblBhdGgsIENoYWluWydpbnRlcmZhY2UnXT4gPSB7fTtcblx0KGFzeW5jIGZ1bmN0aW9uIGxvYWRfY2hhaW5zKCkge1xuXHRcdGhfY2hhaW5zID0gb2ZlKChhd2FpdCBDaGFpbnMucmVhZCgpKS5lbnRyaWVzKCkpO1xuXHR9KSgpO1xuXG5cdC8vIHJlYWN0aXZlbHkgZGVzdHJ1Y3R1cmUgY29udGFjdCdzIHByb3BlcnRpZXNcblx0JDogc19uYW1lID0gZ19jb250YWN0Py5uYW1lIHx8ICcnO1xuXHQkOiBzX2FkZHIgPSBnX2NvbnRhY3Q/LmFkZHJlc3MgfHwgJyc7XG5cdCQ6IHNhX2JlY2gzMiA9IHNfYWRkcj8gQ2hhaW5zLmJlY2gzMihzX2FkZHIgYXMgc3RyaW5nKTogJyc7XG5cdCQ6IHNfbm90ZXMgPSBnX2NvbnRhY3Q/Lm5vdGVzIHx8ICcnO1xuXHQkOiBzaV9hZ2VudF90eXBlID0gZ19jb250YWN0Py5hZ2VudFR5cGUgfHwgQ29udGFjdEFnZW50VHlwZS5QRVJTT047XG5cblx0bGV0IHNfZXJyX25hbWUgPSAnJztcblx0bGV0IHNfZXJyX2FkZHJlc3MgPSAnJztcblxuXHRmdW5jdGlvbiBwdWJrZXlfZnJvbV9hZGRyKHNhX2FkZHJlc3M6IHN0cmluZywgYl9zaG93X2Vycj1mYWxzZSk6IHN0cmluZyB7XG5cdFx0Y29uc3QgbV9iZWNoID0gUl9CRUNIMzIuZXhlYyhzYV9hZGRyZXNzKTtcblx0XHRpZighbV9iZWNoKSB7XG5cdFx0XHRpZihiX3Nob3dfZXJyKSB7XG5cdFx0XHRcdHNfZXJyX2FkZHJlc3MgPSAnSW52YWxpZCBCZWNoMzIgYWRkcmVzcyc7XG5cdFx0XHR9XG5cdFxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGNvbnN0IFssIHNfY2hhaW4sIHNfcHVia2V5X2xvY2FsXSA9IG1fYmVjaDtcblxuXHRcdGxldCBrX2NoYWluX21hdGNoID0gbnVsbDtcblx0XHRmb3IoY29uc3QgWywga19jaGFpbl0gb2Ygb2RlKEhfQ0hBSU5TKSkge1xuXHRcdFx0aWYoa19jaGFpbi5kZWYuYmVjaFByZWZpeCA9PT0gc19jaGFpbikge1xuXHRcdFx0XHRrX2NoYWluX21hdGNoID0ga19jaGFpbjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoYl9zaG93X2Vycikge1xuXHRcdFx0aWYoIWtfY2hhaW5fbWF0Y2gpIHtcblx0XHRcdFx0c19lcnJfYWRkcmVzcyA9IGBObyBDb3Ntb3MgU0RLIGNoYWlucyBtYXRjaGVkICcke3NfY2hhaW59J2A7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c19lcnJfYWRkcmVzcyA9ICcnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzX2FkZHIgPSBzX3B1YmtleV9sb2NhbDtcblx0fVxuXG5cdCQ6IGJfZm9ybV92YWxpZCA9ICEhKHNfbmFtZSAmJiBwdWJrZXlfZnJvbV9hZGRyKHNhX2JlY2gzMikpO1xuXHRsZXQgY19zaG93X3ZhbGlkYXRpb25zID0gMDtcblxuXHQkOiB7XG5cdFx0aWYoY19zaG93X3ZhbGlkYXRpb25zKSB7XG5cdFx0XHRzX2Vycl9uYW1lID0gc19uYW1lPyAnJzogJ05hbWUgbXVzdCBub3QgYmUgZW1wdHknO1xuXHRcdFx0cHVia2V5X2Zyb21fYWRkcihzYV9iZWNoMzIsIHRydWUpO1xuXHRcdH1cblx0fVxuXG5cdGxldCBiX2J1c3kgPSBmYWxzZTtcblxuXHRsZXQgeV9zY3JlZW46IFN2ZWx0ZUNvbXBvbmVudDtcblx0YXN5bmMgZnVuY3Rpb24gc2F2ZSgpIHtcblx0XHRpZighYl9mb3JtX3ZhbGlkKSB7XG5cdFx0XHRjX3Nob3dfdmFsaWRhdGlvbnMrKztcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRlbHNlIGlmKHBfY29udGFjdCkge1xuXHRcdFx0T2JqZWN0LmFzc2lnbihnX2NvbnRhY3QsIHtcblx0XHRcdFx0bmFtZTogc19uYW1lLFxuXHRcdFx0XHRhZGRyZXNzOiBzX2FkZHIsXG5cdFx0XHRcdHBmcDogZ19jb250YWN0LnBmcCxcblx0XHRcdFx0YWdlbnRUeXBlOiBzaV9hZ2VudF90eXBlLFxuXHRcdFx0XHRub3Rlczogc19ub3Rlcyxcblx0XHRcdH0pO1xuXG5cdFx0XHRrX3BhZ2UucmVzZXQoKTtcblx0XHRcdC8vIHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0Ly8gXHR0cnkge1xuXHRcdFx0Ly8gXHRcdHlfc2NyZWVuLiRkZXN0cm95KCk7XG5cdFx0XHQvLyBcdH1cblx0XHRcdC8vIFx0Y2F0Y2goZSkge31cblx0XG5cdFx0XHQvLyBcdGNvbnRhY3QgPSBIX0NPTlRBQ1RTW2NvbnRhY3QuZGVmLmlyaV07XG5cdFx0XHQvLyBcdHB1c2hfc2NyZWVuKENvbnRhY3RWaWV3LCB7XG5cdFx0XHQvLyBcdFx0Y29udGFjdCxcblx0XHRcdC8vIFx0fSk7XG5cdFx0XHQvLyB9LCA1KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRnX2NvbnRhY3QgPSB7XG5cdFx0XHRcdG5hbWU6IHNfbmFtZSxcblx0XHRcdFx0ZmFtaWx5OiAkeXdfZmFtaWx5LFxuXHRcdFx0XHRhZGRyZXNzOiBzX2FkZHIsXG5cdFx0XHRcdHBmcDogZ19jb250YWN0LnBmcCxcblx0XHRcdFx0YWdlbnRUeXBlOiBzaV9hZ2VudF90eXBlLFxuXHRcdFx0XHRub3Rlczogc19ub3Rlcyxcblx0XHRcdFx0c3BhY2U6ICdhY2MnLFxuXHRcdFx0XHRvcmlnaW46ICd1c2VyJyxcblx0XHRcdFx0Y2hhaW5zOiB7fSxcblx0XHRcdH07XG5cdFx0fVxuXG5cblx0XHRiX2J1c3kgPSB0cnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBBZ2VudHMub3Blbihhc3luYyhrc19hZ2VudHMpID0+IHtcblx0XHRcdFx0YXdhaXQga3NfYWdlbnRzLnB1dENvbnRhY3QoZ19jb250YWN0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRrX3BhZ2UucmVzZXQoKTtcblxuXHRcdFx0Ly8gaW1tZWRpYXRlbHkgb3BlbiBuZXcgY29udGFjdFxuXHRcdFx0a19wYWdlLnB1c2goe1xuXHRcdFx0XHRjcmVhdG9yOiBDb250YWN0Vmlldyxcblx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRjb250YWN0UmVmOiBwX2NvbnRhY3QsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0Y2F0Y2goZV93cml0ZSkge1xuXHRcdFx0Yl9idXN5ID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gbGV0IHBfaWNvbjogSWNvbi5SZWYgPSBjb250YWN0Py5kZWYuaWNvblJlZiB8fCAnJyBhcyBJY29uLlJlZjtcbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHQjY2hhaW4tZmFtaWx5IHtcblx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdGZsZXg6IDE7XG5cdFx0XHRhbGlnbi1pdGVtczogYmFzZWxpbmU7XG5cdFx0XHQuZm9udCh0aW55KTtcblx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cblx0XHRcdG92ZXJmbG93OiBoaWRkZW47XG5cdFx0XHR0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxTY3JlZW4gYmluZDp0aGlzPXt5X3NjcmVlbn0gbGVhdmVzPlxuXHQ8SGVhZGVyXG5cdFx0cGxhaW4gcG9wc1xuXHRcdHRpdGxlPVwie3BfY29udGFjdD8gJ0VkaXQnOiAnQWRkIE5ldyd9IENvbnRhY3RcIlxuXHQvPlxuXG5cdDxGaWVsZFxuXHRcdGtleT1cImNvbnRhY3QtcGZwXCJcblx0XHRuYW1lPVwiUHJvZmlsZSBJY29uXCJcblx0PlxuXHRcdDxJY29uRWRpdG9yIGludGVudD0ncGVyc29uJyBwZnBSZWY9e2dfY29udGFjdD8ucGZwfSBiaW5kOm5hbWU9e3NfbmFtZX0gLz5cblx0PC9GaWVsZD5cblxuXHQ8RmllbGRcblx0XHRrZXk9XCJjaGFpbi1mYW1pbHlcIlxuXHRcdG5hbWU9XCJDaGFpbiBGYW1pbHlcIlxuXHQ+XG5cdFx0PEluZm8ga2V5PVwiY2hhaW4tZmFtaWx5XCI+XG5cdFx0XHQ8c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0XHRcdFx0QGltcG9ydCAnLi9fYmFzZS5sZXNzJztcblxuXHRcdFx0XHQudGl0bGUge1xuXHRcdFx0XHRcdC5mb250KHJlZ3VsYXIpO1xuXHRcdFx0XHRcdGNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC5leGFtcGxlcyB7XG5cdFx0XHRcdFx0bWFyZ2luLWxlZnQ6IDAuNWVtO1xuXHRcdFx0XHR9XG5cdFx0XHQ8L3N0eWxlPlxuXG5cdFx0XHQ8c3BhbiBjbGFzcz1cInRpdGxlXCI+XG5cdFx0XHRcdHtwcm9wZXIoJHl3X2ZhbWlseSl9XG5cdFx0XHQ8L3NwYW4+XG5cblx0XHRcdDxzcGFuIGNsYXNzPVwiZXhhbXBsZXNcIj5cblx0XHRcdFx0KHtvZGUoaF9jaGFpbnMpLmZpbHRlcigoWywgZ10pID0+ICR5d19mYW1pbHkgPT09IGcuZmFtaWx5KS5tYXAoKFssIGddKSA9PiBnLmJlY2gzMnMuYWNjLmhycCkuam9pbignLCAnKX0pXG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9JbmZvPlxuXHQ8L0ZpZWxkPlxuXG5cblx0PEZpZWxkXG5cdFx0a2V5PVwiY29udGFjdC1uYW1lXCJcblx0XHRuYW1lPVwiTmFtZVwiXG5cdD5cblx0XHQ8aW5wdXQgY2xhc3M6aW52YWxpZD17c19lcnJfbmFtZX0gdHlwZT1cInRleHRcIiBzcGVsbGNoZWNrPVwiZmFsc2VcIiBiaW5kOnZhbHVlPXtzX25hbWV9IHBsYWNlaG9sZGVyPVwiRW50ZXIgYSBuYW1lXCI+XG5cblx0XHR7I2lmIHNfZXJyX25hbWV9XG5cdFx0XHQ8c3BhbiBjbGFzcz1cInZhbGlkYXRpb24tbWVzc2FnZVwiPlxuXHRcdFx0XHR7c19lcnJfbmFtZX1cblx0XHRcdDwvc3Bhbj5cblx0XHR7L2lmfVxuXHQ8L0ZpZWxkPlxuXG5cdDxGaWVsZFxuXHRcdGtleT1cImNvbnRhY3QtYWRkcmVzc1wiXG5cdFx0bmFtZT1cIkFkZHJlc3NcIlxuXHQ+XG5cdFx0PGlucHV0XG5cdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRjbGFzcz1cImFkZHJlc3NcIlxuXHRcdFx0Y2xhc3M6aW52YWxpZD17c19lcnJfYWRkcmVzc31cblx0XHRcdHNwZWxsY2hlY2s9XCJmYWxzZVwiXG5cdFx0XHRwbGFjZWhvbGRlcj1cInskeXdfY2hhaW4uYmVjaDMycy5hY2N9MS4uLlwiXG5cdFx0XHRiaW5kOnZhbHVlPXtzYV9iZWNoMzJ9XG5cdFx0PlxuXG5cdFx0eyNpZiBzX2Vycl9hZGRyZXNzfVxuXHRcdFx0PHNwYW4gY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIj5cblx0XHRcdFx0e3NfZXJyX2FkZHJlc3N9XG5cdFx0XHQ8L3NwYW4+XG5cdFx0ey9pZn1cblx0PC9GaWVsZD5cblxuXHQ8RmllbGRcblx0XHRrZXk9XCJjb250YWN0LW5vdGVzXCJcblx0XHRuYW1lPVwiU2VjdXJlIE5vdGVzXCJcblx0PlxuXHRcdDx0ZXh0YXJlYSBiaW5kOnZhbHVlPXtzX25vdGVzfSBwbGFjZWhvbGRlcj1cIlwiPjwvdGV4dGFyZWE+XG5cdDwvRmllbGQ+XG5cblx0PGhyPlxuXG5cdDxoMz5cblx0XHR7cF9jb250YWN0PyAnRWRpdCc6ICdBZGQnfSBUYWdzXG5cdDwvaDM+XG5cblx0PElubGluZVRhZ3MgZWRpdGFibGUgcmVzb3VyY2VQYXRoPXtwX2NvbnRhY3R9IC8+XG5cblx0PGRpdiBjbGFzcz1cImFjdGlvbi1saW5lXCI+XG5cdFx0PGJ1dHRvbiBvbjpjbGljaz17KCkgPT4ga19wYWdlLnBvcCgpfT5cblx0XHRcdEJhY2tcblx0XHQ8L2J1dHRvbj5cblxuXHRcdDxidXR0b24gY2xhc3M9XCJwcmltYXJ5XCIgb246Y2xpY2s9eygpID0+IHNhdmUoKX0gcmVhZG9ubHk9eyFiX2Zvcm1fdmFsaWR9PlxuXHRcdFx0e3BfY29udGFjdD8gJ1NhdmUnOiAnQWRkJ31cblx0XHQ8L2J1dHRvbj5cblx0PC9kaXY+XG48L1NjcmVlbj4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHN0eWxlIHR5cGU9XFxcInRleHQvY3NzXFxcIj5cXG5cXHRcXHQuczJyLW1vcmUtdmVydC1mZyB7XFxuXFx0XFx0XFx0ZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcblxcdFxcdH1cXG5cXHQ8L3N0eWxlPlxcblxcdDxwYXRoIGNsYXNzPVxcXCJzMnItbW9yZS12ZXJ0LWZnXFxcIiBkPVxcXCJNMTIgOEMxMy4xIDggMTQgNy4xIDE0IDZDMTQgNC45IDEzLjEgNCAxMiA0QzEwLjkgNCAxMCA0LjkgMTAgNkMxMCA3LjEgMTAuOSA4IDEyIDhaTTEyIDEwQzEwLjkgMTAgMTAgMTAuOSAxMCAxMkMxMCAxMy4xIDEwLjkgMTQgMTIgMTRDMTMuMSAxNCAxNCAxMy4xIDE0IDEyQzE0IDEwLjkgMTMuMSAxMCAxMiAxMFpNMTIgMTZDMTAuOSAxNiAxMCAxNi45IDEwIDE4QzEwIDE5LjEgMTAuOSAyMCAxMiAyMEMxMy4xIDIwIDE0IDE5LjEgMTQgMThDMTQgMTYuOSAxMy4xIDE2IDEyIDE2WlxcXCIgZmlsbD1cXFwiI0ZGQjYxQVxcXCIvPlxcbjwvc3ZnPlxcblwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxwYXRoIHN0eWxlPVxcXCJmaWxsOiB2YXIoLS1zdmctY29sb3ItZmcsY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIk05IDE2aDZ2LTZoNGwtNy03LTcgN2g0djZ6bTMtMTAuMTdMMTQuMTcgOEgxM3Y2aC0yVjhIOS44M0wxMiA1Ljgzek01IDE4aDE0djJINXpcXFwiLz5cXG48L3N2Zz5cIiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7cXVpbnRPdXR9IGZyb20gJ3N2ZWx0ZS9lYXNpbmcnO1xuXHRpbXBvcnQge3l3X2ZhbWlseX0gZnJvbSAnIyMvbWVtJztcblxuXHRpbXBvcnQgU1hfSUNPTl9ET1RTIGZyb20gJyMvaWNvbi9tb3JlLXZlcnQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0VESVQgZnJvbSAnIy9pY29uL2VkaXQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX1NFTkQgZnJvbSAnIy9pY29uL3VwbG9hZC5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fREVMRVRFIGZyb20gJyMvaWNvbi9kZWxldGUuc3ZnP3Jhdyc7XG5cblx0aW1wb3J0IFNYX0lDT05fUEVSU09OQUwgZnJvbSAnIy9pY29uL2FjY291bnRfYm94LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9DT05UUkFDVCBmcm9tICcjL2ljb24vYW5hbHl0aWNzLnN2Zz9yYXcnO1xuXG5cdGltcG9ydCB7c2xpZGV9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblx0aW1wb3J0IEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBSb3cgZnJvbSAnLi9Sb3cuc3ZlbHRlJztcblx0aW1wb3J0IFB1dCBmcm9tICcuL1B1dC5zdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7RGljdCwgSnNvblByaW1pdGl2ZX0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCBJbmxpbmVUYWdzIGZyb20gJy4vSW5saW5lVGFncy5zdmVsdGUnO1xuXG5cdGltcG9ydCBDb250YWN0RWRpdCBmcm9tICcjIy9zY3JlZW4vQ29udGFjdEVkaXQuc3ZlbHRlJztcblx0aW1wb3J0IFNlbmQgZnJvbSAnIyMvc2NyZWVuL1NlbmQuc3ZlbHRlJztcblx0aW1wb3J0IERlYWRFbmQgZnJvbSAnIyMvc2NyZWVuL0RlYWRFbmQuc3ZlbHRlJztcblx0aW1wb3J0IENvbnRhY3RWaWV3IGZyb20gJyMjL3NjcmVlbi9Db250YWN0Vmlldy5zdmVsdGUnO1xuXG5cdGltcG9ydCB0eXBlIHtDb250YWN0LCBDb250YWN0UGF0aH0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXHRpbXBvcnQge0FnZW50c30gZnJvbSAnIy9zdG9yZS9hZ2VudHMnO1xuXHRpbXBvcnQge0NoYWluc30gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXG5cdGltcG9ydCB0eXBlIHtQYWdlfSBmcm9tICcuLi9zY3JlZW4vX3NjcmVlbnMnO1xuXHRpbXBvcnQge2dldENvbnRleHR9IGZyb20gJ3N2ZWx0ZSc7XG5cblx0Ly8gZ2V0IHBhZ2UgZnJvbSBjb250ZXh0XG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuXG5cdGV4cG9ydCBsZXQgZmlsdGVyOiAoZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSkgPT4gYm9vbGVhbiA9IGcgPT4gdHJ1ZTtcblxuXHRleHBvcnQgbGV0IHNvcnQ6IChnX2E6IENvbnRhY3RbJ2ludGVyZmFjZSddLCBnX2I6IENvbnRhY3RbJ2ludGVyZmFjZSddKSA9PiBudW1iZXIgPSAoZ19hLCBnX2IpID0+IGdfYS5uYW1lIDwgZ19iLm5hbWU/IC0xOiAxO1xuXG5cdGV4cG9ydCBsZXQgYXBwZW5kOiBDb250YWN0WydpbnRlcmZhY2UnXVtdID0gW107XG5cblxuXHQvLyBsb2FkIGFsbCBjb250YWN0cyBmb3IgdGhlIGN1cnJlbnQgY2hhaW4ncyBmYW1pbHkgYXMgYSBsaXN0XG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfY29udGFjdHMoKTogUHJvbWlzZTxbQ29udGFjdFBhdGgsIENvbnRhY3RbJ2ludGVyZmFjZSddXVtdPiB7XG5cdFx0Ly8gcmVhZCBmcm9tIGFnZW50cyBzdG9yZVxuXHRcdGNvbnN0IGtzX2FnZW50cyA9IGF3YWl0IEFnZW50cy5yZWFkKCk7XG5cblx0XHQvLyBzcHJlYWQgaXRlcmF0b3IgaW50byBhcnJheVxuXHRcdHJldHVybiBbLi4ua3NfYWdlbnRzLmNvbnRhY3RzKCR5d19mYW1pbHkpXTtcblx0fVxuXG5cdGNvbnN0IGhtX2V2ZW50cyA9IG5ldyBXZWFrTWFwPEV2ZW50LCBEaWN0PEpzb25QcmltaXRpdmU+PigpO1xuXG5cdGxldCBzaV9vdmVybGF5ID0gJyc7XG5cdGZ1bmN0aW9uIGFjdGl2YXRlX292ZXJsYXkocF9jb250YWN0OiBzdHJpbmcsIGdfY29udGFjdDogQ29udGFjdFsnaW50ZXJmYWNlJ10pOiAoZDogTW91c2VFdmVudCkgPT4gdm9pZCB7XG5cdFx0cmV0dXJuIChkX2V2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG5cdFx0XHQvLyBwcmV2ZW50IGV2ZW50IGZyb20gYnViYmxpbmdcblx0XHRcdGRfZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cblx0XHRcdC8vIHJlZiBlbnRyeSBpZFxuXHRcdFx0Y29uc3Qgc2lfc2V0ID0gcF9jb250YWN0O1xuXG5cdFx0XHQvLyBvdmVybGF5IGFscmVhZHkgc2V0IHRvIHRoaXMgZW50cnk7IGhpZGUgaXRcblx0XHRcdGlmKGhtX2V2ZW50cy5nZXQoZF9ldmVudCk/LmNhbmNlbE1lbnUgPT09IHNpX3NldCkge1xuXHRcdFx0XHRzaV9vdmVybGF5ID0gJyc7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0IG92ZXJsYXkgdG8gdGhpcyBlbnRyeVxuXHRcdFx0c2lfb3ZlcmxheSA9IHNpX3NldDtcblxuXHRcdFx0Ly8gcmVtb3ZlIG9uIGNsaWNrIGV2ZW50XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG5cdFx0XHRcdGhtX2V2ZW50cy5zZXQoZF9ldmVudCwge1xuXHRcdFx0XHRcdGNhbmNlbE1lbnU6IHNpX292ZXJsYXksXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzaV9vdmVybGF5ID0gJyc7XG5cdFx0XHR9LCB7XG5cdFx0XHRcdGNhcHR1cmU6IHRydWUsXG5cdFx0XHRcdG9uY2U6IHRydWUsXG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9XG5cblx0Y29uc3QgYV9vdmVybGF5X2FjdGlvbnM6IHtcblx0XHRsYWJlbDogc3RyaW5nO1xuXHRcdGljb246IHN0cmluZztcblx0XHRjbGljayhnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddKTogdm9pZDtcblx0fVtdID0gW1xuXHRcdHtcblx0XHRcdGxhYmVsOiAnRWRpdCcsXG5cdFx0XHRpY29uOiBTWF9JQ09OX0VESVQsXG5cdFx0XHRjbGljayhnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBDb250YWN0RWRpdCxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0Y29udGFjdDogZ19jb250YWN0LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdGxhYmVsOiAnU2VuZCcsXG5cdFx0XHRpY29uOiBTWF9JQ09OX1NFTkQsXG5cdFx0XHRjbGljayhnX2NvbnRhY3Q6IENvbnRhY3RbJ2ludGVyZmFjZSddKSB7XG5cdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRjcmVhdG9yOiBTZW5kLFxuXHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRyZWNpcGllbnQ6IENoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MpLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdGxhYmVsOiAnRGVsZXRlJyxcblx0XHRcdGljb246IFNYX0lDT05fREVMRVRFLFxuXHRcdFx0Y2xpY2soZ19jb250YWN0OiBDb250YWN0WydpbnRlcmZhY2UnXSkge1xuXHRcdFx0XHQvLyBUT0RPOlxuXHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogRGVhZEVuZCxcblx0XHRcdFx0XHRwcm9wczoge30sXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRdO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdC5yb3dzIHtcblx0XHRtYXJnaW4tbGVmdDogY2FsYygwcHggLSB2YXIoLS11aS1wYWRkaW5nKSk7XG5cdFx0bWFyZ2luLXJpZ2h0OiBjYWxjKDBweCAtIHZhcigtLXVpLXBhZGRpbmcpKTtcblxuXHRcdC5yb3cge1xuXHRcdFx0LnN0YXR1cyB7XG5cdFx0XHRcdDpnbG9iYWwoJikge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC5pY29uLm1vcmUtbWVudSB7XG5cdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRwYWRkaW5nLXRvcDogNTAlO1xuXHRcdFx0XHRcdFx0cGFkZGluZy1ib3R0b206IDUwJTtcblx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0XHRvdXRsaW5lOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uOiAzNTBtcyBvdXRsaW5lLWNvbG9yIHZhcigtLWVhc2Utb3V0LWN1YmljKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ6Z2xvYmFsKCY6aG92ZXIpIHtcblx0XHRcdFx0XHRcdG91dGxpbmUtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Omdsb2JhbCgmOmFjdGl2ZSksIDpnbG9iYWwoJi5hY3RpdmUpIHtcblx0XHRcdFx0XHRcdG91dGxpbmUtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC5vdmVybGF5IHtcblx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdFx0XHRcdHBhZGRpbmc6IDEwcHggMTRweDtcblx0XHRcdFx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcblx0XHRcdFx0XHRcdGJvcmRlci1yYWRpdXM6IDhweDtcblx0XHRcdFx0XHRcdHJpZ2h0OiAyNnB4O1xuXHRcdFx0XHRcdFx0dG9wOiAtMThweDtcblx0XHRcdFx0XHRcdG1pbi13aWR0aDogMTIwcHg7XG5cdFx0XHRcdFx0XHR6LWluZGV4OiAxMDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pi5hY3Rpb24ge1xuXHRcdFx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmc6IDEwcHggOHB4O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ+LnRleHQge1xuXHRcdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0XHRwYWRkaW5nLWxlZnQ6IDEwcHg7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQuaWNvbiB7XG5cdFx0XHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC5pY29uLmNvbnRhY3QtdHlwZSB7XG5cdFx0LS1pY29uLWRpYW1ldGVyOiAxNnB4O1xuXHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXHR9XG5cblx0LnBmcC1nZW4ge1xuXHRcdC5mb250KGh1Z2UpO1xuXHRcdGRpc3BsYXk6IGlubGluZS1mbGV4O1xuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdGJvcmRlci1yYWRpdXM6IDIwJTtcblx0XHRvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0YmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KGVsbGlwc2UgZmFydGhlc3Qtc2lkZSBhdCBib3R0b20gcmlnaHQsICMwNzA4MGEsICMwZjEzMTcpO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwicm93c1wiPlxuXHR7I2F3YWl0IGxvYWRfY29udGFjdHMoKX1cblx0XHRMb2FkaW5nIGNvbnRhY3RzLi4uXG5cdHs6dGhlbiBhX2xpc3R9XG5cdFx0eyNlYWNoIGFfbGlzdCBhcyBbcF9jb250YWN0LCBnX2NvbnRhY3RdfVxuXHRcdFx0PFJvd1xuXHRcdFx0XHRyZXNvdXJjZT17Z19jb250YWN0fVxuXHRcdFx0XHRyZXNvdXJjZVBhdGg9e3BfY29udGFjdH1cblx0XHRcdFx0b246Y2xpY2s9eyhkX2V2ZW50KSA9PiB7XG5cdFx0XHRcdFx0aWYoIWhtX2V2ZW50cy5nZXQoZF9ldmVudCk/LmNhbmNlbE1lbnUpIHtcblx0XHRcdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0Y3JlYXRvcjogQ29udGFjdFZpZXcsXG5cdFx0XHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGFjdDogZ19jb250YWN0LFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9fVxuXHRcdFx0PlxuXHRcdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJkZXRhaWxcIj5cblx0XHRcdFx0XHQ8QWRkcmVzcyBhZGRyZXNzPXtDaGFpbnMuYmVjaDMyKGdfY29udGFjdC5hZGRyZXNzKycnKX0gLz5cblx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cblx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwidGFnc1wiPlxuXHRcdFx0XHRcdDxJbmxpbmVUYWdzIGNvbGxhcHNlZCByb290U3R5bGU9J21hcmdpbjogMHB4Oydcblx0XHRcdFx0XHRcdHJlc291cmNlUGF0aD17cF9jb250YWN0fVxuXHRcdFx0XHRcdD5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvbiBjb250YWN0LXR5cGVcIiBzbG90PVwicHJlZml4XCI+XG5cdFx0XHRcdFx0XHRcdHtAaHRtbCBTWF9JQ09OX1BFUlNPTkFMfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDwvSW5saW5lVGFncz5cblx0XHRcdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cblx0XHRcdFx0PHN2ZWx0ZTpmcmFnbWVudCBzbG90PVwic3RhdHVzXCI+XG5cdFx0XHRcdFx0PHNwYW5cblx0XHRcdFx0XHRcdGNsYXNzPVwiaWNvbiBtb3JlLW1lbnVcIlxuXHRcdFx0XHRcdFx0Y2xhc3M6YWN0aXZlPXtzaV9vdmVybGF5ID09PSBwX2NvbnRhY3R9XG5cdFx0XHRcdFx0XHRvbjpjbGljaz17YWN0aXZhdGVfb3ZlcmxheShwX2NvbnRhY3QsIGdfY29udGFjdCl9XG5cdFx0XHRcdFx0PlxuXHRcdFx0XHRcdFx0e0BodG1sIFNYX0lDT05fRE9UU31cblx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHR7I2lmIHNpX292ZXJsYXkgPT09IHBfY29udGFjdH1cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwib3ZlcmxheVwiIHRyYW5zaXRpb246c2xpZGU9e3tkdXJhdGlvbjozMDAsIGVhc2luZzpxdWludE91dH19PlxuXHRcdFx0XHRcdFx0XHR7I2VhY2ggYV9vdmVybGF5X2FjdGlvbnMgYXMgZ19hY3Rpb259XG5cdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImFjdGlvblwiIG9uOmNsaWNrPXsoZF9ldmVudCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZF9ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdFx0XHRcdGdfYWN0aW9uLmNsaWNrKGdfY29udGFjdCk7XG5cdFx0XHRcdFx0XHRcdFx0fX0+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImljb25cIj5cblx0XHRcdFx0XHRcdFx0XHRcdFx0e0BodG1sIGdfYWN0aW9uLmljb259XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cblx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7Z19hY3Rpb24ubGFiZWx9XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdHsvZWFjaH1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5cblx0XHRcdDwvUm93PlxuXHRcdHsvZWFjaH1cblx0ey9hd2FpdH1cbjwvZGl2PiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7Z2V0Q29udGV4dH0gZnJvbSAnc3ZlbHRlJztcblxuXHRpbXBvcnQge1xuXHRcdFRhYnMsXG5cdFx0VGFiLFxuXHRcdFRhYkxpc3QsXG5cdFx0VGFiUGFuZWwsXG5cdH0gZnJvbSAnc3ZlbHRlLXRhYnMnO1xuXG5cdGltcG9ydCB7XG5cdFx0U2NyZWVuLFxuXHRcdEhlYWRlcixcblx0XHR0eXBlIFBhZ2UsXG5cdH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0aW1wb3J0IENvbnRhY3RFZGl0IGZyb20gJy4vQ29udGFjdEVkaXQuc3ZlbHRlJztcblx0aW1wb3J0IFN1YkhlYWRlciBmcm9tICcuLi91aS9TdWJIZWFkZXIuc3ZlbHRlJztcblx0aW1wb3J0IENvbnRhY3RMaXN0IGZyb20gJy4uL3VpL0NvbnRhY3RMaXN0LnN2ZWx0ZSc7XG5cdGltcG9ydCB7Q29udGFjdEFnZW50VHlwZX0gZnJvbSAnIy9tZXRhL2NvbnRhY3QnO1xuXG5cdGNvbnN0IGtfcGFnZSA9IGdldENvbnRleHQ8UGFnZT4oJ3BhZ2UnKTtcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuL19iYXNlLmxlc3MnO1xuXG5cdC5zY3JlZW4uY29udGFjdHMgZGl2LnN2ZWx0ZS10YWJzPmRpdi5zdmVsdGUtdGFic19fdGFiLXBhbmVsIHtcblx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdG1hcmdpbi10b3A6IC0xcHg7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG48U2NyZWVuIG5hdiByb290IGNsYXNzTmFtZXM9J2NvbnRhY3RzJz5cblx0PEhlYWRlciBzZWFyY2ggbmV0d29yayBhY2NvdW50XG5cdD5cblx0PC9IZWFkZXI+XG5cblx0PFN1YkhlYWRlciB0aXRsZT1cIkNvbnRhY3RzXCJcblx0Lz5cblx0PCEtLSBidXR0b25zPXtbJ0V4cG9ydCddfSAtLT5cblx0PCEtLSBvbjphZGRfbmV3PXsoKSA9PiBrX3BhZ2UucHVzaCh7Y3JlYXRvcjpDb250YWN0RWRpdH0pfSAtLT5cblx0XG5cdDxUYWJzPlxuXHRcdDxUYWJMaXN0PlxuXHRcdFx0PFRhYj5cblx0XHRcdFx0QWxsXG5cdFx0XHQ8L1RhYj5cblxuXHRcdFx0PFRhYj5cblx0XHRcdFx0SHVtYW5zXG5cdFx0XHQ8L1RhYj5cblxuXHRcdFx0PFRhYj5cblx0XHRcdFx0Q29udHJhY3RzXG5cdFx0XHQ8L1RhYj5cblx0XHQ8L1RhYkxpc3Q+XG5cblxuXHRcdDwhLS0gQWxsIC0tPlxuXHRcdDxUYWJQYW5lbD5cblx0XHRcdDxDb250YWN0TGlzdCAvPlxuXHRcdDwvVGFiUGFuZWw+XG5cblxuXHRcdDwhLS0gSHVtYW5zIC0tPlxuXHRcdDxUYWJQYW5lbD5cblx0XHRcdDxDb250YWN0TGlzdFxuXHRcdFx0XHRmaWx0ZXI9e2dfY29udGFjdCA9PiBDb250YWN0QWdlbnRUeXBlLlBFUlNPTiA9PT0gZ19jb250YWN0LmFnZW50VHlwZX1cblx0XHRcdC8+XG5cdFx0PC9UYWJQYW5lbD5cblxuXHRcdFxuXHRcdDwhLS0gQ29udHJhY3RzIC0tPlxuXHRcdDxUYWJQYW5lbD5cblx0XHRcdDxDb250YWN0TGlzdFxuXHRcdFx0XHRmaWx0ZXI9e2dfY29udGFjdCA9PiBDb250YWN0QWdlbnRUeXBlLkNPTlRSQUNUID09PSBnX2NvbnRhY3QuYWdlbnRUeXBlfVxuXHRcdFx0Lz5cblx0XHQ8L1RhYlBhbmVsPlxuXG5cdDwvVGFicz5cblxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgQXBwcyB9IGZyb20gXCIjL3N0b3JlL2FwcHNcIjtcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gXCJzdmVsdGVcIjtcblx0aW1wb3J0IEhlYWRlciBmcm9tIFwiLi4vdWkvSGVhZGVyLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgUm93IGZyb20gXCIuLi91aS9Sb3cuc3ZlbHRlXCI7XG5cdGltcG9ydCB7IFBhZ2UsIFNjcmVlbiwgU3ViSGVhZGVyIH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIGxvYWRfYXBwcygpIHtcblx0XHRjb25zdCBrc19hcHBzID0gYXdhaXQgQXBwcy5yZWFkKCk7XG5cblx0XHRyZXR1cm4ga3NfYXBwcy5lbnRyaWVzKCk7XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0XG48L3N0eWxlPlxuXG48U2NyZWVuIGRlYnVnPSdTaXRlc0hvbWUnIG5hdiByb290PlxuXHQ8SGVhZGVyIHNlYXJjaCBuZXR3b3JrIGFjY291bnQgLz5cblxuXHQ8U3ViSGVhZGVyIGJhcmVcblx0XHR0aXRsZT0nU2l0ZXMgLyBBcHBzJ1xuXHQvPlxuXG5cdDxkaXYgY2xhc3M9XCJyb3dzIG5vLW1hcmdpblwiPlxuXHRcdHsjYXdhaXQgbG9hZF9hcHBzKCl9XG5cdFx0XHRMb2FkaW5nLi4uXG5cdFx0ezp0aGVuIGFfYXBwc30gXG5cdFx0XHR7I2VhY2ggYV9hcHBzIGFzIFtwX2FwcCwgZ19hcHBdfVxuXHRcdFx0XHQ8Um93XG5cdFx0XHRcdFx0cGZwPXtnX2FwcC5wZnB9XG5cdFx0XHRcdFx0bmFtZT17Z19hcHAuaG9zdH1cblx0XHRcdFx0XHRyZXNvdXJjZVBhdGg9e3BfYXBwfVxuXHRcdFx0XHRcdGljb25DbGFzcz17J3NxdWFyZSBwZnAnfVxuXHRcdFx0XHRcdG9uOmNsaWNrPXsoKSA9PiB7XG5cdFx0XHRcdFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0XHRcdFx0XHRcdC8vIGNyZWF0b3I6IFNpdGVWaWV3LFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fX1cblx0XHRcdFx0PlxuXHRcdFx0XHQ8L1Jvdz5cblx0XHRcdHsvZWFjaH1cblx0XHR7L2F3YWl0fVxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7eXdfYWNjb3VudCwgeXdfY2hhaW59IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdFxuXHRpbXBvcnQgeyBIZWFkZXIsIHR5cGUgUGFnZSwgU2NyZWVuIH0gZnJvbSAnLi4vc2NyZWVuL19zY3JlZW5zJztcblx0aW1wb3J0IFBvcnRyYWl0IGZyb20gJyMjL3VpL1BvcnRyYWl0LnN2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgTmV0d29yaywgTmV0d29ya1BhdGggfSBmcm9tICcjL21ldGEvbmV0d29yayc7XG5cdGltcG9ydCB7IE5ldHdvcmtzIH0gZnJvbSAnIy9zdG9yZS9uZXR3b3Jrcyc7XG5cdGltcG9ydCB0eXBlIHsgQ2hhaW4sIENoYWluUGF0aCB9IGZyb20gJyMvbWV0YS9jaGFpbic7XG5pbXBvcnQgRmllbGQgZnJvbSAnLi4vdWkvRmllbGQuc3ZlbHRlJztcbmltcG9ydCBJbmZvIGZyb20gJy4uL3VpL0luZm8uc3ZlbHRlJztcbmltcG9ydCBHYXAgZnJvbSAnLi4vdWkvR2FwLnN2ZWx0ZSc7XG5cblxuXHRleHBvcnQgbGV0IG5ldHdvcmtSZWY6IE5ldHdvcmtQYXRoO1xuXHRjb25zdCBwX25ldHdvcmsgPSBuZXR3b3JrUmVmO1xuXG5cdGxldCBnX25ldHdvcms6IE5ldHdvcmtbJ2ludGVyZmFjZSddO1xuXHR2b2lkIE5ldHdvcmtzLmF0KHBfbmV0d29yaykudGhlbihnID0+IGdfbmV0d29yayA9IGchKTtcblxuXHQkOiBwX2NoYWluID0gZ19uZXR3b3JrPy5jaGFpbjtcblxuXHRsZXQgZ19jaGFpbjogQ2hhaW5bJ2ludGVyZmFjZSddO1xuXHQkOiBpZihwX2NoYWluKSB7XG5cdFx0dm9pZCBDaGFpbnMuYXQocF9jaGFpbiBhcyBDaGFpblBhdGgpLnRoZW4oZyA9PiBnX2NoYWluID0gZyEpO1xuXHR9XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGNvbnN0IGdjX2FjdGlvbnMgPSB7XG5cdFx0Ly8gc2VuZDoge1xuXHRcdC8vIFx0bGFiZWw6ICdTZW5kJyxcblx0XHQvLyBcdHRyaWdnZXIoKSB7XG5cdFx0Ly8gXHRcdGtfcGFnZS5wdXNoKHtcblx0XHQvLyBcdFx0XHRjcmVhdG9yOiBTZW5kLFxuXHRcdC8vIFx0XHRcdHByb3BzOiB7XG5cdFx0Ly8gXHRcdFx0XHR0bzogQ2hhaW5zLmJlY2gzMihnX25ldHdvcmsuYWRkcmVzcyksXG5cdFx0Ly8gXHRcdFx0fSxcblx0XHQvLyBcdFx0fSk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdFx0Ly8gZWRpdDoge1xuXHRcdC8vIFx0bGFiZWw6ICdFZGl0Jyxcblx0XHQvLyBcdHRyaWdnZXIoKSB7XG5cdFx0Ly8gXHRcdGtfcGFnZS5wdXNoKHtcblx0XHQvLyBcdFx0XHRjcmVhdG9yOiBDb250YWN0RWRpdCxcblx0XHQvLyBcdFx0XHRwcm9wczoge1xuXHRcdC8vIFx0XHRcdFx0Y29udGFjdFJlZjogcF9uZXR3b3JrLFxuXHRcdC8vIFx0XHRcdH0sXG5cdFx0Ly8gXHRcdH0pO1xuXHRcdC8vIFx0fSxcblx0XHQvLyB9LFxuXHRcdC8vIGRlbGV0ZToge1xuXHRcdC8vIFx0bGFiZWw6ICdEZWxldGUnLFxuXHRcdC8vIFx0dHJpZ2dlcigpIHtcblx0XHQvLyBcdFx0a19wYWdlLnB1c2goe1xuXHRcdC8vIFx0XHRcdGNyZWF0b3I6IERlYWRFbmQsXG5cdFx0Ly8gXHRcdH0pO1xuXHRcdC8vIFx0fSxcblx0XHQvLyB9LFxuXHR9O1xuXG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJ19iYXNlLmxlc3MnO1xuXG5cblx0LnBmcC1nZW4ge1xuXHRcdC5mb250KGh1Z2UsIEBzaXplOiAzMHB4KTtcblx0XHRkaXNwbGF5OiBpbmxpbmUtZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0XHRib3JkZXItcmFkaXVzOiAyMCU7XG5cdFx0b3V0bGluZTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdGJhY2tncm91bmQ6IHJhZGlhbC1ncmFkaWVudChlbGxpcHNlIGZhcnRoZXN0LXNpZGUgYXQgYm90dG9tIHJpZ2h0LCAjMDcwODBhLCAjMGYxMzE3KTtcblx0fVxuPC9zdHlsZT5cblxuXG48U2NyZWVuIG5hdiBzbGlkZXM+XG5cdDxIZWFkZXIgcG9wcyBzZWFyY2ggbmV0d29yayBhY2NvdW50IC8+XG5cblx0eyNpZiAhZ19jaGFpbn1cblx0XHRMb2FkaW5nIG5ldHdvcmsuLi5cblx0ezplbHNlfVxuXHRcdDxQb3J0cmFpdFxuXHRcdFx0cmVzb3VyY2U9e2dfbmV0d29ya31cblx0XHRcdHJlc291cmNlUGF0aD17cF9uZXR3b3JrfVxuXHRcdFx0YWN0aW9ucz17Z2NfYWN0aW9uc31cblx0XHQ+XG5cdFx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJzdWJ0aXRsZVwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImZvbnQtZmFtaWx5X21vbm9cIj5cblx0XHRcdFx0XHR7Z19jaGFpbi5uYW1lfSAoe2dfY2hhaW4uaWR9KVxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L3N2ZWx0ZTpmcmFnbWVudD5hZGRyZXNzXG5cdFx0PC9Qb3J0cmFpdD5cblxuXHRcdDxGaWVsZFxuXHRcdFx0bmFtZT0nZ1JQQy13ZWIgVVJMJ1xuXHRcdFx0a2V5PSdncnBjLXdlYidcblx0XHQ+XG5cdFx0XHQ8SW5mbyBrZXk9J2dycGMtd2ViLXZhbHVlJz5cblx0XHRcdFx0e2dfbmV0d29yay5ncnBjV2ViVXJsfVxuXHRcdFx0PC9JbmZvPlxuXHRcdDwvRmllbGQ+XG5cblx0XHR7I2lmIGdfbmV0d29yay5ycGNIb3N0fVxuXHRcdFx0PEZpZWxkXG5cdFx0XHRcdG5hbWU9J1JQQyBIb3N0J1xuXHRcdFx0XHRrZXk9J3JwYydcblx0XHRcdD5cblx0XHRcdFx0PEluZm8ga2V5PSdycGMtdmFsdWUnPlxuXHRcdFx0XHRcdHtnX25ldHdvcmsucnBjSG9zdH1cblx0XHRcdFx0PC9JbmZvPlxuXHRcdFx0PC9GaWVsZD5cblx0XHR7L2lmfVxuXHR7L2lmfVxuXG5cdDxHYXAgLz5cblxuPC9TY3JlZW4+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtDaGFpbnN9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHtOZXR3b3Jrc30gZnJvbSAnIy9zdG9yZS9uZXR3b3Jrcyc7XG5cdGltcG9ydCB7Z2V0Q29udGV4dH0gZnJvbSAnc3ZlbHRlJztcblx0aW1wb3J0IEhlYWRlciBmcm9tICcuLi91aS9IZWFkZXIuc3ZlbHRlJztcblx0aW1wb3J0IFJvdyBmcm9tICcuLi91aS9Sb3cuc3ZlbHRlJztcblx0aW1wb3J0IE5ldHdvcmtWaWV3IGZyb20gJy4vTmV0d29ya1ZpZXcuc3ZlbHRlJztcblx0aW1wb3J0IHtQYWdlLCBTY3JlZW4sIFN1YkhlYWRlcn0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0Y29uc3Qga19wYWdlID0gZ2V0Q29udGV4dDxQYWdlPigncGFnZScpO1xuXG5cdGxldCBrc19jaGFpbnM6IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgQ2hhaW5zLnJlYWQ+Pjtcblx0bGV0IGtzX25ldHdvcmtzOiBBd2FpdGVkPFJldHVyblR5cGU8dHlwZW9mIE5ldHdvcmtzLnJlYWQ+Pjtcblx0YXN5bmMgZnVuY3Rpb24gbG9hZF9uZXR3b3JrcygpIHtcblx0XHRbXG5cdFx0XHRrc19jaGFpbnMsXG5cdFx0XHRrc19uZXR3b3Jrcyxcblx0XHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuXHRcdFx0Q2hhaW5zLnJlYWQoKSxcblx0XHRcdE5ldHdvcmtzLnJlYWQoKSxcblx0XHRdKTtcblxuXHRcdHJldHVybiBrc19uZXR3b3Jrcy5lbnRyaWVzKCk7XG5cdH1cblxuXHQvLyBmdW5jdGlvbiBhZGRfbmV3X25ldHdvcmsoKSB7XG5cdC8vIFx0a19wYWdlLnB1c2goe1xuXHQvLyBcdFx0Y3JlYXRvcjogTmV0d29ya0NyZWF0ZSxcblx0Ly8gXHR9KTtcblx0Ly8gfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRcbjwvc3R5bGU+XG5cbjxTY3JlZW4gZGVidWc9J05ldHdvcmtzSG9tZScgbmF2IHJvb3Q+XG5cdDxIZWFkZXIgc2VhcmNoIG5ldHdvcmsgYWNjb3VudCAvPlxuXG5cdDxTdWJIZWFkZXIgYmFyZVxuXHRcdHRpdGxlPSdOZXR3b3Jrcydcblx0Lz5cblx0XHQ8IS0tIG9uOmFkZF9uZXc9e2FkZF9uZXdfbmV0d29ya30gLS0+XG5cblx0PGRpdiBjbGFzcz1cInJvd3Mgbm8tbWFyZ2luXCI+XG5cdFx0eyNhd2FpdCBsb2FkX25ldHdvcmtzKCl9XG5cdFx0XHRMb2FkaW5nLi4uXG5cdFx0ezp0aGVuIGFfbmV0d29ya3N9IFxuXHRcdFx0eyNlYWNoIGFfbmV0d29ya3MgYXMgW3BfbmV0d29yaywgZ19uZXR3b3JrXX1cblx0XHRcdFx0e0Bjb25zdCBnX2NoYWluID0ga3NfY2hhaW5zLmF0KGdfbmV0d29yay5jaGFpbil9XG5cdFx0XHRcdDxSb3dcblx0XHRcdFx0XHRyZXNvdXJjZT17Z19uZXR3b3JrfVxuXHRcdFx0XHRcdHJlc291cmNlUGF0aD17cF9uZXR3b3JrfVxuXHRcdFx0XHRcdGljb25DbGFzcz17J3NxdWFyZSBwZnAnfVxuXHRcdFx0XHRcdGRldGFpbD17YCR7Z19jaGFpbj8ubmFtZX0gKCR7Z19jaGFpbj8uaWR9KWB9XG5cdFx0XHRcdFx0b246Y2xpY2s9eygpID0+IHtcblx0XHRcdFx0XHRcdGtfcGFnZS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0Y3JlYXRvcjogTmV0d29ya1ZpZXcsXG5cdFx0XHRcdFx0XHRcdHByb3BzOiB7XG5cdFx0XHRcdFx0XHRcdFx0bmV0d29ya1JlZjogcF9uZXR3b3JrLFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fX1cblx0XHRcdFx0PlxuXHRcdFx0XHQ8L1Jvdz5cblx0XHRcdHsvZWFjaH1cblx0XHR7L2F3YWl0fVxuXHQ8L2Rpdj5cbjwvU2NyZWVuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7IGdsb2JhbF9yZWNlaXZlIH0gZnJvbSAnIy9zY3JpcHQvbXNnLWdsb2JhbCc7XG5cblx0aW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnIy9zdG9yZS9ldmVudHMnO1xuXHRpbXBvcnQgeyBvbkRlc3Ryb3kgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBvbmNlX3N0b3JlX3VwZGF0ZXMgfSBmcm9tICcuLi9zdmVsdGUnO1xuXHRpbXBvcnQgVHhuTGlzdCBmcm9tICcuLi91aS9UeG5MaXN0LnN2ZWx0ZSc7XG5cblx0aW1wb3J0IHtcblx0XHRTY3JlZW4sXG5cdFx0SGVhZGVyLFxuXHRcdFN1YkhlYWRlcixcblx0XHR0eXBlIFBhZ2UsXG5cdH0gZnJvbSAnLi9fc2NyZWVucyc7XG5cblx0bGV0IGNfcmVsb2FkcyA9IDE7XG5cdGNvbnN0IGZfdW5zdWJzY3JpYmUgPSBnbG9iYWxfcmVjZWl2ZSh7XG5cdFx0dXBkYXRlU3RvcmUoe2tleTpzaV9zdG9yZX0pIHtcblx0XHRcdGlmKCdldmVudHMnID09PSBzaV9zdG9yZSkge1xuXHRcdFx0XHRjX3JlbG9hZHMrKztcblx0XHRcdH1cblx0XHR9LFxuXHR9KTtcblxuXHRvbkRlc3Ryb3koKCkgPT4ge1xuXHRcdGZfdW5zdWJzY3JpYmUoKTtcblx0fSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4vX2Jhc2UubGVzcyc7XG5cbjwvc3R5bGU+XG5cbjxTY3JlZW4gbmF2IHJvb3Rcbj5cblx0PEhlYWRlciBzZWFyY2ggbmV0d29yayBhY2NvdW50XG5cdD5cblx0XHQ8c3ZlbHRlOmZyYWdtZW50IHNsb3Q9XCJ0aXRsZVwiPlxuXG5cdFx0PC9zdmVsdGU6ZnJhZ21lbnQ+XG5cdDwvSGVhZGVyPlxuXG5cdDxTdWJIZWFkZXJcblx0XHR0aXRsZT0nSGlzdG9yeSdcblx0XHRiYXJlXG5cdD48L1N1YkhlYWRlcj5cblxuXHQ8IS0tIFxuXHQ8cCBzdHlsZT0nZm9udC1zaXplOjEycHgnPlxuXHRcdDxzcGFuIHN0eWxlPSdjb2xvcjp2YXIoLS10aGVtZS1jb2xvci1jYXV0aW9uKTsnPkRpc2NsYWltZXI6IDwvc3Bhbj5cblx0XHRUaGlzIHRlbXBvcmFyeSBoaXN0b3J5IGludGVyZmFjZSBkb2VzIG5vdCByZXByZXNlbnQgdGhlIGxvb2sgYW5kIGZ1bmN0aW9uIG9mIHRoZSBhY3R1YWwgaGlzdG9yeSBpbnRlcmZhY2UgY3VycmVudGx5IHVuZGVyIGRldmVsb3BtZW50IGZvciBiZXRhLlxuXHQ8L3A+IC0tPlxuXG5cdHsja2V5IGNfcmVsb2Fkc31cblx0XHR7I2F3YWl0IEV2ZW50cy5yZWFkKCl9XG5cdFx0XHRMb2FkaW5nIGhpc3RvcnkuLi5cblx0XHR7OnRoZW4ga3NfZXZlbnRzfVxuXHRcdFx0e0Bjb25zdCBhX2V2ZW50cyA9IGtzX2V2ZW50cy5yYXd9XG5cblx0XHRcdDxUeG5MaXN0XG5cdFx0XHRcdGV2ZW50cz17YV9ldmVudHN9XG5cdFx0XHQvPlxuXHRcdHsvYXdhaXR9XG5cdHsva2V5fVxuPC9TY3JlZW4+XG4iLCJpbXBvcnQgQmxhbmtTdmVsdGUgZnJvbSAnLi9zY3JlZW4vQmxhbmsuc3ZlbHRlJztcbmltcG9ydCBSZWdpc3RlclN2ZWx0ZSBmcm9tICcuL3NjcmVlbi9SZWdpc3Rlci5zdmVsdGUnO1xuaW1wb3J0IEhvbGRpbmdzSG9tZVN2ZWx0ZSBmcm9tICcuL3NjcmVlbi9Ib2xkaW5nc0hvbWUuc3ZlbHRlJztcbmltcG9ydCBBY2NvdW50SG9tZVN2ZWx0ZSBmcm9tICcuL3NjcmVlbi9BY2NvdW50c0hvbWUuc3ZlbHRlJztcbmltcG9ydCBDb250YWN0c0hvbWVTdmVsdGUgZnJvbSAnLi9zY3JlZW4vQ29udGFjdHNIb21lLnN2ZWx0ZSc7XG5pbXBvcnQgU2l0ZXNIb21lU3ZlbHRlIGZyb20gJy4vc2NyZWVuL1NpdGVzSG9tZS5zdmVsdGUnO1xuaW1wb3J0IE5ldHdvcmtzSG9tZVN2ZWx0ZSBmcm9tICcuL3NjcmVlbi9OZXR3b3Jrc0hvbWUuc3ZlbHRlJztcbmltcG9ydCBIaXN0b3J5SG9tZVN2ZWx0ZSBmcm9tICcuL3NjcmVlbi9IaXN0b3J5SG9tZS5zdmVsdGUnO1xuXG5leHBvcnQgZW51bSBUaHJlYWRJZCB7XG5cdERFRkFVTFQ9J2RlZmF1bHQnLFxuXHRJTklUPSdpbml0Jyxcblx0U0VBUkNIPSdzZWFyY2gnLFxuXHRUT0tFTlM9J3Rva2VucycsXG5cdE5GVFM9J25mdHMnLFxuXHRDT05UQUNUUz0nY29udGFjdHMnLFxuXHRISVNUT1JZPSdoaXN0b3J5Jyxcblx0TkVUV09SS1M9J25ldHdvcmtzJyxcblx0QUNDT1VOVFM9J2FjY291bnRzJyxcblx0VEFHUz0ndGFncycsXG5cdFNJVEVTPSdzaXRlcycsXG59XG5cbmV4cG9ydCBjb25zdCBIX1RIUkVBRFMgPSB7XG5cdFtUaHJlYWRJZC5ERUZBVUxUXTogQmxhbmtTdmVsdGUsXG5cdFtUaHJlYWRJZC5JTklUXTogUmVnaXN0ZXJTdmVsdGUsXG5cdC8vIFtUaHJlYWRJZC5TRUFSQ0hdOiBTZWFyY2gsXG5cdFtUaHJlYWRJZC5UT0tFTlNdOiBIb2xkaW5nc0hvbWVTdmVsdGUsXG5cdC8vIFtUaHJlYWRJZC5ORlRTXTogR2FsbGVyeSxcblx0W1RocmVhZElkLkNPTlRBQ1RTXTogQ29udGFjdHNIb21lU3ZlbHRlLFxuXHRbVGhyZWFkSWQuSElTVE9SWV06IEhpc3RvcnlIb21lU3ZlbHRlLFxuXHRbVGhyZWFkSWQuTkVUV09SS1NdOiBOZXR3b3Jrc0hvbWVTdmVsdGUsXG5cdFtUaHJlYWRJZC5BQ0NPVU5UU106IEFjY291bnRIb21lU3ZlbHRlLFxuXHQvLyAvLyBbVGhyZWFkSWQuVGFnc106IFRhZ3MsXG5cdFtUaHJlYWRJZC5TSVRFU106IFNpdGVzSG9tZVN2ZWx0ZSxcbn0gYXMgY29uc3Q7XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQge1xuXHRcdHl3X292ZXJzY3JvbGxfcGN0LFxuXHR9IGZyb20gJyMjL21lbSc7XG5cblx0bGV0IGRtX3Byb2dyZXNzOiBTVkdDaXJjbGVFbGVtZW50O1xuXG5cdC8vICQ6IHtcblx0Ly8gXHRkbV9wcm9ncmVzcy5zdHlsZS4keXdfb3ZlcnNjcm9sbF9wY3Rcblx0Ly8gfVxuPC9zY3JpcHQ+XG5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdHN2ZyB7XG5cdFx0ZGlzcGxheTogbm9uZTtcblx0XHR6LWluZGV4OiAyMDAwMTtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAxMHB4O1xuXHRcdGxlZnQ6IGNhbGMoNTAlIC0gMTZweCk7XG5cblx0XHQucHJvZ3Jlc3Mge1xuXHRcdFx0c3Ryb2tlLWRhc2hhcnJheTogNjI7XG5cdFx0XHRzdHJva2UtZGFzaG9mZnNldDogNjI7XG5cdFx0XHRzdHJva2UtbGluZWNhcDogcm91bmQ7XG5cdFx0XHR0cmFuc2l0aW9uOiBzdHJva2UtZGFzaGFycmF5IDEwMG1zIGxpbmVhcjtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cblxuPHN2ZyB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiB2aWV3Qm94PVwiMCAwIDMyIDMyXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGNsYXNzPVwib3ZlcnNjcm9sbFwiPlxuXHQ8c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0XHQub3ZlcnNjcm9sbCB7XG5cdFx0XHQuYmcge1xuXHRcdFx0XHRmaWxsOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0LnJpbmcge1xuXHRcdFx0XHRmaWxsOiB0cmFuc3BhcmVudDtcblx0XHRcdFx0c3Ryb2tlOiAjYzRjNGM0O1xuXHRcdFx0fVxuXG5cdFx0XHQucHJvZ3Jlc3Mge1xuXHRcdFx0XHRmaWxsOiB0cmFuc3BhcmVudDtcblx0XHRcdFx0c3Ryb2tlOiBibGFjaztcblx0XHRcdH1cblx0XHR9XG5cdDwvc3R5bGU+XG5cblx0PGNpcmNsZSBjeD1cIjE2XCIgY3k9XCIxNlwiIHI9XCIxNlwiIGNsYXNzPVwiYmdcIiAvPlxuXG5cdDxjaXJjbGUgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTBcIiBjbGFzcz1cInJpbmdcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3R5bGU9XCJvcGFjaXR5OjAuMjtcIiAvPlxuXG5cdDxjaXJjbGUgY3g9XCIxNlwiIGN5PVwiMTZcIiByPVwiMTBcIiBjbGFzcz1cInByb2dyZXNzXCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0eWxlPVwic3Ryb2tlLWRhc2hvZmZzZXQ6ezYyIC0gKCR5d19vdmVyc2Nyb2xsX3BjdCAqIDYyKX1cIiBiaW5kOnRoaXM9e2RtX3Byb2dyZXNzfSAvPlxuXHRcblx0PCEtLSA8cGF0aCBkPVwiTTE2IDE2IEExNiA2IHt4YV9wY3R9IHt4YV9wY3R9XCIgY2xhc3M9XCJzMnItb3ZlcmZsb3ctZmdcIiAvPiAtLT5cbjwvc3ZnPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XG5cdGltcG9ydCB7XG5cdFx0eXdfcG9wdXAsXG5cdH0gZnJvbSAnIyMvbWVtJztcblxuXG5cdFxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdC5wb3B1cCB7XG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiB2YXIoLS1hcHAtd2luZG93LWhlaWdodCk7XG5cdFx0bGVmdDogMDtcblx0XHR6LWluZGV4OiAxMTAwO1xuXG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcblx0XHR0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMzVzIGxpbmVhcjtcblxuXHRcdCYuc2hvd2luZyB7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRwb2ludGVyLWV2ZW50czogaW5pdGlhbDtcblx0XHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjg1KTtcblxuXHRcdFx0Pi5jb250ZW50IHtcblx0XHRcdFx0Ly8gdG9wOiAyNHB4O1xuXHRcdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMjRweCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Pi5jb250ZW50IHtcblx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdC8vIHRvcDogdmFyKC0tYXBwLXdpbmRvdy1oZWlnaHQpO1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0bGVmdDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gdmFyKC0tdWktcGFkZGluZykgLSB2YXIoLS11aS1wYWRkaW5nKSk7XG5cdFx0XHRoZWlnaHQ6IDg3JTtcblx0XHRcdG92ZXJmbG93LXk6IHNjcm9sbDtcblx0XHRcdC5oaWRlLXNjcm9sbGJhcigpO1xuXG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRib3JkZXItcmFkaXVzOiA4cHg7XG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0cGFkZGluZzogdmFyKC0tdWktcGFkZGluZyk7XG5cblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0Z2FwOiB2YXIoLS11aS1wYWRkaW5nKTtcblxuXHRcdFx0Ly8gdHJhbnNpdGlvbjogdG9wIDY3NW1zIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0XHRcdHRyYW5zaXRpb246IHRyYW5zZm9ybSA2NzVtcyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZVkodmFyKC0tYXBwLXdpbmRvdy1oZWlnaHQpKTtcblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxkaXYgY2xhc3M9XCJwb3B1cFwiIGNsYXNzOnNob3dpbmc9e251bGwgIT09ICR5d19wb3B1cH0gb246Y2xpY2s9eygpID0+ICR5d19wb3B1cCA9IG51bGx9PlxuXHQ8c2VjdGlvbiBjbGFzcz1cInNjcmVlbiBjb250ZW50XCIgb246Y2xpY2s9eyhkX2V2ZW50KSA9PiBkX2V2ZW50LnN0b3BQcm9wYWdhdGlvbigpfT5cblx0XHQ8c3ZlbHRlOmNvbXBvbmVudCB0aGlzPXskeXdfcG9wdXB9Pjwvc3ZlbHRlOmNvbXBvbmVudD5cblx0PC9zZWN0aW9uPlxuPC9kaXY+XG4iLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZyxjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTEyIDE2TDE4IDEwTDE2LjU5IDguNTlMMTIgMTMuMTdMNy40MSA4LjU5TDYgMTBMMTIgMTZaXFxcIiAvPlxcbjwvc3ZnPlxcblwiIiwiZXhwb3J0IGRlZmF1bHQgXCI8c3ZnIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPlxcblxcdDxzdHlsZSB0eXBlPVxcXCJ0ZXh0L2Nzc1xcXCI+XFxuXFx0XFx0LnMyci10b2tlbnMtZmcge1xcblxcdFxcdFxcdGZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXG5cXHRcXHR9XFxuXFx0PC9zdHlsZT5cXG5cXHQ8cGF0aCBjbGFzcz1cXFwiczJyLXRva2Vucy1mZ1xcXCIgZD1cXFwiTTE1IDRjLTQuNDIgMC04IDMuNTgtOCA4czMuNTggOCA4IDggOC0zLjU4IDgtOC0zLjU4LTgtOC04Wm0wIDE0Yy0zLjMxIDAtNi0yLjY5LTYtNnMyLjY5LTYgNi02IDYgMi42OSA2IDYtMi42OSA2LTYgNlpNMyAxMmE1Ljk5IDUuOTkgMCAwIDEgNC01LjY1VjQuMjZDMy41NSA1LjE1IDEgOC4yNyAxIDEyYzAgMy43MyAyLjU1IDYuODUgNiA3Ljc0di0yLjA5QTUuOTkgNS45OSAwIDAgMSAzIDEyWlxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLGN1cnJlbnRDb2xvcik7XFxcIiBkPVxcXCJNMTMgM2E5IDkgMCAwIDAtOSA5SDFsMy44OSAzLjg5LjA3LjE0TDkgMTJINmMwLTMuODcgMy4xMy03IDctN3M3IDMuMTMgNyA3LTMuMTMgNy03IDdjLTEuOTMgMC0zLjY4LS43OS00Ljk0LTIuMDZsLTEuNDIgMS40MkE4Ljk1NCA4Ljk1NCAwIDAgMCAxMyAyMWE5IDkgMCAwIDAgMC0xOFptLTEgNXY1bDQuMjUgMi41Mi43Ny0xLjI4LTMuNTItMi4wOVY4SDEyWlxcXCIgLz5cXG48L3N2Zz5cXG5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8c3R5bGUgdHlwZT1cXFwidGV4dC9jc3NcXFwiPlxcblxcdFxcdC5zMnItbWVudS1mZyB7XFxuXFx0XFx0XFx0ZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcblxcdFxcdH1cXG5cXHQ8L3N0eWxlPlxcblxcdDxwYXRoIGNsYXNzPVxcXCJzMnItbWVudS1mZ1xcXCIgZD1cXFwiTTQgMTloMTZjLjU1IDAgMS0uNDUgMS0xcy0uNDUtMS0xLTFINGMtLjU1IDAtMSAuNDUtMSAxcy40NSAxIDEgMVptMC02aDE2Yy41NSAwIDEtLjQ1IDEtMXMtLjQ1LTEtMS0xSDRjLS41NSAwLTEgLjQ1LTEgMXMuNDUgMSAxIDFaTTMgNmMwIC41NS40NSAxIDEgMWgxNmMuNTUgMCAxLS40NSAxLTFzLS40NS0xLTEtMUg0Yy0uNTUgMC0xIC40NS0xIDFaXFxcIiAvPlxcbjwvc3ZnPlxcblwiIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgSF9USFJFQURTLCBUaHJlYWRJZCB9IGZyb20gJyMjL2RlZic7XG5cdGltcG9ydCB7XG5cdFx0eXdfcGF0dGVybixcblx0XHR5d19uYXZfY29sbGFwc2VkLFxuXHRcdC8vIHl3X3RocmVhZF9pZCxcblx0XHR5d19uYXZfdmlzaWJsZSxcblx0XHR5d19tZW51X2V4cGFuZGVkLFxuXHRcdHl3X2JsdXIsXG5cdFx0eXdfb3ZlcmxheV9uZXR3b3JrLFxuXHRcdHl3X292ZXJsYXlfYWNjb3VudCxcblx0XHR5d19ub3RpZmljYXRpb25zLFxuXHRcdHl3X25hdmlnYXRvcixcblx0XHR5d19wYWdlLFxuXHRcdHl3X3RocmVhZCxcblx0fSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCB7IG9kZSwgb2RlcmFjLCBvZGVyb20gfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IFNYX0lDT05fRVhQQU5EIGZyb20gJyMvaWNvbi9leHBhbmQuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX1RPS0VOUyBmcm9tICcjL2ljb24vdG9rZW5zLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9DT05UQUNUUyBmcm9tICcjL2ljb24vYWNjb3VudF9ib3guc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0hJU1RPUlkgZnJvbSAnIy9pY29uL2hpc3Rvcnkuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX05GVCBmcm9tICcjL2ljb24vbmZ0cy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fTUVOVSBmcm9tICcjL2ljb24vbWVudS5zdmc/cmF3Jztcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgUGFnZSB9IGZyb20gJyMvYXBwL25hdi9wYWdlJztcblx0aW1wb3J0IEhvbGRpbmdzSG9tZSBmcm9tICcjL2FwcC9zY3JlZW4vSG9sZGluZ3NIb21lLnN2ZWx0ZSc7XG5cdGltcG9ydCB0eXBlIHsgUGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yIH0gZnJvbSAnIy9tZXRhL3N2ZWx0ZSc7XG5cblx0Ly8gbmF2IGJhciBkZWZpbml0aW9uXG5cdGNvbnN0IEhfQlVUVE9OUyA9IHtcblx0XHRbVGhyZWFkSWQuVE9LRU5TXToge1xuXHRcdFx0c3ZnOiBTWF9JQ09OX1RPS0VOUyxcblx0XHRcdGxhYmVsOiAnVG9rZW5zJyxcblx0XHR9LFxuXHRcdFtUaHJlYWRJZC5DT05UQUNUU106IHtcblx0XHRcdHN2ZzogU1hfSUNPTl9DT05UQUNUUyxcblx0XHRcdGxhYmVsOiAnQ29udGFjdHMnLFxuXHRcdFx0ZGlzYWJsZWQ6IHRydWUsXG5cdFx0fSxcblx0XHQvLyBbVGhyZWFkSWQuTkZUU106IHtcblx0XHQvLyBcdHN2ZzogU1hfSUNPTl9ORlQsXG5cdFx0Ly8gXHRsYWJlbDogJ05GVHMnLFxuXHRcdC8vIH0sXG5cdFx0W1RocmVhZElkLkhJU1RPUlldOiB7XG5cdFx0XHRzdmc6IFNYX0lDT05fSElTVE9SWSxcblx0XHRcdGxhYmVsOiAnSGlzdG9yeScsXG5cdFx0XHQvLyBkaXNhYmxlZDogdHJ1ZSxcblx0XHR9LFxuXHRcdG1lbnU6IHtcblx0XHRcdHN2ZzogU1hfSUNPTl9NRU5VLFxuXHRcdFx0bGFiZWw6ICdNZW51Jyxcblx0XHR9LFxuXHR9IGFzIFJlY29yZDxzdHJpbmcsIHtcblx0XHRzdmc6IHN0cmluZztcblx0XHRsYWJlbDogc3RyaW5nO1xuXHR9PjtcblxuXHRjb25zdCBITV9IT01FU0NSRUVOUyA9IG5ldyBNYXA8UGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yLCBUaHJlYWRJZD4oXG5cdFx0b2RlcmFjKEhfVEhSRUFEUywgKHNpX3RocmVhZCwgZGNfY3JlYXRvcikgPT4gW2RjX2NyZWF0b3IsIHNpX3RocmVhZCBhcyBUaHJlYWRJZF0pKTtcblxuXHRsZXQgc2lfdGhyZWFkX2hlYWQ6ICcnIHwgVGhyZWFkSWQgPSAnJztcblx0JDogc2lfdGhyZWFkX2hlYWQgPSAkeXdfcGFnZT8gSE1fSE9NRVNDUkVFTlMuZ2V0KCR5d19wYWdlLmNyZWF0b3IpIHx8ICcnOiAnJztcblxuXHRcblx0ZnVuY3Rpb24gdG9nZ2xlX2NvbGxhcHNlZCgpIHtcblx0XHQkeXdfbmF2X2NvbGxhcHNlZCA9ICEkeXdfbmF2X2NvbGxhcHNlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIG5hdl9jbGljayhzaV9idXR0b246IHN0cmluZykge1xuXHRcdC8vIHJlbW92ZSBub3RpZmljYXRpb25cblx0XHQkeXdfbm90aWZpY2F0aW9ucyA9ICR5d19ub3RpZmljYXRpb25zLmZpbHRlcihzaSA9PiBzaV9idXR0b24gIT09IHNpKTtcblxuXHRcdC8vIGJsdXIgaXMgYWN0aXZlXG5cdFx0aWYoJHl3X2JsdXIpIHtcblx0XHRcdC8vIGNhbmNlbCBibHVyXG5cdFx0XHQkeXdfYmx1ciA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIG5ldHdvcmsgb3ZlcmxheSBpcyBhY3RpdmVcblx0XHRpZigkeXdfb3ZlcmxheV9uZXR3b3JrKSB7XG5cdFx0XHQkeXdfb3ZlcmxheV9uZXR3b3JrID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gYWNjb3VudCBvdmVybGF5IGlzIGFjdGl2ZVxuXHRcdGlmKCR5d19vdmVybGF5X2FjY291bnQpIHtcblx0XHRcdCR5d19vdmVybGF5X2FjY291bnQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBkZXBlbmRpbmcgb24gYnV0dG9uIGNsaWNrXG5cdFx0c3dpdGNoKHNpX2J1dHRvbikge1xuXHRcdFx0Ly8gbWVudVxuXHRcdFx0Y2FzZSAnbWVudSc6IHtcblx0XHRcdFx0Ly8gZXhwYW5kIG1lbnVcblx0XHRcdFx0JHl3X21lbnVfZXhwYW5kZWQgPSB0cnVlO1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjdXJyZW50IHRocmVhZCBoZWFkIGxvYWRlZFxuXHRcdFx0Y2FzZSBzaV90aHJlYWRfaGVhZDoge1xuXHRcdFx0XHQvLyBzY3JvbGwgdG8gdG9wIHNtb290aGx5XG5cdFx0XHRcdCR5d19uYXZpZ2F0b3IuYWN0aXZlUGFnZS5kb20uc2Nyb2xsVG8oe1xuXHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdGJlaGF2aW9yOiAnc21vb3RoJyxcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHdpdGhpbiB0aGlzIHRocmVhZFxuXHRcdFx0Y2FzZSAkeXdfdGhyZWFkLmlkOiB7XG5cdFx0XHRcdC8vIHByZXZpb3VzOyBwb3Bcblx0XHRcdFx0Y29uc3Qga19wcmV2aW91cyA9ICR5d19wYWdlLnBlYWsoKTtcblx0XHRcdFx0aWYoa19wcmV2aW91cyAmJiBITV9IT01FU0NSRUVOUy5nZXQoa19wcmV2aW91cy5jcmVhdG9yKSA9PT0gJHl3X3RocmVhZC5pZCkge1xuXHRcdFx0XHRcdCR5d19wYWdlLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGN1cnJlbnQgdGhyZWFkIHdvbid0IGNhdXNlIHVwZGF0ZVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQkeXdfcGFnZS5yZXNldCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHN3aXRjaCB0aHJlYWRcblx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0Ly8gJHl3X3RocmVhZF9pZCA9IHNpX2J1dHRvbiBhcyBUaHJlYWRJZDtcblx0XHRcdFx0dm9pZCAkeXdfbmF2aWdhdG9yLmFjdGl2YXRlVGhyZWFkKHNpX2J1dHRvbiBhcyBUaHJlYWRJZCk7XG5cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQvLyBjb25zdCBITV9IT01FU0NSRUVOUyA9IG5ldyBNYXA8UGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yLCBUaHJlYWRJZD4oW1xuXHQvLyBcdFtIb2xkaW5ncywgVGhyZWFkSWQuVE9LRU5TXSxcblx0Ly8gXHRbQ29udGFjdExpc3QsIFRocmVhZElkLkNPTlRBQ1RTXSxcblx0Ly8gXSk7XG5cblx0Ly8gY29uc3QgSF9IT01FUzogUmVjb3JkPHN0cmluZywgVGhyZWFkSWQ+ID0ge1xuXHQvLyBcdCcvZmFtaWxpZXMve2ZhbWlseUlkfS9jaGFpbnMve2NoYWluSWR9L2hvbGRpbmdzL3thY2NvdW50SWR9JzogVGhyZWFkSWQuVE9LRU5TLFxuXHQvLyBcdCcvZmFtaWxpZXMve2ZhbWlseUlkfS9jaGFpbnMve2NoYWluSWR9L2dhbGxlcnkve2FjY291bnRJZH0nOiBUaHJlYWRJZC5ORlRTLFxuXHQvLyBcdCcvY29udGFjdHMnOiBUaHJlYWRJZC5DT05UQUNUUyxcblx0Ly8gXHQvLyAnL25ldHdvcmtzJzogVGhyZWFkSWQuTkVUV09SS1MsXG5cdC8vIFx0Jy9hY2NvdW50cyc6IFRocmVhZElkLkFDQ09VTlRTLFxuXHQvLyBcdCcvaGlzdG9yeSc6IFRocmVhZElkLkhJU1RPUlksXG5cdC8vIH07XG5cblx0Ly8gbGV0IHNpX3RocmVhZF9oZWFkOiAnJyB8IFRocmVhZElkID0gJyc7XG5cdC8vICQ6IHtcblx0Ly8gXHQkeXdfcGFnZVxuXHQvLyBcdCR5d190aHJlYWRcblx0Ly8gXHQvLyBjb25zdCBzeF9wYXR0ZXJuID0gJHl3X3BhdHRlcm47XG5cblx0Ly8gXHRzaV90aHJlYWRfaGVhZCA9IEhfSE9NRVNbc3hfcGF0dGVybl0gfHwgJyc7XG5cdC8vIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImxlc3NcIj5cblx0QGltcG9ydCAnLi4vLi4vLi4vc3R5bGUvdXRpbC5sZXNzJztcblxuXHRuYXYge1xuXHRcdC0tbmF2LWhlaWdodDogNzJweDtcblxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRib3R0b206IDA7XG5cdFx0aGVpZ2h0OiB2YXIoLS1uYXYtaGVpZ2h0KTtcblx0XHR3aWR0aDogMTAwJTtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0ei1pbmRleDogMTAwMDtcblxuXHRcdHRyYW5zaXRpb246IGJvdHRvbSAxcyB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cblx0XHRkaXNwbGF5OiBub25lO1xuXHRcdCYudmlzaWJsZSB7XG5cdFx0XHRkaXNwbGF5OiBpbml0aWFsO1xuXHRcdH1cblxuXHRcdCYuY29sbGFwc2VkIHtcblx0XHRcdGJvdHRvbTogY2FsYygwcHggLSB2YXIoLS1uYXYtaGVpZ2h0KSk7XG5cblx0XHRcdD4uY29sbGFwc2UuaWNvbj5zdmcge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHR0cmFuc2Zvcm06IHJvdGF0ZSgtMTgwZGVnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdD4uY29sbGFwc2UuaWNvbiB7XG5cdFx0XHQtLWJ1dHRvbi1kaWFtZXRlcjogMzJweDtcblx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblxuXHRcdFx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHRyaWdodDogMDtcblx0XHRcdHRvcDogY2FsYygwcHggLSB2YXIoLS1idXR0b24tZGlhbWV0ZXIpKTtcblxuXHRcdFx0Ym9yZGVyLXJhZGl1czogMDtcblx0XHRcdGJvcmRlci1ib3R0b20td2lkdGg6IDA7XG5cdFx0XHRib3JkZXItY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXG5cdFx0XHQ+c3ZnIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDFzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0fVxuXG5cdFx0Pi5iYXIge1xuXHRcdFx0bGlzdC1zdHlsZTogbm9uZTtcblx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRtYXJnaW46IDA7XG5cblx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cblx0XHRcdGJvcmRlci10b3A6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXG5cdFx0XHQ+LmJ1dHRvbiB7XG5cdFx0XHRcdGZsZXg6IDE7XG5cdFx0XHRcdHBhZGRpbmctdG9wOiAxMXB4O1xuXHRcdFx0XHRwYWRkaW5nLWJvdHRvbTogMTJweDtcblxuXHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LWxpZ2h0KTtcblxuXHRcdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cblx0XHRcdFx0Ji5hY3RpdmUge1xuXHRcdFx0XHRcdCYudG9rZW5zIHtcblx0XHRcdFx0XHRcdC0tc3ZnLWNvbG9yLWZnOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ji5jb250YWN0cyB7XG5cdFx0XHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCYubmZ0cyB7XG5cdFx0XHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCYuaGlzdG9yeSB7XG5cdFx0XHRcdFx0XHQtLXN2Zy1jb2xvci1mZzogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Pi5sYWJlbCB7XG5cdFx0XHRcdFx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1saWdodCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5pY29uIHtcblx0XHRcdFx0XHQuaW5oZXJpdCgtLWljb24tZGlhbWV0ZXIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Lm5vdGlmaWNhdGlvbiB7XG5cdFx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHRcdHdpZHRoOiA3cHg7XG5cdFx0XHRcdFx0aGVpZ2h0OiA3cHg7XG5cdFx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3Itc2t5KTtcblx0XHRcdFx0XHRib3JkZXItcmFkaXVzOiA3cHg7XG5cdFx0XHRcdFx0bWFyZ2luLXRvcDogMTVweDtcblx0XHRcdFx0XHRib3JkZXI6IDJweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRcdFx0bWFyZ2luLWxlZnQ6IC05cHg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+LmxhYmVsIHtcblx0XHRcdFx0XHRmb250LXNpemU6IDExcHg7XG5cdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPG5hdiBjbGFzczpjb2xsYXBzZWQ9eyR5d19uYXZfY29sbGFwc2VkfSBjbGFzczp2aXNpYmxlPXskeXdfbmF2X3Zpc2libGV9PlxuXHQ8ZGl2IGNsYXNzPVwiY29sbGFwc2UgaWNvblwiIG9uOmNsaWNrPXsoKSA9PiB0b2dnbGVfY29sbGFwc2VkKCl9PlxuXHRcdHtAaHRtbCBTWF9JQ09OX0VYUEFORH1cblx0PC9kaXY+XG5cdDx1bCBjbGFzcz1cImJhclwiPlxuXHRcdHsjZWFjaCBvZGUoSF9CVVRUT05TKSBhcyBbc2lfYnV0dG9uLCBnX2J1dHRvbl19XG5cdFx0XHR7I2lmIGdfYnV0dG9uLmRpc2FibGVkfVxuXHRcdFx0XHQ8bGkgY2xhc3M9XCJidXR0b24ge3NpX2J1dHRvbn1cIiBjbGFzczphY3RpdmU9e3NpX3RocmVhZF9oZWFkID09PSBzaV9idXR0b259IHN0eWxlPVwib3BhY2l0eTogMC41O1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHR7QGh0bWwgZ19idXR0b24uc3ZnfVxuXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm5vdGlmaWNhdGlvblwiIGNsYXNzOmRpc3BsYXlfbm9uZT17ISR5d19ub3RpZmljYXRpb25zLmluY2x1ZGVzKHNpX2J1dHRvbil9Pjwvc3Bhbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibGFiZWxcIj5cblx0XHRcdFx0XHRcdHtnX2J1dHRvbi5sYWJlbH1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9saT5cblx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0PGxpIGNsYXNzPVwiYnV0dG9uIHtzaV9idXR0b259XCIgY2xhc3M6YWN0aXZlPXtzaV90aHJlYWRfaGVhZCA9PT0gc2lfYnV0dG9ufSBvbjpjbGljaz17KCkgPT4gbmF2X2NsaWNrKHNpX2J1dHRvbil9PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJpY29uXCI+XG5cdFx0XHRcdFx0XHR7QGh0bWwgZ19idXR0b24uc3ZnfVxuXG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cIm5vdGlmaWNhdGlvblwiIGNsYXNzOmRpc3BsYXlfbm9uZT17ISR5d19ub3RpZmljYXRpb25zLmluY2x1ZGVzKHNpX2J1dHRvbil9Pjwvc3Bhbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibGFiZWxcIj5cblx0XHRcdFx0XHRcdHtnX2J1dHRvbi5sYWJlbH1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9saT5cblx0XHRcdHsvaWZ9XG5cdFx0ey9lYWNofVxuXHRcdDwvdWw+XG48L25hdj5cbiIsIi8qKlxuICogRnVzZS5qcyB2Ni42LjIgLSBMaWdodHdlaWdodCBmdXp6eS1zZWFyY2ggKGh0dHA6Ly9mdXNlanMuaW8pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIyIEtpcm8gUmlzayAoaHR0cDovL2tpcm8ubWUpXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiBBcGFjaGUgU29mdHdhcmUgTGljZW5zZSAyLjBcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheVxuICAgID8gZ2V0VGFnKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWx1ZSlcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzXG5jb25zdCBJTkZJTklUWSA9IDEgLyAwO1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBsZXQgcmVzdWx0ID0gdmFsdWUgKyAnJztcbiAgcmV0dXJuIHJlc3VsdCA9PSAnMCcgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/ICctMCcgOiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9pc0Jvb2xlYW4uanNcbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlID09PSB0cnVlIHx8XG4gICAgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSAnW29iamVjdCBCb29sZWFuXScpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuLy8gQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNCbGFuayh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlLnRyaW0oKS5sZW5ndGhcbn1cblxuLy8gR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvZ2V0VGFnLmpzXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJ1tvYmplY3QgVW5kZWZpbmVkXSdcbiAgICAgIDogJ1tvYmplY3QgTnVsbF0nXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbmNvbnN0IEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSA9ICdFeHRlbmRlZCBzZWFyY2ggaXMgbm90IGF2YWlsYWJsZSc7XG5cbmNvbnN0IElOQ09SUkVDVF9JTkRFWF9UWVBFID0gXCJJbmNvcnJlY3QgJ2luZGV4JyB0eXBlXCI7XG5cbmNvbnN0IExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWSA9IChrZXkpID0+XG4gIGBJbnZhbGlkIHZhbHVlIGZvciBrZXkgJHtrZXl9YDtcblxuY29uc3QgUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFID0gKG1heCkgPT5cbiAgYFBhdHRlcm4gbGVuZ3RoIGV4Y2VlZHMgbWF4IG9mICR7bWF4fS5gO1xuXG5jb25zdCBNSVNTSU5HX0tFWV9QUk9QRVJUWSA9IChuYW1lKSA9PiBgTWlzc2luZyAke25hbWV9IHByb3BlcnR5IGluIGtleWA7XG5cbmNvbnN0IElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRSA9IChrZXkpID0+XG4gIGBQcm9wZXJ0eSAnd2VpZ2h0JyBpbiBrZXkgJyR7a2V5fScgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgO1xuXG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5jbGFzcyBLZXlTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fa2V5TWFwID0ge307XG5cbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxldCBvYmogPSBjcmVhdGVLZXkoa2V5KTtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcblxuICAgICAgdGhpcy5fa2V5cy5wdXNoKG9iaik7XG4gICAgICB0aGlzLl9rZXlNYXBbb2JqLmlkXSA9IG9iajtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIE5vcm1hbGl6ZSB3ZWlnaHRzIHNvIHRoYXQgdGhlaXIgc3VtIGlzIGVxdWFsIHRvIDFcbiAgICB0aGlzLl9rZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAga2V5LndlaWdodCAvPSB0b3RhbFdlaWdodDtcbiAgICB9KTtcbiAgfVxuICBnZXQoa2V5SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5TWFwW2tleUlkXVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2tleXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICBsZXQgcGF0aCA9IG51bGw7XG4gIGxldCBpZCA9IG51bGw7XG4gIGxldCBzcmMgPSBudWxsO1xuICBsZXQgd2VpZ2h0ID0gMTtcbiAgbGV0IGdldEZuID0gbnVsbDtcblxuICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBpc0FycmF5KGtleSkpIHtcbiAgICBzcmMgPSBrZXk7XG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgoa2V5KTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChrZXksICduYW1lJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX0tFWV9QUk9QRVJUWSgnbmFtZScpKVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBrZXkubmFtZTtcbiAgICBzcmMgPSBuYW1lO1xuXG4gICAgaWYgKGhhc093bi5jYWxsKGtleSwgJ3dlaWdodCcpKSB7XG4gICAgICB3ZWlnaHQgPSBrZXkud2VpZ2h0O1xuXG4gICAgICBpZiAod2VpZ2h0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRShuYW1lKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoID0gY3JlYXRlS2V5UGF0aChuYW1lKTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKG5hbWUpO1xuICAgIGdldEZuID0ga2V5LmdldEZuO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aCwgaWQsIHdlaWdodCwgc3JjLCBnZXRGbiB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVBhdGgoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkgOiBrZXkuc3BsaXQoJy4nKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlJZChrZXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkoa2V5KSA/IGtleS5qb2luKCcuJykgOiBrZXlcbn1cblxuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICBsZXQgbGlzdCA9IFtdO1xuICBsZXQgYXJyID0gZmFsc2U7XG5cbiAgY29uc3QgZGVlcEdldCA9IChvYmosIHBhdGgsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQob2JqKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcGF0aFtpbmRleF0pIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGF0aCBsZWZ0LCB3ZSd2ZSBhcnJpdmVkIGF0IHRoZSBvYmplY3Qgd2UgY2FyZSBhYm91dC5cbiAgICAgIGxpc3QucHVzaChvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQga2V5ID0gcGF0aFtpbmRleF07XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGxhc3QgdmFsdWUgaW4gdGhlIHBhdGgsIGFuZCBpZiBpdCdzIGEgc3RyaW5nL251bWJlci9ib29sLFxuICAgICAgLy8gYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgICBpZiAoXG4gICAgICAgIGluZGV4ID09PSBwYXRoLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc051bWJlcih2YWx1ZSkgfHwgaXNCb29sZWFuKHZhbHVlKSlcbiAgICAgICkge1xuICAgICAgICBsaXN0LnB1c2godG9TdHJpbmcodmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYXJyID0gdHJ1ZTtcbiAgICAgICAgLy8gU2VhcmNoIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGRlZXBHZXQodmFsdWVbaV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gQW4gb2JqZWN0LiBSZWN1cnNlIGZ1cnRoZXIuXG4gICAgICAgIGRlZXBHZXQodmFsdWUsIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChzaW5jZSBwYXRoIHVzZWQgdG8gYmUgYSBzdHJpbmcpXG4gIGRlZXBHZXQob2JqLCBpc1N0cmluZyhwYXRoKSA/IHBhdGguc3BsaXQoJy4nKSA6IHBhdGgsIDApO1xuXG4gIHJldHVybiBhcnIgPyBsaXN0IDogbGlzdFswXVxufVxuXG5jb25zdCBNYXRjaE9wdGlvbnMgPSB7XG4gIC8vIFdoZXRoZXIgdGhlIG1hdGNoZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgc2V0LiBXaGVuIGB0cnVlYCwgZWFjaCByZWNvcmQgaW4gdGhlIHJlc3VsdFxuICAvLyBzZXQgd2lsbCBpbmNsdWRlIHRoZSBpbmRpY2VzIG9mIHRoZSBtYXRjaGVkIGNoYXJhY3RlcnMuXG4gIC8vIFRoZXNlIGNhbiBjb25zZXF1ZW50bHkgYmUgdXNlZCBmb3IgaGlnaGxpZ2h0aW5nIHB1cnBvc2VzLlxuICBpbmNsdWRlTWF0Y2hlczogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICAvLyBhIHBlcmZlY3QgbWF0Y2ggaGFzIGFscmVhZHkgYmVlbiBsb2NhdGVkIGluIHRoZSBzdHJpbmcuXG4gIGZpbmRBbGxNYXRjaGVzOiBmYWxzZSxcbiAgLy8gTWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgbWF0Y2hlZCBiZWZvcmUgYSByZXN1bHQgaXMgY29uc2lkZXJlZCBhIG1hdGNoXG4gIG1pbk1hdGNoQ2hhckxlbmd0aDogMVxufTtcblxuY29uc3QgQmFzaWNPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGFsZ29yaXRobSBjb250aW51ZXMgc2VhcmNoaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IGV2ZW4gaWYgYSBwZXJmZWN0XG4gIC8vIG1hdGNoIGlzIGZvdW5kIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBzYW1lIGlucHV0LlxuICBpc0Nhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAvLyBXaGVuIHRydWUsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIHRvIHRoZSBlbmQgb2YgYSBzZWFyY2ggcGF0dGVybiBldmVuIGlmXG4gIGluY2x1ZGVTY29yZTogZmFsc2UsXG4gIC8vIExpc3Qgb2YgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQuIFRoaXMgYWxzbyBzdXBwb3J0cyBuZXN0ZWQgcHJvcGVydGllcy5cbiAga2V5czogW10sXG4gIC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgcmVzdWx0IGxpc3QsIGJ5IHNjb3JlXG4gIHNob3VsZFNvcnQ6IHRydWUsXG4gIC8vIERlZmF1bHQgc29ydCBmdW5jdGlvbjogc29ydCBieSBhc2NlbmRpbmcgc2NvcmUsIGFzY2VuZGluZyBpbmRleFxuICBzb3J0Rm46IChhLCBiKSA9PlxuICAgIGEuc2NvcmUgPT09IGIuc2NvcmUgPyAoYS5pZHggPCBiLmlkeCA/IC0xIDogMSkgOiBhLnNjb3JlIDwgYi5zY29yZSA/IC0xIDogMVxufTtcblxuY29uc3QgRnV6enlPcHRpb25zID0ge1xuICAvLyBBcHByb3hpbWF0ZWx5IHdoZXJlIGluIHRoZSB0ZXh0IGlzIHRoZSBwYXR0ZXJuIGV4cGVjdGVkIHRvIGJlIGZvdW5kP1xuICBsb2NhdGlvbjogMCxcbiAgLy8gQXQgd2hhdCBwb2ludCBkb2VzIHRoZSBtYXRjaCBhbGdvcml0aG0gZ2l2ZSB1cC4gQSB0aHJlc2hvbGQgb2YgJzAuMCcgcmVxdWlyZXMgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIChvZiBib3RoIGxldHRlcnMgYW5kIGxvY2F0aW9uKSwgYSB0aHJlc2hvbGQgb2YgJzEuMCcgd291bGQgbWF0Y2ggYW55dGhpbmcuXG4gIHRocmVzaG9sZDogMC42LFxuICAvLyBEZXRlcm1pbmVzIGhvdyBjbG9zZSB0aGUgbWF0Y2ggbXVzdCBiZSB0byB0aGUgZnV6enkgbG9jYXRpb24gKHNwZWNpZmllZCBhYm92ZSkuXG4gIC8vIEFuIGV4YWN0IGxldHRlciBtYXRjaCB3aGljaCBpcyAnZGlzdGFuY2UnIGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBmdXp6eSBsb2NhdGlvblxuICAvLyB3b3VsZCBzY29yZSBhcyBhIGNvbXBsZXRlIG1pc21hdGNoLiBBIGRpc3RhbmNlIG9mICcwJyByZXF1aXJlcyB0aGUgbWF0Y2ggYmUgYXRcbiAgLy8gdGhlIGV4YWN0IGxvY2F0aW9uIHNwZWNpZmllZCwgYSB0aHJlc2hvbGQgb2YgJzEwMDAnIHdvdWxkIHJlcXVpcmUgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIHRvIGJlIHdpdGhpbiA4MDAgY2hhcmFjdGVycyBvZiB0aGUgZnV6enkgbG9jYXRpb24gdG8gYmUgZm91bmQgdXNpbmcgYSAwLjggdGhyZXNob2xkLlxuICBkaXN0YW5jZTogMTAwXG59O1xuXG5jb25zdCBBZHZhbmNlZE9wdGlvbnMgPSB7XG4gIC8vIFdoZW4gYHRydWVgLCBpdCBlbmFibGVzIHRoZSB1c2Ugb2YgdW5peC1saWtlIHNlYXJjaCBjb21tYW5kc1xuICB1c2VFeHRlbmRlZFNlYXJjaDogZmFsc2UsXG4gIC8vIFRoZSBnZXQgZnVuY3Rpb24gdG8gdXNlIHdoZW4gZmV0Y2hpbmcgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gVGhlIGRlZmF1bHQgd2lsbCBzZWFyY2ggbmVzdGVkIHBhdGhzICppZSBmb28uYmFyLmJheipcbiAgZ2V0Rm46IGdldCxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHNlYXJjaCB3aWxsIGlnbm9yZSBgbG9jYXRpb25gIGFuZCBgZGlzdGFuY2VgLCBzbyBpdCB3b24ndCBtYXR0ZXJcbiAgLy8gd2hlcmUgaW4gdGhlIHN0cmluZyB0aGUgcGF0dGVybiBhcHBlYXJzLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZnV6emluZXNzLXNjb3JlXG4gIGlnbm9yZUxvY2F0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBjYWxjdWxhdGlvbiBmb3IgdGhlIHJlbGV2YW5jZSBzY29yZSAodXNlZCBmb3Igc29ydGluZykgd2lsbFxuICAvLyBpZ25vcmUgdGhlIGZpZWxkLWxlbmd0aCBub3JtLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZmllbGQtbGVuZ3RoLW5vcm1cbiAgaWdub3JlRmllbGROb3JtOiBmYWxzZSxcbiAgLy8gVGhlIHdlaWdodCB0byBkZXRlcm1pbmUgaG93IG11Y2ggZmllbGQgbGVuZ3RoIG5vcm0gZWZmZWN0cyBzY29yaW5nLlxuICBmaWVsZE5vcm1XZWlnaHQ6IDFcbn07XG5cbnZhciBDb25maWcgPSB7XG4gIC4uLkJhc2ljT3B0aW9ucyxcbiAgLi4uTWF0Y2hPcHRpb25zLFxuICAuLi5GdXp6eU9wdGlvbnMsXG4gIC4uLkFkdmFuY2VkT3B0aW9uc1xufTtcblxuY29uc3QgU1BBQ0UgPSAvW14gXSsvZztcblxuLy8gRmllbGQtbGVuZ3RoIG5vcm06IHRoZSBzaG9ydGVyIHRoZSBmaWVsZCwgdGhlIGhpZ2hlciB0aGUgd2VpZ2h0LlxuLy8gU2V0IHRvIDMgZGVjaW1hbHMgdG8gcmVkdWNlIGluZGV4IHNpemUuXG5mdW5jdGlvbiBub3JtKHdlaWdodCA9IDEsIG1hbnRpc3NhID0gMykge1xuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbSA9IE1hdGgucG93KDEwLCBtYW50aXNzYSk7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQodmFsdWUpIHtcbiAgICAgIGNvbnN0IG51bVRva2VucyA9IHZhbHVlLm1hdGNoKFNQQUNFKS5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMobnVtVG9rZW5zKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG51bVRva2VucylcbiAgICAgIH1cblxuICAgICAgLy8gRGVmYXVsdCBmdW5jdGlvbiBpcyAxL3NxcnQoeCksIHdlaWdodCBtYWtlcyB0aGF0IHZhcmlhYmxlXG4gICAgICBjb25zdCBub3JtID0gMSAvIE1hdGgucG93KG51bVRva2VucywgMC41ICogd2VpZ2h0KTtcblxuICAgICAgLy8gSW4gcGxhY2Ugb2YgYHRvRml4ZWQobWFudGlzc2EpYCwgZm9yIGZhc3RlciBjb21wdXRhdGlvblxuICAgICAgY29uc3QgbiA9IHBhcnNlRmxvYXQoTWF0aC5yb3VuZChub3JtICogbSkgLyBtKTtcblxuICAgICAgY2FjaGUuc2V0KG51bVRva2Vucywgbik7XG5cbiAgICAgIHJldHVybiBuXG4gICAgfSxcbiAgICBjbGVhcigpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1c2VJbmRleCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZXRGbiA9IENvbmZpZy5nZXRGbixcbiAgICBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHRoaXMubm9ybSA9IG5vcm0oZmllbGROb3JtV2VpZ2h0LCAzKTtcbiAgICB0aGlzLmdldEZuID0gZ2V0Rm47XG4gICAgdGhpcy5pc0NyZWF0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0SW5kZXhSZWNvcmRzKCk7XG4gIH1cbiAgc2V0U291cmNlcyhkb2NzID0gW10pIHtcbiAgICB0aGlzLmRvY3MgPSBkb2NzO1xuICB9XG4gIHNldEluZGV4UmVjb3JkcyhyZWNvcmRzID0gW10pIHtcbiAgICB0aGlzLnJlY29yZHMgPSByZWNvcmRzO1xuICB9XG4gIHNldEtleXMoa2V5cyA9IFtdKSB7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLl9rZXlzTWFwID0ge307XG4gICAga2V5cy5mb3JFYWNoKChrZXksIGlkeCkgPT4ge1xuICAgICAgdGhpcy5fa2V5c01hcFtrZXkuaWRdID0gaWR4O1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZSgpIHtcbiAgICBpZiAodGhpcy5pc0NyZWF0ZWQgfHwgIXRoaXMuZG9jcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuaXNDcmVhdGVkID0gdHJ1ZTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8U3RyaW5nPlxuICAgIGlmIChpc1N0cmluZyh0aGlzLmRvY3NbMF0pKSB7XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdCBpcyBBcnJheTxPYmplY3Q+XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm5vcm0uY2xlYXIoKTtcbiAgfVxuICAvLyBBZGRzIGEgZG9jIHRvIHRoZSBlbmQgb2YgdGhlIGluZGV4XG4gIGFkZChkb2MpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnNpemUoKTtcblxuICAgIGlmIChpc1N0cmluZyhkb2MpKSB7XG4gICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBpZHgpO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmVzIHRoZSBkb2MgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvZiB0aGUgaW5kZXhcbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5yZWNvcmRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgLy8gQ2hhbmdlIHJlZiBpbmRleCBvZiBldmVyeSBzdWJzcXVlbnQgZG9jXG4gICAgZm9yIChsZXQgaSA9IGlkeCwgbGVuID0gdGhpcy5zaXplKCk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5yZWNvcmRzW2ldLmkgLT0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCkge1xuICAgIHJldHVybiBpdGVtW3RoaXMuX2tleXNNYXBba2V5SWRdXVxuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb3Jkcy5sZW5ndGhcbiAgfVxuICBfYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpIHx8IGlzQmxhbmsoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJlY29yZCA9IHtcbiAgICAgIHY6IGRvYyxcbiAgICAgIGk6IGRvY0luZGV4LFxuICAgICAgbjogdGhpcy5ub3JtLmdldChkb2MpXG4gICAgfTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgX2FkZE9iamVjdChkb2MsIGRvY0luZGV4KSB7XG4gICAgbGV0IHJlY29yZCA9IHsgaTogZG9jSW5kZXgsICQ6IHt9IH07XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgdGhpcy5rZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGtleS5nZXRGbiA/IGtleS5nZXRGbihkb2MpIDogdGhpcy5nZXRGbihkb2MsIGtleS5wYXRoKTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbeyBuZXN0ZWRBcnJJbmRleDogLTEsIHZhbHVlIH1dO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB7IG5lc3RlZEFyckluZGV4LCB2YWx1ZSB9ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAgICAgICBpOiBuZXN0ZWRBcnJJbmRleCxcbiAgICAgICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN1YlJlY29yZHMucHVzaChzdWJSZWNvcmQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGspID0+IHtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgbmVzdGVkQXJySW5kZXg6IGssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZHM7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICByZWNvcmRzOiB0aGlzLnJlY29yZHNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5kZXgoXG4gIGtleXMsXG4gIGRvY3MsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiwgZmllbGROb3JtV2VpZ2h0IH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cy5tYXAoY3JlYXRlS2V5KSk7XG4gIG15SW5kZXguc2V0U291cmNlcyhkb2NzKTtcbiAgbXlJbmRleC5jcmVhdGUoKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gcGFyc2VJbmRleChcbiAgZGF0YSxcbiAgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiwgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodCB9ID0ge31cbikge1xuICBjb25zdCB7IGtleXMsIHJlY29yZHMgfSA9IGRhdGE7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMpO1xuICBteUluZGV4LnNldEluZGV4UmVjb3JkcyhyZWNvcmRzKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlJDEoXG4gIHBhdHRlcm4sXG4gIHtcbiAgICBlcnJvcnMgPSAwLFxuICAgIGN1cnJlbnRMb2NhdGlvbiA9IDAsXG4gICAgZXhwZWN0ZWRMb2NhdGlvbiA9IDAsXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgYWNjdXJhY3kgPSBlcnJvcnMgLyBwYXR0ZXJuLmxlbmd0aDtcblxuICBpZiAoaWdub3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm4gYWNjdXJhY3lcbiAgfVxuXG4gIGNvbnN0IHByb3hpbWl0eSA9IE1hdGguYWJzKGV4cGVjdGVkTG9jYXRpb24gLSBjdXJyZW50TG9jYXRpb24pO1xuXG4gIGlmICghZGlzdGFuY2UpIHtcbiAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3lcbiAgfVxuXG4gIHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIGRpc3RhbmNlXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRNYXNrVG9JbmRpY2VzKFxuICBtYXRjaG1hc2sgPSBbXSxcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aFxuKSB7XG4gIGxldCBpbmRpY2VzID0gW107XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGxldCBsZW4gPSBtYXRjaG1hc2subGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaG1hc2tbaV07XG4gICAgaWYgKG1hdGNoICYmIHN0YXJ0ID09PSAtMSkge1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgZW5kID0gaSAtIDE7XG4gICAgICBpZiAoZW5kIC0gc3RhcnQgKyAxID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgICAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBlbmRdKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLy8gKGktMSAtIHN0YXJ0KSArIDEgPT4gaSAtIHN0YXJ0XG4gIGlmIChtYXRjaG1hc2tbaSAtIDFdICYmIGkgLSBzdGFydCA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBpIC0gMV0pO1xuICB9XG5cbiAgcmV0dXJuIGluZGljZXNcbn1cblxuLy8gTWFjaGluZSB3b3JkIHNpemVcbmNvbnN0IE1BWF9CSVRTID0gMzI7XG5cbmZ1bmN0aW9uIHNlYXJjaChcbiAgdGV4dCxcbiAgcGF0dGVybixcbiAgcGF0dGVybkFscGhhYmV0LFxuICB7XG4gICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRShNQVhfQklUUykpXG4gIH1cblxuICBjb25zdCBwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGg7XG4gIC8vIFNldCBzdGFydGluZyBsb2NhdGlvbiBhdCBiZWdpbm5pbmcgdGV4dCBhbmQgaW5pdGlhbGl6ZSB0aGUgYWxwaGFiZXQuXG4gIGNvbnN0IHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gbG9jYXRpb24gPiB0ZXh0Lmxlbmd0aFxuICBjb25zdCBleHBlY3RlZExvY2F0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jYXRpb24sIHRleHRMZW4pKTtcbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgbGV0IGN1cnJlbnRUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgbGV0IGJlc3RMb2NhdGlvbiA9IGV4cGVjdGVkTG9jYXRpb247XG5cbiAgLy8gUGVyZm9ybWFuY2U6IG9ubHkgY29tcHV0ZXIgbWF0Y2hlcyB3aGVuIHRoZSBtaW5NYXRjaENoYXJMZW5ndGggPiAxXG4gIC8vIE9SIGlmIGBpbmNsdWRlTWF0Y2hlc2AgaXMgdHJ1ZS5cbiAgY29uc3QgY29tcHV0ZU1hdGNoZXMgPSBtaW5NYXRjaENoYXJMZW5ndGggPiAxIHx8IGluY2x1ZGVNYXRjaGVzO1xuICAvLyBBIG1hc2sgb2YgdGhlIG1hdGNoZXMsIHVzZWQgZm9yIGJ1aWxkaW5nIHRoZSBpbmRpY2VzXG4gIGNvbnN0IG1hdGNoTWFzayA9IGNvbXB1dGVNYXRjaGVzID8gQXJyYXkodGV4dExlbikgOiBbXTtcblxuICBsZXQgaW5kZXg7XG5cbiAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzLCBoZXJlIGZvciBzcGVlZCB1cFxuICB3aGlsZSAoKGluZGV4ID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGJlc3RMb2NhdGlvbikpID4gLTEpIHtcbiAgICBsZXQgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBjdXJyZW50TG9jYXRpb246IGluZGV4LFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBNYXRoLm1pbihzY29yZSwgY3VycmVudFRocmVzaG9sZCk7XG4gICAgYmVzdExvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuXG4gICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHBhdHRlcm5MZW4pIHtcbiAgICAgICAgbWF0Y2hNYXNrW2luZGV4ICsgaV0gPSAxO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgdGhlIGJlc3QgbG9jYXRpb25cbiAgYmVzdExvY2F0aW9uID0gLTE7XG5cbiAgbGV0IGxhc3RCaXRBcnIgPSBbXTtcbiAgbGV0IGZpbmFsU2NvcmUgPSAxO1xuICBsZXQgYmluTWF4ID0gcGF0dGVybkxlbiArIHRleHRMZW47XG5cbiAgY29uc3QgbWFzayA9IDEgPDwgKHBhdHRlcm5MZW4gLSAxKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkgKz0gMSkge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSB0aGUgbWF0Y2ggbG9jYXRpb24gd2UgY2FuIHN0cmF5XG4gICAgLy8gYXQgdGhpcyBlcnJvciBsZXZlbC5cbiAgICBsZXQgYmluTWluID0gMDtcbiAgICBsZXQgYmluTWlkID0gYmluTWF4O1xuXG4gICAgd2hpbGUgKGJpbk1pbiA8IGJpbk1pZCkge1xuICAgICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgIGVycm9yczogaSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLFxuICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICBiaW5NaW4gPSBiaW5NaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgICB9XG5cbiAgICAgIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICBiaW5NYXggPSBiaW5NaWQ7XG5cbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCgxLCBleHBlY3RlZExvY2F0aW9uIC0gYmluTWlkICsgMSk7XG4gICAgbGV0IGZpbmlzaCA9IGZpbmRBbGxNYXRjaGVzXG4gICAgICA/IHRleHRMZW5cbiAgICAgIDogTWF0aC5taW4oZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCwgdGV4dExlbikgKyBwYXR0ZXJuTGVuO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgYml0IGFycmF5XG4gICAgbGV0IGJpdEFyciA9IEFycmF5KGZpbmlzaCArIDIpO1xuXG4gICAgYml0QXJyW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xuXG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgaiAtPSAxKSB7XG4gICAgICBsZXQgY3VycmVudExvY2F0aW9uID0gaiAtIDE7XG4gICAgICBsZXQgY2hhck1hdGNoID0gcGF0dGVybkFscGhhYmV0W3RleHQuY2hhckF0KGN1cnJlbnRMb2NhdGlvbildO1xuXG4gICAgICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICAgICAgLy8gU3BlZWQgdXA6IHF1aWNrIGJvb2wgdG8gaW50IGNvbnZlcnNpb24gKGkuZSwgYGNoYXJNYXRjaCA/IDEgOiAwYClcbiAgICAgICAgbWF0Y2hNYXNrW2N1cnJlbnRMb2NhdGlvbl0gPSArISFjaGFyTWF0Y2g7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IHBhc3M6IGV4YWN0IG1hdGNoXG4gICAgICBiaXRBcnJbal0gPSAoKGJpdEFycltqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcblxuICAgICAgLy8gU3Vic2VxdWVudCBwYXNzZXM6IGZ1enp5IG1hdGNoXG4gICAgICBpZiAoaSkge1xuICAgICAgICBiaXRBcnJbal0gfD1cbiAgICAgICAgICAoKGxhc3RCaXRBcnJbaiArIDFdIHwgbGFzdEJpdEFycltqXSkgPDwgMSkgfCAxIHwgbGFzdEJpdEFycltqICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChiaXRBcnJbal0gJiBtYXNrKSB7XG4gICAgICAgIGZpbmFsU2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cbiAgICAgICAgaWYgKGZpbmFsU2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIEluZGVlZCBpdCBpc1xuICAgICAgICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBmaW5hbFNjb3JlO1xuICAgICAgICAgIGJlc3RMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcblxuICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGBsb2NgLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgaWYgKGJlc3RMb2NhdGlvbiA8PSBleHBlY3RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBgYmVzdExvY2F0aW9uYCwgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gYGV4cGVjdGVkTG9jYXRpb25gLlxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGV4cGVjdGVkTG9jYXRpb24gLSBiZXN0TG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgIGVycm9yczogaSArIDEsXG4gICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHNjb3JlID4gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBsYXN0Qml0QXJyID0gYml0QXJyO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlzTWF0Y2g6IGJlc3RMb2NhdGlvbiA+PSAwLFxuICAgIC8vIENvdW50IGV4YWN0IG1hdGNoZXMgKHRob3NlIHdpdGggYSBzY29yZSBvZiAwKSB0byBiZSBcImFsbW9zdFwiIGV4YWN0XG4gICAgc2NvcmU6IE1hdGgubWF4KDAuMDAxLCBmaW5hbFNjb3JlKVxuICB9O1xuXG4gIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgIGNvbnN0IGluZGljZXMgPSBjb252ZXJ0TWFza1RvSW5kaWNlcyhtYXRjaE1hc2ssIG1pbk1hdGNoQ2hhckxlbmd0aCk7XG4gICAgaWYgKCFpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybikge1xuICBsZXQgbWFzayA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IHBhdHRlcm4uY2hhckF0KGkpO1xuICAgIG1hc2tbY2hhcl0gPSAobWFza1tjaGFyXSB8fCAwKSB8ICgxIDw8IChsZW4gLSBpIC0gMSkpO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tcbn1cblxuY2xhc3MgQml0YXBTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgdGhpcy5jaHVua3MgPSBbXTtcblxuICAgIGlmICghdGhpcy5wYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYWRkQ2h1bmsgPSAocGF0dGVybiwgc3RhcnRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh7XG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIGFscGhhYmV0OiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybiksXG4gICAgICAgIHN0YXJ0SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA+IE1BWF9CSVRTKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCByZW1haW5kZXIgPSBsZW4gJSBNQVhfQklUUztcbiAgICAgIGNvbnN0IGVuZCA9IGxlbiAtIHJlbWFpbmRlcjtcblxuICAgICAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihpLCBNQVhfQklUUyksIGkpO1xuICAgICAgICBpICs9IE1BWF9CSVRTO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtYWluZGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBsZW4gLSBNQVhfQklUUztcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihzdGFydEluZGV4KSwgc3RhcnRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybiwgMCk7XG4gICAgfVxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHsgaXNDYXNlU2Vuc2l0aXZlLCBpbmNsdWRlTWF0Y2hlcyB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFpc0Nhc2VTZW5zaXRpdmUpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRXhhY3QgbWF0Y2hcbiAgICBpZiAodGhpcy5wYXR0ZXJuID09PSB0ZXh0KSB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICBzY29yZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgIHJlc3VsdC5pbmRpY2VzID0gW1swLCB0ZXh0Lmxlbmd0aCAtIDFdXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgdXNlIEJpdGFwIGFsZ29yaXRobVxuICAgIGNvbnN0IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCBhbGxJbmRpY2VzID0gW107XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG5cbiAgICB0aGlzLmNodW5rcy5mb3JFYWNoKCh7IHBhdHRlcm4sIGFscGhhYmV0LCBzdGFydEluZGV4IH0pID0+IHtcbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaCh0ZXh0LCBwYXR0ZXJuLCBhbHBoYWJldCwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24gKyBzdGFydEluZGV4LFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBoYXNNYXRjaGVzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdG90YWxTY29yZSArPSBzY29yZTtcblxuICAgICAgaWYgKGlzTWF0Y2ggJiYgaW5kaWNlcykge1xuICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIGlzTWF0Y2g6IGhhc01hdGNoZXMsXG4gICAgICBzY29yZTogaGFzTWF0Y2hlcyA/IHRvdGFsU2NvcmUgLyB0aGlzLmNodW5rcy5sZW5ndGggOiAxXG4gICAgfTtcblxuICAgIGlmIChoYXNNYXRjaGVzICYmIGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmNsYXNzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICB9XG4gIHN0YXRpYyBpc011bHRpTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLm11bHRpUmVnZXgpXG4gIH1cbiAgc3RhdGljIGlzU2luZ2xlTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLnNpbmdsZVJlZ2V4KVxuICB9XG4gIHNlYXJjaCgvKnRleHQqLykge31cbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2gocGF0dGVybiwgZXhwKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXR0ZXJuLm1hdGNoKGV4cCk7XG4gIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IG51bGxcbn1cblxuLy8gVG9rZW46ICdmaWxlXG5cbmNsYXNzIEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXj1cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL149KC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dCA9PT0gdGhpcy5wYXR0ZXJuO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIWZpcmVcblxuY2xhc3MgSW52ZXJzZUV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGV4dC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgY29uc3QgaXNNYXRjaCA9IGluZGV4ID09PSAtMTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiBeZmlsZVxuXG5jbGFzcyBQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3ByZWZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5zdGFydHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhXmZpcmVcblxuY2xhc3MgSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1wcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcXF5cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46IC5maWxlJFxuXG5jbGFzcyBTdWZmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3N1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCJcXCQkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogW3RleHQubGVuZ3RoIC0gdGhpcy5wYXR0ZXJuLmxlbmd0aCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIS5maWxlJFxuXG5jbGFzcyBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLXN1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopXFwkJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSAhdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1enp5TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gICAgdGhpcy5fYml0YXBTZWFyY2ggPSBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2Z1enp5J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRhcFNlYXJjaC5zZWFyY2hJbih0ZXh0KVxuICB9XG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBJbmNsdWRlTWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW5jbHVkZSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eJ1wiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXicoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGxldCBsb2NhdGlvbiA9IDA7XG4gICAgbGV0IGluZGV4O1xuXG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHBhdHRlcm5MZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzXG4gICAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4sIGxvY2F0aW9uKSkgPiAtMSkge1xuICAgICAgbG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG4gICAgICBpbmRpY2VzLnB1c2goW2luZGV4LCBsb2NhdGlvbiAtIDFdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01hdGNoID0gISFpbmRpY2VzLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXNcbiAgICB9XG4gIH1cbn1cblxuLy8g4p2XT3JkZXIgaXMgaW1wb3J0YW50LiBETyBOT1QgQ0hBTkdFLlxuY29uc3Qgc2VhcmNoZXJzID0gW1xuICBFeGFjdE1hdGNoLFxuICBJbmNsdWRlTWF0Y2gsXG4gIFByZWZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCxcbiAgU3VmZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZUV4YWN0TWF0Y2gsXG4gIEZ1enp5TWF0Y2hcbl07XG5cbmNvbnN0IHNlYXJjaGVyc0xlbiA9IHNlYXJjaGVycy5sZW5ndGg7XG5cbi8vIFJlZ2V4IHRvIHNwbGl0IGJ5IHNwYWNlcywgYnV0IGtlZXAgYW55dGhpbmcgaW4gcXVvdGVzIHRvZ2V0aGVyXG5jb25zdCBTUEFDRV9SRSA9IC8gKyg/PSg/OlteXFxcIl0qXFxcIlteXFxcIl0qXFxcIikqW15cXFwiXSokKS87XG5jb25zdCBPUl9UT0tFTiA9ICd8JztcblxuLy8gUmV0dXJuIGEgMkQgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXJ5LCBmb3Igc2ltcGxlciBwYXJzaW5nLlxuLy8gRXhhbXBsZTpcbi8vIFwiXmNvcmUgZ28kIHwgcmIkIHwgcHkkIHh5JFwiID0+IFtbXCJeY29yZVwiLCBcImdvJFwiXSwgW1wicmIkXCJdLCBbXCJweSRcIiwgXCJ4eSRcIl1dXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gcGF0dGVybi5zcGxpdChPUl9UT0tFTikubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IHF1ZXJ5ID0gaXRlbVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KFNQQUNFX1JFKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiAhIWl0ZW0udHJpbSgpKTtcblxuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBxdWVyeUl0ZW0gPSBxdWVyeVtpXTtcblxuICAgICAgLy8gMS4gSGFuZGxlIG11bHRpcGxlIHF1ZXJ5IG1hdGNoIChpLmUsIG9uY2UgdGhhdCBhcmUgcXVvdGVkLCBsaWtlIGBcImhlbGxvIHdvcmxkXCJgKVxuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoIWZvdW5kICYmICsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzTXVsdGlNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBIYW5kbGUgc2luZ2xlIHF1ZXJ5IG1hdGNoZXMgKGkuZSwgb25jZSB0aGF0IGFyZSAqbm90KiBxdW90ZWQpXG4gICAgICBpZHggPSAtMTtcbiAgICAgIHdoaWxlICgrK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc1NpbmdsZU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfSlcbn1cblxuLy8gVGhlc2UgZXh0ZW5kZWQgbWF0Y2hlcnMgY2FuIHJldHVybiBhbiBhcnJheSBvZiBtYXRjaGVzLCBhcyBvcHBvc2VkXG4vLyB0byBhIHNpbmdsIG1hdGNoXG5jb25zdCBNdWx0aU1hdGNoU2V0ID0gbmV3IFNldChbRnV6enlNYXRjaC50eXBlLCBJbmNsdWRlTWF0Y2gudHlwZV0pO1xuXG4vKipcbiAqIENvbW1hbmQtbGlrZSBzZWFyY2hpbmdcbiAqID09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBHaXZlbiBtdWx0aXBsZSBzZWFyY2ggdGVybXMgZGVsaW1pdGVkIGJ5IHNwYWNlcy5lLmcuIGBeanNjcmlwdCAucHl0aG9uJCBydWJ5ICFqYXZhYCxcbiAqIHNlYXJjaCBpbiBhIGdpdmVuIHRleHQuXG4gKlxuICogU2VhcmNoIHN5bnRheDpcbiAqXG4gKiB8IFRva2VuICAgICAgIHwgTWF0Y2ggdHlwZSAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IGBqc2NyaXB0YCAgIHwgZnV6enktbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGZ1enp5IG1hdGNoIGBqc2NyaXB0YCAgICAgICB8XG4gKiB8IGA9c2NoZW1lYCAgIHwgZXhhY3QtbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGFyZSBgc2NoZW1lYCAgICAgICAgICAgICAgICB8XG4gKiB8IGAncHl0aG9uYCAgIHwgaW5jbHVkZS1tYXRjaCAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGluY2x1ZGUgYHB5dGhvbmAgICAgICAgICAgICB8XG4gKiB8IGAhcnVieWAgICAgIHwgaW52ZXJzZS1leGFjdC1tYXRjaCAgICAgICAgfCBJdGVtcyB0aGF0IGRvIG5vdCBpbmNsdWRlIGBydWJ5YCAgICAgICB8XG4gKiB8IGBeamF2YWAgICAgIHwgcHJlZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IHN0YXJ0IHdpdGggYGphdmFgICAgICAgICAgICB8XG4gKiB8IGAhXmVhcmxhbmdgIHwgaW52ZXJzZS1wcmVmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGBlYXJsYW5nYCB8XG4gKiB8IGAuanMkYCAgICAgIHwgc3VmZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IGVuZCB3aXRoIGAuanNgICAgICAgICAgICAgICB8XG4gKiB8IGAhLmdvJGAgICAgIHwgaW52ZXJzZS1zdWZmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBlbmQgd2l0aCBgLmdvYCAgICAgICB8XG4gKlxuICogQSBzaW5nbGUgcGlwZSBjaGFyYWN0ZXIgYWN0cyBhcyBhbiBPUiBvcGVyYXRvci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmdcbiAqIHF1ZXJ5IG1hdGNoZXMgZW50cmllcyB0aGF0IHN0YXJ0IHdpdGggYGNvcmVgIGFuZCBlbmQgd2l0aCBlaXRoZXJgZ29gLCBgcmJgLFxuICogb3JgcHlgLlxuICpcbiAqIGBgYFxuICogXmNvcmUgZ28kIHwgcmIkIHwgcHkkXG4gKiBgYGBcbiAqL1xuY2xhc3MgRXh0ZW5kZWRTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvbixcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2VcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIGlnbm9yZUxvY2F0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucXVlcnkgPSBwYXJzZVF1ZXJ5KHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25kaXRpb24oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoXG4gIH1cblxuICBzZWFyY2hJbih0ZXh0KSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuXG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICAgIHNjb3JlOiAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmNsdWRlTWF0Y2hlcywgaXNDYXNlU2Vuc2l0aXZlIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0ZXh0ID0gaXNDYXNlU2Vuc2l0aXZlID8gdGV4dCA6IHRleHQudG9Mb3dlckNhc2UoKTtcblxuICAgIGxldCBudW1NYXRjaGVzID0gMDtcbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcblxuICAgIC8vIE9Sc1xuICAgIGZvciAobGV0IGkgPSAwLCBxTGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgcUxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzZWFyY2hlcnMgPSBxdWVyeVtpXTtcblxuICAgICAgLy8gUmVzZXQgaW5kaWNlc1xuICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgbnVtTWF0Y2hlcyA9IDA7XG5cbiAgICAgIC8vIEFORHNcbiAgICAgIGZvciAobGV0IGogPSAwLCBwTGVuID0gc2VhcmNoZXJzLmxlbmd0aDsgaiA8IHBMZW47IGogKz0gMSkge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tqXTtcbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBpbmRpY2VzLCBzY29yZSB9ID0gc2VhcmNoZXIuc2VhcmNoKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbnVtTWF0Y2hlcyArPSAxO1xuICAgICAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG4gICAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc2VhcmNoZXIuY29uc3RydWN0b3IudHlwZTtcbiAgICAgICAgICAgIGlmIChNdWx0aU1hdGNoU2V0Lmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcy5wdXNoKGluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbFNjb3JlID0gMDtcbiAgICAgICAgICBudW1NYXRjaGVzID0gMDtcbiAgICAgICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPUiBjb25kaXRpb24sIHNvIGlmIFRSVUUsIHJldHVyblxuICAgICAgaWYgKG51bU1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICAgIHNjb3JlOiB0b3RhbFNjb3JlIC8gbnVtTWF0Y2hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3RoaW5nIHdhcyBtYXRjaGVkXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgc2NvcmU6IDFcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmVnaXN0ZXJlZFNlYXJjaGVycyA9IFtdO1xuXG5mdW5jdGlvbiByZWdpc3RlciguLi5hcmdzKSB7XG4gIHJlZ2lzdGVyZWRTZWFyY2hlcnMucHVzaCguLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucykge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVnaXN0ZXJlZFNlYXJjaGVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBzZWFyY2hlckNsYXNzID0gcmVnaXN0ZXJlZFNlYXJjaGVyc1tpXTtcbiAgICBpZiAoc2VhcmNoZXJDbGFzcy5jb25kaXRpb24ocGF0dGVybiwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBuZXcgc2VhcmNoZXJDbGFzcyhwYXR0ZXJuLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwgb3B0aW9ucylcbn1cblxuY29uc3QgTG9naWNhbE9wZXJhdG9yID0ge1xuICBBTkQ6ICckYW5kJyxcbiAgT1I6ICckb3InXG59O1xuXG5jb25zdCBLZXlUeXBlID0ge1xuICBQQVRIOiAnJHBhdGgnLFxuICBQQVRURVJOOiAnJHZhbCdcbn07XG5cbmNvbnN0IGlzRXhwcmVzc2lvbiA9IChxdWVyeSkgPT5cbiAgISEocXVlcnlbTG9naWNhbE9wZXJhdG9yLkFORF0gfHwgcXVlcnlbTG9naWNhbE9wZXJhdG9yLk9SXSk7XG5cbmNvbnN0IGlzUGF0aCA9IChxdWVyeSkgPT4gISFxdWVyeVtLZXlUeXBlLlBBVEhdO1xuXG5jb25zdCBpc0xlYWYgPSAocXVlcnkpID0+XG4gICFpc0FycmF5KHF1ZXJ5KSAmJiBpc09iamVjdChxdWVyeSkgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSk7XG5cbmNvbnN0IGNvbnZlcnRUb0V4cGxpY2l0ID0gKHF1ZXJ5KSA9PiAoe1xuICBbTG9naWNhbE9wZXJhdG9yLkFORF06IE9iamVjdC5rZXlzKHF1ZXJ5KS5tYXAoKGtleSkgPT4gKHtcbiAgICBba2V5XTogcXVlcnlba2V5XVxuICB9KSlcbn0pO1xuXG4vLyBXaGVuIGBhdXRvYCBpcyBgdHJ1ZWAsIHRoZSBwYXJzZSBmdW5jdGlvbiB3aWxsIGluZmVyIGFuZCBpbml0aWFsaXplIGFuZCBhZGRcbi8vIHRoZSBhcHByb3ByaWF0ZSBgU2VhcmNoZXJgIGluc3RhbmNlXG5mdW5jdGlvbiBwYXJzZShxdWVyeSwgb3B0aW9ucywgeyBhdXRvID0gdHJ1ZSB9ID0ge30pIHtcbiAgY29uc3QgbmV4dCA9IChxdWVyeSkgPT4ge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMocXVlcnkpO1xuXG4gICAgY29uc3QgaXNRdWVyeVBhdGggPSBpc1BhdGgocXVlcnkpO1xuXG4gICAgaWYgKCFpc1F1ZXJ5UGF0aCAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICAgIHJldHVybiBuZXh0KGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KSlcbiAgICB9XG5cbiAgICBpZiAoaXNMZWFmKHF1ZXJ5KSkge1xuICAgICAgY29uc3Qga2V5ID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVEhdIDoga2V5c1swXTtcblxuICAgICAgY29uc3QgcGF0dGVybiA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRURVJOXSA6IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWShrZXkpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIGtleUlkOiBjcmVhdGVLZXlJZChrZXkpLFxuICAgICAgICBwYXR0ZXJuXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXV0bykge1xuICAgICAgICBvYmouc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIGxldCBub2RlID0ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgb3BlcmF0b3I6IGtleXNbMF1cbiAgICB9O1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV4dChpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBpZiAoIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICBxdWVyeSA9IGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KHF1ZXJ5KVxufVxuXG4vLyBQcmFjdGljYWwgc2NvcmluZyBmdW5jdGlvblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKFxuICByZXN1bHRzLFxuICB7IGlnbm9yZUZpZWxkTm9ybSA9IENvbmZpZy5pZ25vcmVGaWVsZE5vcm0gfVxuKSB7XG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAxO1xuXG4gICAgcmVzdWx0Lm1hdGNoZXMuZm9yRWFjaCgoeyBrZXksIG5vcm0sIHNjb3JlIH0pID0+IHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IGtleSA/IGtleS53ZWlnaHQgOiBudWxsO1xuXG4gICAgICB0b3RhbFNjb3JlICo9IE1hdGgucG93KFxuICAgICAgICBzY29yZSA9PT0gMCAmJiB3ZWlnaHQgPyBOdW1iZXIuRVBTSUxPTiA6IHNjb3JlLFxuICAgICAgICAod2VpZ2h0IHx8IDEpICogKGlnbm9yZUZpZWxkTm9ybSA/IDEgOiBub3JtKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC5zY29yZSA9IHRvdGFsU2NvcmU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXRjaGVzKHJlc3VsdCwgZGF0YSkge1xuICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoZXM7XG4gIGRhdGEubWF0Y2hlcyA9IFtdO1xuXG4gIGlmICghaXNEZWZpbmVkKG1hdGNoZXMpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQobWF0Y2guaW5kaWNlcykgfHwgIW1hdGNoLmluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IGluZGljZXMsIHZhbHVlIH0gPSBtYXRjaDtcblxuICAgIGxldCBvYmogPSB7XG4gICAgICBpbmRpY2VzLFxuICAgICAgdmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKG1hdGNoLmtleSkge1xuICAgICAgb2JqLmtleSA9IG1hdGNoLmtleS5zcmM7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmlkeCA+IC0xKSB7XG4gICAgICBvYmoucmVmSW5kZXggPSBtYXRjaC5pZHg7XG4gICAgfVxuXG4gICAgZGF0YS5tYXRjaGVzLnB1c2gob2JqKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNjb3JlKHJlc3VsdCwgZGF0YSkge1xuICBkYXRhLnNjb3JlID0gcmVzdWx0LnNjb3JlO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoXG4gIHJlc3VsdHMsXG4gIGRvY3MsXG4gIHtcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpbmNsdWRlU2NvcmUgPSBDb25maWcuaW5jbHVkZVNjb3JlXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IFtdO1xuXG4gIGlmIChpbmNsdWRlTWF0Y2hlcykgdHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtTWF0Y2hlcyk7XG4gIGlmIChpbmNsdWRlU2NvcmUpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybVNjb3JlKTtcblxuICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IHsgaWR4IH0gPSByZXN1bHQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgaXRlbTogZG9jc1tpZHhdLFxuICAgICAgcmVmSW5kZXg6IGlkeFxuICAgIH07XG5cbiAgICBpZiAodHJhbnNmb3JtZXJzLmxlbmd0aCkge1xuICAgICAgdHJhbnNmb3JtZXJzLmZvckVhY2goKHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgICAgIHRyYW5zZm9ybWVyKHJlc3VsdCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9KVxufVxuXG5jbGFzcyBGdXNlIHtcbiAgY29uc3RydWN0b3IoZG9jcywgb3B0aW9ucyA9IHt9LCBpbmRleCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uQ29uZmlnLCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2ggJiZcbiAgICAgICF0cnVlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVhURU5ERURfU0VBUkNIX1VOQVZBSUxBQkxFKVxuICAgIH1cblxuICAgIHRoaXMuX2tleVN0b3JlID0gbmV3IEtleVN0b3JlKHRoaXMub3B0aW9ucy5rZXlzKTtcblxuICAgIHRoaXMuc2V0Q29sbGVjdGlvbihkb2NzLCBpbmRleCk7XG4gIH1cblxuICBzZXRDb2xsZWN0aW9uKGRvY3MsIGluZGV4KSB7XG4gICAgdGhpcy5fZG9jcyA9IGRvY3M7XG5cbiAgICBpZiAoaW5kZXggJiYgIShpbmRleCBpbnN0YW5jZW9mIEZ1c2VJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihJTkNPUlJFQ1RfSU5ERVhfVFlQRSlcbiAgICB9XG5cbiAgICB0aGlzLl9teUluZGV4ID1cbiAgICAgIGluZGV4IHx8XG4gICAgICBjcmVhdGVJbmRleCh0aGlzLm9wdGlvbnMua2V5cywgdGhpcy5fZG9jcywge1xuICAgICAgICBnZXRGbjogdGhpcy5vcHRpb25zLmdldEZuLFxuICAgICAgICBmaWVsZE5vcm1XZWlnaHQ6IHRoaXMub3B0aW9ucy5maWVsZE5vcm1XZWlnaHRcbiAgICAgIH0pO1xuICB9XG5cbiAgYWRkKGRvYykge1xuICAgIGlmICghaXNEZWZpbmVkKGRvYykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2RvY3MucHVzaChkb2MpO1xuICAgIHRoaXMuX215SW5kZXguYWRkKGRvYyk7XG4gIH1cblxuICByZW1vdmUocHJlZGljYXRlID0gKC8qIGRvYywgaWR4ICovKSA9PiBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9kb2NzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLl9kb2NzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShkb2MsIGkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQXQoaSk7XG4gICAgICAgIGkgLT0gMTtcbiAgICAgICAgbGVuIC09IDE7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIHJlbW92ZUF0KGlkeCkge1xuICAgIHRoaXMuX2RvY3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgdGhpcy5fbXlJbmRleC5yZW1vdmVBdChpZHgpO1xuICB9XG5cbiAgZ2V0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX215SW5kZXhcbiAgfVxuXG4gIHNlYXJjaChxdWVyeSwgeyBsaW1pdCA9IC0xIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgaW5jbHVkZVNjb3JlLFxuICAgICAgc2hvdWxkU29ydCxcbiAgICAgIHNvcnRGbixcbiAgICAgIGlnbm9yZUZpZWxkTm9ybVxuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBsZXQgcmVzdWx0cyA9IGlzU3RyaW5nKHF1ZXJ5KVxuICAgICAgPyBpc1N0cmluZyh0aGlzLl9kb2NzWzBdKVxuICAgICAgICA/IHRoaXMuX3NlYXJjaFN0cmluZ0xpc3QocXVlcnkpXG4gICAgICAgIDogdGhpcy5fc2VhcmNoT2JqZWN0TGlzdChxdWVyeSlcbiAgICAgIDogdGhpcy5fc2VhcmNoTG9naWNhbChxdWVyeSk7XG5cbiAgICBjb21wdXRlU2NvcmUocmVzdWx0cywgeyBpZ25vcmVGaWVsZE5vcm0gfSk7XG5cbiAgICBpZiAoc2hvdWxkU29ydCkge1xuICAgICAgcmVzdWx0cy5zb3J0KHNvcnRGbik7XG4gICAgfVxuXG4gICAgaWYgKGlzTnVtYmVyKGxpbWl0KSAmJiBsaW1pdCA+IC0xKSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zbGljZSgwLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdChyZXN1bHRzLCB0aGlzLl9kb2NzLCB7XG4gICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgIGluY2x1ZGVTY29yZVxuICAgIH0pXG4gIH1cblxuICBfc2VhcmNoU3RyaW5nTGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBzdHJpbmcgaW4gdGhlIGluZGV4XG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7IHY6IHRleHQsIGk6IGlkeCwgbjogbm9ybSB9KSA9PiB7XG4gICAgICBpZiAoIWlzRGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgaXRlbTogdGV4dCxcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgbWF0Y2hlczogW3sgc2NvcmUsIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIF9zZWFyY2hMb2dpY2FsKHF1ZXJ5KSB7XG5cbiAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2UocXVlcnksIHRoaXMub3B0aW9ucyk7XG5cbiAgICBjb25zdCBldmFsdWF0ZSA9IChub2RlLCBpdGVtLCBpZHgpID0+IHtcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCB7IGtleUlkLCBzZWFyY2hlciB9ID0gbm9kZTtcblxuICAgICAgICBjb25zdCBtYXRjaGVzID0gdGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgIGtleTogdGhpcy5fa2V5U3RvcmUuZ2V0KGtleUlkKSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5fbXlJbmRleC5nZXRWYWx1ZUZvckl0ZW1BdEtleUlkKGl0ZW0sIGtleUlkKSxcbiAgICAgICAgICBzZWFyY2hlclxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgICAgaXRlbSxcbiAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXZhbHVhdGUoY2hpbGQsIGl0ZW0sIGlkeCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzLnB1c2goLi4ucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLm9wZXJhdG9yID09PSBMb2dpY2FsT3BlcmF0b3IuQU5EKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9O1xuXG4gICAgY29uc3QgcmVjb3JkcyA9IHRoaXMuX215SW5kZXgucmVjb3JkcztcbiAgICBjb25zdCByZXN1bHRNYXAgPSB7fTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICByZWNvcmRzLmZvckVhY2goKHsgJDogaXRlbSwgaTogaWR4IH0pID0+IHtcbiAgICAgIGlmIChpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgbGV0IGV4cFJlc3VsdHMgPSBldmFsdWF0ZShleHByZXNzaW9uLCBpdGVtLCBpZHgpO1xuXG4gICAgICAgIGlmIChleHBSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIERlZHVwZSB3aGVuIGFkZGluZ1xuICAgICAgICAgIGlmICghcmVzdWx0TWFwW2lkeF0pIHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpZHhdID0geyBpZHgsIGl0ZW0sIG1hdGNoZXM6IFtdIH07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0TWFwW2lkeF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBSZXN1bHRzLmZvckVhY2goKHsgbWF0Y2hlcyB9KSA9PiB7XG4gICAgICAgICAgICByZXN1bHRNYXBbaWR4XS5tYXRjaGVzLnB1c2goLi4ubWF0Y2hlcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cblxuICBfc2VhcmNoT2JqZWN0TGlzdChxdWVyeSkge1xuICAgIGNvbnN0IHNlYXJjaGVyID0gY3JlYXRlU2VhcmNoZXIocXVlcnksIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgeyBrZXlzLCByZWNvcmRzIH0gPSB0aGlzLl9teUluZGV4O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8T2JqZWN0PlxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyAkOiBpdGVtLCBpOiBpZHggfSkgPT4ge1xuICAgICAgaWYgKCFpc0RlZmluZWQoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBrZXkgKGkuZSwgcGF0aCksIGFuZCBmZXRjaCB0aGUgdmFsdWUgYXQgdGhhdCBrZXlcbiAgICAgIGtleXMuZm9yRWFjaCgoa2V5LCBrZXlJbmRleCkgPT4ge1xuICAgICAgICBtYXRjaGVzLnB1c2goXG4gICAgICAgICAgLi4udGhpcy5fZmluZE1hdGNoZXMoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IGl0ZW1ba2V5SW5kZXhdLFxuICAgICAgICAgICAgc2VhcmNoZXJcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIG1hdGNoZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG4gIF9maW5kTWF0Y2hlcyh7IGtleSwgdmFsdWUsIHNlYXJjaGVyIH0pIHtcbiAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGxldCBtYXRjaGVzID0gW107XG5cbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goKHsgdjogdGV4dCwgaTogaWR4LCBuOiBub3JtIH0pID0+IHtcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodGV4dCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaGVyLnNlYXJjaEluKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3JlLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICBub3JtLFxuICAgICAgICAgICAgaW5kaWNlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB2OiB0ZXh0LCBuOiBub3JtIH0gPSB2YWx1ZTtcblxuICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCh7IHNjb3JlLCBrZXksIHZhbHVlOiB0ZXh0LCBub3JtLCBpbmRpY2VzIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzXG4gIH1cbn1cblxuRnVzZS52ZXJzaW9uID0gJzYuNi4yJztcbkZ1c2UuY3JlYXRlSW5kZXggPSBjcmVhdGVJbmRleDtcbkZ1c2UucGFyc2VJbmRleCA9IHBhcnNlSW5kZXg7XG5GdXNlLmNvbmZpZyA9IENvbmZpZztcblxue1xuICBGdXNlLnBhcnNlUXVlcnkgPSBwYXJzZTtcbn1cblxue1xuICByZWdpc3RlcihFeHRlbmRlZFNlYXJjaCk7XG59XG5cbmV4cG9ydCB7IEZ1c2UgYXMgZGVmYXVsdCB9O1xuIiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCIgdHlwZT1cInRzXCI+XHRcblx0ZXhwb3J0IGVudW0gQ2xhc3NUeXBlIHtcblx0XHRVTktOT1dOID0gJ3Vua25vd24nLFxuXG5cdFx0Ly8gc2V0IG9mIGNoYWlucyB3aGljaCBzaGFyZSBhIGNvbW1vbiBhZGRyZXNzIHNwYWNlLCBzdWNoIHRoYXQgdXNlciBhY2NvdW50cyBhcmUgdHJhbnNsYXRhYmxlIGFjcm9zcyBtZW1iZXJzXG5cdFx0RkFNSUxZID0gJ2ZhbWlseScsXG5cblx0XHQvLyBzcGVjaWZpYyBibG9ja2NoYWluXG5cdFx0Q0hBSU4gPSAnY2hhaW4nLFxuXG5cdFx0Ly8gY29uZmlndXJhdGlvbiBmb3IgaG93IHRvIGNvbW11bmljYXRlIHdpdGggY2hhaW5cblx0XHRORVRXT1JLID0gJ25ldHdvcmsnLFxuXG5cdFx0Ly8gXG5cdFx0QUNDT1VOVCA9ICdhY2NvdW50JyxcblxuXHRcdC8vIHB1YmtleSBhc3NvY2lhdGVkIHdpdGggZGlzdGluY3QgZmFtaWx5ICdtZW1iZXInXG5cdFx0Q09OVEFDVCA9ICdjb250YWN0JyxcblxuXHRcdC8vIG9uLWNoYWluIHJlc291cmNlIHRoYXQgb25seSBleGlzdHMgdGhpcyBjaGFpblxuXHRcdENPTlRSQUNUID0gJ2NvbnRyYWN0JyxcblxuXHRcdC8vIGFkZHJlc3NhYmxlIGFzc2V0IGFzc29jaWF0ZWQgd2l0aCBkaXN0aW5jdCBjaGFpblxuXHRcdFRPS0VOID0gJ3Rva2VuJyxcblxuXHRcdC8vIGFzc2V0IGhvbGRpbmdzXG5cdFx0SE9MRElORyA9ICdob2xkaW5nJyxcblxuXHRcdC8vIGFwcCBjb25uZWN0aW9uXG5cdFx0QVBQID0gJ2FwcCcsXG5cblx0XHQvLyBuYXRpdmUgY29pblxuXHRcdENPSU4gPSAnY29pbicsXG5cblx0XHRUQUcgPSAndGFnJyxcblx0XHRJQ09OID0gJ2ljb24nLFxuXG5cdFx0SUJDVCA9ICdpYmN0Jyxcblx0XHRTTklQNzIxID0gJ3NuaXA3MjEnLFxuXHRcdFRYTiA9ICd0eG4nLFxuXHRcdE9USEVSID0gJ290aGVyJyxcblx0fVxuXG5cdGV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoSXRlbSB7XG5cdFx0Y2xhc3M6IENsYXNzVHlwZTtcblx0XHRyZXNvdXJjZVBhdGg6IFJlc291cmNlLlBhdGg7XG5cdFx0bmFtZTogc3RyaW5nO1xuXHRcdHJlc291cmNlOiBSZXNvdXJjZVsnaW50ZXJmYWNlJ107XG5cdFx0ZGV0YWlsczogRGljdDxKc29uVmFsdWU+O1xuXHR9XG5cblx0ZXhwb3J0IGludGVyZmFjZSBTZWFyY2hHcm91cCB7XG5cdFx0c291cmNlOiBQcm9taXNhYmxlPHR5cGVvZiBXcml0YWJsZVN0b3JlTWFwICYgU3RhdGljU3RvcmUgfCBBcnJheTxhbnk+Pjtcblx0XHR0cmFuc2Zvcm0oZ190aGluZzogUmVzb3VyY2VbJ2ludGVyZmFjZSddKTogT21pdDxTZWFyY2hJdGVtLCAncmVmJz47XG5cdFx0a2V5czogc3RyaW5nW107XG5cdH1cbjwvc2NyaXB0PlxuXG48c2NyaXB0IHR5cGU9XCJ0c1wiPlxuXHRpbXBvcnQgRnVzZSBmcm9tICdmdXNlLmpzJztcblxuXHRpbXBvcnQge1xuXHRcdHl3X2NhbmNlbF9zZWFyY2gsXG5cdFx0eXdfaGVhZGVyX3Byb3BzLFxuXHRcdHl3X3NlYXJjaCxcblx0fSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCB7XG5cdFx0U2NyZWVuLFxuXHRcdEhlYWRlcixcblx0fSBmcm9tICcjIy9zY3JlZW4vX3NjcmVlbnMnO1xuXG5cdC8vIGltcG9ydCBHZW5lcmljUm93IGZyb20gJyMvdWkvR2VuZXJpY1Jvdy5zdmVsdGUnO1xuXHRpbXBvcnQge0FjY291bnRzfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHtBZ2VudHN9IGZyb20gJyMvc3RvcmUvYWdlbnRzJztcblx0aW1wb3J0IHtBcHBzfSBmcm9tICcjL3N0b3JlL2FwcHMnO1xuXHRpbXBvcnQge0NoYWluc30gZnJvbSAnIy9zdG9yZS9jaGFpbnMnO1xuXHRpbXBvcnQge0VudGl0aWVzfSBmcm9tICcjL3N0b3JlL2VudGl0aWVzJztcblx0aW1wb3J0IHtNZWRpYXN9IGZyb20gJyMvc3RvcmUvbWVkaWFzJztcblx0aW1wb3J0IHtOZXR3b3Jrc30gZnJvbSAnIy9zdG9yZS9uZXR3b3Jrcyc7XG5cdGltcG9ydCB7UGZwc30gZnJvbSAnIy9zdG9yZS9wZnBzJztcblx0aW1wb3J0IHR5cGUge1Jlc291cmNlfSBmcm9tICcjL21ldGEvcmVzb3VyY2UnO1xuXHRpbXBvcnQgdHlwZSB7QWNjb3VudCwgQWNjb3VudFBhdGh9IGZyb20gJyMvbWV0YS9hY2NvdW50Jztcblx0aW1wb3J0IHtEaWN0LCBKc29uT2JqZWN0LCBKc29uVmFsdWUsIG9kZSwgb2RlcmFjLCBQcm9taXNhYmxlLCBwcm9wZXJ9IGZyb20gJyMvdXRpbC9iZWx0Jztcblx0aW1wb3J0IHR5cGUge1N0YXRpY1N0b3JlLCBXcml0YWJsZVN0b3JlTWFwfSBmcm9tICcjL3N0b3JlL19iYXNlJztcblx0aW1wb3J0IHR5cGUge0FnZW50LCBBZ2VudFBhdGgsIENoYWluUGF0aH0gZnJvbSAnIy9tZXRhL2NoYWluJztcblx0aW1wb3J0IFJvdyBmcm9tICcjL2FwcC91aS9Sb3cuc3ZlbHRlJztcblxuXHRsZXQgZG1fcmVzdWx0czogSFRNTEVsZW1lbnQ7XG5cdGNvbnN0IGFfcmVzdWx0czogU2VhcmNoSXRlbVtdID0gW107XG5cblxuXHQvLyBsZXQgeV9mdXNlOiBGdXNlPFNlYXJjaEl0ZW0+O1xuXHRsZXQgYV9mdXNlczogRnVzZTxTZWFyY2hJdGVtPltdID0gW107XG5cblx0Y29uc3QgZnV6ZXkgPSAoYV9pdGVtczogU2VhcmNoSXRlbVtdLCBhX2tleXM6IHN0cmluZ1tdKSA9PiBuZXcgRnVzZShhX2l0ZW1zLCB7XG5cdFx0aW5jbHVkZVNjb3JlOiB0cnVlLFxuXHRcdGluY2x1ZGVNYXRjaGVzOiB0cnVlLFxuXHRcdGtleXM6IFtcblx0XHRcdCdsYWJlbCcsXG5cdFx0XHQuLi5hX2tleXMubWFwKHMgPT4gYGRldGFpbHMuJHtzfWApLFxuXHRcdF0sXG5cdH0pO1xuXG5cdChhc3luYygpID0+IHtcblx0XHRjb25zdCBoX3N0b3JlcyA9IHt9O1xuXG5cdFx0Y29uc3Qga3NfY2hhaW5zID0gYXdhaXQgQ2hhaW5zLnJlYWQoKTtcblxuXHRcdGFfZnVzZXMgPSBbXG5cdFx0XHQvLyBjaGFpbnNcblx0XHRcdCgoKSA9PiBmdXpleShrc19jaGFpbnMuZW50cmllcygpLm1hcCgoW3BfY2hhaW4sIGdfY2hhaW5dKSA9PiAoe1xuXHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLkNIQUlOLFxuXHRcdFx0XHRuYW1lOiBnX2NoYWluLm5hbWUsXG5cdFx0XHRcdHJlc291cmNlUGF0aDogcF9jaGFpbixcblx0XHRcdFx0cmVzb3VyY2U6IGdfY2hhaW4sXG5cdFx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0XHRuYW1lOiBnX2NoYWluLm5hbWUsXG5cdFx0XHRcdFx0aWQ6IGdfY2hhaW4uaWQsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KSksIFsnaWQnXSkpKCksXG5cblx0XHRcdC8vIGNvaW5zXG5cdFx0XHQoKCkgPT4gZnV6ZXkoa3NfY2hhaW5zLmVudHJpZXMoKS5mbGF0TWFwKChbcF9jaGFpbiwgZ19jaGFpbl0pID0+IG9kZXJhYyhnX2NoYWluLmNvaW5zLCAoc2lfY29pbiwgZ19jb2luKSA9PiAoe1xuXHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLkNPSU4sXG5cdFx0XHRcdG5hbWU6IHByb3BlcihnX2NvaW4uZXh0cmE/LmNvaW5nZWNrb19pZCB8fCAnVW5rbm93bicpLFxuXHRcdFx0XHRwb3N0bmFtZTogc2lfY29pbixcblx0XHRcdFx0cmVzb3VyY2VQYXRoOiBgJHtwX2NoYWlufS9jb2luLiR7c2lfY29pbn1gLFxuXHRcdFx0XHRyZXNvdXJjZToge1xuXHRcdFx0XHRcdG5hbWU6IHByb3BlcihnX2NvaW4uZXh0cmE/LmNvaW5nZWNrb19pZCB8fCAnVW5rbm93bicpLFxuXHRcdFx0XHRcdHBmcDogZ19jaGFpbi5wZnAsXG5cdFx0XHRcdFx0Li4uZ19jb2luLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0c3ltYm9sOiBzaV9jb2luLFxuXHRcdFx0XHRcdGRlbm9tOiBnX2NvaW4uZGVub20sXG5cdFx0XHRcdFx0Y29pbmdlY2tvOiBnX2NvaW4uZXh0cmE/LmNvaW5nZWNrb19pZCB8fCAnJyxcblx0XHRcdFx0fSxcblx0XHRcdH0pKSksIFsnc3ltYm9sJywgJ2Rlbm9tJ10pKSgpLFxuXG5cdFx0XHQuLi5hd2FpdCBQcm9taXNlLmFsbChbXG5cdFx0XHRcdC8vIGFjY291bnRzXG5cdFx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0XHRjb25zdCBrc19hY2NvdW50cyA9IGF3YWl0IEFjY291bnRzLnJlYWQoKTtcblxuXHRcdFx0XHRcdHJldHVybiBmdXpleShrc19hY2NvdW50cy5lbnRyaWVzKCkubWFwKChbcF9hY2NvdW50LCBnX2FjY291bnRdKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBhX2FkZHJzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRcdFx0Y29uc3QgYXNfYWRkcnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuXHRcdFx0XHRcdFx0Zm9yKGNvbnN0IFssIGdfY2hhaW5dIG9mIGtzX2NoYWlucykge1xuXHRcdFx0XHRcdFx0XHRhc19hZGRycy5hZGQoQ2hhaW5zLmFkZHJlc3NGb3IoZ19hY2NvdW50LnB1YmtleSwgZ19jaGFpbikpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRhX2FkZHJzLnB1c2goLi4uYXNfYWRkcnMpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLkFDQ09VTlQsXG5cdFx0XHRcdFx0XHRcdG5hbWU6IGdfYWNjb3VudC5uYW1lLFxuXHRcdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg6IHBfYWNjb3VudCxcblx0XHRcdFx0XHRcdFx0cmVzb3VyY2U6IGdfYWNjb3VudCxcblx0XHRcdFx0XHRcdFx0ZGV0YWlsczoge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IGdfYWNjb3VudC5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdGFkZHJlc3NlczogYV9hZGRycyxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSksIFsnYWRkcmVzc2VzJ10pO1xuXHRcdFx0XHR9KSgpLFxuXG5cdFx0XHRcdC8vIGNvbnRhY3RzXG5cdFx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0XHRjb25zdCBrc19hZ2VudHMgPSBhd2FpdCBBZ2VudHMucmVhZCgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZ1emV5KFsuLi5rc19hZ2VudHMuY29udGFjdHMoKV0ubWFwKChbcF9jb250YWN0LCBnX2NvbnRhY3RdKSA9PiAoe1xuXHRcdFx0XHRcdFx0Y2xhc3M6IENsYXNzVHlwZS5DT05UQUNULFxuXHRcdFx0XHRcdFx0bmFtZTogZ19jb250YWN0Lm5hbWUsXG5cdFx0XHRcdFx0XHRyZXNvdXJjZVBhdGg6IHBfY29udGFjdCxcblx0XHRcdFx0XHRcdHJlc291cmNlOiBnX2NvbnRhY3QsXG5cdFx0XHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IGdfY29udGFjdC5uYW1lLFxuXHRcdFx0XHRcdFx0XHRub3RlczogZ19jb250YWN0Lm5vdGVzLFxuXHRcdFx0XHRcdFx0XHRhZGRyZXNzZXM6IFsuLi5rc19jaGFpbnMuaW5GYW1pbHkoZ19jb250YWN0LmZhbWlseSldXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgoWywgZ19jaGFpbl0pID0+IENoYWlucy5iZWNoMzIoZ19jb250YWN0LmFkZHJlc3MsIGdfY2hhaW4pKSxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSkpLCBbJ25vdGVzJ10pO1xuXHRcdFx0XHR9KSgpLFxuXG5cdFx0XHRcdC8vIGFwcHNcblx0XHRcdFx0KGFzeW5jKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGtzX2FwcHMgPSBhd2FpdCBBcHBzLnJlYWQoKTtcblxuXHRcdFx0XHRcdHJldHVybiBmdXpleShrc19hcHBzLmVudHJpZXMoKS5tYXAoKFtwX2FwcCwgZ19hcHBdKSA9PiAoe1xuXHRcdFx0XHRcdFx0Y2xhc3M6IENsYXNzVHlwZS5BUFAsXG5cdFx0XHRcdFx0XHRuYW1lOiBnX2FwcC5ob3N0LFxuXHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoOiBwX2FwcCxcblx0XHRcdFx0XHRcdHJlc291cmNlOiBnX2FwcCxcblx0XHRcdFx0XHRcdGRldGFpbHM6IHtcblx0XHRcdFx0XHRcdFx0aG9zdDogZ19hcHAuaG9zdCxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSkpLCBbXSk7XG5cdFx0XHRcdH0pKCksXG5cblx0XHRcdFx0Ly8gdG9rZW5zXG5cdFx0XHRcdChhc3luYygpID0+IHtcblx0XHRcdFx0XHRjb25zdCBhX3Rva2VuczogU2VhcmNoSXRlbVtdID0gW107XG5cblx0XHRcdFx0XHRmb3IoY29uc3QgWywgZ19jaGFpbl0gb2Yga3NfY2hhaW5zLmVudHJpZXMoKSkge1xuXHRcdFx0XHRcdFx0Zm9yKGNvbnN0IFtzaV9zcGVjLCBoX3Rva2Vuc10gb2Ygb2RlKGF3YWl0IEVudGl0aWVzLnJlYWRGdW5naWJsZVRva2VucyhnX2NoYWluKSkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yKGNvbnN0IFtwX3Rva2VuLCBnX3Rva2VuXSBvZiBvZGUoaF90b2tlbnMpKSB7XG5cdFx0XHRcdFx0XHRcdFx0YV90b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzczogQ2xhc3NUeXBlLlRPS0VOLFxuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZTogZ190b2tlbi5uYW1lLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVzb3VyY2VQYXRoOiBwX3Rva2VuLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmVzb3VyY2U6IGdfdG9rZW4sXG5cdFx0XHRcdFx0XHRcdFx0XHRkZXRhaWxzOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNwZWM6IHNpX3NwZWMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5hbWU6IGdfdG9rZW4ubmFtZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3ltYm9sOiBnX3Rva2VuLnN5bWJvbCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0YmVjaDMyOiBnX3Rva2VuLmJlY2gzMixcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29kZWhhc2g6IGdfdG9rZW4uaGFzaCxcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gZnV6ZXkoYV90b2tlbnMsIFtcblx0XHRcdFx0XHRcdCdzcGVjJyxcblx0XHRcdFx0XHRcdCdzeW1ib2wnLFxuXHRcdFx0XHRcdFx0J2JlY2gzMicsXG5cdFx0XHRcdFx0XHQnY29kZWhhc2gnLFxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9KSgpLFxuXG5cdFx0XHRcdC8vIEVudGl0aWVzLFxuXHRcdFx0XHQvLyBOZXR3b3Jrcyxcblx0XHRcdF0pLFxuXHRcdF07XG5cdH0pKCk7XG5cblx0ZnVuY3Rpb24gc2VhcmNoKHNfc2VhcmNoOiBzdHJpbmcpIHtcblx0XHRjb25zdCBhX2dyb3Vwczoge3RvcDpudW1iZXIsIGhpdHM6RnVzZS5GdXNlUmVzdWx0PFNlYXJjaEl0ZW0+W119W10gPSBbXTtcblx0XHRjb25zdCBhX2hpdHM6IEZ1c2UuRnVzZVJlc3VsdDxTZWFyY2hJdGVtPltdID0gW107XG5cdFx0bGV0IGNfdG90YWwgPSAwO1xuXG5cdFx0Zm9yKGNvbnN0IHlfZnVzZSBvZiBhX2Z1c2VzKSB7XG5cdFx0XHRjb25zdCBhX2hpdHNfbG9jYWwgPSB5X2Z1c2Uuc2VhcmNoKHNfc2VhcmNoKTtcblxuXHRcdFx0aWYoYV9oaXRzX2xvY2FsLmxlbmd0aCkge1xuXHRcdFx0XHRjX3RvdGFsICs9IGFfaGl0cy5sZW5ndGg7XG5cblx0XHRcdFx0YV9oaXRzLnB1c2goLi4uYV9oaXRzX2xvY2FsKTtcblxuXHRcdFx0XHRhX2dyb3Vwcy5wdXNoKHtcblx0XHRcdFx0XHR0b3A6IGFfaGl0c19sb2NhbFswXS5zY29yZSEsXG5cdFx0XHRcdFx0aGl0czogYV9oaXRzX2xvY2FsLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzb3J0IGFsbCBoaXRzXG5cdFx0YV9oaXRzLnNvcnQoKGdfYSwgZ19iKSA9PiBnX2Iuc2NvcmUhIC0gZ19hLnNjb3JlISk7XG5cblx0XHQvLyBjbGVhciByZXN1bHRzIGxpc3Rcblx0XHRkbV9yZXN1bHRzLmlubmVySFRNTCA9ICcnO1xuXG5cdFx0Y29uc29sZS5sb2coYV9oaXRzKTtcblxuXHRcblx0XHRmb3IoY29uc3QgZ19oaXQgb2YgYV9oaXRzKVx0e1xuXHRcdFx0bmV3IFJvdyh7XG5cdFx0XHRcdHRhcmdldDogZG1fcmVzdWx0cyxcblx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHQuLi5nX2hpdC5pdGVtLFxuXHRcdFx0XHRcdHBmcERpbTogMzIsXG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHQkOiB7XG5cdFx0aWYoJHl3X3NlYXJjaCkge1xuXHRcdFx0c2VhcmNoKCR5d19zZWFyY2gpO1xuXHRcdH1cblx0fVxuXG5cdC8vIG9uTW91bnQoKCkgPT4ge1xuXHQvLyBcdHNlYXJjaCgkeXdfc2VhcmNoKTtcblx0Ly8gfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdC5zZWFyY2gge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0ei1pbmRleDogMTAwMDtcblxuXHRcdC5yZXN1bHRzIHtcblxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGNsYXNzPVwic2VhcmNoXCIgY2xhc3M6ZGlzcGxheV9ub25lPXshJHl3X3NlYXJjaH0+XG5cdDxTY3JlZW4gZGVidWc9J1NlYXJjaCcgcm9vdD5cblx0XHQ8SGVhZGVyIG5ldHdvcmsgYWNjb3VudCBzZWFyY2hcblx0XHRcdGlzU2VhcmNoU2NyZWVuIHsuLi4oJHl3X2hlYWRlcl9wcm9wcyB8fCB7fSl9IG9uOnNlYXJjaD17ZF9ldmVudCA9PiBzZWFyY2goZF9ldmVudC5kZXRhaWwpfVxuXHRcdC8+XG5cblx0XHQ8cCBzdHlsZT0nZm9udC1zaXplOjEycHgnPlxuXHRcdFx0PHNwYW4gc3R5bGU9J2NvbG9yOnZhcigtLXRoZW1lLWNvbG9yLWNhdXRpb24pOyc+RGlzY2xhaW1lcjogPC9zcGFuPlxuXHRcdFx0VGhpcyB0ZW1wb3Jhcnkgc2VhcmNoIGludGVyZmFjZSBkb2VzIG5vdCByZXByZXNlbnQgdGhlIGxvb2sgYW5kIGZ1bmN0aW9uIG9mIHRoZSBhY3R1YWwgc2VhcmNoIGludGVyZmFjZSBjdXJyZW50bHkgdW5kZXIgZGV2ZWxvcG1lbnQgZm9yIGJldGEuXG5cdFx0PC9wPlxuXG5cdFx0PGRpdiBjbGFzcz1cInJlc3VsdHMgbm8tbWFyZ2luXCIgYmluZDp0aGlzPXtkbV9yZXN1bHRzfT5cblx0XHRcdHsja2V5IGFfcmVzdWx0c31cblx0XHRcdFx0eyNlYWNoIGFfcmVzdWx0cyBhcyBnX3Jlc3VsdH1cblx0XHRcdFx0XHQ8R2VuZXJpY1JvdyBpdGVtPXtnX3Jlc3VsdH0gLz5cblx0XHRcdFx0ey9lYWNofVxuXHRcdFx0ey9rZXl9XG5cdFx0PC9kaXY+XG5cdDwvU2NyZWVuPlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyB5d19wcm9ncmVzcyB9IGZyb20gJyMjL21lbSc7XG5cblx0JDogeF93aWR0aF9wY3RfYmFyID0gKCR5d19wcm9ncmVzc1swXSAvICR5d19wcm9ncmVzc1sxXSkgKiAxMDA7XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJsZXNzXCI+XG5cdEBpbXBvcnQgJy4uLy4uLy4uL3N0eWxlL3V0aWwubGVzcyc7XG5cblx0LnByb2dyZXNzIHtcblx0XHQtLWJhci1oZWlnaHQ6IDRweDtcblx0XHR6LWluZGV4OiAxMDAxO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRoZWlnaHQ6IHZhcigtLWJhci1oZWlnaHQpO1xuXHRcdHRvcDogY2FsYygwcHggLSB2YXIoLS1iYXItaGVpZ2h0KSk7XG5cdFx0bGVmdDogMDtcblx0XHR3aWR0aDogMTAwJTtcblx0XHR0cmFuc2l0aW9uOiB0b3AgMC4ycyB2YXIoLS1lYXNlLW91dC1jdWJpYyk7XG5cblx0XHQmLnZpc2libGUge1xuXHRcdFx0dG9wOiAwO1xuXHRcdH1cblxuXHRcdD4uYmFyIHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXHRcdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdFx0d2lkdGg6IDAlO1xuXHRcdFx0dHJhbnNpdGlvbjogd2lkdGggMXMgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdH1cblx0fVxuXG5cdC5zdGVwIHtcblx0XHQuZm9udCh0aW55KTtcblx0XHRjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItdGV4dC1tZWQpO1xuXG5cdFx0ei1pbmRleDogMTAwMTtcblxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IGNhbGMoMHB4IC0gdmFyKC0tdWktcGFkZGluZykpO1xuXHRcdGxlZnQ6IDA7XG5cdFx0Ly8gbGVmdDogY2FsYygwcHggLSAodmFyKC0tYXBwLXdpbmRvdy13aWR0aCkgKiAwLjI1KSk7XG5cdFx0XG5cdFx0bWFyZ2luLXRvcDogdmFyKC0tdWktcGFkZGluZyk7XG5cdFx0bWFyZ2luLWxlZnQ6IHZhcigtLXVpLXBhZGRpbmcpO1xuXHRcdFxuXHRcdG9wYWNpdHk6IDA7XG5cdFx0dHJhbnNpdGlvbjogYWxsIDAuNnMgdmFyKC0tZWFzZS1vdXQtY3ViaWMpO1xuXHRcdHRyYW5zaXRpb24tZGVsYXk6IDAuNHM7XG5cblx0XHQmLnZpc2libGUge1xuXHRcdFx0Ly8gbGVmdDogMDtcblx0XHRcdHRvcDogMDtcblx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0fVxuXHR9XG48L3N0eWxlPlxuXG5cbjxkaXYgY2xhc3M9XCJwcm9ncmVzc1wiIGNsYXNzOnZpc2libGU9eyR5d19wcm9ncmVzc1swXSA+IDB9PlxuXHQ8ZGl2IGNsYXNzPVwiYmFyXCIgc3R5bGU9XCJ3aWR0aDoge3hfd2lkdGhfcGN0X2Jhcn0lO1wiPjwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJzdGVwXCIgY2xhc3M6dmlzaWJsZT17JHl3X3Byb2dyZXNzWzBdID4gMH0+XG5cdFN0ZXAgeyR5d19wcm9ncmVzc1swXSB8fCAkeXdfcHJvZ3Jlc3NbMV19IG9mIHskeXdfcHJvZ3Jlc3NbMV19XG48L2Rpdj5cbiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwibTE4IDE2IDQtNC00LTR2M2gtNS4wNkE4Ljk3NCA4Ljk3NCAwIDAgMCA4IDMuOTUgMy4wMDUgMy4wMDUgMCAwIDAgNSAxQzMuMzQgMSAyIDIuMzQgMiA0czEuMzQgMyAzIDNjLjk1IDAgMS43OC0uNDUgMi4zMy0xLjE0QzkuMjMgNi45IDEwLjYgOC43NyAxMC45MiAxMWgtMy4xQzcuNCA5Ljg0IDYuMyA5IDUgOWMtMS42NiAwLTMgMS4zNC0zIDNzMS4zNCAzIDMgM2MxLjMgMCAyLjQtLjg0IDIuODItMmgzLjFjLS4zMiAyLjIzLTEuNjkgNC4xLTMuNTggNS4xNEM2Ljc4IDE3LjQ1IDUuOTUgMTcgNSAxN2MtMS42NiAwLTMgMS4zNC0zIDNzMS4zNCAzIDMgM2EyLjk5IDIuOTkgMCAwIDAgMi45OS0yLjk1QTguOTc0IDguOTc0IDAgMCAwIDEyLjkzIDEzSDE4djN6XFxcIi8+XFxuPC9zdmc+XCIiLCJleHBvcnQgZGVmYXVsdCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB3aWR0aD1cXFwiMjRcXFwiIGhlaWdodD1cXFwiMjRcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCI+XFxuXFx0PHBhdGggc3R5bGU9XFxcImZpbGw6IHZhcigtLXN2Zy1jb2xvci1mZywgY3VycmVudENvbG9yKTtcXFwiIGQ9XFxcIk0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyek03LjA3IDE4LjI4Yy40My0uOSAzLjA1LTEuNzggNC45My0xLjc4czQuNTEuODggNC45MyAxLjc4QzE1LjU3IDE5LjM2IDEzLjg2IDIwIDEyIDIwcy0zLjU3LS42NC00LjkzLTEuNzJ6bTExLjI5LTEuNDVjLTEuNDMtMS43NC00LjktMi4zMy02LjM2LTIuMzNzLTQuOTMuNTktNi4zNiAyLjMzQTcuOTUgNy45NSAwIDAgMSA0IDEyYzAtNC40MSAzLjU5LTggOC04czggMy41OSA4IDhjMCAxLjgyLS42MiAzLjQ5LTEuNjQgNC44M3pNMTIgNmMtMS45NCAwLTMuNSAxLjU2LTMuNSAzLjVTMTAuMDYgMTMgMTIgMTNzMy41LTEuNTYgMy41LTMuNVMxMy45NCA2IDEyIDZ6bTAgNWMtLjgzIDAtMS41LS42Ny0xLjUtMS41UzExLjE3IDggMTIgOHMxLjUuNjcgMS41IDEuNVMxMi44MyAxMSAxMiAxMXpcXFwiLz5cXG48L3N2Zz5cIiIsImV4cG9ydCBkZWZhdWx0IFwiPHN2ZyB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHdpZHRoPVxcXCIyNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIj5cXG5cXHQ8cGF0aCBzdHlsZT1cXFwiZmlsbDogdmFyKC0tc3ZnLWNvbG9yLWZnLCBjdXJyZW50Q29sb3IpO1xcXCIgZD1cXFwiTTE4IDR2MTZINlY0aDEybTAtMkg2Yy0xLjEgMC0yIC45LTIgMnYxOGgxNlY0YzAtMS4xLS45LTItMi0yem0tMi41IDguNWMtLjgzIDAtMS41LjY3LTEuNSAxLjVzLjY3IDEuNSAxLjUgMS41UzE3IDEyLjgzIDE3IDEycy0uNjctMS41LTEuNS0xLjV6XFxcIi8+XFxuPC9zdmc+XCIiLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBGX05PT1AsIHRpbWVvdXQgfSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IHtcblx0XHR5d19tZW51X2V4cGFuZGVkLCB5d19uYXZpZ2F0b3IsXG5cdH0gZnJvbSAnIy9hcHAvbWVtJztcblxuXHRpbXBvcnQgU1hfSUNPTl9DT05UQUNUUyBmcm9tICcjL2ljb24vc3VwZXJ2aXNvcl9hY2NvdW50LnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9DSEFJTlMgZnJvbSAnIy9pY29uL21lZGlhdGlvbi5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQUNDT1VOVFMgZnJvbSAnIy9pY29uL2FjY291bnRfY2lyY2xlLnN2Zz9yYXcnO1xuXHRpbXBvcnQgU1hfSUNPTl9UQUdTIGZyb20gJyMvaWNvbi9ib29rbWFya3Muc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX0NPTk5FQ1RJT05TIGZyb20gJyMvaWNvbi9hY2NvdW50X3RyZWUuc3ZnP3Jhdyc7XG5cdGltcG9ydCBTWF9JQ09OX1NFVFRJTkdTIGZyb20gJyMvaWNvbi9zZXR0aW5ncy5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fTE9HT1VUIGZyb20gJyMvaWNvbi9zZW5zb3JfZG9vci5zdmc/cmF3Jztcblx0aW1wb3J0IFNYX0lDT05fQ0xPU0UgZnJvbSAnIy9pY29uL2Nsb3NlLnN2Zz9yYXcnO1xuXHRpbXBvcnQgeyBUaHJlYWRJZCB9IGZyb20gJyMvYXBwL2RlZic7XG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgdHlwZSB7IFBhZ2UgfSBmcm9tICcjIy9zY3JlZW4vX3NjcmVlbnMnO1xuXHRpbXBvcnQgeyBsb2dvdXQgfSBmcm9tICcjL3NoYXJlL2F1dGgnO1xuXG5cdGludGVyZmFjZSBJdGVtIHtcblx0XHRjbGljazogVm9pZEZ1bmN0aW9uO1xuXHRcdGxhYmVsOiBzdHJpbmc7XG5cdFx0Ly8gaWNvbjogSWNvbjtcblx0XHRpY29uOiBzdHJpbmc7XG5cdH1cblxuXHRjb25zdCBrX3BhZ2UgPSBnZXRDb250ZXh0PFBhZ2U+KCdwYWdlJyk7XG5cblx0ZnVuY3Rpb24gYWN0aXZhdGUoc2lfdGhyZWFkOiBUaHJlYWRJZCkge1xuXHRcdCR5d19tZW51X2V4cGFuZGVkID0gZmFsc2U7XG5cblx0XHRpZihzaV90aHJlYWQgPT09ICR5d19uYXZpZ2F0b3IuYWN0aXZlVGhyZWFkLmlkKSB7XG5cdFx0XHQkeXdfbmF2aWdhdG9yLmFjdGl2ZVRocmVhZC5yZXNldCgpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHZvaWQgJHl3X25hdmlnYXRvci5hY3RpdmF0ZVRocmVhZChzaV90aHJlYWQpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IEFfSVRFTVMgPSBbXG5cdFx0Ly8ge1xuXHRcdC8vIFx0bGFiZWw6ICdDb250YWN0cycsXG5cdFx0Ly8gXHQvLyBpY29uOiBJY29uLmZyb21IdG1sKFNYX0lDT05fQ09OVEFDVFMpLFxuXHRcdC8vIFx0aWNvbjogU1hfSUNPTl9DT05UQUNUUyxcblx0XHQvLyBcdGNsaWNrKCkge1xuXHRcdC8vIFx0XHQkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlO1xuXHRcdC8vIFx0XHR2b2lkICR5d19uYXZpZ2F0b3IuYWN0aXZhdGVUaHJlYWQoVGhyZWFkSWQuQ09OVEFDVFMpO1xuXHRcdC8vIFx0fSxcblx0XHQvLyB9LFxuXHRcdHtcblx0XHRcdGxhYmVsOiAnQWNjb3VudHMnLFxuXHRcdFx0Ly8gaWNvbjogSWNvbi5mcm9tSHRtbChTWF9JQ09OX0FDQ09VTlRTKSxcblx0XHRcdGljb246IFNYX0lDT05fQUNDT1VOVFMsXG5cdFx0XHRjbGljaygpIHtcblx0XHRcdFx0YWN0aXZhdGUoVGhyZWFkSWQuQUNDT1VOVFMpO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdGxhYmVsOiAnTmV0d29ya3MnLFxuXHRcdFx0Ly8gaWNvbjogSWNvbi5mcm9tSHRtbChTWF9JQ09OX0NIQUlOUyksXG5cdFx0XHRpY29uOiBTWF9JQ09OX0NIQUlOUyxcblx0XHRcdGNsaWNrKCkge1xuXHRcdFx0XHRhY3RpdmF0ZShUaHJlYWRJZC5ORVRXT1JLUyk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0Ly8ge1xuXHRcdC8vIFx0bGFiZWw6ICdUYWdzJyxcblx0XHQvLyBcdC8vIGljb246IEljb24uZnJvbUh0bWwoU1hfSUNPTl9UQUdTKSxcblx0XHQvLyBcdGljb246IFNYX0lDT05fVEFHUyxcblx0XHQvLyBcdGNsaWNrKCkge1xuXHRcdC8vIFx0XHQkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlO1xuXHRcdC8vIFx0XHQvLyBrX3BhZ2UucHVzaCh7XG5cdFx0Ly8gXHRcdC8vIFx0Y3JlYXRvcjogRGVhZEVuZCxcblx0XHQvLyBcdFx0Ly8gfSk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdFx0Ly8ge1xuXHRcdC8vIFx0bGFiZWw6ICdTaXRlcycsXG5cdFx0Ly8gXHQvLyBpY29uOiBJY29uLmZyb21IdG1sKFNYX0lDT05fQ09OTkVDVElPTlMpLFxuXHRcdC8vIFx0aWNvbjogU1hfSUNPTl9DT05ORUNUSU9OUyxcblx0XHQvLyBcdGNsaWNrKCkge1xuXHRcdC8vIFx0XHQkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlO1xuXHRcdC8vIFx0XHR2b2lkICR5d19uYXZpZ2F0b3IuYWN0aXZhdGVUaHJlYWQoVGhyZWFkSWQuU0lURVMpO1xuXHRcdC8vIFx0fSxcblx0XHQvLyB9LFxuXHRcdC8vIHtcblx0XHQvLyBcdGxhYmVsOiAnU2V0dGluZ3MnLFxuXHRcdC8vIFx0Ly8gaWNvbjogSWNvbi5mcm9tSHRtbChTWF9JQ09OX1NFVFRJTkdTKSxcblx0XHQvLyBcdGljb246IFNYX0lDT05fU0VUVElOR1MsXG5cdFx0Ly8gXHRjbGljazogKCkgPT4ge1xuXHRcdC8vIFx0XHQkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlO1xuXHRcdC8vIFx0XHRrX3BhZ2UucHVzaCh7XG5cdFx0Ly8gXHRcdFx0Y3JlYXRvcjogRGVhZEVuZCxcblx0XHQvLyBcdFx0fSk7XG5cdFx0Ly8gXHR9LFxuXHRcdC8vIH0sXG5cdF07XG5cblx0Y29uc3QgQV9TRVNTSU9OX0lURU1TID0gW1xuXHRcdHtcblx0XHRcdGxhYmVsOiAnTG9nIG91dCcsXG5cdFx0XHRpY29uOiBTWF9JQ09OX0xPR09VVCxcblx0XHRcdGFzeW5jIGNsaWNrKCkge1xuXHRcdFx0XHRhd2FpdCBsb2dvdXQoKTtcblx0XHRcdFx0Z2xvYmFsVGhpcy5jbG9zZSgpO1xuXHRcdFx0fSxcblx0XHR9LFxuXHRdO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi9zY3JlZW4vX2Jhc2UubGVzcyc7XG5cblx0OnJvb3Qge1xuXHRcdC0tYmFyLXdpZHRoOiA3OC44JTtcblx0XHQtLWFuaW1hdGlvbi1kdXJhdGlvbjogMXM7XG5cdFx0LS1hbmltYXRpb24tZWFzaW5nOiB2YXIoLS1lYXNlLW91dC1xdWljayk7XG5cdH1cblxuXHRAa2V5ZnJhbWVzIGZhZGUge1xuXHRcdDAlIHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXHRcdH1cblxuXHRcdDEwMCUge1xuXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuXHRcdH1cblx0fVxuXG5cdEBrZXlmcmFtZXMgc2xpZGUge1xuXHRcdDAlIHtcblx0XHRcdHJpZ2h0OiBjYWxjKDAlIC0gdmFyKC0tYmFyLXdpZHRoKSk7XG5cdFx0fVxuXG5cdFx0MTAwJSB7XG5cdFx0XHRyaWdodDogMCU7XG5cdFx0fVxuXHR9XG5cblx0QGtleWZyYW1lcyBvZmZzY3JlZW4ge1xuXHRcdDAlIHtcblx0XHRcdHRvcDogMDtcblx0XHR9XG5cblx0XHQxMDAlIHtcblx0XHRcdHRvcDogdmFyKC0tYXBwLXdpbmRvdy1oZWlnaHQpO1xuXHRcdH1cblx0fVxuXG5cdC5hYnNvbHV0ZShAZGltczogJycpIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cblx0XHR3aWR0aDogaWYoJycgPSBAZGltcywgdmFyKC0tYXBwLXdpbmRvdy13aWR0aCksIEBkaW1zKTtcblx0XHRoZWlnaHQ6IGlmKCcnID0gQGRpbXMsIHZhcigtLWFwcC13aW5kb3ctaGVpZ2h0KSwgQGRpbXMpO1xuXHR9XG5cblx0LnNpZGUtbWVudSB7XG5cdFx0LS1pdGVtLXBhZGRpbmc6IDMwcHg7XG5cblx0XHQuYWJzb2x1dGUoKTtcblx0XHQuZm9udChyZWd1bGFyKTtcblx0XHR6LWluZGV4OiAxMDAxO1xuXHRcdHVzZXItc2VsZWN0OiBub25lO1xuXG5cdFx0Pi5iYWNrZHJvcCB7XG5cdFx0XHQuYWJzb2x1dGUoMTAwJSk7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG5cdFx0XHR0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgdmFyKC0tZWFzZS1vdXQtZXhwbyk7XG5cdFx0fVxuXG5cdFx0Pi5iYXIge1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0d2lkdGg6IHZhcigtLWJhci13aWR0aCk7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1iZyk7XG5cdFx0XHRyaWdodDogMCU7XG5cdFx0XHR0cmFuc2l0aW9uOiByaWdodCB2YXIoLS1hbmltYXRpb24tZHVyYXRpb24pIHZhcigtLWFuaW1hdGlvbi1lYXNpbmcpO1xuXG5cdFx0XHQ+Lm1lbnUge1xuXHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWV2ZW5seTtcblx0XHRcdFx0aGVpZ2h0OiAxMDAlO1xuXG5cdFx0XHRcdHVsIHtcblx0XHRcdFx0XHRtYXJnaW46IDA7XG5cdFx0XHRcdFx0cGFkZGluZzogMDtcblx0XHRcdFx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdFx0XHRcdGZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZTtcblxuXHRcdFx0XHRcdD5saSB7XG5cdFx0XHRcdFx0XHRsaXN0LXN0eWxlOiBub25lO1xuXHRcdFx0XHRcdFx0cGFkZGluZzogMTNweCAwO1xuXHRcdFx0XHRcdFx0cGFkZGluZy1sZWZ0OiB2YXIoLS1pdGVtLXBhZGRpbmcpO1xuXHRcdFx0XHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXG5cdFx0XHRcdFx0XHQ+KiB7XG5cdFx0XHRcdFx0XHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdD4uaWNvbiB7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1kaWFtZXRlcjogMjRweDtcblx0XHRcdFx0XHRcdFx0cGFkZGluZzogMDtcblx0XHRcdFx0XHRcdFx0cGFkZGluZy1yaWdodDogY2FsYyh2YXIoLS1pdGVtLXBhZGRpbmcpIC8gMik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ji5pdGVtcyB7XG5cdFx0XHRcdFx0XHQuaWNvbiB7XG5cdFx0XHRcdFx0XHRcdC0taWNvbi1jb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItcHJpbWFyeSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ji5zZXNzaW9uIHtcblx0XHRcdFx0XHRcdHBhZGRpbmc6IGNhbGModmFyKC0taXRlbS1wYWRkaW5nKSAvIDIpIDA7XG5cblx0XHRcdFx0XHRcdC5pY29uIHtcblx0XHRcdFx0XHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci10ZXh0LW1lZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5tYWluIHtcblx0XHRcdFx0XHRmbGV4OiAxO1xuXHRcdFx0XHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuXHRcdFx0XHRcdHBhZGRpbmctdG9wOiAxNSU7XG5cdFx0XHRcdFx0cGFkZGluZy1ib3R0b206IDE1JTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdD4uYm90dG9tLD4udG9wIHtcblx0XHRcdFx0XHRmbGV4OiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi50b3Age1xuXHRcdFx0XHRcdHBhZGRpbmctdG9wOiAxNSU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQmLmNvbGxhcHNlZCB7XG5cdFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdGFuaW1hdGlvbjogb2Zmc2NyZWVuIHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgc3RlcHMoMiwganVtcC1ub25lKSBib3RoO1xuXHRcdFx0XG5cdFx0XHQ+LmJhY2tkcm9wIHtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0Pi5iYXIge1xuXHRcdFx0XHRyaWdodDogY2FsYygwJSAtIHZhcigtLWJhci13aWR0aCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0aHIge1xuXHRcdFx0bWFyZ2luOiAwIHZhcigtLWl0ZW0tcGFkZGluZyk7XG5cdFx0XHRib3JkZXI6IG5vbmU7XG5cdFx0XHRib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHR9XG5cblx0XHQuY2xvc2Uge1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0cmlnaHQ6IDA7XG5cdFx0XHRtYXJnaW46IDEwcHg7XG5cdFx0XHRwYWRkaW5nOiAxMnB4O1xuXHRcdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblxuXHRcdFx0b3V0bGluZTogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0XHRib3JkZXItcmFkaXVzOiAwcHg7XG5cdFx0XHR0cmFuc2l0aW9uOiBib3JkZXItcmFkaXVzIDY1MG1zIHZhcigtLWVhc2Utb3V0LWV4cG8pO1xuXHRcdFx0cG9pbnRlci1ldmVudHM6IGFsbDtcblxuXHRcdFx0Jjo6YmVmb3JlIHtcblx0XHRcdFx0LS1vY2NsdXNpb24tdGhpY2tuZXNzOiA0cHg7XG5cblx0XHRcdFx0Y29udGVudDogJyc7XG5cdFx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdFx0dG9wOiBjYWxjKHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIC8gMik7XG5cdFx0XHRcdGxlZnQ6IGNhbGModmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgLyAyKTtcblx0XHRcdFx0d2lkdGg6IGNhbGMoMTAwJSAtIHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpKTtcblx0XHRcdFx0aGVpZ2h0OiBjYWxjKDEwMCUgLSB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSk7XG5cdFx0XHRcdG91dGxpbmU6IHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblx0XHRcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHRcdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0XHR9XG5cblx0XHRcdCY6aG92ZXIge1xuXHRcdFx0XHRib3JkZXItcmFkaXVzOiAyMnB4O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPGRpdlxuXHRjbGFzcz1cInNpZGUtbWVudVwiXG5cdGNsYXNzOmNvbGxhcHNlZD17ISR5d19tZW51X2V4cGFuZGVkfVxuPlxuXHQ8ZGl2IGNsYXNzPVwiYmFja2Ryb3BcIlxuXHRcdG9uOmNsaWNrPXsoKSA9PiAkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlfVxuXHQvPlxuXG5cdDxkaXYgY2xhc3M9XCJiYXJcIj5cblx0XHQ8ZGl2IGNsYXNzPVwiY2xvc2UgaWNvblwiIG9uOmNsaWNrPXsoKSA9PiAkeXdfbWVudV9leHBhbmRlZCA9IGZhbHNlfT5cblx0XHRcdHtAaHRtbCBTWF9JQ09OX0NMT1NFfVxuXHRcdDwvZGl2PlxuXG5cdFx0PGRpdiBjbGFzcz1cIm1lbnVcIj5cblx0XHRcdDxkaXYgY2xhc3M9XCJ0b3BcIj5cblx0XHRcdFx0PHVsIGNsYXNzPVwic2Vzc2lvblwiPlxuXHRcdFx0XHRcdHsjZWFjaCBBX1NFU1NJT05fSVRFTVMgYXMgZ19pdGVtfVxuXHRcdFx0XHRcdFx0PGxpIG9uOmNsaWNrPXsoKSA9PiBnX2l0ZW0uY2xpY2soKX0+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBnX2l0ZW0uaWNvbn1cblx0XHRcdFx0XHRcdFx0XHQ8IS0tIDxQdXQgZWxlbWVudD17Z19pdGVtLmljb24ucmVuZGVyKCl9IC8+IC0tPlxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuXHRcdFx0XHRcdFx0XHRcdHtnX2l0ZW0ubGFiZWx9XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHQ8L3VsPlxuXG5cdFx0XHRcdDxocj5cblx0XHRcdDwvZGl2PlxuXG5cdFx0XHQ8ZGl2IGNsYXNzPVwibWFpblwiPlxuXHRcdFx0XHQ8dWwgY2xhc3M9XCJpdGVtc1wiPlxuXHRcdFx0XHRcdHsjZWFjaCBBX0lURU1TIGFzIGdfaXRlbX1cblx0XHRcdFx0XHRcdDxsaSBjbGFzcz1cIlwiIG9uOmNsaWNrPXsoKSA9PiBnX2l0ZW0uY2xpY2soKX0+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuXHRcdFx0XHRcdFx0XHRcdHtAaHRtbCBnX2l0ZW0uaWNvbn1cblx0XHRcdFx0XHRcdFx0XHQ8IS0tIDxQdXQgZWxlbWVudD17Z19pdGVtLmljb24ucmVuZGVyKCl9IC8+IC0tPlxuXHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuXHRcdFx0XHRcdFx0XHRcdHtnX2l0ZW0ubGFiZWx9XG5cdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0ey9lYWNofVxuXHRcdFx0XHQ8L3VsPlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC9kaXY+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgRl9OT09QIH0gZnJvbSAnIy91dGlsL2JlbHQnO1xuXG5cdGltcG9ydCB7XG5cdFx0eXdfbWVudV9leHBhbmRlZCxcblx0XHR5d19tZW51X3ZlbmRvcixcblx0XHR5d19jaGFpbl9yZWYsXG5cdFx0eXdfY2hhaW4sXG5cdFx0eXdfbmV0d29ya19yZWYsXG5cdFx0eXdfbmV0d29yayxcblx0fSBmcm9tICcjIy9tZW0nO1xuXG5cdGltcG9ydCB7IGdsb2JhbF9yZWNlaXZlIH0gZnJvbSAnIy9zY3JpcHQvbXNnLWdsb2JhbCc7XG5cdGltcG9ydCB7IG9uRGVzdHJveSB9IGZyb20gJ3N2ZWx0ZSc7XG5pbXBvcnQgeyBTSV9WRVJTSU9OIH0gZnJvbSAnIy9zaGFyZS9jb25zdGFudHMnO1xuXG5cdC8vIGltcG9ydCB7XG5cdC8vIFx0SWNvbixcblx0Ly8gfSBmcm9tICcjL29iamVjdHMnO1xuXG5cdC8vIGltcG9ydCB7XG5cdC8vIFx0UHV0LFxuXHQvLyAgfSBmcm9tICcjL3VpJztcblxuXHQvLyBpbXBvcnQgU1hfQ09OVEFDVFMgZnJvbSAnQG1hdGVyaWFsLWRlc2lnbi1pY29ucy9zdmcvb3V0bGluZWQvc3VwZXJ2aXNvcl9hY2NvdW50LnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfQ0hBSU5TIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL21lZGlhdGlvbi5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0FDQ09VTlRTIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL2FjY291bnRfY2lyY2xlLnN2Zz9yYXcnO1xuXHQvLyBpbXBvcnQgU1hfVEFHUyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9ib29rbWFya3Muc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9DT05ORUNUSU9OUyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9hY2NvdW50X3RyZWUuc3ZnP3Jhdyc7XG5cdC8vIGltcG9ydCBTWF9TRVRUSU5HUyBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9zZXR0aW5ncy5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0xPR09VVCBmcm9tICdAbWF0ZXJpYWwtZGVzaWduLWljb25zL3N2Zy9vdXRsaW5lZC9zZW5zb3JfZG9vci5zdmc/cmF3Jztcblx0Ly8gaW1wb3J0IFNYX0NMT1NFIGZyb20gJ0BtYXRlcmlhbC1kZXNpZ24taWNvbnMvc3ZnL291dGxpbmVkL2Nsb3NlLnN2Zz9yYXcnO1xuXG5cdC8vIGltcG9ydCBTWF9USVRMRSBmcm9tICcjL2Fzc2V0L3ZlbmRvci9zdGFyc2hlbGwtdGl0bGUuc3ZnP3Jhdyc7XG5cblx0Ly8gJHl3X21lbnVfZXhwYW5kZWRcblxuXHRpbnRlcmZhY2UgSXRlbSB7XG5cdFx0Y2xpY2s6IFZvaWRGdW5jdGlvbjtcblx0XHRsYWJlbDogc3RyaW5nO1xuXHRcdC8vIGljb246IEljb247XG5cdH1cblxuXHQvLyBsZXQgc19sYXRlbmN5ID0gJzEyMG1zJztcblxuXHRsZXQgc19oZWlnaHQgPSAnJztcblx0bGV0IHh0X3doZW4gPSAwO1xuXHRsZXQgeHRfYXZnX2Jsb2NrX3RpbWUgPSAwO1xuXG5cdGxldCBzX25ldHdvcmtfc3RhdHVzID0gJ0xvYWRpbmcnO1xuXHRsZXQgcF9wcm92aWRlciA9ICcnO1xuXHRsZXQgc2lfY2hhaW4gPSAnJztcblxuXHRsZXQgc19ncnBjd19zdGF0dXMgPSAnJztcblx0bGV0IHNfcnBjX3N0YXR1cyA9ICcnO1xuXG5cblx0Ly8gd2hlbiB0aGUgbmV0d29yayBpcyBjaGFuZ2VkXG5cdCQ6IGlmKCR5d19uZXR3b3JrKSB7XG5cdFx0c19oZWlnaHQgPSAnWy4uLl0nO1xuXHRcdHh0X3doZW4gPSAwO1xuXHRcdHh0X2F2Z19ibG9ja190aW1lID0gMDtcblx0XHRzX25ldHdvcmtfc3RhdHVzID0gJ0Nvbm5lY3RpbmcnO1xuXHRcdHBfcHJvdmlkZXIgPSBuZXcgVVJMKCR5d19uZXR3b3JrLmdycGNXZWJVcmwpLmhvc3Q7XG5cdFx0c2lfY2hhaW4gPSAnJztcblx0fVxuXG5cdGdsb2JhbF9yZWNlaXZlKHtcblx0XHRibG9ja0luZm8oZ19pbmZvKSB7XG5cdFx0XHRpZigkeXdfY2hhaW5fcmVmID09PSBnX2luZm8uY2hhaW4pIHtcblx0XHRcdFx0c19uZXR3b3JrX3N0YXR1cyA9ICdPbmxpbmUnO1xuXHRcdFx0XHRzaV9jaGFpbiA9IGdfaW5mby5oZWFkZXIuY2hhaW5faWQgYXMgc3RyaW5nO1xuXG5cdFx0XHRcdHNfaGVpZ2h0ID0gZ19pbmZvLmhlYWRlci5oZWlnaHQgYXMgc3RyaW5nO1xuXHRcdFx0XHR4dF93aGVuID0gRGF0ZS5ub3coKTtcblxuXHRcdFx0XHRjb25zdCBhX3JlY2VudHMgPSBnX2luZm8ucmVjZW50cztcblx0XHRcdFx0aWYoYV9yZWNlbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRjb25zdCBhX2dhcHM6IG51bWJlcltdID0gW107XG5cdFx0XHRcdFx0Zm9yKGxldCBpX2VhY2g9MTsgaV9lYWNoPGFfcmVjZW50cy5sZW5ndGg7IGlfZWFjaCsrKSB7XG5cdFx0XHRcdFx0XHRhX2dhcHMucHVzaChhX3JlY2VudHNbaV9lYWNoXSAtIGFfcmVjZW50c1tpX2VhY2gtMV0pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHh0X2F2Z19ibG9ja190aW1lID0gYV9nYXBzLnJlZHVjZSgoY19vdXQsIHhfdmFsdWUpID0+IGNfb3V0ICsgeF92YWx1ZSwgMCkgLyBhX2dhcHMubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG5cblx0bGV0IHNfbG9uZ19hZ28gPSAnWy4uLl0nO1xuXHRjb25zdCBpX2xvbmdfYWdvID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcblx0XHRpZih4dF93aGVuID4gMCkge1xuXHRcdFx0Y29uc3QgeHRfYWdvID0gRGF0ZS5ub3coKSAtIHh0X3doZW47XG5cdFx0XHRzX2xvbmdfYWdvID0gYCR7TWF0aC5yb3VuZCh4dF9hZ28gLyAxZTMpfSBzZWNvbmRzIGFnb2A7XG5cdFx0fVxuXHR9LCA1MDApO1xuXHRcblx0b25EZXN0cm95KCgpID0+IHtcblx0XHRjbGVhckludGVydmFsKGlfbG9uZ19hZ28pO1xuXHR9KTtcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdDpyb290IHtcblx0XHQtLWJhci13aWR0aDogNzguOCU7XG5cdFx0LS1hbmltYXRpb24tZHVyYXRpb246IDFzO1xuXHRcdC0tYW5pbWF0aW9uLWVhc2luZzogdmFyKC0tZWFzZS1vdXQtcXVpY2spO1xuXHR9XG5cblx0QGtleWZyYW1lcyBmYWRlIHtcblx0XHQwJSB7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcblx0XHR9XG5cblx0XHQxMDAlIHtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44KTtcblx0XHR9XG5cdH1cblxuXHQvLyBAa2V5ZnJhbWVzIHNsaWRlIHtcblx0Ly8gXHQwJSB7XG5cdC8vIFx0XHRsZWZ0OiBjYWxjKDAlIC0gdmFyKC0tYmFyLXdpZHRoKSk7XG5cdC8vIFx0fVxuXG5cdC8vIFx0MTAwJSB7XG5cdC8vIFx0XHRsZWZ0OiAwJTtcblx0Ly8gXHR9XG5cdC8vIH1cdFxuXG5cdEBrZXlmcmFtZXMgb3BhY2l0eSB7XG5cdFx0MCUge1xuXHRcdFx0b3BhY2l0eTogMDtcblx0XHR9XG5cblx0XHQxMDAlIHtcblx0XHRcdG9wYWNpdHk6IDE7XG5cdFx0fVxuXHR9XG5cblxuXHRAa2V5ZnJhbWVzIG9mZnNjcmVlbiB7XG5cdFx0MCUge1xuXHRcdFx0dG9wOiAwO1xuXHRcdH1cblxuXHRcdDEwMCUge1xuXHRcdFx0dG9wOiB2YXIoLS1hcHAtd2luZG93LWhlaWdodCk7XG5cdFx0fVxuXHR9XG5cblx0LmFic29sdXRlKEBkaW1zOiAnJykge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDA7XG5cdFx0bGVmdDogMDtcblxuXHRcdHdpZHRoOiBpZignJyA9IEBkaW1zLCB2YXIoLS1hcHAtd2luZG93LXdpZHRoKSwgQGRpbXMpO1xuXHRcdGhlaWdodDogaWYoJycgPSBAZGltcywgdmFyKC0tYXBwLXdpbmRvdy1oZWlnaHQpLCBAZGltcyk7XG5cdH1cblxuXHQudmVuZG9yLW1lbnUge1xuXHRcdC0taXRlbS1wYWRkaW5nOiAzMHB4O1xuXG5cdFx0LmFic29sdXRlKCk7XG5cdFx0LmZvbnQocmVndWxhcik7XG5cdFx0ei1pbmRleDogMTAwMTtcblx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblx0XHQvLyBjb2xvcjogdmFyKC0tdGhlbWUtY29sb3ItYmxhY2spO1xuXG5cdFx0Pi5iYWNrZHJvcCB7XG5cdFx0XHQuYWJzb2x1dGUoMTAwJSk7XG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG5cdFx0XHR0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgdmFyKC0tZWFzZS1vdXQtZXhwbyk7XG5cdFx0fVxuXG5cdFx0Pi5iYXIge1xuXHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0dG9wOiAwO1xuXHRcdFx0d2lkdGg6IHZhcigtLWJhci13aWR0aCk7XG5cdFx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0XHQvLyBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblx0XHRcdGxlZnQ6IDAlO1xuXHRcdFx0b3BhY2l0eTogMTtcblx0XHRcdHRyYW5zaXRpb246IGxlZnQgdmFyKC0tYW5pbWF0aW9uLWR1cmF0aW9uKSB2YXIoLS1hbmltYXRpb24tZWFzaW5nKSxcblx0XHRcdFx0b3BhY2l0eSBjYWxjKHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgLyAzKSBlYXNlLW91dDtcblxuXHRcdFx0Pi5tZW51IHtcblx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRcdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XG5cdFx0XHRcdGhlaWdodDogMTAwJTtcblxuXHRcdFx0XHR1bCB7XG5cdFx0XHRcdFx0bWFyZ2luOiAwO1xuXHRcdFx0XHRcdHBhZGRpbmc6IDA7XG5cblx0XHRcdFx0XHQ+bGkge1xuXHRcdFx0XHRcdFx0bGlzdC1zdHlsZTogbm9uZTtcblx0XHRcdFx0XHRcdHBhZGRpbmc6IDEzcHggMDtcblx0XHRcdFx0XHRcdHBhZGRpbmctbGVmdDogdmFyKC0taXRlbS1wYWRkaW5nKTtcblx0XHRcdFx0XHRcdGN1cnNvcjogcG9pbnRlcjtcblxuXHRcdFx0XHRcdFx0Pioge1xuXHRcdFx0XHRcdFx0XHR2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQ+Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmc6IDA7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmctcmlnaHQ6IGNhbGModmFyKC0taXRlbS1wYWRkaW5nKSAvIDIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCYuaXRlbXMge1xuXHRcdFx0XHRcdFx0Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJsYWNrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQmLnNlc3Npb24ge1xuXHRcdFx0XHRcdFx0cGFkZGluZzogY2FsYyh2YXIoLS1pdGVtLXBhZGRpbmcpIC8gMikgMDtcblxuXHRcdFx0XHRcdFx0Lmljb24ge1xuXHRcdFx0XHRcdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQ+Lm1haW4ge1xuXHRcdFx0XHRcdGZsZXg6IDE7XG5cdFx0XHRcdFx0ZGlzcGxheTogZmxleDtcblx0XHRcdFx0XHRmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuXHRcdFx0XHRcdGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcblx0XHRcdFx0XHQvLyBwYWRkaW5nLXRvcDogMTUlO1xuXG5cdFx0XHRcdFx0cGFkZGluZy1sZWZ0OiAxZW07XG5cblx0XHRcdFx0XHQ+KiB7XG5cdFx0XHRcdFx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQ+LmFwcCB7XG5cdFx0XHRcdFx0XHQvLyBtYXJnaW4tdG9wOiAyNSU7XG5cdFx0XHRcdFx0XHRtYXJnaW4tdG9wOiAxMHB4O1xuXHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHRcdC5mb250KHRpbnkpO1xuXHRcdFx0XHRcdFx0cGFkZGluZzogMTZweCAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdD4uaW5mbyB7XG5cdFx0XHRcdFx0XHRwYWRkaW5nOiAxNnB4IDA7XG5cblx0XHRcdFx0XHRcdC5uYW1lIHtcblx0XHRcdFx0XHRcdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbWVkKTtcblx0XHRcdFx0XHRcdFx0LmZvbnQodGlueSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC52YWx1ZSB7XG5cdFx0XHRcdFx0XHRcdHBhZGRpbmctdG9wOiA0cHg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Pi5ib3R0b20ge1xuXHRcdFx0XHRcdGZsZXg6IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQmLmNvbGxhcHNlZCB7XG5cdFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRcdHRvcDogMDtcblx0XHRcdGFuaW1hdGlvbjogb2Zmc2NyZWVuIHZhcigtLWFuaW1hdGlvbi1kdXJhdGlvbikgc3RlcHMoMiwganVtcC1ub25lKSBib3RoO1xuXHRcdFx0XG5cdFx0XHQ+LmJhY2tkcm9wIHtcblx0XHRcdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0Pi5iYXIge1xuXHRcdFx0XHRsZWZ0OiBjYWxjKDAlIC0gdmFyKC0tYmFyLXdpZHRoKSk7XG5cdFx0XHRcdG9wYWNpdHk6IDAuMTtcblx0XHRcdH1cblx0XHR9XG5cblxuXHRcdGhyIHtcblx0XHRcdG1hcmdpbjogMCB2YXIoLS1pdGVtLXBhZGRpbmcpO1xuXHRcdFx0Ym9yZGVyOiBub25lO1xuXHRcdFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkIHZhcigtLXRoZW1lLWNvbG9yLWJvcmRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gLmNsb3NlLWRhcmsge1xuXHRcdC8vIFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdC8vIFx0dG9wOiAwO1xuXHRcdC8vIFx0cmlnaHQ6IDA7XG5cdFx0Ly8gXHRtYXJnaW46IDEwcHg7XG5cdFx0Ly8gXHRwYWRkaW5nOiAxMnB4O1xuXHRcdC8vIFx0Y3Vyc29yOiBwb2ludGVyO1xuXHRcdC8vIFx0LS1pY29uLWRpYW1ldGVyOiAyNHB4O1xuXHRcdC8vIFx0LS1pY29uLWNvbG9yOiB2YXIoLS10aGVtZS1jb2xvci1ibGFjayk7XG5cblx0XHQvLyBcdG91dGxpbmU6IDFweCBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1ib3JkZXIpO1xuXHRcdC8vIFx0Ym9yZGVyLXJhZGl1czogMHB4O1xuXHRcdC8vIFx0dHJhbnNpdGlvbjogYm9yZGVyLXJhZGl1cyA2NTBtcyB2YXIoLS1lYXNlLW91dC1leHBvKTtcblx0XHQvLyBcdHBvaW50ZXItZXZlbnRzOiBhbGw7XG5cblx0XHQvLyBcdCY6OmJlZm9yZSB7XG5cdFx0Ly8gXHRcdC0tb2NjbHVzaW9uLXRoaWNrbmVzczogNHB4O1xuXG5cdFx0Ly8gXHRcdGNvbnRlbnQ6ICcnO1xuXHRcdC8vIFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0Ly8gXHRcdHRvcDogY2FsYyh2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSAvIDIpO1xuXHRcdC8vIFx0XHRsZWZ0OiBjYWxjKHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpIC8gMik7XG5cdFx0Ly8gXHRcdHdpZHRoOiBjYWxjKDEwMCUgLSB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSk7XG5cdFx0Ly8gXHRcdGhlaWdodDogY2FsYygxMDAlIC0gdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykpO1xuXHRcdC8vIFx0XHRvdXRsaW5lOiB2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSBzb2xpZCB2YXIoLS10aGVtZS1jb2xvci1wcmltYXJ5KTtcblx0XHQvLyBcdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcblx0XHQvLyBcdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0Ly8gXHR9XG5cblx0XHQvLyBcdCY6aG92ZXIge1xuXHRcdC8vIFx0XHRib3JkZXItcmFkaXVzOiAyMnB4O1xuXHRcdC8vIFx0fVxuXHRcdC8vIH1cblxuXHRcdC5jbG9zZSB7XG5cdFx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0XHR0b3A6IDA7XG5cdFx0XHRyaWdodDogMDtcblx0XHRcdG1hcmdpbjogMTBweDtcblx0XHRcdHBhZGRpbmc6IDEycHg7XG5cdFx0XHRjdXJzb3I6IHBvaW50ZXI7XG5cdFx0XHQtLWljb24tZGlhbWV0ZXI6IDI0cHg7XG5cdFx0XHQtLWljb24tY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXByaW1hcnkpO1xuXG5cdFx0XHRvdXRsaW5lOiAxcHggc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYm9yZGVyKTtcblx0XHRcdGJvcmRlci1yYWRpdXM6IDBweDtcblx0XHRcdHRyYW5zaXRpb246IGJvcmRlci1yYWRpdXMgNjUwbXMgdmFyKC0tZWFzZS1vdXQtZXhwbyk7XG5cdFx0XHRwb2ludGVyLWV2ZW50czogYWxsO1xuXG5cdFx0XHQmOjpiZWZvcmUge1xuXHRcdFx0XHQtLW9jY2x1c2lvbi10aGlja25lc3M6IDRweDtcblxuXHRcdFx0XHRjb250ZW50OiAnJztcblx0XHRcdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0XHR0b3A6IGNhbGModmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgLyAyKTtcblx0XHRcdFx0bGVmdDogY2FsYyh2YXIoLS1vY2NsdXNpb24tdGhpY2tuZXNzKSAvIDIpO1xuXHRcdFx0XHR3aWR0aDogY2FsYygxMDAlIC0gdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykpO1xuXHRcdFx0XHRoZWlnaHQ6IGNhbGMoMTAwJSAtIHZhcigtLW9jY2x1c2lvbi10aGlja25lc3MpKTtcblx0XHRcdFx0b3V0bGluZTogdmFyKC0tb2NjbHVzaW9uLXRoaWNrbmVzcykgc29saWQgdmFyKC0tdGhlbWUtY29sb3ItYmcpO1xuXHRcdFx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdFx0XHRwb2ludGVyLWV2ZW50czogbm9uZTtcblx0XHRcdH1cblxuXHRcdFx0Jjpob3ZlciB7XG5cdFx0XHRcdGJvcmRlci1yYWRpdXM6IDIycHg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHR9XG48L3N0eWxlPlxuXG48ZGl2XG5cdGNsYXNzPVwidmVuZG9yLW1lbnVcIlxuXHRjbGFzczpjb2xsYXBzZWQ9eyEkeXdfbWVudV92ZW5kb3J9XG4+XG5cdDxkaXYgY2xhc3M9XCJiYWNrZHJvcFwiXG5cdFx0b246Y2xpY2s9eygpID0+ICR5d19tZW51X3ZlbmRvciA9IGZhbHNlfVxuXHQvPlxuXG5cdDxkaXYgY2xhc3M9XCJiYXJcIj5cblx0XHQ8ZGl2IGNsYXNzPVwiY2xvc2UgaWNvblwiIG9uOmNsaWNrPXsoKSA9PiAkeXdfbWVudV92ZW5kb3IgPSBmYWxzZX0+XG5cdFx0XHQ8IS0tIDxpbWcgYWx0PVwiQ2xvc2UgaWNvblwiIHNyYz1cIi9hc3NldHMvbWVkaWEvbmF2L2Nsb3NlLnN2Z1wiPiAtLT5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgY2xhc3M9XCJtZW51XCI+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwibWFpblwiPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYXBwXCI+XG5cdFx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRcdDwhLS0ge0BodG1sIFNYX1RJVExFfSAtLT5cblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHR2e1NJX1ZFUlNJT059XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDwhLS0gPGRpdj5cblx0XHRcdFx0XHRDdXJyZW50IGRBcHBcblx0XHRcdFx0PC9kaXY+IC0tPlxuXG5cdFx0XHRcdDwhLS0gPGRpdj5cblx0XHRcdFx0XHRkb21haW46IHNlY3JldHN3YXAuaW9cblx0XHRcdFx0PC9kaXY+IC0tPlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdE5ldHdvcmsgU3RhdHVzXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsdWVcIj5cblx0XHRcdFx0XHRcdHtzX25ldHdvcmtfc3RhdHVzfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHRDaGFpbiBJZFxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbHVlXCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImZvbnQtZmFtaWx5X21vbm9cIj5cblx0XHRcdFx0XHRcdFx0e3NpX2NoYWlufVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHRDdXJyZW50IFByb3ZpZGVyXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsdWVcIj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiZm9udC1mYW1pbHlfbW9ub1wiPlxuXHRcdFx0XHRcdFx0XHR7cF9wcm92aWRlcn1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0Q3VycmVudCBCbG9jayBIZWlnaHRcblx0XHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWx1ZVwiPlxuXHRcdFx0XHRcdFx0I3tzX2hlaWdodH1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImluZm9cIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibmFtZVwiPlxuXHRcdFx0XHRcdFx0QXZlcmFnZSBCbG9jayBUaW1lXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsdWVcIj5cblx0XHRcdFx0XHRcdHsjaWYgeHRfYXZnX2Jsb2NrX3RpbWV9XG5cdFx0XHRcdFx0XHRcdHsoeHRfYXZnX2Jsb2NrX3RpbWUgLyAxZTMpLnRvRml4ZWQoMil9IHNlY29uZHNcblx0XHRcdFx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0XHRcdFx0Wy4uLl1cblx0XHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJpbmZvXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cIm5hbWVcIj5cblx0XHRcdFx0XHRcdExhc3QgQmxvY2sgU2VlblxuXHRcdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cInZhbHVlXCI+XG5cdFx0XHRcdFx0XHR7c19sb25nX2Fnb31cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0PCEtLSA8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJuYW1lXCI+XG5cdFx0XHRcdFx0XHROZXh0IGJsb2NrIGluXG5cdFx0XHRcdFx0PC9kaXY+XG5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwidmFsdWVcIj5cblx0XHRcdFx0XHRcdCBzZWNvbmRzXG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZGl2PiAtLT5cblxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC9kaXY+XG4iLCJpbXBvcnQgdHlwZSB7IFBsYWluT2JqZWN0IH0gZnJvbSAnIy9tZXRhL2JlbHQnO1xuaW1wb3J0IHR5cGUgeyBQYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3IgfSBmcm9tICcjL21ldGEvc3ZlbHRlJztcbmltcG9ydCB7XG5cdERpY3QsIG9iamVjdHNfbWlnaHRfZGlmZmVyLCBvZGUsIFByb21pc2FibGUsXG59IGZyb20gJyMvdXRpbC9iZWx0JztcbmltcG9ydCB7IGRkIH0gZnJvbSAnIy91dGlsL2RvbSc7XG5pbXBvcnQgdHlwZSB7IEp1bXBDb25maWcsIFBvcENvbmZpZywgVGhyZWFkIH0gZnJvbSAnLi90aHJlYWQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VDb25maWc8XG5cdGhfcHJvcHMgZXh0ZW5kcyBEaWN0PHVua25vd24+PURpY3Q8dW5rbm93bj4sXG5cdGRjX2NyZWF0b3IgZXh0ZW5kcyBQYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3I8aF9wcm9wcz49UGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yPGhfcHJvcHM+LFxuPiB7XG5cdGNyZWF0b3I6IGRjX2NyZWF0b3I7XG5cdHByb3BzPzogaF9wcm9wcztcblx0Y29udGV4dD86IFBsYWluT2JqZWN0O1xuXHRldmVudHM/OiBEaWN0PChkX2V2ZW50OiBDdXN0b21FdmVudDx1bmtub3duPikgPT4gUHJvbWlzYWJsZTx2b2lkPj47XG5cdHBhdGg/OiBzdHJpbmc7XG5cdHBhdHRlcm4/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZUV2ZW50Q29uZmlnIHtcblx0LyoqXG5cdCAqIEZpcmVkIGFueXRpbWUgYSBwYWdlIGxvc2VzIGZvY3VzIChpbmNsdWRpbmcgb24gdGhyZWFkIHN3aXRjaClcblx0ICovXG5cdGJsdXI/KCk6IFByb21pc2FibGU8dm9pZD47XG5cblx0LyoqXG5cdCAqIEZpcmVkIGFueXRpbWUgYSBwYWdlIHJlY2VpdmVzIGZvY3VzIChpbmNsdWRpbmcgb24gdGhyZWFkIHN3aXRjaClcblx0ICovXG5cdGZvY3VzPygpOiBQcm9taXNhYmxlPHZvaWQ+O1xuXG5cdC8qKlxuXHQgKiBGaXJlZCB3aGVuIGEgcHJldmlvdXNseSBleGlzdGluZyBwYWdlIGlzIHJlc3RvcmVkIGZyb20gaGlzdG9yeSAoZS5nLiwgdmlhIHBvcClcblx0ICovXG5cdHJlc3RvcmU/KCk6IFByb21pc2FibGU8dm9pZD47XG59XG5cbnR5cGUgUGFnZUV2ZW50SWQgPSBrZXlvZiBQYWdlRXZlbnRDb25maWc7XG5cbmV4cG9ydCBjbGFzcyBQYWdlPFxuXHRoX3Byb3BzIGV4dGVuZHMgRGljdDx1bmtub3duPj1EaWN0PHVua25vd24+LFxuXHRkY19jcmVhdG9yIGV4dGVuZHMgUGFyYW1ldHJpY1N2ZWx0ZUNvbnN0cnVjdG9yPGhfcHJvcHM+PVBhcmFtZXRyaWNTdmVsdGVDb25zdHJ1Y3RvcjxoX3Byb3BzPixcblx0eWNfY29tcG9uZW50IGV4dGVuZHMgSW5zdGFuY2VUeXBlPGRjX2NyZWF0b3I+PUluc3RhbmNlVHlwZTxkY19jcmVhdG9yPixcbj4ge1xuXHRwcm90ZWN0ZWQgX2RjX2NyZWF0b3I6IGRjX2NyZWF0b3I7XG5cdHByb3RlY3RlZCBfeWNfY29tcG9uZW50OiB5Y19jb21wb25lbnQ7XG5cdHByb3RlY3RlZCBfaF9wcm9wczogaF9wcm9wcztcblx0cHJvdGVjdGVkIF9oX2NvbnRleHQ6IFBsYWluT2JqZWN0O1xuXHRwcm90ZWN0ZWQgX2RtX3BhZ2U6IEhUTUxFbGVtZW50O1xuXG5cdHByb3RlY3RlZCBfc2lfcGFnZTogc3RyaW5nO1xuXHRwcm90ZWN0ZWQgX2hfZXZlbnRzOiBQYXJ0aWFsPFJlY29yZDxQYWdlRXZlbnRJZCwgQXJyYXk8KC4uLmFfYXJnczogYW55W10pID0+IFByb21pc2FibGU8dm9pZD4+Pj4gPSB7fTtcblxuXHRwcm90ZWN0ZWQgX3NyX3BhdGg6IHN0cmluZztcblx0cHJvdGVjdGVkIF9zeF9wYXR0ZXJuOiBzdHJpbmc7XG5cblx0Y29uc3RydWN0b3IoZ2NfcGFnZTogUGFnZUNvbmZpZzxoX3Byb3BzLCBkY19jcmVhdG9yPiwgcHJvdGVjdGVkIF9rdF9wYXJlbnQ6IFRocmVhZCkge1xuXHRcdCh7XG5cdFx0XHRjcmVhdG9yOiB0aGlzLl9kY19jcmVhdG9yLFxuXHRcdFx0cHJvcHM6IHRoaXMuX2hfcHJvcHM9e30gYXMgaF9wcm9wcyxcblx0XHRcdGNvbnRleHQ6IHRoaXMuX2hfY29udGV4dD17fSBhcyBQbGFpbk9iamVjdCxcblx0XHRcdC8vIHBhdGg6IHRoaXMuX3NyX3BhdGg9JycsXG5cdFx0XHQvLyBwYXR0ZXJuOiB0aGlzLl9zeF9wYXR0ZXJuPScnLFxuXHRcdH0gPSBnY19wYWdlIGFzIFJlcXVpcmVkPHR5cGVvZiBnY19wYWdlPik7XG5cblx0XHQvLyBzZXQgdW5pcXVlIHBhZ2UgaWRcblx0XHR0aGlzLl9zaV9wYWdlID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcblxuXHRcdC8vIGNyZWF0ZSBidWZmZXIgZWxlbWVudFxuXHRcdGNvbnN0IGRtX2J1ZmZlciA9IGRkKCdkaXYnKTtcblxuXHRcdGNvbnN0IGhtX2NvbnRleHQgPSBuZXcgTWFwKG9kZSh7XG5cdFx0XHQuLi50aGlzLl9oX2NvbnRleHQsXG5cdFx0XHRwYWdlOiB0aGlzLFxuXHRcdH0pKTtcblxuXHRcdC8vIHNwYXduIGNvbXBvbmVudFxuXHRcdHRoaXMuX3ljX2NvbXBvbmVudCA9IG5ldyB0aGlzLl9kY19jcmVhdG9yKHtcblx0XHRcdHRhcmdldDogZG1fYnVmZmVyLFxuXHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0Li4udGhpcy5faF9wcm9wcyxcblx0XHRcdFx0a19wYWdlOiB0aGlzLFxuXHRcdFx0fSxcblx0XHRcdGNvbnRleHQ6IGhtX2NvbnRleHQsXG5cdFx0fSkgYXMgeWNfY29tcG9uZW50O1xuXG5cdFx0Ly8gYmluZCBldmVudHNcblx0XHRpZihnY19wYWdlLmV2ZW50cykge1xuXHRcdFx0Zm9yKGNvbnN0IFtzaV9ldmVudCwgZl9saXN0ZW5lcl0gb2Ygb2RlKGdjX3BhZ2UuZXZlbnRzKSkge1xuXHRcdFx0XHR0aGlzLl95Y19jb21wb25lbnQuJG9uKHNpX2V2ZW50LCBmX2xpc3RlbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBmZXRjaCBkb21cblx0XHRjb25zdCBkbV9zdGF0ZSA9IGRtX2J1ZmZlci5maXJzdEVsZW1lbnRDaGlsZCBhcyBudWxsIHwgSFRNTEVsZW1lbnQ7XG5cdFx0aWYoIWRtX3N0YXRlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYE5vIERPTSBlbGVtZW50IHdhcyBjcmVhdGVkIGR1cmluZyBwYWdlIGNvbXBvbmVudCBzcGF3bmluZyB1c2luZzogJHtKU09OLnN0cmluZ2lmeShnY19wYWdlKX1gKTtcblx0XHR9XG5cblx0XHQvLyBzZXQgZmllbGRcblx0XHR0aGlzLl9kbV9wYWdlID0gZG1fc3RhdGU7XG5cdH1cblxuXHRnZXQgaWQoKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5fc2lfcGFnZTtcblx0fVxuXG5cdGdldCBpbmRleCgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLnRocmVhZC5oaXN0b3J5Lmxlbmd0aDtcblx0fVxuXG5cdGdldCB0aHJlYWQoKTogVGhyZWFkIHtcblx0XHRyZXR1cm4gdGhpcy5fa3RfcGFyZW50O1xuXHR9XG5cblx0Z2V0IGNyZWF0b3IoKTogZGNfY3JlYXRvciB7XG5cdFx0cmV0dXJuIHRoaXMuX2RjX2NyZWF0b3I7XG5cdH1cblxuXHRnZXQgY29tcG9uZW50KCk6IHljX2NvbXBvbmVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX3ljX2NvbXBvbmVudDtcblx0fVxuXG5cdGdldCBwcm9wcygpOiBoX3Byb3BzIHtcblx0XHRyZXR1cm4gdGhpcy5faF9wcm9wcztcblx0fVxuXG5cdGdldCBkb20oKTogSFRNTEVsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl9kbV9wYWdlO1xuXHR9XG5cblx0ZXF1aXZhbGVudCh3X290aGVyOiBQYWdlIHwgUGFnZUNvbmZpZyk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB3X290aGVyLmNyZWF0b3IgPT09IHRoaXMuY3JlYXRvclxuXHRcdFx0JiYgIW9iamVjdHNfbWlnaHRfZGlmZmVyKHdfb3RoZXIucHJvcHMgfHwge30sIHRoaXMucHJvcHMpO1xuXHR9XG5cblx0cGVhaygpOiBQYWdlIHtcblx0XHRyZXR1cm4gdGhpcy5fa3RfcGFyZW50LnBlYWsoKTtcblx0fVxuXG5cdHB1c2goZ2NfcGFnZTogUGFnZUNvbmZpZyk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLl9rdF9wYXJlbnQucHVzaChnY19wYWdlLCB0aGlzKTtcblx0fVxuXG5cdHBvcChnY19wb3A/OiBQb3BDb25maWcpOiBQYWdlIHtcblx0XHRyZXR1cm4gdGhpcy5fa3RfcGFyZW50LnBvcChnY19wb3AgfHwge30sIHRoaXMpO1xuXHR9XG5cblx0anVtcChnY19wYWdlOiBQYWdlQ29uZmlnLCBnY19qdW1wPzogSnVtcENvbmZpZyk6IFBhZ2Uge1xuXHRcdHJldHVybiB0aGlzLl9rdF9wYXJlbnQuanVtcChnY19wYWdlLCBnY19qdW1wIHx8IHt9LCB0aGlzKTtcblx0fVxuXG5cdG9uKGhfZXZlbnRzOiBQYWdlRXZlbnRDb25maWcpOiB2b2lkIHtcblx0XHRmb3IoY29uc3QgW3NpX2V2ZW50LCBmX2xpc3RlbmVyXSBvZiBvZGUoaF9ldmVudHMpKSB7XG5cdFx0XHRpZihmX2xpc3RlbmVyKSB7XG5cdFx0XHRcdGNvbnN0IGFfbGlzdGVuZXJzID0gdGhpcy5faF9ldmVudHNbc2lfZXZlbnRdID0gdGhpcy5faF9ldmVudHNbc2lfZXZlbnRdIHx8IFtdO1xuXHRcdFx0XHRhX2xpc3RlbmVycy5wdXNoKGZfbGlzdGVuZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGZpcmUoc2lfZXZlbnQ6IFBhZ2VFdmVudElkLCBhX2FyZ3M/OiBhbnlbXSk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGFfbGlzdGVuZXJzID0gdGhpcy5faF9ldmVudHNbc2lfZXZlbnRdO1xuXG5cdFx0aWYoYV9saXN0ZW5lcnMpIHtcblx0XHRcdGF3YWl0IFByb21pc2UuYWxsKGFfbGlzdGVuZXJzLm1hcChmID0+IGYoLi4uYV9hcmdzIHx8IFtdIGFzIGNvbnN0KSkpO1xuXHRcdH1cblx0fVxuXG5cdGRlc3Ryb3koKTogdm9pZCB7XG5cdFx0dGhpcy5feWNfY29tcG9uZW50LiRkZXN0cm95KCk7XG5cdH1cblxuXHRyZXNldCgpOiB2b2lkIHtcblx0XHR0aGlzLl9rdF9wYXJlbnQucmVzZXQoKTtcblx0fVxufVxuIiwiaW1wb3J0IHR5cGUgeyBQYXJhbWV0cmljU3ZlbHRlQ29uc3RydWN0b3IgfSBmcm9tICcjL21ldGEvc3ZlbHRlJztcbmltcG9ydCB7IERpY3QsIEZfTk9PUCB9IGZyb20gJyMvdXRpbC9iZWx0JztcbmltcG9ydCB7IGRkIH0gZnJvbSAnIy91dGlsL2RvbSc7XG5pbXBvcnQgdHlwZSB7VGhyZWFkSWR9IGZyb20gJy4uL2RlZic7XG5pbXBvcnQgeyBOYXZpZ2F0b3IsIHNldF96aW5kZXhfcmVsYXRpdmVseSB9IGZyb20gJy4vbmF2aWdhdG9yJztcbmltcG9ydCB7UGFnZSwgUGFnZUNvbmZpZ30gZnJvbSAnLi9wYWdlJztcblxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc2V0Q29uZmlnIHtcblx0a2VlcFRvcD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9wQ29uZmlnIHtcblx0YnlwYXNzQW5pbWF0aW9uPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBKdW1wQ29uZmlnIHtcblx0Zm9yY2U/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgVGhyZWFkIHtcblx0cHJvdGVjdGVkIF9kbV90aHJlYWQ6IEhUTUxEaXZFbGVtZW50O1xuXG5cdHByb3RlY3RlZCBfYV9oaXN0b3J5OiBQYWdlW10gPSBbXTtcblxuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX3NpX3RocmVhZDogVGhyZWFkSWQsIHByb3RlY3RlZCBfZ2NfZGVmYXVsdDogUGFnZUNvbmZpZywgcHJvdGVjdGVkIF9rX25hdmlnYXRvcjogTmF2aWdhdG9yKSB7XG5cdFx0dGhpcy5fZG1fdGhyZWFkID0gZGQoJ2RpdicsIHtcblx0XHRcdCdjbGFzcyc6ICd0aHJlYWQnLFxuXHRcdFx0J2RhdGEtdGhyZWFkLWlkJzogdGhpcy5fc2lfdGhyZWFkLFxuXHRcdFx0J3N0eWxlJzogJ3otaW5kZXg6IDEwMDsnLFxuXHRcdH0pO1xuXHR9XG5cblx0Z2V0IGlkKCk6IFRocmVhZElkIHtcblx0XHRyZXR1cm4gdGhpcy5fc2lfdGhyZWFkO1xuXHR9XG5cblx0Z2V0IGRlZmF1bHQoKTogUGFnZUNvbmZpZyB7XG5cdFx0cmV0dXJuIHRoaXMuX2djX2RlZmF1bHQ7XG5cdH1cblxuXHRnZXQgaGlzdG9yeSgpOiBQYWdlW10ge1xuXHRcdHJldHVybiB0aGlzLl9hX2hpc3Rvcnk7XG5cdH1cblxuXHRnZXQgcGFnZSgpOiBQYWdlIHtcblx0XHRyZXR1cm4gdGhpcy5fYV9oaXN0b3J5WzBdO1xuXHR9XG5cblx0Z2V0IGRvbSgpOiBIVE1MRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2RtX3RocmVhZDtcblx0fVxuXG5cdC8vIHBsYWNlIHBhZ2Vcblx0cHJvdGVjdGVkIF9wbGFjZShnY19wYWdlOiBQYWdlQ29uZmlnKTogUGFnZSB7XG5cdFx0Ly8gY3JlYXRlIG5ldyBwYWdlXG5cdFx0Y29uc3Qga3BfbmV3ID0gbmV3IFBhZ2Uoe1xuXHRcdFx0Li4uZ2NfcGFnZSxcblx0XHRcdGNvbnRleHQ6IHtcblx0XHRcdFx0Li4udGhpcy5fa19uYXZpZ2F0b3IuY29udGV4dCxcblx0XHRcdFx0Li4uZ2NfcGFnZS5jb250ZXh0LFxuXHRcdFx0fSxcblx0XHR9LCB0aGlzKTtcblxuXHRcdC8vIGFwcGVuZCB0byBkb21cblx0XHR0aGlzLl9kbV90aHJlYWQuYXBwZW5kQ2hpbGQoa3BfbmV3LmRvbSk7XG5cblx0XHQvLyBwdXNoIHN0YXRlIHRvIGZyb250IG9mIHN0YWNrXG5cdFx0dGhpcy5fYV9oaXN0b3J5LnVuc2hpZnQoa3BfbmV3KTtcblxuXHRcdC8vIHJldHVybiBuZXcgcGFnZVxuXHRcdHJldHVybiBrcF9uZXc7XG5cdH1cblxuXG5cdHJlc2V0KGdjX3BhZ2U6IFBhZ2VDb25maWc9dGhpcy5kZWZhdWx0LCBnY19yZXNldD86IFJlc2V0Q29uZmlnKTogUGFnZSB7XG5cdFx0Ly8gXG5cdFx0Y29uc3Qge1xuXHRcdFx0a2VlcFRvcDogYl9rZWVwX3RvcCxcblx0XHR9ID0gZ2NfcmVzZXQgfHwge307XG5cblx0XHQvLyByZWYgaGlzdG9yeVxuXHRcdGNvbnN0IGFfaGlzdG9yeSA9IHRoaXMuX2FfaGlzdG9yeTtcblxuXHRcdC8vIC8vIGtlZXAgdG9wIGlzIGVuYWJsZWQ7IGdyYWIgc3JjIHN0eWxlXG5cdFx0Ly8gY29uc3QgZF9zdHlsZSA9IGJfa2VlcF90b3A/IGFfaGlzdG9yeVswXS5kb20uc3R5bGU6IG51bGw7XG5cblx0XHQvLyBkcm9wIGFsbCBzdGFsZSBzdGF0ZXMgaW4gaGlzdG9yeVxuXHRcdGZvcihsZXQgaV9zdGF0ZT1iX2tlZXBfdG9wPyAxOiAwOyBpX3N0YXRlPGFfaGlzdG9yeS5sZW5ndGg7IGlfc3RhdGUrKykge1xuXHRcdFx0YV9oaXN0b3J5W2lfc3RhdGVdLmNvbXBvbmVudC4kZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdC8vIHJlc2V0IGhpc3Rvcnlcblx0XHRhX2hpc3RvcnkubGVuZ3RoID0gMDtcblxuXHRcdC8vIHBsYWNlIG5ldyBwYWdlXG5cdFx0Y29uc3Qga3BfbmV3ID0gdGhpcy5fcGxhY2UoZ2NfcGFnZSk7XG5cblx0XHQvLyBmaXJlIGNoYW5nZSBvbiBuZXcgcGFnZVxuXHRcdHZvaWQgdGhpcy5fa19uYXZpZ2F0b3IuYWZ0ZXJfcmVzZXQodGhpcywga3BfbmV3LCBnY19yZXNldCB8fCB7fSk7XG5cblx0XHQvLyAvLyBrZWVwIHRvcCBpcyBlbmFibGVkXG5cdFx0Ly8gaWYoZF9zdHlsZSkge1xuXHRcdC8vIFx0Ly8gc2V0IG5ldyBzY3JlZW4gYmVsb3dcblx0XHQvLyBcdGtzX25ldy5kb20uc3R5bGUuekluZGV4ID0gKCgrZF9zdHlsZS56SW5kZXgpKzEpKycnO1xuXHRcdC8vIH1cblxuXHRcdHJldHVybiBrcF9uZXc7XG5cdH1cblxuXHRwZWFrKCk6IFBhZ2UgfCB1bmRlZmluZWQge1xuXHRcdHJldHVybiB0aGlzLl9hX2hpc3RvcnlbMV07XG5cdH1cblxuXHRwdXNoKGdjX3BhZ2U6IFBhZ2VDb25maWcsIGtwX3NyYzogUGFnZSk6IFBhZ2Uge1xuXHRcdC8vIGNhbGxlciBpcyBwcmVzZW50IGJ1dCBpdCBpcyBub3QgdGhlIGFjdGl2ZSBwYWdlXG5cdFx0aWYoa3Bfc3JjICE9PSB0aGlzLnBhZ2UpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUHJldmVudGVkIGluYWN0aXZlIHBhZ2UgZnJvbSBwdXNoaW5nIG5ldyBzY3JlZW4nKTtcblx0XHR9XG5cblx0XHQvLyBnZXQgYXBwcm92YWwgZnJvbSBwYXJlbnRcblx0XHRpZighdGhpcy5fa19uYXZpZ2F0b3IuYmVmb3JlX3B1c2goZ2NfcGFnZSwga3Bfc3JjLCB0aGlzKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcmV2ZW50ZWQgaW5hY3RpdmUgdGhyZWFkIGZyb20gcHVzaGluZyBuZXcgc2NyZWVuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gcGxhY2UgcGFnZVxuXHRcdGNvbnN0IGtwX25ldyA9IHRoaXMuX3BsYWNlKGdjX3BhZ2UpO1xuXG5cdFx0Ly8gY2FsbCBob29rcyBvbiBwYXJlbnRcblx0XHR2b2lkIHRoaXMuX2tfbmF2aWdhdG9yLmFmdGVyX3B1c2godGhpcywga3Bfc3JjLCBrcF9uZXcpO1xuXG5cdFx0Ly8gcmV0dXJuIG5ldyBwYWdlXG5cdFx0cmV0dXJuIGtwX25ldztcblx0fVxuXG5cdHBvcChnY19wb3A6IFBvcENvbmZpZywga3Bfc3JjOiBQYWdlKTogUGFnZSB7XG5cdFx0Ly8gY2FsbGVyIGlzIHByZXNlbnQgYnV0IGl0IGlzIG5vdCB0aGUgYWN0aXZlIHBhZ2Vcblx0XHRpZihrcF9zcmMgIT09IHRoaXMucGFnZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcmV2ZW50ZWQgaW5hY3RpdmUgcGFnZSBmcm9tIHBvcHBpbmcgYWN0aXZlIHNjcmVlbicpO1xuXHRcdH1cblxuXHRcdC8vIHRvbyBzaG9ydFxuXHRcdGlmKHRoaXMuX2FfaGlzdG9yeS5sZW5ndGggPCAyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwb3AgZW1wdHkgaGlzdG9yeWApO1xuXHRcdH1cblxuXHRcdC8vIGdldCBhcHByb3ZhbCBmcm9tIHBhcmVudFxuXHRcdGlmKCF0aGlzLl9rX25hdmlnYXRvci5iZWZvcmVfcG9wKGdjX3BvcCwgdGhpcy5fYV9oaXN0b3J5WzFdLCBrcF9zcmMsIHRoaXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ByZXZlbnRlZCBpbmFjdGl2ZSB0aHJlYWQgZnJvbSBwb3BwaW5nIGFjdGl2ZSBzY3JlZW4nKTtcblx0XHR9XG5cblx0XHQvLyBzaGlmdCBoaXN0b3J5XG5cdFx0dGhpcy5fYV9oaXN0b3J5LnNoaWZ0KCk7XG5cblx0XHQvLyBhY3F1aXJlIGRlc3RpbmF0aW9uIHBhZ2Vcblx0XHRjb25zdCBrcF9kc3QgPSB0aGlzLnBhZ2U7XG5cblx0XHQvLyBjYWxsIGhvb2tzIG9uIHBhcmVudFxuXHRcdHZvaWQgdGhpcy5fa19uYXZpZ2F0b3IuYWZ0ZXJfcG9wKHRoaXMsIGtwX3NyYywga3BfZHN0LCBnY19wb3ApO1xuXG5cdFx0Ly8gcmV0dXJuIGRzdCBwYWdlXG5cdFx0cmV0dXJuIGtwX2RzdDtcblx0fVxuXG5cdGp1bXAoZ2NfcGFnZTogUGFnZUNvbmZpZywgZ2NfanVtcDogSnVtcENvbmZpZywga3Bfc3JjOiBQYWdlKTogUGFnZSB7XG5cdFx0Ly8gY2FsbGVyIGlzIHByZXNlbnQgYnV0IGl0IGlzIG5vdCB0aGUgYWN0aXZlIHBhZ2Vcblx0XHRpZihrcF9zcmMgIT09IHRoaXMucGFnZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQcmV2ZW50ZWQgaW5hY3RpdmUgcGFnZSBmcm9tIGp1bXBpbmcgdG8gc2NyZWVuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gZ2V0IGFwcHJvdmFsIGZyb20gcGFyZW50XG5cdFx0aWYoIXRoaXMuX2tfbmF2aWdhdG9yLmJlZm9yZV9qdW1wKGdjX2p1bXAsIGdjX3BhZ2UsIGtwX3NyYywgdGhpcykpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignUHJldmVudGVkIGluYWN0aXZlIHRocmVhZCBmcm9tIGp1bXBpbmcgdG8gc2NyZWVuJyk7XG5cdFx0fVxuXG5cdFx0Ly8gbm90IGJlaW5nIGZvcmNlZCBhbmQgdGhlIHByZXZpb3VzIGl0ZW0gaW4gaGlzdG9yeSBtYXRjaGVzIHRoZSB0YXJnZXRcblx0XHRjb25zdCBrcF9wcmV2ID0gdGhpcy5fYV9oaXN0b3J5WzFdIGFzIFBhZ2UgfCB1bmRlZmluZWQ7XG5cdFx0aWYoIWdjX2p1bXAuZm9yY2UgJiYga3BfcHJldj8uZXF1aXZhbGVudChnY19wYWdlKSkge1xuXHRcdFx0Ly8gZGVmZXIgdG8gcG9wIG9wZXJhdGlvblxuXHRcdFx0cmV0dXJuIHRoaXMucG9wKHt9LCBrcF9zcmMpO1xuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBuZXcgcGFnZVxuXHRcdGNvbnN0IGtwX2RzdCA9IG5ldyBQYWdlKGdjX3BhZ2UsIHRoaXMpO1xuXG5cdFx0Ly8gZGVzdHJveSBhbGwgY29tcG9uZW50cyBmdXJ0aGVyIGJhY2sgaW4gdGhlIHN0YWNrXG5cdFx0dGhpcy5yZXNldCgpO1xuXG5cdFx0Ly8gbW92ZSBkZWFkXG5cdFx0c2V0X3ppbmRleF9yZWxhdGl2ZWx5KGtwX2RzdC5kb20sIGtwX3NyYy5kb20sICsxKTtcblxuXHRcdC8vIHdhaXQgZm9yIGNhbGwgaG9va3MgdG8gcmVzb2x2ZVxuXHRcdHZvaWQgdGhpcy5fa19uYXZpZ2F0b3IuYWZ0ZXJfanVtcCh0aGlzLCBrcF9zcmMsIGtwX2RzdCwgZ2NfanVtcCkudGhlbigoKSA9PiB7XG5cdFx0XHQvLyBhdHRlbXB0IHRvIGRlc3Ryb3kgc3JjIHBhZ2Vcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGtwX3NyYy5kZXN0cm95KCk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaChlX2Rlc3Ryb3kpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKGBGYWlsZWQgdG8gZGVzdHJveSBzdGFsZSBjb21wb25lbnQgYmVsb25naW5nIHRvIHBhZ2U6ICR7a3Bfc3JjLmNyZWF0b3IubmFtZSsnJ31gKTtcblxuXHRcdFx0XHQvLyBhdHRlbXB0IHRvIGZvcmNpYmx5IHJlbW92ZSB0aGUgZG9tXG5cdFx0XHRcdGtwX3NyYy5kb20ucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyByZXR1cm4gbmV3IHBhZ2Vcblx0XHRyZXR1cm4ga3BfZHN0O1xuXHR9XG5cblx0aGlkZSgpOiB2b2lkIHtcblx0XHR0aGlzLl9kbV90aHJlYWQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0fVxuXG5cdHNob3coKTogdm9pZCB7XG5cdFx0dGhpcy5fZG1fdGhyZWFkLnN0eWxlLmRpc3BsYXkgPSAnaW5pdGlhbCc7XG5cdH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUGxhaW5PYmplY3QgfSBmcm9tICcjL21ldGEvYmVsdCc7XG5pbXBvcnQgeyBEaWN0LCBvYmplY3RzX21pZ2h0X2RpZmZlciwgUHJvbWlzYWJsZSB9IGZyb20gJyMvdXRpbC9iZWx0JztcbmltcG9ydCB7IGRkIH0gZnJvbSAnIy91dGlsL2RvbSc7XG5pbXBvcnQgdHlwZSB7IE1lcmdlIH0gZnJvbSAndHMtdG9vbGJlbHQvb3V0L09iamVjdC9NZXJnZSc7XG5pbXBvcnQgeyBUaHJlYWRJZCB9IGZyb20gJy4uL2RlZic7XG5pbXBvcnQgeyBQYWdlLCBQYWdlQ29uZmlnIH0gZnJvbSAnLi9wYWdlJztcbmltcG9ydCB7IEp1bXBDb25maWcsIFBvcENvbmZpZywgUmVzZXRDb25maWcsIFRocmVhZCB9IGZyb20gJy4vdGhyZWFkJztcblxuXG5pbnRlcmZhY2UgSG9va3Mge1xuXHRiZWZvcmVfY2hhbmdlPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwgc190cmFuc2l0aW9uOiBzdHJpbmcsIGhfZXh0cmE/OiBEaWN0KTogdm9pZCB8IGJvb2xlYW47XG5cblx0YmVmb3JlX3B1c2g/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBnY19kc3Q6IFBhZ2VDb25maWcpOiB2b2lkIHwgYm9vbGVhbjtcblx0YmVmb3JlX3BvcD8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGtwX2RzdDogUGFnZSwgZ2NfcG9wOiBQb3BDb25maWcpOiB2b2lkIHwgYm9vbGVhbjtcblx0YmVmb3JlX2p1bXA/KGt0X2NvbnRleHQ6IFRocmVhZCwga3Bfc3JjOiBQYWdlLCBnY19wYWdlOiBQYWdlQ29uZmlnLCBnY19qdW1wOiBKdW1wQ29uZmlnKTogdm9pZCB8IGJvb2xlYW47XG5cblx0YWZ0ZXJfY2hhbmdlPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSB8IG51bGwsIGtwX2RzdDogUGFnZSwgc190cmFuc2l0aW9uOiBzdHJpbmcsIGhfZXh0cmE/OiBEaWN0KTogUHJvbWlzYWJsZTx2b2lkPjtcblxuXHRhZnRlcl9wdXNoPyhrdF9jb250ZXh0OiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlKTogUHJvbWlzYWJsZTx2b2lkIHwgRGljdD47XG5cdGFmdGVyX3BvcD8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGtwX2RzdDogUGFnZSwgZ2NfcG9wOiBQb3BDb25maWcpOiBQcm9taXNhYmxlPHZvaWQgfCBEaWN0Pjtcblx0YWZ0ZXJfanVtcD8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGtwX2RzdDogUGFnZSwgZ2NfanVtcDogSnVtcENvbmZpZyk6IFByb21pc2FibGU8dm9pZCB8IERpY3Q+O1xuXHRhZnRlcl9yZXNldD8oa3RfY29udGV4dDogVGhyZWFkLCBrcF9kc3Q6IFBhZ2UsIGdjX2p1bXA6IFJlc2V0Q29uZmlnKTogUHJvbWlzYWJsZTx2b2lkIHwgRGljdD47XG5cblx0YmVmb3JlX3N3aXRjaD8oa3Rfc3JjOiBUaHJlYWQsIHNpX3RocmVhZF9kc3Q6IFRocmVhZElkKTogUHJvbWlzYWJsZTx2b2lkPjtcblx0YWZ0ZXJfc3dpdGNoPyhrdF9zcmM6IFRocmVhZCwga3RfZHN0OiBUaHJlYWQpOiBQcm9taXNhYmxlPHZvaWQ+O1xufVxuXG5cbnR5cGUgVGhyZWFkU3Bhd25lciA9IChoX3BhcmFtczogUGxhaW5PYmplY3QsIGhfY29udGV4dD86IFBsYWluT2JqZWN0KSA9PiBQYWdlQ29uZmlnO1xuXG50eXBlIFRocmVhZHNDb25maWcgPSBNZXJnZTx7XG5cdGRlZmF1bHQ6IFRocmVhZFNwYXduZXI7XG59LCBQYXJ0aWFsPFJlY29yZDxUaHJlYWRJZCwgVGhyZWFkU3Bhd25lcj4+PjtcblxuZXhwb3J0IGludGVyZmFjZSBOYXZpZ2F0b3JDb25maWcge1xuXHRjb250YWluZXI6IEhUTUxFbGVtZW50O1xuXHRob29rczogSG9va3M7XG5cdHRocmVhZHM6IFRocmVhZHNDb25maWc7XG5cblx0Y29udGV4dDogUGxhaW5PYmplY3QgfCBuZXZlcjtcblxuXHQvLyBzaW5nbGVUaHJlYWRNb2RlPzogYm9vbGVhbjtcblxuXHQvLyByb3V0ZXI6IFJvdXRlcjtcblx0Ly8gdGhyZWFkczogTWVyZ2U8e1xuXHQvLyBcdGRlZmF1bHQ6IFRocmVhZFNwYXduZXI7XG5cdC8vIH0sIFJlY29yZDxUaHJlYWRJZCwgVGhyZWFkU3Bhd25lcj4+O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfemluZGV4X3JlbGF0aXZlbHkoZG1fc3JjOiBIVE1MRWxlbWVudCwgZG1fZHN0OiBIVE1MRWxlbWVudCwgbl9vcmRlcjogbnVtYmVyKTogdm9pZCB7XG5cdGNvbnN0IGl6X3NyYyA9ICtkbV9zcmMuc3R5bGUuekluZGV4O1xuXHRjb25zdCBpel9kc3QgPSBpel9zcmMgKyBuX29yZGVyO1xuXHRkbV9zcmMuc3R5bGUuekluZGV4ID0gaXpfc3JjKycnO1xuXHRkbV9kc3Quc3R5bGUuekluZGV4ID0gaXpfZHN0KycnO1xufVxuXG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yIHtcblx0cHJvdGVjdGVkIF9oX3RocmVhZHM6IFBhcnRpYWw8UmVjb3JkPFRocmVhZElkLCBUaHJlYWQ+PiA9IHt9O1xuXHRwcm90ZWN0ZWQgX2hfdGhyZWFkX3NwYXduZXJzOiBUaHJlYWRzQ29uZmlnO1xuXHRwcm90ZWN0ZWQgX2RtX3RocmVhZHM6IEhUTUxFbGVtZW50O1xuXHQvLyBwcm90ZWN0ZWQgX2JfbW9kZV9zaW5nbGVfdGhyZWFkPzogYm9vbGVhbiA9IGZhbHNlO1xuXHQvLyBwcm90ZWN0ZWQgX2tfcm91dGVyOiBSO1xuXG5cdC8vIGJ1ZmZlciBlbGVtZW50XG5cdHByb3RlY3RlZCBfZG1fYnVmZmVyID0gZGQoJ2RpdicpO1xuXG5cdC8vIGhvb2tzXG5cdHByb3RlY3RlZCBfZ19ob29rczogSG9va3M7XG5cblx0Ly8gY29udGV4dHNcblx0cHJvdGVjdGVkIF9oX2NvbnRleHQ6IFBsYWluT2JqZWN0O1xuXG5cdC8vIGN1cnJlbnRseSBhY3RpdmUgdGhyZWFkIGlkXG5cdHByb3RlY3RlZCBfc2lfdGhyZWFkOiBUaHJlYWRJZCA9IFRocmVhZElkLkRFRkFVTFQ7XG5cblx0Ly8gcnVubmluZyB6LWluZGV4IGNvdW50ZXIgZm9yIG5ldyB0aHJlYWRzXG5cdHByb3RlY3RlZCBfY190aHJlYWRfeiA9IDIwMDtcblxuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBfZ2NfbmF2aWdhdG9yOiBOYXZpZ2F0b3JDb25maWcpIHtcblx0XHQvLyB0aHJlYWQgY29udGFpbmVyIGRvbVxuXHRcdCh7XG5cdFx0XHRjb250YWluZXI6IHRoaXMuX2RtX3RocmVhZHMsXG5cdFx0XHR0aHJlYWRzOiB0aGlzLl9oX3RocmVhZF9zcGF3bmVycyxcblx0XHRcdGhvb2tzOiB0aGlzLl9nX2hvb2tzLFxuXHRcdFx0Y29udGV4dDogdGhpcy5faF9jb250ZXh0PXt9LFxuXHRcdFx0Ly8gcm91dGVyOiB0aGlzLl9rX3JvdXRlcixcblx0XHRcdC8vIHNpbmdsZVRocmVhZE1vZGU6IHRoaXMuX2JfbW9kZV9zaW5nbGVfdGhyZWFkPWZhbHNlLFxuXHRcdH0gPSBfZ2NfbmF2aWdhdG9yKTtcblxuXHRcdC8vIGNyZWF0ZSBkZWZhdWx0IHRocmVhZFxuXHRcdHRoaXMuX25ld190aHJlYWQoVGhyZWFkSWQuREVGQVVMVCk7XG5cdH1cblxuXHRnZXQgY29udGV4dCgpOiBQbGFpbk9iamVjdCB7XG5cdFx0cmV0dXJuIHRoaXMuX2hfY29udGV4dDtcblx0fVxuXG5cdHByaXZhdGUgX25ld190aHJlYWQoc2lfdGhyZWFkOiBUaHJlYWRJZCwgaF9wcm9wczogRGljdDx1bmtub3duPj17fSwgaF9jb250ZXh0OiBQbGFpbk9iamVjdD17fSk6IFRocmVhZCB7XG5cdFx0Ly8gbm8gc3VjaCB0aHJlYWQgc3Bhd25lclxuXHRcdGNvbnN0IGZfc3Bhd25lciA9IHRoaXMuX2hfdGhyZWFkX3NwYXduZXJzW3NpX3RocmVhZF07XG5cdFx0aWYoIWZfc3Bhd25lcikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBOYXZpZ2F0b3IgaGFzIG5vIHN1Y2ggdGhyZWFkIHJlZ2lzdGVyZWQ6ICcke3NpX3RocmVhZH0nYCk7XG5cdFx0fVxuXG5cdFx0Ly8gY3JlYXRlIG5ldyB0aHJlYWRcblx0XHRjb25zdCBrdF9uZXcgPSBuZXcgVGhyZWFkKHNpX3RocmVhZCwgZl9zcGF3bmVyKGhfcHJvcHMsIGhfY29udGV4dCksIHRoaXMpO1xuXG5cdFx0Ly8gc2F2ZSB0byB0aHJlYWRzXG5cdFx0dGhpcy5faF90aHJlYWRzW3NpX3RocmVhZF0gPSBrdF9uZXc7XG5cblx0XHQvLyBhcHBlbmQgdGhyZWFkIHRvIGNvbnRhaW5lclxuXHRcdHRoaXMuX2RtX3RocmVhZHMuYXBwZW5kQ2hpbGQoa3RfbmV3LmRvbSk7XG5cblx0XHQvLyBjcmVhdGUgbmV3IGRlZmF1bHQgcGFnZSBhbmQgbWVyZ2UgcHJvcHNcblx0XHRrdF9uZXcucmVzZXQoe1xuXHRcdFx0Li4ua3RfbmV3LmRlZmF1bHQsXG5cdFx0XHRwcm9wczoge1xuXHRcdFx0XHQuLi5rdF9uZXcuZGVmYXVsdC5wcm9wcyxcblx0XHRcdFx0Li4uaF9wcm9wcyxcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHQvLyByZXR1cm4gbmV3IHRocmVhZFxuXHRcdHJldHVybiBrdF9uZXc7XG5cdH1cblxuXHQvKipcblx0ICogR2V0cyB0aGUgY3VycmVudGx5IGFjdGl2ZSB0aHJlYWQuXG5cdCAqL1xuXHRnZXQgYWN0aXZlVGhyZWFkKCk6IFRocmVhZCB7XG5cdFx0cmV0dXJuIHRoaXMuX2hfdGhyZWFkc1t0aGlzLl9zaV90aHJlYWRdITtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjdXJyZW50bHkgYWN0aXZlIHBhZ2UuXG5cdCAqL1xuXHRnZXQgYWN0aXZlUGFnZSgpOiBQYWdlIHtcblx0XHRyZXR1cm4gdGhpcy5hY3RpdmVUaHJlYWQucGFnZTtcblx0fVxuXG5cdC8vIC8qKlxuXHQvLyAgKiBQdXNoZXMgYSBuZXcgcGFnZSB0byB0aGUgY3VycmVudGx5IGFjdGl2ZSB0aHJlYWQuXG5cdC8vICAqL1xuXHQvLyBwdXNoKGdjX3BhZ2U6IFBhZ2VDb25maWcpOiBQYWdlIHtcblx0Ly8gXHQvLyByZWYgY3VycmVudCAoc29vbiB0byBiZSBvbGQpIHBhZ2Vcblx0Ly8gXHRjb25zdCBrcF9vbGQgPSB0aGlzLmFjdGl2ZVBhZ2U7XG5cblx0Ly8gXHQvLyBjcmVhdGUgbmV3IHBhZ2Vcblx0Ly8gXHRjb25zdCBrcF9uZXcgPSB0aGlzLmFjdGl2ZVRocmVhZC5wdXNoKGdjX3BhZ2UpO1xuXG5cdC8vIFx0Ly8gLy8gY2FsbCBob29rc1xuXHQvLyBcdC8vIHRoaXMuX2ZfcHVzaChrcF9vbGQsIGtwX25ldyk7XG5cdC8vIFx0Ly8gdGhpcy5fYXJyaXZlKGtwX29sZCwgJycsICdwdXNoJyk7XG5cblx0Ly8gXHQvLyByZXR1cm4gbmV3IHBhZ2Vcblx0Ly8gXHRyZXR1cm4ga3BfbmV3O1xuXHQvLyB9XG5cblx0Ly8gLyoqXG5cdC8vICAqIFBvcHMgdGhlIGFjdGl2ZSBwYWdlIGZyb20gdGhlIHN0YWNrLlxuXHQvLyAgKi9cblx0Ly8gcG9wKGdjX3BvcD86IFBvcENvbmZpZyk6IFBhZ2Uge1xuXHQvLyBcdC8vIGRlc3RydWN0dXJlIG9wdGlvbnNcblx0Ly8gXHRjb25zdCB7XG5cdC8vIFx0XHRieXBhc3NBbmltYXRpb246IGJfYnlwYXNzX2FuaW1hdGlvbj1mYWxzZSxcblx0Ly8gXHR9ID0gZ2NfcG9wIHx8IHt9O1xuXG5cdC8vIFx0Ly8gdG9vIHNob3J0XG5cdC8vIFx0aWYodGhpcy5hY3RpdmVUaHJlYWQuaGlzdG9yeS5sZW5ndGggPCAyKSB7XG5cdC8vIFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwb3AgZW1wdHkgaGlzdG9yeWApO1xuXHQvLyBcdH1cblxuXHQvLyBcdC8vIHBvcCBmcm9tIGZyb250IG9mIHN0YWNrXG5cdC8vIFx0Y29uc3Qga3Bfc3JjID0gdGhpcy5hY3RpdmVUaHJlYWQucG9wKCk7XG5cblx0Ly8gXHQvLyAvLyBlbXB0eSBoaXN0b3J5XG5cdC8vIFx0Ly8gaWYoIWtzX3NyYykge1xuXHQvLyBcdC8vIFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcG9wIGVtcHR5IGhpc3RvcnlgKTtcblx0Ly8gXHQvLyB9XG5cblx0Ly8gXHQvLyAvLyBjYWxsIGhvb2tzXG5cdC8vIFx0Ly8gdGhpcy5fZl9wb3Aoa3Bfc3JjLCB0aGlzLnN0YXRlLCBiX2J5cGFzc19hbmltYXRpb24pO1xuXHQvLyBcdC8vIHRoaXMuX2Fycml2ZShrcF9zcmMsICcnLCBiX2J5cGFzc19hbmltYXRpb24/ICdwb3AuYnlwYXNzJzogJ3BvcCcpLnRoZW4oKCkgPT4ge1xuXHQvLyBcdC8vIFx0dHJ5IHtcblx0Ly8gXHQvLyBcdFx0a3Bfc3JjLmNvbXBvbmVudC4kZGVzdHJveSgpO1xuXHQvLyBcdC8vIFx0fVxuXHQvLyBcdC8vIFx0Y2F0Y2goZV9kZXN0cm95KSB7XG5cdC8vIFx0Ly8gXHRcdGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBkZXN0cm95IHN0YWxlIGNvbXBvbmVudCBiZWxvbmdpbmcgdG8gU3RhdGU6ICR7a3Bfc3JjLnBhdHRlcm59YCk7XG5cdC8vIFx0Ly8gXHR9XG5cdC8vIFx0Ly8gfSk7XG5cblx0Ly8gXHQvLyByZXR1cm4gb2xkIHBhZ2Vcblx0Ly8gXHRyZXR1cm4ga3Bfc3JjO1xuXHQvLyB9XG5cblxuXHRiZWZvcmVfcHVzaChnY19wYWdlOiBQYWdlQ29uZmlnLCBrcF9zcmM6IFBhZ2UsIGt0X2NoaWxkOiBUaHJlYWQpOiBib29sZWFuIHtcblx0XHQvLyBub3QgYWN0aXZlIHRocmVhZDsgZGVueVxuXHRcdGlmKHRoaXMuYWN0aXZlVGhyZWFkICE9PSBrdF9jaGlsZCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Ly8gY2FsbCBwcmVwdXNoIGhvb2tzXG5cdFx0aWYoZmFsc2UgPT09IHRoaXMuX2dfaG9va3MuYmVmb3JlX2NoYW5nZT8uKGt0X2NoaWxkLCBrcF9zcmMsICdwdXNoJykpIHJldHVybiBmYWxzZTtcblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfcHVzaD8uKGt0X2NoaWxkLCBrcF9zcmMsIGdjX3BhZ2UpKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBhcHByb3ZlZFxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblxuXHRiZWZvcmVfcG9wKGdjX3BvcDogUG9wQ29uZmlnLCBrcF9kc3Q6IFBhZ2UsIGtwX3NyYzogUGFnZSwga3RfY2hpbGQ6IFRocmVhZCk6IGJvb2xlYW4ge1xuXHRcdC8vIG5vdCBhY3RpdmUgdGhyZWFkOyBkZW55XG5cdFx0aWYodGhpcy5hY3RpdmVUaHJlYWQgIT09IGt0X2NoaWxkKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBjYWxsIHByZXB1c2ggaG9va3Ncblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfY2hhbmdlPy4oa3RfY2hpbGQsIGtwX3NyYywgJ3BvcCcpKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYoZmFsc2UgPT09IHRoaXMuX2dfaG9va3MuYmVmb3JlX3BvcD8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCwgZ2NfcG9wKSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0Ly8gYXBwcm92ZWRcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGJlZm9yZV9qdW1wKGdjX2p1bXA6IEp1bXBDb25maWcsIGdjX3BhZ2U6IFBhZ2VDb25maWcsIGtwX3NyYzogUGFnZSwga3RfY2hpbGQ6IFRocmVhZCk6IGJvb2xlYW4ge1xuXHRcdC8vIG5vdCBhY3RpdmUgdGhyZWFkOyBkZW55XG5cdFx0aWYodGhpcy5hY3RpdmVUaHJlYWQgIT09IGt0X2NoaWxkKSByZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBjYWxsIHByZWp1bXAgaG9va3Ncblx0XHRpZihmYWxzZSA9PT0gdGhpcy5fZ19ob29rcy5iZWZvcmVfY2hhbmdlPy4oa3RfY2hpbGQsIGtwX3NyYywgJ2p1bXAnKSkgcmV0dXJuIGZhbHNlO1xuXHRcdGlmKGZhbHNlID09PSB0aGlzLl9nX2hvb2tzLmJlZm9yZV9qdW1wPy4oa3RfY2hpbGQsIGtwX3NyYywgZ2NfcGFnZSwgZ2NfanVtcCkpIHJldHVybiBmYWxzZTtcblxuXHRcdC8vIGFwcHJvdmVkXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRhc3luYyBiZWZvcmVfc3dpdGNoKGt0X3NyYzogVGhyZWFkLCBzaV90aHJlYWQ6IFRocmVhZElkKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0aWYoZmFsc2UgPT09IHRoaXMuX2dfaG9va3MuYmVmb3JlX2NoYW5nZT8uKGt0X3NyYywga3Rfc3JjLnBhZ2UsICdzd2l0Y2gnKSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3RvcCB0aHJlYWQgc3dpdGNoJyk7XG5cblx0XHRhd2FpdCB0aGlzLl9nX2hvb2tzLmJlZm9yZV9zd2l0Y2g/LihrdF9zcmMsIHNpX3RocmVhZCk7XG5cdH1cblxuXHRhc3luYyBhZnRlcl9wdXNoKGt0X2NoaWxkOiBUaHJlYWQsIGtwX3NyYzogUGFnZSwga3BfZHN0OiBQYWdlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Y29uc3QgaF9leHRyYSA9IGF3YWl0IHRoaXMuX2dfaG9va3MuYWZ0ZXJfcHVzaD8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCk7XG5cblx0XHRhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX2NoYW5nZT8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCwgJ3B1c2gnLCBoX2V4dHJhIHx8IHt9KTtcblx0fVxuXG5cdGFzeW5jIGFmdGVyX3BvcChrdF9jaGlsZDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGtwX2RzdDogUGFnZSwgZ2NfcG9wOiBQb3BDb25maWcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRjb25zdCBoX2V4dHJhID0gYXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9wb3A/LihrdF9jaGlsZCwga3Bfc3JjLCBrcF9kc3QsIGdjX3BvcCk7XG5cblx0XHRhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX2NoYW5nZT8uKGt0X2NoaWxkLCBrcF9zcmMsIGtwX2RzdCwgJ3BvcCcsIGhfZXh0cmEgfHwge30pO1xuXHR9XG5cblx0YXN5bmMgYWZ0ZXJfanVtcChrdF9jaGlsZDogVGhyZWFkLCBrcF9zcmM6IFBhZ2UsIGtwX2RzdDogUGFnZSwgZ2NfanVtcDogSnVtcENvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGhfZXh0cmEgPSBhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX2p1bXA/LihrdF9jaGlsZCwga3Bfc3JjLCBrcF9kc3QsIGdjX2p1bXApO1xuXG5cdFx0YXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9jaGFuZ2U/LihrdF9jaGlsZCwga3Bfc3JjLCBrcF9kc3QsICdqdW1wJywgaF9leHRyYSB8fCB7fSk7XG5cdH1cblxuXHRhc3luYyBhZnRlcl9yZXNldChrdF9jaGlsZDogVGhyZWFkLCBrcF9kc3Q6IFBhZ2UsIGdjX3Jlc2V0OiBSZXNldENvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdGNvbnN0IGhfZXh0cmEgPSBhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX3Jlc2V0Py4oa3RfY2hpbGQsIGtwX2RzdCwgZ2NfcmVzZXQpO1xuXG5cdFx0YXdhaXQgdGhpcy5fZ19ob29rcy5hZnRlcl9jaGFuZ2U/LihrdF9jaGlsZCwgbnVsbCwga3BfZHN0LCAncmVzZXQnLCBoX2V4dHJhIHx8IHt9KTtcblx0fVxuXG5cdGFzeW5jIGFmdGVyX3N3aXRjaChrdF9zcmM6IFRocmVhZCwga3RfZHN0OiBUaHJlYWQpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRhd2FpdCB0aGlzLl9nX2hvb2tzLmFmdGVyX3N3aXRjaD8uKGt0X3NyYywga3RfZHN0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBY3RpdmF0ZXMgYSB0aHJlYWQgYnkgdGhlIGdpdmVuIHRocmVhZCBpZC5cblx0ICovXG5cdGFzeW5jIGFjdGl2YXRlVGhyZWFkKHNpX3RocmVhZDogVGhyZWFkSWQsIGhfcHJvcHM6IFBsYWluT2JqZWN0PXt9KTogUHJvbWlzZTxib29sZWFuPiB7XG5cdFx0Ly8gcmVmIGN1cnJlbnQgdGhyZWFkXG5cdFx0Y29uc3Qga3Rfc3JjID0gdGhpcy5hY3RpdmVUaHJlYWQ7XG5cblx0XHQvLyByZWYgcHJldmlvdXMgcGFnZVxuXHRcdGNvbnN0IGtwX3NyYyA9IHRoaXMuYWN0aXZlUGFnZTtcblxuXHRcdC8vIGxvb2t1cCBleGlzdGluZyB0aHJlYWRcblx0XHRsZXQga3RfZHN0ID0gdGhpcy5faF90aHJlYWRzW3NpX3RocmVhZF07XG5cblx0XHQvLyB0aHJlYWQgY2hhbmdlXG5cdFx0aWYoc2lfdGhyZWFkICE9PSB0aGlzLl9zaV90aHJlYWQpIHtcblx0XHRcdC8vIC8vIHNpbmdsZSB0aHJlYWQgbW9kZTsgYWJvcnRcblx0XHRcdC8vIGlmKHRoaXMuX2JfbW9kZV9zaW5nbGVfdGhyZWFkKSB7XG5cdFx0XHQvLyBcdHRocm93IG5ldyBFcnJvcihgTmF2aWdhdG9yIG9wZXJhdGluZyBpbiBzaW5nbGUgdGhyZWFkIG1vZGUgcmVmdXNpbmcgdG8gYWN0aXZhdGUgdGhlYWQgJyR7c2lfdGhyZWFkfScuYCk7XG5cdFx0XHQvLyB9XG5cblx0XHRcdC8vIGNhbGwgcHJlc3dpdGNoIGhvb2tzXG5cdFx0XHRhd2FpdCB0aGlzLmJlZm9yZV9zd2l0Y2goa3Rfc3JjLCBzaV90aHJlYWQpO1xuXG5cdFx0XHQvLyBwcmV2IHRocmVhZFxuXHRcdFx0Y29uc3Qgc2lfdGhyZWFkX3ByZXYgPSB0aGlzLl9zaV90aHJlYWQ7XG5cblx0XHRcdC8vIG5vIGV4aXN0aW5nIHRocmVhZDsgY3JlYXRlIG5ldyBvbmVcblx0XHRcdGlmKCFrdF9kc3QpIHtcblx0XHRcdFx0a3RfZHN0ID0gdGhpcy5fbmV3X3RocmVhZChzaV90aHJlYWQsIGhfcHJvcHMpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcHJvcHMgZGlmZmVyXG5cdFx0XHRlbHNlIGlmKG9iamVjdHNfbWlnaHRfZGlmZmVyKGt0X2RzdC5kZWZhdWx0LnByb3BzIHx8IHt9LCBoX3Byb3BzKSkge1xuXHRcdFx0XHQvLyBjcmVhdGUgbmV3IHBhZ2Vcblx0XHRcdFx0Y29uc3Qga3BfZHN0ID0gbmV3IFBhZ2Uoe1xuXHRcdFx0XHRcdC4uLmt0X2RzdC5kZWZhdWx0LFxuXHRcdFx0XHRcdHByb3BzOiBoX3Byb3BzLFxuXHRcdFx0XHRcdGNvbnRleHQ6IHRoaXMuX2hfY29udGV4dCxcblx0XHRcdFx0fSwga3RfZHN0KTtcblxuXHRcdFx0XHQvLyByZXNldCB0aHJlYWQgaGlzdG9yeVxuXHRcdFx0XHRrdF9kc3QucmVzZXQoa3BfZHN0LCB7XG5cdFx0XHRcdFx0a2VlcFRvcDogdHJ1ZSxcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gcGxhY2UgaW5jb21pbmcgc3RhdGUgYmVsb3dcblx0XHRcdFx0c2V0X3ppbmRleF9yZWxhdGl2ZWx5KGtwX3NyYy5kb20sIGtwX2RzdC5kb20sIC0xKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdXBkYXRlIHRocmVhZFxuXHRcdFx0dGhpcy5fc2lfdGhyZWFkID0gc2lfdGhyZWFkO1xuXG5cdFx0XHQvLyBwbGFjZSB0aHJlYWQgaW4gZnJvbnRcblx0XHRcdHRoaXMuYWN0aXZlVGhyZWFkLnNob3coKTtcblx0XHRcdHRoaXMuYWN0aXZlVGhyZWFkLmRvbS5zdHlsZS56SW5kZXggPSAodGhpcy5fY190aHJlYWRfeisrKSsnJztcblxuXHRcdFx0Ly8gLy8gYXJyaXZlXG5cdFx0XHQvLyB0aGlzLl9hcnJpdmUoa3Bfc3JjLCBzaV90aHJlYWRfcHJldiwgJ3RocmVhZCcpLnRoZW4oKCkgPT4ge1xuXHRcdFx0Ly8gXHQvLyAvLyBoaWRlIHByZXZpb3VzIHRocmVhZFxuXHRcdFx0Ly8gXHQvLyBpZihrdF9kc3QgJiYga3Rfc3JjICYmIGt0X3NyYyAhPT0ga3RfZHN0KSB7XG5cdFx0XHQvLyBcdC8vIFx0Ly8gZGVidWdnZXI7XG5cdFx0XHQvLyBcdC8vIFx0Ly8ga3Rfc3JjLmhpZGUoKTtcblx0XHRcdC8vIFx0Ly8gfVxuXHRcdFx0Ly8gfSk7XG5cblx0XHRcdC8vIGNhbGwgcG9zdHN3aXRjaCBob29rc1xuXHRcdFx0YXdhaXQgdGhpcy5hZnRlcl9zd2l0Y2goa3Rfc3JjLCBrdF9kc3QpO1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0Ly8gLy8gc2FtZSB0aHJlYWRcblx0XHQvLyBlbHNlIHtcblx0XHQvLyBcdC8vIHRocmVhZCBkZWZhdWx0IGlzIHByZXZpb3VzIGluIGhpc3Rvcnlcblx0XHQvLyBcdGRlYnVnZ2VyO1xuXHRcdC8vIFx0Y29uc29sZS5pbmZvKGtfdGhyZWFkPy5kZWZhdWx0LnBhdGgpO1xuXHRcdC8vIH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuIiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHtcblx0XHRnZXRBbGxDb250ZXh0cyxcblx0XHRvbk1vdW50LFxuXHRcdHRpY2ssXG5cdH0gZnJvbSAnc3ZlbHRlJztcblxuXHRpbXBvcnQgdHlwZSB7IFBsYWluT2JqZWN0IH0gZnJvbSAnIy9tZXRhL2JlbHQnO1xuXHRpbXBvcnQge1xuXHRcdG9kZSxcblx0XHRvZGVyb20sXG5cdFx0dGltZW91dCxcblx0fSBmcm9tICcjL3V0aWwvYmVsdCc7XG5cblx0aW1wb3J0IE92ZXJzY3JvbGxTdmVsdGUgZnJvbSAnLi9zeXN0ZW0vT3ZlcnNjcm9sbC5zdmVsdGUnO1xuXHRpbXBvcnQgUG9wdXBTdmVsdGUgZnJvbSAnLi9zeXN0ZW0vUG9wdXAuc3ZlbHRlJztcblx0aW1wb3J0IE5hdlN2ZWx0ZSBmcm9tICcuL3N5c3RlbS9OYXYuc3ZlbHRlJztcblx0aW1wb3J0IFNlYXJjaFN2ZWx0ZSBmcm9tICcuL3N5c3RlbS9TZWFyY2guc3ZlbHRlJztcblx0aW1wb3J0IFByb2dyZXNzU3ZlbHRlIGZyb20gJy4vc3lzdGVtL1Byb2dyZXNzLnN2ZWx0ZSc7XG5cdGltcG9ydCBTaWRlTWVudVN2ZWx0ZSBmcm9tICcuL3N5c3RlbS9TaWRlTWVudS5zdmVsdGUnO1xuXHRpbXBvcnQgVmVuZG9yTWVudVN2ZWx0ZSBmcm9tICcuL3N5c3RlbS9WZW5kb3JNZW51LnN2ZWx0ZSc7XG5cblx0aW1wb3J0IEJsYW5rU3ZlbHRlIGZyb20gJyMjL3NjcmVlbi9CbGFuay5zdmVsdGUnO1xuXG5cdGltcG9ydCB0eXBlIHsgUGFnZSwgUGFnZUNvbmZpZyB9IGZyb20gJyMjL25hdi9wYWdlJztcblx0aW1wb3J0IHR5cGUgeyBQb3BDb25maWcsIFRocmVhZCB9IGZyb20gJyMjL25hdi90aHJlYWQnO1xuXHRpbXBvcnQgeyBOYXZpZ2F0b3IsIE5hdmlnYXRvckNvbmZpZyB9IGZyb20gJyMjL25hdi9uYXZpZ2F0b3InO1xuXG5cdGltcG9ydCB7IEhfVEhSRUFEUyB9IGZyb20gJyMjL2RlZic7XG5cdGltcG9ydCB7IHl3X2FjY291bnQsIHl3X2FjY291bnRfcmVmLCB5d19jaGFpbiwgeXdfY2hhaW5fcmVmLCB5d19uYXZpZ2F0b3IsIHl3X25hdl92aXNpYmxlLCB5d19uZXR3b3JrLCB5d19uZXR3b3JrX2FjdGl2ZSwgeXdfbmV0d29ya19yZWYsIHl3X3BhZ2UsIHl3X3RocmVhZCB9IGZyb20gJyMjL21lbSc7XG5cdGltcG9ydCB7IENoYWlucyB9IGZyb20gJyMvc3RvcmUvY2hhaW5zJztcblx0aW1wb3J0IHsgQWNjb3VudHMgfSBmcm9tICcjL3N0b3JlL2FjY291bnRzJztcblx0aW1wb3J0IHsgb25jZV9zdG9yZV91cGRhdGVzIH0gZnJvbSAnLi4vc3ZlbHRlJztcblx0aW1wb3J0IHsgTmV0d29ya3MgfSBmcm9tICcjL3N0b3JlL25ldHdvcmtzJztcblx0aW1wb3J0IHsgVmF1bHQgfSBmcm9tICcjL2NyeXB0by92YXVsdCc7XG5cblx0ZXhwb3J0IGxldCBwYWdlOiBQYWdlQ29uZmlnO1xuXHRjb25zdCBnY19wYWdlID0gcGFnZTtcblxuXHRleHBvcnQgbGV0IG1vZGU6ICdhcHAnIHwgJ2Zsb3cnO1xuXHRjb25zdCBiX2Zsb3cgPSAnZmxvdycgPT09IG1vZGU7XG5cdGNvbnN0IGJfbWFpbiA9ICdhcHAnID09PSBtb2RlO1xuXG5cdGxldCBkbV92aWV3cG9ydDogSFRNTEVsZW1lbnQ7XG5cdGxldCBkbV90aHJlYWRzOiBIVE1MRWxlbWVudDtcblx0bGV0IGRtX2NvbnRlbnQ6IEhUTUxFbGVtZW50O1xuXHRsZXQgZG1fZXhpdHRpbmc6IEhUTUxFbGVtZW50O1xuXG5cdC8vIGdldCBhbGwgY29udGV4dHNcblx0Y29uc3QgaF9jb250ZXh0X2FsbCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRBbGxDb250ZXh0cygpLmVudHJpZXMoKSk7XG5cblx0YXN5bmMgZnVuY3Rpb24gc2xpZGUoZG1fc2xpZGU6IEhUTUxFbGVtZW50LCBiX2luPWZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0Ly8gc21vb3RoZXIsIGFsbG93IGZvciBwcmV2aW91cyBtb2RzIHRvIG1ha2UgZWxlbWVudCB2aXNpYmxlXG5cdFx0YXdhaXQgdGltZW91dCgwKTtcblxuXHRcdC8vIGdvIGFzeW5jXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChma19yZXNvbHZlKSA9PiB7XG5cdFx0XHQvLyB3YWl0IGZvciB0cmFuc2l0aW9uIHRvIGNvbXBsZXRlXG5cdFx0XHRkbV9zbGlkZS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gdHJhbnNpdGlvbl9lbmQoZF9ldmVudCkge1xuXHRcdFx0XHRpZigndHJhbnNmb3JtJyA9PT0gZF9ldmVudC5wcm9wZXJ0eU5hbWUpIHtcblx0XHRcdFx0XHQvLyBjaGFuZ2UgY2xhc3Ncblx0XHRcdFx0XHRkbV9zbGlkZS5jbGFzc0xpc3QuYWRkKCdzbGlkJyk7XG5cblx0XHRcdFx0XHRma19yZXNvbHZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBhcHBseSB0cmFuc2Zvcm1cblx0XHRcdGRtX3NsaWRlLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7Yl9pbj8gJzBweCc6ICd2YXIoLS1hcHAtd2luZG93LXdpZHRoKSd9KWA7XG5cdFx0fSk7XG5cdH1cblxuXHRvbk1vdW50KGFzeW5jKCkgPT4ge1xuXHRcdC8vIG5hdmlnYXRvciBjb25maWdcblx0XHRjb25zdCBnY19uYXZpZ2F0b3I6IE5hdmlnYXRvckNvbmZpZyA9IHtcblx0XHRcdC8vIHRocmVhZHMgY29udGFpbmVyXG5cdFx0XHRjb250YWluZXI6IGRtX3RocmVhZHMsXG5cblx0XHRcdC8vIGZvcndhcmQgYWxsIGNvbnRleHRzXG5cdFx0XHRjb250ZXh0OiBoX2NvbnRleHRfYWxsLFxuXG5cdFx0XHQvLyBkZWZhdWx0IHRocmVhZHMgY29uZmlnXG5cdFx0XHR0aHJlYWRzOiB7XG5cdFx0XHRcdGRlZmF1bHQ6ICgpID0+ICh7XG5cdFx0XHRcdFx0Y3JlYXRvcjogQmxhbmtTdmVsdGUsXG5cdFx0XHRcdH0pLFxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gZGVmYXVsdCBob29rc1xuXHRcdFx0aG9va3M6IHtcblx0XHRcdFx0YmVmb3JlX2NoYW5nZShrdF9jb250ZXh0LCBrcF9zcmMsIGtwX2RzdCkge1xuXHRcdFx0XHRcdC8vIGJsdXIgb24gcGFnZVxuXHRcdFx0XHRcdHZvaWQga3Bfc3JjLmZpcmUoJ2JsdXInKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBvbmNlIGEgbmV3IHBhZ2UgaGFzIGJlZW4gcHVzaGVkXG5cdFx0XHRcdGFmdGVyX3B1c2goa3RfY29udGV4dCwga3Bfc3JjLCBrcF9kc3QpIHtcblx0XHRcdFx0XHQvLyAvLyBwdXNoIHN0YXRlIHRvIG5hdmlnYXRvciBoaXN0b3J5XG5cdFx0XHRcdFx0Ly8gaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgJycsICcjcGFnZTonK2twX2RzdC5pZCk7XG5cblx0XHRcdFx0XHQvLyB3YWl0IGZvciBzdmVsdGUgdG8gcmVuZGVyIGNvbXBvbmVudCBiZWZvcmUgcXVlcnlpbmcgY29udGFpbmVyXG5cdFx0XHRcdFx0dm9pZCB0aWNrKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0XHQvLyBxdWVyeSBjb250YWluZXIgZm9yIGxhc3QgZWxlbWVudCBjaGlsZFxuXHRcdFx0XHRcdFx0dm9pZCBzbGlkZShrcF9kc3QuZG9tLCB0cnVlKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBvbmNlIGEgcGFnZSBoYXMgYmVlbiBwb3BwZWRcblx0XHRcdFx0YWZ0ZXJfcG9wKGt0X2NvbnRleHQsIGtwX3NyYywga3BfZHN0LCBnY19wb3ApIHtcblx0XHRcdFx0XHQvLyBub3RpZnkgZHN0IHBhZ2Vcblx0XHRcdFx0XHR2b2lkIGtwX2RzdC5maXJlKCdyZXN0b3JlJyk7XG5cblx0XHRcdFx0XHQvLyBkbyBub3QgYnlwYXNzIGFuaW1hdGlvblxuXHRcdFx0XHRcdGlmKCFnY19wb3AuYnlwYXNzQW5pbWF0aW9uKSB7XG5cdFx0XHRcdFx0XHQvLyBhcHBseSB0cmFuc2xhdGlvbiB0cmFuc2Zvcm0gdG8gc3JjIHBhZ2Vcblx0XHRcdFx0XHRcdGtwX3NyYy5kb20uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgodmFyKC0tYXBwLXdpbmRvdy13aWR0aCkpYDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gdXBvbiBhbnkgcGFnZSBjaGFuZ2Vcblx0XHRcdFx0YWZ0ZXJfY2hhbmdlKGt0X2NvbnRleHQsIGtwX3NyYywga3BfZHN0LCBzX3RyYW5zaXRpb24sIGhfZXh0cmE9e30pIHtcblx0XHRcdFx0XHQvLyBzZXQgZ2xvYmFsIHBhZ2UgYW5kIHRocmVhZFxuXHRcdFx0XHRcdCR5d19wYWdlID0ga3BfZHN0O1xuXHRcdFx0XHRcdCR5d190aHJlYWQgPSBrdF9jb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gbm90aWZ5IGRzdCBwYWdlXG5cdFx0XHRcdFx0dm9pZCBrcF9kc3QuZmlyZSgnZm9jdXMnKTtcblxuXHRcdFx0XHRcdC8vIC8vIG1haW50YWluIHNjcm9sbFRvcCBvZiB0aGUgc3JjIHBhZ2Vcblx0XHRcdFx0XHQvLyBjb25zdCB4X3Njcm9sbF90b3AgPSBrcF9zcmMuZG9tLnNjcm9sbFRvcDtcblxuXHRcdFx0XHRcdC8vIGRlYnVnZ2VyO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGFzeW5jIGJlZm9yZV9zd2l0Y2goKSB7XG5cdFx0XHRcdFx0Ly8gYWxsb3cgdGhlc2UgdG8gZmFpbCBpbiBvcmRlciB0byByZWNvdmVyIGZyb20gZGlzYXN0ZXJzXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdC8vIHNldCBkZWZhdWx0c1xuXHRcdFx0XHRcdFx0YXdhaXQgUHJvbWlzZS5hbGwoW1xuXHRcdFx0XHRcdFx0XHQvLyBkZWZhdWx0IGNoYWluXG5cdFx0XHRcdFx0XHRcdCR5d19jaGFpbiB8fCBvbmNlX3N0b3JlX3VwZGF0ZXMoeXdfY2hhaW4sIHRydWUpLFxuXHRcdFx0XHRcdFx0XHRDaGFpbnMucmVhZCgpLnRoZW4oa3MgPT4gJHl3X2NoYWluX3JlZiA9IG9kZShrcy5yYXcpWzBdWzBdKSxcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZhdWx0IG5ldHdvcmtcblx0XHRcdFx0XHRcdFx0JHl3X25ldHdvcmtfYWN0aXZlIHx8IG9uY2Vfc3RvcmVfdXBkYXRlcyh5d19uZXR3b3JrX2FjdGl2ZSwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdE5ldHdvcmtzLnJlYWQoKS50aGVuKGtzID0+ICR5d19uZXR3b3JrX3JlZiA9IG9kZShrcy5yYXcpWzBdWzBdKSxcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZhdWx0IGFjY291bnRcblx0XHRcdFx0XHRcdFx0JHl3X2FjY291bnQgfHwgb25jZV9zdG9yZV91cGRhdGVzKHl3X2FjY291bnQsIHRydWUpLFxuXHRcdFx0XHRcdFx0XHRBY2NvdW50cy5yZWFkKCkudGhlbihrcyA9PiAkeXdfYWNjb3VudF9yZWYgPSBvZGUoa3MucmF3KVswXVswXSksXG5cdFx0XHRcdFx0XHRdKTtcblxuXHRcdFx0XHRcdFx0Ly8gb25seSBuZWVkcyB0byBoYXBwZW4gb25jZVxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRoaXMuYmVmb3JlX3N3aXRjaDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2goZV9sb2FkX2RlZmF1bHQpIHtcblx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGVfbG9hZF9kZWZhdWx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0YXN5bmMgYWZ0ZXJfc3dpdGNoKGt0X3NyYywga3RfZHN0KSB7XG5cdFx0XHRcdFx0Ly8gc2V0IGdsb2JhbCBwYWdlIGFuZCB0aHJlYWRcblx0XHRcdFx0XHQkeXdfcGFnZSA9IGt0X2RzdC5wYWdlO1xuXHRcdFx0XHRcdCR5d190aHJlYWQgPSBrdF9kc3Q7XG5cblx0XHRcdFx0XHQvLyBmb2N1cyBvbiBwYWdlXG5cdFx0XHRcdFx0dm9pZCBrdF9kc3QucGFnZS5maXJlKCdmb2N1cycpO1xuXG5cdFx0XHRcdFx0Ly8gd2FpdCBmb3Igc3ZlbHRlIHRvIHJlbmRlciBjb21wb25lbnQgYmVmb3JlIHF1ZXJ5aW5nIGNvbnRhaW5lclxuXHRcdFx0XHRcdGF3YWl0IHRpY2soKTtcblxuXHRcdFx0XHRcdC8vIHF1ZXJ5IGNvbnRhaW5lciBmb3IgbGFzdCBlbGVtZW50IGNoaWxkXG5cdFx0XHRcdFx0YXdhaXQgc2xpZGUoa3RfZHN0LnBhZ2UuZG9tLCB0cnVlKTtcblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cdFx0fTtcblxuXHRcdC8vIHNwZWNpZmljIHBhZ2UgZ2l2ZW5cblx0XHRpZihiX2Zsb3cpIHtcblx0XHRcdC8vIG92ZXJyaWRlIHRocmVhZHMgY29uZmlnXG5cdFx0XHRnY19uYXZpZ2F0b3IudGhyZWFkcyA9IHtcblx0XHRcdFx0ZGVmYXVsdDogKCkgPT4gZ2NfcGFnZSxcblx0XHRcdH07XG5cdFx0fVxuXHRcdC8vIG1haW4gc3lzdGVtXG5cdFx0ZWxzZSBpZihiX21haW4pIHtcblx0XHRcdC8vIG92ZXJyaWRlIHRocmVhZHMgY29uZmlnXG5cdFx0XHRnY19uYXZpZ2F0b3IudGhyZWFkcyA9IG9kZXJvbShIX1RIUkVBRFMsIChzaV90aHJlYWQsIGRjX3NjcmVlbikgPT4ge1xuXHRcdFx0XHQvLyAvLyBsb29rdXAgcm91dGVyIG5vZGUgY29ycmVzcG9uZGluZyB0byBzY3JlZW4gY2xhc3Ncblx0XHRcdFx0Ly8gY29uc3Qga19ub2RlID0gS19ST1VURVIubG9va3VwX3NjcmVlbihkY19zY3JlZW4pO1xuXG5cdFx0XHRcdC8vIC8vIHJlZiBwYXRoIHBhdHRlcm5cblx0XHRcdFx0Ly8gY29uc3Qgc3hfcGF0dGVybiA9IGtfbm9kZS5wYXRoX3BhdHRlcm47XG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRbc2lfdGhyZWFkXTogKGhfcHJvcHM6IFBsYWluT2JqZWN0KSA9PiAoe1xuXHRcdFx0XHRcdFx0Y3JlYXRvcjogZGNfc2NyZWVuLFxuXHRcdFx0XHRcdFx0cHJvcHM6IGhfcHJvcHMsXG5cdFx0XHRcdFx0XHQvLyBwYXRoOiBrX25vZGUucmV2ZXJzZV9yZXNvbHZlKGhfcHJvcHMpLFxuXHRcdFx0XHRcdFx0Ly8gcGF0dGVybjogc3hfcGF0dGVybixcblx0XHRcdFx0XHRcdC8vIHNjcmVlbjogZGNfc2NyZWVuLFxuXHRcdFx0XHRcdH0pLFxuXHRcdFx0XHR9IGFzIFJlY29yZDx0eXBlb2Ygc2lfdGhyZWFkLCAoaF9wcm9wczogUGxhaW5PYmplY3QpID0+IFBhZ2VDb25maWc+O1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIHNldCBpbml0XG5cdFx0XHRnY19uYXZpZ2F0b3IudGhyZWFkcy5pbml0ID0gKGhfcHJvcHM6IFBsYWluT2JqZWN0LCBoX2NvbnRleHQ/OiBQbGFpbk9iamVjdCkgPT4gKHtcblx0XHRcdFx0Li4uZ2NfcGFnZSxcblx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHQuLi5nY19wYWdlLnByb3BzLFxuXHRcdFx0XHRcdC4uLmhfcHJvcHMsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbnRleHQ6IHtcblx0XHRcdFx0XHQuLi5nY19wYWdlLmNvbnRleHQsXG5cdFx0XHRcdFx0Li4uaF9jb250ZXh0LFxuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Y29uc3Qga19uYXZpZ2F0b3IgPSBuZXcgTmF2aWdhdG9yKGdjX25hdmlnYXRvcik7XG5cdFx0JHl3X25hdmlnYXRvciA9IGtfbmF2aWdhdG9yO1xuXG5cblxuXHRcdC8vIGhhbmRsZSBwb3Agc3RhdGVcblx0XHQvLyB3aW5kb3cub25wb3BzdGF0ZSA9IGZ1bmN0aW9uKGRfZXZlbnQ6IFBvcFN0YXRlRXZlbnQpIHtcblx0XHQvLyBcdGtfbmF2aWdhdG9yLmFjdGl2ZVBhZ2UucG9wKHtcblx0XHQvLyBcdFx0ZXh0ZXJuYWw6IHRydWUsXG5cdFx0Ly8gXHR9KTtcblx0XHQvLyB9O1xuXG5cdFx0Ly8gJHl3X2V4aXR0aW5nX2RvbSA9IGRtX2V4aXR0aW5nO1xuXG5cdFx0Ly8gY29uc3Qga19zdGF0ZV9yb290ID0gbmV3IFN0YXRlKCcvbG9ja2VkJywgbnVsbCBhcyB1bmtub3duIGFzIFN2ZWx0ZUNvbXBvbmVudCwgJy9sb2NrZWQnKTtcblx0XHQvLyBjb25zdCBrX3RocmVhZF9yb290ID0gbmV3IFN0YXRlVGhyZWFkKGtfc3RhdGVfcm9vdCk7XG5cblx0Ly8gXHRpbml0aWFsaXplKG5ldyBTdGF0ZU1hbmFnZXIoe1xuXHQvLyBcdFx0cm91dGVyOiBLX1JPVVRFUixcblxuXHQvLyBcdFx0YXJyaXZlKHRoaXM6IFN0YXRlTWFuYWdlciwga3Nfc3JjOiBTdGF0ZSwga3NfZHN0OiBTdGF0ZSwgc2lfdGhyZWFkX3NyYzogc3RyaW5nLCBzX3RyYW5zaXRpb249JycpOiBQcm9taXNlPHZvaWQ+IHtcblx0Ly8gXHRcdFx0Ly8gbWFpbnRhaW4gc2Nyb2xsVG9wXG5cdC8vIFx0XHRcdGNvbnN0IHhfc2Nyb2xsX3RvcCA9IGtzX3NyYy5kb20uc2Nyb2xsVG9wO1xuXG5cdC8vIFx0XHRcdGNvbnNvbGUubG9nKHtcblx0Ly8gXHRcdFx0XHR0eXBlOiAnYXJyaXZlJyxcblx0Ly8gXHRcdFx0XHRrc19zcmMsXG5cdC8vIFx0XHRcdFx0a3NfZHN0LFxuXHQvLyBcdFx0XHRcdHNpX3RocmVhZF9zcmMsXG5cdC8vIFx0XHRcdFx0c190cmFuc2l0aW9uLFxuXHQvLyBcdFx0XHR9KTtcblxuXHQvLyBcdFx0XHQvLyBuZXcgTXV0YXRpb25PYnNlcnZlcigobSkgPT4ge1xuXHQvLyBcdFx0XHQvLyBcdGRlYnVnZ2VyO1xuXHQvLyBcdFx0XHQvLyB9KS5vYnNlcnZlKGtzX3NyYy5kb20sIHtcblx0Ly8gXHRcdFx0Ly8gXHRhdHRyaWJ1dGVzOiB0cnVlLFxuXHQvLyBcdFx0XHQvLyBcdGNoaWxkTGlzdDogdHJ1ZSxcblx0Ly8gXHRcdFx0Ly8gfSk7XG5cblx0Ly8gXHRcdFx0Ly8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGtzX3NyYy5kb20sICdzY3JvbGxUb3AnLCB7XG5cdC8vIFx0XHRcdC8vIFx0Z2V0KCkge1xuXHQvLyBcdFx0XHQvLyBcdFx0cmV0dXJuIHhfc2Nyb2xsX3RvcDtcblx0Ly8gXHRcdFx0Ly8gXHR9LFxuXHQvLyBcdFx0XHQvLyBcdHNldCh4X3RvOiBudW1iZXIpIHtcblx0Ly8gXHRcdFx0Ly8gXHRcdGNvbnNvbGUubG9nKGBTRVQgVE86ICR7eF90b31gKTtcblx0Ly8gXHRcdFx0Ly8gXHRcdGRlYnVnZ2VyO1xuXHQvLyBcdFx0XHQvLyBcdH0sXG5cdC8vIFx0XHRcdC8vIH0pO1xuXG5cdC8vIFx0XHRcdC8vIG5ldXRlciBzcmMgZnJhbWVcblx0Ly8gXHRcdFx0a3Nfc3JjLmRvbS5jbGFzc0xpc3QuYWRkKCdmcm96ZW4nKTtcblxuXHQvLyBcdFx0XHQvLyBlbnN1cmUgaW5jb21pbmcgZnJhbWUgaXMgbm90IGZyb3plblxuXHQvLyBcdFx0XHRrc19kc3QuZG9tLmNsYXNzTGlzdC5yZW1vdmUoJ2Zyb3plbicpO1xuXG5cdC8vIFx0XHRcdGNvbnN0IGdjX3BhcmFtcyA9IHl3X3BhcmFtcy5nZXQoKTtcblx0Ly8gXHRcdFx0Ly8gY29uc3QgZ2NfcGFyYW1zID0ge307XG5cblx0Ly8gXHRcdFx0JHl3X3BhdGggPSBrc19kc3QucGF0aDtcblx0Ly8gXHRcdFx0JHl3X3BhdHRlcm4gPSBrc19kc3QucGF0dGVybjtcblxuXHQvLyBcdFx0XHRjb25zdCBnY19wcm9wcyA9IGtzX2RzdC5wcm9wcztcblxuXHQvLyBcdFx0XHQkeXdfcGFyYW1zID0ge1xuXHQvLyBcdFx0XHRcdGZhbWlseUlkOiBnY19wcm9wcy5mYW1pbHlJZCBhcyBzdHJpbmcgfHwgZ2NfcGFyYW1zLmZhbWlseUlkLFxuXHQvLyBcdFx0XHRcdGNoYWluSWQ6IGdjX3Byb3BzLmNoYWluSWQgYXMgc3RyaW5nIHx8IGdjX3BhcmFtcy5jaGFpbklkLFxuXHQvLyBcdFx0XHRcdGFjY291bnRJZDogZ2NfcHJvcHMuYWNjb3VudElkIGFzIHN0cmluZyB8fCBnY19wYXJhbXMuYWNjb3VudElkLFxuXHQvLyBcdFx0XHR9O1xuXG5cdC8vIFx0XHRcdGlmKGdjX3Byb3BzLmZhbWlseUlkKSB7XG5cdC8vIFx0XHRcdFx0Y29uc3QgcF9mYW1pbHkgPSBGYW1pbHkucmVmRnJvbUlkKGdjX3Byb3BzLmZhbWlseUlkIGFzIHN0cmluZyk7XG5cdC8vIFx0XHRcdFx0aWYoIUhfRkFNSUxJRVNbcF9mYW1pbHldKSBkZWJ1Z2dlcjtcblx0Ly8gXHRcdFx0XHQkeXdfZmFtaWx5ID0gSF9GQU1JTElFU1twX2ZhbWlseV07XG5cdC8vIFx0XHRcdH1cblxuXHQvLyBcdFx0XHQvLyBpZihnY19wcm9wcy5jaGFpbklkKSB7XG5cdC8vIFx0XHRcdC8vIFx0aWYoISR5d19mYW1pbHkpIGRlYnVnZ2VyO1xuXHQvLyBcdFx0XHQvLyBcdGNvbnN0IHBfY2hhaW4gPSBDaGFpbi5yZWZGcm9tRmFtaWx5SWQoJHl3X2ZhbWlseS5kZWYuaXJpLCBnY19wcm9wcy5jaGFpbklkIGFzIHN0cmluZyk7XG5cdC8vIFx0XHRcdC8vIFx0JHl3X2NoYWluID0gSF9DSEFJTlNbcF9jaGFpbl0gfHwgbnVsbDtcblx0Ly8gXHRcdFx0Ly8gfVxuXG5cdC8vIFx0XHRcdC8vIGlmKGdjX3Byb3BzLmFjY291bnRJZCkge1xuXHQvLyBcdFx0XHQvLyBcdGNvbnNvbGUud2FybihgPCR7JHl3X3BhdGh9PiBwcm9wcyBzZXQgYWNjb3VudElkID0gJHtnY19wcm9wcy5hY2NvdW50SWR9YCk7XG5cdC8vIFx0XHRcdC8vIFx0JHl3X2FjY291bnQgPSBIX0FDQ09VTlRTW0FjY291bnQucmVmRnJvbUlkKGdjX3Byb3BzLmFjY291bnRJZCBhcyBzdHJpbmcpXTtcblx0Ly8gXHRcdFx0Ly8gfVxuXG5cdC8vIFx0XHRcdCR5d19zY3JlZW5fZG9tID0ga3NfZHN0LmRvbTtcblxuXHQvLyBcdFx0XHQvLyB0cmlnZ2VyIGNvbXBvbmVudCBzZXR0aW5nc1xuXHQvLyBcdFx0XHRjb25zdCBma19hcnJpdmUgPSBobV9hcnJpdmFscy5nZXQoa3NfZHN0LmRvbSk7XG5cdC8vIFx0XHRcdGlmKGZrX2Fycml2ZSkgZmtfYXJyaXZlKCk7XG5cblx0Ly8gXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5cdC8vIFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShhc3luYyhma19yZXNvbHZlKSA9PiB7XG5cdC8vIFx0XHRcdFx0Ly8gcmVmIHNyYyBzdGF0ZSdzIGRvbVxuXHQvLyBcdFx0XHRcdGxldCBkbV9zcmMgPSBrc19zcmMuZG9tO1xuXG5cdC8vIFx0XHRcdFx0Ly8gcmVmIGNsYXNzbGlzdFxuXHQvLyBcdFx0XHRcdGNvbnN0IGRfY2xhc3NfbGlzdCA9IGRtX3NyYy5jbGFzc0xpc3Q7XG5cblx0Ly8gXHRcdFx0XHQvLyBzaG9ydCBjaXJjdWl0IGV4cGVuc2l2ZSBjb21wdXRlZCBzdHlsZSBjYWxsXG5cdC8vIFx0XHRcdFx0bGV0IGJfdHJhbnNpdGlvbnMgPSBmYWxzZTtcblx0Ly8gXHRcdFx0XHRpZignZ290bycgPT09IHNfdHJhbnNpdGlvbikge1xuXHQvLyBcdFx0XHRcdFx0aWYoZF9jbGFzc19saXN0LmNvbnRhaW5zKCdzbGlkZXMnKSkge1xuXHQvLyBcdFx0XHRcdFx0XHQvLyBjaGFuZ2luZyB0aHJlYWRzXG5cdC8vIFx0XHRcdFx0XHRcdGlmKHNpX3RocmVhZF9zcmMpIHtcblx0Ly8gXHRcdFx0XHRcdFx0XHRkbV9zcmMgPSBkbV9zcmMuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50O1xuXHQvLyBcdFx0XHRcdFx0XHRcdGRtX2V4aXR0aW5nLnJlcGxhY2VDaGlsZHJlbihkbV9zcmMpO1xuXHQvLyBcdFx0XHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHRcdFx0ZG1fc3JjLnN0eWxlLnpJbmRleCA9ICcxMDAxJztcblxuXHQvLyBcdFx0XHRcdFx0XHRhd2FpdCB0aW1lb3V0KDApO1xuXG5cdC8vIFx0XHRcdFx0XHRcdC8vIGRtX3NyYy5zdHlsZS5sZWZ0ID0gYC0ke1hQX0FQUF9XSURUSH1weGA7XG5cdC8vIFx0XHRcdFx0XHRcdGRtX3NyYy5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKC0ke1hQX0FQUF9XSURUSH1weClgO1xuXHQvLyBcdFx0XHRcdFx0XHRiX3RyYW5zaXRpb25zID0gdHJ1ZTtcblx0Ly8gXHRcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHRcdGVsc2Uge1xuXHQvLyBcdFx0XHRcdFx0XHRjb25zdCBzaV9leGl0ID0gZG1fc3JjLmdldEF0dHJpYnV0ZSgnZGF0YS1zMi1leGl0JykgYXMgc3RyaW5nO1xuXG5cdC8vIFx0XHRcdFx0XHRcdHN3aXRjaChzaV9leGl0KSB7XG5cdC8vIFx0XHRcdFx0XHRcdFx0Y2FzZSAnc3dpcGVzJzoge1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0ZG1fc3JjLnN0eWxlLmxlZnQgPSBgLSR7WFBfQVBQX1dJRFRIfXB4YDtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGRtX3NyYy5zdHlsZS56SW5kZXggPSAnMTAwMSc7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRiX3RyYW5zaXRpb25zID0gdHJ1ZTtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHQvLyBcdFx0XHRcdFx0XHRcdH1cblxuXHQvLyBcdFx0XHRcdFx0XHRcdGNhc2UgJ2xlYXZlcyc6IHtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdC8vIGNoYW5naW5nIHRocmVhZHNcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGlmKHNpX3RocmVhZF9zcmMpIHtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdFx0ZG1fc3JjID0gZG1fc3JjLmNsb25lTm9kZSh0cnVlKSBhcyBIVE1MRWxlbWVudDtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdFx0ZG1fZXhpdHRpbmcucmVwbGFjZUNoaWxkcmVuKGRtX3NyYyk7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGRtX3NyYy5zdHlsZS56SW5kZXggPSAnMTAwMSc7XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHRpbWVvdXQoMCk7XG5cblx0Ly8gXHRcdFx0XHRcdFx0XHRcdC8vIGRtX3NyYy5zdHlsZS5sZWZ0ID0gYC0ke1hQX0FQUF9XSURUSH1weGA7XG5cdC8vIFx0XHRcdFx0XHRcdFx0XHRkbV9zcmMuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgtJHtYUF9BUFBfV0lEVEh9cHgpYDtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGJfdHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdC8vIFx0XHRcdFx0XHRcdFx0fVxuXG5cdC8vIFx0XHRcdFx0XHRcdFx0Y2FzZSAncmV2ZWFscyc6IHtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGRtX3NyYy5jbGFzc0xpc3QuYWRkKCdyZXZlYWwnKTtcblx0Ly8gXHRcdFx0XHRcdFx0XHRcdGJfdHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdC8vIFx0XHRcdFx0XHRcdFx0fVxuXG5cdC8vIFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDoge1xuXHQvLyBcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGF0dHJpYnV0ZSB2YWx1ZTogXCIke3NpX2V4aXQgPz8gJyd9XCJgKTtcblx0Ly8gXHRcdFx0XHRcdFx0XHR9XG5cdC8vIFx0XHRcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHQvLyBub3QgY2hhbmdpbmcgdGhyZWFkc1xuXHQvLyBcdFx0XHRcdGlmKCFzaV90aHJlYWRfc3JjKSB7XG5cdC8vIFx0XHRcdFx0XHQvLyAvLyBzcmMgbGVhdmVzXG5cdC8vIFx0XHRcdFx0XHQvLyBpZihkX2NsYXNzX2xpc3QuY29udGFpbnMoJ2xlYXZlcycpKSB7XG5cdC8vIFx0XHRcdFx0XHQvLyBcdGRtX3NyYy5zdHlsZS5sZWZ0ID0gYC0ke1hQX0FQUF9XSURUSH1weGA7XG5cdC8vIFx0XHRcdFx0XHQvLyBcdGRtX3NyYy5zdHlsZS56SW5kZXggPSAnMTAwMSc7XG5cdC8vIFx0XHRcdFx0XHQvLyBcdGJfdHJhbnNpdGlvbnMgPSB0cnVlO1xuXHQvLyBcdFx0XHRcdFx0Ly8gfVxuXG5cdC8vIFx0XHRcdFx0XHQvLyBzcmMgc2xpZGVzIG91dFxuXHQvLyBcdFx0XHRcdFx0aWYoZF9jbGFzc19saXN0LmNvbnRhaW5zKCdzbGlkZXMnKSkge1xuXHQvLyBcdFx0XHRcdFx0XHRiX3RyYW5zaXRpb25zID0gdHJ1ZTtcblx0Ly8gXHRcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHR9XG5cdC8vIFx0XHRcdFx0Ly8gY2hhbmdpbmcgdGhyZWFkc1xuXHQvLyBcdFx0XHRcdGVsc2Uge1xuXHQvLyBcdFx0XHRcdFx0Ly8gZ29pbmcgdG8gc2VhcmNoXG5cdC8vIFx0XHRcdFx0XHRpZignL3NlYXJjaCcgPT09IGtzX2RzdC5wYXR0ZXJuKSB7XG5cdC8vIFx0XHRcdFx0XHRcdGRtX3NyYy5jbGFzc0xpc3QuYWRkKCdzdWJsaW1hdGUnKTtcblx0Ly8gXHRcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHRcdC8vIGxlYXZpbmcgc2VhcmNoXG5cdC8vIFx0XHRcdFx0XHRlbHNlIGlmKCcvc2VhcmNoJyA9PT0ga3Nfc3JjLnBhdHRlcm4pIHtcblx0Ly8gXHRcdFx0XHRcdFx0a3NfZHN0LmRvbS5jbGFzc0xpc3QucmVtb3ZlKCdzdWJsaW1hdGUnKTtcblx0Ly8gXHRcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHQvLyBcblx0Ly8gXHRcdFx0XHRhd2FpdCBtaWNyb3Rhc2soKTtcblxuXHQvLyBcdFx0XHRcdC8vIGVsZW1lbnQgaXMgdHJhbnNpdGlvbmluZ1xuXHQvLyBcdFx0XHRcdGlmKCFzX3RyYW5zaXRpb24uZW5kc1dpdGgoJy5ieXBhc3MnKSkge1xuXHQvLyBcdFx0XHRcdFx0aWYoYl90cmFuc2l0aW9ucyB8fCBTWF9OT19UUkFOU0lUSU9OICE9PSBnZXRDb21wdXRlZFN0eWxlKGRtX3NyYykudHJhbnNpdGlvbikge1xuXHQvLyBcdFx0XHRcdFx0XHQvLyB3YWl0IGZvciB0cmFuc2l0aW9uIHRvIGVuZFxuXHQvLyBcdFx0XHRcdFx0XHRkbV9zcmMuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIHRyYW5zaXRpb25fZW5kKGRfZXZlbnQpIHtcblx0Ly8gXHRcdFx0XHRcdFx0XHQvLyBub3QgYSBwb3NpdGlvbiBwcm9wZXJ0eVxuXHQvLyBcdFx0XHRcdFx0XHRcdGlmKCd0cmFuc2Zvcm0nICE9PSBkX2V2ZW50LnByb3BlcnR5TmFtZSkgcmV0dXJuO1xuXG5cdC8vIFx0XHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIHNlbGZcblx0Ly8gXHRcdFx0XHRcdFx0XHRkbV9zcmMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRyYW5zaXRpb25fZW5kKTtcblxuXHQvLyBcdFx0XHRcdFx0XHRcdC8vIHJlc29sdmVcblx0Ly8gXHRcdFx0XHRcdFx0XHRma19yZXNvbHZlKCk7XG5cdC8vIFx0XHRcdFx0XHRcdH0pO1xuXG5cdC8vIFx0XHRcdFx0XHRcdC8vIHdhaXQgZm9yIGNhbGxiYWNrXG5cdC8vIFx0XHRcdFx0XHRcdHJldHVybjtcblx0Ly8gXHRcdFx0XHRcdH1cblx0Ly8gXHRcdFx0XHR9XG5cblx0Ly8gXHRcdFx0XHRma19yZXNvbHZlKCk7XG5cdC8vIFx0XHRcdH0pO1xuXHQvLyBcdFx0fSxcblx0Ly8gXHR9KSk7XG5cdH0pO1xuXHRcbjwvc2NyaXB0PlxuXG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdC5mdWxsKEB0eXBlKSB7XG5cdFx0cG9zaXRpb246IEB0eXBlO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcblx0fVxuXG5cdC5mdWxsKGFic29sdXRlKSB7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdH1cblxuXHQudmlld3BvcnQge1xuXHRcdC5mdWxsKHJlbGF0aXZlKTtcblx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXG5cdFx0Y29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLXRleHQtbGlnaHQpO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXRoZW1lLWNvbG9yLWJnKTtcblxuXHRcdD4uY29udGVudCB7XG5cdFx0XHQuZnVsbChyZWxhdGl2ZSk7XG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xuXG5cdFx0XHR3aWR0aDogMTAwJTtcblx0XHRcdGhlaWdodDogMTAwJTtcblxuXHRcdFx0Ji5leGl0dGluZyB7XG5cdFx0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHRcdFx0dG9wOiAwO1xuXHRcdFx0XHR6LWluZGV4OiAxMDAxO1xuXHRcdFx0XHR1c2VyLXNlbGVjdDogbm9uZTtcblx0XHRcdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XG5cdFx0XHR9XG5cblx0XHRcdD4udGhyZWFkIHtcblx0XHRcdFx0Omdsb2JhbCgmKSB7XG5cdFx0XHRcdFx0LmZ1bGwoYWJzb2x1dGUpO1xuXHRcdFx0XHRcdHBhZGRpbmctbGVmdDogY2FsYyg1MHZ3IC0gKHZhcigtLWFwcC1tYXgtd2lkdGgpIC8gMikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gOmdsb2JhbCgmPnNlY3Rpb24pIHtcblx0XHRcdC8vIFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdFx0Ly8gXHR0b3A6IDBweDtcblx0XHRcdC8vIFx0dHJhbnNpdGlvbjogbGVmdCAwLjZzIHZhcigtLWVhc2Utb3V0LXF1aWNrKTtcblx0XHRcdC8vIH1cblx0XHR9XG5cdH1cbjwvc3R5bGU+XG5cbjxtYWluIGNsYXNzPVwidmlld3BvcnRcIiBiaW5kOnRoaXM9e2RtX3ZpZXdwb3J0fT5cblx0PGRpdiBjbGFzcz1cImNvbnRlbnQgdGhyZWFkc1wiIGJpbmQ6dGhpcz17ZG1fdGhyZWFkc30gLz5cblx0PGRpdiBjbGFzcz1cImNvbnRlbnQgZXhpdHRpbmdcIiBiaW5kOnRoaXM9e2RtX2V4aXR0aW5nfSAvPlxuXHQ8c2xvdD48L3Nsb3Q+XG5cblx0PFByb2dyZXNzU3ZlbHRlIC8+XG5cdFxuXHR7I2lmIGJfbWFpbn1cblx0XHR7I2F3YWl0IFZhdWx0LmdldFJvb3RLZXkoKSB0aGVuIGRrX3Jvb3R9XG5cdFx0XHR7I2lmIGRrX3Jvb3R9XG5cdFx0XHRcdDxPdmVyc2Nyb2xsU3ZlbHRlIC8+XG5cdFx0XHRcdDxOYXZTdmVsdGUgLz5cblx0XHRcdFx0PFNlYXJjaFN2ZWx0ZSAvPlxuXHRcdFx0XHQ8VmVuZG9yTWVudVN2ZWx0ZSAvPlxuXHRcdFx0XHQ8U2lkZU1lbnVTdmVsdGUgLz5cblx0XHRcdFx0PFBvcHVwU3ZlbHRlIC8+XG5cdFx0XHR7L2lmfVxuXHRcdHsvYXdhaXR9XG5cdHsvaWZ9XG48L21haW4+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcblxuXHRpbXBvcnQgTG9nLCB7IExvZ2dlciB9IGZyb20gJyMvYXBwL3VpL0xvZy5zdmVsdGUnO1xuXG5cdGltcG9ydCB7IFZhdWx0IH0gZnJvbSAnIy9jcnlwdG8vdmF1bHQnO1xuXHRpbXBvcnQgdHlwZSB7IENvbXBsZXRlZCB9IGZyb20gJyMvZW50cnkvZmxvdyc7XG5cblx0aW1wb3J0IHtcblx0XHRBVFU4X0RVTU1ZX1BIUkFTRSxcblx0XHRBVFU4X0RVTU1ZX1ZFQ1RPUixcblx0XHRsb2dpbixcblx0XHRDb3JydXB0ZWRWYXVsdEVycm9yLFxuXHRcdEludmFsaWRQYXNzcGhyYXNlRXJyb3IsXG5cdFx0UmVjb3ZlcmFibGVWYXVsdEVycm9yLFxuXHRcdFVucmVnaXN0ZXJlZEVycm9yLFxuXHR9IGZyb20gJyMvc2hhcmUvYXV0aCc7XG5cblx0aW1wb3J0IHsgU2NyZWVuLCB0eXBlIFBhZ2UgfSBmcm9tICcuL19zY3JlZW5zJztcblx0aW1wb3J0IEFjdGlvbnNMaW5lIGZyb20gJyMvYXBwL3VpL0FjdGlvbnNMaW5lLnN2ZWx0ZSc7XG5cdGltcG9ydCBGaWVsZCBmcm9tICcjL2FwcC91aS9GaWVsZC5zdmVsdGUnO1xuXHRpbXBvcnQgeyBzbGlkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblxuXHQvLyB3aWxsIGJlIHNldCBpZiBwYXJ0IG9mIGZsb3dcblx0Y29uc3QgY29tcGxldGVkID0gZ2V0Q29udGV4dDxDb21wbGV0ZWQgfCB1bmRlZmluZWQ+KCdjb21wbGV0ZWQnKTtcblxuXHQvLyBwYXNzd29yZCB2YWx1ZSBiaW5kaW5nXG5cdGxldCBzaF9wYXNzd29yZCA9ICcnO1xuXG5cdC8vIHBhc3N3b3JkIGVycm9yXG5cdGxldCBzX2Vycl9wYXNzd29yZCA9ICcnO1xuXG5cdC8vIGJ1c3kgYXR0ZW1wdGluZyB1bmxvY2tcblx0bGV0IGJfYnVzeSA9IGZhbHNlO1xuXG5cblx0bGV0IHh0X3N0YXJ0ID0gMDtcblx0bGV0IGtfbG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXHRmdW5jdGlvbiBsb2coc19tc2c6IHN0cmluZykge1xuXHRcdGtfbG9nZ2VyID0ga19sb2dnZXIuZXZlbnQoc19tc2csIERhdGUubm93KCkgLSB4dF9zdGFydCk7XG5cdH1cblxuXHRhc3luYyBmdW5jdGlvbiBhdHRlbXB0X3VubG9jayhiX3JlY292ZXI9ZmFsc2UpOiBQcm9taXNlPDE+IHtcblx0XHQvLyBkbyBub3QgaW50ZXJ1cHQ7IGxvY2tcblx0XHRpZihiX2J1c3kpIHJldHVybiAxOyBiX2J1c3kgPSB0cnVlO1xuXG5cdFx0Ly8gcHJlcCBncmFjZWZ1bCBleGl0XG5cdFx0Y29uc3QgZXhpdCA9ICgpOiAxID0+IChiX2J1c3kgPSBmYWxzZSwgMSk7XG5cblx0XHQvLyByZXNldCBlcnJvclxuXHRcdHNfZXJyX3Bhc3N3b3JkID0gJyc7XG5cblx0XHQvLyBzdGFydCB0aW1lclxuXHRcdHh0X3N0YXJ0ID0gRGF0ZS5ub3coKTtcblxuXHRcdGxvZygnRXN0aW1hdGluZyB0aW1lIHRvIGNvbXBsZXRlJyk7XG5cblx0XHQvLyBlc3RpbWF0ZSB0aW1lIHRvIGNvbXBsZXRlXG5cdFx0e1xuXHRcdFx0Y29uc3QgeHRfc3RhcnRfZXN0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0YXdhaXQgVmF1bHQuZGVyaXZlUm9vdEJpdHMoQVRVOF9EVU1NWV9QSFJBU0UsIEFUVThfRFVNTVlfVkVDVE9SLCAxIC8gNTApO1xuXHRcdFx0Y29uc3QgeHRfZmluaXNoX2VzdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdFx0Y29uc3QgeHRfZWxhcHNlZCA9IHh0X2ZpbmlzaF9lc3QgLSB4dF9zdGFydF9lc3Q7XG5cdFx0XHRjb25zdCB4dF9lc3RpbWF0ZSA9ICgyICogKHh0X2VsYXBzZWQgKiA1MCkpO1xuXHRcdFx0bG9nKGBBYm91dCAkeyh4dF9lc3RpbWF0ZSAvIDEwMDApLnRvRml4ZWQoMSl9IHNlY29uZHNgKTtcblx0XHR9XG5cblx0XHQvLyBhdHRlbXB0IGxvZ2luXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IGxvZ2luKHNoX3Bhc3N3b3JkLCBiX3JlY292ZXIsIGxvZyk7XG5cdFx0fVxuXHRcdC8vIGhhbmRsZSBlcnJvclxuXHRcdGNhdGNoKGVfbG9naW4pIHtcblx0XHRcdGlmKGVfbG9naW4gaW5zdGFuY2VvZiBVbnJlZ2lzdGVyZWRFcnJvcikge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9ICdObyBhY2NvdW50cyBkZXRlY3RlZCc7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGVfbG9naW4gaW5zdGFuY2VvZiBJbnZhbGlkUGFzc3BocmFzZUVycm9yKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gJ0ludmFsaWQgcGFzc3BocmFzZSc7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGVfbG9naW4gaW5zdGFuY2VvZiBSZWNvdmVyYWJsZVZhdWx0RXJyb3IpIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSAnVmF1bHQgaXMgcGFydGlhbGx5IGNvcnJ1cHRlZDsgYXR0ZW1wdGluZyByZWNvdmVyeS4uLic7XG5cdFx0XHRcdHJldHVybiBhd2FpdCBhdHRlbXB0X3VubG9jayh0cnVlKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoYl9yZWNvdmVyKSB7XG5cdFx0XHRcdHNfZXJyX3Bhc3N3b3JkID0gYFJlY292ZXJ5IGZhaWxlZC4gVmF1bHQgbWF5IGJlIGlycmVwYXJhYmx5IGNvcnJ1cHRlZC5cXG4ke2VfbG9naW4ubWVzc2FnZSF9YDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoZV9sb2dpbiBpbnN0YW5jZW9mIENvcnJ1cHRlZFZhdWx0RXJyb3IpIHtcblx0XHRcdFx0c19lcnJfcGFzc3dvcmQgPSBgVmF1bHQgYXBwZWFycyB0byBiZSBpcnJlcGFyYWJseSBjb3JydXB0ZWQuXFxuJHtlX2xvZ2luLm1lc3NhZ2V9YDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRzX2Vycl9wYXNzd29yZCA9IGBVbmtub3duIGVycm9yIG9jY3VycmVkOiAke2VfbG9naW4uc3RhY2sgfHwgZV9sb2dpbi5tZXNzYWdlfWA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGV4aXRcblx0XHRcdHJldHVybiBleGl0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gc3VjY2Vzc1xuXHRcdGlmKGNvbXBsZXRlZCkgY29tcGxldGVkKHRydWUpO1xuXG5cdFx0Ly8gZXhpdFxuXHRcdHJldHVybiBleGl0KCk7XG5cdH1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdC53ZWxjb21lIHtcblx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5cdFx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRcdGdhcDogMjBweDtcblx0XHRcdHBhZGRpbmctbGVmdDogMTZweDtcblx0XHRcdHBhZGRpbmctcmlnaHQ6IDE2cHg7XG5cdFx0XHRiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJy9tZWRpYS92ZW5kb3Ivb3JiLTEuc3ZnJyk7XG5cdFx0XHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuXHRcdFx0YmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIHRvcDtcblx0XHRcdGJhY2tncm91bmQtc2l6ZTogY292ZXI7XG5cdFx0XHRwYWRkaW5nLXRvcDogY2FsYyg1MHZoIC0gMjAwcHgpO1xuXHRcdH1cblxuXHRcdD5kaXYge1xuXHRcdFx0Ji5sb2dvLCYudGl0bGUge1xuXHRcdFx0XHQ6Z2xvYmFsKCYpIHtcblx0XHRcdFx0XHRtYXJnaW4tbGVmdDogYXV0byAhaW1wb3J0YW50O1xuXHRcdFx0XHRcdG1hcmdpbi1yaWdodDogYXV0byAhaW1wb3J0YW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblxuXHQubGFyZ2Uge1xuXHRcdC5mb250KGJpZyk7XG5cdH1cblxuXHRwIHtcblx0XHQuZm9udChyZWd1bGFyKTtcblx0XHRwYWRkaW5nOiA4cHggMDtcblx0fVxuXG5cdC5saW5lIHtcblx0XHR3aWR0aDogY2FsYygxMDAlIC0gNDBweCk7XG5cdFx0aGVpZ2h0OiAxcHg7XG5cdFx0YmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KDUwJSA1MCUgYXQgNTAlIDUwJSwgI0ZGQzcwMCAwJSwgcmdiYSgyNTUsIDE5OSwgMCwgMCkgMTAwJSk7XG5cdH1cblxuXHQuYWN0aW9ucy1saW5lIHtcblx0XHR3aWR0aDogMTAwJTtcblx0fVxuXG5cdC5vZmYtc2NyZWVuIHtcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XG5cdFx0dG9wOiBjYWxjKHZhcigtLWFwcC13aW5kb3ctd2lkdGgpICogMTAwKTtcblx0fVxuPC9zdHlsZT5cblxueyNpZiBmYWxzZX1cblx0PHNwYW5cblx0XHRjbGFzczp3ZWxjb21lPXt0cnVlfVxuXHQvPlxuey9pZn1cblxuPFNjcmVlbiBkZWJ1Zz0nQXV0aGVudGljYXRlJyBjbGFzc05hbWVzPSd3ZWxjb21lJz5cblx0PGRpdiBjbGFzcz1cImxvZ29cIj5cblx0XHQ8aW1nIHdpZHRoPVwiOTZcIiBzcmM9XCIvbWVkaWEvdmVuZG9yL2xvZ28tOTZweC5wbmdcIiBzcmNzZXQ9XCIvbWVkaWEvdmVuZG9yL2xvZ28tOTZweC5wbmcgMXgsIC9tZWRpYS92ZW5kb3IvbG9nby0xOTJweC5wbmcgMnhcIiBhbHQ9XCJTdGFyU2hlbGxcIiAvPlxuXHQ8L2Rpdj5cblxuXHQ8ZGl2IGNsYXNzPVwidGl0bGVcIj5cblx0XHQ8aW1nIHNyYz1cIi9tZWRpYS92ZW5kb3IvdGl0bGUuc3ZnXCIgYWx0PVwiXCIgLz5cblx0PC9kaXY+XG5cblx0PGRpdiBjbGFzcz1cImxpbmVcIj4mbmJzcDs8L2Rpdj5cblxuXHQ8ZGl2IGNsYXNzPVwiZm9ybSBmbGV4LXJvd3NcIj5cblx0XHQ8RmllbGQga2V5PVwicGFzc3dvcmRcIiBuYW1lPVwiXCI+XG5cdFx0XHQ8aW5wdXRcblx0XHRcdFx0dHlwZT1cInBhc3N3b3JkXCJcblx0XHRcdFx0bmFtZT1cInBhc3N3b3JkXCJcblx0XHRcdFx0cGxhY2Vob2xkZXI9XCJQYXNzd29yZFwiXG5cdFx0XHRcdGJpbmQ6dmFsdWU9e3NoX3Bhc3N3b3JkfVxuXHRcdFx0XHRjbGFzczppbnZhbGlkPXtzX2Vycl9wYXNzd29yZH1cblx0XHRcdC8+XG5cblx0XHRcdHsjaWYgc19lcnJfcGFzc3dvcmR9XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ2YWxpZGF0aW9uLW1lc3NhZ2VcIiB0cmFuc2l0aW9uOnNsaWRlPXt7ZHVyYXRpb246MzAwfX0+XG5cdFx0XHRcdFx0e3NfZXJyX3Bhc3N3b3JkfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvaWZ9XG5cdFx0PC9GaWVsZD5cblx0PC9kaXY+XG5cblx0PEFjdGlvbnNMaW5lIGNvbmZpcm09e1snVW5sb2NrJywgYXR0ZW1wdF91bmxvY2tdfSAvPlxuXG5cdDxMb2cgYmluZDppdGVtcz17a19sb2dnZXIuaXRlbXN9IGhpZGUgLz5cblxuPC9TY3JlZW4+XG4iLCJpbXBvcnQgeyBkZCwgcXMgfSBmcm9tICcjL3V0aWwvZG9tJztcblxuLy8gc2VsZWN0IGRvbSBsb2cgZWxlbWVudHNcbmV4cG9ydCBjb25zdCBkbV9sb2cgPSBxcyhkb2N1bWVudCwgJ3NlY3Rpb24jZG9tLWxvZycpO1xuZXhwb3J0IGNvbnN0IGRtX2xvZ19saXN0ID0gcXMoZG9jdW1lbnQsICcjZG9tLWxvZy1saXN0Jyk7XG5cbi8qKlxuICogTG9ncyBhIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUgYW5kIHRvIERPTSBhcyBhIGZhbGxiYWNrIGZvciB1bmhhbmRsZWQgZXJyb3JzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb21sb2coc2lfbXNnOiBzdHJpbmcpOiB2b2lkIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0Y29uc29sZS5sb2coc2lfbXNnKTtcblxuXHRkbV9sb2dfbGlzdD8uYXBwZW5kKGRkKCdsaScsIHt9LCBbXG5cdFx0ZGQoJ3ByZScsIHt9LCBbc2lfbXNnXSksXG5cdF0pKTtcbn1cbiIsIjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHQuaG9yaXpvbiB7XG5cdFx0d2lkdGg6IGNhbGMoMTAwJSAtIDQwcHgpO1xuXHRcdGhlaWdodDogMXB4O1xuXHRcdGJhY2tncm91bmQ6IHJhZGlhbC1ncmFkaWVudCg1MCUgNTAlIGF0IDUwJSA1MCUsICNGRkM3MDAgMCUsIHJnYmEoMjU1LCAxOTksIDAsIDApIDEwMCUpO1xuXG5cdFx0bWFyZ2luLWxlZnQ6IGF1dG87XG5cdFx0bWFyZ2luLXJpZ2h0OiBhdXRvO1xuXHR9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwibm8tbWFyZ2luIGhvcml6b25cIj57QGh0bWwgJyZuYnNwOyd9PC9kaXY+XG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBTY3JlZW4gfSBmcm9tICcuL19zY3JlZW5zJztcblxuXHRpbXBvcnQgQWN0aW9uc0xpbmUgZnJvbSAnLi4vdWkvQWN0aW9uc0xpbmUuc3ZlbHRlJztcblx0aW1wb3J0IFJlZ2lzdGVyIGZyb20gJy4vUmVnaXN0ZXIuc3ZlbHRlJztcblx0aW1wb3J0IFN0YXJTaGVsbExvZ28gZnJvbSAnLi4vdWkvU3RhclNoZWxsTG9nby5zdmVsdGUnO1xuXHRpbXBvcnQgU3RhclNoZWxsVGl0bGUgZnJvbSAnLi4vdWkvU3RhclNoZWxsVGl0bGUuc3ZlbHRlJztcblx0aW1wb3J0IEhvcml6b24gZnJvbSAnLi4vdWkvSG9yaXpvbi5zdmVsdGUnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBsYW5nPVwibGVzc1wiPlxuXHRAaW1wb3J0ICcuLi8uLi9zdHlsZS91dGlsLmxlc3MnO1xuXG5cdDpnbG9iYWwoLnByZXJlZ2lzdGVyKSB7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0Z2FwOiAyMHB4O1xuXHRcdHBhZGRpbmctbGVmdDogMTZweDtcblx0XHRwYWRkaW5nLXJpZ2h0OiAxNnB4O1xuXHRcdGJhY2tncm91bmQtaW1hZ2U6IHVybCgnL21lZGlhL3ZlbmRvci9vcmItMS5zdmcnKTtcblx0XHRiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xuXHRcdGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciB0b3A7XG5cdFx0YmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcblxuXHRcdHBhZGRpbmctdG9wOiBjYWxjKDUwdmggLSAxNTBweCk7XG5cdH1cbjwvc3R5bGU+XG5cbjxTY3JlZW4gcm9vdCBjbGFzc05hbWVzPSdwcmVyZWdpc3Rlcic+XG5cdDxTdGFyU2hlbGxMb2dvIGRpbT17OTZ9IC8+XG5cblx0PFN0YXJTaGVsbFRpdGxlIC8+XG5cblx0PEhvcml6b24gLz5cblxuXHQ8ZGl2IGNsYXNzPVwibGFyZ2VcIj5cblx0XHQ8ZGl2PldlbGNvbWUgdG8gdGhlIGJldGEgcHJvZ3JhbS48L2Rpdj5cblx0XHQ8ZGl2PlRoYW5rIGZvciB5b3UgYmVpbmcgYSB0ZXN0ZXIhPC9kaXY+XG5cdDwvZGl2PlxuXG5cdDxwPlxuXHRcdFxuXHQ8L3A+XG5cblx0PEFjdGlvbnNMaW5lIGNvbmZpcm09e1snR2V0IFN0YXJ0ZWQnXX0gY29udGQ9e3tjcmVhdG9yOlJlZ2lzdGVyfX0gLz5cbjwvU2NyZWVuPlxuIl0sIm5hbWVzIjpbImNyZWF0ZV9pZl9ibG9jayIsImN0eCIsImNyZWF0ZV9pZl9ibG9ja18zIiwiY3JlYXRlX2lmX2Jsb2NrXzQiLCJjcmVhdGVfaWZfYmxvY2tfNSIsImNyZWF0ZV9pZl9ibG9ja18yIiwiY3JlYXRlX2lmX2Jsb2NrXzEiLCJzZWFyY2giLCJjbGlja19oYW5kbGVyIiwicCIsIlJlZ2lzdGVyV2Vha1Bhc3N3b3JkU3ZlbHRlIiwicmVnaXN0ZXIiLCJnX3Rva2VuIiwiU1hfSUNPTl9QRVJTT05BTCIsInNpX3ZlcnN1cyIsImFwcGVuZF8xIiwiYXBwZW5kIiwiZnVuY18xIiwiVGhyZWFkSWQiLCJCbGFua1N2ZWx0ZSIsIlJlZ2lzdGVyU3ZlbHRlIiwiSG9sZGluZ3NIb21lU3ZlbHRlIiwiQ29udGFjdHNIb21lU3ZlbHRlIiwiSGlzdG9yeUhvbWVTdmVsdGUiLCJOZXR3b3Jrc0hvbWVTdmVsdGUiLCJBY2NvdW50SG9tZVN2ZWx0ZSIsIlNpdGVzSG9tZVN2ZWx0ZSIsImlkIiwib2JqIiwicGF0aCIsIm5vcm0iLCJ2YWx1ZSIsInRleHQiLCJzY29yZSIsInBhdHRlcm4iLCJyZXN1bHQiLCJpdGVtIiwic2VhcmNoZXJzIiwicXVlcnkiLCJDbGFzc1R5cGUiLCJzbGlkZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLE1BQU0sSUFBSSxTQUFTLFdBQVc7QUFDMUIsUUFBTSxVQUFVLFNBQVMsY0FBYyxNQUFNLEVBQUU7QUFDL0MsTUFBSSxXQUFXLFFBQVEsWUFBWSxRQUFRLFNBQVMsZUFBZSxHQUFHO0FBQ2xFO0FBQUEsRUFDSDtBQUNELGFBQVcsUUFBUSxTQUFTLGlCQUFpQiwyQkFBMkIsR0FBRztBQUN2RSxtQkFBZSxJQUFJO0FBQUEsRUFDdEI7QUFDRCxNQUFJLGlCQUFpQixDQUFDLGNBQWM7QUFDaEMsZUFBVyxZQUFZLFdBQVc7QUFDOUIsVUFBSSxTQUFTLFNBQVMsYUFBYTtBQUMvQjtBQUFBLE1BQ0g7QUFDRCxpQkFBVyxRQUFRLFNBQVMsWUFBWTtBQUNwQyxZQUFJLEtBQUssWUFBWSxVQUFVLEtBQUssUUFBUTtBQUN4Qyx5QkFBZSxJQUFJO0FBQUEsTUFDMUI7QUFBQSxJQUNKO0FBQUEsRUFDVCxDQUFLLEVBQUUsUUFBUSxVQUFVLEVBQUUsV0FBVyxNQUFNLFNBQVMsS0FBSSxDQUFFO0FBQ3ZELFdBQVMsYUFBYSxRQUFRO0FBQzFCLFVBQU0sWUFBWSxDQUFBO0FBQ2xCLFFBQUksT0FBTztBQUNQLGdCQUFVLFlBQVks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
